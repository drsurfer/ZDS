;
;=======================================================================
;
; DarkStar (NE Z80) Serial support library - UART 1
;
;=======================================================================
;;---------------------------------------------------------------------
;; Version      : 1.0 - 20170311
;; Assemble     : SLR z80asm, myzmac
;; Revisions:
;; 20170311	- Initial revision
;;---------------------------------------------------------------------

	title	zds_serial1.lib - Serial i/o to host computer
;
	public	srlout1,srlin1
	public attach_1_legacy, detach_1_legacy

; 	extern	cnfbyte

;;
;; Using this lib require inclusion of "darkstar.equ"
;;
;
;
xon		equ	11h
xoff		equ	13h
rst8op		equ	0008h
rst8adr		equ	0009h
op_ret		equ	0c9h
op_jp		equ	0c3h


;;
;; attach_1_legacy
;;
;; connect to uart1 via legacy RST8
;;
;;

attach_1_legacy:
	push	af
	push	hl
	di				; hold interrupts
	ld	a,op_jp			; jp opcode
	ld	(rst8op),a		; in rst8 base
	ld	hl,isr_s1		; and isr routine
	ld	(rst8adr),hl
	ld	hl,cnfbyte
	set	0,(hl)			; enable rst8 redirect
	ei				; re-enable interrupts
	pop	hl
	pop	af
	ret				; done

;;
;; detach_1_legacy
;;
;; disconnect uart1 from RST8 redirect
;;

detach_1_legacy:
	push	af
	push	hl
	di				; hold interrupts
	ld	a,op_ret		; ret opcode
	ld	(rst8op),a		; in rst8 base
	ld	hl,cnfbyte
	res	0,(hl)			; disable rst8 redirect
	ei				; re-enable interrupts
	pop	hl
	pop	af
	ret				; done

;;
;; Check for input (and get it)
;;
;; A contain input byte
;;

srlin1:
	ld	a,(ilen)		; buffer length
	or	a			; empty ?
	ret	z			; yes -> forget it
	call	getbyte
	scf				; success
	ret

;;
;; getbyte - extract char from queue
;;

getbyte:
	push	hl
	push	de
	ld	hl,(ibgp)
	ld	a,(hl)			; get next char.
	inc	hl
	ld	de,ibend
	call	cphlde			; buffer end ?
	jr	c,noiwrap		; no ->
	ld	hl,ibstrt		; yes, back to start
noiwrap:
	ld	(ibgp),hl
	ld	hl,ilen
	dec	(hl)
	push	af
	ld	a,(ilen)
; 	cp	imax-20
	cp	imax-32
	call	z,pson
	pop	af
	pop	de
	pop	hl
	ret

;;
;;  Output routine
;;  upon entry:	A contains the character to be output
;;

srlout1:
srlout:
	push	af
sot0:	ld	a,(opflg)		; test xon/xoff
	bit	0,a
	jr	nz,sot0			; idle if xoff
sot1:
	in	a,(uart1+r5lsr)		; read status
	bit	5,a			; ready to send?
	jp	z,sot1			; no, retry.

	pop	af
	out	(uart1+r0rxtx),a	; send it
	ret
;;
;;	Interrupt Service Routines
;;

;;
;; psoff: send xoff to host
;;
psoff:
; 	push	af
	ld	a,xoff
	call	srlout
; 	pop	af
	ret
;
;;
;; pson: send xon to host
;;
pson:	ld	a,xon
	jp	srlout

;;
;; isr_s1
;;
;; Called upon interrupt on uart1
;;

isr_s1:
	ld	(tstack),sp		; save status
	ld	sp,stack
	call	pushem
	call	psoff			; lock host

	ld	a,(ilen)		; buffer capacity ?
	ld	hl,opflg
 	cp	imax-16			; uart hw fifo is 16 bytes
; 	call	z,psoff
; 	cp	imax			; buffer full
	jr	z,iret			; wait for dequeue
;
isr_s10:
	in	a,(uart1+r5lsr)		; read status
	bit	0,a			; data available in rx buffer?
	jr	z,iret0			; no.
	in	a,(uart1+r0rxtx)	; read data

; 	ld	c,a
; 	call	bbconout

	cp	xoff
	call	z,idle
	cp	xon
	call	z,nidle

	ld	hl,(ibpp)
	ld	(hl),a
	inc	hl
	ld	de,ibend
	call	cphlde
	jr	c,norw
	ld	hl,ibstrt
norw:
	ld	(ibpp),hl
	ld	hl,ilen
	inc	(hl)
	jr	isr_s10			; repeat for more data in UART
iret0:
	call	pson
iret:
	call	popem
	ld	sp,(tstack)
dummy:	ret

idle:
	set	0,(hl)
	ret
;
nidle:
	res	0,(hl)
	ret
;
cphlde:
	push	hl		;compares hl & de
	or	a		;and sets flags.
	sbc	hl,de
	pop	hl
	ret
;
pushem:
	ex	(sp),hl		;save main regs on stack.
	push	de		;the hl pair is mod'd.
	push	bc
	push	af
	jp	(hl)
;
popem:
	pop	hl		;restore all main regs
	pop	af		;from stack after a
	pop	bc		;call to pushem.
	pop	de
	ex	(sp),hl
	ret
;

opflg	db	0
;
ilen	db	0		;input buffer length
ibgp	dw	ibstrt		;input buffer get pointer
ibpp	dw	ibstrt		;input buffer put pointer
ibstrt	equ	$		;input buffer start
ibuff	ds	0ffh		;input buffer
ibend	equ	$		;input buffer end
imax	equ	0ffh		;input buffer max length
;
tstack	ds	80h
stack	equ	$
;
	end
