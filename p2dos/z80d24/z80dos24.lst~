   1:			;
   2:			; Z80DOS - Z80 Disk Operating System
   3:			;
   4:			; Version 2.4	Maskable disk reset's using variable fixdrv
   5:			;		Now can assemble with Z80MR if Z80MR equate
   6:			;		set to -1.
   7:			;		Gene Nolan 4/9/89
   8:			;
   9:			;
  10:			;------------------------------------------------------
  11:			;
  12:			; Version 2.3	Fast directory lookup, ZRL compatible - 11/4/88 Gene Nolan
  13:			;
  14:			;------------------------------------------------------
  15:			;
  16:			; Version 2.0a - BETA TEST VERSION - 6 Nov 87 by Carson Wilson
  17:			;
  18:			; Main Module
  19:			;
  20:			
  21:			
  22:			; Remove the comments from the following 6 lines if making a ZRL form for NZCOM
  23:			;name	DOSZ82
  24:			;COM	/_ID_/
  25:			;	db	13,10,13,10
  26:			;	db	'You are now loading up the Z80DOS234.ZRL file'
  27:			;	db	13,10,13,10,0
  28:			;	maclib z34cmn
  29:			
  30:			; If you are using Z80MR, change the following to -1 and the -1 to 0
  31:			
  32:	FFFF          	Z80MR	EQU	-1		; We do it this way because of Z80MR
  33:							; ... and for zmac (Z80DarkStar)
  34:	0000          	NOZ80MR	EQU	0
  35:			
  36:	0000          		IF NOZ80MR
  46:				 ENDIF
  47:			
  48:	FFFF          		IF Z80MR
  49:			include z80dhdr.lib	; Operating system addresses, options,
**** z80dhdr.lib ****
   1:			;
   2:			; Z80DOS - Z80 Disk Operating System
   3:			;
   4:			; Version 2.4	Maskable disk reset's using variable fixdrv
   5:			;		Now can assemble with Z80MR if Z80MR equate
   6:			;		set to -1.
   7:			;		Gene Nolan 4/9/89
   8:			;
   9:			;--------------------------------------------------------------
  10:			;
  11:			; Z80DOS - Z80 Disk Operating System
  12:			;
  13:			; Version 2.3	Fast directory lookup, ZRL compatiblity
  14:			; Date:		4 Nov 88
  15:			; Update:	Eugene Nolan
  16:			;
  17:			;-------------------------------------------------------------
  18:			; Version 2.0a - BETA TEST VERSION - 6 Nov 87 by Carson Wilson
  19:			;
  20:			; Support file:	Z80DHDR.LIB
  21:			; Version:	2.0
  22:			; Date:		6 Nov 87
  23:			; Author:	Carson Wilson
  24:			; Changes:	Added RTC equate.  If false, use internal DOS routine
  25:			;		instead of BIOS call for get/set time.  Default address
  26:			;		for buffer is 50 hex.
  27:			;
  28:			; Description:	Options and Standard Equates
  29:			
  30:			; --------------------------------------------------------------------
  31:			
  32:			; Specify where in memory your BDOS begins and where your BIOS ends.
  33:			; The next two equates must be set for the particular system.
  34:			; You can use either kilobyte or page boundaries.
  35:			;
  36:			; The number for "MSize/MPages" is where your BIOS ENDS in memory.  For
  37:			; standard 64k CP/M systems this is 64 kilobytes/256 pages.
  38:			;
  39:			; The number for "base" is where your CCP BEGINS in memory.  This is
  40:			; computed using MSize and a value n which is the size in kilobytes/pages
  41:			; of your entire operating system (CCP+BDOS+BIOS).  You should be able
  42:			; to get these values from the source code of your BIOS.
  43:			;
  44:			; 1 page = 256 bytes, so 4 pages = 1 kilobyte.
  45:			;
  46:			
  47:			include ../common.asm
**** ../common.asm ****
   1:			;
   2:			; Here just some common symbol...
   3:			;
   4:			
   5:	0016          	VERS	EQU     22      	; VERSION 2.2 (CP/M related)
   6:			;
   7:			;MSIZE	EQU     60              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
   8:	0038          	MSIZE	EQU     56              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
   9:	0300          	RESROOM	EQU	768		; RESERVED ROOM SPACE BELOW MONITOR (F000)
  10:				;
  11:				;       "BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
  12:				;       THAN 16K (REFERRED TO AS"B" THROUGHOUT THE TEXT)
  13:				;
  14:	8D00          	BIAS	EQU     ((MSIZE-20)*1024)-RESROOM
  15:	C100          	CCP	EQU     3400H+BIAS      ; BASE OF CCP
  16:	C906          	BDOS	EQU     CCP+806H        ; BASE OF BDOS
  17:	C900          	BDOSB	EQU	CCP+$0800	; BDOS base offset
  18:	D700          	BIOS	EQU     CCP+1600H       ; BASE OF BIOS
  19:				;
  20:				; 	some other equs...
  21:				;
  22:	000D          	CR	EQU     0DH		; CARRIAGE RETURN
  23:	000A          	LF	EQU     0AH		; LINE FEED;
  24:	FFFF          	TRUE	EQU	-1		; ....
  25:	0000          	FALSE	EQU	0
  26:	0000          	INTRON	EQU	FALSE		; Interrupts disabled
**** z80dhdr.lib ****
  48:			
  49:			; Specify addresses using kilobyte boundaries:
  50:			
  51:			; NOTE: Definition of BASE not used if creating a .ZRL file
  52:			
  53:			;MSize	equ	64			; Standard 64k system size
  54:			; base	equ	(MSIZE-(BIOSIZ/1024))*1024	; (MSize-n) where n is size of
  55:								; BIOS+DOS+CCP in kilobytes
  56:			;base	equ	0d400h			; N varies with the length of
  57:								; ..your BIOS.
  58:	C100          	base	EQU	CCP
  59:			;base	EQU	$E400
  60:			; Or, specify addresses using page boundaries:
  61:			
  62:			;MPages equ	256			; 256 page system size
  63:			;base	equ	(MPages-37)*256 	; (mpages-n) where n is size in
  64:								; ..pages of BIOS+DOS+CCP
  65:								; N varies with the length of
  66:								; ..your BIOS.
  67:			
  68:			; Standard addresses and equates - don't change the next five equates:
  69:			
  70:	0000          	RamLow	equ	0000h			; Start address memory
  71:			
  72:			;****** Comment out the following 2 lines if making a .ZRL file
  73:	C900          	DOS	equ	base+800h		; Start address DOS
  74:			;BIOS	equ	DOS+00e00h		; Start address BIOS
  75:			
  76:			
  77:	0000          	false	equ	0
  78:	FFFF          	true	equ	-1
  79:			
  80:			; RTC - Real Time Clock
  81:			;
  82:			; 	Set to true if you are using a Real Time Clock as the
  83:			; source for your time, and fill in the address at BIOStim below.
  84:			;
  85:			;	Set to false to use a 5 byte buffer in protected memory
  86:			; as a substitute for a Real Time Clock, and give the address of
  87:			; the 5 byte buffer at label TimeBuf below.
  88:			;
  89:			; NOTE: If making a ZRL and RTC is TRUE, it may be necessary to
  90:			;	POKE the RTC JMP into NZCOM's psuedo BIOS BEFORE loading the
  91:			;	Z80DOS.ZRL file.
  92:			
  93:	FFFF          	RTC	equ	true		;Real time clock
  94:			
  95:	FFFF          		 if	RTC
  96:							; IF USING Z80MR, then put NO SPACES
  97:							; on the following line between
  98:							; BIOS, the '+', and the address!!!!
  99:	D721          	BIOStim	equ	BIOS+33		; Address of BIOS jump or RTC driver
 100:			
 101:				 else
 103:				 endif	; RTC
 104:			
 105:			
 106:			; ResDsk - You can optionally define an alternate disk for disk reset.
 107:			;	   This is useful in floppy systems with a virtual drive feature.
 108:			;	   By defining a non-virtual drive (drive B in Morrow MD3) as the
 109:			;	   reset disk, you avoid having to switch back to disk A every time a
 110:			;	   disk reset is performed.  However, this requires that you always
 111:			;	   have a diskette in drive B:.
 112:			;
 113:			
 114:	0000          	ResDsk	equ	0	; CP/M default is disk A for resets
 115:						; ..0=A, 1=B, 2=C, etc.
 116:			
 117:			
 118:			; Options -	Bit 0: public file enable(1)/disable(0)
 119:			;		Bit 1: delay 256 characters active(1)/disable(0)
 120:			;
 121:	0001          	Options	equ	00000001B		; Enable public file and delay
 122:			
 123:			
 124:			; -------------------------------------------------------------
 125:			;
 126:			; The remaining equates should stay the same for all systems:
 127:			;
 128:			; -------------------------------------------------------------
 129:			
 130:			; Standard BIOS function offsets:
 131:			
 132:	D700          	Boot	equ	BIOS+00000h		; BIOS cold boot
 133:	D703          	WBoot	equ	BIOS+00003h		; BIOS warm boot
 134:	D706          	ConSt	equ	BIOS+00006h		; BIOS console status
 135:	D709          	ConIn	equ	BIOS+00009h		; BIOS console input
 136:	D70C          	ConOut	equ	BIOS+0000ch		; BIOS console output
 137:	D70F          	dlist	equ	BIOS+0000fh		; BIOS list output
 138:	D712          	punch	equ	BIOS+00012h		; BIOS punch output
 139:	D715          	reader	equ	BIOS+00015h		; BIOS reader input
 140:	D718          	home	equ	BIOS+00018h		; BIOS home disk
 141:	D71B          	SelDsk	equ	BIOS+0001bh		; BIOS select disk
 142:	D71E          	SetTrk	equ	BIOS+0001eh		; BIOS select track
 143:	D721          	SetSec	equ	BIOS+00021h		; BIOS select sector
 144:	D724          	SetDMA	equ	BIOS+00024h		; BIOS set DMA address
 145:	D727          	dread	equ	BIOS+00027h		; BIOS read 128 bytes
 146:	D72A          	write	equ	BIOS+0002ah		; BIOS write 128 bytes
 147:	D72D          	ListSt	equ	BIOS+0002dh		; BIOS list status
 148:	D730          	SecTrn	equ	BIOS+00030h		; BIOS sector translation
 149:			;Time	equ	BIOS+00033h		; BIOS TIME call
 150:	D736          	BOTDSK	equ	BIOS+00036h		; BIOS boot drive id
 151:			
 152:			; Internal definitions:
 153:			
 154:	0003          	ContC	equ	003h			; Key to generate warm boot
 155:	0008          	ContH	equ	008h			; Backspace
 156:	0013          	ContS	equ	013h			; Control-S
 157:	0009          	tab	equ	009h			; Tab
 158:	000A          	lf	equ	00ah			; Line feed
 159:	000D          	cr	equ	00dh			; Carriage return
 160:	0010          	ContP	equ	010h			; Set/reset print flag
 161:	0018          	ContX	equ	018h			; Delete line (backspaces)
 162:	003A          	DrvSep	equ	03ah			; Drive seperator (:)
 163:	007F          	rubout	equ	07fh			; Delete last char
 164:			;
 165:	0028          	MaxCmd	equ	40			; Number of valid DOS commands
 166:			
 167:			; END Z80DHDR.LIB
 168:			
**** z80dos24.z80 ****
  50:						; ..and equates
  51:			
  52:			include z80dchar.z80	; Jump table, character I/O routines,error routines
**** z80dchar.z80 ****
   1:			;
   2:			; Z80DOS - Z80 Disk Operating System
   3:			;
   4:			; Version 2.4	Maskable disk reset's using variable fixdrv
   5:			;		Now can assemble with Z80MR if Z80MR equate
   6:			;		set to -1.
   7:			;		Gene Nolan 4/9/89
   8:			;
   9:			;------------------------------------------------------
  10:			;
  11:			; Version 2.3	Fast file lookup, ZRL compatability
  12:			; Date:		4 Nov 88
  13:			; Update:	Eugene Nolan
  14:			;
  15:			;------------------------------------------------------------
  16:			;
  17:			; Version 2.0a - BETA TEST VERSION - 6 Nov 87 by Carson Wilson
  18:			;
  19:			; Support file:	Z80DCHAR.Z80
  20:			; Version:	2.0
  21:			; Date:		6 Nov 87
  22:			; Author:	Carson Wilson
  23:			; Changes:	Combined BIOS read and write error messages into one
  24:			;		message - "Data error" so that BDOS error intecepts
  25:			;		work same as standard CP/M.
  26:			;
  27:			;		Added disk changed error routine.
  28:			;
  29:			; Description:	DOS Entry Points, Character I/O, and Error Routines
  30:			;
  31:			; Use ONE only of the following lines:
  32:			;---------------------------------------------
  33:			; Use following line for assembly to .COM file, comment it out for a .ZRL
  34:	C900          		org	DOS
  35:			
  36:	C900  5A383044		db	'Z80D24'
	      3234
  37:			
  38:			;---------------------------------------------
  39:			;
  40:			; Start DOS
  41:			;
  42:			
  43:	C906  C397C9  	start:	jp	entry			; Jump to entry point DOS
  44:			
  45:			;
  46:			; Error messages DOS - for programs which intercept DOS errors
  47:			;
  48:	C909  18CC    	StRW:	defw	RWErr			; Read or write error
  49:	C90B  0CCC    	StSel:	defw	SelErr			; Select error
  50:	C90D  1DCC    	stro:	defw	rdonly			; Drive read only
  51:	C90F  11CC    	sfilro:	defw	filro			; File read only
  52:			
  53:			;
  54:			; Run-time configurable options:
  55:			;
  56:	C911          	timead:
  57:	FFFF          		 if	RTC
  58:	C911  21D7    		defw	BIOStim			; Dummy or address of BIOS routine
  59:				 else
  61:				 endif	;RTC
  62:			
  63:	C913          	fixdrvs:
  64:	C913  0000    		dw	0			; This word specifies fixed drives, ie:
  65:								; ones that do not need their ALV's
  66:								; re-built for every non-specific
  67:								; BDOS disk reset command. Set to
  68:								; 1 the bits for drives not to be reset
  69:								; 1=A; 3=A,B, 5=A,C etc
  70:			
  71:			
  72:	C915  01      	flags:	defb	options			; Flag byte for public and ^S interrupt
  73:			
  74:			; ----------------------------------------------------------------------
  75:			
  76:			; RAM area
  77:			
  78:			; -------------
  79:			
  80:	C916  00      	tabcnt:	defb	0			; Tab counter
  81:	C917  00      	tabcx1:	defb	0			; Temporary tab counter (used by rdbuf)
  82:	C918  00      	fcontp:	defb	0			; List enable flag (control p)
  83:	C919  00      	lastch:	defb	0			; Last character
  84:	C91A  FF      	delay:	defb	0ffh			; Delay counter
  85:			;
  86:	C91B  0000    	trans:	defw	0			; Translation vector
  87:	C91D  0000    	temp0:	defw	0			; Number of files on drive
  88:	C91F  0000    	dirbuf:	defw	0			; Directory buffer
  89:	C921  0000    	ixp:	defw	0			; Disk parameter block
  90:	C923  0000    	csv:	defw	0			; Checksum pointer
  91:	C925  0000    	alv:	defw	0			; Allocation vector pointer
  92:			;
  93:	C927  0000    	maxsec:	defw	0			; Maximum number of sectors/track
  94:	C929  00      	nblock:	defb	0			; Number of blocks
  95:	C92A  00      	nmask:	defb	0			; Mask number of blocks
  96:	C92B  00      	nextnd:	defb	0			; Extent mask
  97:	C92C  0000    	maxlen:	defw	0			; Maximum block number-1
  98:	C92E  0000    	nfiles:	defw	0			; Maximum number of files-1
  99:	C930  00      	ndir0:	defb	0			; First two entries alv buffer
 100:	C931  00      	ndir1:	defb	0
 101:	C932  0000    	ncheck:	defw	0			; Number of checksum entries
 102:	C934  0000    	nftrk:	defw	0			; First track number
 103:			;
 104:	C936  0000    	dskro:	defw	0			; Disk R/O vector
 105:	C938  0000    	login:	defw	0			; Login vector
 106:	C93A  0000    	diff:	defw	0			; Disk changed vector <crw>
 107:			;
 108:	C93C  8000    	DMA:	defw	080h			; DMA address
 109:			;
 110:	C93E  00      	funct:	defb	0			; Function number
 111:	C93F  0000    	pexit:	defw	0			; Exit code
 112:	C941  00      	fldrv:	defb	0			; Drive select used flag
 113:	C942  00      	rdwr:	defb	0			; Read/write flag
 114:			;
 115:	C943  00      	FCB0:	defb	0			; FCB byte 0
 116:	C944  00      	user:	defb	0			; User number
 117:	C945  00      	drive:	defb	0			; Drive number
 118:	C946  00      	defdrv:	defb	0			; Default drive number
 119:	C947  0000    	recdir:	defw	0			; Record directory (checksum)
 120:	C949  0000    	filcnt:	defw	0			; File counter
 121:	C94B  00      	secpnt:	defb	0			; Sector pointer
 122:	C94C  00      	subflg:	defb	0			; Submit flag (reset disk command)
 123:			;
 124:	C94D  0000    	dcopy:	defw	0			; Copy address FCB
 125:	C94F  00      	searex:	defb	0			; Exit code search
 126:	C950  00      	searnb:	defb	0			; Search number of bytes
 127:	C951  00      	searqu:	defb	0			; Search question mark used
 128:	C952  00      	searpu:	defb	0			; Search public file
 129:			;
 130:	C953  00      	retflg:	db	0			; Allow retry on error when non-zero
 131:			;
 132:	C954  00      	dtime	db	0			; Flag for UseStp <crw>
 133:	C955          	cdate	ds	2			; Create date storage
 134:	C957          	udate	ds	4			; Update date/time
 135:	C95B          	adate	ds	4			; Last access date/time <crw>
 136:			;
 137:	C95F  0000    	spsave:	defw	0			; Stack pointer location
 138:	C961          		defs	54
 139:	C997          	DOSstk	equ	$			; DOS internal 64 byte stack
 140:	C997          	DOSstop	equ	$
 141:			;
 142:			
 143:			;
 144:			; Entry point for DOS commands
 145:			;
 146:	C997  79      	Entry:	ld	a,c			; Get function number
 147:	C998  323EC9  		ld	(funct),a		; Save it for later use
 148:	C99B  210000  		ld	hl,0			; Set hl to zero
 149:	C99E  223FC9  		ld	(pexit),hl		; Clear exit code
 150:	C9A1  2241C9  		ld	(fldrv),hl
 151:	C9A4  45      		ld	b,l
 152:	C9A5  ED735FC9		ld	(spsave),sp		; Save stack pointer
 153:	C9A9  3197C9  		ld	sp,DOSstk			; Get internal stack pointer
 154:	C9AC  DDE5    		push	ix			; Save index register
 155:	C9AE  D5      		push	de			; Save parameter register
 156:	C9AF  DDE1    		pop	ix			; Get it back in ix
 157:	C9B1  21CDD6  		ld	hl,p2exit		; Get exit address DOS
 158:	C9B4  E5      		push	hl			; Save it on stack to return from DOS
 159:	C9B5  FE29    		cp	maxcmd+1
 160:	C9B7  3815    		jr	C,lowcmd
 161:	C9B9  FE69    		cp	105			; Test get time <crw>
 162:	C9BB  CAAFD6  		jp	Z,gettim		; Yes then get time
 163:	C9BE  FE68    		cp	104			; Test set time <crw>
 164:	C9C0  CABCD6  		jp	Z,settim		; Yes then set time
 165:	C9C3  FE37    		cp	55			; Test use time stamp <crw>
 166:	C9C5  CAC5D6  		jp	Z,UseStp
 167:	C9C8  FE36    		cp	54			; Test get time stamp <crw>
 168:	C9CA  CA7BD6  		jp	Z,Getstp
 169:	C9CD  C9      		ret
 170:	C9CE  21D9C9  	lowcmd:	ld	hl,ctable		; Load table
 171:	C9D1  81      		add	a,c
 172:	C9D2  4F      		ld	c,a
 173:	C9D3  09      		add	hl,bc			; Add
 174:	C9D4  7E      		ld	a,(hl)			; Get LSB
 175:	C9D5  23      		inc	hl			; Pointer to MSB
 176:	C9D6  66      		ld	h,(hl)			; Get MSB
 177:	C9D7  6F      		ld	l,a			; Save LSB in l
 178:	C9D8  E9      		jp	(hl)			; Jump to routine
 179:			;
 180:			; Command Jump Table
 181:			;
 182:	C9D9  03D7    	CTable:	defw	WBoot			; Warm boot
 183:	C9DB  31CA    		defw	rdcon			; Console input
 184:	C9DD  40CA    		defw	bwrcon			; Console output
 185:	C9DF  43CA    		defw	rdrdr			; Reader input
 186:	C9E1  48CA    		defw	wpunch			; Punch output
 187:	C9E3  4CCA    		defw	wlist			; List output
 188:	C9E5  50CA    		defw	dcio			; Direct console I/O
 189:	C9E7  6ACA    		defw	giost			; Get I/O byte
 190:	C9E9  6FCA    		defw	siost			; Set I/O byte
 191:	C9EB  48CB    		defw	mess			; Print string
 192:	C9ED  9DCB    		defw	rdbuf			; Read console buffer
 193:	C9EF  74CA    		defw	tstcs			; Get console status
 194:	C9F1  04CD    		defw	cmnd12			; Return version number
 195:	C9F3  0DCD    		defw	cmnd13			; Reset disk system
 196:	C9F5  1FCE    		defw	cmnd14			; Select disk
 197:	C9F7  A0D2    		defw	cmnd15			; Open file
 198:	C9F9  E5D2    		defw	cmnd16			; Close file
 199:	C9FB  40CD    		defw	cmnd17			; Search for first
 200:	C9FD  67CD    		defw	cmnd18			; Search for next
 201:	C9FF  73CD    		defw	cmnd19			; Delete file
 202:	CA01  55D4    		defw	cmnd20			; Read sequential
 203:	CA03  A0D4    		defw	cmnd21			; Write sequential
 204:	CA05  91D3    		defw	cmnd22			; Make file
 205:	CA07  7ECD    		defw	cmnd23			; Rename file
 206:	CA09  86CD    		defw	cmnd24			; Return login vector
 207:	CA0B  8DCD    		defw	cmnd25			; Return current disk
 208:	CA0D  24D0    		defw	cmnd26			; Set DMA address
 209:	CA0F  93CD    		defw	cmnd27			; Get address allocation vector
 210:	CA11  84D0    		defw	cmnd28			; Write protect disk
 211:	CA13  98CD    		defw	cmnd29			; Get R/O vector
 212:	CA15  9DCD    		defw	cmnd30			; Set file attributes
 213:	CA17  A5CD    		defw	cmnd31			; Get address disk parameter header(dph)
 214:	CA19  AACD    		defw	cmnd32			; Get/set user code
 215:	CA1B  4BD4    		defw	cmnd33			; Read random
 216:	CA1D  95D4    		defw	cmnd34			; Write random
 217:	CA1F  B8CD    		defw	cmnd35			; Compute file size
 218:	CA21  C0CD    		defw	cmnd36			; Set random record
 219:	CA23  D0CD    		defw	cmnd37			; Reset multiple drive
 220:	CA25  3FCA    		defw	dummy			; Access drive - not implemented
 221:	CA27  2BCA    		defw	gfixed			; Get fixed login vector
 222:	CA29  95D4    		defw	cmnd40			; Write random with zero fill
 223:			
 224:			; ---------------------------------
 225:			
 226:			; Return current fixed drive vector
 227:			
 228:	CA2B          	gfixed:
 229:	CA2B  2A13C9  		ld	hl,(fixdrvs)
 230:	CA2E  C389CD  		jp	cmd24a
 231:			
 232:			; ---------------------------------
 233:			
 234:			;	Character Routines
 235:			
 236:			; ---------------------------------
 237:			
 238:			; DOS console input
 239:			;
 240:			; Read character from console and echo
 241:			;  if char=cr, lf, tab, ContH or >=space
 242:			;
 243:	CA31  CDECCA  	RdCon:	call	getch			; Get character
 244:	CA34  CD2CCB  		call	tstch			; Test if cr,lf,tab,ContH or >=space
 245:	CA37  3803    		jr	C,exit			; No then exit
 246:	CA39  CD94CA  		call	wrcon			; Echo character
 247:	CA3C  323FC9  	exit:	ld	(pexit),a		; Return character
 248:	CA3F  C9      	dummy:	ret				; And exit DOS
 249:			;
 250:			; DOS write console
 251:			;
 252:	CA40  7B      	bwrcon:	ld	a,e			; Copy character
 253:	CA41  1851    		jr	wrcon			; And output it
 254:			;
 255:			; read reader
 256:			;
 257:	CA43  CD15D7  	rdrdr:	call	reader			; Get character from reader
 258:	CA46  18F4    		jr	exit			; And return it to caller
 259:			;
 260:			; write punch
 261:			;
 262:	CA48  4B      	wpunch:	ld	c,e			; Copy character
 263:	CA49  C312D7  		jp	punch			; And output it to punch device
 264:			;
 265:			; Write list
 266:			;
 267:	CA4C  4B      	wlist:	ld	c,e			; Copy character
 268:	CA4D  C30FD7  		jp	dlist			; And output it to list device
 269:			;
 270:			; Direct console input/output
 271:			;
 272:	CA50  4B      	DCIO:	ld	c,e			; Copy character
 273:	CA51  1C      		inc	e			; Test if 0ffh
 274:	CA52  280B    		jr	Z,dcio0			; Yes do input
 275:	CA54  1C      		inc	e			; Test if 0feh
 276:	CA55  C20CD7  		jp	NZ,ConOut		; No then output character
 277:	CA58  CD06D7  		call	ConSt			; Get console status
 278:	CA5B  E601    		and	1			; Test it
 279:	CA5D  18DD    		jr	exit			; And return it to caller
 280:	CA5F  CD06D7  	DCIO0:	call	ConSt			; Get console status
 281:	CA62  E601    		and	1			; Test it
 282:	CA64  C8      		ret	Z			; Exit if no character present
 283:	CA65  CD09D7  		call	ConIn			; Get character
 284:	CA68  18D2    		jr	exit			; And return it to caller
 285:			;
 286:			; Get I/O status byte
 287:			;
 288:	CA6A  3A0300  	giost:	ld	a,(RamLow+00003h)	; Get I/O byte from ram
 289:	CA6D  18CD    		jr	exit			; And return it to caller
 290:			;
 291:			; Set I/O status byte
 292:			;
 293:	CA6F  7B      	siost:	ld	a,e			; Copy I/O byte
 294:	CA70  320300  		ld	(RamLow+00003h),a	; And save it in ram
 295:	CA73  C9      		ret				; Exit to caller
 296:			;
 297:			; Test console status
 298:			;
 299:	CA74  CDF7CA  	tstcs:	call	gConSt			; Get console status
 300:	CA77  18C3    		jr	exit			; And return it to caller
 301:			;
 302:			; Output char (control char = ^char)
 303:			;
 304:	CA79  CD2CCB  	outch:	call	tstch			; Test it cr,lf,tab,ContH or >=space
 305:	CA7C  3016    		jr	NC,wrcon		; Yes then jump
 306:	CA7E  F5      		push	af			; Save character
 307:	CA7F  3E5E    		ld	a,'^'			; Load a with '^'
 308:	CA81  CD94CA  		call	wrcon			; Output it
 309:	CA84  F1      		pop	af			; Get character back
 310:	CA85  F5      		push	af			; Save it again
 311:	CA86  C640    		add	a,'A'-1			; Add offset
 312:	CA88  CD94CA  		call	wrcon			; Output it
 313:	CA8B  F1      		pop	af			; Get character
 314:	CA8C  C9      		ret				; Return to caller
 315:			;
 316:			; Echo cr,lf
 317:			;
 318:	CA8D  3E0D    	CROut:	ld	a,cr			; A=carriage return
 319:	CA8F  CD94CA  		call	wrcon			; Output it
 320:	CA92  3E0A    		ld	a,lf			; A=line feed
 321:								; Fall through to output routine
 322:			;
 323:			; Write character on console
 324:			;
 325:	CA94  FE09    	wrcon:	cp	tab			; Test if tab
 326:	CA96  200F    		jr	NZ,wrcon1		; No then jump
 327:	CA98  3E20    	wrcon0:	ld	a,' '			; Expand tab with spaces
 328:	CA9A  CD94CA  		call	wrcon			; Write space
 329:	CA9D  3A16C9  		ld	a,(tabcnt)		; Get tab count
 330:	CAA0  E607    		and	7			; Test if done
 331:	CAA2  20F4    		jr	NZ,wrcon0		; No then repeat
 332:	CAA4  3E09    		ld	a,tab			; Return tab
 333:	CAA6  C9      		ret				; Return to caller
 334:	CAA7  F5      	wrcon1:	push	af			; Save character
 335:	CAA8  CDF7CA  		call	gConSt			; Test status and ContS/ContC
 336:	CAAB  F1      		pop	af			; Get character back
 337:	CAAC  F5      		push	af			; Save it again
 338:	CAAD  4F      		ld	c,a			; Copy it
 339:	CAAE  CD0CD7  		call	ConOut			; Output it
 340:	CAB1  F1      		pop	af			; Get character back
 341:	CAB2  F5      		push	af			; Save it again
 342:	CAB3  4F      		ld	c,a			; Copy it
 343:	CAB4  3A18C9  		ld	a,(fContP)		; Get printer echo flag
 344:	CAB7  B7      		or	a			; Test it
 345:	CAB8  C40FD7  		call	nz,dlist			; Non zero => output char to printer
 346:	CABB  3A15C9  		ld	a,(flags)		; Get flag byte
 347:	CABE  CB4F    		bit	1,a			; Test delay 256 bytes active
 348:	CAC0  2808    		jr	Z,wrcon2		; No then exit
 349:	CAC2  211AC9  		ld	hl,delay		; Get delay counter
 350:	CAC5  AF      		xor	a			; A=0
 351:	CAC6  B6      		or	(hl)			; Test counter=0
 352:	CAC7  2801    		jr	Z,wrcon2		; Yes then exit
 353:	CAC9  35      		dec	(hl)			; Else decrement counter
 354:	CACA  F1      	wrcon2:	pop	af			; Restore character
 355:								; Fall through to count routine
 356:			;
 357:			; Count characters in line
 358:			;
 359:	CACB  2116C9  	countc:	ld	hl,tabcnt		; Get pointer to tab counter
 360:	CACE  34      		inc	(hl)			; Increment tab counter
 361:	CACF  FE20    		cp	' '			; Test if char >= ' '
 362:	CAD1  D0      		ret	NC			; Yes, normal character then exit
 363:	CAD2  35      		dec	(hl)			; Control character, decrement tab count
 364:	CAD3  FE08    		cp	ContH			; Test backspace
 365:	CAD5  2002    		jr	NZ,count0		; No backspace then jump
 366:	CAD7  35      		dec	(hl)			; Decrement tab counter
 367:	CAD8  C9      		ret				; And exit
 368:	CAD9  FE0D    	count0:	cp	cr			; Test carriage return
 369:	CADB  2003    		jr	NZ,count1		; No then jump
 370:	CADD  3600    		ld	(hl),0			; Reset tab count
 371:	CADF  C9      		ret				; And exit
 372:	CAE0  FE09    	count1:	cp	tab			; Test tab character
 373:	CAE2  C0      		ret	NZ			; No then exit
 374:	CAE3  F5      		push	af			; Save character
 375:	CAE4  7E      		ld	a,(hl)			; Get tab count
 376:	CAE5  C608    		add	a,8			; Advance it 8 position
 377:	CAE7  E6F8    		and	0f8h			; Set it to next tab position
 378:	CAE9  77      		ld	(hl),a			; Save it
 379:	CAEA  F1      		pop	af			; Restore character
 380:	CAEB  C9      		ret				; And exit
 381:			;
 382:			; Get character from console
 383:			;
 384:	CAEC  2119C9  	getch:	ld	hl,lastch		; Get pointer to last input character
 385:	CAEF  7E      		ld	a,(hl)			; Get character
 386:	CAF0  3600    		ld	(hl),0			; Reset last character
 387:	CAF2  B7      		or	a			; Test if character present
 388:	CAF3  C0      		ret	NZ			; Return if so
 389:	CAF4  C309D7  		jp	ConIn			; Else get character
 390:			;
 391:			; Get console status
 392:			;
 393:	CAF7  3A1AC9  	gConSt:	ld	a,(delay)		; Get 256 bytes delay
 394:	CAFA  B7      		or	a			; Test it
 395:	CAFB  2007    		jr	NZ,gcons0		; Non zero, delay stil active or disabled
 396:	CAFD  CD06D7  		call	ConSt			; Get console status
 397:	CB00  E601    		and	1			; Test it
 398:	CB02  200C    		jr	NZ,gcons1		; Non zero then get character
 399:	CB04  3A19C9  	gcons0:	ld	a,(lastch)		; Get last character
 400:	CB07  B7      		or	a			; Test it
 401:	CB08  201F    		jr	NZ,gcons3		; Non zero then character present
 402:	CB0A  CD06D7  		call	ConSt			; Get console status
 403:	CB0D  E601    		and	1			; Test it
 404:	CB0F  C8      		ret	Z			; Return if no character present
 405:	CB10  CD09D7  	gcons1:	call	ConIn			; Get character
 406:	CB13  FE13    		cp	ContS			; Test stop character
 407:	CB15  200A    		jr	NZ,gcons2		; Not then exit character
 408:	CB17  CD09D7  		call	ConIn			; Get next character
 409:	CB1A  FE03    		cp	ContC			; Test if user wants to exit
 410:	CB1C  CA0000  		jp	Z,RamLow+00000h		; Yes then warm boot
 411:	CB1F  18D6    		jr	gConSt			; Test again
 412:	CB21  3219C9  	gcons2:	ld	(lastch),a		; Save character
 413:	CB24  3EFF    		ld	a,0ffh			; Set delay counter
 414:	CB26  321AC9  		ld	(delay),a		; And save it
 415:	CB29  3E01    	gcons3:	ld	a,1			; Character present code
 416:	CB2B  C9      		ret				; Return to caller
 417:			;
 418:			; Test character
 419:			;  exit carry=0: cr,lf,tab,ContH or >=space
 420:			;	carry=1: all other characters
 421:			;
 422:	CB2C  FE0D    	tstch:	cp	cr			; Test carriage return
 423:	CB2E  C8      		ret	Z			; Return if so
 424:	CB2F  FE09    		cp	tab			; Test tab
 425:	CB31  C8      		ret	Z			; Return if so
 426:	CB32  FE08    		cp	ContH			; Test backspace
 427:	CB34  C8      		ret	Z			; Return if so
 428:	CB35  FE7F    		cp	rubout
 429:	CB37  C8      		ret	Z
 430:	CB38  FE20    		cp	' '			; Test >=space
 431:	CB3A  C9      		ret				; Return to caller
 432:			;
 433:			; Write backspace, space, backspace
 434:			;
 435:	CB3B  CD43CB  	wContH:	call	wcont0			; Write backspace
 436:	CB3E  0E20    		ld	c,' '			; Load space
 437:	CB40  CD0CD7  		call	ConOut			; And output it
 438:	CB43  0E08    	wcont0:	ld	c,ContH			; Load backspace
 439:	CB45  C30CD7  		jp	ConOut			; And output it
 440:			;
 441:			; Output message
 442:			;
 443:	CB48  1A      	mess:	ld	a,(de)			; Get byte from buffer
 444:	CB49  FE24    		cp	'$'			; Test last byte
 445:	CB4B  C8      		ret	Z			; Yes, then return to caller
 446:	CB4C  13      		inc	de			; Point to next byte
 447:	CB4D  D5      		push	de			; Save pointer
 448:	CB4E  CD94CA  		call	wrcon			; Output character
 449:	CB51  D1      		pop	de			; Restore pointer
 450:	CB52  18F4    		jr	mess			; And test again
 451:			;
 452:	CB54  2116C9  	again:	ld	hl,tabcnt		; Get tab count pointer
 453:	CB57  3A17C9  		ld	a,(tabcx1)		; Get position first character line
 454:	CB5A  BE      		cp	(hl)			; Check it
 455:	CB5B  C8      		ret	Z			; Return if on same position
 456:	CB5C  3E20    		ld	a,' '			; Load space
 457:	CB5E  CD94CA  		call	wrcon			; Output it
 458:	CB61  18F1    		jr	again			; And test again
 459:			;
 460:			; Delete char
 461:			;  entry : HL = start buffer - 1
 462:			;	   B  = character counter (always > 0)
 463:			;
 464:	CB63  05      	delch:	dec	b			; Decrement character counter
 465:	CB64  3A16C9  		ld	a,(tabcnt)		; Get tab counter
 466:	CB67  F5      		push	af			; Save it
 467:	CB68  C5      		push	bc			; Save character counter
 468:	CB69  3A17C9  		ld	a,(tabcx1)		; Get position first character line
 469:	CB6C  3216C9  		ld	(tabcnt),a		; Save it in tab counter
 470:	CB6F  78      	delch0:	ld	a,b			; Copy character counter
 471:	CB70  B7      		or	a			; Test if 0
 472:	CB71  2813    		jr	Z,delch2		; Yes then jump
 473:	CB73  05      		dec	b			; Decrement it
 474:	CB74  23      		inc	hl			; Increment buffer pointer
 475:	CB75  7E      		ld	a,(hl)			; Get character from buffer
 476:	CB76  E5      		push	hl			; Save buffer pointer
 477:	CB77  CD2CCB  		call	tstch			; Test if cr,lf,tab,ContH or >=sp
 478:	CB7A  3004    		jr	NC,delch1		; Yes then jump
 479:	CB7C  1F      		rra				; Else must be control character
 480:	CB7D  CDCBCA  		call	countc			; Count control character twice
 481:	CB80  CDCBCA  	delch1:	call	countc			; Count character
 482:	CB83  E1      		pop	hl			; Get buffer pointer
 483:	CB84  18E9    		jr	delch0			; And test again
 484:	CB86  C1      	delch2:	pop	bc			; Restore character counter
 485:	CB87  F1      		pop	af			; And tab counter
 486:	CB88  E5      		push	hl			; Save buffer pointer
 487:	CB89  C5      		push	bc			; And character counter
 488:	CB8A  2116C9  		ld	hl,tabcnt		; Get tab counter pointer
 489:	CB8D  96      		sub	(hl)			; Calculate difference
 490:	CB8E  3D      	delch3:	dec	a			; Decrement it
 491:	CB8F  FE08    		cp	8			; Compare with 8
 492:	CB91  3007    		jr	NC,delch4		; Jump if >=8
 493:	CB93  F5      		push	af			; Save difference
 494:	CB94  CD3BCB  		call	wContH			; Remove character end line
 495:	CB97  F1      		pop	af			; Restore counter
 496:	CB98  18F4    		jr	delch3			; Remove more characters
 497:	CB9A  C1      	delch4:	pop	bc			; Restore character counter
 498:	CB9B  E1      		pop	hl			; Restore buffer pointer
 499:	CB9C  C9      		ret				; And return to caller
 500:			;
 501:			; Read buffer
 502:			;
 503:	CB9D  3A16C9  	rdbuf:	ld	a,(tabcnt)		; Get current position cursor
 504:	CBA0  3217C9  		ld	(tabcx1),a		; Save it
 505:	CBA3  DDE5    	rdbuf0:	push	ix			; Save start address buffer
 506:	CBA5  E1      		pop	hl			; Get it in hl
 507:	CBA6  4E      		ld	c,(hl)			; Get maximum line lenght
 508:	CBA7  23      		inc	hl			; Increment to line lenght position
 509:	CBA8  0600    		ld	b,0			; Clear line lenght counter
 510:	CBAA  E5      		push	hl			; Save start line - 1
 511:	CBAB  E5      	rdbuf1:	push	hl			; Save registers
 512:	CBAC  C5      		push	bc
 513:	CBAD  CDECCA  	rdbuf2:	call	getch			; Get character
 514:	CBB0  C1      		pop	bc			; Restore registers
 515:	CBB1  E1      		pop	hl
 516:	CBB2  E67F    		and	07fh			; Mask character
 517:	CBB4  FE08    	rdbuf3:	cp	ContH			; Test backspace
 518:	CBB6  200B    		jr	NZ,rdbuf4		; Not then jump
 519:	CBB8  78      	doback:	ld	a,b			; Test if deleting char from empty line
 520:	CBB9  B7      		or	a
 521:	CBBA  28EF    		jr	Z,rdbuf1		; Yes then get next char
 522:	CBBC  E1      		pop	hl			; Get start line
 523:	CBBD  E5      		push	hl			; And save it again
 524:	CBBE  CD63CB  		call	delch			; Delete character
 525:	CBC1  18E8    		jr	rdbuf1			; Get next character
 526:	CBC3  FE10    	rdbuf4:	cp	ContP			; Test print enable/disable
 527:	CBC5  2007    		jr	NZ,rdbufC		; Not then jump
 528:	CBC7  3A18C9  		ld	a,(fContP)		; Complement print flag
 529:	CBCA  2F      		cpl
 530:	CBCB  3218C9  		ld	(fContP),a
 531:	CBCE  FE18    	rdbufc:	cp	ContX			; Test delete line
 532:	CBD0  200C    		jr	NZ,rdbufe		; Not then jump
 533:	CBD2  E1      	rdbufd:	pop	hl			; Get start line
 534:	CBD3  78      		ld	a,b			; Test if last character deleted
 535:	CBD4  B7      		or	a
 536:	CBD5  CA9DCB  		jp	Z,RDBUF			; Yes start routine again
 537:	CBD8  E5      		push	hl			; Save pointer
 538:	CBD9  CD63CB  		call	delch			; Delete last character line
 539:	CBDC  18F4    		jr	rdbufd			; Test last character deleted
 540:	CBDE  FE7F    	rdbufe:	cp	rubout			; Test delete last character
 541:	CBE0  2002    		jr	NZ,rdbuff		; Not then jump
 542:	CBE2  18D4    		jr	doback			; Part of delete key fix
 543:	CBE4  FE0D    	rdbuff:	cp	cr			; Test carriage return
 544:	CBE6  2818    		jr	Z,rdbufi		; Yes, then exit
 545:	CBE8  23      		inc	hl			; Increment pointer
 546:	CBE9  77      		ld	(hl),a			; And save character
 547:	CBEA  04      		inc	b			; Increment line counter
 548:	CBEB  E5      	rdbufg:	push	hl			; Save registers
 549:	CBEC  C5      		push	bc
 550:	CBED  CD79CA  		call	outch			; Echo character
 551:	CBF0  C1      		pop	bc			; Restore registers
 552:	CBF1  E1      		pop	hl
 553:	CBF2  FE03    		cp	ContC			; Test warm boot
 554:	CBF4  78      		ld	a,b			; Get line count
 555:	CBF5  2005    		jr	NZ,rdbufh		; No warm boot then jump
 556:	CBF7  FE01    		cp	1			; Test ContC is first character line
 557:	CBF9  CA0000  		jp	Z,RamLow+00000h		; Yes then execute warm boot
 558:	CBFC  B9      	rdbufh:	cp	c			; Test line length=maximum line length
 559:	CBFD  C2ABCB  		jp	NZ,rdbuf1		; Not then get next character
 560:	CC00  E1      	rdbufi:	pop	hl			; Get start line - 1
 561:	CC01  70      		ld	(hl),b			; Save line counter
 562:	CC02  3E0D    		ld	a,cr			; Load carriage return
 563:	CC04  C394CA  		jp	wrcon			; And echo it
 564:			
 565:			
 566:			;---------------------------
 567:			
 568:			;	Error routines
 569:			
 570:			;---------------------------
 571:			
 572:			;
 573:			; Disk changed error
 574:			;
 575:	CC07          	ChgErr:
 576:	CC07  11DACC  		ld	de,mchg 		; Load changed error message
 577:	CC0A  1814    		jr	derror			; And display error
 578:			;
 579:			; Select error
 580:			;
 581:	CC0C  11E0CC  	SelErr:	ld	de,msel			; Load selected error message
 582:	CC0F  180F    		jr	derror			; And display error
 583:			;
 584:			; File read only error
 585:			;
 586:	CC11  11E6CC  	FilRO:	ld	de,mfilro		; Load file R/O message
 587:	CC14  3EFF    		ld	a,0ffh			; Set file R/O message flag
 588:	CC16  1809    		jr	error			; And display error
 589:			;
 590:			; Read/Write error
 591:			;
 592:	CC18          	RWErr:
 593:	CC18  11ECCC  		ld	de,mrwerr
 594:	CC1B  1803    		jr	derror
 595:			;
 596:			; Drive read only error
 597:			;
 598:	CC1D  11E9CC  	rdonly:	ld	de,mro			; Load drive R/O message
 599:	CC20  AF      	derror:	xor	a			; Set no file R/O message
 600:			;	fall	thru
 601:			
 602:			;
 603:			; Display error message
 604:			;
 605:			; "Error message" error on d:
 606:			; Function	nn
 607:			; File		filename.typ
 608:			;
 609:	CC21  4F      	error:	ld	c,a			; Save file R/O message flag
 610:	CC22  C5      		push	bc
 611:	CC23  D5      		push	de			; Save error message pointer
 612:	CC24  CD8DCA  		call	crout			; Display cr/lf
 613:	CC27  D1      		pop	de
 614:	CC28  CD48CB  		call	mess			; Display error
 615:	CC2B  3A46C9  		ld	a,(defdrv)		; Get current drive
 616:	CC2E  C641    		add	a,'A'			; Make ASCII
 617:	CC30  32F5CC  		ld	(mdrive),a		; Save it
 618:	CC33  11EFCC  		ld	de,mberr		; Load message " error on d:"
 619:	CC36  CD48CB  		call	mess			; Display message
 620:	CC39  11F8CC  		ld	de,mbfunc		; Load message "function "
 621:	CC3C  CD48CB  		call	mess			; Display message
 622:	CC3F  3A3EC9  		ld	a,(funct)		; Get function number
 623:	CC42  F5      		push	af			; Save it
 624:	CC43  016400  		ld	bc,100			; Display number / 100
 625:	CC46  CDB5CC  		call	num
 626:	CC49  0E0A    		ld	c,10			; Display number / 10
 627:	CC4B  CDB5CC  		call	num
 628:	CC4E  010101  		ld	bc,101h			; Always display number / 1
 629:	CC51  CDB5CC  		call	num
 630:	CC54  F1      		pop	af			; Get function number
 631:	CC55  C1      		pop	bc			; Get file R/O flag
 632:	CC56  FE0F    		cp	15			; Test if FCB used in command
 633:	CC58  3839    		jr	C,error3		; Commands <16, don't show filename
 634:	CC5A  FE18    		cp	24
 635:	CC5C  3810    		jr	C,error1		; Commands 16..23 show file
 636:	CC5E  FE1E    		cp	30
 637:	CC60  280C    		jr	Z,error1		; Command 30 show file
 638:	CC62  FE21    		cp	33
 639:	CC64  382D    		jr	C,error3		; Other commands 24..32 no file
 640:	CC66  FE25    		cp	37
 641:	CC68  3804    		jr	C,error1		; 33..36 show
 642:	CC6A  FE28    		cp	40
 643:	CC6C  2025    		jr	NZ,error3		; 37 don't show
 644:			
 645:	CC6E  DDE5    	error1:	push	ix			; Display "file ="
 646:	CC70  D613    		sub	19			; Test delete file function
 647:	CC72  2007    		jr	NZ,error2		; Not then jump
 648:	CC74  B1      		or	c			; Test file R/O flag
 649:	CC75  2804    		jr	Z,error2		; No file R/O then jump
 650:	CC77  CD75CF  		call	caldir			; Get FCB from directory buffer
 651:	CC7A  E3      		ex	(sp),hl			; Save it
 652:	CC7B  11FECC  	error2:	ld	de,mfile		; Get message " file ="
 653:	CC7E  CD48CB  		call	mess			; Display message
 654:	CC81  E1      		pop	hl			; Get pointer FCB
 655:	CC82  0608    		ld	b,8			; Display first 8 characters
 656:	CC84  CDCCCC  		call	filenm
 657:	CC87  3E2E    		ld	a,'.'			; Load '.'
 658:	CC89  E5      		push	hl			; Save FCB pointer
 659:	CC8A  CD94CA  		call	wrcon			; Echo it
 660:	CC8D  E1      		pop	hl			; Restore FCB pointer
 661:	CC8E  0603    		ld	b,3			; Display last 3 characters
 662:	CC90  CDCCCC  		call	filenm
 663:			
 664:			; Absorb any pending characters:
 665:			
 666:	CC93  CDF7CA  	error3:	call	gConSt			; Test if character pending
 667:	CC96  B7      		or	a
 668:	CC97  2805    		jr	Z,error4		; No then jump
 669:	CC99  CDECCA  		call	getch			; Get character
 670:	CC9C  18F5    		jr	error3			; And test again
 671:			;
 672:			; Allow retry on read/write errors
 673:			;
 674:	CC9E          	error4:
 675:	CC9E  3A53C9  		ld	a,(retflg)		; Allow retry?
 676:	CCA1  B7      		or	a
 677:	CCA2  280A    		jr	Z,error5		; No
 678:	CCA4  AF      		xor	a
 679:	CCA5  3253C9  		ld	(retflg),a		; Reset flag <crw>
 680:	CCA8  CDECCA  		call	getch
 681:	CCAB  FE03    		cp	ContC			; Control-c entered?
 682:	CCAD  C0      		ret	NZ			; No, retry
 683:	CCAE  AF      	error5:	xor	a			; Make sure no use stamp flag is
 684:								; around when we warmboot
 685:	CCAF  3254C9  		ld	(dtime),a
 686:	CCB2  C30000  		jp	RamLow+00000h		; Do warm boot
 687:			;
 688:			; Display number
 689:			;
 690:	CCB5  16FF    	num:	ld	d,0ffh			; Load number -1
 691:	CCB7  14      	num1:	inc	d			; Increment number
 692:	CCB8  91      		sub	c			; Divide by c
 693:	CCB9  30FC    		jr	NC,num1			; Not finished then loop
 694:	CCBB  81      		add	a,c			; Restore last value
 695:	CCBC  F5      		push	af			; Save it
 696:	CCBD  7A      		ld	a,d			; Test if "0"
 697:	CCBE  B0      		or	b			; And if leading zero
 698:	CCBF  2809    		jr	Z,num2			; Yes, then exit
 699:	CCC1  47      		ld	b,a			; Set no leading zero
 700:	CCC2  7A      		ld	a,d			; Get number
 701:	CCC3  C630    		add	a,'0'			; Make ASCII
 702:	CCC5  C5      		push	bc			; Save registers
 703:	CCC6  CD94CA  		call	wrcon			; Echo number
 704:	CCC9  C1      		pop	bc			; Restore registers
 705:	CCCA  F1      	num2:	pop	af			; Restore number
 706:	CCCB  C9      		ret				; And exit
 707:			;
 708:			; Display filename.typ
 709:			;
 710:	CCCC  23      	filenm:	inc	hl			; Increment pointer FCB
 711:	CCCD  7E      		ld	a,(hl)			; Get character from FCB
 712:	CCCE  E67F    		and	07fh			; Mask it
 713:	CCD0  E5      		push	hl			; Save registers
 714:	CCD1  C5      		push	bc
 715:	CCD2  CD94CA  		call	wrcon			; Echo character
 716:	CCD5  C1      		pop	bc			; Restore registers
 717:	CCD6  E1      		pop	hl
 718:	CCD7  10F3    		djnz	filenm			; Repeat b times
 719:	CCD9  C9      		ret				; And exit
 720:			;
 721:			; Error messages
 722:			; Made more meaningful--b.h.
 723:			;
 724:			
 725:	CCDA  446B2063	mchg:	db	'Dk ch$'	;DISK CHANGED
	      6824
 726:			
 727:	CCE0  496C2064	msel:	db	'Il dr$'	;ILLEGAL DRIVE
	      7224
 728:			
 729:	CCE6  466C20  	mfilro:	db	'Fl '		;FILE
 730:			
 731:	CCE9  524F24  	mro:	db	'RO$'		;READ ONLY
 732:			
 733:	CCEC  447424  	mrwerr:	db	'Dt$'		; DATA  BIOS read/write error 
 734:			
 735:	CCEF  2065726F	mberr:	defm	' eron '	;ERROR ON
	      6E20
 736:	CCF5  00      	mdrive:	defb	0
 737:	CCF6  3A      		defb	DrvSep
 738:	CCF7  24      		defm	'$'
 739:			
 740:	CCF8  0D0A4674	mbfunc:	defm	cr,lf,'Ft',tab,'$'	;FUNCTION
	      0924
 741:			
 742:	CCFE  0D0A4669	mfile:	defm	cr,lf,'Fi',tab,'$'	;FILE
	      0924
 743:			
 744:			; END Z80DCHAR.Z80
**** z80dos24.z80 ****
  53:			
  54:			include z80ddisk.z80	; Return CP/M version, disk routines
**** z80ddisk.z80 ****
   1:			;
   2:			; Z80DOS - Z80 Disk Operating System
   3:			;
   4:			; Version 2.4	Maskable disk reset's using variable fixdrv
   5:			;		Now can assemble with Z80MR if Z80MR equate
   6:			;		set to -1.
   7:			;		Gene Nolan 4/9/89
   8:			;
   9:			;
  10:			;------------------------------------------------------
  11:			;
  12:			; Version 2.31	Fast file lookup for random records fix
  13:			; Date		15 Nov 88
  14:			; Update	Eugene Nolan
  15:			;
  16:			; Version 2.3	Fast file lookup
  17:			; Date:		4 Nov 88
  18:			; Update:	Eugene Nolan
  19:			;
  20:			;-------------------------------------------------------------
  21:			; Version 2.0a - BETA TEST VERSION - 6 Nov 87 by Carson Wilson
  22:			;
  23:			; Support file:	Z80DDISK.Z80
  24:			; Version:	2.0
  25:			; Date:		6 Nov 87
  26:			; Author:	Carson Wilson
  27:			; Description:	DOS Return CP/M Version, Disk Functions
  28:			;
  29:			; Changes:	--------
  30:			;		Changed Readr and Writer to use a common error function,
  31:			;		RWErr, which displays "Data error on d:".
  32:			;
  33:			;		new disk will be overwritten, data from the first file will
  34:			;		probably be lost.
  35:			;
  36:			;		--------
  37:			;		Command 37 (reset individual disk) now resets the disk changed
  38:			;		vector instead of the drive R/O vector.
  39:			;
  40:			;		--------
  41:			;		Removed code which made public files read-only from
  42:			;		other user areas.  The user must now manually set public
  43:			;		files to read-only using the R/O attribute (t1).  This
  44:			;		change was made because some applications must write to
  45:			;		public files.
  46:			;
  47:			;		--------
  48:			;		System files are now R/W unless referenced by wildcards.
  49:			;
  50:			
  51:			
  52:			; -----------------------
  53:			;
  54:			; Return version number
  55:			;
  56:			; -----------------------
  57:			
  58:	CD04  3E22    	cmnd12:	ld	a,22h			; Set version number
  59:	CD06  DD210038		ld	ix,3800h		; this will put an '8' into D
  60:								; register upon return, saying
  61:								; Z80DOS operating
  62:	CD0A  C390CD  		jp	cmd25a			; And exit
  63:			
  64:			
  65:			; -----------------------------
  66:			;
  67:			;	Disk functions
  68:			;
  69:			; -----------------------------
  70:			;
  71:			; Reset disk system
  72:			;
  73:	CD0D          	cmnd13:
  74:			;	ld	hl,0			; Load zero
  75:	CD0D  2A38C9  		ld	hl,(login)		; Get login vector
  76:	CD10  ED5B13C9		ld	de,(fixdrvs)		; get drive mask
  77:	CD14  7C      		ld	a,h
  78:	CD15  A2      		and	d
  79:	CD16  67      		ld	h,a
  80:	CD17  7D      		ld	a,l
  81:	CD18  A3      		and	e
  82:	CD19  6F      		ld	l,a			; HL now has selective drives
  83:								; logged out
  84:	CD1A  2238C9  		ld	(login),hl
  85:	CD1D  210000  		ld	hl,0
  86:	CD20  2236C9  		ld	(dskro),hl		; All drives read/write
  87:	CD23  223AC9  		ld	(diff),hl		; No disks changed <crw>
  88:	CD26  218000  		ld	hl,RamLow+80h		; Set up DMA address
  89:	CD29  223CC9  		ld	(DMA),hl		; And save it
  90:	CD2C  CD28D0  		call	stDMA			; Do BIOS call
  91:			;	ld	a,ResDsk+1		; When selective logout enabled
  92:	CD2F  3A36D7  		ld	a,(BOTDSK)		; When selective logout enabled
  93:			;	inc	a
  94:								; the call to seldk below requires
  95:								; defdrv and the drive to select in
  96:								; the A reg to be different
  97:	CD32  3246C9  		ld	(defdrv),a		; Save it
  98:			;	ld	a,ResDsk		; <crw>
  99:	CD35  3A36D7  		ld	a,(BOTDSK)		; When selective logout enabled
 100:	CD38  CD20CE  		call	seldk			; Select drive 0=A, 1=B, etc.
 101:	CD3B  3A4CC9  		ld	a,(subflg)		; Get submit flag
 102:	CD3E  1850    		jr	cmd25a			; Exit
 103:			;
 104:			; Search for file
 105:			;
 106:	CD40  CDF0CD  	cmnd17:	call	seldrv			; Select drive from FCB
 107:	CD43  DD7E00  		ld	a,(ix+0)		; Get drive number from FCB
 108:	CD46  D63F    		sub	'?'			; Test if '?'
 109:	CD48  280D    		jr	Z,cmd17b		; If so all entries match
 110:	CD4A  DD7E0E  		ld	a,(ix+14)		; Get system byte
 111:	CD4D  FE3F    		cp	'?'			; Test if '?'
 112:	CD4F  2804    		jr	Z,cmd17a		; Yes, jump
 113:	CD51  DD360E00		ld	(ix+14),0		; Load system byte with zero
 114:	CD55  3E0F    	cmd17a:	ld	a,15			; Test first 15 items in FCB
 115:	CD57  CD26D1  	cmd17b:	call	search			; Do search
 116:	CD5A  2A1FC9  	cmd17c:	ld	hl,(dirbuf)		; Copy directory buffer
 117:	CD5D  ED5B3CC9		ld	de,(DMA)		; To DMA address
 118:	CD61  018000  		ld	bc,128			; Directory=128 bytes
 119:	CD64  EDB0    		ldir
 120:	CD66  C9      		ret				; Exit
 121:			;
 122:			; Search for next occurrence of file
 123:			;
 124:	CD67  DD2A4DC9	cmnd18:	ld	ix,(dcopy)		; Get last FCB used by search
 125:	CD6B  CDF0CD  		call	seldrv			; Select drive from FCB
 126:	CD6E  CD38D1  		call	searcn			; Search next file match
 127:	CD71  18E7    		jr	cmd17c			; And copy directory to DMA address
 128:			;
 129:			; Delete file
 130:			;
 131:	CD73  CDF0CD  	cmnd19:	call	seldrv			; Select drive from FCB
 132:	CD76  CDE3D1  		call	delete			; Delete file
 133:	CD79  3A4FC9  	cmd19a:	ld	a,(searex)		; Get exit byte 00=file found,0ffh not
 134:	CD7C  1812    		jr	cmd25a			; And exit
 135:			;
 136:			; Rename file
 137:			;
 138:	CD7E  CDF0CD  	cmnd23:	call	seldrv			; Select drive from FCB
 139:	CD81  CD02D2  		call	renam			; Rename file
 140:	CD84  18F3    		jr	cmd19a			; And exit
 141:			;
 142:			; Return login vector
 143:			;
 144:	CD86  2A38C9  	cmnd24:	ld	hl,(login)		; Get login vector
 145:	CD89  223FC9  	cmd24a:	ld	(pexit),hl		; Save it
 146:	CD8C  C9      		ret				; And exit
 147:			;
 148:			; Return current drive
 149:			;
 150:	CD8D  3A46C9  	cmnd25:	ld	a,(defdrv)		; Get current drive
 151:	CD90  C33CCA  	cmd25a:	jp	exit			; And exit
 152:			;
 153:			; Return allocation vector
 154:			;
 155:	CD93  2A25C9  	cmnd27:	ld	hl,(alv)		; Get allocation vector
 156:	CD96  18F1    		jr	cmd24a			; And exit
 157:			;
 158:			; Return disk R/O vector
 159:			;
 160:	CD98  2A36C9  	cmnd29:	ld	hl,(dskro)		; Get disk R/O vector
 161:	CD9B  18EC    		jr	cmd24a			; And exit
 162:			;
 163:			; Set file attributes
 164:			;
 165:	CD9D  CDF0CD  	cmnd30:	call	seldrv			; Select drive from FCB
 166:	CDA0  CD35D2  		call	cstat			; Change status
 167:	CDA3  18D4    		jr	cmd19a			; And exit
 168:			;
 169:			; Get Disk Parameter Block Address
 170:			;
 171:	CDA5  2A21C9  	cmnd31:	ld	hl,(ixp)		; get drive table
 172:	CDA8  18DF    		jr	cmd24a			; And exit
 173:			;
 174:			; Set/get user code
 175:			;
 176:			
 177:	CDAA  7B      	cmnd32:	ld	a,e			; Get user code
 178:	CDAB  3C      		inc	a			; Test if 0ffh
 179:	CDAC  3A44C9  		ld	a,(user)		; Get old user code
 180:	CDAF  28DF    		jr	Z,cmd25a		; If 0ffh then exit
 181:	CDB1  7B      		ld	a,e			; Get new user code
 182:	CDB2  E61F    		and	01fh			; Mask it
 183:	CDB4  3244C9  		ld	(user),a		; Save it
 184:	CDB7  C9      		ret				; And exit
 185:			;
 186:			; Compute file size
 187:			;
 188:	CDB8  CDF0CD  	cmnd35:	call	seldrv			; Select drive from FCB
 189:	CDBB  CD5CD2  		call	filsz			; Compute file size
 190:	CDBE  18B9    		jr	cmd19a			; And exit
 191:			;
 192:			; Set random record count
 193:			;
 194:	CDC0  212000  	cmnd36:	ld	hl,32			; Set pointer to next record
 195:	CDC3  CD20D6  		call	calrrc			; Calculate random record count
 196:	CDC6  DD7221  	ldrrc:	ld	(ix+33),d		; And save random record count
 197:	CDC9  DD7122  		ld	(ix+34),c
 198:	CDCC  DD7023  		ld	(ix+35),b
 199:	CDCF  C9      		ret				; And exit
 200:			;
 201:			; Reset individual disk drives from vector in DE
 202:			;
 203:	CDD0  7B      	cmnd37:	ld	a,e			; Get mask LSB
 204:	CDD1  2F      		cpl				; Complement it
 205:	CDD2  5F      		ld	e,a
 206:	CDD3  7A      		ld	a,d			; Get mask MSB
 207:	CDD4  2F      		cpl				; Complement it
 208:	CDD5  57      		ld	d,a
 209:	CDD6  2A38C9  		ld	hl,(login)		; Get login vector
 210:	CDD9  7B      		ld	a,e			; Mask login vector
 211:	CDDA  A5      		and	l			; LSB
 212:	CDDB  6F      		ld	l,a
 213:	CDDC  7A      		ld	a,d			; Mask login vector
 214:	CDDD  A4      		and	h			; MSB
 215:	CDDE  67      		ld	h,a
 216:	CDDF  2238C9  		ld	(login),hl		; Save login vector
 217:	CDE2  EB      		ex	de,hl			; Use login vector as mask
 218:	CDE3  2A3AC9  		ld	hl,(diff)		; Get disk changed vector <crw>
 219:	CDE6  7B      		ld	a,e			; Mask drive R/O vector
 220:	CDE7  A5      		and	l			; LSB
 221:	CDE8  6F      		ld	l,a
 222:	CDE9  7A      		ld	a,d			; Mask drive R/O vector
 223:	CDEA  A4      		and	h			; LSB
 224:	CDEB  67      		ld	h,a
 225:	CDEC  223AC9  		ld	(diff),hl		; Save disk changed vector <crw>
 226:	CDEF  C9      		ret				; And exit
 227:			;
 228:			; Select disk from FCB
 229:			;
 230:	CDF0  3EFF    	seldrv:	ld	a,0ffh			; Set disk select done flag
 231:	CDF2  3241C9  		ld	(fldrv),a
 232:	CDF5  3A46C9  		ld	a,(defdrv)		; Get current drive
 233:	CDF8  3245C9  		ld	(drive),a		; Save it in memory
 234:	CDFB  5F      		ld	e,a			; Save it in register e
 235:	CDFC  DD7E00  		ld	a,(ix+0)		; Get drive from FCB
 236:	CDFF  3243C9  		ld	(fcb0),a		; Save it
 237:	CE02  57      		ld	d,a
 238:	CE03  FE3F    		cp	'?'			; Test if '?'
 239:	CE05  2818    		jr	Z,cmnd14		; Yes, then select drive from register e
 240:	CE07  E61F    		and	01fh			; Mask drive
 241:	CE09  7B      		ld	a,e			; Test if zero
 242:	CE0A  2802    		jr	Z,seldr0		; Select drive from register e
 243:	CE0C  7A      		ld	a,d
 244:	CE0D  3D      		dec	a			; Decrement drive
 245:	CE0E  CD20CE  	seldr0:	call	seldk			; Select drive
 246:	CE11  DD7E00  		ld	a,(ix+0)		; Get drive from FCB
 247:	CE14  E6E0    		and	0e0h			; Remove drive bits
 248:	CE16  47      		ld	b,a			; Save register
 249:	CE17  3A44C9  		ld	a,(user)		; Get user number
 250:	CE1A  B0      		or	b			; Insert user number in FCB
 251:	CE1B  DD7700  		ld	(ix+0),a
 252:	CE1E  C9      		ret				; And exit
 253:			;
 254:			; Select disk
 255:			;
 256:	CE1F  7B      	cmnd14:	ld	a,e			; Copy drive number
 257:			;
 258:	CE20  E60F    	seldk:	and	0fh			; Mask drive number to 0-15
 259:	CE22  47      		ld	b,a			; Save counter
 260:	CE23  ED5B38C9		ld	de,(login)		; Get login vector
 261:	CE27  B7      		or	a			; Test drive 'a'
 262:	CE28  2806    		jr	Z,seldk1		; Yes then jump
 263:	CE2A  CB1A    	seldk0:	rr	d			; Shift login vector
 264:	CE2C  CB1B    		rr	e			; Until bit 0 register e
 265:	CE2E  10FA    		djnz	seldk0			; Is current drive
 266:	CE30  2146C9  	seldk1:	ld	hl,defdrv		; Get pointer last drive
 267:	CE33  CB43    		bit	0,e			; Test if drive logged in
 268:	CE35  2802    		jr	Z,seldk2		; No, login drive
 269:	CE37  BE      		cp	(hl)			; Test same drive
 270:	CE38  C8      		ret	Z			; Yes then exit
 271:	CE39  77      	seldk2: ld	(hl),a			; Save new current drive
 272:	CE3A  D5      		push	de			; Save drive logged in flag
 273:	CE3B  4F      		ld	c,a
 274:	CE3C  CD1BD7  		call	SelDsk			; Do BIOS select
 275:	CE3F  7C      		ld	a,h			; Test if error
 276:	CE40  B5      		or	l
 277:	CE41  282D    		jr	Z,seldk3		; Yes, illegal drive number
 278:	CE43  5E      		ld	e,(hl)			; Get LSB translation vector
 279:	CE44  23      		inc	hl			; Increment pointer
 280:	CE45  56      		ld	d,(hl)			; Get MSB translation vector
 281:	CE46  23      		inc	hl			; Increment pointer
 282:	CE47  ED531BC9		ld	(trans),de		; Save translation vector
 283:	CE4B  221DC9  		ld	(temp0),hl		; Save address temp0
 284:	CE4E  110600  		ld	de,6
 285:	CE51  19      		add	hl,de			; Point to dirbuf pointer <crw>
 286:	CE52  111FC9  		ld	de,dirbuf		; Load dirbuf pointer
 287:	CE55  010800  		ld	bc,8			; Copy pointers to dirbuf,
 288:	CE58  EDB0    		ldir				; ..csv (wacd), alv from BIOS
 289:	CE5A  2A21C9  		ld	hl,(ixp)		; Get drive parameter address
 290:	CE5D  0E0F    		ld	c,15			; Copy 15 bytes
 291:	CE5F  EDB0    		ldir
 292:	CE61  D1      		pop	de			; Get drive logged in flag
 293:	CE62  CB43    		bit	0,e			; Test it
 294:	CE64  C0      		ret	NZ			; Drive logged in so return
 295:	CE65  2A38C9  		ld	hl,(login)		; Get login vector
 296:	CE68  CDD3CE  		call	sdrvb			; Set drive bit in login vector
 297:	CE6B  2238C9  		ld	(login),hl		; Save login vector
 298:	CE6E  1804    		jr	initdr			; And setup drive tables
 299:	CE70          	seldk3:
 300:	CE70  2A0BC9  		ld	hl,(StSel)		; Load error message address
 301:	CE73  E9      		jp	(hl)			; And display error
 302:			;
 303:			; Init drive
 304:			;  Clear allocation vector bit buffer after drive reset
 305:			;
 306:	CE74  ED5B2CC9	initdr:	ld	de,(maxlen)		; Get length alv buffer-1 (bits)
 307:	CE78  3E03    		ld	a,3			; Divide by 8
 308:	CE7A  CB3A    	initd0:	srl	d			; To get bytes
 309:	CE7C  CB1B    		rr	e
 310:	CE7E  3D      		dec	a
 311:	CE7F  20F9    		jr	NZ,initd0
 312:	CE81  13      		inc	de			; Increment, so all bits are cleared
 313:	CE82  2A25C9  		ld	hl,(alv)		; Get pointer alv buffer
 314:	CE85  E5      		push	hl
 315:	CE86  3600    	initd1:	ld	(hl),0			; Clear 8 bits
 316:	CE88  23      		inc	hl			; Increment pointer
 317:	CE89  1B      		dec	de			; Decrement counter
 318:	CE8A  7A      		ld	a,d			; Test if counter zero
 319:	CE8B  B3      		or	e
 320:	CE8C  20F8    		jr	NZ,initd1		; Not then jump
 321:	CE8E  E1      		pop	hl			; Get alv pointer
 322:	CE8F  ED5B30C9		ld	de,(ndir0)		; Get first two bytes alv buffer
 323:	CE93  73      		ld	(hl),e			; Save LSB
 324:	CE94  23      		inc	hl			; Increment pointer
 325:	CE95  72      		ld	(hl),d			; Save MSB
 326:	CE96  2A1DC9  		ld	hl,(temp0)		; Clear number of files
 327:	CE99  AF      		xor	a			; On this drive
 328:	CE9A  77      		ld	(hl),a			; Clear LSB
 329:	CE9B  23      		inc	hl			; Increment pointer
 330:	CE9C  77      		ld	(hl),a			; Clear MSB
 331:	CE9D  324CC9  		ld	(subflg),a		; Clear submit flag (reset disk command)
 332:	CEA0  CD80CF  		call	setfct			; Set file count
 333:	CEA3  3EFF    	initd2:	ld	a,0ffh			; Update directory checksum
 334:	CEA5  CDA4CF  		call	rddir			; Read FCB's from directory
 335:	CEA8  CD87CF  		call	tstfct			; Test last FCB
 336:	CEAB  C8      		ret	Z			; Yes then exit
 337:	CEAC  CD75CF  		call	caldir			; Calculate entry point FCB
 338:	CEAF  7E      		ld	a,(hl)			; Get first byte FCB
 339:	CEB0  FEE5    		cp	0e5h			; Test empty directory entry
 340:	CEB2  28EF    		jr	Z,initd2		; Yes then get next FCB
 341:	CEB4  FE21    		cp	021h			; Test time stamp
 342:	CEB6  28EB    		jr	Z,initd2		; Yes then get next FCB
 343:	CEB8  3A44C9  		ld	a,(user)		; Get user number
 344:	CEBB  BE      		cp	(hl)			; Test if user is same
 345:	CEBC  200B    		jr	NZ,initd3		; No then jump
 346:	CEBE  23      		inc	hl			; Point to file name
 347:	CEBF  7E      		ld	a,(hl)			; Get first char filename
 348:	CEC0  2B      		dec	hl
 349:	CEC1  D624    		sub	'$'			; Test if '$'
 350:	CEC3  2004    		jr	NZ,initd3		; Not then jump
 351:	CEC5  3D      		dec	a			; Load a with 0ffh
 352:	CEC6  324CC9  		ld	(subflg),a		; Save it in subflg
 353:	CEC9  0E01    	initd3:	ld	c,1			; Set bit in alv buffer
 354:	CECB  CD5ED0  		call	fillbb			; Set bits from FCB in alv buffer
 355:	CECE  CD8ECF  		call	setlf			; Update last file count
 356:	CED1  18D0    		jr	initd2			;
 357:			;
 358:			; Set drive bit from (defdrv) in HL
 359:			;	Exit:	DE = HL before setting bit (if any)
 360:			;
 361:	CED3  EB      	sdrvb:	ex	de,hl			; Copy hl=>de
 362:	CED4  210100  		ld	hl,1			; Get mask drive "a"
 363:	CED7  3A46C9  		ld	a,(defdrv)		; Get current drive
 364:	CEDA  B7      		or	a			; Test if drive "a"
 365:	CEDB  2804    		jr	Z,sdrvb1		; Yes then done
 366:	CEDD  29      	sdrvb0:	add	hl,hl			; Get next mask
 367:	CEDE  3D      		dec	a			; Decrement drive counter
 368:	CEDF  20FC    		jr	NZ,sdrvb0		; And test if done
 369:	CEE1  7A      	sdrvb1:	ld	a,d			; Hl=hl or de
 370:	CEE2  B4      		or	h
 371:	CEE3  67      		ld	h,a
 372:	CEE4  7B      		ld	a,e
 373:	CEE5  B5      		or	l
 374:	CEE6  6F      		ld	l,a
 375:	CEE7  C9      		ret				; Exit
 376:			
 377:			;
 378:			; Calculate sector/track directory
 379:			;
 380:	CEE8          	stdir:
 381:	CEE8  2A49C9  		ld	hl,(filcnt)		; Get FCB counter directory
 382:	CEEB  CB3C    		srl	h			; Divide by 4
 383:	CEED  CB1D    		rr	l			; (4 FCB's / sector)
 384:	CEEF  CB3C    		srl	h
 385:	CEF1  CB1D    		rr	l
 386:	CEF3  2247C9  		ld	(recdir),hl		; Save value (used by checksum)
 387:	CEF6  EB      		ex	de,hl			; Copy it to de
 388:	CEF7  210000  		ld	hl,0			; Clear hl
 389:			;
 390:			; Calculate sector/track
 391:			;	Entry:	hl,de = sector number (128 byte sector)
 392:			;	Exit:	set track  = hl,de  /  maxsec
 393:			;		set sector = hl,de mod maxsec
 394:			;
 395:	CEFA  ED4B27C9	calst:	ld	bc,(maxsec)		; Get sectors/track
 396:	CEFE  3E11    		ld	a,17			; Set up loop counter
 397:	CF00  B7      	calst0:	or	a			; Test hl>=bc
 398:	CF01  ED42    		sbc	hl,bc
 399:	CF03  3F      		ccf
 400:	CF04  3802    		jr	C,calst1		; Yes then jump
 401:	CF06  09      		add	hl,bc			; No then restore hl
 402:	CF07  B7      		or	a			; And clear carry
 403:	CF08  CB13    	calst1:	rl	e			; Shift result in de
 404:	CF0A  CB12    		rl	d
 405:	CF0C  3D      		dec	a			; Test last bit done
 406:	CF0D  2806    		jr	Z,calst2		; Yes then exit
 407:	CF0F  CB15    		rl	l			; Shift next bit in hl
 408:	CF11  CB14    		rl	h
 409:	CF13  18EB    		jr	calst0			; Continue
 410:	CF15  E5      	calst2:	push	hl			; Save sector number
 411:	CF16  2A34C9  		ld	hl,(nftrk)		; Get first track
 412:	CF19  19      		add	hl,de			; Add track number
 413:	CF1A  44      		ld	b,h			; Copy it to bc
 414:	CF1B  4D      		ld	c,l
 415:	CF1C  CD1ED7  		call	SetTrk			; BIOS call set track
 416:	CF1F  C1      		pop	bc			; Restore sector number
 417:	CF20  ED5B1BC9		ld	de,(trans)		; Get translation table address
 418:	CF24  CD30D7  		call	SecTrn			; BIOS call sector translation
 419:	CF27  44      		ld	b,h			; Copy result to bc
 420:	CF28  4D      		ld	c,l
 421:	CF29  C321D7  		jp	SetSec			; BIOS call set sector
 422:			;
 423:			; Get disk map block number from FCB
 424:			;
 425:			; Exit: HL = address FCB
 426:			;	DE = disk map
 427:			;	BC = offset in disk map
 428:			;
 429:	CF2C  DD4E20  	getdm:	ld	c,(ix+32)		; Get next record
 430:	CF2F  3A29C9  		ld	a,(nblock)		; Get number of blocks
 431:	CF32  47      		ld	b,a			; Save it
 432:	CF33  CB39    	getdm0:	srl	c			; Shift next record
 433:	CF35  10FC    		djnz	getdm0			; Number of blocks times
 434:	CF37  2F      	getdm1:	cpl				; Complement number of blocks
 435:	CF38  C609    		add	a,9			; Add 9
 436:	CF3A  47      		ld	b,a			; B=8-number of blocks
 437:	CF3B  3A2BC9  		ld	a,(nextnd)		; Get extend mask
 438:	CF3E  DDA60C  		and	(ix+12)			; Mask with extend
 439:	CF41  0F      		rrca				; Rotate one right
 440:	CF42  07      	getdm2:	rlca				; Rotate one left
 441:	CF43  10FD    		djnz	getdm2			; 8-number of blocks times
 442:	CF45  81      	getdm3:	add	a,c			; Add the two values to get entry FCB
 443:	CF46  DDE5    	getdm4:	push	ix			; Get FCB address
 444:	CF48  E1      		pop	hl
 445:	CF49  0E10    		ld	c,16			; Add offset 16 to point to dm
 446:	CF4B  09      		add	hl,bc
 447:	CF4C  4F      		ld	c,a			; Add entry FCB
 448:	CF4D  09      		add	hl,bc
 449:	CF4E  3A2DC9  		ld	a,(maxlen+1)		; Test 8 bits/16 bits FCB entry
 450:	CF51  B7      		or	a
 451:	CF52  2003    		jr	NZ,getdm5		; 16 bits => jump
 452:	CF54  5E      		ld	e,(hl)			; Get 8 bit value
 453:	CF55  57      		ld	d,a			; Make MSB zero
 454:	CF56  C9      		ret				; And exit
 455:	CF57  09      	getdm5:	add	hl,bc			; Add twice (16 bit values)
 456:	CF58  5E      		ld	e,(hl)			; Get LSB
 457:	CF59  23      		inc	hl			; Increment pointer
 458:	CF5A  56      		ld	d,(hl)			; Get MSB
 459:	CF5B  2B      		dec	hl			; Decrement pointer
 460:	CF5C  C9      		ret				; And exit
 461:			;
 462:			; Calculate sector number
 463:			;  entry: de=block number from FCB
 464:			;
 465:	CF5D  210000  	calsec:	ld	hl,0			; Clear MSB sector number
 466:	CF60  3A29C9  		ld	a,(nblock)		; Get loop counter
 467:	CF63  47      		ld	b,a			; Save it in b
 468:	CF64  CB23    	calsc0:	sla	e			; Shift l,d,e
 469:	CF66  CB12    		rl	d
 470:	CF68  CB15    		rl	l
 471:	CF6A  10F8    		djnz	calsc0			; B times
 472:	CF6C  3A2AC9  	calsc1:	ld	a,(nmask)		; Get sector mask
 473:	CF6F  DDA620  		and	(ix+32)			; And with next record
 474:	CF72  B3      		or	e			; Set up LSB sector number
 475:	CF73  5F      		ld	e,a
 476:	CF74  C9      		ret				; And exit
 477:			;
 478:			; Calculate dirbuf entry point
 479:			;
 480:	CF75  2A1FC9  	caldir:	ld	hl,(dirbuf)		; Get start address dirbuf
 481:	CF78  3A4BC9  		ld	a,(secpnt)		; Get sector pointer
 482:	CF7B  85      		add	a,l			; Add l=l+a
 483:	CF7C  6F      		ld	l,a
 484:	CF7D  D0      		ret	NC			; No carry exit
 485:	CF7E  24      		inc	h			; Increment h
 486:	CF7F  C9      		ret				; And exit
 487:			;
 488:			; Init file count
 489:			;
 490:	CF80  21FFFF  	setfct:	ld	hl,-1			; Set up file count
 491:	CF83  2249C9  		ld	(filcnt),hl		; Save it
 492:	CF86  C9      		ret				; And exit
 493:			;
 494:			; Test file count
 495:			;
 496:			; Exit:	Zero flag set and A = 0 if filcnt = 0ffffh
 497:			;
 498:	CF87  2A49C9  	tstfct:	ld	hl,(filcnt)		; Test file count=0ffffh
 499:	CF8A  7C      	 	ld	a,h			; Get MSB
 500:	CF8B  A5      		and	l			; And LSB
 501:	CF8C  3C      		inc	a			; Test if result=0ffh
 502:	CF8D  C9      		ret				; And exit
 503:			;
 504:			; Set last file
 505:			;
 506:	CF8E  CD97CF  	setlf:	call	tstlf			; Test last file
 507:	CF91  D8      		ret	C			; No then exit
 508:	CF92  13      		inc	de			; Increment last file
 509:	CF93  72      		ld	(hl),d			; Save it in temp0
 510:	CF94  2B      		dec	hl
 511:	CF95  73      		ld	(hl),e
 512:	CF96  C9      		ret				; And exit
 513:			;
 514:			; Test last file
 515:			;
 516:	CF97  2A1DC9  	tstlf:	ld	hl,(temp0)		; Get pointer to last file
 517:	CF9A  ED5B49C9		ld	de,(filcnt)		; Get file counter
 518:	CF9E  7B      		ld	a,e			; Subtract filcnt-(temp0)
 519:	CF9F  96      		sub	(hl)
 520:	CFA0  23      		inc	hl
 521:	CFA1  7A      		ld	a,d
 522:	CFA2  9E      		sbc	a,(hl)			; Carry means (temp0) > filcnt
 523:	CFA3  C9      		ret				; Exit
 524:			;
 525:			; Get next FCB from drive
 526:			;	Entry:	A = 0 check checksum
 527:			;		A = 0ffh update checksum
 528:			;
 529:	CFA4  4F      	rddir:	ld	c,a			; Save checksum flag
 530:	CFA5  2A49C9  		ld	hl,(filcnt)		; Get file counter
 531:	CFA8  23      		inc	hl			; Increment it
 532:	CFA9  2249C9  		ld	(filcnt),hl		; And save it
 533:	CFAC  ED5B2EC9		ld	de,(nfiles)		; Get maximum number of files
 534:	CFB0  B7      		or	a			; Clear carry
 535:	CFB1  ED52    		sbc	hl,de			; Test if last file
 536:	CFB3  19      		add	hl,de
 537:	CFB4  2802    		jr	Z,rddir0		; No, jump
 538:	CFB6  30C8    		jr	NC,setfct		; Yes, set file count to 0ffffh
 539:	CFB8  7D      	rddir0:	ld	a,l			; Get file count LSB
 540:	CFB9  87      		add	a,a			; *32
 541:	CFBA  87      		add	a,a
 542:	CFBB  87      		add	a,a
 543:	CFBC  87      		add	a,a
 544:	CFBD  87      		add	a,a
 545:	CFBE  E660    		and	060h			; Mask it
 546:	CFC0  324BC9  		ld	(secpnt),a		; Save it for later use
 547:	CFC3  C0      		ret	NZ			; Return if not first FCB sector
 548:	CFC4  C5      		push	bc			; Save checksum flag
 549:	CFC5  CDE8CE  		call	stdir			; Calculate sector/track directory
 550:	CFC8  CD0DD0  		call	readdr			; Read sector directory
 551:	CFCB  C1      		pop	bc			; Restore checksum flag
 552:			;
 553:			; Update/check checksum directory
 554:			; Entry C=0 check checksum, C=0ffh update checksum
 555:			;
 556:	CFCC  2A32C9  	chkdir:	ld	hl,(ncheck)		; Get number of checked records
 557:	CFCF  7C      		ld	a,h
 558:	CFD0  B5      		or	l
 559:	CFD1  C8      		ret	Z
 560:	CFD2  ED5B47C9		ld	de,(recdir)		; Get current record
 561:	CFD6  B7      		or	a			; Clear carry
 562:	CFD7  ED52    		sbc	hl,de			; Test current record
 563:	CFD9  C8      		ret	Z			; Exit if zero
 564:	CFDA  D8      		ret	C			; Exit if greater then ncheck
 565:	CFDB  2A1FC9  		ld	hl,(dirbuf)		; Get dirbuf
 566:	CFDE  0680    		ld	b,128			; Set up counter
 567:	CFE0  AF      		xor	a			; Clear checksum
 568:	CFE1  86      	chkdr0:	add	a,(hl)			; Add checksum
 569:	CFE2  23      		inc	hl			; Increment pointer
 570:	CFE3  10FC    		djnz	chkdr0			; 128 times
 571:	CFE5  2A23C9  		ld	hl,(csv)		; Get pointer checksum directory
 572:	CFE8  19      		add	hl,de			; Add current record
 573:	CFE9  0C      		inc	c			; Test checksum flag
 574:	CFEA  280E    		jr	Z,chkdr1		; 0ffh=> update checksum
 575:	CFEC  BE      		cp	(hl)			; Test checksum
 576:	CFED  C8      		ret	Z			; Exit if ok
 577:	CFEE  2A3AC9  		ld	hl,(diff)		; Get disk changed vector
 578:	CFF1  CDD3CE  		call	sdrvb			; Include drive bit
 579:	CFF4  223AC9  		ld	(diff),hl		; Save disk changed bit
 580:	CFF7  C38DD0  		jp	setfn			; Set # files to maximum
 581:	CFFA  77      	chkdr1:	ld	(hl),a			; Update checksum
 582:	CFFB  C9      		ret				; And exit
 583:			;
 584:			; Read sector from drive
 585:			;
 586:	CFFC  CD27D7  	readr:	call	dread			; BIOS call read sector
 587:	CFFF  1803    		jr	write0			; Test exit code
 588:			;
 589:			; Write sector on drive
 590:			;
 591:	D001  CD2AD7  	writer:	call	write			; BIOS call write sector
 592:	D004  B7      	write0:	or	a			; Test exit code
 593:	D005  C8      		ret	Z			; Exit if ok
 594:	D006  2A09C9  		ld	hl,(StRW)		; Point to data error routine
 595:	D009  3253C9  		ld	(retflg),a		; Allow retry for read/write errors
 596:	D00C  E9      		jp	(hl)			; Display "Data error on d:"
 597:			;
 598:			; Read directory from drive
 599:			;
 600:	D00D  CD2ED0  	readdr:	call	DMAdir			; Set up DMA directory
 601:	D010  CDFCCF  		call	readr			; Read record
 602:	D013  1813    		jr	stDMA			; Set up DMA user
 603:			;
 604:			; Write directory on drive
 605:			;
 606:	D015  0EFF    	writdr:	ld	c,0ffh			; Update checksum directory
 607:	D017  CDCCCF  		call	chkdir
 608:	D01A  CD2ED0  		call	DMAdir			; Set up DMA directory
 609:	D01D  0E01    		ld	c,1			; Write directory flag
 610:	D01F  CD01D0  		call	writer			; Write record
 611:	D022  1804    		jr	stDMA			; Set up DMA user
 612:			;
 613:			; Set DMA address command
 614:			;
 615:	D024  ED533CC9	cmnd26:	ld	(DMA),de		; Save DMA address
 616:			;
 617:	D028  ED4B3CC9	stDMA:	ld	bc,(DMA)		; Get DMA address
 618:	D02C  1804    		jr	DMAdr0			; And do BIOS call
 619:			;
 620:			; Set DMA address directory
 621:			;
 622:	D02E  ED4B1FC9	DMAdir:	ld	bc,(dirbuf)		; Get DMA address directory
 623:	D032  C324D7  	DMAdr0:	jp	setDMA			; BIOS call set DMA
 624:			
 625:			;
 626:			; Get bit from allocation vector buffer
 627:			;
 628:			;	Entry:	DE = block number
 629:			;	Exit:	A  = bit in LSB
 630:			;		B  = bitnumber in a
 631:			;		HL = pointer in alv buffer
 632:			;
 633:	D035  7B      	getbit:	ld	a,e			; Get bit number
 634:	D036  E607    		and	7			; Mask it
 635:	D038  3C      		inc	a			; Add 1
 636:	D039  47      		ld	b,a			; Save it
 637:	D03A  4F      		ld	c,a			; Twice
 638:	D03B  CB3A    		srl	d			; Get byte number
 639:	D03D  CB1B    		rr	e			; De=de/8
 640:	D03F  CB3A    		srl	d
 641:	D041  CB1B    		rr	e
 642:	D043  CB3A    		srl	d
 643:	D045  CB1B    		rr	e
 644:	D047  2A25C9  		ld	hl,(alv)		; Get start address alv buffer
 645:	D04A  19      		add	hl,de			; Add byte number
 646:	D04B  7E      		ld	a,(hl)			; Get 8 bits
 647:	D04C  07      	getbt0:	rlca				; Get correct bit
 648:	D04D  10FD    		djnz	getbt0
 649:	D04F  41      		ld	b,c			; Restore bit number
 650:	D050  C9      		ret				; And return to caller
 651:			;
 652:			; Set/reset bit in allocation vector buffer
 653:			;	Entry	DE = block number
 654:			;		 C = 0 reset bit, c=1 set bit
 655:			;
 656:	D051  C5      	setbit:	push	bc			; Save set/reset bit
 657:	D052  CD35D0  		call	getbit			; Get bit
 658:	D055  E6FE    		and	0feh			; Mask it
 659:	D057  D1      		pop	de			; Get set/reset bit
 660:	D058  B3      		or	e			; Set/reset bit
 661:	D059  0F      	setbt0:	rrca				; Rotate bit in correct position
 662:	D05A  10FD    		djnz	setbt0
 663:	D05C  77      		ld	(hl),a			; Save 8 bits
 664:	D05D  C9      		ret				; And return to caller
 665:			;
 666:			; Fill bit buffer from FCB in dirbuf
 667:			;	Entry:	C = 0 reset bit
 668:			;		C = 1 set bit
 669:			;
 670:	D05E          	fillbb:;	call	caldir			; Get directory entry
 671:	D05E  111000  		ld	de,16			; Get offset dm block
 672:	D061  19      		add	hl,de			; Add offset
 673:	D062  43      		ld	b,e			; Get block counter
 674:	D063  5E      	fillb0:	ld	e,(hl)			; Get LSB block number
 675:	D064  23      		inc	hl			; Increment pointer
 676:	D065  1600    		ld	d,0			; Reset MSB block number
 677:	D067  3A2DC9  		ld	a,(maxlen+1)		; Test >256 blocks present
 678:	D06A  B7      		or	a
 679:	D06B  2803    		jr	Z,fillb1		; No then jump
 680:	D06D  05      		dec	b			; Decrement block counter
 681:	D06E  56      		ld	d,(hl)			; Get correct MSB
 682:	D06F  23      		inc	hl			; Increment pointer
 683:	D070  7A      	fillb1:	ld	a,d			; Test block number
 684:	D071  B3      		or	e
 685:	D072  280D    		jr	Z,fillb2		; Zero then get next block
 686:	D074  E5      		push	hl			; Save pointer
 687:	D075  C5      		push	bc			; Save counter and set/reset bit
 688:	D076  2A2CC9  		ld	hl,(maxlen)		; Get maximum lenght alv buffer
 689:	D079  B7      		or	a			; Reset carry
 690:	D07A  ED52    		sbc	hl,de			; Test de<=maxlen alv buffer
 691:	D07C  D451D0  		call	nc,setbit		; Yes then insert bit
 692:	D07F  C1      		pop	bc			; Get counter and set/reset bit
 693:	D080  E1      		pop	hl			; Get pointer
 694:	D081  10E0    	fillb2:	djnz	fillb0			; Repeat for all dm entries
 695:	D083  C9      		ret				; And return to caller
 696:			;
 697:			; Set write protect disk
 698:			;
 699:	D084          	cmnd28:
 700:	D084  2A36C9  		ld	hl,(dskro)		; Get disk R/O vector
 701:	D087  CDD3CE  		call	sdrvb			; Include drive bit
 702:	D08A  2236C9  		ld	(dskro),hl		; Save disk R/O bit
 703:	D08D  ED5B2EC9	setfn:	ld	de,(nfiles)		; Get maximum number of files-1
 704:	D091  13      		inc	de			; Increment it
 705:	D092  2A1DC9  		ld	hl,(temp0)		; Get pointer to disk parameter block
 706:	D095  73      		ld	(hl),e			; And save number of files
 707:	D096  23      		inc	hl
 708:	D097  72      		ld	(hl),d
 709:	D098  C9      		ret				; And return to caller
 710:			;
 711:			; Check file R/O bit
 712:			;
 713:	D099  CD75CF  	chkfro:	call	caldir			; Get directory entry
 714:	D09C  110900  		ld	de,9			; Offset to file R/O bit <crw>
 715:	D09F  19      		add	hl,de			; Add offset
 716:	D0A0  CB7E    		bit	7,(hl)			; Test file R/O
 717:	D0A2  2009    		jr	NZ,chkfr2		; Yes then error
 718:			;
 719:			; System files are R/O if referenced with wildcards:
 720:			;
 721:	D0A4  3A51C9  		ld	a,(searqu)		; Test if question mark used <crw>
 722:	D0A7  B7      		or	a			; Test question mark used
 723:	D0A8  C8      		ret	Z			; No then don't test system file bit
 724:	D0A9  23      		inc	hl			; Increment to system file
 725:	D0AA  CB7E    		bit	7,(hl)			; Test system file
 726:	D0AC  C8      		ret	Z			; No system file then ok
 727:	D0AD          	chkfr2:
 728:	D0AD  2A0FC9  		ld	hl,(sfilro)		; Get pointer to file R/O message
 729:	D0B0  E9      		jp	(hl)			; Display message
 730:			
 731:			;
 732:			; Check drive read only
 733:			;
 734:	D0B1  2A36C9  	chkro:	ld	hl,(dskro)		; Get drive R/O vector
 735:	D0B4  CDD3CE  		call	sdrvb			; Set drive bit
 736:	D0B7  ED52    		sbc	hl,de			; Test extra bit added
 737:	D0B9  C0      		ret	NZ			; Yes then drive not R/O
 738:	D0BA  2A0DC9  		ld	hl,(stro)		; Get pointer to drive R/O message
 739:	D0BD  E9      		jp	(hl)			; Display message
 740:			
 741:			;
 742:			; Get free block from allocation vector buffer
 743:			;	Entry:	DE = old block number
 744:			;	Exit:	DE = new block number (0 if no free block)
 745:			; HL counts up
 746:			; DE counts down
 747:			;
 748:	D0BE  62      	getfre:	ld	h,d			; Copy old block to hl
 749:	D0BF  6B      		ld	l,e
 750:	D0C0  7A      	getfr0:	ld	a,d			; Test down counter is zero
 751:	D0C1  B3      		or	e
 752:	D0C2  280B    		jr	Z,getfr1		; Yes then jump
 753:	D0C4  1B      		dec	de			; Decrememt down counter
 754:	D0C5  E5      		push	hl			; Save up/down counter
 755:	D0C6  D5      		push	de
 756:	D0C7  CD35D0  		call	getbit			; Get bit from alv buffer
 757:	D0CA  1F      		rra				; Test if zero
 758:	D0CB  301F    		jr	NC,getfr3		; Yes then found empty block
 759:	D0CD  D1      		pop	de			; Get up/down counter
 760:	D0CE  E1      		pop	hl
 761:	D0CF  ED4B2CC9	getfr1:	ld	bc,(maxlen)		; Get maximum alv lenght-1 in bc
 762:	D0D3  B7      		or	a			; Clear carry
 763:	D0D4  ED42    		sbc	hl,bc			; Test hl>=lenght alv-1
 764:	D0D6  09      		add	hl,bc			; Restore hl (flags are not affected)
 765:	D0D7  300E    		jr	NC,getfr2		; End buffer then jump
 766:	D0D9  23      		inc	hl			; Increment up counter
 767:	D0DA  D5      		push	de			; Save down/up counter
 768:	D0DB  E5      		push	hl
 769:	D0DC  EB      		ex	de,hl			; Save up counter in de
 770:	D0DD  CD35D0  		call	getbit			; Get bit from alv buffer
 771:	D0E0  1F      		rra				; Test if zero
 772:	D0E1  3009    		jr	NC,getfr3		; Yes then found empty block
 773:	D0E3  E1      		pop	hl			; Get down/up counter
 774:	D0E4  D1      		pop	de
 775:	D0E5  18D9    		jr	getfr0			; And test next block
 776:	D0E7  7A      	getfr2:	ld	a,d			; Test if last block tested
 777:	D0E8  B3      		or	e
 778:	D0E9  20D5    		jr	NZ,getfr0		; No then test next block
 779:	D0EB  C9      		ret				; Exit (de=0)
 780:	D0EC  37      	getfr3:	scf				; Set block number used
 781:	D0ED  17      		rla				; Save bit
 782:	D0EE  CD59D0  		call	setbt0			; Put bit in alv buffer
 783:	D0F1  D1      		pop	de			; Get correct counter
 784:	D0F2  E1      		pop	hl			; Restore stack pointer
 785:	D0F3  C9      		ret				; Exit (de=block number)
 786:			
 787:			;
 788:			; Entry point to search for a file that is currently open
 789:			;
 790:			
 791:	D0F4  3E0F    	sear0:	ld	a,15			; Match first 15 bytes
 792:	D0F6  3250C9  	sear01:	ld	(searnb),a		; Save number of bytes
 793:	D0F9  DD7E0D  		ld	a,(ix+13)		; Check if =FF, if was, use normal
 794:	D0FC  3C      		inc	a			; search routine
 795:	D0FD  282A    		jr	Z,sr1
 796:	D0FF  CD18D7  		call	home			; Force BIOS directory read
 797:	D102  DD6E0D  		ld	l,(ix+13)		; Get sector of directory file was on
 798:	D105  2600    		ld	h,0			; *4 to satisify internal data base
 799:	D107  CB25    		sla	l
 800:	D109  CB14    		rl	h
 801:	D10B  CB25    		sla	l
 802:	D10D  CB14    		rl	h
 803:	D10F  2249C9  		ld	(filcnt),hl		; Place in internal data base
 804:	D112  E5      		push	hl
 805:	D113  CDE8CE  		call	stdir			; Get sec-trk of directory entry
 806:	D116  CD0DD0  		call	readdr			; Read it to memory
 807:	D119  E1      		pop	hl
 808:	D11A  2B      		dec	hl			; -1, will be +1 in readdr
 809:	D11B  2249C9  		ld	(filcnt),hl
 810:	D11E  180F    		jr	sear1
 811:			
 812:			;
 813:			; Find file name only
 814:			;
 815:	D120  3E0C    	findfn:	ld	a,12
 816:	D122  1802    		jr	search
 817:			;
 818:			; Find file
 819:			;
 820:	D124  3E0F    	findf:	ld	a,15			; Number of bytes to search for
 821:			
 822:			;
 823:			; Search for file name
 824:			;	Entry:	A = number of bytes to search for
 825:			;
 826:			
 827:	D126          	search:
 828:	D126  3250C9  		ld	(searnb),a		; Save number of bytes
 829:	D129  CD80CF  	sr1:	call	setfct			; Initiate file counter
 830:	D12C  CD18D7  		call	home			; Force BIOS directory read
 831:	D12F  3EFF    	sear1:	ld	a,0ffh			; Set exit code to 0ffh (not found)
 832:	D131  324FC9  		ld	(searex),a
 833:	D134  DD224DC9		ld	(dcopy),ix		; Copy FCB pointer to ram (search next)
 834:			
 835:			;					; ..after disk change
 836:			; Search next file name
 837:			;
 838:	D138  AF      	SearcN:	xor	a			; Clear accu, check checksum dir.
 839:	D139  3251C9  		ld	(searqu),a		; Clear question mark detected flag
 840:	D13C  3252C9  		ld	(searpu),a		; Clear public file flag
 841:	D13F  CDA4CF  		call	rddir			; Get FCB from directory
 842:	D142  CD87CF  		call	tstfct			; Test if past last entry
 843:	D145  CAC0D1  		jp	Z,searc8		; Yes then jump
 844:	D148  ED5B4DC9		ld	de,(dcopy)		; Get FCB pointer
 845:	D14C  1A      		ld	a,(de)			; Get first byte
 846:	D14D  FEE5    		cp	0e5h			; Test if searching empty directory
 847:	D14F  2807    		jr	Z,searc1		; Yes then jump
 848:	D151  D5      		push	de			; Save FCB pointer
 849:	D152  CD97CF  		call	tstlf			; Test last file on this drive
 850:	D155  D1      		pop	de			; Restore FCB pointer
 851:	D156  3068    		jr	NC,searc8		; Yes then jump
 852:	D158  CD75CF  	searc1:	call	caldir			; Get entry in directory
 853:	D15B  7E      		ld	a,(hl)			; Get first byte directory entry
 854:	D15C  FE21    		cp	021h			; Test time stamp
 855:	D15E  28D8    		jr	Z,searcn		; Yes then get next directory entry
 856:	D160  3A50C9  		ld	a,(searnb)		; Get number of bytes to search for
 857:	D163  47      		ld	b,a			; Save it in counter
 858:	D164  AF      		xor	a			; Clear accu
 859:	D165  4F      		ld	c,a			; Clear counter
 860:	D166  78      	searc2:	ld	a,b			; Test if counter is zero
 861:	D167  B7      		or	a
 862:	D168  285F    		jr	Z,searc9		; Yes then jump
 863:	D16A  1A      		ld	a,(de)			; Get byte from FCB
 864:	D16B  EE3F    		xor	'?'			; Test if question mark
 865:	D16D  E67F    		and	07fh			; Mask it (remove high bit)
 866:	D16F  283C    		jr	Z,searc6		; Yes then jump
 867:	D171  79      		ld	a,c			; Get FCB counter
 868:	D172  B7      		or	a			; Test whether first byte
 869:	D173  2023    		jr	NZ,searc3		; No
 870:	D175  3A15C9  		ld	a,(flags)		; Yes. get flag byte
 871:	D178  CB47    		bit	0,a			; Test public file enable
 872:	D17A  281C    		jr	Z,searc3		; No
 873:	D17C  23      		inc	hl			; Yes. get pointer to public bit
 874:	D17D  23      		inc	hl
 875:	D17E  CB7E    		bit	7,(hl)			; Test public bit directory
 876:	D180  2B      		dec	hl			; Restore pointer
 877:	D181  2B      		dec	hl
 878:	D182  2814    		jr	Z,searc3		; No public file then jump
 879:	D184  1A      		ld	a,(de)			; Get first byte FCB
 880:	D185  FEE5    		cp	0e5h			; Test if searching empty directory
 881:	D187  280F    		jr	Z,searc3		; Yes then jump
 882:	D189  AE      		xor	(hl)			; Test FCB=directory entry
 883:	D18A  E67F    		and	07fh			; Mask it
 884:	D18C  2819    		jr	Z,searc5		; Yes then jump
 885:	D18E  E6E0    		and	0e0h			; Mask user number
 886:	D190  2006    		jr	NZ,searc3		; Not the same then jump
 887:	D192  3D      		dec	a			; A=0ffh
 888:	D193  3252C9  		ld	(searpu),a		; Set public file found
 889:	D196  180F    		jr	searc5			; Jump found
 890:	D198  79      	searc3:	ld	a,c			; Get FCB counter
 891:	D199  FE0D    		cp	13			; Test if at user code
 892:	D19B  280A    		jr	Z,searc5		; Yes then no test
 893:	D19D  FE0C    		cp	12			; Test if at extend number
 894:	D19F  1A      		ld	a,(de)			; Get byte from FCB
 895:	D1A0  2811    		jr	Z,searc7		; Jump if extent number
 896:	D1A2  AE      		xor	(hl)			; Test byte FCB=byte directory entry
 897:	D1A3  E67F    		and	07fh			; Mask it
 898:	D1A5  2091    	searc4:	jr	NZ,searcn		; Not the same then get next entry
 899:	D1A7  13      	searc5:	inc	de			; Increment pointer FCB
 900:	D1A8  23      		inc	hl			; Increment pointer directory entry
 901:	D1A9  0C      		inc	c			; Increment counter
 902:	D1AA  05      		dec	b			; Decrement counter
 903:	D1AB  18B9    		jr	searc2			; Test next byte
 904:	D1AD  3D      	searc6:	dec	a			; Set question mark found flag
 905:	D1AE  3251C9  		ld	(searqu),a
 906:	D1B1  18F4    		jr	searc5			; Jump found
 907:	D1B3  C5      	searc7:	push	bc			; Save counters
 908:	D1B4  AE      		xor	(hl)			; Test extends
 909:	D1B5  47      		ld	b,a			; Save it
 910:	D1B6  3A2BC9  		ld	a,(nextnd)		; Get extent mask
 911:	D1B9  2F      		cpl				; Complement it
 912:	D1BA  E61F    		and	01fh			; Mask it
 913:	D1BC  A0      		and	b			; Mask extents
 914:	D1BD  C1      		pop	bc			; Restore counters
 915:	D1BE  18E5    		jr	searc4			; And test result
 916:	D1C0  CD80CF  	searc8:	call	setfct			; Error set file counter
 917:	D1C3  3EFF    		ld	a,0ffh			; And set exit code
 918:	D1C5  323FC9  		ld	(pexit),a
 919:	D1C8  C9      		ret				; Return to caller
 920:	D1C9  3A51C9  	searc9:	ld	a,(searqu)		; Get question mark found flag
 921:	D1CC  47      		ld	b,a			; Save it
 922:	D1CD  3A52C9  		ld	a,(searpu)		; Get public file flag
 923:	D1D0  A0      		and	b			; Test if public file and question mark
 924:	D1D1  20D2    		jr	NZ,searc4		; Yes then search for next entry
 925:	D1D3  CD8ECF  		call	setlf			; Update last file count (empty FCB)
 926:	D1D6  3A49C9  		ld	a,(filcnt)		; Get file counter
 927:	D1D9  E603    		and	3			; Mask it
 928:	D1DB  323FC9  		ld	(pexit),a		; And set exit code
 929:	D1DE  AF      		xor	a			; Clear exit code search
 930:	D1DF  324FC9  		ld	(searex),a
 931:	D1E2  C9      		ret				; And return to caller
 932:			;
 933:			; Delete file
 934:			;
 935:	D1E3  CDB1D0  	delete:	call	chkro			; Check disk R/O
 936:	D1E6  CD20D1  		call	findfn
 937:	D1E9  CD87CF  	del0:	call	tstfct			; Test if file found
 938:	D1EC  C8      		ret	Z			; Not then exit
 939:	D1ED  CD99D0  		call	chkfro			; Check file R/O
 940:	D1F0  CD75CF  		call	caldir			; Get entry point directory
 941:	D1F3  36E5    		ld	(hl),0e5h		; Remove file
 942:	D1F5  0E00    		ld	c,0			; Remove bits alv buffer
 943:	D1F7  CD5ED0  		call	fillbb
 944:	D1FA  CD88D2  		call	wrFCB			; Write directory buffer on disk
 945:	D1FD  CD38D1  		call	searcn			; Search next entry
 946:	D200  18E7    		jr	del0			; And test it
 947:			;
 948:			; Rename file
 949:			;
 950:	D202  CDB1D0  	renam:	call	chkro			; Check disk R/O
 951:	D205  CD20D1  		call	findfn
 952:	D208  CD87CF  	renam0:	call	tstfct			; Test if file found
 953:	D20B  C8      		ret	Z			; Not then exit
 954:	D20C  CD99D0  		call	chkfro			; Check file R/O
 955:	D20F  DDE5    		push	ix			; Save FCB entry
 956:	D211  E1      		pop	hl			; Get it in hl
 957:	D212  111000  		ld	de,16			; Offset to new name
 958:	D215  19      		add	hl,de			; Add offset
 959:	D216  EB      		ex	de,hl			; Copy hl=>de
 960:	D217  CD75CF  		call	caldir			; Get directory entry
 961:	D21A  060B    		ld	b,11			; Set up loop counter
 962:	D21C  23      	renam1:	inc	hl			; Increment directory pointer
 963:	D21D  13      		inc	de			; Increment FCB pointer
 964:	D21E  1A      		ld	a,(de)			; Get character from FCB
 965:	D21F  E67F    		and	07fh			; Mask it
 966:	D221  FE3F    		cp	'?'			; Test if question mark
 967:	D223  2806    		jr	Z,renam2		; Yes then do not change char. on disk
 968:	D225  4F      		ld	c,a			; Save it in c
 969:	D226  7E      		ld	a,(hl)			; Get character from directory
 970:	D227  E680    		and	080h			; Mask status bit
 971:	D229  B1      		or	c			; Or with new character
 972:	D22A  77      		ld	(hl),a			; Save in directory
 973:	D22B  10EF    	renam2:	djnz	renam1			; Loop until done
 974:	D22D  CD88D2  		call	wrFCB			; And write directory on disk
 975:	D230  CD38D1  		call	searcn			; Search next file
 976:	D233  18D3    		jr	renam0			; And test it
 977:			;
 978:			; Change status file
 979:			;
 980:	D235  CDB1D0  	cstat:	call	chkro			; Check disk R/O
 981:	D238  CD20D1  		call	findfn
 982:	D23B  CD87CF  	cstat0:	call	tstfct			; Test if file found
 983:	D23E  C8      		ret	Z			; Not then exit
 984:	D23F  DDE5    		push	ix			; Save FCB entry
 985:	D241  D1      		pop	de			; Get it in hl
 986:	D242  CD75CF  		call	caldir			; Get directory entry
 987:	D245  060B    		ld	b,11			; Set up loop counter
 988:	D247  23      	cstat1:	inc	hl			; Increment directory pointer
 989:	D248  13      		inc	de			; Increment FCB pointer
 990:	D249  1A      		ld	a,(de)			; Get status bit from FCB
 991:	D24A  E680    		and	080h			; Mask it
 992:	D24C  4F      		ld	c,a			; Save it in c
 993:	D24D  7E      		ld	a,(hl)			; Get character from directory
 994:	D24E  E67F    		and	07fh			; Mask it
 995:	D250  B1      		or	c			; Or with new status bit
 996:	D251  77      		ld	(hl),a			; Save in directory
 997:	D252  10F3    		djnz	cstat1			; Loop until done
 998:	D254  CD88D2  		call	wrFCB			; And write directory to disk
 999:	D257  CD38D1  		call	searcn			; Search next file
1000:	D25A  18DF    		jr	cstat0			; And test it
1001:			;
1002:			; Compute file size
1003:			;
1004:	D25C  010000  	filsz:	ld	bc,0			; Reset file size lenght
1005:	D25F  51      		ld	d,c
1006:	D260  CDC6CD  		call	ldrrc			; Save it in FCB+33,34,35
1007:	D263  CD20D1  		call	findfn
1008:	D266  CD87CF  	filsz0:	call	tstfct			; Test if file found
1009:	D269  C8      		ret	Z			; Not then exit
1010:	D26A  CD75CF  		call	caldir			; Get directory entry
1011:	D26D  EB      		ex	de,hl			; Copy to de
1012:	D26E  210F00  		ld	hl,15			; Offset to next record
1013:	D271  CD20D6  		call	calrrc			; Calculate random record count
1014:	D274  7A      		ld	a,d			; Test LSB < (ix+33)
1015:	D275  DD9621  		sub	(ix+33)
1016:	D278  79      		ld	a,c			; Test isb < (ix+34)
1017:	D279  DD9E22  		sbc	a,(ix+34)
1018:	D27C  78      		ld	a,b			; Test MSB < (ix+35)
1019:	D27D  DD9E23  		sbc	a,(ix+35)
1020:	D280  D4C6CD  		call	nc,ldrrc		; Write new maximum
1021:	D283  CD38D1  		call	searcn			; Search next file
1022:	D286  18DE    		jr	filsz0			; And test it
1023:			;
1024:			; Write FCB on disk
1025:			;
1026:	D288  CDE8CE  	wrFCB:	call	stdir			; Calculate sector/track directory
1027:	D28B  C315D0  		jp	writdr			; Write directory on disk
1028:			
1029:			;
1030:			; Calculate sector of file opened in FCB
1031:			;
1032:	D28E  CD87CF  	cmd15:	call	tstfct			; Look for ffff
1033:	D291  2809    		jr	Z,cmd151		; yes, save ff, can't do fast lookup
1034:	D293  CB3C    		srl	h			; HL=(filcnt)/4-1
1035:	D295  CB1D    		rr	l
1036:	D297  CB3C    		srl	h
1037:	D299  CB1D    		rr	l
1038:	D29B  2D      		dec	l
1039:	D29C  DD750D  	cmd151:	ld	(ix+13),l		; Save in FCB+13 for use in SEAR0
1040:	D29F  C9      		ret
1041:			;
1042:			; Open file
1043:			;
1044:	D2A0  CDF0CD  	cmnd15:	call	seldrv			; Select drive from FCB
1045:	D2A3  DD360E00		ld	(ix+14),0		; Clear FCB+14
1046:			
1047:	D2A7  CD24D1  	openf:	call	findf			; Find file
1048:	D2AA  CD87CF  		call	tstfct			; Test file found
1049:	D2AD  C8      		ret	Z			; No then exit
1050:	D2AE          	openf0:
1051:	D2AE  DD7E0C  		ld	a,(ix+12)		; Get extent number from FCB
1052:	D2B1  F5      		push	af			; Save it
1053:	D2B2  CD75CF  		call	caldir			; Get directory entry
1054:	D2B5  E5      		push	hl			; Save it <crw>
1055:	D2B6  1E08    		ld	e,8			; Set access date/time <crw>
1056:	D2B8  CD45D6  		call	stime			; Zero flag set if stamps present <crw>
1057:	D2BB  E1      		pop	hl			; Get directory entry <crw>
1058:	D2BC  DDE5    		push	ix			; Save FCB entry
1059:	D2BE  D1      		pop	de			; Get in in de
1060:	D2BF  012000  		ld	bc,32			; Number of bytes to move
1061:	D2C2  EDB0    		ldir				; Move directory to FCB
1062:	D2C4  CC88D2  		call	Z,wrFCB			; Write to disk if stamps present <crw>
1063:	D2C7  DDCB0EFE		set	7,(ix+14)		; Set FCB/file not modified
1064:	D2CB  DD460C  		ld	b,(ix+12)		; Get extent number
1065:	D2CE  DD4E0F  		ld	c,(ix+15)		; Get next record number
1066:	D2D1  F1      		pop	af			; Get old extent number
1067:	D2D2  DD770C  		ld	(ix+12),a		; Save it
1068:	D2D5  B8      		cp	b			; Compare old and new extent number
1069:	D2D6  2806    		jr	Z,openf1		; Same then jump
1070:	D2D8  0E00    		ld	c,0			; Set next record count to 0
1071:	D2DA  3002    		jr	NC,openf1		; Old extent >= new extent then jump
1072:	D2DC  0E80    		ld	c,80h			; Set next record count to maximum
1073:	D2DE  DD710F  	openf1:	ld	(ix+15),c		; Save next record count
1074:	D2E1  CD8ED2  		call	cmd15			; Fill in FCB+13,fast lookup
1075:	D2E4  C9      		ret				; And return to caller
1076:			
1077:			;
1078:			; Close file command
1079:			;
1080:	D2E5  CDF0CD  	cmnd16:	call	seldrv			; select drive from FCB
1081:			;
1082:			; Close file
1083:			;
1084:	D2E8  DDCB0E7E	close:	bit	7,(ix+14)		; test FCB/file modified
1085:	D2EC  C0      		ret	NZ			; not then no close required
1086:	D2ED  CDB1D0  		call	chkro			; test disk R/O
1087:			;	ld	a,15			; number of bytes to search for
1088:			;	call	search			; search file
1089:			;	call	findf
1090:	D2F0  CDF4D0  		call	sear0			; Use fast search
1091:	D2F3  CD87CF  		call	tstfct			; test file present
1092:	D2F6  C8      		ret	Z			; no then exit
1093:	D2F7  CD99D0  		call	chkfro			; check file R/O
1094:	D2FA  CD75CF  		call	caldir			; get directory entry
1095:	D2FD  011000  		ld	bc,16			; offset to dm block
1096:	D300  09      		add	hl,bc			; add offset
1097:	D301  EB      		ex	de,hl			; save hl in de
1098:	D302  DDE5    		push	ix			; save FCB pointer
1099:	D304  E1      		pop	hl			; get it in hl
1100:	D305  09      		add	hl,bc			; add offset
1101:	D306  3A2DC9  		ld	a,(maxlen+1)		; test number of block >= 256
1102:	D309  B7      		or	a
1103:	D30A  2801    		jr	Z,close0		; no then jump
1104:	D30C  05      		dec	b			; set flag
1105:	D30D  CD59D3  	close0:	call	copydm			; copy and test blocks
1106:	D310  EB      		ex	de,hl			; exchange copy direction
1107:	D311  CD59D3  		call	copydm			; copy and test blocks
1108:	D314  EB      		ex	de,hl			; exchange copy direction
1109:	D315  203C    		jr	NZ,close4		; block not the same then error
1110:	D317  23      		inc	hl			; increment pointer FCB
1111:	D318  13      		inc	de			; increment pointer directory
1112:	D319  CB40    		bit	0,b			; test number of block >= 256
1113:	D31B  2803    		jr	Z,close1		; no then jump
1114:	D31D  23      		inc	hl			; increment pointer FCB
1115:	D31E  13      		inc	de			; increment pointer directory
1116:	D31F  0D      		dec	c			; decrement counter
1117:	D320  0D      	close1:	dec	c			; decrement counter
1118:	D321  20EA    		jr	NZ,close0		; not ready then jump
1119:	D323  21ECFF  		ld	hl,-20			; add -20 to get extent number
1120:	D326  19      		add	hl,de			; hL contains pointer to extent number
1121:	D327  DD7E0C  		ld	a,(ix+12)		; get extent number FCB
1122:	D32A  BE      		cp	(hl)			; compare with extent number directory
1123:	D32B  3808    		jr	C,close3		; fCB < directory then jump
1124:	D32D  77      		ld	(hl),a			; save extent number in directory
1125:	D32E  23      		inc	hl			; get pointer to next record
1126:	D32F  23      		inc	hl
1127:	D330  23      		inc	hl
1128:	D331  DD7E0F  		ld	a,(ix+15)		; get next record FCB
1129:	D334  77      	close2:	ld	(hl),a			; save next record in directory
1130:	D335  1E04    	close3:	ld	e,4			; Set last update date/time
1131:	D337  CD45D6  		call	stime			; Update time
1132:	D33A  CD75CF  		call	caldir			; Get directory entry
1133:	D33D  010B00  		ld	bc,11			; Point to archive byte
1134:	D340  09      		add	hl,bc
1135:	D341  CBBE    		res	7,(hl)			; reset archive bit
1136:	D343  DDCB0BBE		res	7,(ix+11)		; reset bit in FCB
1137:	D347  23      		inc	hl
1138:	D348  23      		inc	hl
1139:	D349  E5      		push	hl
1140:	D34A  CD8ED2  		call	cmd15			; Fill in FCB+13 for next fast lookup
1141:	D34D  7D      		ld	a,l
1142:	D34E  E1      		pop	hl
1143:	D34F  77      		ld	(hl),a
1144:	D350  C388D2  		jp	wrFCB			; write FCB on disk
1145:			;
1146:	D353  3EFF    	close4:	ld	a,0ffh			; flag error
1147:	D355  323FC9  		ld	(pexit),a
1148:	D358  C9      		ret				; and return to caller
1149:			;
1150:			; Copy and test disk map
1151:			;
1152:			;	Entry:	HL = pointer to first FCB
1153:			;		DE = pointer to second FCB
1154:			;		 B = 000h if less then 256 blocks
1155:			;		     0ffh if more or equal to 256 blocks
1156:			;	Exit:	Z  blocks are the same
1157:			;		NZ blocks are not the same
1158:			;
1159:	D359  7E      	copydm:	ld	a,(hl)			; get byte first FCB
1160:	D35A  CB40    		bit	0,b			; test number of blocks >=256
1161:	D35C  2803    		jr	Z,copyd0		; No then jump
1162:	D35E  23      		inc	hl			; Increment pointer
1163:	D35F  B6      		or	(hl)			; Test byte =0
1164:	D360  2B      		dec	hl			; Decrement pointer
1165:	D361  B7      	copyd0:	or	a			; Test block number is zero
1166:	D362  200B    		jr	NZ,copyd1		; No then compare blocks
1167:	D364  1A      		ld	a,(de)			; Copy block from other FCB in empty location
1168:	D365  77      		ld	(hl),a
1169:	D366  CB40    		bit	0,b			; Test number of blocks >=256
1170:	D368  C8      		ret	Z			; No then exit
1171:	D369  23      		inc	hl			; Increment to MSB block numbers
1172:	D36A  13      		inc	de
1173:	D36B  1A      		ld	a,(de)			; Copy block from other FCB in empty location
1174:	D36C  77      		ld	(hl),a
1175:	D36D  1807    		jr	copyd2			; Jump trick to save space
1176:	D36F  1A      	copyd1:	ld	a,(de)			; Get block number first FCB
1177:	D370  96      		sub	(hl)			; Test if the same
1178:	D371  C0      		ret	NZ			; Not then return
1179:	D372  B0      		or	b			; Test if >=256 blocks
1180:	D373  C8      		ret	Z			; No then return
1181:	D374  23      		inc	hl			; Increment to MSB block numbers
1182:	D375  13      		inc	de
1183:	D376  1A      	copyd2:	ld	a,(de)			; Get block number first FCB
1184:	D377  96      		sub	(hl)			; Test if the same
1185:	D378  2B      		dec	hl			; Decrement block FCB pointers
1186:	D379  1B      		dec	de
1187:	D37A  C9      		ret				; And exit to caller
1188:			
1189:			
1190:			;
1191:			; Entry point to use fast lookup to 'MAKE' next FCB entry for open file
1192:			;
1193:			
1194:	D37B  CD86D3  	maker:	call	mak0
1195:	D37E  F5      		push	af
1196:	D37F  3E01    		ld	a,1
1197:	D381  CDF6D0  		call	sear01
1198:	D384  181B    		jr	mak1
1199:			
1200:			;
1201:			; Common code for MAKE/MAKER
1202:			;
1203:	D386  CDB1D0  	mak0:	call	chkro			; Check drive R/O
1204:	D389  DD7E00  		ld	a,(ix+0)		; Get first byte FCB
1205:	D38C  DD3600E5		ld	(ix+0),0e5h		; Set first byte to empty file
1206:	D390  C9      		ret
1207:			
1208:			
1209:			;
1210:			; Make file command
1211:			;
1212:			
1213:	D391          	cmnd22:
1214:	D391  CDF0CD  		call	seldrv			; Select drive from FCB
1215:	D394  DD360E00		ld	(ix+14),0		; Clear FCB+14
1216:			;
1217:			; Make file
1218:			;
1219:	D398          	make:
1220:	D398  CD86D3  		call	mak0
1221:	D39B  F5      		push	af			; Save it
1222:	D39C  3E01    		ld	a,1			; Search for 1 byte
1223:	D39E  CD26D1  		call	search			; Search empty file
1224:	D3A1  F1      	mak1:	pop	af			; Get first byte FCB
1225:	D3A2  DD7700  		ld	(ix+0),a		; Restore it
1226:	D3A5  CD87CF  		call	tstfct			; Test empty file found
1227:	D3A8  C8      		ret	Z			; No then return error
1228:	D3A9  AF      		xor	a			; Clear FCB+13
1229:			;	ld	(ix+13),a
1230:	D3AA  DDE5    		push	ix			; Save FCB pointer
1231:	D3AC  E1      		pop	hl			; Get it back in hl
1232:	D3AD  110F00  		ld	de,15			; Prepare offset
1233:	D3B0  19      		add	hl,de			; Add it
1234:	D3B1  0611    		ld	b,17			; Set loop counter
1235:	D3B3  77      	make0:	ld	(hl),a			; Clear FCB+15 up to FCB+31
1236:	D3B4  23      		inc	hl			; Increment pointer
1237:	D3B5  10FC    		djnz	make0			; And clear all bytes
1238:	D3B7  1E02    		ld	e,2			; Set creation date
1239:	D3B9  CD45D6  		call	stime			; Update time in directory
1240:	D3BC  1E04    		ld	e,4			; Set last update date/time
1241:	D3BE  CD45D6  		call	stime			; Update time in directory
1242:	D3C1  1E08    		ld	e,8			; Set access date/time <crw>
1243:	D3C3  CD45D6  		call	stime
1244:	D3C6  DDCB0BBE		res	7,(ix+11)		; Reset archive bit if present
1245:			;	call	cmd15			; Fill in FCB for fast lookup
1246:			;	call	caldir			; Get directory entry
1247:			;	push	ix			; Save FCB entry
1248:			;	pop	de			; Get it in de
1249:	D3CA  CD75CF  		call	caldir			; get directory entry
1250:	D3CD  E5      		push	hl			; save directory pointer
1251:	D3CE  DDE5    		push	ix			; put fcb pointer on stack
1252:	D3D0  CD8ED2  		call	cmd15			; fill in FCB+13
1253:	D3D3  D1      		pop	de			; fcb pointer to DE
1254:	D3D4  E1      		pop	hl			; directory entry pointer
1255:			
1256:	D3D5  EB      		ex	de,hl			; Exchange FCB and directory entry
1257:	D3D6  012000  		ld	bc,32			; Number of bytes to move
1258:	D3D9  EDB0    		ldir				; Move bytes
1259:	D3DB  CD88D2  		call	wrFCB			; Write FCB on disk
1260:	D3DE  DDCB0EFE		set	7,(ix+14)		; Set FCB/file not modified
1261:	D3E2  C9      		ret				; And return to caller
1262:			;
1263:			; Open next extent
1264:			;
1265:	D3E3  DDCB0E7E	openex:	bit	7,(ix+14)		; Test if FCB/file modified (write)
1266:	D3E7  2027    		jr	NZ,openx2		; Not then jump
1267:	D3E9  CDE8D2  		call	close			; Close current FCB
1268:	D3EC  3A3FC9  		ld	a,(pexit)		; Get exit code
1269:	D3EF  3C      		inc	a			; Test if error
1270:	D3F0  C8      		ret	Z			; Yes then exit
1271:	D3F1  CD25D4  		call	calnex			; Calculate next extent
1272:	D3F4  381F    		jr	C,openx3		; Error then jump
1273:	D3F6  2027    		jr	NZ,openx5		; fCB present from close then jump
1274:	D3F8          	openx0:
1275:	D3F8  CDF4D0  		call	sear0			; Use fast lookup to find next extent
1276:	D3FB  CD87CF  	openx1:	call	tstfct			; Test if file found
1277:	D3FE  201F    		jr	NZ,openx5		; Yes then jump
1278:	D400  3A42C9  		ld	a,(rdwr)		; Test read/write flag
1279:	D403  B7      		or	a			; Test if read
1280:	D404  280F    		jr	Z,openx3		; Yes then error
1281:	D406  CD7BD3  		call	maker			; Make new extent if write
1282:	D409  CD87CF  		call	tstfct			; Test if succesfull
1283:	D40C  2014    		jr	NZ,openx6		; Yes then exit
1284:	D40E  1805    		jr	openx3			; No then error
1285:	D410  CD25D4  	openx2:	call	calnex			; Calculate next extent
1286:	D413  30E3    		jr	NC,openx0
1287:	D415  DDCB0EFE	openx3:	set	7,(ix+14)		; Set FCB/file not modified
1288:	D419  3EFF    		ld	a,0ffh			; Set exit code
1289:	D41B  323FC9  	openx4:	ld	(pexit),a
1290:	D41E  C9      		ret				; And return to caller
1291:	D41F  CDAED2  	openx5:	call	openf0			; Open file
1292:	D422  AF      	openx6:	xor	a			; And clear exit code
1293:	D423  18F6    		jr	openx4			; Use same routine
1294:			;
1295:			; Calculate next extent
1296:			;
1297:			;	Exit:	C  overflow detected
1298:			;		Z  search next extent
1299:			;		NZ next extent present (close)
1300:			;
1301:	D425  DD460C  	calnex:	ld	b,(ix+12)		; Get extent number
1302:	D428  DD4E0E  		ld	c,(ix+14)		; Get FCB+14
1303:	D42B  CB71    		bit	6,c			; Test error bit random record
1304:	D42D  37      		scf				; Set error flag
1305:	D42E  C0      		ret	NZ			; Non zero then error exit
1306:	D42F  04      		inc	b			; Increment extent number
1307:	D430  78      		ld	a,b			; Get extent number
1308:	D431  E61F    		and	01fh			; Mask it
1309:	D433  47      		ld	b,a			; Save it in b
1310:	D434  200A    		jr	NZ,calnx0		; Non zero then jump
1311:	D436  0C      		inc	c			; Increment FCB+14
1312:	D437  79      		ld	a,c			; Get it in a
1313:	D438  E63F    		and	03fh			; Mask it
1314:	D43A  4F      		ld	c,a			; Save it in c
1315:	D43B  37      		scf				; Set error flag
1316:	D43C  C8      		ret	Z			; And return if file overflow
1317:	D43D  AF      		xor	a			; Clear zero flag (not same extent)
1318:	D43E  1804    		jr	calnx1			; And save extent number and FCB+14
1319:	D440  3A2BC9  	calnx0:	ld	a,(nextnd)		; Get next extent mask
1320:	D443  A0      		and	b			; Test if same extent (close)
1321:	D444  DD700C  	calnx1:	ld	(ix+12),b		; Save extent number
1322:	D447  DD710E  		ld	(ix+14),c		; Save FCB+14
1323:	D44A  C9      		ret				; And return to caller
1324:			;
1325:			; Read random record command
1326:			;
1327:	D44B  CDF0CD  	cmnd33:	call	seldrv			; Select drive from FCB
1328:			;
1329:			; Read random sector
1330:			;
1331:	D44E  AF      	rdran:	xor	a			; Set read/write flag
1332:	D44F  CD92D5  		call	ldFCB			; Load random record in FCB
1333:	D452  2804    		jr	Z,reads			; No error then read sector
1334:	D454  C9      		ret				; Return error
1335:			;
1336:			; Read sequential
1337:			;
1338:	D455  CDF0CD  	cmnd20:	call	seldrv			; Select drive from FCB
1339:			;	ld	c,30h
1340:			;	call	conout
1341:			
1342:			;
1343:			; Read sector
1344:			;
1345:	D458  AF      	reads:	xor	a			; Set read/write flag
1346:	D459  3242C9  		ld	(rdwr),a		; Save it
1347:	D45C  DD7E20  		ld	a,(ix+32)		; Get record counter
1348:	D45F  FE80    		cp	080h			; Test if last record this extent
1349:	D461  300B    		jr	NC,reads1		; Yes then open next extent
1350:	D463  DDBE0F  		cp	(ix+15)			; Test if greater then current record
1351:	D466  3813    		jr	C,reads2		; No then get record
1352:	D468  3E01    	reads0:	ld	a,1			; Set end of file flag
1353:	D46A  323FC9  		ld	(pexit),a		; Save it
1354:	D46D  C9      		ret				; And return to caller
1355:	D46E          	reads1:
1356:	D46E  CDE3D3  		call	openex			; ..To open next extent
1357:	D471  3A3FC9  		ld	a,(pexit)		; Get exit code
1358:	D474  B7      		or	a
1359:	D475  20F1    		jr	NZ,reads0		; Yes then end of file
1360:	D477  DD362000		ld	(ix+32),0		; Clear record counter
1361:	D47B  CD2CCF  	reads2:	call	getdm			; Get block number from dm in FCB
1362:	D47E  7A      		ld	a,d			; Test block number = 0
1363:	D47F  B3      		or	e
1364:	D480  28E6    		jr	Z,reads0		; Yes then end file
1365:	D482  CD5DCF  		call	calsec			; Calculate sector number (128 bytes)
1366:	D485  CDFACE  		call	calst			; Calculate sector/track number
1367:	D488  CDFCCF  		call	readr			; Read data
1368:	D48B  3A3EC9  		ld	a,(funct)		; Get function number
1369:	D48E  FE14    		cp	20			; Test if read sequential
1370:	D490  C0      		ret	NZ			; No then return
1371:	D491  DD3420  		inc	(ix+32)			; Increment next record counter
1372:	D494  C9      		ret				; And return to caller
1373:			;
1374:			; Write random record commands
1375:			;
1376:	D495          	cmnd34:
1377:	D495          	cmnd40:
1378:	D495  CDF0CD  		call	seldrv			; Select drive from FCB
1379:			;
1380:			; Write random sector
1381:			;
1382:	D498  3EFF    	wrran:	ld	a,0ffh			; Set read/write flag
1383:	D49A  CD92D5  		call	ldFCB			; Load FCB from random record
1384:	D49D  2804    		jr	Z,writes		; No error then write record
1385:	D49F  C9      		ret				; Return error
1386:			;
1387:			; Write sequential
1388:			;
1389:	D4A0          	cmnd21:
1390:	D4A0  CDF0CD  		call	seldrv			; Select drive from FCB
1391:			;
1392:			; Write sector
1393:			;
1394:	D4A3          	writes:
1395:	D4A3  3EFF    		ld	a,0ffh			; Set read/write flag
1396:	D4A5  3242C9  		ld	(rdwr),a		; And save it
1397:	D4A8  CDB1D0  		call	chkro			; Check disk R/O
1398:	D4AB  DDCB097E		bit	7,(ix+9)		; Test if file R/O
1399:	D4AF  C2ADD0  		jp	NZ,chkfr2		; Yes then file R/O message
1400:			
1401:			; Check for changed disk.
1402:			; If disk changed:
1403:			; 	If file modified, abort.
1404:			; 	Else reset disk and disk changed bit.
1405:			;
1406:			
1407:			; Test disk changed
1408:			;
1409:	D4B2  2A3AC9  		ld	hl,(diff)		; Get drive changed vector
1410:	D4B5  CDD3CE  		call	sdrvb			; Set current drive bit
1411:	D4B8  ED52    		sbc	hl,de			; Test extra bit added
1412:	D4BA  2021    		jr	NZ,writsa		; Bit added, so disk not changed
1413:			
1414:			; Test file modified
1415:			;
1416:	D4BC  DDCB0E7E		bit	7,(ix+14)		; File modified?
1417:	D4C0  CA07CC  		jp	Z,chgerr		; Yes, abort and warm boot
1418:			
1419:			; Reset disk and disk changed bit.
1420:			;	HL = 0 from SBC, DE = (diff) from SDRVB above
1421:			;
1422:	D4C3  D5      		push	de			; Save (diff)
1423:	D4C4  CDD3CE  		call	sdrvb			; Set current bit only in HL
1424:	D4C7  D1      		pop	de			; Get (diff)
1425:	D4C8  E5      		push	hl			; Save current drive bit for reset
1426:	D4C9  7A      		ld	a,d
1427:	D4CA  AC      		xor	h
1428:	D4CB  57      		ld	d,a			; Mask current bit in DE
1429:	D4CC  7B      		ld	a,e
1430:	D4CD  AD      		xor	l
1431:	D4CE  5F      		ld	e,a
1432:	D4CF  ED533AC9		ld	(diff),de		; Reset disk changed bit in (diff)
1433:	D4D3  D1      		pop	de			; Get current bit for disk reset
1434:	D4D4  CDD0CD  		call	cmnd37			; No, reset drive:
1435:	D4D7  3A46C9  		ld	a,(defdrv)		; Get drive
1436:	D4DA  CD20CE  		call	seldk			; ..and log it in again
1437:	D4DD          	writsa:
1438:	D4DD  DD7E20  		ld	a,(ix+32)		; Get record count
1439:	D4E0  FE80    		cp	080h			; Test if end this extent
1440:	D4E2  380E    		jr	C,writs0		; Yes then open next extent
1441:	D4E4  CDE3D3  		call	openex			; Open next extent
1442:	D4E7  3A3FC9  		ld	a,(pexit)		; Get error code
1443:	D4EA  B7      		or	a
1444:	D4EB  C28CD5  		jp	NZ,writs9		; Error then directory full error
1445:	D4EE  DD362000		ld	(ix+32),0		; Clear record counter
1446:	D4F2  CD2CCF  	writs0:	call	getdm			; Get block number from FCB
1447:	D4F5  7A      		ld	a,d			; Test if block number = 0
1448:	D4F6  B3      		or	e
1449:	D4F7  2062    		jr	NZ,writs5		; No then write sector
1450:	D4F9  E5      		push	hl			; Save pointer to block number
1451:	D4FA  79      		ld	a,c			; Test first block number in extent
1452:	D4FB  B7      		or	a
1453:	D4FC  2804    		jr	Z,writs1		; Yes then jump
1454:	D4FE  3D      		dec	a			; Decrement pointer to block number
1455:	D4FF  CD46CF  		call	getdm4			; Get previous blocknumber
1456:	D502  CDBED0  	writs1:	call	getfre			; Get nearest free block
1457:	D505  E1      		pop	hl			; Get pointer to block number
1458:	D506  7A      		ld	a,d			; Test if blocknumber = 0
1459:	D507  B3      		or	e
1460:	D508  287C    		jr	Z,writs8		; Yes then disk full error
1461:	D50A  DDCB0EBE		res	7,(ix+14)		; Reset FCB/file modified
1462:	D50E  73      		ld	(hl),e			; Save blocknumber
1463:	D50F  3A2DC9  		ld	a,(maxlen+1)		; Get number of blocks
1464:	D512  B7      		or	a			; Test if <256
1465:	D513  2802    		jr	Z,writs2		; Yes then jump
1466:	D515  23      		inc	hl			; Increment to MSB block number
1467:	D516  72      		ld	(hl),d			; Save MSB block number
1468:	D517  0E02    	writs2:	ld	c,2			; Set write new block flag
1469:	D519  3A2AC9  		ld	a,(nmask)		; Get sector mask
1470:	D51C  DDA620  		and	(ix+32)			; Mask with record counter
1471:	D51F  2802    		jr	Z,writsx		; Zero then ok (at start new record)
1472:	D521  0E00    		ld	c,0			; Else clear new block flag
1473:	D523  3A3EC9  	writsx:	ld	a,(funct)		; Get function number
1474:	D526  D628    		sub	40			; Test if write rr with zero fill
1475:	D528  2033    		jr	NZ,writs6		; No then jump
1476:	D52A  D5      		push	de			; Save blocknumber
1477:	D52B  2A1FC9  		ld	hl,(dirbuf)		; Use directory buffer for zero fill
1478:	D52E  0680    		ld	b,128			; 128 bytes to clear
1479:	D530  77      	writs3:	ld	(hl),a			; Clear directory buffer
1480:	D531  23      		inc	hl			; Increment pointer
1481:	D532  10FC    		djnz	writs3			; Clear all bytes
1482:	D534  CD5DCF  		call	calsec			; Calculate sector number (128 bytes)
1483:	D537  3A2AC9  		ld	a,(nmask)		; Get sector mask
1484:	D53A  47      		ld	b,a			; Copy it
1485:	D53B  04      		inc	b			; Increment it to get number of writes
1486:	D53C  2F      		cpl				; Complement sector mask
1487:	D53D  A3      		and	e			; Mask sector number
1488:	D53E  5F      		ld	e,a			; And save it
1489:	D53F  0E02    		ld	c,2			; Set write new block flag
1490:	D541  E5      	writs4:	push	hl			; Save registers
1491:	D542  D5      		push	de
1492:	D543  C5      		push	bc
1493:	D544  CDFACE  		call	calst			; Calculate sector/track
1494:	D547  CD2ED0  		call	DMAdir			; Set DMA directory buffer
1495:	D54A  C1      		pop	bc			; Get write new block flag
1496:	D54B  C5      		push	bc			; Save it again
1497:	D54C  CD01D0  		call	writer			; Write record on disk
1498:	D54F  C1      		pop	bc			; Restore registers
1499:	D550  D1      		pop	de
1500:	D551  E1      		pop	hl
1501:	D552  0E00    		ld	c,0			; Clear write new block flag
1502:	D554  1C      		inc	e			; Increment sector number
1503:	D555  10EA    		djnz	writs4			; Write all blocks
1504:	D557  CD28D0  		call	stDMA			; Set user DMA address
1505:	D55A  D1      		pop	de			; Get block number
1506:	D55B  0E00    	writs5:	ld	c,0			; Clear write new block flag
1507:	D55D  DDCB0EBE	writs6:	res	7,(ix+14)		; Reset FCB/file modified flag
1508:	D561  C5      		push	bc			; Save it
1509:	D562  CD5DCF  		call	calsec			; Calculate sector number (128 bytes)
1510:	D565  CDFACE  		call	calst			; Calculate sector/track
1511:	D568  C1      		pop	bc			; Get write new block flag
1512:	D569  CD01D0  		call	writer			; Write record on disk
1513:	D56C  DD7E20  		ld	a,(ix+32)		; Get record counter
1514:	D56F  DDBE0F  		cp	(ix+15)			; Compare with next record
1515:	D572  3808    		jr	C,writs7		; If less then jump
1516:	D574  3C      		inc	a			; Increment record count
1517:	D575  DD770F  		ld	(ix+15),a		; Save it on next record position
1518:	D578  DDCB0EBE		res	7,(ix+14)		; Reset FCB/file modified flag
1519:	D57C  3A3EC9  	writs7:	ld	a,(funct)		; Get function number
1520:	D57F  FE15    		cp	21			; Test write sequential
1521:	D581  C0      		ret	NZ			; Not then return
1522:	D582  DD3420  		inc	(ix+32)			; Increment record count
1523:	D585  C9      		ret				; And return to caller
1524:	D586  3E02    	writs8:	ld	a,2			; Set disk full error
1525:	D588  323FC9  		ld	(pexit),a
1526:	D58B  C9      		ret				; And return to caller
1527:	D58C  3E01    	writs9:	ld	a,1			; Set directory full flag
1528:	D58E  323FC9  		ld	(pexit),a
1529:	D591  C9      		ret				; And return to caller
1530:			;
1531:			; Load FCB for random read/write
1532:			;
1533:			;	Exit:	Z  no error
1534:			;		NZ error occured
1535:			;
1536:	D592  3242C9  	ldFCB:	ld	(rdwr),a		; Save read/write flag
1537:	D595  DD7E21  		ld	a,(ix+33)		; Get first byte random record
1538:	D598  57      		ld	d,a			; Save it in d
1539:	D599  CBBA    		res	7,d			; Reset MSB to get next record
1540:	D59B  17      		rla				; Shift MSB in carry
1541:	D59C  DD7E22  		ld	a,(ix+34)		; Load next byte random record
1542:	D59F  17      		rla				; Shift carry
1543:	D5A0  F5      		push	af			; Save it
1544:	D5A1  E61F    		and	01fh			; Mask next extent
1545:	D5A3  4F      		ld	c,a			; Save it in c
1546:	D5A4  F1      		pop	af			; Get byte
1547:	D5A5  17      		rla				; Shift 4 times
1548:	D5A6  17      		rla
1549:	D5A7  17      		rla
1550:	D5A8  17      		rla
1551:	D5A9  E60F    		and	0fh			; Mask it
1552:	D5AB  47      		ld	b,a			; Save FCB+14
1553:	D5AC  DD7E23  		ld	a,(ix+35)		; Get next byte random record
1554:	D5AF  1E06    		ld	e,6			; Set random record to large flag
1555:	D5B1  FE04    		cp	4			; Test random record to large
1556:	D5B3  3061    		jr	NC,ldFCB8		; Yes then error
1557:	D5B5  07      		rlca				; Shift 4 times
1558:	D5B6  07      		rlca
1559:	D5B7  07      		rlca
1560:	D5B8  07      		rlca
1561:	D5B9  80      		add	a,b			; Add byte
1562:	D5BA  47      		ld	b,a			; Save FCB+14 in b
1563:	D5BB  DD7220  		ld	(ix+32),d		; Set next record count
1564:	D5BE  DD560E  		ld	d,(ix+14)		; Get FCB+14
1565:	D5C1  CB72    		bit	6,d			; Test error random record
1566:	D5C3  200E    		jr	NZ,ldFCB0		; Yes then jump
1567:	D5C5  79      		ld	a,c			; Get new extent number
1568:	D5C6  DDBE0C  		cp	(ix+12)			; Compare with FCB
1569:	D5C9  2008    		jr	NZ,ldFCB0		; Not equal then open next extent
1570:	D5CB  78      		ld	a,b			; Get new FCB+14
1571:	D5CC  DDAE0E  		xor	(ix+14)			; Compare with FCB+14
1572:	D5CF  E63F    		and	03fh			; Mask it
1573:	D5D1  283A    		jr	Z,ldFCB6		; Equal then return
1574:	D5D3  CB7A    	ldFCB0:	bit	7,d			; Test FCB modified (write)
1575:	D5D5  200F    		jr	NZ,ldFCB1		; No then jump
1576:	D5D7  D5      		push	de			; Save registers
1577:	D5D8  C5      		push	bc
1578:	D5D9  CDE8D2  		call	close			; Close extent
1579:	D5DC  C1      		pop	bc			; Restore registers
1580:	D5DD  D1      		pop	de
1581:	D5DE  1E03    		ld	e,3			; Set close error
1582:	D5E0  3A3FC9  		ld	a,(pexit)		; Get exit code
1583:	D5E3  3C      		inc	a
1584:	D5E4  282C    		jr	Z,ldFCB7		; Error then exit
1585:	D5E6  DD710C  	ldFCB1:	ld	(ix+12),c		; Save new extent number
1586:	D5E9  DD700E  		ld	(ix+14),b		; Save new FCB+14
1587:			;	bit	7,d			; Test FCB modified (previous FCB)
1588:			;	jr	NZ,ldFCB3		; No then jump
1589:			;ldFCB2:
1590:			;	call	sear0			; File was opened for writing, so
1591:								; the close filled in FCB+13 for fast
1592:								; lookup, so do it
1593:			;	jr	ldFCB4			; Jump
1594:			
1595:	D5EC          	ldFCB3:
1596:	D5EC  CD24D1  		call	findf			; Open file old way because may not
1597:								; have valid FCB+13 for fast lookup
1598:			
1599:	D5EF  3A3FC9  	ldFCB4:	ld	a,(pexit)		; Get error code
1600:	D5F2  3C      		inc	a
1601:	D5F3  2015    		jr	NZ,ldFCB5		; No error then exit
1602:	D5F5  3A42C9  		ld	a,(rdwr)		; Get read/write flag
1603:	D5F8  1E04    		ld	e,4			; Set read empty record
1604:	D5FA  3C      		inc	a
1605:	D5FB  2015    		jr	NZ,ldFCB7		; Read then error
1606:	D5FD  CD7BD3  		call	maker			; Make new FCB using fast lookup
1607:	D600  1E05    		ld	e,5			; Set make error
1608:	D602  3A3FC9  		ld	a,(pexit)		; Get error code
1609:	D605  3C      		inc	a
1610:	D606  280A    		jr	Z,ldFCB7		; Error then exit
1611:	D608  1803    		jr	ldFCB6			; No error exit (zero set)
1612:	D60A  CDAED2  	ldFCB5:	call	openf0			; Open file
1613:	D60D          	ldFCB6:
1614:	D60D  AF      		xor	a			; Set zero flag and clear error code
1615:	D60E  323FC9  		ld	(pexit),a
1616:	D611  C9      		ret				; And return to caller
1617:	D612  DD360EC0	ldFCB7:	ld	(ix+14),0c0h		; Set random record error
1618:	D616  7B      	ldFCB8:	ld	a,e			; Get error code
1619:	D617  323FC9  		ld	(pexit),a		; And save it
1620:	D61A  DDCB0EFE		set	7,(ix+14)		; Set FCB/file not modified
1621:	D61E  B7      		or	a			; Clear zero flag
1622:	D61F  C9      		ret				; And return to caller
1623:			;
1624:			; Calculate random record
1625:			;	Entry:	HL = offset in FCB
1626:			;		DE = FCB pointer
1627:			;	Exit:	D  = LSB random record
1628:			;		C  = ISB random record
1629:			;		B  = MSB random record
1630:			;
1631:	D620  19      	calrrc:	add	hl,de			; Pointer to FCB+15 or FCB+32
1632:	D621  7E      		ld	a,(hl)			; Get byte
1633:	D622  210C00  		ld	hl,12			; Offset to extent number
1634:	D625  19      		add	hl,de			; Get pointer to extent byte
1635:	D626  57      		ld	d,a			; Save first byte
1636:	D627  7E      		ld	a,(hl)			; Get extent byte
1637:	D628  E61F    		and	01fh			; Mask it
1638:	D62A  CB12    		rl	d			; Shift MSB in carry
1639:	D62C  CE00    		adc	a,0			; Add carry
1640:	D62E  1F      		rra				; Shift 1 time (16 bits)
1641:	D62F  CB1A    		rr	d
1642:	D631  4F      		ld	c,a			; Save isb
1643:	D632  23      		inc	hl			; Increment to FCB+14
1644:	D633  23      		inc	hl
1645:	D634  7E      		ld	a,(hl)			; Get FCB+14
1646:	D635  0F      		rrca				; Shift 4 times
1647:	D636  0F      		rrca
1648:	D637  0F      		rrca
1649:	D638  0F      		rrca
1650:	D639  F5      		push	af			; Save it
1651:	D63A  E603    		and	03h			; Mask MSB
1652:	D63C  47      		ld	b,a			; Save it
1653:	D63D  F1      		pop	af			; Get LSB
1654:	D63E  E6F0    		and	0f0h			; Mask it
1655:	D640  81      		add	a,c			; Add with isb
1656:	D641  4F      		ld	c,a			; Save isb
1657:	D642  D0      		ret	NC			; No carry then return
1658:	D643  04      		inc	b			; Increment MSB
1659:	D644  C9      		ret				; And return to caller
1660:			
1661:			; END Z80DDISK.Z80
**** z80dos24.z80 ****
  55:			
  56:			include z80dtime.z80	; Time routines, DOS exit routines,
**** z80dtime.z80 ****
   1:			;
   2:			; Z80DOS - Z80 Disk Operating System
   3:			;
   4:			; Version 2.4	Maskable disk reset's using variable fixdrv
   5:			;		Now can assemble with Z80MR if Z80MR equate
   6:			;		set to -1.
   7:			;		Gene Nolan 4/9/89
   8:			;
   9:			;
  10:			;------------------------------------------------------
  11:			;
  12:			; Version 2.3	Fast file lookup
  13:			; Date:		4 Nov 88
  14:			; Update:	Eugene Nolan
  15:			;
  16:			;--------------------------------------------------------------
  17:			;
  18:			; Version 2.0a - BETA TEST VERSION - 6 Nov 87 by Carson Wilson
  19:			;
  20:			; Support file:	Z80DTIME.Z80
  21:			; Version:	2.0
  22:			; Date:		6 Nov 87
  23:			; Author:	Carson Wilson
  24:			; Changes:	Added internal time routine for systems without a
  25:			;		real time clock.  This routine assembles if RTC is false.
  26:			;		Cleaned up and clarified code.
  27:			;
  28:			; Description:	Time Functions, Exit Routine, RAM Area
  29:			;
  30:			
  31:			; ---------------------------------------------------------------------
  32:			
  33:			; Time Routines
  34:			
  35:			; -------------------------
  36:			
  37:			;
  38:			; STime - Set file's time and date at DMA buffer.
  39:			;
  40:			;	Entry:	E = 2 - set creation date or get time stamp
  41:			;		E = 4 - Set last update time/date
  42:			;		E = 8 - Set last access time/date
  43:			;
  44:			;	Exit:	Z  if time stamps present
  45:			;		NZ if no time stamps
  46:			
  47:	D645  2A1FC9  	STime:	ld	hl,(dirbuf)		; get directory entry
  48:	D648  016000  		ld	bc,060h			; offset entry point time/date stamp
  49:	D64B  09      		add	hl,bc			; add offset to time stamp
  50:	D64C  7E      		ld	a,(hl)			; get time stamp byte
  51:	D64D  D621    		sub	021h			; time stamp present?
  52:	D64F  C0      		ret	NZ			; no, return
  53:	D650  57      		ld	d,a			; yes, clear d
  54:	D651  19      		add	hl,de			; add entry (update/create/access)
  55:	D652  7B      		ld	a,e			; set access time if E ge 8 <crw>
  56:	D653  E608    		and	8			;
  57:	D655  2802    		jr	Z,STim1			; E lt 8
  58:	D657  CB3B    		srl	e			; E ge 8, set to 4
  59:	D659  43      	STim1:	ld	b,e			; save # bytes to write
  60:	D65A  3A4BC9  		ld	a,(secpnt)		; get sector pointer
  61:	D65D  0F      		rrca				; shift 2 times
  62:	D65E  0F      		rrca
  63:	D65F  5F      		ld	e,a			; save it
  64:	D660  0F      		rrca				; shift 2 times
  65:	D661  0F      		rrca
  66:	D662  83      		add	a,e			; add it (a=0,10,20)
  67:	D663  5F      		ld	e,a			; save in e
  68:	D664  19      		add	hl,de			; add offset
  69:	D665  3A3EC9  		ld	a,(funct)
  70:	D668  FE36    		cp	54			; if set DOS time
  71:	D66A  C8      		ret	Z			; ..just point to date stamp
  72:	D66B  E5      		push	hl			; save result
  73:	D66C  0E00    		ld	c,0			; time return date/time pointer in hl
  74:	D66E  C5      		push	bc			; save 2 or 4 byte count <crw>
  75:	D66F  CD97D6  		call	time			; return pointer in hl
  76:	D672  C1      		pop	bc
  77:	D673  D1      		pop	de			; get pointer
  78:	D674  48      		ld	c,b			; set write 2 or 4 bytes <crw>
  79:	D675  0600    		ld	b,0
  80:	D677  EDB0    		ldir				; copy 2 or 4 bytes to directory buff.
  81:	D679  AF      		xor	a			; set zero flag - time stamps present
  82:	D67A  C9      		ret				; and return to caller
  83:			
  84:			;
  85:			; GetStp - Store time stamp following file find, open, or make.
  86:			;
  87:			;	Exit:	HL points to file's 10-byte time stamp stored in DOS.
  88:			;		This buffer is used by subsequent disk commands if
  89:			;		DOS-time (dtime) has been activated by command 55.
  90:			;
  91:	D67B          	GetStp:
  92:	D67B  1E02    		ld	e,2			; Point to file's stamp
  93:	D67D  CD45D6  		call	STime			; Point to beginning of
  94:								; ..last file's stamp
  95:	D680  1155C9  		ld	de,cdate		; Point to DOS stamp buffer
  96:	D683  ED533FC9		ld	(pexit),de		; Save for return in HL
  97:	D687  010A00  		ld	bc,10
  98:	D68A  2003    		jr	NZ,GtStp1		; STime said no stamp found
  99:	D68C  EDB0    		ldir				; Save full stamp
 100:	D68E  C9      		ret				; Back to calling program
 101:	D68F          	GtStp1:
 102:	D68F  41      		ld	b,c			; No stamp found
 103:	D690          	GtStp2:
 104:	D690  3E00    		ld	a,0			; ..so zero out DOS buffer
 105:	D692  12      		ld	(de),a
 106:	D693  13      		inc	de
 107:	D694  10FA    		djnz	GtStp2
 108:	D696  C9      		ret				; Return to calling program
 109:			
 110:			; ------------------------------------------------------------------
 111:			
 112:			; Time - get time for stamping from DOS storage or get real time
 113:			
 114:			;
 115:			; Entry:	DTime = 0	Get real time
 116:			;		DTime <> 0	Get time from DOS buffer and reset DTime.
 117:			;
 118:			; Format of time returned to pointer in HL:
 119:			;
 120:			;	HL + 0 = low  byte of date since Dec. 31, 1977
 121:			;	HL + 1 = high byte of date since Dec. 31, 1977
 122:			;	HL + 2 = hours	 (BCD)
 123:			;	HL + 3 = minutes (BCD)
 124:			;	HL + 4 = seconds (BCD) (not used in time stamp)
 125:			;
 126:			
 127:	D697          	time:
 128:	D697  3A54C9  		ld	a,(dtime)		; Get time from buffer?
 129:	D69A  B7      		or	a
 130:	D69B  2822    		jr	Z,btime			; No, get real time
 131:			
 132:	D69D  3A3EC9  		ld	a,(funct)		; Yes, check function
 133:	D6A0  FE16    		cp	22			; Creating file?
 134:	D6A2  2155C9  		ld	hl,cdate		; If so, point to
 135:	D6A5  2803    		jr	Z,time2			; ..stored create date
 136:	D6A7  2157C9  		ld	hl,udate		; No, point to update date/time
 137:	D6AA          	time2:
 138:	D6AA  AF      		xor	a
 139:	D6AB  3254C9  		ld	(dtime),a		; Use buffer for this call only
 140:	D6AE  C9      		ret
 141:			
 142:			; -------------------------------------------------------------------
 143:			
 144:			; GetTim and SetTim - Get or Set Time using memory or Real Time Clock
 145:			
 146:			; -------------------------------------------------------------------
 147:			
 148:			;
 149:			; Get time to address DE
 150:			;
 151:	D6AF          	gettim:
 152:	D6AF  D5      		push	de			; Save address to put time
 153:	D6B0  0E00    		ld	c,0			; Get time address
 154:	D6B2  CDBFD6  		call	btime			; Execute p2bios call
 155:	D6B5  D1      		pop	de			; Restore address to put time
 156:	D6B6  010500  		ld	bc,5			; 5 bytes to move
 157:	D6B9  EDB0    		ldir				; Store the time
 158:	D6BB  C9      		ret				; Return to caller (or DOS)
 159:			;
 160:			; Set time from address DE
 161:			;
 162:	D6BC  EB      	settim:	ex	de,hl			; get address time in hl
 163:	D6BD  0EFF    		ld	c,0ffh			; set time from address
 164:			
 165:			;	fall	thru
 166:			
 167:			;
 168:			; Real Time Clock (RTC) or memory "clock" interface:
 169:			;
 170:			;	Entry:	C =  0: Load 5-byte buffer at HL with time
 171:			;		C <> 0: 5-byte entry pointed to by HL sets system time
 172:			
 173:	FFFF          		if	RTC			; Real time clock available
 174:	D6BF          	btime:
 175:	D6BF  E5      		push	hl			; Save value in HL
 176:	D6C0  2A11C9  		ld	hl,(timead)		; Get address time routine
 177:	D6C3  E3      		ex	(sp),hl			; Put address on stack and restore hl
 178:	D6C4  C9      		ret				; Execute BIOS time routine
 179:			
 180:				 else				; Use memory "clock"
 192:				 endif	; RTC
 193:			
 194:			; ---------------------------------------------------------
 195:			;
 196:			; UseStp - Use stored time stamp for very next DOS call.
 197:			; 	   All other DOS calls cancel DOS time thru p2exit.
 198:			;
 199:	D6C5          	UseStp:
 200:	D6C5  F6FF    		or	0ffh
 201:	D6C7  3254C9  		ld	(dtime),a		; Use DOS time
 202:	D6CA  E1      		pop	hl			; clean up stack
 203:	D6CB  1819    		jr	p2ext0
 204:			
 205:			; -------------------------------------------------------------------------
 206:			
 207:			; DOS exit routines
 208:			
 209:			; -------------------
 210:			
 211:			
 212:	D6CD  AF      	p2exit:	xor	a
 213:	D6CE  3254C9  		ld	(dtime),a		; Turn off DOS time <crw>
 214:	D6D1  3253C9  		ld	(retflg),a		; Turn off retries
 215:	D6D4  3A41C9  		ld	a,(fldrv)		; Test drive select used flag
 216:	D6D7  B7      		or	a
 217:	D6D8  280C    		jr	Z,p2ext0		; No then exit
 218:	D6DA  3A43C9  		ld	a,(FCB0)		; Get FCB byte 0
 219:	D6DD  DD7700  		ld	(ix+0),a		; Save it
 220:	D6E0  3A45C9  		ld	a,(drive)		; Get old drive number
 221:	D6E3  CD20CE  		call	seldk			; Select disk
 222:	D6E6  DDE5    	p2ext0:	push	ix			; Save IX
 223:	D6E8  D1      		pop	de			; Restore DE
 224:	D6E9  DDE1    		pop	ix			; Restore IX
 225:	D6EB  ED7B5FC9		ld	sp,(spsave)		; Get old sp
 226:	D6EF  2A3FC9  		ld	hl,(pexit)		; Get exit code
 227:	D6F2  3A3EC9  		ld	a,(funct)		; Get function code
 228:	D6F5  4F      		ld	c,a			; Restore C
 229:	D6F6  7D      		ld	a,l			; Copy function code
 230:	D6F7  44      		ld	b,h
 231:	D6F8  C9      		ret				; And return to caller
 232:	0000          		if	($-dos) gt 3584
 234:				endif
 235:			
 236:			; END Z80DTIME.Z80
 237:			
**** z80dos24.z80 ****
  57:				ENDIF				; ..RAM area
  58:			
  59:			; END Z80DOS.Z80
**** z80dos24.z80 ****



Statistics:

   392	symbols
  3513	bytes



Symbol Table:

adate           c95b+    error2          cc7b     rdbuff          cbe4     
again           cb54     error3          cc93     rdbufg          cbeb+    
alv             c925     error4          cc9e     rdbufh          cbfc     
base           =c100     error5          ccae     rdbufi          cc00     
bdos           =c906+    exit            ca3c     rdcon           ca31     
bdosb          =c900+    false          =   0     rddir           cfa4     
bias           =8d00     fcb0            c943     rddir0          cfb8     
bios           =d700     fcontp          c918     rdonly          cc1d     
biostim        =d721     filcnt          c949     rdran           d44e+    
boot           =d700+    filenm          cccc     rdrdr           ca43     
botdsk         =d736     fillb0          d063     rdwr            c942     
btime           d6bf     fillb1          d070     readdr          d00d     
bwrcon          ca40     fillb2          d081     reader         =d715     
caldir          cf75     fillbb          d05e     readr           cffc     
calnex          d425     filro           cc11     reads           d458     
calnx0          d440     filsz           d25c     reads0          d468     
calnx1          d444     filsz0          d266     reads1          d46e     
calrrc          d620     findf           d124     reads2          d47b     
calsc0          cf64     findfn          d120     recdir          c947     
calsc1          cf6c+    fixdrvs         c913     renam           d202     
calsec          cf5d     flags           c915     renam0          d208     
calst           cefa     fldrv           c941     renam1          d21c     
calst0          cf00     funct           c93e     renam2          d22b     
calst1          cf08     gcons0          cb04     resdsk         =   0+    
calst2          cf15     gcons1          cb10     resroom        = 300     
ccp            =c100     gcons2          cb21     retflg          c953     
cdate           c955     gcons3          cb29     rtc            =ffff     
chgerr          cc07     gconst          caf7     rubout         =  7f     
chkdir          cfcc     getbit          d035     rwerr           cc18     
chkdr0          cfe1     getbt0          d04c     sdrvb           ced3     
chkdr1          cffa     getch           caec     sdrvb0          cedd     
chkfr2          d0ad     getdm           cf2c     sdrvb1          cee1     
chkfro          d099     getdm0          cf33     sear0           d0f4     
chkro           d0b1     getdm1          cf37+    sear01          d0f6     
close           d2e8     getdm2          cf42     sear1           d12f     
close0          d30d     getdm3          cf45+    searc1          d158     
close1          d320     getdm4          cf46     searc2          d166     
close2          d334+    getdm5          cf57     searc3          d198     
close3          d335     getfr0          d0c0     searc4          d1a5     
close4          d353     getfr1          d0cf     searc5          d1a7     
cmd15           d28e     getfr2          d0e7     searc6          d1ad     
cmd151          d29c     getfr3          d0ec     searc7          d1b3     
cmd17a          cd55     getfre          d0be     searc8          d1c0     
cmd17b          cd57     getstp          d67b     searc9          d1c9     
cmd17c          cd5a     gettim          d6af     search          d126     
cmd19a          cd79     gfixed          ca2b     searcn          d138     
cmd24a          cd89     giost           ca6a     searex          c94f     
cmd25a          cd90     gtstp1          d68f     searnb          c950     
cmnd12          cd04     gtstp2          d690     searpu          c952     
cmnd13          cd0d     home           =d718     searqu          c951     
cmnd14          ce1f     initd0          ce7a     secpnt          c94b     
cmnd15          d2a0     initd1          ce86     sectrn         =d730     
cmnd16          d2e5     initd2          cea3     seldk           ce20     
cmnd17          cd40     initd3          cec9     seldk0          ce2a     
cmnd18          cd67     initdr          ce74     seldk1          ce30     
cmnd19          cd73     intron         =   0+    seldk2          ce39     
cmnd20          d455     ixp             c921     seldk3          ce70     
cmnd21          d4a0     lastch          c919     seldr0          ce0e     
cmnd22          d391     ldfcb           d592     seldrv          cdf0     
cmnd23          cd7e     ldfcb0          d5d3     seldsk         =d71b     
cmnd24          cd86     ldfcb1          d5e6     selerr          cc0c     
cmnd25          cd8d     ldfcb3          d5ec+    setbit          d051     
cmnd26          d024     ldfcb4          d5ef+    setbt0          d059     
cmnd27          cd93     ldfcb5          d60a     setdma         =d724     
cmnd28          d084     ldfcb6          d60d     setfct          cf80     
cmnd29          cd98     ldfcb7          d612     setfn           d08d     
cmnd30          cd9d     ldfcb8          d616     setlf           cf8e     
cmnd31          cda5     ldrrc           cdc6     setsec         =d721     
cmnd32          cdaa     lf             =   a     settim          d6bc     
cmnd33          d44b     listst         =d72d+    settrk         =d71e     
cmnd34          d495     login           c938     sfilro          c90f     
cmnd35          cdb8     lowcmd          c9ce     siost           ca6f     
cmnd36          cdc0     mak0            d386     spsave          c95f     
cmnd37          cdd0     mak1            d3a1     sr1             d129     
cmnd40          d495     make            d398+    start           c906+    
conin          =d709     make0           d3b3     stdir           cee8     
conout         =d70c     maker           d37b     stdma           d028     
const          =d706     maxcmd         =  28     stim1           d659     
contc          =   3     maxlen          c92c     stime           d645     
conth          =   8     maxsec          c927     stro            c90d     
contp          =  10     mberr           ccef     strw            c909     
conts          =  13     mbfunc          ccf8     stsel           c90b     
contx          =  18     mchg            ccda     subflg          c94c     
copyd0          d361     mdrive          ccf5     tab            =   9     
copyd1          d36f     mess            cb48     tabcnt          c916     
copyd2          d376     mfile           ccfe     tabcx1          c917     
copydm          d359     mfilro          cce6     temp0           c91d     
count0          cad9     mro             cce9     time            d697     
count1          cae0     mrwerr          ccec     time2           d6aa     
countc          cacb     msel            cce0     timead          c911     
cr             =   d     msize          =  38     trans           c91b     
crout           ca8d     nblock          c929     true           =ffff     
cstat           d235     ncheck          c932     tstch           cb2c     
cstat0          d23b     ndir0           c930     tstcs           ca74     
cstat1          d247     ndir1           c931+    tstfct          cf87     
csv             c923     nextnd          c92b     tstlf           cf97     
ctable          c9d9     nfiles          c92e     udate           c957     
dcio            ca50     nftrk           c934     user            c944     
dcio0           ca5f     nmask           c92a     usestp          d6c5     
dcopy           c94d     noz80mr        =   0     vers           =  16+    
defdrv          c946     num             ccb5     wboot          =d703     
del0            d1e9     num1            ccb7     wcont0          cb43     
delay           c91a     num2            ccca     wconth          cb3b     
delch           cb63     openex          d3e3     wlist           ca4c     
delch0          cb6f     openf           d2a7+    wpunch          ca48     
delch1          cb80     openf0          d2ae     wrcon           ca94     
delch2          cb86     openf1          d2de     wrcon0          ca98     
delch3          cb8e     openx0          d3f8     wrcon1          caa7     
delch4          cb9a     openx1          d3fb+    wrcon2          caca     
delete          d1e3     openx2          d410     wrfcb           d288     
derror          cc20     openx3          d415     writdr          d015     
diff            c93a     openx4          d41b     write          =d72a     
dirbuf          c91f     openx5          d41f     write0          d004     
dlist          =d70f     openx6          d422     writer          d001     
dma             c93c     options        =   1     writes          d4a3     
dmadir          d02e     outch           ca79     writs0          d4f2     
dmadr0          d032     p2exit          d6cd     writs1          d502     
doback          cbb8     p2ext0          d6e6     writs2          d517     
dos            =c900     pexit           c93f     writs3          d530     
dosstk         =c997     punch          =d712     writs4          d541     
dosstop        =c997+    ramlow         =   0     writs5          d55b     
dread          =d727     rdbuf           cb9d     writs6          d55d     
drive           c945     rdbuf0          cba3+    writs7          d57c     
drvsep         =  3a     rdbuf1          cbab     writs8          d586     
dskro           c936     rdbuf2          cbad+    writs9          d58c     
dtime           c954     rdbuf3          cbb4+    writsa          d4dd     
dummy           ca3f     rdbuf4          cbc3     writsx          d523     
entry           c997     rdbufc          cbce     wrran           d498+    
error           cc21     rdbufd          cbd2     z80mr          =ffff     
error1          cc6e     rdbufe          cbde     
