   1:			;****************************************************************************
   2:			;				Z S D O S
   3:			;   A CP/M 2.2 compatible replacement Basic Disk Operating System (BDOS)
   4:			;
   5:			;     Copyright (C) 1986,7,8 by:
   6:			;
   7:			;          Harold F. Bower        and       Cameron W. Cotrill
   8:			;
   9:			;         7914 Redglobe Ct.                2160 N.W. 159th Place
  10:			;         Severn, MD 21144-1048            Beaverton, OR  97006
  11:			;         USA.                             USA.
  12:			;
  13:			;       HalBower@worldnet.att.net         ccotrill@symantec.com
  14:			;
  15:			;   This program is free software; you can redistribute it and/or modify
  16:			;   it under the terms of the GNU General Public License as published by
  17:			;   the Free Software Foundation; either version 2 of the License, or
  18:			;   (at your option) any later version.
  19:			;
  20:			;   This program is distributed in the hope that it will be useful,
  21:			;   but WITHOUT ANY WARRANTY; without even the implied warranty of
  22:			;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  23:			;   General Public License (file LICENSE.TXT) for more details.
  24:			;
  25:			;   You should have received a copy of the GNU General Public License
  26:			;   along with this program; if not, write to the Free Software
  27:			;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  28:			;---------------------------------------------------------------------------
  29:			; ZSDOS is a CP/M 2.2 compatable BDOS replacement that contains numerous
  30:			; enhancements.  It is based on P2DOS 2.1 by HAJ Ten Brugge and revisions
  31:			; to P2DOS made by Harold F. Bower, Benjamin Ho, and Cameron W. Cotrill.
  32:			; Several good ideas from both CP/M Plus(tm) and ZRDOS(tm) have been added.
  33:			; The authors wish to thank Bridger Mitchell of Plu*Perfect Systems for
  34:			; suggesting we put our heads together, for reviewing the efforts, and for
  35:			; suggesting better methods for coding some sections.  Thanks also to Joe
  36:			; Wright of Alpha Systems for his review and suggestions, as well as
  37:			; squeezing a few more bytes for us.
  38:			
  39:			; Support for Plu*Perfect'a BackGrounder ii(tm) and ZDS DateStamper(tm) is
  40:			; included, as well as support for ZCPR/BGii WHEEL and PATH.
  41:			; ZSDOS is compatable with NZCOM by Joe Wright of Alpha Systems.
  42:			
  43:			; ZSDOS is designed for Z80 compatible processors ONLY!!!
  44:			; ZSDOS is coded to run in Z280 protected mode and may be ROMmed.
  45:			
  46:			; LEGAL DEPARTMENT:   P2DOS was written by H.A.J. Ten Brugge,  ZSDOS
  47:			; modifications were by Cameron W. Cotrill and Harold F. Bower.
  48:			; ZDDOS modifications were done by Carson Wilson, Cameron W. Cotrill
  49:			; and Harold F. Bower.
  50:			
  51:			; No author assumes responsibility or liability in the use of this
  52:			; program or any of its support utilities.
  53:			
  54:			; P2DOS is Copyright (C) 1985 by H.A.J. Ten Brugge  - All Rights Reserved
  55:			;	H.A.J. Ten Brugge
  56:			;	F. Zernikestraat 207
  57:			;	7553 EC Hengelo
  58:			;	Netherlands
  59:			; Permission to use P2DOS code in ZSDOS granted to Harold F. Bower and
  60:			;   Cameron W. Cotrill in letter 28 March 1988
  61:			
  62:			;   Code sections marked (bm) are revisions suggested by Bridger Mitchell.
  63:			;   Code sections marked (bh) are from SUPRBDOS mods to P2DOS by Benjamin Ho.
  64:			;   Code sections marked (crw) are revisions to support internal datestamper
  65:			;      and are Copyright (C) 1988 by Carson Wilson.
  66:			
  67:			; NOTES: Backgrounder ii and DateStamper are trademarks of Plu*Perfect
  68:			;  Systems.  CP/M is a trademark of Digital Research, Incorporated.
  69:			;  ZRDOS is a trademark of Echelon, Incorporated.
  71:			;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  72:			; Version 1.2a, 11/04/89
  73:			; Assemble with : SLR Z80ASMP or ZMAC
  74:			; Revisions:
  75:			; 11/04/89	Moved home call to rddir so bios hostbuf always
  76:			;		updated before dir read.
  77:			; 07/18/89	Fixed tderr routine in ZDDOS so return codes not
  78:			; CWC		altered from tderr unless called from 102 or 103.
  79:			; 06/20/89	Fixed bug in F10 ^R that output 256 spaces if ^R
  80:			; CWC		entered with tab counter =0.
  81:			;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  82:			;;---------------------------------------------------------------------
  83:			;; Modified on 2006/04/29 to assemble with zmac, linux cross-assembler
  84:			;; not the CP/M ZMAC
  85:			;;---------------------------------------------------------------------
  86:			;; Modified on 2008/02/08 to cope with BIOS clock driver
  87:			;;---------------------------------------------------------------------
  88:			
  89:				include	common.asm	; Common ZDS equs
**** common.asm ****
   1:			;
   2:			; Here just some common symbol...
   3:			;
   4:			
   5:	0016          	VERS	EQU     22      	; VERSION 2.2 (CP/M related)
   6:			;
   7:	003C          	MSIZE	EQU     60              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
   8:			;MSIZE	EQU     56              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
   9:	0400          	RESROOM	EQU	1024		; RESERVED ROOM SPACE BELOW MONITOR (F000)
  10:	0600          	BIOSTDS	EQU	1536		; BIOS STANDARD SIZE
  11:	0A00          	BIOREAS	EQU	BIOSTDS+RESROOM	; BIOS REAL SIZE
  12:	0400          	ZSTDOVR	EQU	1024		; ZCPR STANDARD OVERHEAD SIZE
  13:	0000          	ZIOPKG	EQU	0		; ZCPR IO PACKAGE SIZE
  14:	0800          	ZRESPKG	EQU	2048		; ZCPR RESIDENT CMD PKG SIZE
  15:	0200          	ZFLOPKG	EQU	512		; ZCPR FLOW CMD PACKAGE SIZE
  16:	01C8          	ZDSSTSZ	EQU	01C8H		; ZDS Stamper reserved space
  17:			
  18:	1200          	EXTRABIAS	EQU	RESROOM+ZSTDOVR+ZIOPKG+ZRESPKG+ZFLOPKG	; ...
  19:				;
  20:				;       "BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
  21:				;       THAN 16K (REFERRED TO AS"B" THROUGHOUT THE TEXT)
  22:				;
  23:	8E00          	BIAS	EQU     ((MSIZE-20)*1024)-EXTRABIAS
  24:	C200          	CCP	EQU     3400H+BIAS      ; BASE OF CCP
  25:	CA06          	BDOS	EQU     CCP+0806H       ; BASE OF BDOS
  26:	CA00          	BDOSB	EQU	CCP+0800H	; BDOS base offset
  27:	D800          	BIOS	EQU     CCP+1600H       ; BASE OF BIOS
  28:	E200          	ZBUFBAS	EQU	BIOS+BIOREAS	; BASE OF ZCPR3 BUFFERS
  29:				;
  30:				; 	some other equs...
  31:				;
  32:	000D          	CR	EQU     0DH		; CARRIAGE RETURN
  33:	000A          	LF	EQU     0AH		; LINE FEED;
  34:	000C          	FF	EQU	0CH		; FORM FEED (clear screen)
  35:	FFFF          	TRUE	EQU	-1		; ....
  36:	0000          	FALSE	EQU	0
  37:	0000          	INTRON	EQU	FALSE		; Interrupts disabled
  38:				;
  39:				; define which kind of date stamper must be embedded in
  40:				; RCP
  41:				;
  42:	0000          	STMPP2	EQU	FALSE		; P2DOS date stamper
  43:	FFFF          	STMPZS	EQU	TRUE		; ZSDOS date stamper	
  44:	FFFF          	HASEDS	EQU	(STMPP2+STMPZS)	; set a flag for embedded date stamper
  45:				;
  46:				; path for ZCPR3 used on cold boot
  47:				;
  48:	0024          	IDISK1	EQU	'$'		; 1st: current disk, current user
  49:	0024          	IUSER1	EQU	'$'
  50:	0024          	IDISK2	EQU	'$'		; 2nd: current disk, user 15
  51:	000F          	IUSER2	EQU	15
  52:	0001          	IDISK3	EQU	'A'-'@'		; 3rd: disk A, current user
  53:	0024          	IUSER3	EQU	'$'
  54:	0001          	IDISK4	EQU	'A'-'@'		; 4th: disk A, user 15
  55:	000F          	IUSER4	EQU	15
  56:			
  57:			; COMMON.ASM [EOF]
**** zsdos.asm ****
  90:			;	MACLIB	ZSDOS.LIB	; Get initialization code
  91:				include z3base.lib	; Get address for WHEEL byte
**** z3base.lib ****
   1:			; Z3BASE - Dynamic Configuration
   2:			;
   3:			; ZCPR33 is copyright 1987 by Echelon, Inc.  All rights reserved.  End-user
   4:			; distribution and duplication permitted for non-commercial purposes only.
   5:			; Any commercial use of ZCPR33, defined as any situation where the duplicator
   6:			; recieves revenue by duplicating or distributing ZCPR33 by itself or in
   7:			; conjunction with any hardware or software product, is expressly prohibited
   8:			; unless authorized in writing by Echelon.
   9:			;
  10:			; This is a special version of Z3BASE, inspired by Joe Wright's Z3BASE
  11:			; for Z-Com.  All segment addresses are automatically derived when the
  12:			; CCP equate is set.  The benefit of this is that reconfiguration of the
  13:			; system after initial installation is greatly eased.
  14:			;
  15:			; Although this version of Z3BASE is being distributed with ZCPR 3.3, any
  16:			; previous version of Z3BASE can be used to assemble the Z33 Command
  17:			; Processor.  No new symbols are needed.  So, if you have an existing
  18:			; Z3BASE, go ahead and use it.
  19:			;
  20:			; Instructions:
  21:			;
  22:			; The user should first design the ZCPR3 memory usage using the chart
  23:			; below.  (Echelon recommends the chart be filled out, even though it is
  24:			; not read by the assembler, so that your system will be self-documenting.)
  25:			; Then set the CCP equate for the beginning address of ZCPR3.  Next, examine
  26:			; and change the SEGn equates which follow in the file to ensure that the
  27:			; system segments and buffers are placed at the proper addresses.
  28:			;
  29:			; This file has been customized for use with AMPRO hard disk systems.  The
  30:			; target configuration has support for hard disks up to 49 Meg, extended
  31:			; IOP support, and 28-entry NDR.
  32:			;
  33:			;****************************************************************
  34:			;*								*
  35:			;*  Z3BASE.LIB -- Base Addresses for ZCPR 3.3/Z-System		*
  36:			;*								*
  37:			;* 	Segments:						*
  38:			;*								*
  39:			;*	Segment		Function				*
  40:			;*	-------		--------				*
  41:			;*	ZSDOS		ZSDOS 1.1				*
  42:			;*	CBIOSZ		ZDS BIOS with additional		*
  43:			;*			ZCPR3 initialization routines		*
  44:			;*	ZCPR3		Echelon Z80 Command Processor		*
  45:			;*			Replacement, Version 3.3 (ZCPR3)	*
  46:			;*	*.ENV		All Environment Descriptors		*
  47:			;*	*.FCP		All Flow Command Packages		*
  48:			;*	*.NDR		All Named Directory Definition Files	*
  49:			;*	*.RCP		All Resident Command Packages		*
  50:			;*	*.IOP		All Input/Output Packages		*
  51:			;*								*
  52:			;*								*
  53:			;* Memory Map of System (for CCP EQU 0BC00H):			*
  54:			;*								*
  55:			;*	Address Range	  Size	Function			*
  56:			;*	-------------	-------	--------			*
  57:			;*	    0 -   FF	256 b	Standard CP/M Buffers except	*
  58:			;*	  100 - C2FF	~48 K	Transient Program Area		*
  59:			;*	 C200 - C9FF	  2 K	ZCPR 3.3 Command Processor	*
  60:			;*	 CA00 - D7FF	3.5 K	ZSDOS				*
  61:			;*	 D800 - E1FF	2.5 K	BIOS with disk buffers		*
  62:			;*	 E200 - E9FF	  2 K	Resident Command Package	*
  63:			;*	 0000 - 0000	1.5 K	Input/Output Package		*
  64:			;*	 EA00 - EBFF	 .5 K	Flow Command Package		*
  65:			;*	 EC00 - ECFF	256 b	Environment Descriptor		*
  66:			;*				Bytes 00H-7FH:  Z3 Parameters	*
  67:			;*				Bytes 80H-FFH:  Z3 TCAP		*
  68:			;*	 ED00 - ED7F	128 b	ZCPR3 Shell Stack		*
  69:			;*	 ED80 - EDCF	 80 b	ZCPR3 Message Buffers		*
  70:			;*	 EDD0 - EDF3	 36 b	ZCPR3 External FCB		*
  71:			;*	 EDF4 - EDFE	 11 b	ZCPR3 External Path	        *
  72:			;*       EDFF  		  1 b	Wheel Byte			*
  73:			;*	 EE00 - EEFF    256 B	Memory-Based Named Directory	*
  74:			;*	 EF00 - EFCF	208 B	Multiple Command Line Buffer	*
  75:			;*	 EFD0 - EFFF	 48 b	ZCPR3 External Stack		*
  76:			;****************************************************************
  77:			
  78:			; include	macro	filename
  79:			;
  80:			; 	 if	zas
  81:			; 	.in		filename
  82:			; 	 else	;slr assembler
  83:			; 	include	filename
  84:			; 	 endif	;zas
  85:			;
  86:			; 	 endm
  87:			
  88:			; FALSE	equ	0
  89:			; TRUE	equ	NOT FALSE
  90:			
  91:	0021          	Z3REV	EQU	33	; ZCPR3 REV NUMBER
  92:			; MSIZE	EQU	54	; SIZE OF CPM SYSTEM
  93:			
  94:	0000          	BASE	EQU	0
  95:			
  96:			; CCP	EQU	0BC00H 	; ZCPR3 COMMAND PROCESSOR
  97:			
  98:	E200          	SEG1	EQU	ZBUFBAS	; where the things starts
  99:			
 100:			;
 101:			; RCP definition.  Set RCPS to 0 to eliminate RCP
 102:			;
 103:			
 104:	0010          	RCPS	EQU	16		; 16 128-byte Blocks (2K bytes)
 105:			
 106:	0001          		 IF	RCPS NE 0
 107:	E200          	RCP	EQU	SEG1		; RESIDENT COMMAND PACKAGE
 108:				 ELSE
 110:				 ENDIF
 111:			
 112:	EA00          	SEG2	EQU	SEG1+(RCPS*128)
 113:			
 114:			;
 115:			; IOP definition.  Set IOPS to 0 to eliminate IOP
 116:			;
 117:			; IOPS	EQU	12		; 12 128-byte Blocks (1.5K bytes)
 118:	0000          	IOPS	EQU	0		; 12 128-byte Blocks (1.5K bytes)
 119:			
 120:	0000          		 IF	IOPS NE 0
 122:				 ELSE
 123:	0000          	IOP	EQU	0
 124:				 ENDIF
 125:			
 126:	EA00          	SEG3	EQU	SEG2+(IOPS*128)
 127:			
 128:			;
 129:			; FCP definition.  Set FCPS to 0 to eliminate FCP
 130:			;
 131:			
 132:	0004          	FCPS	EQU	4	; 4 128-byte Blocks (0.5K bytes)
 133:			
 134:	0001          		 IF	FCPS NE 0
 135:	EA00          	FCP	EQU	SEG3
 136:				 ELSE
 138:				 ENDIF
 139:			
 140:	E838          	ZDSSTPR	EQU	(FCP-ZDSSTSZ)	; Z80 Darkstar P2DOS Stamper
 141:	011F          	NWF12O	EQU	011FH
 142:	0133          	SETCHO	EQU	0133H
 143:	013C          	CKTDFO	EQU	013CH
 144:			
 145:	EC00          	SEG10	EQU	SEG3+(FCPS*128)
 146:			
 147:			;
 148:			; The ZCPR3 External Environment Descriptor is mandatory for ZCPR 3.3.
 149:			; Echelon recommends you work this out so that your ENV begins at address
 150:			; FE00h, but this is only a recommendation and not mandatory.
 151:			;
 152:			
 153:	EC00          	Z3ENV	EQU	SEG10	; ENVIRONMENT DESCRIPTORS
 154:	0002          	Z3ENVS	EQU	2	; SIZE OF ENVIRONMENT DESCRIPTOR IN 128-BYTE BLOCKS
 155:			
 156:	ED00          	SEG4	EQU	SEG10+(Z3ENVS*128)
 157:			
 158:			;
 159:			; Shell Stack definition.  Set SHSTKS to 0 to eliminate Shell Stack
 160:			;
 161:			
 162:	0004          	SHSTKS	EQU	4	; NUMBER OF SHSIZE-BYTE SHELL STACK ENTRIES
 163:	0020          	SHSIZE	EQU	32	; SIZE OF A SHELL STACK ENTRY
 164:						;   (STACK SIZE = SHSTKS * SHSIZE)
 165:	0001          		 IF SHSTKS NE 0
 166:	ED00          	SHSTK	EQU	SEG4
 167:				 ELSE
 169:				 ENDIF
 170:			
 171:	ED80          	SEG5	EQU	SEG4+(SHSTKS*SHSIZE)
 172:			
 173:			;
 174:			; The ZCPR3 Message Buffers are mandatory for ZCPR 3.3.
 175:			;
 176:	ED80          	Z3MSG	EQU	SEG5		; ZCPR3 MESSAGE BUFFER
 177:			
 178:	EDD0          	SEG6	EQU	SEG5+80
 179:			
 180:			;
 181:			; The ZCPR3 External FCB is mandatory for ZCPR 3.3.
 182:			;
 183:			
 184:	EDD0          	EXTFCB	EQU	SEG6		; ZCPR3 EXTERNAL FCB
 185:			
 186:	EDF4          	SEG7	EQU	SEG6+36
 187:			
 188:			;
 189:			; The Path is mandatory for ZCPR 3.3.  No more than 5 path elements can be
 190:			; used with this Z3BASE.LIB file.
 191:			;
 192:			
 193:	EDF4          	EXPATH	EQU	SEG7		; EXTERNAL PATH
 194:	0005          	EXPATHS	EQU	5		; 5 2-byte Path Elements
 195:							;  (PATH SIZE = EXPATHS*2 + 1)
 196:			
 197:	EDFF          	SEG8	EQU	SEG7+(EXPATHS*2)+1
 198:			
 199:			;
 200:			; The ZCPR3 Wheel Byte is mandatory for ZCPR 3.3.
 201:			;
 202:			
 203:	EDFF          	Z3WHL	EQU	SEG8		; WHEEL BYTE ADDRESS
 204:			
 205:	EE00          	SEG9	EQU	SEG8+1
 206:			
 207:			;
 208:			; ZCPR3 Named Directory Buffer definition.  Set Z3NDIRS to 0 to eliminate
 209:			; the named directory buffer.  If Z3NDIRS is changed, also change the seg11
 210:			; equate below.
 211:			;
 212:	001C          	Z3NDIRS	EQU	28		; 28 18-byte Named Directory Elements permitted
 213:							;   (NDIR SIZE = Z3NDIRS*18 + 1 for trailing 0)
 214:	0001          		 IF	Z3NDIRS NE 0
 215:	EE00          	Z3NDIR	EQU	SEG9		; ZCPR3 NAMED DIRECTORY AREA
 216:				 ELSE
 218:				 ENDIF
 219:			
 220:	EF00          	SEG11	EQU	SEG9+256	; add 512 for 28-entry NDR
 221:							; add 256 for 14-entry NDR ("standard")
 222:							; add 0 if Z3NDIRS is set to 0
 223:			
 224:			;
 225:			; The ZCPR3 External Command Line Buffer is mandatory for ZCPR 3.3.
 226:			;
 227:			
 228:	EF00          	Z3CL	EQU	SEG11	; ZCPR3 COMMAND LINE BUFFER
 229:	00D0          	Z3CLS	EQU	208	; SIZE OF COMMAND LINE BUFFER
 230:			
 231:	EFD0          	SEG12	EQU	SEG11+Z3CLS
 232:			
 233:			;
 234:			; The ZCPR3 External Stack is mandatory for ZCPR 3.3.
 235:			;
 236:			
 237:	EFD0          	EXTSTK	EQU	SEG12	; ZCPR3 EXTERNAL STACK
 238:			
 239:			; end of Z3BASE.LIB
**** zsdos.asm ****
  92:				include	zsdos.lib		; Get initialization code
**** zsdos.lib ****
   1:			;.....
   2:			; ZSDOS Customization.  		-HFB,  18 Sept 1987
   3:			;					revised 07/17/88 CWC
   4:			
   5:	0000          	FALSE	EQU	0
   6:	FFFF          	TRUE	EQU	NOT FALSE
   7:			
   8:			; Set these conditionals before assembly
   9:			
  10:			;****************************************************************************
  11:			; In the General Public Release version, we have included an equate which
  12:			; controls an additional unreleased fix (which only Howard Goldstein found).
  13:			; If the following equate is set TRUE, a version 1.1 BDOS will be produced
  14:			; which will require no changes to any released utilities.  If set to FALSE,
  15:			; a version 1.2 BDOS will result, and many support utility libraries and
  16:			; overlays will need to be revised to make them function properly.    HFB
  17:			
  18:	FFFF          	ZSDOS11	EQU	TRUE			; Set True for Ver 1.1, False for 1.2
  19:			
  20:			;****************************************************************************
  21:			
  22:	FFFF          	ZS	EQU	TRUE      		; Set True for ZSDOS, False for ZDDOS
  23:			
  24:			;----------
  25:			;   Select assembler for ZSDOS.  Any modifications to source code must
  26:			; support these assemblers at minimum.
  27:			
  28:	FFFF          	SLR	EQU	TRUE		; SLR Z80ASM or SLR180 Assembler, OR ZMAC
  29:							; ... and Linux Z80 cross asm. zmac too !!
  30:	0000          	ZAS	EQU	FALSE 		; MITEK/ECHELON ZAS Assembler (3.0 or later)
  31:			
  32:	0000          		  IF ZAS
  34:				  ENDIF
  35:			
  36:	FFFF          		  IF  SLR
  37:	0000          		.Z80
  38:			;	NAME	('DOS')
  39:				  ENDIF
  40:			
  41:	0000          		  IF ZAS AND ZS
  47:				  ENDIF
  48:	0000          		  IF ZAS AND (NOT ZS)
  54:				  ENDIF
  55:			
  56:	FFFF          		  IF SLR AND ZS
  57:	FFFF          		   IF  ZSDOS11
  58:				TITLE	'ZSDOS 1.1 - Enhanced CP/M BDOS Replacement'
  59:				   ELSE		;~Zsdos11
  61:				   ENDIF	;Zsdos11
  62:				  ENDIF
  63:	0000          		  IF SLR AND (NOT ZS)
  69:				  ENDIF
  70:			
  71:			;----------
  72:			;   P2DOS introduced a search path feature compatible with that used in
  73:			; Richard Conn's ZCPR2 and ZCPR3.  If a requested file is not located in
  74:			; the currently logged Drive/User, the SEARCH routine will sequentially
  75:			; scan along the path until either the file is found or the end of the
  76:			; path is reached.
  77:			
  78:	FFFF          		  IF	ZS
  79:	D7F1          	PATHAD	EQU	IPATH		; Set to the desired ZCPR2/3 search path.
  80:				  ELSE			; use 0000H to disable path.  A short
  82:				  ENDIF			; in ZSDOS.  ZDDOS does not use path.
  83:			
  84:			;----------
  85:			;   The WHEEL byte may be sensed from within ZSDOS by setting the following
  86:			; address to that of the ZCPR3 WHEEL byte.  A value of 0 disables the WHEEL
  87:			; byte sensing.
  88:			
  89:	EDFF          	WHLADR	EQU	Z3WHL		; Set WHEEL byte address (0FDFFH for SB180)
  90:			
  91:			;----------
  92:			;   Some systems, like the Kaypro 4, only recognize changes between single
  93:			; and double-sided disks when the system is warm booted; BDOS Function 13
  94:			; (reset disk) will not work.  By adding a "hook" to the BIOS of these mach-
  95:			; ines and setting RESDSK to TRUE, BDOS functions 13 and 37 will allow changes
  96:			; between single and double-sided disks; very handy for disk housekeeping
  97:			; utilities such as NSWP, NULU, and cataloging programs.
  98:			
  99:			;   The "hook" is added as follows: Obtain the source to your computer's BIOS.
 100:			; Examine the code for WARM BOOT.  Somewhere, there should be a call to a rou-
 101:			; tine which initializes the disk system after a warm boot, or which detects
 102:			; changes between single and double-sided disks.  Call this routine DISKINT
 103:			; for purposes of discussion.  Modify your BIOS's cold boot routine to ini-
 104:			; tialize 3 bytes at address SETDSK as "JP DISKINT".  The location of SETDSK
 105:			; is arbitrary, it may be in your BIOS, or in a reserved spot in CP/M's page 0.
 106:			
 107:	0000          	RESDSK	EQU	FALSE
 108:			
 109:	0000          	   IF	   RESDSK
 111:			   ENDIF		; resdsk (bh)
 112:			
 113:			;----------
 114:			;   The following equate is used to produce separate code and data segments
 115:			; for blowing ZSDOS into ROM.  Calling BDOS Function 0 will initialize the
 116:			; Data Segment to default values.
 117:			
 118:	0000          	ROM	EQU	FALSE		; Separate data and code?
 119:			
 120:			;----------
 121:			;   Many ZSDOS features can be controlled while ZSDOS is running by altering
 122:			; the FLAG byte.  Set the following equate to your desired configuration based
 123:			; on your requirements.  The individual bit assignments in the FLAG byte are:
 124:			;
 125:			; Bit -	7 6 5 4 3 2 1 0
 126:			;	 \ \ \ \ \ \ \ \__Public File Enable (1) / Disable (0)
 127:			;	  \ \ \ \ \ \ \___Public/Path Write Enable (1) / Disable (0)
 128:			;	   \ \ \ \ \ \____Read-Only Enable (1) / Disable (0)
 129:			;	    \ \ \ \ \_____Fast Fixed Disk Relog Enable (1) / Disable (0)
 130:			;	     \ \ \ \______Disk Change Warning Enable (1) / Disable (0)
 131:			;	      \ \ \_______ZCPR2/3 Path Enable (1) / Disable (0)
 132:			;	       \ \________Path without System Enable (1) / Disable (0)
 133:			;		\_________(Reserved)
 134:			
 135:	006D          	FLGBITS	EQU	01101101B	; PUBLIC On, P/P Write Off, R/O On,
 136:							; Fast Relog On,Disk Change warning Off,
 137:							; Path On, No System path On
 138:			
 139:			; The operation of Bit 6 represents a deviation from the description of PUBLIC
 140:			; Files as given in DDJ Article by Bridger Mitchell and Derek McKay of Plu*
 141:			; Perfect Systems.  The PUBLIC Specification states that Public Files will NOT
 142:			; be found by any wildcard reference except when a "?" is in the FCB+0 byte.
 143:			; The code here relaxes that requirement as follows:  If we are in the same
 144:			; user area as the public file, then don't report the file as PUBLIC, but find
 145:			; it.  This has a nasty side effect - it allows erasing of PUBLIC files if we
 146:			; are in the same area.  However, these files also show up on the directory
 147:			; (they wouldn't otherwise), so at least we should know we're blasting them.
 148:			
 149:			;----------
 150:			; Equates for selecting ZSDOS or ZDDOS configurations
 151:			
 152:			; Since much ZSDOS code must be deleted to embed DateStamper in ZDDOS, the
 153:			; following flags do the stripping:
 154:			;	PICKEY	- True = Don't save users' DE register
 155:			;	CTLREN	- True = Add ^R Retype line to cons read, False = No ^R
 156:			;	UNROLL	- True = Inline code for shifts, False = collapse into loops
 157:			;	UPATH	- True = Add User path from OS, False = No OS path search
 158:			
 159:	FFFF          		  IF ZS
 160:	FFFF          	CTLREN	EQU	TRUE
 161:	FFFF          	UNROLL	EQU	TRUE
 162:	FFFF          	UPATH	EQU	TRUE
 163:	0000          	PICKEY	EQU	FALSE
 164:				  ELSE
 169:				  ENDIF
 170:			
 171:			;----------
 172:			; To Use the Named-COMMON aspect of NZCOM and JETLOADER (tm), the BIOS must
 173:			; be referenced from the _BIOS_ name.  If operating under this scheme, set
 174:			; the ZRL equate to TRUE.  With the ZRL equate set to FALSE, a standalone
 175:			; .REL file will be produced with no external requirements.
 176:			
 177:	0000          	ZRL	EQU	FALSE		; Set True .ZRL file with COMMON for NZCOM,
 178:							;     False to produce straight .REL file
 179:			
 180:			
**** zsdos.asm ****
  93:			
  94:	0000          	RAMLOW	EQU	0000H		; Start address memory
  95:	CA00          		ORG	BDOSB
  96:			
  97:			; 	CSEG
  98:	CA00          	ZSDOS	EQU	$		; Start address ZSDOS
  99:			
 100:	0000          		  IF  	ZRL
 104:				  ELSE
 105:			;BIOS	EQU	ZSDOS+0E00H	; already in common.asm
 106:				  ENDIF
 107:			
 108:	D800          	BOOT	EQU	BIOS+0000H	; Cold Boot
 109:	D803          	WBOOT	EQU	BIOS+0003H	; Warm Boot
 110:	D806          	CONST	EQU	BIOS+0006H	; Console Status
 111:	D809          	CONIN	EQU	BIOS+0009H	; Console Input
 112:	D80C          	CONOUT	EQU	BIOS+000CH	; Console Output
 113:	D80F          	BDLIST	EQU	BIOS+000FH	; List Output
 114:	D812          	PUNCH	EQU	BIOS+0012H	; Punch Output
 115:	D815          	READER	EQU	BIOS+0015H	; Reader Input
 116:	D818          	HOME	EQU	BIOS+0018H	; Home Disk
 117:	D81B          	SELDSK	EQU	BIOS+001BH	; Select Disk
 118:	D81E          	SETTRK	EQU	BIOS+001EH	; Select Track
 119:	D821          	SETSEC	EQU	BIOS+0021H	; Select Sector
 120:	D824          	SETDMA	EQU	BIOS+0024H	; Set DMA Address
 121:	D827          	BDREAD	EQU	BIOS+0027H	; Read 128 Bytes
 122:	D82A          	WRITE	EQU	BIOS+002AH	; Write 128 Bytes
 123:	D82D          	LISTST	EQU	BIOS+002DH	; List Status
 124:	D830          	SECTRN	EQU	BIOS+0030H	; Sector Translation
 125:	D833          	BTIME	EQU	BIOS+0033H	; BIOS clock driver
 126:	D836          	BOTDSK	equ	BIOS+0036H	; BIOS boot drive id
 127:			
 128:			; Internal Definitions
 129:	FFFF          		  IF  ZSDOS11
 130:	0001          	VERMAJ	EQU	1		; Major version number
 131:	0001          	VERMIN	EQU	1		; Minor version number
 132:				  ELSE
 135:				  ENDIF		;Zs
 136:	0011          	BDVERS	EQU	VERMAJ*10H+VERMIN
 137:			
 138:	0003          	CONTC	EQU	03H		; Key to generate warm boot
 139:	0008          	CONTH	EQU	08H		; Backspace
 140:	0009          	TAB	EQU	09H		; Tab
 141:	000A          	LF	EQU	0AH		; Line feed
 142:	000D          	CR	EQU	0DH		; Carriage return
 143:	0010          	CONTP	EQU	10H		; Set/reset print flag
 144:	0012          	CONTR	EQU	12H		; Retype line
 145:	0013          	CONTS	EQU	13H		; Stop console output
 146:	0018          	CONTX	EQU	18H		; Delete line (backspaces)
 147:	0015          	CONTU	EQU	15H		; Same as Control-X
 148:	007F          	RUBOUT	EQU	7FH		; Delete last char
 149:			
 150:	001F          	MAXEXT	EQU	1FH		; Maximum extent number
 151:	003F          	MAXMOD	EQU	3FH		; Maximum data module number
 152:			
 153:	0091          	TDCKSM	EQU	91H		; CHECKSUM OF !!!TIME&.DAT
 154:			
 155:			; Attribute Bit Definitions
 156:			
 157:	0002          	PUBATT	EQU	2		; Public attribute offset
 158:	0007          	PSFATT	EQU	7		; Public/system file (internal only)
 159:	0008          	WHLATT	EQU	8		; Wheel protect attribute offset
 160:	0009          	ROATT	EQU	9		; Read only attribute offset
 161:	000A          	SYSATT	EQU	10		; System attribute offset
 162:	000B          	ARCATT	EQU	11		; Archive attribute offset
 163:			
 164:			; FCB POSITION EQUATES
 165:			
 166:	000C          	FCBEXT	EQU	12		; Extent number
 167:	000D          	FCBUSR	EQU	13		; User valid at offset 13 if set (internal)
 168:	000E          	FCBMOD	EQU	14		; Data module number - D7 used as unmod flag
 169:	000F          	FCBREC	EQU	15		; Record number
 170:	0020          	NXTREC	EQU	32		; Next record number
 172:			;**************************************************************
 173:			;*	 Z S D O S	P r o g r a m	  S t a r t	      *
 174:			;**************************************************************
 175:			
 176:			; WARNING!!  Do NOT change labels or sequences of ZSDOS through ZSDOS+25H
 177:			;   ID string added for easy identification in running system (hfb)
 178:			
 179:	FFFF          		  IF  ZS
 180:	CA00  5A53444F		DEFB	'ZSDOS '	; Used in CP/M for serial number. these bytes
	      5320
 181:				  ELSE			; are patched by INSTALOS to contain the serial
 183:				  ENDIF			; still be used without problems.
 184:			
 185:			; ZSDOS Entry Point
 186:			
 187:	CA06  C39BCA  	START:	JP	ENTRY		; Jump to start of program code
 188:			
 189:			; CP/M 2.2 Compatable Error Vector Table
 190:			
 191:	CA09  4CCD    	STBDSC:	DEFW	ERROR		; Bad sector message
 192:	CA0B  4CCD    	STSEL:	DEFW	ERROR		; Select error
 193:	CA0D  4CCD    	STRO:	DEFW	ERROR		; Drive read only
 194:	CA0F  4CCD    	SFILRO:	DEFW	ERROR		; File read only
 195:			
 196:			; External Path Name
 197:			
 198:	CA11  F1D7    	PATH:	DEFW	PATHAD		; Path address for file open, 0 if no path
 199:			
 200:			; Wheel Byte Pointer
 201:			
 202:	CA13  FFED    	WHEEL:	DEFW	WHLADR		; Address of wheel byte, 0 if none
 203:			
 204:			; User configuration byte
 205:			
 206:	CA15  6D      	FLAGS:	DEFB	FLGBITS		; Flag byte set in zsdos.lib
 207:			
 208:			; Dispatch table for time/date stamp routines
 209:			
 210:			; ZSDOS uses all vectors in this table as indicated.  ZDDOS uses all but
 211:			; STUPDV, GETSTV, and PUTSTV.  STCRV is used to store the address of the
 212:			; stamp for ZDDOS, thus allowing ZSCONFIG to enable and disable stamping
 213:			; of Last Access and Modify.
 214:			
 215:			; GSTIME:	DEFW	DOTDER		; Address of get/set time/date routine (hfb)
 216:			
 217:	CA16  33D8    	GSTIME:	DEFW	BTIME		; Address of get/set time/date routine (hfb)
 218:	FFFF          		  IF	ZS
 219:	FFFF          		   IF	STMPZS
 220:	CA18  44E8    	STLAV:	DEFW	ZDSSTPR+12	; Address of stamp last access routine
 221:			; STLAV:	DEFW	DOTDER		; Address of stamp last access routine
 222:				   ELSE
 224:				   ENDIF
 225:	CA1A  38E8    	STCRV:	DEFW	ZDSSTPR+0	; Address of stamp create routine
 226:	CA1C  3BE8    	STUPDV:	DEFW	ZDSSTPR+3	; Address of stamp modify routine
 227:				  ELSE
 231:				  ENDIF
 232:	CA1E  3EE8    	GETSTV:	DEFW	ZDSSTPR+6	; Address of get stamp routine
 233:	CA20  41E8    	PUTSTV:	DEFW	ZDSSTPR+9	; Address of set stamp routine
 234:	CA22  DDD7    		DEFW	DOTDER		; Dummy vector to disable with ZSCONFIG
 235:	CA24  0000    	UNLOAD:	DEFW	0		; Pointer to remove Time Stamp routine
 236:			
 238:			;********************************************************
 239:			;*	 Z S D O S	L o w	 R A M	 D a t a	*
 240:			;********************************************************
 241:			
 242:			; RAM has been moved down here to an area that is compatable with ZRDOS per
 243:			; suggestion by Hal Bower.  The actual addresses used are NOT compatable with
 244:			; ZRDOS.
 245:			
 246:			; Due to ZSDOS's smaller RAM area, any program that saves RAM in accordance
 247:			; with ZRDOS's specifications for re-entry into BDOS should work under ZSDOS
 248:			; without problems.  Some code will be saved also, as well as the Flag Byte,
 249:			; but this should be no problem for IOP'S.
 250:			
 251:			; The Write Protect, Login, and Hard Disk Login Vectors are kept at the top of
 252:			; ZSDOS, as they must reflect the current status of the Disk System and hence
 253:			; should NOT be saved with other system variables Under ANY Circumstance!
 254:			
 255:	0000          		  IF  ROM
 257:				  ENDIF
 258:	CA26          	BGLORAM:
 259:			;--------------------------------------------------------------------
 260:			; The following locations MUST remain in EXACTLY this order
 261:			
 262:	CA26  00      	TABCNT:	DEFB	0		; Tab counter
 263:	CA27  00      	TABCX1:	DEFB	0		; Temporary Tab counter (used by RDBUF)
 264:			;--------------------------------------------------------------------
 265:			
 266:	CA28  00      	FCONTP:	DEFB	0		; List enable flag (Control-P) - used by BGii
 267:	CA29  00      	LASTCH:	DEFB	0		; Last character - used by BGii
 268:			
 269:			;--------------------------------------------------------------------
 270:			; The following locations MUST remain in EXACTLY this order
 271:			
 272:	CA2A  00      	USER:	DEFB	0		; User number - used by BGii
 273:	CA2B  00      	DEFDRV:	DEFB	0		; Default drive number - used by BGii and DS
 274:	CA2C  00      	DRIVE:	DEFB	0		; Drive number
 275:			;--------------------------------------------------------------------
 276:			
 277:	CA2D  00      	FCB0:	DEFB	0		; FCB byte 0
 278:			
 279:	CA2E          	BGHIRAM:
 280:	CA2E  8000    	DMA:	DEFW	0080H		; DMA address
 281:			
 282:	CA30  0000    	TRANS:	DEFW	0		; Translation vector
 283:	CA32  0000    	TEMP0:	DEFW	0		; Number of files on drive
 284:			
 285:			
 286:	CA34  0000    	DIRBUF:	DEFW	0		; Directory buffer pointer - used by bgii
 287:	CA36  0000    	IXP:	DEFW	0		; Disk parameter block
 288:	CA38  0000    	CSV:	DEFW	0		; Check sum pointer
 289:	CA3A  0000    	ALV:	DEFW	0		; Allocation vector pointer
 290:			
 291:			;--------------------------------------------------------------------
 292:			; The following locations MUST remain in EXACTLY this order
 293:			; Copy of DPB for Current Drive
 294:			
 295:	003C          	DPBOF	EQU	$-ZSDOS		; Value needed by ZSDOS
 296:			
 297:	CA3C  0000    	MAXSEC:	DEFW	0		; Number of sectors/track
 298:	CA3E  00      	NBLOCK:	DEFB	0		; Block shift
 299:	CA3F  00      	NMASK:	DEFB	0		; Mask number of blocks
 300:	CA40  00      	NEXTND:	DEFB	0		; Extent mask
 301:	CA41  0000    	MAXLEN:	DEFW	0		; Maximum block number-1
 302:	CA43  0000    	NFILES:	DEFW	0		; Maximum number of files-1
 303:	CA45  00      	NDIR0:	DEFB	0		; First two entries ALV buffer
 304:	CA46  00      		DEFB	0		; ..(NDIR1)
 305:	CA47  0000    	NCHECK:	DEFW	0		; Number of checksum entries
 306:	CA49  0000    	NFTRK:	DEFW	0		; First track number
 307:			;--------------------------------------------------------------------
 308:	CA4B  00      	FUNCT:	DEFB	0		; Function number
 309:	CA4C  0000    	PEXIT:	DEFW	0		; Exit code
 310:			;--------------------------------------------------------------------
 311:			; The following locations MUST remain in EXACTLY this order
 312:			
 313:	CA4E  00      	FLDRV:	DEFB	0		; Drive select used flag
 314:	CA4F  00      	RDWR:	DEFB	0		; Read/write flag
 315:	CA50  00      	SEARQU:	DEFB	0		; Search question mark used
 316:	CA51  00      	SEARPU:	DEFB	0		; Search public file
 317:			;--------------------------------------------------------------------
 318:	CA52  0000    	RECDIR:	DEFW	0		; Record directory (checksum)
 319:	CA54  0000    	FILCNT:	DEFW	0		; File counter
 320:	CA56  00      	SECPNT:	DEFB	0		; Sector pointer
 321:	CA57  00      	SUBFLG:	DEFB	0		; Submit flag (reset disk command)
 322:			
 323:	CA58  0000    	DCOPY:	DEFW	0		; Copy address FCB
 324:	CA5A  00      	SEAREX:	DEFB	0		; Exit code search
 325:	CA5B  00      	SEARNB:	DEFB	0		; Search number of bytes
 326:	CA5C  00      	ERMODE:	DEFB	0		; BDOS error mode
 327:			
 328:	CA5D  0000    	ARWORD:	DEFW	0		; De argument on entry - used for BGii
 329:	CA5F  0000    	DEVAL:	DEFW	0		; Return value for DE reg
 330:	CA61  0000    	SPSAVE:	DEFW	0		; Stack pointer location
 331:	FFFF          		  IF  ZS
 332:	CA63  5A53444F		DEFB	'ZSDOS 1.1 Copyri'
	      5320312E
	      3120436F
	      70797269
 333:				  ELSE
 335:				  ENDIF
 336:	CA73  67687420		DEFB	'ght (c) 1987,88 '
	      28632920
	      31393837
	      2C383820
 337:	CA83  20432E57		DEFB	' C.W.Cotrill & H'
	      2E436F74
	      72696C6C
	      20262048
 338:	CA93  2E462E42		DEFB	'.F.Bow'
	      6F77
 339:	CA99  6572    	IXSAVE:	DEFB	'er'		; User's IX register
 340:	CA9B          	ZSDOSS:				; ZSDOS stack
 341:			
 342:	CA9B          	BGRAMTOP EQU	ZSDOSS
 344:			; 	CSEG
 345:			;**********************************************************************
 346:			;*		 Z S D O S   e n t r y	 p o i n t		      *
 347:			;**********************************************************************
 348:			
 349:	CA9B  AF      	ENTRY:	XOR	A		; Clear A
 350:	CA9C  47      		LD	B,A		; For later 16 bit adds
 351:	CA9D  6F      		LD	L,A
 352:	CA9E  67      		LD	H,A		; Set HL to zero
 353:	CA9F  224CCA  		LD	(PEXIT),HL	; Clear exit code
 354:	CAA2  224ECA  		LD	(FLDRV),HL	; Reset drive select and R/W flags
 355:	CAA5  ED7361CA		LD	(SPSAVE),SP	; Save stack pointer
 356:	CAA9  319BCA  		LD	SP,ZSDOSS	; Get internal stack pointer
 357:	CAAC  DDE5    		PUSH	IX		; Save index register on our stack
 358:	CAAE  D5      		PUSH	DE		; Save parameter register
 359:	CAAF  DDE1    		POP	IX		; Get it back in IX
 360:	CAB1  DD225DCA		LD	(ARWORD),IX	; Save in memory for BGii
 361:	FFFF          		  IF  NOT PICKEY
 362:	CAB5  DD225FCA		LD	(DEVAL),IX	; ..and for non-file access returns
 363:				  ENDIF
 364:	CAB9  21E6CD  		LD	HL,DOSEXIT	; Get exit address ZSDOS
 365:	CABC  E5      		PUSH	HL		; Save it on stack to return from ZSDOS
 366:	CABD  79      		LD	A,C		; Get function code - B reg = 0
 367:	CABE  324BCA  		LD	(FUNCT),A	; Save it for later use
 368:	CAC1  FE0C    		CP	12		; Is it a non-disk function?
 369:	CAC3  380D    		JR	C,ENTRY0	; ..jump if so
 370:	CAC5  FE31    		CP	MAXCMD		; Cmnd < Maximum Command Number (48)?
 371:	CAC7  380D    		JR	C,ENTRY1	; ..jump if disk function
 372:			
 373:			; Extended function scanner for added functions
 374:			
 375:	CAC9  FE62    		CP	98		; Is it less than Cmd98?
 376:	CACB  D8      		RET	C		; ..return if so
 377:	CACC  FE68    		CP	103+1		; Is it greater than Cmd103?
 378:	CACE  D0      		RET	NC		; ..quit if so
 379:	CACF  D631    		SUB	98-MAXCMD	; Rework so 98-->49..103-->54
 380:	CAD1  4F      		LD	C,A		; Save reworked function #
 381:						; ..fall thru to entry0..
 382:			
 383:			; If Non-disk Function (ie Function # less than 12), push the address of
 384:			;  the SAVEA routine on the Stack (save A reg as return code).	Saves
 385:			;  code in Console Routines, as simple RET can be used in most cases.
 386:			
 387:	CAD2  21BBCE  	ENTRY0:	LD	HL,SAVEA
 388:	CAD5  E5      		PUSH	HL		; Vector return thru A reg save
 389:	CAD6  21E2CA  	ENTRY1:	LD	HL,CTABLE	; Load table
 390:	CAD9  09      		ADD	HL,BC		; Add
 391:	CADA  09      		ADD	HL,BC		; Add twice to get word value
 392:	CADB  7E      		LD	A,(HL)		; Get LSB
 393:	CADC  23      		INC	HL		; Pointer to MSB
 394:	CADD  66      		LD	H,(HL)		; Get MSB
 395:	CADE  6F      		LD	L,A		; Save LSB in L
 396:			
 397:			; Copy byte argument into A and C to simplify Function calls.  This allows
 398:			;  direct BIOS jumps for several functions with resulting code savings.
 399:			
 400:	CADF  4B      		LD	C,E		; Place arg in C for BIOS
 401:	CAE0  7B      		LD	A,E		; And in A for others
 402:	CAE1  E9      		JP	(HL)		; Jump to routine
 403:			
 405:			;******************************************************
 406:			;*	 C O M M A N D	    T A B L E		      *
 407:			;******************************************************
 408:	CAE2          	CTABLE:
 409:	0000          		  IF  ROM
 411:				  ELSE
 412:	CAE2  CACD    		DEFW	ERROR5		; Warm boot (BIOS) with ERMODE clear
 413:				  ENDIF
 414:	CAE4  50CB    		DEFW	CMND01		; Console input
 415:	CAE6  64CC    		DEFW	WRCON		; Console output
 416:	CAE8  15D8    		DEFW	READER		; Reader input (BIOS)
 417:	CAEA  12D8    		DEFW	PUNCH		; Punch output (BIOS)
 418:	CAEC  0FD8    		DEFW	BDLIST		; List output (BIOS)
 419:	CAEE  5ACB    		DEFW	CMND06		; Direct console I/O
 420:	CAF0  91CB    		DEFW	CMND07		; Get I/O byte
 421:	CAF2  8ECB    		DEFW	CMND08		; Set I/O byte
 422:	CAF4  D5CC    		DEFW	CMND09		; Print string
 423:	CAF6  95CB    		DEFW	CMND10		; Read console buffer
 424:	CAF8  B7CC    		DEFW	CMND11		; Get console status
 425:	CAFA  CFCE    		DEFW	CMND12		; Return version number
 426:	CAFC  0ACE    		DEFW	CMND13		; Reset disk system
 427:	CAFE  7ACF    		DEFW	CMND14		; Select disk
 428:	CB00  B4D4    		DEFW	CMND15		; Open file
 429:	CB02  A8D1    		DEFW	CMND16		; Close file
 430:	CB04  6ECE    		DEFW	CMND17		; Search for first
 431:	CB06  95CE    		DEFW	CMND18		; Search for next
 432:	CB08  A5CE    		DEFW	CMND19		; Delete file
 433:	CB0A  BED5    		DEFW	CMND20		; Read sequential
 434:	CB0C  FFD5    		DEFW	CMND21		; Write sequential
 435:	CB0E  02D5    		DEFW	CMND22		; Make file
 436:	CB10  B0CE    		DEFW	CMND23		; Rename file
 437:	CB12  E8CE    		DEFW	CMND24		; Return login vector
 438:	CB14  B8CE    		DEFW	CMND25		; Return current disk
 439:	CB16  33D2    		DEFW	CMND26		; Set DMA address
 440:	CB18  E4CE    		DEFW	CMND27		; Get address allocation vector
 441:	CB1A  03D1    		DEFW	CMND28		; Write protect disk
 442:	CB1C  DCCE    		DEFW	CMND29		; Get R/O vector
 443:	CB1E  C7CE    		DEFW	CMND30		; Set file attributes
 444:	CB20  ECCE    		DEFW	CMND31		; Get address disk parameter header (DPH)
 445:	CB22  FBCE    		DEFW	CMND32		; Get/set user code
 446:	CB24  B4D5    		DEFW	CMND33		; Read random
 447:	CB26  F4D5    		DEFW	CMND34		; Write random
 448:	CB28  07CF    		DEFW	CMND35		; Compute file size
 449:	CB2A  0FCF    		DEFW	CMND36		; Set random record
 450:	CB2C  1CCE    		DEFW	CMND37		; Reset multiple drive
 451:	CB2E  BECE    		DEFW	DUMMY		; Function 38 (unused)
 452:	CB30  E0CE    		DEFW	CMND39		; Return fixed disk login vector
 453:	CB32  F4D5    		DEFW	CMND40		; Write random with zero fill
 454:	CB34  BECE    		DEFW	DUMMY		; Function 41 (unused)
 455:	CB36  BECE    		DEFW	DUMMY		; Function 42 (unused)
 456:	CB38  BECE    		DEFW	DUMMY		; Function 43 (unused)
 457:	CB3A  BECE    		DEFW	DUMMY		; Function 44 (unused)
 458:	CB3C  F7CE    		DEFW	CMND45		; Set Error Mode
 459:	CB3E  BECE    		DEFW	DUMMY		; Function 46 (unused)
 460:	CB40  F0CE    		DEFW	CMND47		; Return DMA
 461:	CB42  D8CE    		DEFW	CMND48		; Return DOS version
 462:			
 463:	0031          	MAXCMD	EQU	($-CTABLE)/2	; Jww
 464:			
 465:	CB44  D7D7    		DEFW	CMD98		; Get Time	; 49
 466:	CB46  D4D7    		DEFW	CMD99		; Set Time	; 50
 467:	CB48  C2CE    		DEFW	CMD100		; Get Flags	; 51
 468:	CB4A  BFCE    		DEFW	CMD101		; Set Flags	; 52
 469:	CB4C  A4D7    		DEFW	CMD102		; Get Stamp	; 53
 470:	CB4E  A4D7    		DEFW	CMD103		; Put Stamp	; 54
 471:			
 473:			;******************************************************
 474:			;*	 N o n - D i s k     F u n c t i o n s	      *
 475:			;******************************************************
 476:			
 477:	0000          		  IF  ROM
 502:				  ENDIF		; Rom
 503:			
 504:			;.....
 505:			; I/O Routines
 506:			
 507:			; ZSDOS Console Input.	Read character from Console and Echo
 508:			;  If Char=CR,LF,TAB,CONTH or >=Space
 509:			
 510:	CB50  CD75CB  	CMND01:	CALL	GETCH		; Get character (and test it  jww)
 511:	CB53  D8      		RET	C		; Less than space, exit
 512:	CB54  E5      	PUTCH:	PUSH	HL		; Save regs for other calls
 513:	CB55  CD64CC  		CALL	WRCON		; Echo character
 514:	CB58  E1      		POP	HL
 515:	CB59  C9      		RET
 516:			
 517:			; Direct Console Input/Output
 518:			;  Call with Char in C and E - Enhanced to CP/M-3 Spec
 519:			;  Checks ZSDOS typeahead for reliable console I/O under all conditions
 520:			;  as per a suggestion by Bridger Mitchell.
 521:			
 522:	CB5A  1C      	CMND06:	INC	E		; Test if get char if avail
 523:	CB5B  2814    		JR	Z,DCIO1		; Yes do input
 524:	CB5D  1C      		INC	E		; Test for 0FEH
 525:	CB5E  2806    		JR	Z,DCIO2		; Yes, get status
 526:	CB60  1C      		INC	E		; Test for 0FDH
 527:	CB61  2812    		JR	Z,GETCH		; Yes, wait for input char
 528:	CB63  C30CD8  		JP	CONOUT		; Else print char
 529:			
 530:	CB66  3A29CA  	DCIO2:	LD	A,(LASTCH)	; Check for buffered char
 531:	CB69  B7      		OR	A
 532:	CB6A  3E01    		LD	A,0001B		; ..preset ready
 533:	CB6C  CC06D8  		CALL	Z,CONST		; Get console status
 534:	CB6F  A7      		AND	A		; Test it
 535:	CB70  C9      		RET			; And return it to caller
 536:			
 537:	CB71  CD66CB  	DCIO1:	CALL	DCIO2		; Get console status
 538:	CB74  C8      		RET	Z		; Exit if no character present
 539:							; Else fall thru
 540:			; Get Character from Console
 541:			
 542:	CB75  2129CA  	GETCH:	LD	HL,LASTCH	; Check ZSDOS type ahead for char
 543:	CB78  7E      		LD	A,(HL)
 544:	CB79  3600    		LD	(HL),0		; Reset last character
 545:	CB7B  B7      		OR	A		; ..set flags
 546:	CB7C  CC09D8  		CALL	Z,CONIN		; Get character (and test it  jww)
 547:			
 548:			; Test Character
 549:			;  Exit Carry=0: CR,LF,TAB,CONTH or >= Space
 550:			;	Carry=1: All other Characters
 551:			
 552:	CB7F  FE0D    		CP	CR		; Is it a carriage return?
 553:	CB81  C8      		RET	Z		; ..return if so
 554:	CB82  FE0A    		CP	LF		; Is it a line feed?
 555:	CB84  C8      		RET	Z		; ..return if so
 556:	CB85  FE09    		CP	TAB		; Is it a tab?
 557:	CB87  C8      		RET	Z		; ..return if so
 558:	CB88  FE08    		CP	CONTH		; Is it a backspace?
 559:	CB8A  C8      		RET	Z		; ..return if so
 560:	CB8B  FE20    		CP	' '		; Test >=space
 561:	CB8D  C9      		RET			; ..and return to caller
 562:			
 563:			; Set I/O Status Byte
 564:			
 565:	CB8E  320300  	CMND08:	LD	(RAMLOW+0003H),A ; And save it in RAM and fall through
 566:			
 567:			; Get I/O Status Byte
 568:			
 569:	CB91  3A0300  	CMND07:	LD	A,(RAMLOW+0003H) ; Get I/O byte from RAM
 570:	CB94  C9      		RET
 571:			
 572:			; Buffered Console Read
 573:			
 574:	CB95  3A26CA  	CMND10:	LD	A,(TABCNT)
 575:	CB98  3227CA  		LD	(TABCX1),A	; Save start tab position
 576:	CB9B  13      		INC	DE
 577:	CB9C  AF      		XOR	A
 578:	CB9D  12      		LD	(DE),A		; Set char count to zero
 579:	CB9E  13      		INC	DE		; Point to actual buffer start
 580:			
 581:	CB9F  D5      	RDBUF1:	PUSH	DE		; Save buffer pointer
 582:	CBA0  CD75CB  		CALL	GETCH		; Get next byte from user
 583:	CBA3  D1      		POP	DE
 584:	CBA4  219FCB  		LD	HL,RDBUF1
 585:	CBA7  E5      		PUSH	HL		; Return address to stack
 586:	CBA8  2A5DCA  		LD	HL,(ARWORD)
 587:	CBAB  4E      		LD	C,(HL)		; Put buffer length in C
 588:	CBAC  23      		INC	HL		; And point to current length
 589:			
 590:	CBAD  FE0D    		CP	CR
 591:	FFFF          		  IF  CTLREN
 592:	CBAF  2802    		JR	Z,JZRBX		; Exit if CR
 593:				  ELSE
 595:				  ENDIF		;Ctlren
 596:			
 597:	CBB1  FE0A    		CP	LF
 598:	FFFF          		  IF  CTLREN
 599:	CBB3  CA4ECC  	JZRBX:	JP	Z,RDBUFX	; ..or LF
 600:				  ELSE
 602:				  ENDIF		;Ctlren
 603:						;..Not CR or LF, so fall thru to next test
 604:			
 605:			; Delete Character from Buffer
 606:			;  RUB, Backspace, CR, LF are NEVER in the Buffer
 607:			
 608:	CBB6  FE7F    	RDBUF2:	CP	RUBOUT		; Delete char?
 609:	CBB8  2804    		JR	Z,DOBACK	; ..jump if so
 610:	CBBA  FE08    		CP	CONTH		; Control-H also deletes
 611:	CBBC  2036    		JR	NZ,RDBUF3	; Skip to next test if no delete
 612:			
 613:	CBBE  7E      	DOBACK:	LD	A,(HL)
 614:	CBBF  A7      		AND	A		; Test if attempting del from empty line
 615:	CBC0  C8      		RET	Z		; ..Exit if so
 616:	CBC1  1B      	DOBAK0:	DEC	DE		; Back up to last character
 617:	CBC2  35      		DEC	(HL)		; Erase from buffer
 618:	CBC3  D5      		PUSH	DE		; Save buffer pointer
 619:	CBC4  46      		LD	B,(HL)		; Get new char count
 620:	CBC5  23      		INC	HL		; Point to first char
 621:	CBC6  EB      		EX	DE,HL
 622:	CBC7  2126CA  		LD	HL,TABCNT
 623:	CBCA  4E      		LD	C,(HL)		; Save current Tab count
 624:	CBCB  23      		INC	HL
 625:	CBCC  7E      		LD	A,(HL)		; Get starting Tab position
 626:	CBCD  2B      		DEC	HL
 627:	CBCE  77      		LD	(HL),A		; Init the counter
 628:	CBCF  04      		INC	B		; Insure non-zero
 629:	CBD0  1805    		JR	DOBAK2		; Jump to done test
 630:			
 631:	CBD2  1A      	DOBAK1:	LD	A,(DE)		; Get char from buffer
 632:	CBD3  CD93CC  		CALL	WRCON2		; Counts chars
 633:	CBD6  13      		INC	DE
 634:	CBD7  10F9    	DOBAK2:	DJNZ	DOBAK1		; Continue count until done
 635:	CBD9  79      		LD	A,C		; Get prior tab count
 636:	CBDA  96      		SUB	(HL)		; Get diff between new and old
 637:	CBDB  47      		LD	B,A		; Set up as count
 638:	CBDC  71      		LD	(HL),C		; Restore prior count
 639:	CBDD  D1      		POP	DE		; Restore buffer pointer
 640:			
 641:			; Delete B Characters from Console
 642:			
 643:	CBDE  D5      		PUSH	DE		; Save pointer
 644:	CBDF  0E08    	DOBAK5:	LD	C,CONTH
 645:	CBE1  C5      		PUSH	BC		; Save counter from destruction
 646:	CBE2  CD0CD8  		CALL	CONOUT
 647:	CBE5  0E20    		LD	C,' '
 648:	CBE7  CD0CD8  		CALL	CONOUT		; Output backspace,space to CON: only
 649:	CBEA  3E08    		LD	A,CONTH
 650:	CBEC  CD64CC  		CALL	WRCON		; Now backspace CON:, counter, and printer
 651:	CBEF  C1      		POP	BC		; Restore counter
 652:	CBF0  10ED    		DJNZ	DOBAK5		; Loop until all done
 653:	CBF2  D1      		POP	DE		; Restore pointer
 654:	CBF3  C9      		RET
 655:			
 656:			; Erase Buffer
 657:			
 658:	CBF4  FE15    	RDBUF3:	CP	CONTU		; Test erase line
 659:	CBF6  2804    		JR	Z,ERALIN	; Do it if so
 660:	CBF8  FE18    		CP	CONTX
 661:	CBFA  200A    		JR	NZ,RDBUF4	; Skip to next test if no erase line
 662:			
 663:	CBFC  AF      	ERALIN:	XOR	A
 664:	CBFD  B6      		OR	(HL)		; Line empty?
 665:	CBFE  C8      		RET	Z		; Exit if so
 666:	CBFF  E5      		PUSH	HL
 667:	CC00  CDC1CB  		CALL	DOBAK0		; Else delete another (skip empty check)
 668:	CC03  E1      		POP	HL
 669:	CC04  18F6    		JR	ERALIN
 670:			
 671:	CC06          	RDBUF4:			; If CTL-R=True, do following code, else bypass
 672:	FFFF          		  IF  CTLREN
 673:	CC06  FE12    		CP	CONTR		; If ^R, type clean buffer version on console
 674:	CC08  2024    		JR	NZ,RDBUF5
 675:	CC0A  E5      		PUSH	HL		; Save pointer to buffer length
 676:	CC0B  CDD2CC  		CALL	CROUT		; Do CR/LF
 677:	CC0E  2126CA  		LD	HL,TABCNT
 678:	CC11  3600    		LD	(HL),0		; Init Tab count
 679:	CC13  23      		INC	HL
 680:	CC14  46      		LD	B,(HL)		; And get Tab offset count
 681:	CC15  3E20    		LD	A,' '
 682:	CC17  04      		inc	b		; [1.1] insure nz value
 683:	CC18  1803    		jr	rety1a		; [1.1] so case of lh side of screen ok
 684:	CC1A  CD64CC  	RETYP1:	CALL	WRCON		; Space off start of line
 685:	CC1D  10FB    	rety1a:	DJNZ	RETYP1
 686:	CC1F  E1      		POP	HL		; Point to buffer length
 687:	CC20  46      		LD	B,(HL)		; Get how many chars to print
 688:	CC21  23      		INC	HL		; Restore buffer pointer
 689:	CC22  EB      		EX	DE,HL		; Put buffer pointer in DE
 690:	CC23  04      		INC	B		; Comp for first DJNZ
 691:	CC24  1805    		JR	RETYP3		; Skip to done test
 692:	CC26  1A      	RETYP2:	LD	A,(DE)		; Get char from buffer
 693:	CC27  CD53CC  		CALL	WRCTL		; Output it
 694:	CC2A  13      		INC	DE		; Bump pointer
 695:	CC2B  10F9    	RETYP3:	DJNZ	RETYP2		; Loop until done
 696:	CC2D  C9      		RET
 697:				  ENDIF		; Ctlren
 698:			
 699:			; Toggle Line Printer Echo
 700:			
 701:	CC2E  FE10    	RDBUF5:	CP	CONTP		; Toggle printer?
 702:	CC30  2007    		JR	NZ,RDBUF6	; Next test if not
 703:	CC32  2128CA  		LD	HL,FCONTP
 704:	CC35  7E      		LD	A,(HL)		; Get printer echo flag
 705:	CC36  2F      		CPL			; Toggle it
 706:	CC37  77      		LD	(HL),A		; Put back
 707:	CC38  C9      		RET
 708:			
 709:			; Check if Control-C is First char in BUFF and Exit if so
 710:			
 711:	CC39  12      	RDBUF6:	LD	(DE),A		; Put character in buffer
 712:	CC3A  E5      		PUSH	HL
 713:	CC3B  CD53CC  		CALL	WRCTL		; Echo the character
 714:	CC3E  E1      		POP	HL
 715:	CC3F  34      		INC	(HL)		; Increment the character count
 716:			
 717:	CC40  7E      		LD	A,(HL)		; Get current length
 718:	CC41  B9      		CP	C		; Test against buffer size
 719:	CC42  280A    		JR	Z,RDBUFX
 720:	CC44  3D      		DEC	A		; Set Z flag for first character
 721:	CC45  1A      		LD	A,(DE)		; Get the character back
 722:	CC46  13      		INC	DE		; ..and bump the pointer
 723:	CC47  C0      		RET	NZ		; Return if not the first character
 724:	CC48  FE03    		CP	CONTC		; Possible user abort?
 725:	CC4A  C0      		RET	NZ		; ..return if not
 726:	CC4B  C3CACD  		JP	ERROR5		; Else jump to error reset exit
 727:			
 728:			; Done with Read Console Buffer Function
 729:			
 730:	CC4E  E1      	RDBUFX:	POP	HL		; Clear RDBUF1 return address
 731:	CC4F  3E0D    		LD	A,CR
 732:	CC51  1811    		JR	WRCON		; ..and echo a CR
 733:			
 734:			; Print Control Character as '^X'
 735:			
 736:	CC53  FE20    	WRCTL:	CP	' '		; Test if control char
 737:	CC55  300D    		JR	NC,WRCON	; Not, send it out
 738:	CC57  FE09    		CP	TAB		; Test if Tab
 739:	CC59  280D    		JR	Z,WRCON0	; It is, so expand with spaces
 740:	CC5B  F5      		PUSH	AF		; Save char
 741:	CC5C  3E5E    		LD	A,'^'		; Output a karet
 742:	CC5E  CD77CC  		CALL	WRCON1		; No need for Tab test here
 743:	CC61  F1      		POP	AF
 744:	CC62  C640    		ADD	A,40H		; Convert to printable
 745:							; And fall thru to WRCON
 746:			
 747:			; Output char with List Echo, Tab Expansion (Function 2)
 748:			
 749:	CC64  FE09    	WRCON:	CP	TAB		; Is it a Tab?
 750:	CC66  200F    		JR	NZ,WRCON1	; ..jump if not
 751:	CC68  3E20    	WRCON0:	LD	A,' '		; Expand Tab with spaces
 752:	CC6A  CD77CC  		CALL	WRCON1		; Write space
 753:	CC6D  3A26CA  		LD	A,(TABCNT)	; Get Tab count
 754:	CC70  E607    		AND	7		; Test if done
 755:	CC72  20F4    		JR	NZ,WRCON0	; No then repeat
 756:	CC74  3E09    		LD	A,TAB		; Return Tab
 757:	CC76  C9      		RET			; Return to caller
 758:			
 759:	CC77  C5      	WRCON1:	PUSH	BC
 760:	CC78  D5      		PUSH	DE		; Save pointers
 761:	CC79  4F      		LD	C,A
 762:	CC7A  C5      		PUSH	BC		; Save character
 763:			
 764:	CC7C          	BGPTCH0	EQU	$+1		;<-- BGii patches this address
 765:			
 766:	CC7B  CDB7CC  		CALL	CMND11		; Test status and CONTS/CONTC
 767:	CC7E  C1      		POP	BC		; Get character back
 768:	CC7F  C5      		PUSH	BC		; Save it again
 769:	CC80  CD0CD8  		CALL	CONOUT		; Output it
 770:	CC83  C1      		POP	BC		; Get character back
 771:	CC84  C5      		PUSH	BC		; Save it again
 772:	CC85  3A28CA  		LD	A,(FCONTP)	; Get printer echo flag
 773:	CC88  B7      		OR	A		; Test it
 774:	CC89  C40FD8  		CALL	NZ,BDLIST	; Non zero => output char to printer
 775:	CC8C  C1      		POP	BC		; Restore character
 776:	CC8D  79      		LD	A,C		; Fall through to count routine
 777:	CC8E  D1      		POP	DE
 778:	CC8F  C1      		POP	BC		; Restore pointers
 779:			
 780:			; Count Characters in line as shown by f10
 781:			
 782:	CC90  2126CA  		LD	HL,TABCNT	; Get pointer to Tab counter
 783:	CC93  34      	WRCON2:	INC	(HL)		; Increment Tab counter
 784:	CC94  FE7F    		CP	RUBOUT		; Test if character = Rubout
 785:	CC96  2815    		JR	Z,WRCON3	; Treat like Backspace
 786:	CC98  FE20    		CP	' '
 787:	CC9A  D0      		RET	NC		; Ok if not Control
 788:	CC9B  FE09    		CP	TAB		; Only DOBACK ever gets Tabs through here
 789:	CC9D  2811    		JR	Z,WRCON4	; Handle differently if Tab
 790:	CC9F  FE08    		CP	CONTH
 791:	CCA1  280A    		JR	Z,WRCON3	; Or Backspace
 792:	CCA3  34      		INC	(HL)		; Must have been echoed as two chars
 793:	CCA4  FE0A    		CP	LF
 794:	CCA6  2805    		JR	Z,WRCON3	; ..unless it's LF
 795:	CCA8  FE0D    		CP	CR		; ..or CR
 796:	CCAA  C0      		RET	NZ
 797:	CCAB  3602    		LD	(HL),2		; Reset Tab count
 798:	CCAD  35      	WRCON3:	DEC	(HL)		; Decrement Tab counter
 799:	CCAE  35      		DEC	(HL)
 800:	CCAF  C9      		RET			; And exit
 801:			
 802:	CCB0  3E07    	WRCON4:	LD	A,7		; Bumped by one already
 803:	CCB2  86      		ADD	A,(HL)		; Tabs are every 8 spaces
 804:	CCB3  E6F8    		AND	0F8H		; ...mod 8
 805:	CCB5  77      		LD	(HL),A		; Save updated Tab count
 806:	CCB6  C9      		RET			; ..and continue
 807:			
 808:			; Get Console Status - BGII uses this routine
 809:			
 810:	CCB7          	BGCONST:
 811:	CCB7  CD66CB  	CMND11:	CALL	DCIO2		; Get character present status
 812:	CCBA  C8      		RET	Z		; ..exit if none
 813:	CCBB  CD75CB  		CALL	GETCH		; Get next console char
 814:	CCBE  FE13    		CP	CONTS		; Is it stop char?
 815:	CCC0  200A    		JR	NZ,GCONS2	; ..jump if Not
 816:	CCC2  CD09D8  		CALL	CONIN		; Get next character
 817:	CCC5  FE03    		CP	CONTC		; Does the user want to exit (^C)?
 818:	CCC7  20EE    		JR	NZ,CMND11	; ..check for another character if not
 819:	CCC9  C3CACD  		JP	ERROR5		; Else jump to warm boot & clear ERMODE
 820:			
 821:	CCCC  3229CA  	GCONS2:	LD	(LASTCH),A	; Save character
 822:	CCCF  3E01    		LD	A,1		; Character present code
 823:	CCD1  C9      		RET			; Return to caller
 824:			
 825:			; Echo CR,LF
 826:			
 827:	CCD2  1149CD  	CROUT:	LD	DE,MCRLF	; Fall through to output routine
 828:			
 829:			; Output Message
 830:			
 831:	CCD5  1A      	CMND09:	LD	A,(DE)		; Get byte from buffer
 832:	CCD6  FE24    		CP	'$'		; Test last byte
 833:	CCD8  C8      		RET	Z		; Yes, then return to caller
 834:	CCD9  13      		INC	DE		; Point to next byte
 835:	CCDA  CD64CC  		CALL	WRCON		; Output character
 836:	CCDD  18F6    		JR	CMND09		; And test again
 837:			
 839:			;**********************************************
 840:			;*	 E r r o r	R o u t i n e s       *
 841:			;**********************************************
 842:			
 843:	CCDF  016400  	PRDEC:	LD	BC,100
 844:	CCE2  CDEDCC  		CALL	NUM
 845:	CCE5  0E0A    		LD	C,10
 846:	CCE7  CDEDCC  		CALL	NUM
 847:	CCEA  010101  		LD	BC,101H
 848:			
 849:			; Display Number
 850:			
 851:	CCED  16FF    	NUM:	LD	D,-1		; Load number -1
 852:	CCEF  14      	NUM1:	INC	D		; Increment number
 853:	CCF0  91      		SUB	C		; Divide by C
 854:	CCF1  30FC    		JR	NC,NUM1		; Not finished then loop
 855:	CCF3  81      		ADD	A,C		; Restore last value
 856:	CCF4  F5      		PUSH	AF		; Save it
 857:	CCF5  7A      		LD	A,D		; Test if "0"
 858:	CCF6  B0      		OR	B		; And if leading zero
 859:	CCF7  2807    		JR	Z,NUM2		; Yes, then exit
 860:	CCF9  47      		LD	B,A		; Set no leading zero
 861:	CCFA  7A      		LD	A,D		; Get number
 862:	CCFB  C630    		ADD	A,'0'		; Make ASCII
 863:	CCFD  CD54CB  		CALL	PUTCH		; Echo number preserving BC
 864:	CD00  F1      	NUM2:	POP	AF		; Restore number
 865:	CD01  C9      		RET			; And exit
 866:			
 867:			; Error Messages
 868:			
 869:	CD02  4368616E	MDSKCH:	DEFB	'Changed$'
	      67656424
 870:			
 871:	CD0A  42616420	MBADSC:	DEFB	'Bad Sector$'
	      53656374
	      6F7224
 872:			
 873:	CD15  4E6F2044	MSEL:	DEFB	'No Drive$'
	      72697665
	      24
 874:			
 875:	CD1E  46696C65	MFILRO:	DEFB	'File '
	      20
 876:			
 877:	CD23  572F5024	MRO:	DEFB	'W/P$'
 878:	FFFF          		 IF ZS
 879:	CD27  5A53444F	MBERR:	DEFB	'ZSDOS'
	      53
 880:				 ELSE
 882:				 ENDIF
 883:	CD2C  20657272		DEFB	' error on $'
	      6F72206F
	      6E2024
 884:			
 885:	CD37  0D0A4361	MBFUNC:	DEFB	CR,LF,'Call'
	      6C6C
 886:	CD3D  3A2024  	MDRIVE:	DEFB	': $'
 887:			
 888:	CD40  20204669	MFILE:	DEFB	'  File: $'
	      6C653A20
	      24
 889:			
 890:	CD49  0D0A24  	MCRLF:	DEFB	CR,LF,'$'
 891:			
 892:			; New ZSDOS error handler - enter w/ error code in B and message pointer
 893:			; in DE
 894:			
 895:	CD4C  3A5CCA  	ERROR:	LD	A,(ERMODE)
 896:	CD4F  4F      		LD	C,A		; Save error mode
 897:	CD50  0F      		RRCA			; Test supress print
 898:	CD51  385C    		JR	C,ERROR3	; Suppressed, so skip dsp
 899:			
 900:			; Print ZSDOS Error on X: Explanation
 901:			
 902:	CD53  C5      		PUSH	BC
 903:	CD54  D5      		PUSH	DE		; Save params
 904:	CD55  CDD2CC  		CALL	CROUT		; Output CR/LF
 905:	CD58  1127CD  		LD	DE,MBERR
 906:	CD5B  CDD5CC  		CALL	CMND09		; Output ZSDOS error on
 907:	CD5E  3A2BCA  		LD	A,(DEFDRV)	; Get current default drive
 908:	CD61  C641    		ADD	A,'A'		; Convert to ascii
 909:	CD63  CD64CC  		CALL	WRCON		; Output it to console
 910:	CD66  113DCD  		LD	DE,MDRIVE	; Point to drive tag
 911:	CD69  CDD5CC  		CALL	CMND09		; Put it also
 912:	CD6C  D1      		POP	DE		; Restore error message pointer
 913:	CD6D  CDD5CC  		CALL	CMND09		; Send message
 914:			
 915:			; Now print CALL: XXX [FILE: XXXXXXXX.XXX]
 916:			
 917:	CD70  1137CD  		LD	DE,MBFUNC
 918:	CD73  CDD5CC  		CALL	CMND09		; Display 'call: '
 919:	CD76  3A4BCA  		LD	A,(FUNCT)	; Get function number
 920:	CD79  CDDFCC  		CALL	PRDEC		; Output it
 921:	CD7C  3A4ECA  		LD	A,(FLDRV)
 922:	CD7F  A7      		AND	A		; Was FCB used?
 923:	CD80  2829    		JR	Z,ERROR2	; ..Skip file name display if not
 924:	CD82  C1      		POP	BC
 925:	CD83  C5      		PUSH	BC		; Get error type
 926:	CD84  DDE5    		PUSH	IX		; Save FCB pointer
 927:	CD86  3A4BCA  		LD	A,(FUNCT)	; ARE WE ERASING A FILE?
 928:	CD89  FE13    		CP	19		; IF SO, GET NAME FROM DIRBUF AS
 929:	CD8B  2004    		JR	NZ,ERROR0	; AMBIG NAME MAY HAVE BEEN USED
 930:	CD8D  CDF1D0  		CALL	CALDIR		; Get DIR buffer pointer
 931:	CD90  E3      		EX	(SP),HL		; To show what we really gagged on
 932:	CD91  1140CD  	ERROR0:	LD	DE,MFILE
 933:	CD94  CDD5CC  		CALL	CMND09		; Output 'file: '
 934:	CD97  E1      		POP	HL		; Point to FCB
 935:	CD98  060B    		LD	B,11		; Output this many chars
 936:	CD9A  23      	ERROR1:	INC	HL
 937:	CD9B  3E03    		LD	A,3
 938:	CD9D  B8      		CP	B		; Time to send '.'?
 939:	CD9E  3E2E    		LD	A,'.'		; Get ready for it
 940:	CDA0  CC54CB  		CALL	Z,PUTCH		; Send it if time
 941:	CDA3  7E      		LD	A,(HL)		; Get char
 942:	CDA4  E67F    		AND	7FH		; Mask attributes
 943:	CDA6  CD54CB  		CALL	PUTCH		; Output it
 944:	CDA9  10EF    		DJNZ	ERROR1
 945:	CDAB  CDD2CC  	ERROR2:	CALL	CROUT		; Send CR,LF
 946:	CDAE  C1      		POP	BC		; Get error mode back
 947:	CDAF  3E04    	ERROR3:	LD	A,4
 948:	CDB1  90      		SUB	B		; Test if select error
 949:	CDB2  200D    		JR	NZ,ERROR4	; Skip if not
 950:	CDB4  212CCA  		ld	hl,drive	; point to old default
 951:	CDB7  7E      		ld	a,(hl)		; get it
 952:	CDB8  2B      		dec	hl		; point to bad drive
 953:	CDB9  BE      		cp	(hl)		; same?
 954:	CDBA  2805    		jr	z,error4	; if so, skip relog
 955:	CDBC  C5      		PUSH	BC
 956:	CDBD  CD81CF  		CALL	SELDK		; Get BIOS back in step
 957:	CDC0  C1      		POP	BC
 958:	CDC1  CB49    	ERROR4:	BIT	1,C		; Test if return error mode
 959:	CDC3  2018    		JR	NZ,ERROR7	; Go if return error
 960:	CDC5  3E01    		LD	A,1
 961:	CDC7  90      		SUB	B		; Test if fatal error
 962:	CDC8  3005    		JR	NC,ERROR6	; If not a fatal error
 963:	CDCA  AF      	ERROR5:	XOR	A
 964:	CDCB  325CCA  		LD	(ERMODE),A	; Set DOS error mode to default CP/M
 965:	CDCE  C7      		RST	0		; ..and leave
 966:			
 967:	CDCF  CD71CB  	ERROR6:	CALL	DCIO1		; Get console char if present
 968:	CDD2  A7      		AND	A		; Test if any
 969:	CDD3  20FA    		JR	NZ,ERROR6	; Keep getting them until typeahead eaten
 970:	CDD5  CD75CB  		CALL	GETCH		; Now get operator's response
 971:	CDD8  FE03    		CP	CONTC		; Test if abort
 972:	CDDA  C0      		RET	NZ		; If operator said ignore error
 973:	CDDB  18ED    		JR	ERROR5		; Else boot
 974:			
 975:	CDDD  78      	ERROR7:	LD	A,B		; Get error
 976:	CDDE  67      		LD	H,A		; Save code in H reg for return
 977:	CDDF  A7      		AND	A		; Test if disk changed warning
 978:	CDE0  C8      		RET	Z		; Continue relog if so
 979:	CDE1  2EFF    		LD	L,0FFH		; Set extended error code
 980:	CDE3  224CCA  		LD	(PEXIT),HL	; Save as return code
 981:						; ..and fall thru to DOS exit
 983:			;******************************************************
 984:			;*	 D O S	   E x i t    R o u t i n e	      *
 985:			;******************************************************
 986:			
 987:	CDE6  3A4ECA  	DOSEXIT: LD	A,(FLDRV)	; Test drive select used flag
 988:	CDE9  B7      		OR	A
 989:	CDEA  280C    		JR	Z,DOSEXT0	; No then exit
 990:	CDEC  3A2DCA  		LD	A,(FCB0)	; Get FCB byte 0
 991:	CDEF  DD7700  		LD	(IX+0),A	; Save it
 992:	CDF2  3A2CCA  		LD	A,(DRIVE)	; Get old drive number
 993:	CDF5  CD81CF  		CALL	SELDK		; Select disk
 994:	0000          		  IF  PICKEY
 996:				  ENDIF
 997:			
 998:			; If the error handler was invoked, the stack is in an undefined
 999:			;  condition at this point.  We therefore have to restore the user's
1000:			;  IX register independent of stack position.  Thanks to Joe Wright's
1001:			;  eagle eye for catching this one!
1002:			
1003:	CDF8  ED7B61CA	DOSEXT0: LD	SP,(SPSAVE)	; Restore user stack
1004:	CDFC  DD2A99CA		LD	IX,(IXSAVE)	; Restore IX (stack is don't care)
1005:	CE00  2A4CCA  		LD	HL,(PEXIT)	; Get exit code
1006:	FFFF          		  IF  NOT PICKEY
1007:	CE03  ED5B5FCA		LD	DE,(DEVAL)	; And DE reg for DateStamper
1008:				  ENDIF
1009:	CE07  7D      		LD	A,L		; Copy function code
1010:	CE08  44      		LD	B,H
1011:	CE09  C9      		RET			; And return to caller
1013:			;******************************************************
1014:			;*	 D i s k     F u n c t i o n s		      *
1015:			;******************************************************
1016:			
1017:			; Reset Disk System
1018:			
1019:	CE0A  218000  	CMND13:	LD	HL,RAMLOW+0080H	; Set up DMA address
1020:	CE0D  222ECA  		LD	(DMA),HL	; And save it
1021:	CE10  CD37D2  		CALL	STDMA		; Do BIOS call
1022:			; 	XOR	A		; Set default drive = 'A'
1023:	CE13  3A36D8  		LD	A,(BOTDSK)	; default drive is boot drive
1024:	CE16  322BCA  		LD	(DEFDRV),A	; Save it
1025:	CE19  11FFFF  		LD	DE,0FFFFH	; Reset all drives
1026:			
1027:			; Reset Multiple Login Drive - DE = Reset mask
1028:			; Fixed Disk Login vector is also altered by this call
1029:			
1030:	CE1C  CD5DCE  	CMND37:	CALL	UNLOG		; Clear selected drives in DE from login
1031:	CE1F  3A15CA  		LD	A,(FLAGS)
1032:	CE22  CB57    		BIT	2,A		; Test hard R/O enabled
1033:	CE24  2006    		JR	NZ,UNWPT1	; If enabled
1034:	CE26  21FCD7  		LD	HL,DSKWP	; Get drive W/P vector
1035:	CE29  CD66CE  		CALL	ANDDEM		; Reset W/P stat only of requested drvs
1036:	CE2C  3A4BCA  	UNWPT1:	LD	A,(FUNCT)
1037:	CE2F  FE0D    		CP	13		; Skip hard disk login change?
1038:	CE31  21FED7  		LD	HL,HDLOG
1039:	CE34  C466CE  		CALL	NZ,ANDDEM	; Clear HD Login Vector if Fcn 37
1040:	CE37          	RELOG1:
1041:	FFFF          		  IF  ZS
1042:	CE37  2AFED7  		LD	HL,(HDLOG)
1043:	CE3A  CD58D0  		CALL	HLORDE		; Don't clear fixed disks from T/D
1044:	CE3D  EB      		EX	DE,HL		; Place modified logout in DE
1045:	CE3E  21F8D7  		LD	HL,TDFVCT
1046:	CE41  CD66CE  		CALL	ANDDEM		; Clear T/D vector as needed
1047:				  ENDIF
1048:			
1049:	CE44  3A2BCA  		LD	A,(DEFDRV)	; Get default drive
1050:	CE47  F5      		PUSH	AF
1051:	CE48          	RELOG2:
1052:	0000          		  IF  RESDSK		; (bh)
1054:				  ELSE
1055:			; 	DEFB	0,0,0		; Make 3 NOP's to keep constant code (hfb)
1056:	CE48  00      		DEFB	0		; two bytes stolen to keep in sync with
1057:							; BIOS BOTDSK
1058:				  ENDIF			; (bh)
1059:	CE49  F1      		POP	AF
1060:	CE4A  CD81CF  		CALL	SELDK		; Select default drive
1061:			
1062:			; ZSDOS watches for any $*.* in any user on any drive during re-log,
1063:			; make, and delete.  In this manner, SUBFLG will always be valid -
1064:			; even under fast relog and NZCOM!  Thanks to Joe Wright for suggesting
1065:			; the need for this, and suggesting ways to do it.
1066:			
1067:	CE4D  3A57CA  	SUBEXT:	LD	A,(SUBFLG)	; Get submit flag
1068:	CE50  1869    		JR	SAVEA		; Exit
1069:			
1070:			; Check for possible existance of submit file by checking first
1071:			; byte of dir entry or FCB for '$'.  Pointer to dir or FCB passed
1072:			; to routine in HL.
1073:			
1074:	CE52  23      	CKSUB:	INC	HL		; Point to file name
1075:	CE53  7E      		LD	A,(HL)		; Get first char filename
1076:	CE54  2B      		DEC	HL
1077:	CE55  D624    		SUB	'$'		; Test if '$'
1078:	CE57  C0      		RET	NZ		; Not then exit
1079:	CE58  3D      		DEC	A		; Load a with 0FFH
1080:	CE59  3257CA  		LD	(SUBFLG),A	; Save it in subflg
1081:	CE5C  C9      		RET
1082:			
1083:			; Unlog Drive mask in DE
1084:			
1085:	CE5D  7B      	UNLOG:	LD	A,E		; Get LSB
1086:	CE5E  2F      		CPL			; Complement it
1087:	CE5F  5F      		LD	E,A
1088:	CE60  7A      		LD	A,D		; Get MSB
1089:	CE61  2F      		CPL			; Complement it
1090:	CE62  57      		LD	D,A		; DE = not reset
1091:	CE63  21FAD7  		LD	HL,LOGIN	; Get addr of login vector
1092:	CE66  7B      	ANDDEM:	LD	A,E		; Clear login bits of reset drives
1093:	CE67  A6      		AND	(HL)		; ..a byte at a time
1094:	CE68  77      		LD	(HL),A		; Put to memory
1095:	CE69  23      		INC	HL
1096:	CE6A  7A      		LD	A,D
1097:	CE6B  A6      		AND	(HL)
1098:	CE6C  77      		LD	(HL),A
1099:	CE6D  C9      		RET
1100:			
1101:			; Search for File
1102:			
1103:	CE6E  CD1FCF  	CMND17:	CALL	SELDRV		; Select drive from FCB
1104:	CE71  DD7E00  		LD	A,(IX+0)
1105:	CE74  D63F    		SUB	'?'		; Test if '?'
1106:	CE76  280D    		JR	Z,CMD17B	; If so all entries match
1107:	CE78  DD7E0E  		LD	A,(IX+FCBMOD)	; Get system byte
1108:	CE7B  FE3F    		CP	'?'		; Test if '?'
1109:	CE7D  2804    		JR	Z,CMD17A	; Yes, jump
1110:	CE7F  DD360E00		LD	(IX+FCBMOD),0	; Load system byte with Zero
1111:	CE83  3E0F    	CMD17A:	LD	A,15		; Test first 15 items in FCB
1112:	CE85  CDF3D2  	CMD17B:	CALL	SEARCH		; Do search
1113:	CE88  2A34CA  	CMD17C:	LD	HL,(DIRBUF)	; Copy directory buffer
1114:	CE8B  018000  		LD	BC,128		; Directory=128 bytes
1115:	CE8E  ED5B2ECA	MV2DMA:	LD	DE,(DMA)	; To DMA address
1116:	CE92  EDB0    		LDIR
1117:	CE94  C9      		RET			; Exit
1118:			
1119:			; Search for Next Occurence of File
1120:			
1121:	CE95  DD2A58CA	CMND18:	LD	IX,(DCOPY)	; Get last FCB used by search
1122:	CE99  DD225DCA		LD	(ARWORD),IX	; Save FCB pointer for BGii
1123:	CE9D  CD1FCF  		CALL	SELDRV		; Select drive from FCB
1124:	CEA0  CD0AD3  		CALL	SEARCN		; Search next file match
1125:	CEA3  18E3    		JR	CMD17C		; And copy directory to DMA address
1126:			
1127:			; Delete File
1128:			
1129:	CEA5  CD1FCF  	CMND19:	CALL	SELDRV		; Select drive from FCB
1130:	CEA8  CD6DD2  		CALL	DELETE		; Delete file
1131:	CEAB  3A5ACA  	CMD19A:	LD	A,(SEAREX)	; Get exit byte 00=file found, 0FFH=Not
1132:	CEAE  180B    		JR	SAVEA		; And exit
1133:			
1134:			; Rename File
1135:			
1136:	CEB0  CD1FCF  	CMND23:	CALL	SELDRV		; Select drive from FCB
1137:	CEB3  CDD7D3  		CALL	RENAM		; Rename file
1138:	CEB6  18F3    		JR	CMD19A		; And exit
1139:			
1140:			; Return Current Drive
1141:			
1142:	CEB8  3A2BCA  	CMND25:	LD	A,(DEFDRV)	; Get current drive
1143:	CEBB  324CCA  	SAVEA:	LD	(PEXIT),A	; Return character
1144:	CEBE  C9      	DUMMY:	RET			; ..and exit ZSDOS
1145:			
1146:			; Set flags
1147:			
1148:	CEBF  3215CA  	CMD101:	LD	(FLAGS),A	; Set ZSDOS flags
1149:							; ..and fall thru
1150:			; Get flags
1151:			
1152:	CEC2  3A15CA  	CMD100:	LD	A,(FLAGS)	; Get ZSDOS flags
1153:	CEC5  18F4    		JR	SAVEA		; ..and exit
1154:			
1155:			; Change Status
1156:			
1157:	CEC7  CD1FCF  	CMND30:	CALL	SELDRV		; Select drive from FCB
1158:	CECA  CD02D4  		CALL	CSTAT		; Change status
1159:	CECD  18DC    		JR	CMD19A		; And exit
1160:			
1161:			; Return CP/M Version Number
1162:			
1163:	CECF          	ZDPCH1:
1164:	FFFF          	IF	STMPZS
1165:	CECF  CD57E9  	CMND12:	CALL	(ZDSSTPR+NWF12O)	; Set CP/M compatable version number
1166:			ELSE
1168:			ENDIF
1169:	0000          		  IF  NOT ZS		; (crw)
1178:				  ENDIF
1179:	FFFF          		  IF  NOT PICKEY
1180:	CED2  ED535FCA		LD	(DEVAL),DE	; In case DS gave us a clock addr
1181:				  ENDIF
1182:	CED6  181B    		JR	SAVHL		; For speed
1183:			
1184:			; Following commands return status in like manner and are consolidated here
1185:			; in selected order with least-accessed commands taking longest to traverse
1186:			; string, and frequently accessed/time critical exitting quickest.
1187:			
1188:			; The code in this section is a bit obscure, as it depends on burying
1189:			; instructions within other instructions.  6502 users have long used the
1190:			; 'BIT' trick to skip instructions - this inspired me to see if similar
1191:			; things could be done with the Z80.  Indeed they can, as this demonstrates.
1192:			; When the Z80 jumps in at a label, it executes the LD HL instruction.	The
1193:			; DEFB 0DDH turns the LD HL instructions that follow into LD IX.  In effect,
1194:			; this turns the DEFB 0DDH into a one byte relative jump to SAVHL.  As IX
1195:			; is never used by these calls, its loss is of no consequence.
1196:			; A similar trick is used in SEAR15, resulting in a useless LD HL but
1197:			; saving a byte.
1198:			
1199:			; New Universal Return Version FUNCTION 48
1200:			
1201:	CED8          	CMND48:
1202:	FFFF          		  IF  ZS
1203:	CED8  211153  		LD	HL,('S' SHL 8) + BDVERS ;"S" indicates ZSDOS - ZRDOS returns 0
1204:				  ELSE
1206:				  ENDIF
1207:	CEDB  DD      		DEFB	0DDH		; Trash IX and fall through
1208:			
1209:			; Return Disk W/P Vector
1210:			
1211:	CEDC  2AFCD7  	CMND29:	LD	HL,(DSKWP)	; Get disk W/P vector
1212:	CEDF  DD      		DEFB	0DDH		; Trash IX and fall through
1213:			
1214:			; Return Fixed Disk Login Vector
1215:			
1216:	CEE0  2AFED7  	CMND39:	LD	HL,(HDLOG)	; Return fixed disk login vector
1217:	CEE3  DD      		DEFB	0DDH		; Trash IX and fall through
1218:			
1219:			; Return ALV Vector
1220:			
1221:	CEE4  2A3ACA  	CMND27:	LD	HL,(ALV)	; Get allocation vector
1222:	CEE7  DD      		DEFB	0DDH		; Trash IX and fall through
1223:			
1224:			; Return Login Vector
1225:			
1226:	CEE8  2AFAD7  	CMND24:	LD	HL,(LOGIN)	; Get login vector
1227:	CEEB  DD      		DEFB	0DDH		; Trash IX and fall through
1228:			
1229:			; Return Drive Table
1230:			
1231:	CEEC  2A36CA  	CMND31:	LD	HL,(IXP)	; Get drive table
1232:	CEEF  DD      		DEFB	0DDH		; Trash IX and fall through
1233:			
1234:			; Return Current DMA
1235:			
1236:	CEF0  2A2ECA  	CMND47:	LD	HL,(DMA)	; Return current DMA addr
1237:	CEF3  224CCA  	SAVHL:	LD	(PEXIT),HL	; Save it
1238:	CEF6  C9      		RET			; And exit
1239:			
1240:			; Set BDOS Error Mode
1241:			
1242:	CEF7  325CCA  	CMND45:	LD	(ERMODE),A	; Save error mode
1243:	CEFA  C9      		RET			; And exit
1244:			
1245:			; Set/Get User Code
1246:			
1247:	CEFB  212ACA  	CMND32:	LD	HL,USER		; Point to user byte location
1248:	CEFE  3C      		INC	A		; Test if 0FFH
1249:	CEFF  7E      		LD	A,(HL)		; Get old user code
1250:	CF00  28B9    		JR	Z,SAVEA		; If 0FFH then exit
1251:	CF02  7B      		LD	A,E		; Get new user code
1252:	CF03  E61F    		AND	01FH		; Mask it
1253:	CF05  77      		LD	(HL),A		; Save it
1254:	CF06  C9      		RET			; And exit
1255:			
1256:			; Compute File Size Command
1257:			
1258:	CF07  CD2DCF  	CMND35:	CALL	SELDR1		; Select drive from FCB
1259:	CF0A  CD2BD4  		CALL	FILSZ		; Compute file size
1260:	CF0D  189C    		JR	CMD19A		; And exit
1261:			
1262:			; Set Random Record Count
1263:			
1264:	CF0F  212000  	CMND36:	LD	HL,32		; Set pointer to next record
1265:	CF12  CD7FD7  		CALL	CALRRC		; Calculate random record count
1266:	CF15  DD7221  	LDRRC:	LD	(IX+33),D	; And save random record count
1267:	CF18  DD7122  		LD	(IX+34),C
1268:	CF1B  DD7023  		LD	(IX+35),B
1269:	CF1E  C9      		RET			; And exit
1270:			
1271:			; Select Disk From FCB
1272:			
1273:	CF1F          	BGSELDRV:
1274:	CF1F  3A5CCA  	SELDRV:	LD	A,(ERMODE)	; Are we in modified user mode?
1275:	CF22  A7      		AND	A
1276:	CF23  2008    		JR	NZ,SELDR1	; Jump if so, else..
1277:	CF25  2A5DCA  		LD	HL,(ARWORD)	;
1278:	CF28  010D00  		LD	BC,FCBUSR	; Point to user number
1279:	CF2B  09      		ADD	HL,BC		;
1280:	CF2C  77      		LD	(HL),A		; Clear user flag
1281:	CF2D  3EFF    	SELDR1:	LD	A,0FFH		; Set disk select done flag
1282:	CF2F  324ECA  		LD	(FLDRV),A
1283:	CF32  3A2BCA  		LD	A,(DEFDRV)	; Get current drive
1284:	CF35  5F      		LD	E,A		; Save it in register E
1285:	CF36  2A5DCA  		LD	HL,(ARWORD)
1286:	CF39  7E      		LD	A,(HL)		; Get drive from FCB
1287:	CF3A  322DCA  		LD	(FCB0),A	; Save it
1288:	CF3D  FE3F    		CP	'?'		; Test if '?'
1289:	CF3F  2839    		JR	Z,CMND14	; Yes, then select drive from register E
1290:	CF41  DDE5    		PUSH	IX		; Save BGii's IX register
1291:							; IX won't be altered on cmnd14
1292:	CF43  DD2A5DCA		LD	IX,(ARWORD)	; Get FCB pointer
1293:			;1.1a Changed to allow proper access to Drive P:
1294:			;1.2a	AND	0FH		; Mask drive
1295:	CF47  E61F    		AND	1FH		;1.2a Mask Drive
1296:	CF49  E5      		PUSH	HL
1297:	CF4A  2802    		JR	Z,SELDR0	; Select drive from register E
1298:	CF4C  5E      		LD	E,(HL)		; Get drive from FCB
1299:	CF4D  1D      		DEC	E		; Decrement drive number so A=0
1300:	CF4E  CD7ACF  	SELDR0:	CALL	CMND14		; - do select of drive
1301:	CF51  E1      		POP	HL		; Restore FCB pointer
1302:			
1303:			; Resolve User for FCB - FCBPTR in IX, Returns User in A
1304:			
1305:	CF52  DD7E0D  		LD	A,(IX+FCBUSR)	; ..get potential user in case
1306:	CF55  CB7F    		BIT	7,A		; Is this a valid user?
1307:	CF57  2007    		JR	NZ,RESUS1	; Skip if there is
1308:	CF59  3A2ACA  		LD	A,(USER)	; Get user number
1309:	CF5C  1802    		JR	RESUS1		; ..and bypass push IX
1310:			
1311:			; Set User in FCB to Value passed in A
1312:			
1313:	CF5E  DDE5    	RESUSR:	PUSH	IX		; Preserve IX
1314:	CF60  DD2A5DCA	RESUS1:	LD	IX,(ARWORD)
1315:	CF64  E61F    		AND	1FH		; User number in A
1316:	CF66  DD7700  		LD	(IX+0),A	; Save in FCB 0 byte
1317:	CF69  F680    		OR	80H		; Set valid DOS user flag
1318:	CF6B  DD770D  		LD	(IX+FCBUSR),A	; ..and in FCB 13 byte
1319:	CF6E  DDE1    		POP	IX		; Restore caller's IX
1320:	CF70  C9      		RET
1321:			
1322:			; Select Disk Error Exit - The stack is off by one level here, but
1323:			;  this is a one way trip anyway.
1324:			
1325:	CF71  2A0BCA  	SELDK3:	LD	HL,(STSEL)	; Load error message address
1326:	CF74  0604    		LD	B,4		; Select error
1327:	CF76  1115CD  		LD	DE,MSEL		; Load select error message
1328:	CF79  E9      		JP	(HL)		; And display error
1329:			
1330:			; Select Disk from E register
1331:			
1332:	CF7A  3A2BCA  	CMND14:	LD	A,(DEFDRV)	; Get current drive
1333:	CF7D  322CCA  		LD	(DRIVE),A	; Save it in memory
1334:	CF80  7B      		LD	A,E		; Copy drive number
1335:			
1336:			; Select Disk
1337:			;  Call w/ A = Drive Number (0..15 = A..P)
1338:			
1339:	CF81  2AFAD7  	SELDK:	LD	HL,(LOGIN)	; Get login vector
1340:	CF84  E60F    		AND	0FH		; Mask drive number
1341:	CF86  47      		LD	B,A		; Save counter
1342:	CF87  C461D0  		CALL	NZ,SHRHLB	; ..and rotate into position
1343:	CF8A  EB      	SELDK0:	EX	DE,HL		; Put drive bit mask in DE
1344:	CF8B  212BCA  		LD	HL,DEFDRV	; Get pointer last drive
1345:	CF8E  CB43    		BIT	0,E		; Test if drive logged in
1346:	CF90  2802    		JR	Z,SELDK2	; No, login drive
1347:	CF92  BE      		CP	(HL)		; Test same drive
1348:	CF93  C8      		RET	Z		; Yes then exit
1349:			
1350:			; NOTE: A long standing DOS bug concerns the SELECT function.  If a
1351:			;  function 14 call is made and the drive doesn't exist, the default
1352:			;  will still point to the bad drive unless we fix it in the error
1353:			;  routine.  It is for this reason that drive is saved above.  We must
1354:			;  allow default to assume the illegal drive value long enough for the
1355:			;  error handler to print it, then re-select the old default.
1356:			
1357:	CF94  77      	SELDK2:	LD	(HL),A		; Save new current drive
1358:	CF95  D5      		PUSH	DE		; Save drive logged in flag
1359:	CF96  4F      		LD	C,A		; Copy drive number
1360:	CF97  CD1BD8  		CALL	SELDSK		; Do BIOS select
1361:	CF9A  7C      		LD	A,H		; Test if error
1362:	CF9B  B5      		OR	L
1363:	CF9C  28D3    		JR	Z,SELDK3	; Yes, illegal drive number
1364:	CF9E  1130CA  		LD	DE,TRANS	; Point to local translation store
1365:	CFA1  010200  		LD	BC,2		; ..and move 2-byte ptr in
1366:	CFA4  EDB0    		LDIR
1367:	CFA6  2232CA  		LD	(TEMP0),HL	; Save address temp0
1368:	CFA9  0E06    		LD	C,6		; Advance to dirbuf part of DPH
1369:	CFAB  09      		ADD	HL,BC		; As TEMP1 and TEMP2 unused in P?DOS
1370:	CFAC  1134CA  		LD	DE,DIRBUF	; Load DIRBUF pointer
1371:	CFAF  0E08    		LD	C,8		; Copy 8 bytes
1372:	CFB1  EDB0    		LDIR
1373:	CFB3  2A36CA  		LD	HL,(IXP)	; Get drive parameter address
1374:	CFB6  0E0F    		LD	C,15		; Copy 15 bytes
1375:	CFB8  EDB0    		LDIR
1376:	CFBA  D1      		POP	DE		; Get drive logged in flag
1377:	CFBB  CB43    		BIT	0,E		; Test it
1378:	CFBD  C0      		RET	NZ		; Drive logged in so return
1379:	CFBE  CD47D0  		CALL	GETCDM
1380:	CFC1  EB      		EX	DE,HL		; Drive mask in DE
1381:	CFC2  2AFAD7  		LD	HL,(LOGIN)	; Get login vector
1382:	CFC5  CD58D0  		CALL	HLORDE		; Set drive bit in login vector
1383:	CFC8  22FAD7  		LD	(LOGIN),HL	; Save login vector
1384:	CFCB  3A15CA  		LD	A,(FLAGS)	; Get flags
1385:	CFCE  CB5F    		BIT	3,A		; Fast relog enabled?
1386:	CFD0  282A    		JR	Z,INITDR	; Skip if disabled
1387:			
1388:			; The following code checks the WACD size to determine if the drive
1389:			;  being selected is a fixed disk.  If the WACD size is 0, the disk
1390:			;  is Non-Removable.  However, several BIOSes support remapping of
1391:			;  logical drives.  This complicates matters because BDOS must catch
1392:			;  the swap and clear the Hard Disk Allocation Vector and allow the
1393:			;  allocation bitmaps to be rebuilt.  Thus, every disk that is being
1394:			;  selected for the first time traverses this code.  If a disk was
1395:			;  logged as a fixed disk and all of the sudden has a WACD buffer,
1396:			;  the Fixed Disk Login Vector is cleared.  Thus, for Bug-free
1397:			;  operation of Fast Fixed Disk Logging, if drives are swapped
1398:			;  NEVER SWAP TWO FIXED DRIVES!
1399:			
1400:	CFD2  2A47CA  		LD	HL,(NCHECK)	; Is this a fixed drive?
1401:	CFD5  7C      		LD	A,H
1402:	CFD6  B5      		OR	L
1403:	CFD7  4F      		LD	C,A		; Save fixed disk flag (Z=true)
1404:	CFD8  2AFED7  		LD	HL,(HDLOG)
1405:	CFDB  7B      		LD	A,E		; See if logged as fixed disk
1406:	CFDC  A5      		AND	L
1407:	CFDD  6F      		LD	L,A
1408:	CFDE  7A      		LD	A,D
1409:	CFDF  A4      		AND	H		; MSB
1410:	CFE0  B5      		OR	L		; Z flag set if HL and DE = 0
1411:	CFE1  3EFF    		LD	A,0FFH		; Don't alter flags
1412:	CFE3  2801    		JR	Z,SELDK4	; If not logged as fixed disk
1413:	CFE5  3C      		INC	A		; Else flag as logged
1414:	CFE6  47      	SELDK4:	LD	B,A		; Save logged as fixed disk flag (Z=true)
1415:	CFE7  B1      		OR	C		; Test if still fixed disk
1416:	CFE8  C8      		RET	Z		; Skip re-map if logged and not swapped
1417:	CFE9  AF      		XOR	A
1418:	CFEA  67      		LD	H,A
1419:	CFEB  6F      		LD	L,A		; Null vector
1420:	CFEC  B0      		OR	B		; Was it logged as a fixed disk?
1421:	CFED  280A    		JR	Z,SELDK5	; Invalidate HDLOG vector - drive no longer
1422:							; Fixed disk
1423:	CFEF  79      		LD	A,C
1424:	CFF0  B7      		OR	A		; Wasn't fixed disk before - is it now?
1425:	CFF1  2009    		JR	NZ,INITDR	; Skip vector update if it isn't
1426:	CFF3  2AFED7  		LD	HL,(HDLOG)
1427:	CFF6  CD58D0  		CALL	HLORDE		; Else add this drive to fixed disk vector
1428:	CFF9  22FED7  	SELDK5:	LD	(HDLOG),HL	; Update fixed disk vector
1429:						;..fall thru to INITDR
1430:			
1431:			; Init Drive
1432:			;  Clear ALV Bit Buffer after Drive reset
1433:			
1434:	CFFC  2A41CA  	INITDR:	LD	HL,(MAXLEN)	; Get length ALV buffer-1 (bits)
1435:	CFFF  CD5FD0  		CALL	SHRHL3		; Divide by 8 to get bytes
1436:	D002  44      		LD	B,H
1437:	D003  4D      		LD	C,L		; Counter to BC (will be count+1 cleared)
1438:	D004  2A3ACA  		LD	HL,(ALV)	; Get pointer ALV buffer
1439:	D007  E5      		PUSH	HL
1440:	D008  54      		LD	D,H
1441:	D009  5D      		LD	E,L
1442:	D00A  13      		INC	DE		; ALV buffer +1 in DE
1443:	D00B  AF      		XOR	A
1444:	D00C  77      		LD	(HL),A		; Clear first 8 bits
1445:	D00D  EDB0    		LDIR			; And remainder of buffer
1446:	D00F  E1      		POP	HL		; Get ALV pointer
1447:	D010  ED5B45CA		LD	DE,(NDIR0)	; Get first two bytes ALV buffer
1448:	D014  73      		LD	(HL),E		; Save LSB
1449:	D015  23      		INC	HL		; Increment pointer
1450:	D016  72      		LD	(HL),D		; Save MSB
1451:	D017  2A32CA  		LD	HL,(TEMP0)	; Clear number of files on this drive
1452:	D01A  77      		LD	(HL),A		; Clear LSB (A still has 0)
1453:	D01B  23      		INC	HL		; Increment pointer
1454:	D01C  77      		LD	(HL),A		; Clear MSB
1455:			
1456:	D01D          	ZDPCH2	EQU	$		;<-- Intercept first scan (ZDS Patch)
1457:	FFFF          	IF	STMPZS
1458:	D01D  CD6BE9  		CALL	(ZDSSTPR+SETCHO)	; Set file count
1459:			ELSE
1461:			ENDIF
1462:	D020  3EFF    	INITD2:	LD	A,0FFH		; Update directory checksum
1463:	D022  CD30D1  		CALL	RDDIR		; Read FCB's from directory
1464:	D025  CD1CD1  		CALL	TSTFCT		; Test last FCB
1465:	D028  CA4DCE  		JP	Z,SUBEXT	; Return subflg for strict CP/M compat (hfb)
1466:	D02B  CDF1D0  		CALL	CALDIR		; Calculate entry point FCB
1467:	D02E  7E      		LD	A,(HL)		; Get first byte FCB
1468:	D02F  FEE5    		CP	0E5H		; Test empty directory entry
1469:	D031  28ED    		JR	Z,INITD2	; Yes then get next FCB
1470:	D033  FE21    		CP	021H		; Test time stamp
1471:	D035  28E9    		JR	Z,INITD2	; Yes then get next FCB
1472:			
1473:	D037          	ZDPCH3	EQU	$		;<-- Test for T&D if first time (ZDS Patch)
1474:	FFFF          	IF	STMPZS
1475:	D037  CD74E9  		CALL	(ZDSSTPR+CKTDFO)	; Set file count
1476:			ELSE
1478:			ENDIF
1479:	D03A  0E01    		LD	C,1		; Set bit in ALV buffer
1480:	D03C  CD83D2  		CALL	FILLBB		; Set bits from FCB in ALV buffer
1481:	D03F  CD23D1  		CALL	TSTLF		; Test for last file
1482:	D042  D414D1  		CALL	NC,SETLF0	; ..and update the last file count if so
1483:	D045  18D9    		JR	INITD2		; And get next FCB
1484:			
1485:			; Return Mask for Current Drive in HL
1486:			
1487:	D047  210000  	GETCDM:	LD	HL,0		; No drives to Or
1488:			
1489:			; Set Drive bit in HL
1490:			
1491:	D04A  EB      	SDRVB:	EX	DE,HL		; Copy HL=>DE
1492:	D04B  210100  		LD	HL,1		; Get mask drive "A"
1493:	D04E  3A2BCA  		LD	A,(DEFDRV)	; Get current drive
1494:	D051  B7      		OR	A		; Test if drive "A"
1495:	D052  2804    		JR	Z,HLORDE	; Yes then done
1496:	D054  29      	SDRVB0:	ADD	HL,HL		; Get next mask
1497:	D055  3D      		DEC	A		; Decrement drive counter
1498:	D056  20FC    		JR	NZ,SDRVB0	; And test if done
1499:	D058  7A      	HLORDE:	LD	A,D		; HL=HL or DE
1500:	D059  B4      		OR	H
1501:	D05A  67      		LD	H,A
1502:	D05B  7B      		LD	A,E
1503:	D05C  B5      		OR	L
1504:	D05D  6F      		LD	L,A
1505:	D05E  C9      		RET			; Exit
1506:			
1507:	D05F  0603    	SHRHL3:	LD	B,3		; Used in a few places
1508:			
1509:			; Shift HL right logical B bits
1510:			
1511:	D061  CB3C    	SHRHLB:	SRL	H
1512:	D063  CB1D    		RR	L		; Shift HL right one bit (divide by 2)
1513:	D065  10FA    		DJNZ	SHRHLB
1514:	D067  C9      		RET
1515:			
1516:			; Calculate Sector/Track Directory
1517:			
1518:	D068  2A54CA  	STDIR:	LD	HL,(FILCNT)	; Get FCB counter directory
1519:	FFFF          		  IF  UNROLL
1520:	D06B  CB3C    		SRL	H
1521:	D06D  CB1D    		RR	L
1522:	D06F  CB3C    		SRL	H		; (net cost: 3)
1523:	D071  CB1D    		RR	L		; Divide by 4 (inline for speed)
1524:				  ELSE
1527:				  ENDIF
1528:	D073  2252CA  		LD	(RECDIR),HL	; Save value (used by checksum)
1529:	D076  EB      	STDIR2:	EX	DE,HL		; Copy it to DE
1530:	D077  210000  	STDIR1:	LD	HL,0		; Clear HL
1531:			
1532:			; Calculate Sector/Track
1533:			;  Entry: HL,DE=Sector Number (128 byte sector)
1534:			;  Result Set Track  =HL,DE  /	MAXSEC
1535:			;	  Set Sector =HL,DE MOD MAXSEC
1536:			
1537:	D07A  ED4B3CCA	CALST:	LD	BC,(MAXSEC)	; Get sectors/track
1538:	D07E  3E11    		LD	A,17		; Set up loop counter
1539:	D080  B7      	CALST0:	OR	A
1540:	D081  ED42    		SBC	HL,BC		; HL > BC?
1541:	D083  3F      		CCF
1542:	D084  3802    		JR	C,CALST1	; Yes then jump
1543:	D086  09      		ADD	HL,BC		; No then restore HL
1544:	D087  B7      		OR	A		; Clear Carry
1545:	D088  CB13    	CALST1:	RL	E		; Shift result in DE
1546:	D08A  CB12    		RL	D
1547:	D08C  3D      		DEC	A		; Test last bit done
1548:	D08D  2804    		JR	Z,CALST2	; Yes then exit
1549:	D08F  ED6A    		ADC	HL,HL		; Shift next bit in HL
1550:	D091  18ED    		JR	CALST0		; Continue
1551:			
1552:	D093  E5      	CALST2:	PUSH	HL		; Save sector number
1553:	D094  2A49CA  		LD	HL,(NFTRK)	; Get first track
1554:	D097  19      		ADD	HL,DE		; Add track number
1555:	D098  44      		LD	B,H		; Copy it to BC
1556:	D099  4D      		LD	C,L
1557:	D09A  CD1ED8  		CALL	SETTRK		; CBIOS call Set Track
1558:	D09D  C1      		POP	BC		; Restore sector number
1559:	D09E  ED5B30CA		LD	DE,(TRANS)	; Get translation table address
1560:	D0A2  CD30D8  		CALL	SECTRN		; CBIOS call sector translation
1561:	D0A5  44      		LD	B,H		; Copy result to BC
1562:	D0A6  4D      		LD	C,L
1563:	D0A7  C321D8  		JP	SETSEC		; BIOS call Set Sector
1564:			
1565:			; Get Disk Map Block Number from FCB   (Squeezed by Joe Wright)
1566:			;  Exit HL=Address FCB
1567:			;	DE=DM
1568:			;	BC=Offset in DM
1569:			;	Zero Flag Set (Z) if DM=0, Else reset (NZ)
1570:			
1571:	D0AA  DD6E20  	GETDM:	LD	L,(IX+NXTREC)	; Get record number in L
1572:	D0AD  CB15    		RL	L		; Shift it left once
1573:	D0AF  3A40CA  		LD	A,(NEXTND)	; Get EXM
1574:	D0B2  DDA60C  		AND	(IX+FCBEXT)	; And the extent number
1575:	D0B5  67      		LD	H,A		; To H
1576:	D0B6  3A3ECA  		LD	A,(NBLOCK)	; Get BSH
1577:	D0B9  47      		LD	B,A		; To B
1578:	D0BA  04      		INC	B		; +1
1579:	D0BB  CD61D0  		CALL	SHRHLB		; Shift HL right B times
1580:	D0BE  50      		LD	D,B		; Zero to D
1581:	D0BF  7D      		LD	A,L		; Result to A
1582:			
1583:	D0C0  2A5DCA  	GETDM4:	LD	HL,(ARWORD)
1584:	D0C3  0E10    		LD	C,16		; Add offset 16 to point to DM
1585:	D0C5  09      		ADD	HL,BC
1586:	D0C6  4F      		LD	C,A		; Add entry FCB
1587:	D0C7  09      		ADD	HL,BC
1588:	D0C8  3A42CA  		LD	A,(MAXLEN+1)	; Test 8 bits/16 bits FCB entry
1589:	D0CB  B7      		OR	A
1590:	D0CC  5E      		LD	E,(HL)		; Get 8 bit value
1591:	D0CD  2805    		JR	Z,GETDMX	; ..and exit if 8-bit entries
1592:			
1593:	D0CF  09      		ADD	HL,BC		; Add twice (16 bit values)
1594:	D0D0  5E      		LD	E,(HL)		; Get LSB
1595:	D0D1  23      		INC	HL		; Increment pointer
1596:	D0D2  56      		LD	D,(HL)		; Get MSB
1597:	D0D3  2B      		DEC	HL		; Decrement pointer
1598:	D0D4  7A      	GETDMX:	LD	A,D		; Check for zero DM value
1599:	D0D5  B3      		OR	E
1600:	D0D6  C9      		RET			; And exit
1601:			
1602:			; Calculate Sector Number
1603:			;  Entry: DE=Block Number from FCB
1604:			
1605:	D0D7  210000  	CALSEC:	LD	HL,0		; Clear MSB sector number
1606:	D0DA  3A3ECA  		LD	A,(NBLOCK)	; Get loop counter
1607:	D0DD  47      		LD	B,A		; Save it in B
1608:	D0DE  EB      		EX	DE,HL
1609:	D0DF  29      	CALSC0:	ADD	HL,HL		; Shift L,D,E
1610:	D0E0  CB13    		RL	E
1611:	D0E2  10FB    		DJNZ	CALSC0		; B times
1612:	D0E4  EB      		EX	DE,HL
1613:	D0E5  3A3FCA  		LD	A,(NMASK)	; Get sector mask
1614:	D0E8  DDA620  		AND	(IX+NXTREC)	; And with next record
1615:	D0EB  B3      		OR	E		; Set up LSB sector number
1616:	D0EC  5F      		LD	E,A
1617:	D0ED  C9      		RET			; And exit
1618:			
1619:			; Check for File Read-Only status, then fall thru to CALDIR
1620:			
1621:	D0EE  CDACD2  	CKRODI:	CALL	CHKFRO		; Abort if the file is R/O
1622:							; ..fall thru..
1623:			
1624:			; Calculate DIRBUF Entry Point
1625:			
1626:	D0F1  3A56CA  	CALDIR:	LD	A,(SECPNT)	; Get sector pointer
1627:	D0F4          	CALDIR1:			; New label for DS (crw)
1628:	D0F4  2A34CA  		LD	HL,(DIRBUF)	; Get start address dirbuf
1629:	D0F7  85      	CALDI0:	ADD	A,L		; Add L=L+A
1630:	D0F8  6F      		LD	L,A
1631:	D0F9  D0      		RET	NC		; No carry exit
1632:	D0FA  24      		INC	H		; Increment H
1633:	D0FB  C9      		RET			; And exit
1634:			
1635:			; Init File Count
1636:			
1637:	D0FC  21FFFF  	SETFCT:	LD	HL,-1		; Set up file count
1638:	D0FF  2254CA  		LD	(FILCNT),HL	; Save it
1639:	D102  C9      		RET			; And exit
1640:			
1641:			; Set Write Protect Disk Command  (relocated & compressed hfb)
1642:			
1643:	D103          	CMND28:				; Set read only disk
1644:	D103  2AFCD7  		LD	HL,(DSKWP)	; Get disk W/P vector
1645:	D106  CD4AD0  		CALL	SDRVB		; Include drive bit
1646:	D109  22FCD7  		LD	(DSKWP),HL	; Save disk W/P vector
1647:	D10C  ED5B43CA		LD	DE,(NFILES)	; Get max number of files-1 (bumped below)
1648:	D110  2A32CA  		LD	HL,(TEMP0)	; Get pointer to disk parameter block
1649:	D113  23      		INC	HL		; Correct pointer..
1650:							; Setlf0 relocated in-line here (hfb)
1651:	D114  13      	SETLF0:	INC	DE		; Increment last file
1652:	D115  72      		LD	(HL),D		; Save it in TEMP0
1653:	D116  2B      		DEC	HL
1654:	D117  73      		LD	(HL),E
1655:	D118  C9      		RET			; And exit
1656:			
1657:			; Search using first 15 bytes of FCB, test if found
1658:			
1659:	D119  CDF1D2  	SRCT15:	CALL	SEAR15		; Search on 15-bytes..(consolidated-hfb)
1660:							; ..fall thru to test presence..
1661:			; Test File Count
1662:			
1663:	D11C  2A54CA  	TSTFCT:	LD	HL,(FILCNT)	; Test file count=0FFFFH
1664:	D11F  7C      		LD	A,H		; Get MSB
1665:	D120  A5      		AND	L		; And LSB
1666:	D121  3C      		INC	A		; Test if result=0FFH
1667:	D122  C9      		RET			; And exit
1668:			
1669:			; Test Last File
1670:			
1671:	D123  2A32CA  	TSTLF:	LD	HL,(TEMP0)	; Get pointer to last file
1672:	D126  ED5B54CA		LD	DE,(FILCNT)	; Get file counter
1673:	D12A  7B      		LD	A,E		; Subtract DE-(HL)
1674:	D12B  96      		SUB	(HL)
1675:	D12C  23      		INC	HL
1676:	D12D  7A      		LD	A,D
1677:	D12E  9E      		SBC	A,(HL)
1678:	D12F  C9      		RET			; Exit
1679:			
1680:			; Get Next FCB from Drive
1681:			; Entry A=0 Check Checksum, A=0FFH Update Checksum
1682:			
1683:	D130  4F      	RDDIR:	LD	C,A		; Save checksum flag
1684:	D131  2A54CA  		LD	HL,(FILCNT)	; Get file counter
1685:	D134  23      		INC	HL		; Increment it
1686:	D135  2254CA  		LD	(FILCNT),HL	; And save it
1687:	D138  ED5B43CA		LD	DE,(NFILES)	; Get maximum number of files
1688:	D13C  7B      		LD	A,E		; Is this the last file?
1689:	D13D  95      		SUB	L
1690:	D13E  7A      		LD	A,D
1691:	D13F  9C      		SBC	A,H
1692:	D140  38BA    		JR	C,SETFCT	; ..set file count to 0FFFFH if so
1693:	D142  7D      		LD	A,L		; Get file count LSB
1694:	D143  0F      		RRCA			; *32 (bm/hfb-to save a byte)
1695:	D144  0F      		RRCA
1696:	D145  0F      		RRCA
1697:	D146  E660    		AND	060H		; Mask it
1698:	D148  3256CA  		LD	(SECPNT),A	; Save it for later use
1699:	D14B  C0      		RET	NZ		; Return if not first FCB sector
1700:	D14C  C5      		PUSH	BC		; Save checksum flag
1701:	0000          		  IF  NOT ZSDOS11	;  (* This was NOT in released package *)
1713:				  ENDIF		;~Zsdos11
1714:	D14D  CD68D0  	RdDir0:	CALL	STDIR		; Calculate sector/track directory
1715:	0000          		  IF  NOT ZS
1734:				  ELSE
1735:							; READDR subroutine moved in-line here
1736:	D150  CD3DD2  		CALL	DMADIR		; Set up DMA directory
1737:	D153  CD95D1  		CALL	READR		; Read a record
1738:	D156  CD37D2  		CALL	STDMA		; ..and set up user's DMA
1739:				  ENDIF
1740:	D159  C1      		POP	BC		; Restore checksum flag
1741:			
1742:			; Update/Check Checksum Directory
1743:			; Entry C=0 Check Checksum, C=0FFH update Checksum
1744:			
1745:	D15A  2A47CA  	CHKDIR:	LD	HL,(NCHECK)	; Get number of checked records
1746:	D15D  ED5B52CA		LD	DE,(RECDIR)	; Get current record
1747:	D161  AF      		XOR	A		; Clear carry (bm)
1748:	D162  ED52    		SBC	HL,DE		; Test current record
1749:	D164  C8      		RET	Z		; Exit if zero
1750:	D165  D8      		RET	C		; Exit if greater than ncheck
1751:	D166  2A34CA  		LD	HL,(DIRBUF)	; Get dirbuf
1752:	D169  CDE0D7  		CALL	CKS127		; ..and checksum first 127 bytes..
1753:	D16C  86      		ADD	A,(HL)		; ...then 128th byte (hfb)
1754:	D16D  2A38CA  		LD	HL,(CSV)	; Get pointer checksum directory
1755:	D170  19      		ADD	HL,DE		; Add current record
1756:	D171  0C      		INC	C		; Test checksum flag
1757:	D172  2002    		JR	NZ,CHKDR1	; 0FFH=> update checksum
1758:	D174  77      		LD	(HL),A		; Update checksum
1759:	D175  C9      		RET			; And exit
1760:			
1761:	D176  BE      	CHKDR1:	CP	(HL)		; Test checksum
1762:	D177  C8      		RET	Z		; Exit if ok
1763:			
1764:			; Checksum differs, So Disk has changed.  Relog it and continue
1765:			
1766:	D178  3A15CA  		LD	A,(FLAGS)
1767:	D17B  CB67    		BIT	4,A		; Inform user?
1768:	D17D  0600    		LD	B,0		; Disk change error code
1769:	D17F  1102CD  		LD	DE,MDSKCH	; Disk changed message
1770:	D182  C44CCD  		CALL	NZ,ERROR	; Inform user
1771:			
1772:			; Relog Current Drive after media change detected
1773:			
1774:	D185  CD47D0  		CALL	GETCDM		; Get current drive mask in HL
1775:	D188  EB      		EX	DE,HL		; Xfer mask to DE
1776:	D189  CD5DCE  		CALL	UNLOG		; Reset login vector for logged drive
1777:	D18C  CD37CE  		CALL	RELOG1		; Do the meat of relogging
1778:							; Caveat emptor: this call is recursive...
1779:	D18F  CDFCD0  		CALL	SETFCT		; Re-initialize search file count
1780:	D192  AF      		XOR	A		; We only get here by checking.. (bm)
1781:	D193  189B    		JR	RDDIR		; And all checking is done from rddir
1782:			
1783:			; Read Sector from Drive
1784:			
1785:	D195  CD27D8  	READR:	CALL	BDREAD		; CBIOS call read sector
1786:	D198  1803    		JR	WRITE0
1787:			
1788:			; Write Sector on Drive
1789:			
1790:	D19A  CD2AD8  	WRITER:	CALL	WRITE		; CBIOS call write sector
1791:	D19D  B7      	WRITE0:	OR	A		; Test exit code
1792:	D19E  C8      		RET	Z		; Exit if ok
1793:	D19F  0601    		LD	B,1		; Disk I/O error code
1794:	D1A1  110ACD  		LD	DE,MBADSC	; Load bad sector message
1795:	D1A4  2A09CA  		LD	HL,(STBDSC)	; Load bad sector vector
1796:	D1A7  E9      		JP	(HL)		; ZSDOS error on D: Bad Sector
1797:			
1798:			; Close File Command (relocated hfb)
1799:			
1800:	D1A9          	BGPTCH2	EQU	$+1		;<-- BGii patch point
1801:			
1802:	D1A8  CD2DCF  	CMND16:	CALL	SELDR1		; Select drive from FCB
1803:			
1804:			; Close File
1805:			
1806:	D1AB  DDCB0E7E	CLOSE:	BIT	7,(IX+FCBMOD)	; Test FCB/file modified
1807:	D1AF  C0      		RET	NZ		; Not then no close required
1808:	D1B0  CDD8D2  		CALL	CHKRO		; Test disk W/P
1809:	D1B3  CD19D1  		CALL	SRCT15		; Search file and test present
1810:	D1B6  C8      		RET	Z		; No then exit with error
1811:	D1B7  CDEED0  		CALL	CKRODI		; Check file W/P, get directory entry
1812:	D1BA  011000  		LD	BC,16		; Offset to DM block
1813:	D1BD  09      		ADD	HL,BC		; Add offset
1814:	D1BE  EB      		EX	DE,HL		; Save DIR PTR in DE
1815:	D1BF  2A5DCA  		LD	HL,(ARWORD)	; Get FCB ptr
1816:	D1C2  09      		ADD	HL,BC		; Add offset
1817:	D1C3  EB      		EX	DE,HL
1818:	D1C4  41      		LD	B,C		; Xfer counter
1819:			
1820:			; Copy FCB (DE) to DIR (HL) if and only if DIR=0 or DIR=FCB
1821:			
1822:	D1C5  34      	CLOSE0:	INC	(HL)
1823:	D1C6  35      		DEC	(HL)		; Test DIR for 0
1824:	D1C7  1A      		LD	A,(DE)		; Get byte from FCB
1825:	D1C8  2804    		JR	Z,CLOSE1	; OK to Copy if 0
1826:	D1CA  BE      		CP	(HL)		; Test if same as DIR
1827:	D1CB  C27AD5  		JP	NZ,RETCFF	; ..if Not, abort Close and return error
1828:	D1CE  77      	CLOSE1:	LD	(HL),A		; Else save in DIR
1829:	D1CF  13      		INC	DE
1830:	D1D0  23      		INC	HL
1831:	D1D1  10F2    		DJNZ	CLOSE0		; Bump pointers and loop until done
1832:	D1D3  11ECFF  		LD	DE,-20		; Add -20 to get Extent Number from DIR
1833:	D1D6  19      		ADD	HL,DE		; HL contains pointer to extent number
1834:	D1D7  DD7E0C  		LD	A,(IX+FCBEXT)	; Get extent number FCB
1835:	D1DA  BE      		CP	(HL)		; Compare with extent number directory
1836:	D1DB  3808    		JR	C,CLOSE3	; FCB < directory then jump
1837:	D1DD  77      		LD	(HL),A		; Save extent number in directory
1838:	D1DE  23      		INC	HL		; Get pointer to next record
1839:	D1DF  23      		INC	HL
1840:	D1E0  23      		INC	HL
1841:	D1E1  DD7E0F  		LD	A,(IX+FCBREC)	; Get next record FCB
1842:	D1E4  77      		LD	(HL),A		; Save next record in directory
1843:	D1E5  CD08D2  	CLOSE3:	CALL	CLOSE6		; Clear Archive Bit and Write FCB
1844:	D1E8  CDA6D5  		CALL	GETDME		; Get Data Module and Extent
1845:	0000          		  IF  NOT ZSDOS11	;  (* NOT in Release version *)
1848:				  ELSE		;Zsdos11   (* This was Release version *)
1849:	D1EB  280D    		JR	Z,CLOSE4	; ..jump to Stamp if they are both 0
1850:	D1ED  C5      		PUSH	BC		; Save prior module and Extent
1851:				  ENDIF		;~Zsdos11
1852:	D1EE  010000  		LD	BC,0
1853:	D1F1  CD9ED5  		CALL	SETDME		; Set FCB Data Module and Extent to 0
1854:	D1F4  CD19D1  		CALL	SRCT15		; Find proper DIR Entry
1855:	0000          		  IF  NOT ZSDOS11
1858:				  ELSE		;Zsdos11
1859:	D1F7  C1      		POP	BC
1860:	D1F8  280B    		JR	Z,JSETDME	; ..Exit if Extent 0 Not Found
1861:	D1FA  C5      	CLOSE4:	PUSH	BC
1862:				  ENDIF		;~Zsdos11
1863:	D1FB  CD08D2  		CALL	CLOSE6		; Clear Archive Bit and Write FCB
1864:	D1FE  2A1CCA  		LD	HL,(STUPDV)	; Get the update routine address
1865:	FFFF          		  IF  ZS
1866:	D201  CDB9D7  		CALL	STAMPT		; ..and stamp it
1867:				  ELSE		;If not Zs (crw)
1870:				  ENDIF		;ZS
1871:	0000          		  IF  NOT  ZSDOS11
1874:				  ELSE		;Zsdos11
1875:	D204  C1      		POP	BC		; Get Original Module and Extent Back
1876:	D205          	JSETDME:
1877:				  ENDIF		;~Zsdos11
1878:	D205  C39ED5  		JP	SETDME		; Restore to FCB and Exit
1879:			
1880:	D208  CDF1D0  	CLOSE6:	CALL	CALDIR		; Get directory entry
1881:	D20B  010B00  		LD	BC,11		; Point to archive byte
1882:	D20E  09      		ADD	HL,BC
1883:	D20F  CBBE    		RES	7,(HL)		; Reset archive bit
1884:	D211  DDCB0BBE		RES	7,(IX+ARCATT)	; Reset bit in FCB
1885:	FFFF          		  IF  ZSDOS11
1886:	D215  1800    		JR	WRFCB		; Write FCB to Disk
1887:			
1888:	0000          		   IF  NOT ZS
1892:				   ENDIF	;NOT Zs
1893:				  ENDIF		;Zsdos11
1894:			
1895:	D217  CDF1D0  	WRFCB:	CALL	CALDIR		; Point to dir entry to write
1896:	D21A  3E0D    		LD	A,FCBUSR	; Offset to user byte in FCB
1897:	D21C  CDF7D0  		CALL	CALDI0		; ..do the add here
1898:	D21F  3600    		LD	(HL),0		; Prevent writing it to disk
1899:	D221  CD68D0  		CALL	STDIR		; Calculate sector/track directory
1900:	D224  0EFF    		LD	C,0FFH		; Update checksum directory
1901:	D226  CD5AD1  		CALL	CHKDIR
1902:	D229  CD3DD2  	WRITD1:	CALL	DMADIR		; Set up dma directory (label for DS - crw)
1903:	D22C  0E01    		LD	C,1		; Write directory flag
1904:	D22E  CD9AD1  		CALL	WRITER		; Write record
1905:	D231  1804    		JR	STDMA		; Set up DMA user
1906:			
1907:	0000          		  IF  NOT ZSDOS11
1913:				  ENDIF		;~Zsdos11
1914:			
1915:			; Set DMA Address Command
1916:			
1917:	D233  ED532ECA	CMND26:	LD	(DMA),DE	; Save DMA address
1918:			
1919:			; Set DMA Address
1920:			
1921:	D237  ED4B2ECA	STDMA:	LD	BC,(DMA)	; Get DMA address
1922:	D23B  1804    		JR	DMADR0		; And do BIOS call
1923:			
1924:			; Set DMA Address Directory
1925:			
1926:	D23D  ED4B34CA	DMADIR:	LD	BC,(DIRBUF)	; Get DMA address directory
1927:	D241  C324D8  	DMADR0:	JP	SETDMA		; Cbios call set DMA
1928:			
1929:			; Get Bit from ALV Buffer
1930:			;  Entry DE=Block Number
1931:			;  Exit  A =Bit in LSB
1932:			;	 B =Bit Number in A
1933:			;	 HL=Pointer in ALV Buffer
1934:			
1935:	D244  7B      	GETBIT:	LD	A,E		; Get bit number
1936:	D245  E607    		AND	7		; Mask it
1937:	D247  3C      		INC	A		; Add 1
1938:	D248  4F      		LD	C,A		; Save it
1939:	FFFF          		  IF  UNROLL
1940:	D249  CB3A    		SRL	D		; Get byte number
1941:	D24B  CB1B    		RR	E		; DE=DE/8
1942:	D24D  CB3A    		SRL	D
1943:	D24F  CB1B    		RR	E
1944:	D251  CB3A    		SRL	D
1945:	D253  CB1B    		RR	E		; ..inline for speed (net cost: 4)
1946:	D255  47      		LD	B,A		; Re-save bit number for next shift
1947:	D256  2A3ACA  		LD	HL,(ALV)	; Get start address ALV buffer
1948:				  ELSE
1953:				  ENDIF		;Unroll
1954:	D259  19      		ADD	HL,DE		; Add byte number
1955:	D25A  7E      		LD	A,(HL)		; Get 8 bits
1956:	D25B  07      	GETBT0:	RLCA			; Get correct bit
1957:	D25C  10FD    		DJNZ	GETBT0
1958:	D25E  41      		LD	B,C		; Restore bit number
1959:	D25F  C9      		RET			; And return to caller
1960:			
1961:			; Set/Reset bit in ALV Buffer
1962:			;  Entry DE=Block Number
1963:			;	 C =0 Reset Bit, C=1 Set Bit
1964:			
1965:	D260  C5      	SETBIT:	PUSH	BC		; Save set/reset bit
1966:	D261  CD44D2  		CALL	GETBIT		; Get bit
1967:	D264  E6FE    		AND	0FEH		; Mask it
1968:	D266  D1      		POP	DE		; Get set/reset bit
1969:	D267  B3      		OR	E		; Set/reset bit
1970:	D268  0F      	SETBT0:	RRCA			; Rotate bit in correct position
1971:	D269  10FD    		DJNZ	SETBT0
1972:	D26B  77      		LD	(HL),A		; Save 8 bits
1973:	D26C  C9      		RET			; And return to caller
1974:			
1975:			; Delete File
1976:			
1977:	D26D  CDBDD3  	DELETE:	CALL	COMCOD		; Call common code w/VDEL on stack
1978:			
1979:			; Delete Routine Core (relocated to save space) (hfb)
1980:			
1981:	D270  CDEED0  	VDEL:	CALL	CKRODI		; Check file W/P, get directory entry
1982:	D273  36E5    		LD	(HL),0E5H	; Remove file
1983:	D275  23      		INC	HL
1984:	D276  7E      		LD	A,(HL)		; Get first char
1985:	D277  D624    		SUB	'$'		; See if submit file
1986:	D279  2003    		JR	NZ,VDEL1	; If not
1987:	D27B  3257CA  		LD	(SUBFLG),A	; Clear subflg if $*.* erased
1988:	D27E  23      	VDEL1:	INC	HL
1989:	D27F  CBBE    		RES	7,(HL)		; Insure erased files are not public
1990:	D281  0E00    		LD	C,0		; Remove bits ALV buffer
1991:							; ..fall thru and return to caller..
1992:			
1993:			; Fill bit buffer from FCB in DIRBUF
1994:			;  Entry C=0 Reset Bit, C=1 Set Bit
1995:			
1996:	D283  CDF1D0  	FILLBB:	CALL	CALDIR		; Get directory entry
1997:	D286  111000  		LD	DE,16		; Get offset DM block
1998:	D289  19      		ADD	HL,DE		; Add offset
1999:	D28A  43      		LD	B,E		; Get block counter
2000:	D28B  5E      	FILLB0:	LD	E,(HL)		; Get LSB block number
2001:	D28C  23      		INC	HL		; Increment pointer
2002:	D28D  1600    		LD	D,0		; Reset MSB block number
2003:	D28F  3A42CA  		LD	A,(MAXLEN+1)	; Test >256 blocks present
2004:	D292  B7      		OR	A
2005:	D293  2803    		JR	Z,FILLB1	; No then jump
2006:	D295  05      		DEC	B		; Decrement block counter
2007:	D296  56      		LD	D,(HL)		; Get correct MSB
2008:	D297  23      		INC	HL		; Increment pointer
2009:	D298  7A      	FILLB1:	LD	A,D		; Test block number
2010:	D299  B3      		OR	E
2011:	D29A  280D    		JR	Z,FILLB2	; Zero then get next block
2012:	D29C  E5      		PUSH	HL		; Save pointer
2013:	D29D  C5      		PUSH	BC		; Save counter and set/reset bit
2014:	D29E  2A41CA  		LD	HL,(MAXLEN)	; Get maximum length ALV buffer
2015:	D2A1  B7      		OR	A		; Reset carry
2016:	D2A2  ED52    		SBC	HL,DE		; Test DE<=maxlen ALV buffer
2017:	D2A4  D460D2  		CALL	NC,SETBIT	; Yes then insert bit
2018:	D2A7  C1      		POP	BC		; Get counter and set/reset bit
2019:	D2A8  E1      		POP	HL		; Get pointer
2020:	D2A9  10E0    	FILLB2:	DJNZ	FILLB0		; Repeat for all DM entries
2021:	D2AB  C9      		RET			; And return to caller
2022:			
2023:			; Check File W/P Bit - SEARCH called first
2024:			
2025:	D2AC  CDF1D0  	CHKFRO:	CALL	CALDIR		; Get directory entry
2026:	D2AF  110800  		LD	DE,WHLATT	; Offset to R/O bit
2027:	D2B2  19      		ADD	HL,DE		; Add offset
2028:	D2B3  ED5B13CA		LD	DE,(WHEEL)	; Get wheel byte address from header
2029:	D2B7  1A      		LD	A,(DE)		; ..and retrieve the actual byte
2030:	D2B8  A7      		AND	A		; ..and check the Wheel byte
2031:	D2B9  2004    		JR	NZ,CHKFR4	; We have wheel, so allow writes anyway
2032:	D2BB  CB7E    		BIT	7,(HL)		; Else check Wheel attribute
2033:	D2BD  2010    		JR	NZ,CHKFR2	; Yes then error
2034:	D2BF  23      	CHKFR4:	INC	HL		; Check W/P bit (hfb)
2035:	D2C0  CB7E    		BIT	7,(HL)		; Test file W/P
2036:	D2C2  200B    		JR	NZ,CHKFR2	; If W/P
2037:	D2C4  DDCB077E	CHKFR3:	BIT	7,(IX+PSFATT)	; Was file accessed as Public or Path?
2038:	D2C8  C8      		RET	Z		; If normal access
2039:	D2C9  3A15CA  		LD	A,(FLAGS)	; Else test for writes allowed
2040:	D2CC  E602    		AND	0010B
2041:	D2CE  C0      		RET	NZ		; Go ahead, writes are allowed
2042:	D2CF  2A0FCA  	CHKFR2:	LD	HL,(SFILRO)	; Get pointer to file W/P message
2043:	D2D2  0603    		LD	B,3		; File W/P error code
2044:	D2D4  111ECD  		LD	DE,MFILRO	; Load file W/P message
2045:	D2D7  E9      		JP	(HL)		; Display message
2046:			
2047:			
2048:			; Check Drive Write Protect
2049:			
2050:	D2D8          	BGCKDRO:
2051:	D2D8  CDE5D2  	CHKRO:	CALL	CHKRO1		; Is the disk W/P?
2052:	D2DB  C0      		RET	NZ		; ..return if disk R/W
2053:	D2DC  0602    		LD	B,2		; Else set disk W/P error code
2054:	D2DE  1123CD  		LD	DE,MRO		; Load drive W/P message
2055:	D2E1  2A0DCA  		LD	HL,(STRO)	; Get pointer to drive W/P message
2056:	D2E4  E9      		JP	(HL)		; Display message
2057:			
2058:	D2E5  2AFCD7  	CHKRO1:	LD	HL,(DSKWP)	; Get the W/P drive vector
2059:	D2E8  CD4AD0  		CALL	SDRVB		; Set the bit for this drive
2060:	D2EB  ED52    		SBC	HL,DE		; See if extra bit added (Cy is clear)
2061:	D2ED  C9      		RET
2062:			
2063:			; Search using first 12 bytes of FCB (hfb)
2064:			
2065:	D2EE  3E0C    	SEAR12:	LD	A,12
2066:	D2F0  21      		DEFB	21H		; Trash HL and fall through
2067:			
2068:			; Search using first 15 bytes of FCB
2069:			
2070:	D2F1  3E0F    	SEAR15:	LD	A,15
2071:			
2072:			; Search for File Name
2073:			;  Entry: A = Number of bytes for which to search
2074:			
2075:	D2F3  325BCA  	SEARCH:	LD	(SEARNB),A	; Save number of bytes
2076:	D2F6  3EFF    		LD	A,0FFH		; Set exit code to 0FFH (not found)
2077:	D2F8  325ACA  		LD	(SEAREX),A
2078:	D2FB  DD2258CA		LD	(DCOPY),IX	; Copy FCB pointer to RAM (search next)
2079:	D2FF  CDFCD0  		CALL	SETFCT		; Initiate file counter
2080:			
2081:			; Force directory read with a Call HOME (bh)   (Only if Floppys-hfb)
2082:	FFFF          		  IF  ZSDOS11		; (* Logic moved to RDDIR if NOT Zsdos11 *)
2083:	D302  2A47CA  		LD	HL,(NCHECK)	; Is this a fixed media?
2084:	D305  7C      		LD	A,H
2085:	D306  B5      		OR	L
2086:	D307  C418D8  		CALL	NZ,HOME		; Invoke CBIOS Home routine if removeable
2087:				  ENDIF		;~Zsdos11
2088:			
2089:			; Search Next File Name
2090:			
2091:	D30A  AF      	SEARCN:	XOR	A		; Check checksum directory
2092:	D30B  67      		LD	H,A
2093:	D30C  6F      		LD	L,A
2094:	D30D  2250CA  		LD	(SEARQU),HL	; Clear question mark & public detected flags
2095:	D310  DDCB07BE		RES	7,(IX+PSFATT)	; Reset public/system file flag
2096:	D314  CD30D1  		CALL	RDDIR		; Get FCB from directory
2097:	D317  CD1CD1  		CALL	TSTFCT		; Test if past last entry
2098:	D31A  280E    		JR	Z,JSEAR8	; Yes then jump (note carry always clear)
2099:	D31C  ED5B58CA		LD	DE,(DCOPY)	; Get FCB pointer
2100:	D320  1A      		LD	A,(DE)		; Get first byte
2101:	D321  FEE5    		CP	0E5H		; Test if searching empty directory
2102:	D323  2807    		JR	Z,SEARC1	; Yes then jump
2103:	D325  D5      		PUSH	DE		; Save FCB pointer
2104:	D326  CD23D1  		CALL	TSTLF		; Test last file on this drive
2105:	D329  D1      		POP	DE		; Restore FCB pointer
2106:	D32A  306B    	JSEAR8:	JR	NC,SEARC8	; Yes then jump
2107:	D32C  CDF1D0  	SEARC1:	CALL	CALDIR		; Get entry in directory
2108:	D32F  7E      		LD	A,(HL)		; Get first byte directory entry
2109:	D330  FE21    		CP	21H		; Test time stamp
2110:	D332  28D6    		JR	Z,SEARCN	; Yes then get next directory entry
2111:	D334  0E00    		LD	C,0		; Clear counter
2112:	D336  3A5BCA  		LD	A,(SEARNB)	; Get number of bytes to search for
2113:	D339  47      		LD	B,A		; Save it in counter
2114:	D33A  78      	SEARC2:	LD	A,B		; Test if counter is zero
2115:	D33B  B7      		OR	A
2116:	D33C  285F    		JR	Z,SEARC9	; Yes then jump
2117:	D33E  1A      		LD	A,(DE)		; Get byte from FCB
2118:	D33F  EE3F    		XOR	'?'		; Test if question mark
2119:	D341  E67F    		AND	7FH		; Mask it
2120:	D343  283B    		JR	Z,SEARC6	; Yes then jump
2121:	D345  79      		LD	A,C		; Get FCB counter
2122:	D346  B7      		OR	A		; Test first byte
2123:	D347  2022    		JR	NZ,SEARC3	; No then jump
2124:	D349  3A15CA  		LD	A,(FLAGS)	; Get flag byte
2125:	D34C  1F      		RRA			; Test public file enable
2126:	D34D  301C    		JR	NC,SEARC3	; ..jump if not
2127:	D34F  23      		INC	HL		; Get pointer to Public Bit
2128:	D350  23      		INC	HL
2129:	D351  CB7E    		BIT	7,(HL)		; Test Public Bit directory
2130:	D353  2B      		DEC	HL		; Restore pointer
2131:	D354  2B      		DEC	HL
2132:	D355  2814    		JR	Z,SEARC3	; No public file then jump
2133:	D357  1A      		LD	A,(DE)		; Get first byte FCB
2134:	D358  FEE5    		CP	0E5H		; Test if searching empty directory
2135:	D35A  280F    		JR	Z,SEARC3	; Yes then jump
2136:			
2137:			; The following 3 lines of code represent a deviation from the description of
2138:			; PUBLIC Files as given in DDJ Article by Bridger Mitchell and Derek McKay of
2139:			; Plu*Perfect Systems.	The PUBLIC Specification states that Public Files will
2140:			; NOT be found by any wildcard reference except when a "?" is in the FCB+0
2141:			; byte.  The code here relaxes that requirement as follows:  If we are in the
2142:			; same user area as the public file, then don't report the file as PUBLIC, but
2143:			; find it.  This has a nasty side effect - it allows erasing of PUBLIC files
2144:			; if we are in the same area.  However, these files also show up on the direc-
2145:			; tory (they wouldn't otherwise), so at least we should know we're blasting
2146:			; them.
2147:			
2148:	D35C  AE      		XOR	(HL)		; Test FCB = Directory Entry
2149:	D35D  E67F    		AND	7FH		; Mask it (setting Zero Flag)
2150:	D35F  2819    		JR	Z,SEARC5	; Jump if user is same
2151:	D361  3EFF    		LD	A,0FFH
2152:	D363  3251CA  		LD	(SEARPU),A	; Set Public file found
2153:	FFFF          		  IF  UPATH
2154:	D366  CDAFD4  		CALL	SETPSF		; Set Public/System file flag
2155:				  ELSE
2157:				  ENDIF
2158:	D369  180F    		JR	SEARC5		; Jump found
2159:			
2160:	D36B  79      	SEARC3:	LD	A,C		; Get FCB counter
2161:	D36C  FE0D    		CP	13		; Is it User Code?
2162:	D36E  280A    		JR	Z,SEARC5	; ..jump if so..don't test
2163:	D370  FE0C    		CP	12		; Is it an Extent Number?
2164:	D372  1A      		LD	A,(DE)		; ..Get byte from FCB
2165:	D373  2811    		JR	Z,SEARC7	; ..Jump if Extent Number
2166:	D375  AE      		XOR	(HL)		; Is FCB byte = Directory Entry byte?
2167:	D376  E67F    		AND	07FH		; ..Mask it
2168:	D378  2090    	SEARC4:	JR	NZ,SEARCN	; ..jump if not same and get next entry
2169:	D37A  13      	SEARC5:	INC	DE		; Increment FCB pointer
2170:	D37B  23      		INC	HL		; Increment Directory Entry pointer
2171:	D37C  0C      		INC	C		; Increment counter
2172:	D37D  05      		DEC	B		; Decrement counter
2173:	D37E  18BA    		JR	SEARC2		; Test next byte
2174:			
2175:	D380  3D      	SEARC6:	DEC	A		; Set question mark found flag
2176:	D381  3250CA  		LD	(SEARQU),A
2177:	D384  18F4    		JR	SEARC5		; Jump found
2178:			
2179:	D386          	SEARC7:
2180:	D386  AE      		XOR	(HL)		; Test extent
2181:	D387  CD8CD3  		CALL	SEARC7A		; Mask Extent
2182:	D38A  18EC    		JR	SEARC4		; ..and test Result
2183:			
2184:			
2185:	D38C  C5      	SEARC7A: PUSH	BC
2186:	D38D  47      		LD	B,A		; Save Extent
2187:	D38E  3A40CA  		LD	A,(NEXTND)	; Get extent mask
2188:	D391  2F      		CPL			; Complement it
2189:	D392  E61F    		AND	MAXEXT		; Mask it
2190:	D394  A0      		AND	B		; Mask extent
2191:	D395  C1      		POP	BC		; Restore counters
2192:	D396  C9      		RET
2193:			
2194:	D397  CDFCD0  	SEARC8:	CALL	SETFCT		; Error set file counter
2195:	D39A  C37AD5  		JP	RETCFF		; Set return code to FF and exit
2196:			
2197:	D39D  2A50CA  	SEARC9:	LD	HL,(SEARQU)	; Get question mark and public found flags
2198:	D3A0  7C      		LD	A,H
2199:	D3A1  A5      		AND	L
2200:	D3A2  20D4    		JR	NZ,SEARC4	; Yes then search for next entry
2201:	D3A4  CD23D1  		CALL	TSTLF		; Test for last file
2202:	D3A7  D414D1  		CALL	NC,SETLF0	; And update if so
2203:	D3AA  2A52CA  		LD	HL,(RECDIR)	; Set DE return to directory record
2204:	D3AD  225FCA  		LD	(DEVAL),HL	; .. for DateStamper simulation
2205:	D3B0  3A54CA  		LD	A,(FILCNT)	; Get file counter
2206:	D3B3  E603    		AND	3		; Mask it
2207:	D3B5  324CCA  		LD	(PEXIT),A	; And set exit code
2208:	D3B8  AF      		XOR	A		; Clear exit code search
2209:	D3B9  325ACA  		LD	(SEAREX),A
2210:	D3BC  C9      		RET			; And return to caller
2211:			
2212:			; The following code is common to DELETE, RENAME, and CSTAT.
2213:			; It is coded in a manner that is compatable with the Z280
2214:			; in protected Mode.
2215:			
2216:	D3BD  CDD8D2  	COMCOD:	CALL	CHKRO		; Check disk W/P
2217:	D3C0  CDEED2  		CALL	SEAR12		; Search file
2218:	D3C3  CD1CD1  	COMCO1:	CALL	TSTFCT		; Test if file found
2219:	D3C6  E1      		POP	HL		; Routine addr to HL (in case not found)
2220:	D3C7  C8      		RET	Z		; Not then exit
2221:	D3C8  E5      		PUSH	HL		; ..found, so routine back to stack
2222:	D3C9  E5      		PUSH	HL		; Twice, as RET pops first push
2223:	D3CA  21CFD3  		LD	HL,COMCO2
2224:	D3CD  E3      		EX	(SP),HL		; COMCO2 to stack, routine addr to HL
2225:	D3CE  E9      		JP	(HL)		; ..branch to routine
2226:			
2227:	D3CF  CD17D2  	COMCO2:	CALL	WRFCB		; Write directory buffer on disk
2228:	D3D2  CD0AD3  		CALL	SEARCN		; Search next entry
2229:	D3D5  18EC    		JR	COMCO1		; And test it
2230:			
2231:			
2232:			; Rename File - Note Wildcard Support
2233:			
2234:	D3D7  CDBDD3  	RENAM:	CALL	COMCOD		; Go to common code w/VRENAM on stack
2235:			
2236:	D3DA  CDACD2  	VRENAM:	CALL	CHKFRO		; Check file W/P
2237:	D3DD  2A5DCA  		LD	HL,(ARWORD)
2238:	D3E0  111000  		LD	DE,16		; Offset to new name
2239:	D3E3  19      		ADD	HL,DE		; Add offset
2240:	D3E4  EB      		EX	DE,HL		; Copy HL=>DE
2241:	D3E5  CDF1D0  		CALL	CALDIR		; Get directory entry
2242:	D3E8  23      		INC	HL
2243:	D3E9  23      		INC	HL
2244:	D3EA  CBBE    		RES	7,(HL)		; Make any renamed file private
2245:	D3EC  2B      		DEC	HL
2246:	D3ED  2B      		DEC	HL
2247:	D3EE  060B    		LD	B,11		; Set up loop counter
2248:	D3F0  23      	RENAM1:	INC	HL		; Increment directory pointer
2249:	D3F1  13      		INC	DE		; Increment FCB pointer
2250:	D3F2  1A      		LD	A,(DE)		; Get character from FCB
2251:	D3F3  E67F    		AND	7FH		; Mask it
2252:	D3F5  FE3F    		CP	'?'		; Test if question mark
2253:	D3F7  2001    		JR	NZ,RENAM2	; no, then change character on disk
2254:	D3F9  7E      		LD	A,(HL)		; Else get what's there as there is no change
2255:	D3FA  17      	RENAM2:	RLA			; Clear MSB
2256:	D3FB  CB16    		RL	(HL)		; Get MSB from directory
2257:	D3FD  1F      		RRA			; And move to FCB
2258:	D3FE  77      		LD	(HL),A		; Save in directory
2259:	D3FF  10EF    		DJNZ	RENAM1		; Loop until done
2260:	D401  C9      		RET
2261:			
2262:			; Change Status Bits for File
2263:			
2264:	D402  CDBDD3  	CSTAT:	CALL	COMCOD		; Go to common code w/VCSTAT on stack
2265:			
2266:	D405  DDE5    	VCSTAT:	PUSH	IX
2267:	D407  D1      		POP	DE		; FCB pointer in DE
2268:	D408  CDF1D0  		CALL	CALDIR		; Get directory entry
2269:	D40B  060B    		LD	B,11		; Set up loop counter
2270:	D40D  23      	CSTAT1:	INC	HL		; Increment directory pointer
2271:	D40E  13      		INC	DE		; Increment FCB pointer
2272:	D40F  3E04    		LD	A,4		; Are we pointing to Wheel Attribute?
2273:	D411  B8      		CP	B
2274:	D412  200E    		JR	NZ,CSTAT2	; ..jump if not
2275:	D414  E5      		PUSH	HL
2276:	D415  2A13CA  		LD	HL,(WHEEL)	; Else do we have Wheel privileges?
2277:	D418  7E      		LD	A,(HL)
2278:	D419  E1      		POP	HL
2279:	D41A  A7      		AND	A		; ..set flags to show
2280:	D41B  2005    		JR	NZ,CSTAT2	; Jump if we have Wheel
2281:	D41D  CB7E    		BIT	7,(HL)		; Is file Wheel protected?
2282:	D41F  C2CFD2  		JP	NZ,CHKFR2	; ..jump if so
2283:	D422  1A      	CSTAT2:	LD	A,(DE)		; Get status bit from FCB
2284:	D423  CB16    		RL	(HL)		; Remove MSB of directory
2285:	D425  17      		RLA			; Get msb from FCB
2286:	D426  CB1E    		RR	(HL)		; And move into directory char
2287:	D428  10E3    		DJNZ	CSTAT1		; Loop until done
2288:	D42A  C9      		RET
2289:			
2290:			; Compute File Size
2291:			
2292:	D42B  010000  	FILSZ:	LD	BC,0		; Reset file size length
2293:	D42E  51      		LD	D,C
2294:	D42F  CD15CF  		CALL	LDRRC		; Save it in FCB+33,34,35
2295:	D432  CDEED2  		CALL	SEAR12		; Search file (hfb)
2296:	D435  CD1CD1  	FILSZ0:	CALL	TSTFCT		; Test if file found
2297:	D438  C8      		RET	Z		; Not then exit
2298:	D439  CDF1D0  		CALL	CALDIR		; Get directory entry
2299:	D43C  EB      		EX	DE,HL		; Copy to DE
2300:	D43D  210F00  		LD	HL,15		; Offset to next record
2301:	D440  CD7FD7  		CALL	CALRRC		; Calculate random record count
2302:	D443  7A      		LD	A,D		; Test LSB < (ix+33)
2303:	D444  DD9621  		SUB	(IX+33)
2304:	D447  79      		LD	A,C		; Test ISB < (ix+34)
2305:	D448  DD9E22  		SBC	A,(IX+34)
2306:	D44B  78      		LD	A,B		; Test MSB < (ix+35)
2307:	D44C  DD9E23  		SBC	A,(IX+35)
2308:	D44F  D415CF  		CALL	NC,LDRRC	; Write new maximum
2309:	D452  CD0AD3  		CALL	SEARCN		; Search next file
2310:	D455  18DE    		JR	FILSZ0		; And test it
2311:			
2312:			; Find File
2313:	FFFF          		  IF  UPATH
2314:	D457  CD19D1  	FINDF:	CALL	SRCT15		; Search file
2315:	D45A  C0      		RET	NZ		; Yes then exit
2316:	D45B  3A15CA  		LD	A,(FLAGS)
2317:	D45E  CB6F    		BIT	5,A		; Test if Path enabled
2318:	D460  C8      		RET	Z		; Exit if not
2319:	D461  2A11CA  		LD	HL,(PATH)	; Get Path address
2320:	D464  7C      		LD	A,H		; Test if zero (no path)
2321:	D465  B5      		OR	L
2322:	D466  C8      		RET	Z		; Yes then exit
2323:	D467  7E      	FINDF0:	LD	A,(HL)		; Get first entry path name
2324:	D468  23      		INC	HL		; Increment pointer
2325:	D469  B7      		OR	A		; Test if last entry
2326:	D46A  CA97D3  		JP	Z,SEARC8	; Yes then error exit
2327:	D46D  E67F    		AND	7FH		; Mask drive number
2328:	D46F  FE24    		CP	'$'		; Test if current drive
2329:	D471  2004    		JR	NZ,FINDF1	; No then jump
2330:	D473  3A2CCA  		LD	A,(DRIVE)	; Get current drive
2331:	D476  3C      		INC	A		; Increment drive number
2332:	D477  3D      	FINDF1:	DEC	A		; Decrement drive number
2333:	D478  E5      		PUSH	HL		; Save path pointer
2334:	D479  CD81CF  		CALL	SELDK		; Select drive
2335:	D47C  E1      		POP	HL		; Restore path pointer
2336:	D47D  7E      		LD	A,(HL)		; Get user number
2337:	D47E  23      		INC	HL		; Advance pointer
2338:	D47F  E67F    		AND	7FH		; Mask user number
2339:	D481  FE24    		CP	'$'		; Test if current user
2340:	D483  2003    		JR	NZ,FINDF2	; No then jump
2341:	D485  3A2ACA  		LD	A,(USER)	; Get current user
2342:	D488  E61F    	FINDF2:	AND	1FH		; Mask user number
2343:	D48A  E5      		PUSH	HL		; Save path pointer
2344:	D48B  CD5ECF  		CALL	RESUSR		; Add new user number in FCB+0 and FCB+13
2345:	D48E  CD19D1  		CALL	SRCT15		; Search file and test if present
2346:	D491  E1      		POP	HL		; Restore path pointer
2347:	D492  28D3    		JR	Z,FINDF0	; No then test next path entry
2348:	D494  E5      		PUSH	HL		; Save path pointer
2349:	D495  CDF1D0  		CALL	CALDIR		; Get directory entry
2350:	D498  110A00  		LD	DE,10		; Add offset system bit
2351:	D49B  19      		ADD	HL,DE
2352:	D49C  CB7E    		BIT	7,(HL)		; Test system file
2353:	D49E  3A15CA  		LD	A,(FLAGS)	; Test for relaxed path definition
2354:	D4A1  17      		RLA			; ..by rotating bit..
2355:	D4A2  17      		RLA			; ..into carry flag
2356:	D4A3  E1      		POP	HL		; Restore path pointer
2357:	D4A4  3802    		JR	C,FINDF3	; If carry, system attrib not required
2358:	D4A6  28BF    		JR	Z,FINDF0	; No system file then test next path entry
2359:	D4A8  3A2BCA  	FINDF3:	LD	A,(DEFDRV)	; Get current drive
2360:	D4AB  3C      		INC	A		; Increment drive number
2361:	D4AC  322DCA  		LD	(FCB0),A	; Save it in exit FCB0
2362:	D4AF  DDCB07FE	SETPSF:	SET	7,(IX+PSFATT)	; set Public/System file flag
2363:	D4B3  C9      		RET			; And return to caller
2364:				  ENDIF		;Upath
2365:			
2366:			; Open File Command
2367:			
2368:	D4B4  CD1FCF  	CMND15:	CALL	SELDRV		; Select drive from FCB
2369:	D4B7  DD360E00		LD	(IX+FCBMOD),0	; Clear data module number
2370:			
2371:			; Open File
2372:	FFFF          		  IF  UPATH
2373:	D4BB  CD57D4  		CALL	FINDF		; Find file (use path name)
2374:	D4BE  CD1CD1  		CALL	TSTFCT		; Test file found
2375:				  ELSE
2377:				  ENDIF		;Upath
2378:	D4C1  C8      		RET	Z		; No then exit
2379:	D4C2  DD7E07  	OPENF0:	LD	A,(IX+PSFATT)	; Get Public/System file bit
2380:	D4C5  F5      		PUSH	AF		; Save it
2381:	D4C6  DD7E0C  		LD	A,(IX+FCBEXT)	; Get extent number from FCB
2382:	D4C9  F5      		PUSH	AF		; Save it
2383:	D4CA  CDF1D0  		CALL	CALDIR		; Get directory entry
2384:	D4CD  7E      		LD	A,(HL)		; Find real user number file is in
2385:	D4CE  F680    		OR	80H		; Set user valid flag
2386:	D4D0  DDE5    		PUSH	IX		; Save FCB entry
2387:	D4D2  D1      		POP	DE		; Get in in DE
2388:	D4D3  012000  		LD	BC,32		; Number of bytes to move
2389:	D4D6  EDB0    		LDIR			; Move directory to FCB
2390:	D4D8  DD770D  		LD	(IX+FCBUSR),A	; And put user byte back
2391:	D4DB  CD7AD7  		CALL	SETB14		; Set FCB/File Not Modified
2392:	D4DE  DD460C  		LD	B,(IX+FCBEXT)	; Get extent number
2393:	D4E1  DD4E0F  		LD	C,(IX+FCBREC)	; Get next record number
2394:	D4E4  F1      		POP	AF		; Get old extent number
2395:	D4E5  DD770C  		LD	(IX+FCBEXT),A	; Save it
2396:	D4E8  B8      		CP	B		; Compare old and new extent number
2397:	D4E9  2804    		JR	Z,OPENF1	; Same then jump
2398:	D4EB  0E00    		LD	C,0		; Set next record count to 0
2399:	D4ED  CB19    		RR	C		; Record count to Max (80H) if need new extent
2400:	D4EF  DD710F  	OPENF1:	LD	(IX+FCBREC),C	; Save next record count
2401:	D4F2  F1      		POP	AF		; Get Public/System file bit
2402:	D4F3  DDCB0716		RL	(IX+PSFATT)	; Remove MSB from IX+8
2403:	D4F7  17      		RLA			; Set new MSB in carry
2404:	D4F8  DDCB071E		RR	(IX+PSFATT)	; Save Carry in IX+8
2405:	FFFF          		  IF  ZS
2406:	D4FC  2A18CA  		LD	HL,(STLAV)	; Get address of last accessed routine
2407:	D4FF  C3B9D7  		JP	STAMPT
2408:				  ELSE
2412:				  ENDIF		;Zs
2413:			
2414:			; Make File Command
2415:			
2416:	D502  CD1FCF  	CMND22:	CALL	SELDRV		; Select drive from FCB
2417:	D505  DD360E00		LD	(IX+FCBMOD),0	; Clear data module number
2418:			
2419:			; Make File
2420:			
2421:	D509  CDD8D2  	MAKES:	CALL	CHKRO		; Check drive W/P
2422:	D50C  2A5DCA  		LD	HL,(ARWORD)
2423:	D50F  7E      		LD	A,(HL)		; Get first byte FCB
2424:	D510  F5      		PUSH	AF		; Save it
2425:	D511  36E5    		LD	(HL),0E5H	; Set first byte to empty file
2426:	D513  3E01    		LD	A,1		; Search for 1 byte
2427:	D515  CDF3D2  		CALL	SEARCH		; Search empty file
2428:	D518  F1      		POP	AF		; Get first byte FCB
2429:	D519  DD7700  		LD	(IX+0),A	; Restore it
2430:	D51C  CD1CD1  		CALL	TSTFCT		; Test empty file found
2431:	D51F  C8      		RET	Z		; No then return error
2432:	D520  2A5DCA  		LD	HL,(ARWORD)	; Get FCB pointer
2433:	D523  CD52CE  		CALL	CKSUB		; Check if this is a submit file
2434:	D526  110F00  		LD	DE,15		; Prepare offset
2435:	D529  19      		ADD	HL,DE		; Add it
2436:	D52A  0611    		LD	B,17		; Set loop counter
2437:	D52C  AF      		XOR	A
2438:	D52D  77      	MAKE0:	LD	(HL),A		; Clear FCB+15 up to FCB+31
2439:	D52E  23      		INC	HL		; Increment pointer
2440:	D52F  10FC    		DJNZ	MAKE0		; And clear all bytes
2441:	D531  DDCB07BE		RES	7,(IX+PSFATT)	; Reset Public/System file bit
2442:	D535  DDCB0BBE		RES	7,(IX+ARCATT)	; Reset archive bit if present
2443:	D539  CDF1D0  		CALL	CALDIR		; Get directory entry
2444:	D53C  DDE5    		PUSH	IX		; Save FCB entry
2445:	D53E  D1      		POP	DE		; Get it in DE
2446:	D53F  EB      		EX	DE,HL		; Exchange FCB and directory entry
2447:	D540  012000  		LD	BC,32		; Number of bytes to move
2448:	D543  EDB0    		LDIR			; Move bytes
2449:	D545  CD17D2  		CALL	WRFCB		; Write FCB on disk
2450:	D548  CD7AD7  		CALL	SETB14		; Set file not modified
2451:	FFFF          		  IF  ZS
2452:	D54B  2A1ACA  		LD	HL,(STCRV)	; Get address of Stamp Create routine
2453:	D54E  C3B9D7  		JP	STAMPT		; ..and stamp it
2454:				  ELSE
2457:				  ENDIF		;Zs
2458:			
2459:			; Open Next Extent
2460:			
2461:	D551  DDCB0E7E	OPENEX:	BIT	7,(IX+FCBMOD)	; Test if FCB/File Modified (write)
2462:	D555  2008    		JR	NZ,OPENX2	; Not then jump
2463:	D557  CDABD1  		CALL	CLOSE		; Close current FCB
2464:	D55A  3A4CCA  		LD	A,(PEXIT)	; Get exit code
2465:	D55D  3C      		INC	A		; Test if error
2466:	D55E  C8      		RET	Z		; Yes then exit
2467:	D55F  CD85D5  	OPENX2:	CALL	CALNEX		; Calculate next extent (LABEL MOVED)
2468:	D562  3813    		JR	C,OPENX3	; Error then jump
2469:			
2470:	D564  CD19D1  	OPENX0:	CALL	SRCT15		; Search for 15-char match & test presence
2471:	D567  2016    		JR	NZ,OPENX5	; Yes then jump
2472:	D569  3A4FCA  		LD	A,(RDWR)	; Test Read/Write flag
2473:	D56C  B7      		OR	A		; Test if read
2474:	D56D  2808    		JR	Z,OPENX3	; Yes then error
2475:	D56F  CD09D5  		CALL	MAKES		; Make new extent if write
2476:	D572  CD1CD1  		CALL	TSTFCT		; Test if succesfull
2477:	D575  200B    		JR	NZ,OPENX6	; Yes then exit
2478:	D577  CD7AD7  	OPENX3:	CALL	SETB14		; Set FCB/File Not Modified
2479:	D57A  3EFF    	RETCFF:	LD	A,0FFH		; (hfb/cwc) set exit code
2480:	D57C  C3BBCE  	OPENX4:	JP	SAVEA		; And return to caller
2481:			
2482:	D57F  CDC2D4  	OPENX5:	CALL	OPENF0		; Open file
2483:	D582  AF      	OPENX6:	XOR	A		; And clear exit code
2484:	D583  18F7    		JR	OPENX4		; Use same routine
2485:			
2486:			;==OPENX2:	CALL	CALNEX		; Calculate next extent
2487:			;==	JR	C,OPENX3	; Error then jump
2488:			;==	JR	OPENX0		; Open next extent, FCB contains DU:
2489:			
2490:			; Calculate Next Extent
2491:			;  Exit: Carry=1 => Overflow Detected
2492:			
2493:	D585  CDA6D5  	CALNEX:	CALL	GETDME		; Get extent number, data module number
2494:	D588  CB70    		BIT	6,B		; Test error bit random record
2495:	D58A  37      		SCF			; Set error flag
2496:	D58B  C0      		RET	NZ		; ..Error exit if Non-zero
2497:	D58C  0C      		INC	C		; Increment extent number
2498:	D58D  79      		LD	A,C		; Get extent number
2499:	D58E  E61F    		AND	MAXEXT		; Mask it for max extent
2500:	D590  4F      		LD	C,A		; Save it in C
2501:			;==	JR	NZ,SETDME	; If new data module not required
2502:	D591  2007    		JR	NZ,CALNE1	;== IF NEW DATA MODULE NOT REQUIRED
2503:	D593  04      		INC	B		; Set next data module
2504:	D594  78      		LD	A,B		; Get it in A
2505:	D595  E63F    		AND	MAXMOD		; Mask it for max module
2506:	D597  47      		LD	B,A		; Save it in B
2507:	D598  37      		SCF			; Set error flag
2508:	D599  C8      		RET	Z		; And return if file overflow
2509:	D59A  DD362000	CALNE1:	LD	(IX+NXTREC),0	;== ZERO NEXT RECORD COUNT
2510:	D59E  DD710C  	SETDME:	LD	(IX+FCBEXT),C	; Save Extent number
2511:	D5A1  DD700E  		LD	(IX+FCBMOD),B	; Save Data Module number
2512:	FFFF          		  IF  ZS
2513:	D5A4  A7      		AND	A		; Clear flag here if ZS
2514:	D5A5  C9      		RET
2515:				  ENDIF			; ..else fall thru on ZD to do same thing
2516:			
2517:	D5A6  DD4E0C  	GETDME:	LD	C,(IX+FCBEXT)	; Get Extent number
2518:	D5A9  DD460E  		LD	B,(IX+FCBMOD)	; Get Data Module number
2519:	D5AC  79      		LD	A,C
2520:	D5AD  CD8CD3  		CALL	SEARC7A		; Mask Extent
2521:	D5B0  CBB8    		RES	7,B		; Clear Unmodified Flag
2522:	D5B2  B0      		OR	B		; Test for Module and Extent = 0
2523:	D5B3  C9      		RET			; ..and return to caller
2524:			
2525:			; Read Random Record Command
2526:			
2527:	D5B4  CD2DCF  	CMND33:	CALL	SELDR1		; Select drive from FCB
2528:			
2529:			; Read Random Sector
2530:			
2531:	D5B7  AF      		XOR	A		; Set read/write flag
2532:	D5B8  CDF6D6  		CALL	LDFCB		; Load random record in FCB
2533:	D5BB  2804    		JR	Z,READS		; No error then read sector
2534:	D5BD  C9      		RET			; Return error
2535:			
2536:			; Read Sequential
2537:			
2538:	D5BE  CD2DCF  	CMND20:	CALL	SELDR1		; Select drive from FCB
2539:			
2540:			; Read Sector
2541:			
2542:	D5C1  AF      	READS:	XOR	A		; Set Read/Write flag
2543:	D5C2  324FCA  		LD	(RDWR),A	; Save it
2544:	D5C5  DD7E20  		LD	A,(IX+NXTREC)	; Get record counter
2545:	D5C8  FE80    		CP	80H		; Test if last record this extent
2546:			;=	JR	NC,READS1	; Yes then open next extent
2547:	D5CA  2809    		JR	Z,READS1	;= Yes then open next extent
2548:	D5CC  DDBE0F  		CP	(IX+FCBREC)	; Test if greater then current record
2549:	D5CF  3807    		JR	C,READS2	; No then get record
2550:	D5D1  3E01    	READS0:	LD	A,1		; Set end of file flag
2551:	D5D3  18A7    		JR	OPENX4		; And exit
2552:			
2553:	D5D5  CDE9D5  	READS1:	CALL	OPNXCK		; Open next extent
2554:	D5D8  CDAAD0  	READS2:	CALL	GETDM		; Get block number from DM in FCB
2555:	D5DB  28F4    		JR	Z,READS0	; Jump if block number=0 to end file
2556:	D5DD  CDD7D0  		CALL	CALSEC		; Calculate Sector Number (128 bytes)
2557:	D5E0  CD7AD0  		CALL	CALST		; Calculate Sector/Track number
2558:	D5E3  CD95D1  		CALL	READR		; Read data
2559:	D5E6  C3E4D6  		JP	WRITS7		; Increment elsewhere if necessary
2560:			
2561:			; Consolidated Routine to Open Extent and check status
2562:			
2563:	D5E9  CD51D5  	OPNXCK:	CALL	OPENEX		; Open next extent
2564:	D5EC  3A4CCA  		LD	A,(PEXIT)	; Get exit code
2565:	D5EF  B7      		OR	A
2566:	D5F0  C8      		RET	Z		;== IF OPEN OK
2567:	D5F1  E1      		POP	HL		;== ELSE POP RETURN ADDRESS TO ABORT R/W
2568:	D5F2  18DD    		JR	READS0		;== AND SET ERROR CODE TO EOF
2569:			;==	JR	NZ,READS0	; Yes then end of file
2570:			;==	LD	(IX+NXTREC),A	; Clear record counter (jww)
2571:			;==	RET
2572:			
2573:			; Write Random Record Command (with and without Zero Fill)
2574:			
2575:	D5F4          	CMND40:				; (hfb/cwc)
2576:	D5F4  CD2DCF  	CMND34:	CALL	SELDR1		; Select drive from FCB
2577:			
2578:			; Write Random Sector and Write Random with Zero Fill
2579:			
2580:	D5F7  3EFF    		LD	A,0FFH		; Set Read/Write flag
2581:	D5F9  CDF6D6  		CALL	LDFCB		; Load FCB from random record
2582:	D5FC  2804    		JR	Z,WRITES	; No error then write record
2583:	D5FE  C9      		RET			; Return error
2584:			
2585:			; Write Sequential
2586:			
2587:	D5FF  CD2DCF  	CMND21:	CALL	SELDR1		; Select drive from FCB
2588:			
2589:			; Write Sector.  Permitted to PUBlic files and those found along Path
2590:			
2591:	D602  3EFF    	WRITES:	LD	A,0FFH		; Set read/write flag
2592:	D604  324FCA  		LD	(RDWR),A	; And save it
2593:			
2594:	D608          	BGPTCH1	EQU	$+1		;<-- Patched location for BGii
2595:			
2596:	D607  CDD8D2  		CALL	CHKRO		; Check disk W/P
2597:	D60A  DDCB097E		BIT	7,(IX+ROATT)	; Test if file W/P
2598:	D60E  200E    		JR	NZ,WRITSA	; Yes then file W/P message
2599:	D610  CDC4D2  		CALL	CHKFR3		; Test W/P if path or Public used
2600:	D613  2A13CA  		LD	HL,(WHEEL)	; Get address of Wheel byte
2601:	D616  7E      		LD	A,(HL)		; Do we have it?
2602:	D617  A7      		AND	A
2603:	D618  2007    		JR	NZ,WRITSB	; Yes - allow write
2604:	D61A  DDCB087E		BIT	7,(IX+WHLATT)	; Else test if Wheel Prot file
2605:	D61E  C2CFD2  	WRITSA:	JP	NZ,CHKFR2	; Yes then file W/P message
2606:	D621  DDCB207E	WRITSB:	BIT	7,(IX+NXTREC)	; End of this extent?
2607:	D625  C4E9D5  		CALL	NZ,OPNXCK	; Open next extent and check status (hfb)
2608:	D628  CDAAD0  		CALL	GETDM		; Get block number from FCB
2609:	D62B  C2C3D6  		JP	NZ,WRITS5	; Jump to write sector if Block Number <> 0
2610:	D62E  E5      		PUSH	HL		; Save pointer to Block Number
2611:	D62F  79      		LD	A,C		; Test first Block Number in extent
2612:	D630  B7      		OR	A
2613:	D631  2804    		JR	Z,WRITS1	; Yes then jump
2614:	D633  3D      		DEC	A		; Decrement pointer to Block Number
2615:	D634  CDC0D0  		CALL	GETDM4		; Get previous Block Number
2616:			
2617:			; Get Free Block from ALV Buffer
2618:			;  Entry DE=Old Block Number
2619:			;  Exit  DE=New Block Number (0 if No Free Block)
2620:			;   HL counts Up,DE counts Down
2621:							; GETFRE routine relocated here inline
2622:	D637  62      	WRITS1:	LD	H,D		; Copy old block to HL
2623:	D638  6B      		LD	L,E
2624:	D639  7A      	GETFR0:	LD	A,D		; Test down counter is zero
2625:	D63A  B3      		OR	E
2626:	D63B  280B    		JR	Z,GETFR1	; Yes then jump
2627:	D63D  1B      		DEC	DE		; Decrememt down counter
2628:	D63E  E5      		PUSH	HL		; Save up/down counter
2629:	D63F  D5      		PUSH	DE
2630:	D640  CD44D2  		CALL	GETBIT		; Get bit from ALV buffer
2631:	D643  1F      		RRA			; Test if zero
2632:	D644  3020    		JR	NC,GETFR3	; Yes then found empty block
2633:	D646  D1      		POP	DE		; Get up/down counter
2634:	D647  E1      		POP	HL
2635:	D648  ED4B41CA	GETFR1:	LD	BC,(MAXLEN)	; Get maximum ALV length-1 in BC
2636:	D64C  7D      		LD	A,L		; Is HL >= length ALV-1?
2637:	D64D  91      		SUB	C		; ..do while preserving HL
2638:	D64E  7C      		LD	A,H
2639:	D64F  98      		SBC	A,B
2640:	D650  300E    		JR	NC,GETFR2	; End buffer then jump
2641:	D652  23      		INC	HL		; Increment up counter
2642:	D653  D5      		PUSH	DE		; Save down/up counter
2643:	D654  E5      		PUSH	HL
2644:	D655  EB      		EX	DE,HL		; Save up counter in DE
2645:	D656  CD44D2  		CALL	GETBIT		; Get bit from ALV buffer
2646:	D659  1F      		RRA			; Test if zero
2647:	D65A  300A    		JR	NC,GETFR3	; Yes then found empty block
2648:	D65C  E1      		POP	HL		; Get down/up counter
2649:	D65D  D1      		POP	DE
2650:	D65E  18D9    		JR	GETFR0		; And test next block
2651:			
2652:	D660  7A      	GETFR2:	LD	A,D		; Test if last block tested
2653:	D661  B3      		OR	E
2654:	D662  20D5    		JR	NZ,GETFR0	; No then test next block
2655:	D664  1807    		JR	WRITSG		; Continue with DE=0
2656:			
2657:	D666  37      	GETFR3:	SCF			; Set block number used
2658:	D667  17      		RLA			; Save bit
2659:	D668  CD68D2  		CALL	SETBT0		; Put bit in ALV buffer
2660:	D66B  D1      		POP	DE		; Get correct counter
2661:	D66C  E1      		POP	HL		; Restore stack pointer
2662:							; ..continue with (DE=block number)
2663:			
2664:	D66D  E1      	WRITSG:	POP	HL		; Get pointer to Block Number
2665:	D66E  7A      		LD	A,D		; Test if blocknumber = 0
2666:	D66F  B3      		OR	E
2667:	D670  287F    		JR	Z,WRITS8	; Yes then disk full error
2668:	D672  DDCB0EBE		RES	7,(IX+FCBMOD)	; Reset FCB/File Modified
2669:	D676  73      		LD	(HL),E		; Save blocknumber
2670:	D677  3A42CA  		LD	A,(MAXLEN+1)	; Get number of blocks
2671:	D67A  B7      		OR	A		; Is it < 256?
2672:	D67B  2802    		JR	Z,WRITS2	; ..Jump if so
2673:	D67D  23      		INC	HL		; Increment to MSB Block Number
2674:	D67E  72      		LD	(HL),D		; ..and save MSB block number
2675:	D67F  0E02    	WRITS2:	LD	C,2		; Set write new block flag
2676:	D681  3A3FCA  		LD	A,(NMASK)	; Get sector mask
2677:	D684  DDA620  		AND	(IX+NXTREC)	; Mask with record counter
2678:	D687  2802    		JR	Z,WRITSX	; Zero then Ok (at start new record)
2679:	D689  0E00    		LD	C,0		; Else clear new block flag
2680:	D68B  3A4BCA  	WRITSX:	LD	A,(FUNCT)	; Get function number
2681:	D68E  D628    		SUB	40		; Test if Write RR with zero fill
2682:	D690  2033    		JR	NZ,WRITS6	; No then jump
2683:	D692  D5      		PUSH	DE		; Save blocknumber
2684:	D693  2A34CA  		LD	HL,(DIRBUF)	; Use directory buffer for zero fill
2685:	D696  0680    		LD	B,128		; 128 bytes to clear
2686:	D698  77      	WRITS3:	LD	(HL),A		; Clear directory buffer
2687:	D699  23      		INC	HL		; Increment pointer
2688:	D69A  10FC    		DJNZ	WRITS3		; Clear all bytes
2689:	D69C  CDD7D0  		CALL	CALSEC		; Calculate sector number (128 bytes)
2690:	D69F  3A3FCA  		LD	A,(NMASK)	; Get sector mask
2691:	D6A2  47      		LD	B,A		; Copy it
2692:	D6A3  04      		INC	B		; Increment it to get number of writes
2693:	D6A4  2F      		CPL			; Complement sector mask
2694:	D6A5  A3      		AND	E		; Mask sector number
2695:	D6A6  5F      		LD	E,A		; And save it
2696:	D6A7  0E02    		LD	C,2		; Set write new block flag
2697:	D6A9  E5      	WRITS4:	PUSH	HL		; Save registers
2698:	D6AA  D5      		PUSH	DE
2699:	D6AB  C5      		PUSH	BC
2700:	D6AC  CD7AD0  		CALL	CALST		; Calculate sector/track
2701:	D6AF  CD3DD2  		CALL	DMADIR		; Set DMA directory buffer
2702:	D6B2  C1      		POP	BC		; Get write new block flag
2703:	D6B3  C5      		PUSH	BC		; Save it again
2704:	D6B4  CD9AD1  		CALL	WRITER		; Write record on disk
2705:	D6B7  C1      		POP	BC		; Restore registers
2706:	D6B8  D1      		POP	DE
2707:	D6B9  E1      		POP	HL
2708:	D6BA  0E00    		LD	C,0		; Clear write new block flag
2709:	D6BC  1C      		INC	E		; Increment sector number
2710:	D6BD  10EA    		DJNZ	WRITS4		; Write all blocks
2711:	D6BF  CD37D2  		CALL	STDMA		; Set user DMA address
2712:	D6C2  D1      		POP	DE		; Get Block Number
2713:	D6C3  0E00    	WRITS5:	LD	C,0		; Clear write new block flag
2714:	D6C5  DDCB0EBE	WRITS6:	RES	7,(IX+FCBMOD)	; Reset FCB/File Modified flag
2715:	D6C9  C5      		PUSH	BC		; Save it
2716:	D6CA  CDD7D0  		CALL	CALSEC		; Calculate sector number (128 bytes)
2717:	D6CD  CD7AD0  		CALL	CALST		; Calculate Sector/Track
2718:	D6D0  C1      		POP	BC		; Get write new block flag
2719:	D6D1  CD9AD1  		CALL	WRITER		; Write record on disk
2720:	D6D4  DD7E20  		LD	A,(IX+NXTREC)	; Get record counter
2721:	D6D7  DDBE0F  		CP	(IX+FCBREC)	; Compare with next record
2722:	D6DA  3808    		JR	C,WRITS7	; If less then jump
2723:	D6DC  3C      		INC	A		; Increment record count
2724:	D6DD  DD770F  		LD	(IX+FCBREC),A	; Save it on next record position
2725:	D6E0  DDCB0EBE		RES	7,(IX+FCBMOD)	; Reset FCB/File Modified flag
2726:	D6E4  3A4BCA  	WRITS7:	LD	A,(FUNCT)	; Get function number
2727:	D6E7  FE14    		CP	20		; (hfb)
2728:	D6E9  D8      		RET	C		; Return if < 20 (hfb)
2729:	D6EA  FE16    		CP	21+1		; (hfb)
2730:	D6EC  D0      		RET	NC		; Return if > 21 (hfb)
2731:	D6ED  DD3420  		INC	(IX+NXTREC)	; Increment record count
2732:	D6F0  C9      		RET			; And return to caller
2733:			
2734:	D6F1  3E02    	WRITS8:	LD	A,2		; Set disk full error
2735:	D6F3  C3BBCE  		JP	SAVEA		; And return to caller
2736:			
2737:			
2738:			; Load FCB for Random Read/Write
2739:			;  Exit : Zero Flag = 1 No Error
2740:			;		      0 Error Occured
2741:			
2742:	D6F6  324FCA  	LDFCB:	LD	(RDWR),A	; Save Read/Write flag
2743:	D6F9  DD7E21  		LD	A,(IX+33)	; Get first byte random record
2744:	D6FC  57      		LD	D,A		; Save it in D
2745:	D6FD  CBBA    		RES	7,D		; Reset MSB to get next record
2746:	D6FF  17      		RLA			; Shift MSB in carry
2747:	D700  DD7E22  		LD	A,(IX+34)	; Load next byte random record
2748:	D703  17      		RLA			; Shift Carry
2749:	D704  F5      		PUSH	AF		; Save it
2750:	D705  E61F    		AND	MAXEXT		; Mask next extent
2751:	D707  4F      		LD	C,A		; Save it in C
2752:	D708  F1      		POP	AF		; Get byte
2753:	D709  17      		RLA			; Shift 4 times
2754:	D70A  17      		RLA
2755:	D70B  17      		RLA
2756:	D70C  17      		RLA
2757:	D70D  E60F    		AND	0FH		; Mask it
2758:	D70F  47      		LD	B,A		; Save data module number
2759:	D710  DD7E23  		LD	A,(IX+35)	; Get next byte random record
2760:	D713  1E06    		LD	E,6		; Set random record to large flag
2761:	D715  FE04    		CP	4		; Test random record to large
2762:	D717  305C    		JR	NC,LDFCB8	; Yes then error
2763:	D719  07      		RLCA			; Shift 4 times
2764:	D71A  07      		RLCA
2765:	D71B  07      		RLCA
2766:	D71C  07      		RLCA
2767:	D71D  80      		ADD	A,B		; Add byte
2768:	D71E  47      		LD	B,A		; Save data module number in B
2769:	D71F  DD7220  		LD	(IX+NXTREC),D	; Set next record count
2770:	D722  DD560E  		LD	D,(IX+FCBMOD)	; Get data module number
2771:	D725  CB72    		BIT	6,D		; Test error random record
2772:	D727  200E    		JR	NZ,LDFCB0	; Yes then jump
2773:	D729  79      		LD	A,C		; Get new extent number
2774:	D72A  DDBE0C  		CP	(IX+FCBEXT)	; Compare with FCB
2775:	D72D  2008    		JR	NZ,LDFCB0	; Not equal then open next extent
2776:	D72F  78      		LD	A,B		; Get new data module number
2777:	D730  DDAE0E  		XOR	(IX+FCBMOD)	; Compare with data module number
2778:	D733  E63F    		AND	MAXMOD		; Mask it
2779:	D735  2837    		JR	Z,LDFCB6	; Equal then return
2780:	D737  CB7A    	LDFCB0:	BIT	7,D		; Test FCB modified (write)
2781:	D739  200F    		JR	NZ,LDFCB1	; No then jump
2782:	D73B  D5      		PUSH	DE		; Save registers
2783:	D73C  C5      		PUSH	BC
2784:	D73D  CDABD1  		CALL	CLOSE		; Close extent
2785:	D740  C1      		POP	BC		; Restore registers
2786:	D741  D1      		POP	DE
2787:	D742  1E03    		LD	E,3		; Set close error
2788:	D744  3A4CCA  		LD	A,(PEXIT)	; Get exit code
2789:	D747  3C      		INC	A
2790:	D748  2827    		JR	Z,LDFCB7	; Error then exit
2791:	D74A  CD9ED5  	LDFCB1:	CALL	SETDME		; Save Data Module and Extent
2792:	D74D  CDF1D2  		CALL	SEAR15		; Search next FCB
2793:	D750  3A4CCA  		LD	A,(PEXIT)	; Get error code
2794:	D753  3C      		INC	A
2795:	D754  2015    		JR	NZ,LDFCB5	; No error then exit
2796:	D756  3A4FCA  		LD	A,(RDWR)	; Get read/write flag
2797:	D759  1E04    		LD	E,4		; Set read empty record
2798:	D75B  3C      		INC	A
2799:	D75C  2013    		JR	NZ,LDFCB7	; Read then error
2800:	D75E  CD09D5  		CALL	MAKES		; Make new FCB
2801:	D761  1E05    		LD	E,5		; Set make error
2802:	D763  3A4CCA  		LD	A,(PEXIT)	; Get error code
2803:	D766  3C      		INC	A
2804:	D767  2808    		JR	Z,LDFCB7	; Error then exit
2805:	D769  1803    		JR	LDFCB6		; No error exit (zero set)
2806:			
2807:	D76B  CDC2D4  	LDFCB5:	CALL	OPENF0		; Open file
2808:	D76E  C382D5  	LDFCB6:	JP	OPENX6		; Set zero flag and clear error code
2809:			
2810:	D771  DD360EC0	LDFCB7:	LD	(IX+FCBMOD),0C0H ; Set random record error
2811:	D775  7B      	LDFCB8:	LD	A,E		; Get error code
2812:	D776  324CCA  		LD	(PEXIT),A	; And save it
2813:	D779  B7      		OR	A		; Clear zero flag
2814:	D77A  DDCB0EFE	SETB14:	SET	7,(IX+FCBMOD)	; (hfb) get FCB/File Not Modified
2815:	D77E  C9      		RET			; And return to caller
2816:			
2817:			; Calculate Random Record
2818:			;  Entry HL=Offset in FCB
2819:			;	 DE=FCB Pointer
2820:			;  Exit  D=LSB Random Record
2821:			;	 C=ISB Random Record
2822:			;	 B=MSB Random Record
2823:			
2824:	D77F  19      	CALRRC:	ADD	HL,DE		; Pointer to FCB+15 or FCB+32
2825:	D780  7E      		LD	A,(HL)		; Get record number
2826:	D781  210C00  		LD	HL,12		; Offset to extent number
2827:	D784  19      		ADD	HL,DE		; Get pointer to extent byte
2828:	D785  57      		LD	D,A		; Save record number
2829:	D786  7E      		LD	A,(HL)		; Get extent byte
2830:	D787  E61F    		AND	MAXEXT		; Mask it 000eeeee
2831:	D789  CB12    		RL	D		; Shift MSB in Carry Cy=R, d=rrrrrrr0
2832:	D78B  CE00    		ADC	A,0		; Add Carry 00xeeeex
2833:	D78D  1F      		RRA			; Shift 1 time (16 bits) 000xeeee
2834:	D78E  CB1A    		RR	D		; D=xrrrrrrr
2835:	D790  4F      		LD	C,A		; Save ISB
2836:	D791  23      		INC	HL		; Increment to data module number
2837:	D792  23      		INC	HL
2838:	D793  7E      		LD	A,(HL)		; Get data module number 00mmmmmm
2839:	D794  0F      		RRCA			; Divide module by 16
2840:	D795  0F      		RRCA
2841:	D796  0F      		RRCA
2842:	D797  0F      		RRCA
2843:	D798  F5      		PUSH	AF		; Save it mmmm00mm
2844:	D799  E603    		AND	03H		; Mask for maximum module
2845:	D79B  47      		LD	B,A		; Save it 000000mm
2846:	D79C  F1      		POP	AF		; Get LSB
2847:	D79D  E6F0    		AND	0F0H		; Mask it mmmm0000
2848:	D79F  81      		ADD	A,C		; Add with ISB mmmxeeee
2849:	D7A0  4F      		LD	C,A		; Save ISB
2850:	D7A1  D0      		RET	NC		; No carry then return
2851:	D7A2  04      		INC	B		; Increment MSB 000000mm
2852:	D7A3  C9      		RET			; And return to caller
2853:							; 000000mm mmmxeeee xrrrrrrr
2855:	FFFF          		  IF  ZS
2856:			;************************************************************************
2857:			;*	  U n i v e r s a l   T i m e / D a t e   S u p p o r t 	*
2858:			;************************************************************************
2859:			
2860:			; In order to provide time/date support for as many systems as possible,
2861:			; a set of universal routines are used.  These routines do not do the
2862:			; actual stamping, but provide all the data required to method specific
2863:			; programs to perform the needed services.  To use the DOS services, the
2864:			; external handler needs to tie itself into the Time/Date vector table
2865:			; in the ZSDOS configuration area.  The Get Stamp, Put Stamp, Stamp Last
2866:			; Access, Stamp Create, and Stamp Modify routines receive the following
2867:			; parameters in the Z80 registers:
2868:			;	A  = Offset to DIR entry [0,20H,40H,60H]
2869:			;	BC = Address of ZSDOS WRFCB routine
2870:			;	DE = Pointer to Directory Buffer
2871:			;	HL = DMA address
2872:			;	IX = Pointer to FCB passed to DOS
2873:			; The directory buffer contains the dir entry for the FCB passed to DOS,
2874:			; A contains the offset.  The disk has been tested for R/O on all calls
2875:			; except get stamp and is R/W.	If a CP/M+ style stamping is used, a simple
2876:			; call to the address passed in BC is used to update the disk after adding
2877:			; the time as required.  This call is ALWAYS required.	The routines may
2878:			; use AF,BC,DE, and HL without restoring them.	Four levels of stack are
2879:			; available on the DOS stack for use by the functions.	All routines must
2880:			; exit with a RET instruction, and A=1 if successful, A=0FFH if error.
2881:			
2882:			; Get/put Timestamps
2883:			
2884:	D7A4          	CMD102:
2885:	D7A4  CD1FCF  	CMD103:	CALL	SELDRV		; Select DU: from FCB
2886:	D7A7  CD19D1  		CALL	SRCT15		; Find the FCB
2887:	D7AA  2831    		JR	Z,DOTDER	; If not found
2888:	D7AC  2A1ECA  		LD	HL,(GETSTV)	; Get time stamp function address
2889:	D7AF  3A4BCA  		LD	A,(FUNCT)
2890:	D7B2  FE66    		CP	102		; Get stamp?
2891:	D7B4  280A    		JR	Z,DOTDR3	; Yes
2892:	D7B6  2A20CA  		LD	HL,(PUTSTV)	; Get address of set stamp routine
2893:							; ..fall thru to common code..
2894:			; Enter here for Stamp Last Access, Stamp Create, Stamp Modify
2895:			
2896:	D7B9  E5      	STAMPT:	PUSH	HL
2897:	FFFF          	IF	HASEDS
2898:	D7BA  CDE7D7  		CALL	CHKEDS		; Test for disk W/P and embedded DateStamper
2899:			ELSE
2901:			ENDIF
2902:	D7BD  E1      		POP	HL
2903:	D7BE  281D    		JR	Z,DOTDER	; No stamp if disk is W/P (or no EDS)
2904:			
2905:	D7C0  CDA6D5  	DOTDR3:	CALL	GETDME		; Get Data Module and Extent Number
2906:	D7C3  2018    		JR	NZ,DOTDER	; ..Quit if Not Extent 0 of Module 0
2907:	D7C5  3A56CA  		LD	A,(SECPNT)	; Offset to FCB in dirbuf
2908:	D7C8  ED5B34CA		LD	DE,(DIRBUF)	; Dir buffer pointer
2909:	D7CC  0117D2  		LD	BC,WRFCB	; Address of WRFCB routine
2910:	D7CF  E5      		PUSH	HL		; Save function vector
2911:	D7D0  2A2ECA  		LD	HL,(DMA)	; Put DMA in HL
2912:	D7D3  C9      		RET			; Then vector to routine
2913:			
2914:			; Time and Date Routines.  Like the date stamping routines, the user must
2915:			; supply the actual driver routines for time and date.	These routines are
2916:			; attached to ZSDOS via the vector table in the configuration area.  The
2917:			; routines are passed the address to Get/Put the Time and Date in the DE
2918:			; and IX registers.  The routines may use AF,BC, and D without restor-
2919:			; ing them.  Four levels of stack are available on the DOS stack for use
2920:			; by the the functions.  All routines must exit with a RET instruction,
2921:			; and A=1 if successful, A=0FFH if error.
2922:			; In order to better provide for internal DateStamper, the clock routines
2923:			; must save the value at DE+5 when called, and return this value to the
2924:			; DOS in the E register.  In addition, the HL register must be returned
2925:			; as the called DE value +5.
2926:			; The Time/Date string consists of 6 packed BCD digits arrayed as:
2927:			;	Byte	00 01 02 03 04 05
2928:			;		YY MM DD HH MM SS
2929:			
2930:			; Set Time/Date from user-supplied buffer string
2931:			
2932:	D7D4  0E01    	CMD99:	LD	C,1		; Set parameter to set time/date
2933:	D7D6  21      		DEFB	21H		; ..and fall thru to GSTD
2934:			
2935:			; Get Time/Date to string whose address is supplied by the user
2936:			
2937:	D7D7  0E00    	CMD98:	LD	C,0		; Set parameter to get time/date
2938:	D7D9  2A16CA  	GSTD:	LD	HL,(GSTIME)	; Get time/date get/set routine address
2939:	D7DC  E5      		PUSH	HL		; ..to stack for pseudo "Jump"
2940:	D7DD  F6FF    	DOTDER:	OR	0FFH		; Save 1 T state while setting flags
2941:	D7DF  C9      		RET			; Vector to service routine
2942:				  ENDIF		;Zs
2944:	0000          		  IF  NOT ZS
3143:				  ENDIF
3144:			
3145:			; Calculate checksum of 127 bytes addressed by HL.  Return with HL
3146:			; pointing to the 128th byte.
3147:			
3148:	D7E0  067F    	CKS127:	LD	B,127		; Test 1st 127 bytes
3149:	D7E2  86      	CKSLP:	ADD	A,(HL)		; Sum all bytes to A
3150:	D7E3  23      		INC	HL
3151:	D7E4  10FC    		DJNZ	CKSLP
3152:	D7E6  C9      		RET
3153:			
3154:			;;
3155:			;; This check for the presence od the DateStamper routine embedded in
3156:			;; RCP space...
3157:			;;
3158:	FFFF          	IF	HASEDS
3159:	D7E7  3A38E8  	CHKEDS:	LD	A,(ZDSSTPR)		; ptr to embedded based
3160:	D7EA  B7      		OR	A			; zero chk.
3161:	D7EB  C8      		RET	Z			; no text in place
3162:	D7EC  C3E5D2  		JP	CHKRO1			; ok test w/p
3163:			ENDIF
3164:			
3165:			
3166:			
3168:			;**************************************************************
3169:			;*	 Z S D O S     H i g h	   R A M     D a t a	      *
3170:			;**************************************************************
3171:			
3172:			; High RAM area.  These locations are not stored by an IOP or
3173:			; BackGrounder.
3174:			
3175:	D7EF          	CODEND:
3176:	0000          		  IF  ROM
3181:				  ELSE
3182:	FFFF          		    IF  ZS
3183:	0000          		      IF  $-ZSDOS GT 0DF1H
3185:				      ENDIF		;$-zsdos
3186:	D7F1          		ORG	ZSDOS+0DF1H		; Set here for Internal Path
3187:				    ELSE
3192:				    ENDIF		;Zs
3193:				  ENDIF			;Rom
3194:	D7F1          	HIRAM:
3195:	FFFF          		  IF  ZS
3196:	D7F1  0100    	IPATH:	DEFB	1,0		; Internal Path = Drive A, User 0
3197:	D7F3  00000000		DEFW	00,00		; ..two more blank entries
3198:	D7F7  00      		DEFB	0		; ...and ending Null
3199:	D7F8  0000    	TDFVCT:	DEFW	00		; Time and date file vector
3200:				  ELSE
3202:				  ENDIF		;Zs
3203:	D7FA  0000    	LOGIN:	DEFW	00		; Login vector
3204:	D7FC  0000    	DSKWP:	DEFW	00		; Disk write protect vector
3205:	D7FE  0000    	HDLOG:	DEFW	00		; Fixed disk login vector
3206:			
3207:	0000          		  IF  ROM
3209:				  ELSE
3210:	0002          	FREEMEM	EQU	HIRAM-CODEND
3211:				  ENDIF		;Rom
3212:			
3213:			; Variables for use with BGii
3214:			
3215:	0008          	BGLOWL	EQU	BGHIRAM-BGLORAM	   ; Size of Low RAM save
3216:	006D          	BGHIL	EQU	BGRAMTOP-BGHIRAM   ; Size of Hi RAM save
3217:			
3218:			; symbols...
3219:			wsym zsdos.sym
3220:			
3221:	D800          		END			; End program



Statistics:

   501	symbols
  3582	bytes



Symbol Table:

alv             ca3a     expath         =edf4+    retyp3          cc2b     
anddem          ce66     expaths        =   5     roatt          =   9     
arcatt         =   b     extfcb         =edd0+    rom            =   0     
arword          ca5d     extrabias      =1200     rubout         =  7f     
base           =   0+    extstk         =efd0+    savea           cebb     
bdlist         =d80f     false          =   0     savhl           cef3     
bdos           =ca06+    fcb0            ca2d     sdrvb           d04a     
bdosb          =ca00     fcbext         =   c     sdrvb0          d054     
bdread         =d827     fcbmod         =   e     sear12          d2ee     
bdvers         =  11     fcbrec         =   f     sear15          d2f1     
bgckdro         d2d8+    fcbusr         =   d     searc1          d32c     
bgconst         ccb7+    fcontp          ca28     searc2          d33a     
bghil          =  6d+    fcp            =ea00     searc3          d36b     
bghiram         ca2e     fcps           =   4     searc4          d378     
bgloram         ca26     ff             =   c+    searc5          d37a     
bglowl         =   8+    filcnt          ca54     searc6          d380     
bgptch0        =cc7c+    fillb0          d28b     searc7          d386     
bgptch1        =d608+    fillb1          d298     searc7a         d38c     
bgptch2        =d1a9+    fillb2          d2a9     searc8          d397     
bgramtop       =ca9b     fillbb          d283     searc9          d39d     
bgseldrv        cf1f+    filsz           d42b     search          d2f3     
bias           =8e00     filsz0          d435     searcn          d30a     
bioreas        = a00     findf           d457     searex          ca5a     
bios           =d800     findf0          d467     searnb          ca5b     
biostds        = 600     findf1          d477     searpu          ca51     
boot           =d800+    findf2          d488     searqu          ca50     
botdsk         =d836     findf3          d4a8     secpnt          ca56     
btime          =d833     flags           ca15     sectrn         =d830     
caldi0          d0f7     fldrv           ca4e     seg1           =e200     
caldir          d0f1     flgbits        =  6d     seg10          =ec00     
caldir1         d0f4+    freemem        =   2+    seg11          =ef00     
calne1          d59a     funct           ca4b     seg12          =efd0     
calnex          d585     gcons2          cccc     seg2           =ea00     
calrrc          d77f     getbit          d244     seg3           =ea00     
calsc0          d0df     getbt0          d25b     seg4           =ed00     
calsec          d0d7     getcdm          d047     seg5           =ed80     
calst           d07a     getch           cb75     seg6           =edd0     
calst0          d080     getdm           d0aa     seg7           =edf4     
calst1          d088     getdm4          d0c0     seg8           =edff     
calst2          d093     getdme          d5a6     seg9           =ee00     
ccp            =c200     getdmx          d0d4     seldk           cf81     
chkdir          d15a     getfr0          d639     seldk0          cf8a+    
chkdr1          d176     getfr1          d648     seldk2          cf94     
chkeds          d7e7     getfr2          d660     seldk3          cf71     
chkfr2          d2cf     getfr3          d666     seldk4          cfe6     
chkfr3          d2c4     getstv          ca1e     seldk5          cff9     
chkfr4          d2bf     gstd            d7d9+    seldr0          cf4e     
chkfro          d2ac     gstime          ca16     seldr1          cf2d     
chkro           d2d8     haseds         =ffff     seldrv          cf1f     
chkro1          d2e5     hdlog           d7fe     seldsk         =d81b     
ckrodi          d0ee     hiram           d7f1     setb14          d77a     
cks127          d7e0     hlorde          d058     setbit          d260     
ckslp           d7e2     home           =d818     setbt0          d268     
cksub           ce52     idisk1         =  24+    setcho         = 133     
cktdfo         = 13c     idisk2         =  24+    setdma         =d824     
close           d1ab     idisk3         =   1+    setdme          d59e     
close0          d1c5     idisk4         =   1+    setfct          d0fc     
close1          d1ce     initd2          d020     setlf0          d114     
close3          d1e5     initdr          cffc     setpsf          d4af     
close4          d1fa     intron         =   0+    setsec         =d821     
close6          d208     iop            =   0+    settrk         =d81e     
cmd100          cec2     iops           =   0     sfilro          ca0f     
cmd101          cebf     ipath           d7f1     shrhl3          d05f     
cmd102          d7a4     iuser1         =  24+    shrhlb          d061     
cmd103          d7a4     iuser2         =   f+    shsize         =  20     
cmd17a          ce83     iuser3         =  24+    shstk          =ed00+    
cmd17b          ce85     iuser4         =   f+    shstks         =   4     
cmd17c          ce88     ixp             ca36     slr            =ffff     
cmd19a          ceab     ixsave          ca99     spsave          ca61     
cmd98           d7d7     jsear8          d32a     srct15          d119     
cmd99           d7d4     jsetdme         d205     stampt          d7b9     
cmnd01          cb50     jzrbx           cbb3     start           ca06+    
cmnd06          cb5a     lastch          ca29     stbdsc          ca09     
cmnd07          cb91     ldfcb           d6f6     stcrv           ca1a     
cmnd08          cb8e     ldfcb0          d737     stdir           d068     
cmnd09          ccd5     ldfcb1          d74a     stdir1          d077+    
cmnd10          cb95     ldfcb5          d76b     stdir2          d076+    
cmnd11          ccb7     ldfcb6          d76e     stdma           d237     
cmnd12          cecf     ldfcb7          d771     stlav           ca18     
cmnd13          ce0a     ldfcb8          d775     stmpp2         =   0     
cmnd14          cf7a     ldrrc           cf15     stmpzs         =ffff     
cmnd15          d4b4     lf             =   a     stro            ca0d     
cmnd16          d1a8     listst         =d82d+    stsel           ca0b     
cmnd17          ce6e     login           d7fa     stupdv          ca1c     
cmnd18          ce95     make0           d52d     subext          ce4d     
cmnd19          cea5     makes           d509     subflg          ca57     
cmnd20          d5be     maxcmd         =  31     sysatt         =   a+    
cmnd21          d5ff     maxext         =  1f     tab            =   9     
cmnd22          d502     maxlen          ca41     tabcnt          ca26     
cmnd23          ceb0     maxmod         =  3f     tabcx1          ca27     
cmnd24          cee8     maxsec          ca3c     tdcksm         =  91+    
cmnd25          ceb8     mbadsc          cd0a     tdfvct          d7f8     
cmnd26          d233     mberr           cd27     temp0           ca32     
cmnd27          cee4     mbfunc          cd37     trans           ca30     
cmnd28          d103     mcrlf           cd49     true           =ffff     
cmnd29          cedc     mdrive          cd3d     tstfct          d11c     
cmnd30          cec7     mdskch          cd02     tstlf           d123     
cmnd31          ceec     mfile           cd40     unload          ca24+    
cmnd32          cefb     mfilro          cd1e     unlog           ce5d     
cmnd33          d5b4     mro             cd23     unroll         =ffff     
cmnd34          d5f4     msel            cd15     unwpt1          ce2c     
cmnd35          cf07     msize          =  3c     upath          =ffff     
cmnd36          cf0f     mv2dma          ce8e+    user            ca2a     
cmnd37          ce1c     nblock          ca3e     vcstat          d405+    
cmnd39          cee0     ncheck          ca47     vdel            d270+    
cmnd40          d5f4     ndir0           ca45     vdel1           d27e     
cmnd45          cef7     nextnd          ca40     vermaj         =   1     
cmnd47          cef0     nfiles          ca43     vermin         =   1     
cmnd48          ced8     nftrk           ca49     vers           =  16+    
codend          d7ef     nmask           ca3f     vrenam          d3da+    
comco1          d3c3     num             cced     wboot          =d803+    
comco2          d3cf     num1            ccef     wheel           ca13     
comcod          d3bd     num2            cd00     whladr         =edff     
conin          =d809     nwf12o         = 11f     whlatt         =   8     
conout         =d80c     nxtrec         =  20     wrcon           cc64     
const          =d806     openex          d551     wrcon0          cc68     
contc          =   3     openf0          d4c2     wrcon1          cc77     
conth          =   8     openf1          d4ef     wrcon2          cc93     
contp          =  10     openx0          d564+    wrcon3          ccad     
contr          =  12     openx2          d55f     wrcon4          ccb0     
conts          =  13     openx3          d577     wrctl           cc53     
contu          =  15     openx4          d57c     wrfcb           d217     
contx          =  18     openx5          d57f     writd1          d229+    
cr             =   d     openx6          d582     write          =d82a     
crout           ccd2     opnxck          d5e9     write0          d19d     
cstat           d402     path            ca11     writer          d19a     
cstat1          d40d     pathad         =d7f1     writes          d602     
cstat2          d422     pexit           ca4c     writs1          d637     
csv             ca38     pickey         =   0     writs2          d67f     
ctable          cae2     prdec           ccdf     writs3          d698     
ctlren         =ffff     psfatt         =   7     writs4          d6a9     
dcio1           cb71     pubatt         =   2+    writs5          d6c3     
dcio2           cb66     punch          =d812     writs6          d6c5     
dcopy           ca58     putch           cb54     writs7          d6e4     
defdrv          ca2b     putstv          ca20     writs8          d6f1     
delete          d26d     ramlow         =   0     writsa          d61e     
deval           ca5f     rcp            =e200+    writsb          d621     
dirbuf          ca34     rcps           =  10     writsg          d66d     
dma             ca2e     rdbuf1          cb9f     writsx          d68b     
dmadir          d23d     rdbuf2          cbb6+    z3cl           =ef00+    
dmadr0          d241     rdbuf3          cbf4     z3cls          =  d0     
doback          cbbe     rdbuf4          cc06     z3env          =ec00+    
dobak0          cbc1     rdbuf5          cc2e     z3envs         =   2     
dobak1          cbd2     rdbuf6          cc39     z3msg          =ed80+    
dobak2          cbd7     rdbufx          cc4e     z3ndir         =ee00+    
dobak5          cbdf     rddir           d130     z3ndirs        =  1c     
dosexit         cde6     rddir0          d14d+    z3rev          =  21+    
dosext0         cdf8     rdwr            ca4f     z3whl          =edff     
dotder          d7dd     reader         =d815     z80                0+    
dotdr3          d7c0     readr           d195     zas            =   0     
dpbof          =  3c+    reads           d5c1     zbufbas        =e200     
drive           ca2c     reads0          d5d1     zdpch1          cecf+    
dskwp           d7fc     reads1          d5d5     zdpch2         =d01d+    
dummy           cebe     reads2          d5d8     zdpch3         =d037+    
entry           ca9b     recdir          ca52     zdsstpr        =e838     
entry0          cad2     relog1          ce37     zdsstsz        = 1c8     
entry1          cad6     relog2          ce48+    zflopkg        = 200     
eralin          cbfc     renam           d3d7     ziopkg         =   0     
ermode          ca5c     renam1          d3f0     zrespkg        = 800     
error           cd4c     renam2          d3fa     zrl            =   0     
error0          cd91     resdsk         =   0     zs             =ffff     
error1          cd9a     resroom        = 400     zsdos          =ca00     
error2          cdab     resus1          cf60     zsdos11        =ffff     
error3          cdaf     resusr          cf5e     zsdoss          ca9b     
error4          cdc1     retcff          d57a     zstdovr        = 400     
error5          cdca     rety1a          cc1d     
error6          cdcf     retyp1          cc1a     
error7          cddd     retyp2          cc26     
