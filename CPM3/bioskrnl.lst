   1:			;
   2:			;=======================================================================
   3:			;
   4:			; CP/M 3 Z80 DarkStar (NE Z80) Porting
   5:			;
   6:			;=======================================================================
   7:			;;---------------------------------------------------------------------
   8:			;; Version      : 1.0 - 20140904
   9:			;; Assemble     : SLR z80asm
  10:			;; Revisions:
  11:			;; 20140904	- Code start
  12:			;;---------------------------------------------------------------------
  13:			
  14:			TITLE	'ROOT MODULE OF RELOCATABLE BIOS FOR CP/M 3.1'
  15:			
  16:			
  17:				.Z80
  18:			
  19:				; define logical values:
  20:				include	common.inc
**** common.inc ****
   1:			;
   2:			;=======================================================================
   3:			;
   4:			; CP/M 3 Z80 DarkStar (NE Z80) Porting
   5:			;
   6:			;=======================================================================
   7:			;;---------------------------------------------------------------------
   8:			;; Version      : 1.0 - 20140904
   9:			;; Assemble     : m80
  10:			;; Revisions:
  11:			;; 20140904	- Code start
  12:			;;---------------------------------------------------------------------
  13:			;
  14:			; Here just some common symbol...
  15:			;
  16:				; SYSBIOS equates
  17:				include	darkstar.equ
**** darkstar.equ ****
   1:			;****** Equ's file autogenerated by genequs ver: 1.0
   2:			;****** Input files:
   3:			;****** SysCommon.lst
   4:	FE77'         	TX0            	EQU	0FE77H
   5:	FDC4'         	FIN            	EQU	0FDC4H
   6:	FE79'         	TX01           	EQU	0FE79H
   7:	FD89'         	DLY1           	EQU	0FD89H
   8:	FD87'         	DLY2           	EQU	0FD87H
   9:	FDE1'         	FOUT           	EQU	0FDE1H
  10:	FE65'         	U1NUL          	EQU	0FE65H
  11:	FE25'         	U0ISR          	EQU	0FE25H
  12:	FE5B'         	U1ISR          	EQU	0FE5BH
  13:	FD85'         	DELAY          	EQU	0FD85H
  14:	FE50'         	UISRE          	EQU	0FE50H
  15:	FDB5'         	FSTAT          	EQU	0FDB5H
  16:	FE35'         	UISRI          	EQU	0FE35H
  17:	FE6F'         	DOSTX          	EQU	0FE6FH
  18:	FC4B'         	BBU1ST         	EQU	0FC4BH
  19:	FC45'         	BBU1RX         	EQU	0FC45H
  20:	FC3F'         	BBU1TX         	EQU	0FC3FH
  21:	FD29'         	BBEXEC         	EQU	0FD29H
  22:	FCFF'         	BBHDRD         	EQU	0FCFFH
  23:	FD6A'         	BBVOID         	EQU	0FD6AH
  24:	FE92'         	UASTKB         	EQU	0FE92H
  25:	FD6B'         	MMPMAP         	EQU	0FD6BH
  26:	FE0F'         	INTRDI         	EQU	0FE0FH
  27:	FC2D'         	SCONIN         	EQU	0FC2DH
  28:	FC15'         	VCONIN         	EQU	0FC15H
  29:	FCDB'         	BBDIV16        	EQU	0FCDBH
  30:	FCF9'         	BBHDWR         	EQU	0FCF9H
  31:	FD78'         	MMGETP         	EQU	0FD78H
  32:	FDFE'         	INTREN         	EQU	0FDFEH
  33:	FE85'         	RLDROM         	EQU	0FE85H
  34:	FCE1'         	BBMUL16        	EQU	0FCE1H
  35:	FC00'         	SYSCOM         	EQU	0FC00H
  36:	FE90'         	UASTAV         	EQU	0FE90H
  37:	FE19'         	SYTIMR         	EQU	0FE19H
  38:	FC33'         	SCONST         	EQU	0FC33H
  39:	FC1B'         	VCONST         	EQU	0FC1BH
  40:	FE6D'         	SRXRSM         	EQU	0FE6DH
  41:	FE69'         	SRXSTP         	EQU	0FE69H
  42:	FC39'         	BBU0INI        	EQU	0FC39H
  43:	FC51'         	BBU1INI        	EQU	0FC51H
  44:	FC87'         	BBFREAD        	EQU	0FC87H
  45:	FD23'         	BBEIDCK        	EQU	0FD23H
  46:	FD05'         	BBHDGEO        	EQU	0FD05H
  47:	FEC0'         	BBSTACK        	EQU	0FEC0H
  48:	FC81'         	BBFHOME        	EQU	0FC81H
  49:	FD94'         	BBCONIN        	EQU	0FD94H
  50:	FFF0'         	SINTVEC        	EQU	0FFF0H
  51:	FEC0'         	SYSCMLO        	EQU	0FEC0H
  52:	FE22'         	VOIDISR        	EQU	0FE22H
  53:	FC9F'         	BBSTTIM        	EQU	0FC9FH
  54:	FDAA'         	BBCONST        	EQU	0FDAAH
  55:	FC27'         	SCONOUT        	EQU	0FC27H
  56:	FC0F'         	VCONOUT        	EQU	0FC0FH
  57:	FCE7'         	BBOFFCAL       	EQU	0FCE7H
  58:	FC57'         	BBINICTC       	EQU	0FC57H
  59:	FE9C'         	BBSTBASE       	EQU	0FE9CH
  60:	FC5D'         	BBRESCTC       	EQU	0FC5DH
  61:	FCA5'         	BBRDTIME       	EQU	0FCA5H
  62:	FD5A'         	BBCALRET       	EQU	0FD5AH
  63:	FCB7'         	BBDMASET       	EQU	0FCB7H
  64:	FCBD'         	BBDSKSEL       	EQU	0FCBDH
  65:	FCED'         	BBHDINIT       	EQU	0FCEDH
  66:	FCB1'         	BBSECSET       	EQU	0FCB1H
  67:	FD0B'         	BBHDBOOT       	EQU	0FD0BH
  68:	FC69'         	BBUPLCHR       	EQU	0FC69H
  69:	FC99'         	BBPRNCHR       	EQU	0FC99H
  70:	FCC9'         	BBVCPMBT       	EQU	0FCC9H
  71:	FC93'         	BBFLOPIO       	EQU	0FC93H
  72:	FD1D'         	BBEPMNGR       	EQU	0FD1DH
  73:	FCCF'         	BBSIDSET       	EQU	0FCCFH
  74:	FD11'         	BBLDPART       	EQU	0FD11H
  75:	FC75'         	BBRDVDSK       	EQU	0FC75H
  76:	FC8D'         	BBFWRITE       	EQU	0FC8DH
  77:	FCC3'         	BBCPBOOT       	EQU	0FCC3H
  78:	FC21'         	BBCURSET       	EQU	0FC21H
  79:	FCAB'         	BBTRKSET       	EQU	0FCABH
  80:	FC7B'         	BBWRVDSK       	EQU	0FC7BH
  81:	FD9F'         	BBCONOUT       	EQU	0FD9FH
  82:	FCF3'         	BBDRIVEID      	EQU	0FCF3H
  83:	FC63'         	BBPSNDBLK      	EQU	0FC63H
  84:	FC03'         	BBCRTCINI      	EQU	0FC03H
  85:	FC6F'         	BBPRCVBLK      	EQU	0FC6FH
  86:	FC09'         	BBCRTFILL      	EQU	0FC09H
  87:	FCD5'         	BBFDRVSEL      	EQU	0FCD5H
  88:	FD17'         	BBDPRMSET      	EQU	0FD17H
  89:			;****** EOF ***
  90:			
**** common.inc ****
  18:			
  19:	FFFF'         	TRUE	EQU	-1
  20:	0000'         	FALSE	EQU	0
  21:			
  22:			
  23:				; determine if for bank select or not:
  24:	FFFF'         	BANKED	EQU	TRUE		;< ... BANKED VERSION
  25:	0000'         	ZPM3	EQU	FALSE		; ZPM3 build ?
  26:			
  27:				;
  28:				; some other equs...
  29:				;
  30:	000D'         	CR	EQU     0DH		; CARRIAGE RETURN
  31:	000A'         	LF	EQU     0AH		; LINE FEED;
  32:	000C'         	FF	EQU	0CH		; FORM FEED (clear screen)
  33:			
  34:			
  35:			;
  36:			; COMMON.ASM [EOF]
  37:			
**** bioskrnl.asm ****
  21:				include syshw.inc
**** syshw.inc ****
   1:			;
   2:			;=======================================================================
   3:			;
   4:			; Modular Z80 DarkStar (NE Z80) SysBios
   5:			;
   6:			;=======================================================================
   7:			;
   8:			; Original code:
   9:			; Z80 Nuova Elettronica Monitor 390 su eprom 2532 (4k)
  10:			;
  11:			; Disassembled and reconstructed by
  12:			; Piergiorgio Betti <pbetti@lpconsul.net> on 2005 01 26
  13:			;
  14:			; Latest non modular BIOS is DARKSTAR-MONITOR-0.9.0.asm
  15:			; dated 20140531
  16:			; - Following addition of MultiF-Board doing complete rewrite of the
  17:			;   monitor/BIOS has been started.
  18:			;   Major goals:
  19:			;   o Modularization: Now monitor can grow up to 256kb instead of 4kb
  20:			;     :-)
  21:			;   o Specialized images fitted in memory page (4kb) or multiples
  22:			;   o Full support for new hardware
  23:			;   o I/O rewrite for MODE 2 interrupts
  24:			;   Minor goals:
  25:			;   o Full code clean-up & reoarganization
  26:			; ---------------------------------------------------------------------
  27:			; Revisions:
  28:			; 20140905 - Modified hexadecimal constants to 0xxH format to be widely
  29:			;            accepted by different assemblers
  30:			; 20150714 - Modified to implement serial XON/XOFF and RTS/CTS
  31:			; ---------------------------------------------------------------------
  32:			
  33:			; ---------------------------------------------------------------------
  34:			; SYSBIOS
  35:			;
  36:			; This is the BIOS non-resident portion of the new (banked)
  37:			; BIOS/Monitor for the NE Z80 (aka DarkStar)
  38:			;
  39:			; ---------------------------------------------------------------------
  40:			;
  41:			; Full BIOS memory scheme:
  42:			;
  43:			;	+-----------------+
  44:			;	+    SysCommon    +   <-- Resident portion. Common to all images
  45:			;	+   FC00 - FFFF   +
  46:			;	+-----------------+
  47:			;	+-----------------+   +-----------------+   +-----------------+
  48:			;	+     SysBios     +   +   BootMonitor   +   +     [Other]     +
  49:			;	+   F000 - FBFF   +   +   F000 - FBFF   +   +   F000 - FBFF   +
  50:			;	+-----------------+   +-----------------+   +-----------------+
  51:			;
  52:			;	         ^                     ^                     ^
  53:			;	         |                     |                     |
  54:			;	         ---------------------------------------------
  55:			;	                      Variable section
  56:			;
  57:			; The above are always assembled at ORG F000 and linked and allocated
  58:			; in the EEPROM in this way:
  59:			;
  60:			;	+-----------------+
  61:			;	+    SysCommon    +
  62:			;	+   FC00 - FFFF   +
  63:			;	+     SysBios     +     <-- EEPROM page 1 ($C1000)
  64:			;	+   F000 - FBFF   +
  65:			;	+-----------------+
  66:			;	+-----------------+
  67:			;	+    SysCommon    +
  68:			;	+   FC00 - FFFF   +
  69:			;	+   BootMonitor   +     <-- EEPROM page 0 ($C0000)
  70:			;	+   F000 - FBFF   +
  71:			;	+-----------------+
  72:			;
  73:			; ---------------------------------------------------------------------
  74:			;
  75:			; Define which assembler we are using
  76:			;
  77:			
  78:			; PASMO	EQU	1
  79:	0001'         	MZMAC	EQU	1
  80:			; ZMAC	EQU	1			; ZMAC Z80 assembler, not Linux/Unix version
  81:			
  82:			; ... only one at a time can be active (1) ...
  83:			
  84:			;
  85:			; Monitor version numbers (major.minor)
  86:			;
  87:	0033'         	MONMAJ		EQU	'3'
  88:	0034'         	MONMIN		EQU	'4'
  89:			
  90:			;
  91:			; Buffers addresses labels
  92:			;
  93:			
  94:			; -- Global --
  95:	0003'         	IOBYTE		EQU	0003H		; byte: Intel IOBYTE (CP/M 2.2 only)
  96:	0004'         	CDISK		EQU	0004H		; byte: Last logged drive
  97:	0006'         	BTPASIZ		EQU	0006H		; word: size of tpa + 1
  98:			;
  99:			; -- Private --
 100:	000B'         	HMEMPAG		EQU	000BH		; byte: highest ram page
 101:	000C'         	BBCBANK		EQU	000CH		; byte: current bank
 102:	000D'         	BBCSTCK		EQU	000DH		; word: current stack
 103:					;
 104:	004F'         	PRVTOP		EQU	004FH		; top of private area storage
 105:	004F'         	COLBUF		EQU	PRVTOP		; byte:
 106:	004E'         	DSELBF		EQU	COLBUF-1	; byte: floppy drive select status
 107:								; - bits: 0 = drive 0
 108:								; - bits: 1 = drive 1
 109:								; - bits: 2 = drive 2
 110:								; - bits: 3 = drive 3
 111:								; - bits: 4 = unused
 112:								; - bits: 5 = head select
 113:								; - bits: 6 = motor on (disabled by jumper)
 114:								; - bits: 7 = unused
 115:	004D'         	KBDBYTE		EQU	DSELBF-1	; byte: store keyboard input
 116:	004C'         	MIOBYTE		EQU	KBDBYTE-1	; byte:
 117:								; - bits: 0: 0 = floppy write		1 = floppy read
 118:								;         1: 0 = no ctrl on keypress	1 = ctrl on keypress
 119:								;         2: 0 = scroll			1 = no scroll
 120:								;         3: 0 = accept lowercase	1 = convert to uppercase
 121:								;         4: 0 = destr. bkspace		1 = non destr. bkspace
 122:								;         5: 0 = console out		1 = serial out
 123:								;         6: 0 = disp. all chars	1 = obscure non punct.
 124:								;         7: 0 = ctrl chr set 1		1 = ctrl chr set 2
 125:	004B'         	TMPBYTE		EQU	MIOBYTE-1	; byte: transients flags
 126:								; - bits: 0: 0 = high in cursor addressing
 127:								;         1: 0 = ESC catched by ANSI driver
 128:								;         2: 0 = CSI catched by ANSI driver
 129:								;         3: 0 = Two byte code ESC seq. from serial
 130:								;         4: 0 = Plain serial i/o (disable ANSI driver)
 131:								;         5: 0 = store interrupt status (on/off)
 132:								;         6: 0 = floppy home on err	1 = no home on err
 133:								;         7: 0 = unlock LBA free addressing (unpartitioned)
 134:	004A'         	CURSSHP		EQU	TMPBYTE-1	; cursor shape
 135:	0048'         	CURPBUF		EQU	CURSSHP-2	; word: cursor position
 136:	0046'         	FTRKBUF		EQU	CURPBUF-2	; word: track # for i/o (0 - 65535)
 137:	0045'         	FDRVBUF		EQU	FTRKBUF-1	; byte: drive number for i/0 (0 - 15)
 138:	0043'         	FSECBUF		EQU	FDRVBUF-2	; word: sector # for i/o (1 .. 65535)
 139:	0041'         	FRDPBUF		EQU	FSECBUF-2	; word: dma address for i/o
 140:	003F'         	FSEKBUF		EQU	FRDPBUF-2	; word: current track number for drive A/B
 141:	003E'         	RAM3BUF		EQU	FSEKBUF-1	; byte:
 142:	003D'         	RAM2BUF		EQU	RAM3BUF-1	; byte:
 143:	003C'         	RAM1BUF		EQU	RAM2BUF-1	; byte:
 144:	003B'         	RAM0BUF		EQU	RAM1BUF-1	; byte:
 145:	003A'         	RST7SP3		EQU	003AH		; keep clear area of RST38 (RST7)
 146:	0039'         	RST7SP2		EQU	0039H
 147:	0038'         	RST7SP1		EQU	0038H
 148:	002F'         	RSRVBUF		EQU	RST7SP1-9	; free 9 byte buffer
 149:	002D'         	APPBUF		EQU	RSRVBUF-2	; word: generic buffer
 150:	002C'         	COPSYS		EQU	APPBUF-1	; Op system type for partition selection
 151:	002B'         	UART0BR		EQU	COPSYS-1	; UART 0 baudrate
 152:	002A'         	UART1BR		EQU	UART0BR-1	; UART 1 baudrate
 153:	0029'         	CTC0TC		EQU	UART1BR-1	; CTC channel 0 time constant
 154:	0028'         	CTC1TC		EQU	CTC0TC-1	; CTC channel 1 time constant
 155:	0027'         	TIMRCON		EQU	CTC1TC-1	; timer buf
 156:	0026'         	CNFBYTE		EQU	TIMRCON-1	; config byte
 157:								; - bits: 0: 0 = UART1 intr disabled	1 = RST8 redir UART1
 158:								;         1: 1 = XON/XOFF enabled on UART0
 159:								;         2: 1 = RTS/CTS enabled on UART0
 160:								;         3: 0 = unused/reserved
 161:								;         4: 0 = unused/reserved
 162:								;         5: 0 = unused/reserved
 163:								;         6: 0 = unused/reserved
 164:								;         7: 0 = unused/reserved
 165:	000F'         	FIFOSTO		EQU	000FH		; fifo queues storage start
 166:	0008'         	FIFSIZE		EQU	8		; fifo queue lenght
 167:	000B'         	FIFBLOK		EQU	11		; fifo queue size
 168:	000F'         	FIFOU0		EQU	FIFOSTO		; uart 0 queue (alternate console)
 169:	001A'         	FIFOKB		EQU	FIFOU0+FIFBLOK	; keyboard queue
 170:	0025'         	FIFOEND		EQU	FIFOKB+FIFBLOK	; fifo blocks end
 171:			;
 172:	3000'         	BLDOFFS		EQU	3000H		; place for disk bootloader
 173:			
 174:			;
 175:			; Some commodity equs
 176:			;
 177:	000D'         	CR		EQU	0DH		; ascii CR & LF
 178:	000A'         	LF		EQU	0AH
 179:	000C'         	FF		EQU	0CH		; FORM FEED (clear screen)
 180:	001B'         	ESC		EQU	1BH		; ESCape
 181:	0011'         	XONC		EQU	11H		; Xon
 182:	0013'         	XOFC		EQU	13H		; Xoff
 183:	FFFF'         	TRUE		EQU	-1
 184:	0000'         	FALSE		EQU	0
 185:	0100'         	TPA		EQU	0100H		; TPA base address (for CP/M)
 186:			
 187:			;
 188:			; Modules equs
 189:			;
 190:				; delay
 191:	00F6'         	MSCNT		EQU	246
 192:				; mmu
 193:	000D'         	MMUTSTPAGE	EQU	0DH		; logical page used for sizing
 194:	D000'         	MMUTSTADDR	EQU	MMUTSTPAGE<<12	; logical page used for sizing
 195:			
 196:			; Conventionally all bios/monitor images start at $F000.
 197:			; Except for special cases all code is copied to ram @ $F000.
 198:			; In this case eeprom page 0 is directly mapped into logical space
 199:			; by hardware so we can initialize the system at cold boot.
 200:			;
 201:			; We assume to initialize MMU as follow:
 202:			;
 203:			; +--------+
 204:			; |  F000  |	-> $C0000  eeprom page 0
 205:			; +--------+
 206:			; +--------+
 207:			; |  EFFF  |
 208:			; +--------+
 209:			;     ...       -> $00000 to $0EFFF ram
 210:			; +--------+
 211:			; |  0000  |
 212:			; +--------+
 213:			;
 214:			
 215:			
 216:			; include	modules/hwequs.inc.asm
 217:			; Hardware equates
 218:			; ---------------------------------------------------------------------
 219:			
 220:			; ---------------------------------------------------------------------
 221:			; LX529 VIDEO BOARD:
 222:			; ---------------------------------------------------------------------
 223:	0080'         	CRTBASE		EQU	80H
 224:				; RAM0 for ascii chars & semi6. Combined with RAM1 and RAM2 for graphics
 225:	0080'         	CRTRAM0DAT	EQU	CRTBASE		; RAM0 access: PIO0 port A data register
 226:	0082'         	CRTRAM0CNT	EQU	CRTBASE+2	; RAM0 access: PIO0 port A control register
 227:				; Printer port
 228:	0081'         	CRTPRNTDAT	EQU	CRTBASE+1	; PRINTER (output): PIO0 port B data register
 229:	0083'         	CRTPRNTCNT	EQU	CRTBASE+3	; PRINTER (output): PIO0 port B control register
 230:								; STROBE is generated by hardware
 231:				; RAM1 for graphics. (pixel index by RAM0+RAM1+RAM2)
 232:	0084'         	CRTRAM1DAT	EQU	CRTBASE+4	; RAM1 access: PIO1 port A data register
 233:	0086'         	CRTRAM1CNT	EQU	CRTBASE+6	; RAM1 access: PIO1 port A control register
 234:				; Keyboard port (negated). Bit 7 is for strobe
 235:	0085'         	CRTKEYBDAT	EQU	CRTBASE+5	; KEYBOARD (input): PIO1 port B data register
 236:	0087'         	CRTKEYBCNT	EQU	CRTBASE+7	; KEYBOARD (input): PIO1 port B control register
 237:	0007'         	KEYBSTRBBIT	EQU	7		; Strobe bit
 238:				; RAM2 for graphics. (pixel index by RAM0+RAM1+RAM2)
 239:	0088'         	CRTRAM2DAT	EQU	CRTBASE+8	; RAM2 access: PIO2 port A data register
 240:	008A'         	CRTRAM2CNT	EQU	CRTBASE+10	; RAM2 access: PIO2 port A control register
 241:				; Service/User port
 242:	0089'         	CRTSERVDAT	EQU	CRTBASE+9	; Service (i/o): PIO2 port B data register
 243:	008B'         	CRTSERVCNT	EQU	CRTBASE+11	; Service (i/o): PIO2 port B control register
 244:	0000'         	PRNTBUSYBIT	EQU	0		; Printer BUSY bit		(in)	1
 245:	0001'         	CRTWIDTHBIT	EQU	1		; Set 40/80 chars per line	(out)	0
 246:	0002'         	PIO2BIT2	EQU	2		; user 1 (input)		(in)	1
 247:	0003'         	PIO2BIT3	EQU	3		; user 2 (input)		(in)	1
 248:	0004'         	PIO2BIT4	EQU	4		; user 3 (input)		(in)	1
 249:	0005'         	CLKSCLK		EQU	5		; DS1320 clock line		(out)	0
 250:	0006'         	CLKIO		EQU	6		; DS1320 I/O line		(i/o)	1
 251:	0007'         	CLKRST		EQU	7		; DS1320 RST line		(out)	0
 252:				; normal set for PIO2 (msb) 01011101 (lsb) that is hex $5D
 253:								; Other bits available to user
 254:				; RAM3 control chars/graphics attributes
 255:	008E'         	CRTRAM3PORT	EQU	CRTBASE+14	; RAM3 port
 256:	0000'         	CRTBLINKBIT	EQU	0		; Blink
 257:	0001'         	CRTREVRSBIT	EQU	1		; Reverse
 258:	0002'         	CRTUNDERBIT	EQU	2		; Underline
 259:	0003'         	CRTHILITBIT	EQU	3		; Highlight
 260:	0004'         	CRTMODEBIT	EQU	4		; ASCII/GRAPHIC mode
 261:				; Beeper port
 262:	008F'         	CRTBEEPPORT	EQU	CRTBASE+15	; Beeper port
 263:				; 6545 CRT controller ports
 264:	008C'         	CRT6545ADST	EQU	CRTBASE+12	; Address & Status register
 265:	008D'         	CRT6545DATA	EQU	CRTBASE+13	; Data register
 266:				; Cursor modes
 267:	0040'         	BLISLOWBLOK	EQU	40H		; Blink, slow, block
 268:	004A'         	BLISLOWLINE	EQU	4AH		; Blink, slow, line
 269:	0060'         	BLIFASTBLOK	EQU	60H		; Blink, fast, block
 270:	006A'         	BLIFASTLINE	EQU	6AH		; Blink, fast, line
 271:	0020'         	CURSOROFF	EQU	20H		; Off
 272:	0000'         	FIXBLOCK	EQU	00H		; Fixed, block
 273:	000A'         	CURSORON	EQU	0AH		; On
 274:			
 275:			; ---------------------------------------------------------------------
 276:			; LX390 FDC CONTROLLER:
 277:			; ---------------------------------------------------------------------
 278:	00D0'         	FDCBASE		EQU	0D0H
 279:	00D0'         	FDCCMDSTATR	EQU	FDCBASE		; Command and status register
 280:	00D1'         	FDCTRAKREG	EQU	FDCBASE+1	; Track register
 281:	00D2'         	FDCSECTREG	EQU	FDCBASE+2	; Sector register
 282:	00D7'         	FDCDATAREG	EQU	FDCBASE+7	; Data register *** Verificare che sia $d7
 283:	00D6'         	FDCDRVRCNT	EQU	FDCBASE+6	; Driver select/control register
 284:			;
 285:	0007'         	FDCRESTC	EQU	00000111b	; 1771 restore (seek to trak 0) cmd
 286:	0017'         	FDCSEEKC	EQU	00010111b	; seek cmd
 287:	0088'         	FDCREADC	EQU	10001000b	; read cmd
 288:	00A8'         	FDCWRITC	EQU	10101000b	; write cmd
 289:	00D0'         	FDCRESET	EQU	11010000b	; fdc reset immediate cmd
 290:			;
 291:			; ---------------------------------------------------------------------
 292:			; LX389: PARALLEL INTERFACE
 293:			; ---------------------------------------------------------------------
 294:			; alternate printer port
 295:	0003'         	ALTPRNPRT	EQU	03H
 296:			;
 297:			; parallel port PC link
 298:	0003'         	PPDATAP		EQU	03H		; Data port
 299:	0002'         	PPCNTRP		EQU	02H		; Control port
 300:	0000'         	PPSTROB		EQU	0		; Strobe bit
 301:	0001'         	PPAKSTB		EQU	1		; Acknowledge/Stop bit
 302:			;
 303:	0000'         	PPDINI		EQU	00H		; 00000000 Dnl Init byte
 304:	0004'         	PPDRDY		EQU	04H		; 00000100 Dnl Ready
 305:	0006'         	PPDSTP		EQU	06H		; 00000110 Dnl Stop
 306:	0002'         	PPDOKG		EQU	02H		; 00000010 Dnl Ok Go
 307:	0001'         	PPUINI		EQU	01H		; 00000001 Upl Init byte
 308:	0005'         	PPURDY		EQU	05H		; 00000101 Upl Ready
 309:	0007'         	PPUACK		EQU	07H		; 00000111 Upl Acknowledge
 310:	0003'         	PPUOKG		EQU	03H		; 00000011 Upl Ok Go
 311:			;
 312:			; virtual disks (PC-linked over parallel port)
 313:	0000'         	VDRDSEC		EQU	0		; read sector command
 314:	0001'         	VDWRSEC		EQU	1		; write sector command
 315:	000A'         	VDBUFSZ		EQU	10		; 10 bytes block
 316:			; ---------------------------------------------------------------------
 317:			; MULTF-BOARD: MMU, IDE, SERIAL, CTC
 318:			; ---------------------------------------------------------------------
 319:			; -- I/O --
 320:	0020'         	MMUPORT		EQU	20H
 321:	0021'         	MENAPRT		EQU	21H
 322:			; -- Map --
 323:	00C0'         	EEPAGE0		EQU	0C0H		; page 0 of eeprom
 324:	F000'         	EEPSTA		EQU	0F000H		; eeprom location after MMU reset
 325:	00EF'         	MMTPAPAG	EQU	(EEPSTA>>8)-1	; TPA top page (256 bytes pages)
 326:	00FF'         	IMTPAG		EQU	0FFH		; eeprom page with image table
 327:	0400'         	IMTSIZ		EQU	1024		; size
 328:	E000'         	RAMTBL		EQU	0E000H		; ram table location
 329:	0030'         	TBLBLK		EQU	48		; block size
 330:	0014'         	MAXBLK		EQU	20		; max images
 331:	03C0'         	RTBSIZ		EQU	TBLBLK * MAXBLK	; real table size
 332:								; A table block is:
 333:	0008'         	TNAMELEN	EQU	8		;	name		: 8 bytes
 334:	0002'         	TPAGELEN	EQU	2		;	page offset	: 2 bytes
 335:	0004'         	TIADDRLEN	EQU	4		;	image address	: 4 bytes
 336:	0004'         	TSIZELEN	EQU	4		;	image size	: 4 bytes
 337:	0014'         	TDESCLEN	EQU	20		;	description	: 20 bytes
 338:			; -- IDE --
 339:	00E0'         	IDEPORTA	EQU	0E0H		; lower 8 bits of IDE interface
 340:	00E1'         	IDEPORTB	EQU	0E1H		; upper 8 bits of IDE interface
 341:	00E2'         	IDEPORTC	EQU	0E2H		; control lines for IDE interface
 342:	00E3'         	IDEPORTCTRL	EQU	0E3H		; 8255 configuration port
 343:			
 344:	0092'         	READCFG8255	EQU	10010010b	; Set 8255 IDEportC to output, IDEportA/B input
 345:	0080'         	WRITECFG8255	EQU	10000000b	; Set all three 8255 ports to output mode
 346:			;IDE control lines for use with IDEportC.
 347:	0001'         	IDEA0LINE	EQU	01H		; direct from 8255 to IDE interface
 348:	0002'         	IDEA1LINE	EQU	02H		; direct from 8255 to IDE interface
 349:	0004'         	IDEA2LINE	EQU	04H		; direct from 8255 to IDE interface
 350:	0008'         	IDECS0LINE	EQU	08H		; inverter between 8255 and IDE interface
 351:	0010'         	IDECS1LINE	EQU	10H		; inverter between 8255 and IDE interface
 352:	0020'         	IDEWRLINE	EQU	20H		; inverter between 8255 and IDE interface
 353:	0040'         	IDERDLINE	EQU	40H		; inverter between 8255 and IDE interface
 354:	0080'         	IDERSTLINE	EQU	80H		; inverter between 8255 and IDE interface
 355:			;Symbolic constants for the IDE Drive registers
 356:	0008'         	REGDATA		EQU	IDECS0LINE
 357:	0009'         	REGERR		EQU	IDECS0LINE + IDEA0LINE
 358:	000A'         	REGSECCNT	EQU	IDECS0LINE + IDEA1LINE
 359:	000B'         	REGSECTOR	EQU	IDECS0LINE + IDEA1LINE + IDEA0LINE
 360:	000C'         	REGCYLLSB	EQU	IDECS0LINE + IDEA2LINE
 361:	000D'         	REGCYLMSB	EQU	IDECS0LINE + IDEA2LINE + IDEA0LINE
 362:	000E'         	REGSHD		EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE		;(0EH)
 363:	000F'         	REGCOMMAND	EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE	;(0FH)
 364:	000F'         	REGSTATUS	EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE
 365:	0016'         	REGCONTROL	EQU	IDECS1LINE + IDEA2LINE + IDEA1LINE
 366:	0016'         	REGASTATUS	EQU	IDECS1LINE + IDEA2LINE + IDEA1LINE
 367:			;IDE Command Constants.
 368:	0010'         	CMDRECAL	EQU	010H
 369:	0020'         	CMDREAD		EQU	020H
 370:	0030'         	CMDWRITE	EQU	030H
 371:	0091'         	CMDINIT		EQU	091H
 372:	00EC'         	CMDID		EQU	0ECH
 373:	00E0'         	CMDSPINDOWN	EQU	0E0H
 374:	00E1'         	CMDSPINUP	EQU	0E1H
 375:			; -- 16C550 UARTS --
 376:	00C0'         	UART0BASE	EQU	0C0H		; Port base address for 0
 377:	00C8'         	UART1BASE	EQU	0C8H		; Port base address for 1
 378:	00C0'         	UART0		EQU	UART0BASE	; Select UART 0
 379:	00C8'         	UART1		EQU	UART1BASE	; Select UART 1
 380:	0000'         	R0RXTX		EQU	0		; (r/w) RXD/TXD Transmit/Receive Buffer
 381:	0000'         	R0BRDL		EQU	0		; (r/w) DLL  if bit 7 of LCR is set: Baud Rate Divisor LSB
 382:	0001'         	R1IER		EQU	1		; (r/w) IER - Interrupt Enable Register
 383:	0001'         	R1BRDM		EQU	1		; (r/w) DLM if bit 7 of LCR is set: Baud Rate Divisor MSB
 384:	0002'         	R2IIR		EQU	2		; (r)   IIR - Interrupt Identification Register
 385:	0002'         	R2FCR		EQU	2		; (w)   FCR - FIFO Control Register
 386:	0003'         	R3LCR		EQU	3		; (r/w) LCR - Line Control Register
 387:	0004'         	R4MCR		EQU	4		; (r/w) MCR - Modem Control Register
 388:	0005'         	R5LSR		EQU	5		; (r)   LSR - Line Status Register
 389:	0006'         	R6MSR		EQU	6		; (r)   MSR - Modem Status Register
 390:	0007'         	R7SPR		EQU	7		; (r/w) SPR - Scratch Pad Register
 391:				; speeds:
 392:	0060'         	UART1200	EQU	96		; = 1,843,200 / ( 16 x 1200 )
 393:	0030'         	UART2400	EQU	48		; = 1,843,200 / ( 16 x 2400 )
 394:	0018'         	UART4800	EQU	24		; = 1,843,200 / ( 16 x 4800 )
 395:	000C'         	UART9600	EQU	12		; = 1,843,200 / ( 16 x 9600 )
 396:	0006'         	UART19K2	EQU	06		; = 1,843,200 / ( 16 x 19,200 )
 397:	0003'         	UART38K4	EQU	03		; = 1,843,200 / ( 16 x 38,400 )
 398:	0002'         	UART57K6	EQU	02		; = 1,843,200 / ( 16 x 57,600 )
 399:	0001'         	UART115K2	EQU	01		; = 1,843,200 / ( 16 x 115,200 )
 400:			
 401:	0006'         	U0DEFSPEED	EQU	UART19K2	; UART 0 default speed
 402:	000C'         	U1DEFSPEED	EQU	UART9600	; UART 1 default speed
 403:			; -- Z80CTC --
 404:	00E8'         	CTCBASE		EQU	0E8H
 405:	00E8'         	CTCCHAN0	EQU	CTCBASE+0	; Channel 1 - Free
 406:	00E9'         	CTCCHAN1	EQU	CTCBASE+1	; Channel 2 - System Timer
 407:	00EA'         	CTCCHAN2	EQU	CTCBASE+2	; Channel 3 - UART 1 Interrupt
 408:	00EB'         	CTCCHAN3	EQU	CTCBASE+3	; Channel 4 - UART 0 Interrupt
 409:	0020'         	CTC0TCHI	EQU	32		; hi speed chan. 0 tc: 4Mhz / 256 / 32 = 488.28 Hz
 410:	0005'         	CTC1TC100HZ	EQU	5		; lo speed chan. 1 tc: 488.28 Hz / 5 = ~ 97.6 Hz
 411:	000A'         	CTC1TC50HZ	EQU	10		; lo speed chan. 1 tc: 488.28 Hz / 10 = ~ 48.8 Hz
 412:	0013'         	CTC1TC25HZ	EQU	19		; lo speed chan. 1 tc: 488.28 Hz / 19 = ~ 25 Hz
 413:	0030'         	CTC1TC10HZ	EQU	48		; lo speed chan. 1 tc: 488.28 Hz / 48 = ~ 10 Hz
 414:	00F4'         	CTC1TC2HZ	EQU	244		; lo speed chan. 1 tc: 488.28 Hz / 244 = ~ 2 Hz
 415:	0013'         	SYSHERTZ	EQU	CTC1TC25HZ	; System timer hertz
 416:			; -- EEPROM --
 417:	0001'         	EEP29EE		EQU	01H		; type 29EE020
 418:	0002'         	EEP29XE		EQU	02H		; type 29LE020 or 29VE020
 419:	0004'         	EEP29C		EQU	04H		; type 29C020
 420:	0008'         	EEPUNSUPP	EQU	08H		; unsupported
 421:	0010'         	EEPROGLOCK	EQU	10H		; programming locked
 422:				;
 423:	0080'         	EERINEPROM	EQU	80H		; tried to program eeprom running inside it
 424:			
 425:			;
 426:			; MMU organization
 427:			;
 428:			; MMU manage 16 4kb pages in Z80 address space (logical)
 429:			; It can assign any of 256 4k pages (physical) from its
 430:			; 1Mb address space.
 431:			;
 432:			; To load phisycal page XXh to logical page (in CPU address space) Y,
 433:			; you should consider that MMU is at a fixed address 20h and that
 434:			; logical 4K page Y is derived in the MMU by the usage of A12,A13,A14
 435:			; and A15 address lines during an I/O instruction.
 436:			;
 437:			; So to address phys. ram page 00h at the top of logical space page Fh
 438:			; you need to have Fh * on top address lines * because this address
 439:			; is the index to MMU page.
 440:			;
 441:			; So:
 442:			;
 443:			; 	LD	A,00h		<--- phis. page number	00xxxh (4k page)
 444:			; 	LD	B,F0h		<--- log. page number 	 Fxxxh (cpu page)
 445:			; 	LD	C,20h		<--- MMU I/O address
 446:			; 	OUT	(C),A
 447:			; 	RET
 448:			;
 449:			; The OUT instruction place:
 450:			; A on data lines D0-D7
 451:			; Fh (from B register) on A12-A15
 452:			; on port 20h (C register)
 453:			;
 454:			;
 455:			; Memory is organized as follow:
 456:			;
 457:			;	Slot 1	-> RAM	  -> 512k from 00000h to 7ffffh (mandatory)
 458:			;	Slot 2	-> RAM	  -> 128k from 80000h to 9ffffh (option 1)
 459:			;	Slot 2	-> RAM    -> 256k from 80000h to bffffh (option 2)
 460:			;	Slot 3	-> EEPROM -> 256k from c0000h to fffffh (mandatory)
 461:			;
 462:			
 463:			
 464:			;-------------------------------------
 465:			; Production / Testing
 466:			
 467:	FFFF'         	BBDEBUG	EQU	TRUE
 468:			
 469:			
 470:			;-------------------------------------
 471:			; Segments, pages locations
 472:			
 473:	FFFF'         	IF	BBDEBUG
 474:			
 475:	0004'         	BBIMGP	EQU	04H		; Image location (DEBUG)
 476:	000E'         	BBAPPP	EQU	0EH
 477:	000F'         	BBPAG	EQU	0FH		; Base page location
 478:			
 479:			ELSE
 485:			ENDIF
 486:			
 487:	000D'         	TRNPAG	EQU	0DH		; Page used for transient MMU ops
 488:	F000'         	BBBASE	EQU	BBPAG << 12	; non resident base address
 489:	FC00'         	BBCOMN	EQU	BBBASE + 0C00H	; resident portion address
 490:			
 491:	F000'         	SYSBASE EQU	BBBASE		; use this to have 60K TPA
 492:			; SYSBASE EQU	BBCOMN		; use this to have 63K TPA
 493:			
 494:			;-------------------------------------
**** bioskrnl.asm ****
  22:			
  23:	0000'         	LDRDBG	EQU	false
  24:			
  25:			
  26:			FTRACE	macro	p1
  27:				if ldrdbg
  28:				ld	(OLDSTACK),SP
  29:				ld	sp,NEWSTACK
  30:				push	af
  31:				push	bc
  32:				push	de
  33:				push	hl
  34:				call	inline
  35:				defb	p1,cr,lf,'$'
  36:			; 	ld	a,(wkp)
  37:			; 	or	a
  38:			; 	call	nz,bbconin
  39:			; 	call	bbconin
  40:				pop	hl
  41:				pop	de
  42:				pop	bc
  43:				pop	af
  44:				ld	sp,(OLDSTACK)
  45:				endif
  46:				endm
  47:			
  48:			HEX16	macro	p1,p2
  49:				if ldrdbg
  50:				ld	(OLDSTACK),SP
  51:				ld	sp,NEWSTACK
  52:				push	af
  53:				push	bc
  54:				push	de
  55:				push	hl
  56:				ld	a,p1
  57:				call	phex
  58:				ld	a,p2
  59:				call	phex
  60:				ld	c,CR
  61:				call	BBCONOUT
  62:				ld	c,LF
  63:				call	BBCONOUT
  64:				pop	hl
  65:				pop	de
  66:				pop	bc
  67:				pop	af
  68:				ld	sp,(OLDSTACK)
  69:				endif
  70:				endm
  71:			
  72:			HEX8	macro	p1
  73:				if ldrdbg
  74:				ld	(OLDSTACK),SP
  75:				ld	sp,NEWSTACK
  76:				push	af
  77:				push	bc
  78:				push	de
  79:				push	hl
  80:				ld	a,p1
  81:				call	phex
  82:				ld	c,CR
  83:				call	BBCONOUT
  84:				ld	c,LF
  85:				call	BBCONOUT
  86:				pop	hl
  87:				pop	de
  88:				pop	bc
  89:				pop	af
  90:				ld	sp,(OLDSTACK)
  91:				endif
  92:				endm
  93:			
  94:			;		  Copyright (C), 1982
  95:			;		 Digital Research, Inc
  96:			;		     P.O. Box 579
  97:			;		Pacific Grove, CA  93950
  98:			
  99:			;   This is the invariant portion of the modular BIOS and is
 100:			;	distributed as source for informational purposes only.
 101:			;	All desired modifications should be performed by
 102:			;	adding or changing externally defined modules.
 103:			;	This allows producing "standard" I/O modules that
 104:			;	can be combined to support a particular system
 105:			;	configuration.
 106:			;
 107:			;   Modified for faster character I/O by Udo Munk
 108:			
 109:	0007'         	BELL	EQU	7
 110:	0011'         	CTLQ	EQU	'Q'-'@'
 111:	0013'         	CTLS	EQU	'S'-'@'
 112:			
 113:	0100'         	CCP	EQU	0100H				; Console Command Processor gets loaded
 114:									; into the TPA
 115:			
 116:				CSEG					; GENCPM puts CSEG stuff in common memory
 117:			
 118:				; variables in system data page
 119:			
 120:				EXTRN	@COVEC,@CIVEC,@AOVEC		; I/O redirection vectors
 121:				EXTRN	@AIVEC,@LOVEC
 122:				EXTRN	@MXTPA				; addr of system entry point
 123:				EXTRN	@BNKBF				; 128 byte scratch buffer
 124:			
 125:				; initialization
 126:			
 127:				EXTRN	?INIT				; general initialization
 128:				EXTRN	?LDCCP,?RLCCP			; load & reload CCP for BOOT & WBOOT
 129:			
 130:				; user defined character I/O routines
 131:			
 132:				EXTRN	?CI,?CO,?CIST,?COST		; each take device in <B>
 133:				EXTRN	?CINIT				; (re)initialize device in <C>
 134:				EXTRN	@CTBL				; physical character device table
 135:			
 136:				; disk communication data items
 137:			
 138:				EXTRN	@DTBL				; table Of pointers to XDPHs
 139:				PUBLIC	@ADRV,@RDRV,@TRK,@SECT		; parameters for disk I/O
 140:				PUBLIC	@DMA,@DBNK,@CNT			;    ''       ''   ''  ''
 141:			
 142:				; memory control
 143:			
 144:				PUBLIC	@CBNK				; current bank
 145:				EXTRN	?XMOVE,?MOVE			; select move bank, and block move
 146:				EXTRN	?BANK				; select CPU bank
 147:			
 148:				; clock support
 149:			
 150:				EXTRN	ZDSTIME				; signal time operation
 151:			
 152:				; general utility routines
 153:			
 154:				PUBLIC	?PMSG,?PDEC			; print message, print number from 0 to 65535
 155:				PUBLIC	?PDERR				; print BIOS disk error message header
 156:			
 157:				include	modebaud.inc			; define mode bits
**** modebaud.inc ****
   1:				; equates for mode byte bit fields
   2:			
   3:	0001'         	mb$input		equ 00000001b	; device may do input
   4:	0002'         	mb$output		equ 00000010b	; device may do output
   5:	0003'         	mb$in$out		equ mb$input+mb$output
   6:			
   7:	0004'         	mb$soft$baud		equ 00000100b	; software selectable
   8:								; baud rates
   9:			
  10:	0008'         	mb$serial		equ 00001000b	; device may use protocol
  11:	0010'         	mb$xon$xoff		equ 00010000b	; XON/XOFF protocol
  12:								; enabled
  13:			
  14:	0000'         	baud$none		equ 0		; no baud rate associated
  15:								; with this device
  16:	0001'         	baud$50			equ 1		; 50 baud
  17:	0002'         	baud$75			equ 2		; 75 baud
  18:	0003'         	baud$110		equ 3		; 110 baud
  19:	0004'         	baud$134		equ 4		; 134.5 baud
  20:	0005'         	baud$150		equ 5		; 150 baud
  21:	0006'         	baud$300		equ 6		; 300 baud
  22:	0007'         	baud$600		equ 7		; 600 baud
  23:	0008'         	baud$1200		equ 8		; 1200 baud
  24:	0009'         	baud$1800		equ 9		; 1800 baud
  25:	000A'         	baud$2400		equ 10		; 2400 baud
  26:	000B'         	baud$3600		equ 11		; 3600 baud
  27:	000C'         	baud$4800		equ 12		; 4800 baud
  28:	000D'         	baud$7200		equ 13		; 7200 baud
  29:	000E'         	baud$9600		equ 14		; 9600 baud
  30:	000F'         	baud$19200		equ 15		; 19.2k baud
  31:			
  32:			
  33:			
**** bioskrnl.asm ****
 158:			
 159:				; External names for BIOS entry points
 160:			
 161:				PUBLIC	?BOOT,?WBOOT,?CONST,?CONIN,?CONO,?LIST,?AUXO,?AUXI
 162:				PUBLIC	?HOME,?SLDSK,?STTRK,?STSEC,?STDMA,?READ,?WRITE
 163:				PUBLIC	?LISTS,?SCTRN
 164:				PUBLIC	?CONOS,?AUXIS,?AUXOS,?DVTBL,?DEVIN,?DRTBL
 165:				PUBLIC	?MLTIO,?FLUSH,?MOV,?TIM,?BNKSL,?STBNK,?XMOV
 166:			
 167:				PUBLIC	@BIOS$STACK
 168:			
 169:				; BIOS Jump vector.
 170:			
 171:				; All BIOS routines are invoked by calling these
 172:				; entry points.
 173:			
 174:	0000' C30000  	?BOOT:	JP	BOOT			; initial entry on cold start
 175:	0003' C36C00  	?WBOOT:	JP	WBOOT			; reentry on program exit, warm start
 176:			
 177:	0006' C36D01  	?CONST:	JP	CONST			; return console input status
 178:	0009' C38601  	?CONIN:	JP	CONIN			; return console input character
 179:	000C' C3E200  	?CONO:	JP	CONOUT			; send console output character
 180:	000F' C3EC00  	?LIST:	JP	BLIST			; send list output character
 181:	0012' C3E700  	?AUXO:	JP	AUXOUT			; send auxiliary output character
 182:	0015' C38B01  	?AUXI:	JP	AUXIN			; return auxiliary input character
 183:			
 184:	0018' C37900  	?HOME:	JP	HOME			; set disks to logical home
 185:	001B' C34800  	?SLDSK:	JP	SELDSK			; select disk drive, return disk parameter info
 186:	001E' C37C00  	?STTRK:	JP	SETTRK			; set disk track
 187:	0021' C38400  	?STSEC:	JP	SETSEC			; set disk sector
 188:	0024' C3A000  	?STDMA:	JP	SETDMA			; set disk I/O memory address
 189:	0027' C3B900  	?READ:	JP	READ			; read physical block(s)
 190:	002A' C3CE00  	?WRITE:	JP	WRITE			; write physical block(s)
 191:			
 192:	002D' C30B01  	?LISTS:	JP	LISTST			; return list device status
 193:	0030' C3AE00  	?SCTRN:	JP	SECTRN			; translate logical to physical sector
 194:			
 195:	0033' C30101  	?CONOS:	JP	CONOST			; return console output status
 196:	0036' C37201  	?AUXIS:	JP	AUXIST			; return aux input status
 197:	0039' C30601  	?AUXOS:	JP	AUXOST			; return aux output status
 198:	003C' C3DA00  	?DVTBL:	JP	DEVTBL			; return address of device def table
 199:	003F' C30000  	?DEVIN:	JP	?CINIT			; change baud rate of device
 200:			
 201:	0042' C3DE00  	?DRTBL:	JP	GETDRV			; return address of disk drive  table
 202:	0045' C3EF00  	?MLTIO:	JP	MULTIO			; set multiple record count for disk I/O
 203:	0048' C3F300  	?FLUSH:	JP	FLUSH			; flush BIOS maintained disk caching
 204:			
 205:	004B' C30000  	?MOV:	JP	?MOVE			; block move memory to memory
 206:	004E' C30000  	?TIM:	JP	ZDSTIME			; Signal Time and Date operation
 207:	0051' C32002  	?BNKSL:	JP	BNKSEL			; select bank for code execution and default DMA
 208:	0054' C3AA00  	?STBNK:	JP	SETBNK			; select different bank for disk I/O DMA operation
 209:	0057' C30000  	?XMOV:	JP	?XMOVE			; set source and destination banks for one operation
 210:			
 211:	005A' C30000  		JP	0			; reserved for future expansion
 212:	005D' C30000  		JP	0			; reserved for future expansion
 213:	0060' C30000  		JP	0			; reserved for future expansion
 214:			
 215:			
 216:				; BOOT
 217:				;	Initial entry point for system startup.
 218:	FFFF'         		IF BANKED
 219:				DSEG				; this part can be banked
 220:				ENDIF
 221:			
 222:	0000"         	BOOT: ftrace "boot"
 222:	0000"         		if ldrdbg
 222:				endif
 222:	0000"         		endm
 222:			
 223:			; 	JP	$A000
 224:	0000" 06F0    		LD	B,BBPAG << 4		; ensure that sysbios base page ($BB)
 225:	0002" 0E20    		LD	C,MMUPORT		; is in place
 226:	0004" 3A0B00  		LD	A,(HMEMPAG)
 227:	0007" D604    		SUB	4
 228:	0009" ED79    		OUT	(C),A
 229:			
 230:	000B" 31DA00  		LD	SP,@BIOS$STACK
 231:	000E" 0E0F    		LD	C,15			; initialize all 16 character devices
 232:	0010"         	C$INIT$LOOP:
 233:	0010" C5      		PUSH	BC
 234:	0011" CD0000  		CALL	?CINIT
 235:	0014" C1      		POP	BC
 236:	0015" 0D      		DEC	C
 237:	0016" F21000  		JP	P,C$INIT$LOOP
 238:			
 239:	0019" CD0000  		CALL	?INIT			; perform any additional system initialization
 240:			
 241:	001C" 010010  		LD	BC,16*256+0
 242:	001F" 210000  		LD	HL,@DTBL		; init all 16 logical disk drives
 243:	0022"         	D$INIT$LOOP:
 244:	0022" C5      		PUSH	BC			; save remaining count and abs drive
 245:	0023" 5E      		LD	E,(HL)
 246:	0024" 23      		INC	HL
 247:	0025" 56      		LD	D,(HL)
 248:	0026" 23      		INC	HL			; grab @drv entry
 249:	0027" 7B      		LD	A,E
 250:	0028" B2      		OR	D
 251:	0029" 2815    		JR	Z,D$INIT$NEXT		; if null, no drive
 252:	002B" E5      		PUSH	HL			; save @drv pointer
 253:	002C" EB      		EX	DE,HL			; XDPH address in <HL>
 254:	002D" 2B      		DEC	HL
 255:	002E" 2B      		DEC	HL
 256:	002F" 7E      		LD	A,(HL)
 257:	0030" 323702  		LD	(@RDRV),A		; get relative drive code
 258:	0033" 79      		LD	A,C
 259:	0034" 323602  		LD	(@ADRV),A		; get absolute drive code
 260:	0037" 2B      		DEC	HL			; point to init pointer
 261:	0038" 56      		LD	D,(HL)
 262:	0039" 2B      		DEC	HL
 263:	003A" 5E      		LD	E,(HL)			; get init pointer
 264:	003B" EB      		EX	DE,HL
 265:	003C" CDA601  		CALL	IPCHL			; call init routine
 266:	003F" E1      		POP	HL			; recover @drv pointer
 267:	0040"         	D$INIT$NEXT:
 268:	0040" C1      		POP	BC			; recover counter and drive #
 269:	0041" 0C      		INC	C
 270:	0042" 05      		DEC	B
 271:	0043" 20DD    		JR	NZ,D$INIT$LOOP		; and loop for each drive
 272:			
 273:	0045" C36300  		JP	BOOT$1
 274:			
 275:				CSEG				; following in resident memory
 276:			
 277:	0063'         	BOOT$1:
 278:	0063' CD7800  		CALL	SETJUMPS
 279:	0066' CD0000  		CALL	?LDCCP			; fetch CCP for first time
 280:	0069' C30001  		JP	CCP
 281:			
 282:			
 283:				; WBOOT
 284:				;	Entry for system restarts.
 285:			
 286:	006C'         	WBOOT:	ftrace "WBOOT"
 286:	0000'         		if ldrdbg
 286:				endif
 286:	006C'         		endm
 286:			
 287:	006C' 31DA00  		LD	SP,@BIOS$STACK
 288:	006F' CD7800  		CALL	SETJUMPS		; initialize page zero
 289:	0072' CD0000  		CALL	?RLCCP			; reload CCP
 290:	0075' C30001  		JP	CCP			; then reset jmp vectors and exit to ccp
 291:			
 292:	0078'         	SETJUMPS:
 293:			
 294:	FFFF'         	    IF BANKED
 295:	0078' 3E00    		LD	A,0
 296:	007A' CD5100  		CALL	?BNKSL
 297:	007D' CD8500  		CALL	DOSETJMPS
 298:	0080' 3E01    		LD	A,1
 299:	0082' CD5100  		CALL	?BNKSL
 300:			    ENDIF
 301:			
 302:	0085'         	DOSETJMPS:
 303:	0085' 3EC3    		LD	A,0C3H			; jp opcode
 304:	0087' 320000  		LD	(0),A
 305:	008A' 320500  		LD	(5),A			; set up jumps in page zero
 306:	008D' 210300  		LD	HL,?WBOOT
 307:	0090' 220100  		LD	(1),HL			; bios warm start entry
 308:	0093' 2A0000  		LD	HL,(@MXTPA)
 309:	0096' 220600  		LD	(6),HL			; bdos system call entry
 310:	0099' C9      		RET
 311:			
 312:	009A'         		DS	64
 313:	00DA'         	@BIOS$STACK 	EQU	$
 314:			
 315:			
 316:				; DEVTBL
 317:				;	Return address of character device table
 318:			
 319:	00DA'         	DEVTBL:
 320:	00DA' 210000  		LD	HL,@CTBL
 321:	00DD' C9      		RET
 322:			
 323:			
 324:				; GETDRV
 325:				;	Return address of drive table
 326:			
 327:	00DE'         	GETDRV:
 328:	00DE' 210000  		LD	HL,@DTBL
 329:	00E1' C9      		RET
 330:			
 331:				; CONOUT
 332:				;	Console Output. Send character in <C>
 333:				;	to all selected devices
 334:			
 335:	00E2'         	CONOUT:
 336:	00E2' 2A0000  		LD	HL,(@COVEC)		; fetch console output bit vector
 337:	00E5' 1808    		JR	OUT$SCAN
 338:			
 339:			
 340:				; AUXOUT
 341:				;	Auxiliary Output. Send character in <C>
 342:				;	to all selected devices
 343:			
 344:	00E7'         	AUXOUT:	ftrace "AUXOUT"
 344:	0000'         		if ldrdbg
 344:				endif
 344:	00E7'         		endm
 344:			
 345:	00E7' 2A0000  		LD	HL,(@AOVEC)		; fetch aux output bit vector
 346:	00EA' 1803    		JR	OUT$SCAN
 347:			
 348:			
 349:				; BLIST
 350:				;	List Output. Send character in <C>
 351:				;	to all selected devices.
 352:			
 353:	00EC'         	BLIST:	ftrace "BLIST"
 353:	0000'         		if ldrdbg
 353:				endif
 353:	00EC'         		endm
 353:			
 354:	00EC' 2A0000  		LD	HL,(@LOVEC)		; fetch list output bit vector
 355:			
 356:	00EF'         	OUT$SCAN:
 357:	00EF' 0600    		LD	B,0			; start with device 0
 358:	00F1'         	CO$NEXT:
 359:	00F1' 29      		ADD	HL,HL			; shift out next bit
 360:	00F2' 3007    		JR	NC,NOT$OUT$DEVICE
 361:	00F4' E5      		PUSH	HL			; save the vector
 362:			; 	PUSH	BC			; save the count and character
 363:			;NO$OUT$READY:
 364:			;	CALL	COSTER
 365:			;	OR	A
 366:			;	JR	NZ,NO$OUT$READY
 367:			; 	POP	BC
 368:	00F5' C5      		PUSH	BC			; restore and resave the character and device
 369:	00F6' CD0000  		CALL	?CO			; if device selected, print it
 370:	00F9' C1      		POP	BC			; recover count and character
 371:	00FA' E1      		POP	HL			; recover the rest of the vector
 372:	00FB'         	NOT$OUT$DEVICE:
 373:	00FB' 04      		INC	B			; next device number
 374:	00FC' 7C      		LD	A,H
 375:	00FD' B5      		OR	L			; see if any devices left
 376:	00FE' 20F1    		JR	NZ,CO$NEXT		; and go find them...
 377:	0100' C9      		RET
 378:			
 379:			
 380:				; CONOST
 381:				;	Console Output Status. Return true if
 382:				;	all selected console output devices
 383:				;	are ready.
 384:			
 385:	0101'         	CONOST:
 386:	0101' 2A0000  		LD	HL,(@COVEC)		; get console output bit vector
 387:	0104' 1808    		JR	OST$SCAN
 388:			
 389:			
 390:				; AUXOST
 391:				;	Auxiliary Output Status. Return true if
 392:				;	all selected auxiliary output devices
 393:				;	are ready.
 394:			
 395:	0106'         	AUXOST:	ftrace "AUXOST"
 395:	0000'         		if ldrdbg
 395:				endif
 395:	0106'         		endm
 395:			
 396:	0106' 2A0000  		LD	HL,(@AOVEC)		; get aux output bit vector
 397:	0109' 1803    		JR	OST$SCAN
 398:			
 399:			
 400:				; LISTST
 401:				;	List Output Status. Return true if
 402:				;	all selected list output devices
 403:				;	are ready.
 404:			
 405:	010B'         	LISTST:	ftrace "LISTST"
 405:	0000'         		if ldrdbg
 405:				endif
 405:	010B'         		endm
 405:			
 406:	010B' 2A0000  		LD	HL,(@LOVEC)		; get list output bit vector
 407:			
 408:	010E'         	OST$SCAN:
 409:	010E' 0600    		LD	B,0			; start with device 0
 410:	0110'         	COS$NEXT:
 411:	0110' 29      		ADD	HL,HL			; check next bit
 412:	0111' E5      		PUSH	HL			; save the vector
 413:	0112' C5      		PUSH	BC			; save the count
 414:	0113' 3EFF    		LD	A,0FFH			; assume device ready
 415:	0115' DC2401  		CALL	C,COSTER		; check status for this device
 416:	0118' C1      		POP	BC			; recover count
 417:	0119' E1      		POP	HL			; recover bit vector
 418:	011A' B7      		OR	A			; see if device ready
 419:	011B' C8      		RET	Z			; if any not ready, return false
 420:	011C' 04      		INC	B			; drop device number
 421:	011D' 7C      		LD	A,H
 422:	011E' B5      		OR	L			; see if any more selected devices
 423:	011F' 20EF    		JR	NZ,COS$NEXT
 424:	0121' F6FF    		OR	0FFH			; all selected were ready, return true
 425:	0123' C9      		RET
 426:			
 427:	0124'         	COSTER:		; check for output device ready, including optional
 428:					;xon/xoff support
 429:	0124' 68      		LD	L,B
 430:	0125' 2600    		LD	H,0			; make device code 16 bits
 431:	0127' E5      		PUSH	HL			; save it in stack
 432:	0128' 29      		ADD	HL,HL
 433:	0129' 29      		ADD	HL,HL
 434:	012A' 29      		ADD	HL,HL			; create offset into device characteristics tbl
 435:	012B' 110600  		LD	DE,@CTBL+6
 436:	012E' 19      		ADD	HL,DE			; make address of mode byte
 437:	012F' 7E      		LD	A,(HL)
 438:	0130' E610    		AND	MB$XON$XOFF
 439:	0132' E1      		POP	HL			; recover console number in <HL>
 440:	0133' CA0000  		JP	Z,?COST			; not a xon device, go get output status direct
 441:	0136' 112602  		LD	DE,XOFFLIST
 442:	0139' 19      		ADD	HL,DE			; make pointer to proper xon/xoff flag
 443:	013A' CD5301  		CALL	CIST1			; see if this keyboard has character
 444:	013D' 7E      		LD	A,(HL)
 445:	013E' C46501  		CALL	NZ,CI1			; get flag or read key if any
 446:	0141' FE11    		CP	CTLQ
 447:	0143' 2002    		JR	NZ,NOT$Q		; if its a ctl-Q,
 448:	0145' 3EFF    		LD	A,0FFH			; set the flag ready
 449:	0147'         	NOT$Q:
 450:	0147' FE13    		CP	CTLS
 451:	0149' 2002    		JR	NZ,NOT$S		; if its a ctl-S,
 452:	014B' 3E00    		LD	A,00H			; clear the flag
 453:	014D'         	NOT$S:
 454:	014D' 77      		LD	(HL),A			; save the flag
 455:	014E' CD5C01  		CALL	COST1			; get the actual output status,
 456:	0151' A6      		AND	(HL)			; and mask with ctl-Q/ctl-S flag
 457:	0152' C9      		RET				; return this as the status
 458:			
 459:	0153'         	CIST1:		; get input status with <BC> and <HL> saved
 460:	0153' C5      		PUSH	BC
 461:	0154' E5      		PUSH	HL
 462:	0155' CD0000  		CALL	?CIST
 463:	0158' E1      		POP	HL
 464:	0159' C1      		POP	BC
 465:	015A' B7      		OR	A
 466:	015B' C9      		RET
 467:			
 468:	015C'         	COST1:		; get output status, saving <BC> & <HL>
 469:	015C' C5      		PUSH	BC
 470:	015D' E5      		PUSH	HL
 471:	015E' CD0000  		CALL	?COST
 472:	0161' E1      		POP	HL
 473:	0162' C1      		POP	BC
 474:	0163' B7      		OR	A
 475:	0164' C9      		RET
 476:			
 477:	0165'         	CI1:		; get input, saving <BC> & <HL>
 478:	0165' C5      		PUSH	BC
 479:	0166' E5      		PUSH	HL
 480:	0167' CD0000  		CALL	?CI
 481:	016A' E1      		POP	HL
 482:	016B' C1      		POP	BC
 483:	016C' C9      		RET
 484:			
 485:			
 486:				; CONST
 487:				;	Console Input Status. Return true if
 488:				;	any selected console input device
 489:				;	has an available character.
 490:			
 491:	016D'         	CONST:
 492:	016D' 2A0000  		LD	HL,(@CIVEC)		; get console input bit vector
 493:	0170' 1803    		JR	IST$SCAN
 494:			
 495:			
 496:				; AUXIST
 497:				;	Auxiliary Input Status. Return true if
 498:				;	any selected auxiliary input device
 499:				;	has an available character.
 500:			
 501:	0172'         	AUXIST:	ftrace "AUXIST"
 501:	0000'         		if ldrdbg
 501:				endif
 501:	0172'         		endm
 501:			
 502:	0172' 2A0000  		LD	HL,(@AIVEC)		; get aux input bit vector
 503:			
 504:	0175'         	IST$SCAN:
 505:	0175' 0600    		LD	B,0			; start with device 0
 506:	0177'         	CIS$NEXT:
 507:	0177' 29      		ADD	HL,HL			; check next bit
 508:	0178' 3E00    		LD	A,0			; assume device not ready
 509:	017A' DC5301  		CALL	C,CIST1			; check status for this device
 510:	017D' B7      		OR	A
 511:	017E' C0      		RET	NZ			; if any ready, return true
 512:	017F' 04      		INC	B			; next device number
 513:	0180' 7C      		LD	A,H
 514:	0181' B5      		OR	L			; see if any more selected devices
 515:	0182' 20F3    		JR	NZ,CIS$NEXT
 516:	0184' AF      		XOR	A			; all selected were not ready, return false
 517:	0185' C9      		RET
 518:			
 519:			
 520:				; CONIN
 521:				;	Console Input. Return character from first
 522:				;		ready console input device.
 523:			
 524:	0186'         	CONIN:
 525:	0186' 2A0000  		LD	HL,(@CIVEC)
 526:	0189' 1803    		JR	IN$SCAN
 527:			
 528:			
 529:				; AUXIN
 530:				;	Auxiliary Input. Return character from first
 531:				;	ready auxiliary input device.
 532:			
 533:	018B'         	AUXIN:	ftrace "AUXIN"
 533:	0000'         		if ldrdbg
 533:				endif
 533:	018B'         		endm
 533:			
 534:	018B' 2A0000  		LD	HL,(@AIVEC)
 535:			
 536:	018E'         	IN$SCAN:
 537:	018E' E5      		PUSH	HL			; save bit vector
 538:	018F' 0600    		LD	B,0
 539:	0191'         	CI$NEXT:
 540:	0191' 29      		ADD	HL,HL			; shift out next bit
 541:	0192' 3E00    		LD	A,0			; insure zero a (nonexistant device not ready).
 542:	0194' DC5301  		CALL	C,CIST1			; see if the device has a character
 543:	0197' B7      		OR	A
 544:	0198' 2008    		JR	NZ,CI$RDY		; this device has a character
 545:	019A' 04      		INC	B			; else, next device
 546:	019B' 7C      		LD	A,H
 547:	019C' B5      		OR	L			; see if any more devices
 548:	019D' 20F2    		JR	NZ,CI$NEXT		; go look at them
 549:	019F' E1      		POP	HL			; recover bit vector
 550:	01A0' 18EC    		JR	IN$SCAN			; loop til we find a character
 551:	01A2'         	CI$RDY:
 552:	01A2' E1      		POP	HL			; discard extra stack
 553:	01A3' C30000  		JP	?CI
 554:			
 555:			
 556:				; Utility Subroutines
 557:			
 558:	01A6'         	IPCHL:	ftrace "IPCHL"		; vectored CALL point
 558:	0000'         		if ldrdbg
 558:				endif
 558:	01A6'         		endm
 558:			
 559:	01A6'         		hex16	h,l
 559:	0000'         		if ldrdbg
 559:				endif
 559:	01A6'         		endm
 559:			
 560:	01A6' E9      		JP	(HL)
 561:			
 562:	01A7'         	?PMSG:		; print message @<HL> up to a null
 563:					; saves <BC> & <DE>
 564:	01A7' C5      		PUSH	BC
 565:	01A8' D5      		PUSH	DE
 566:	01A9'         	PMSG$LOOP:
 567:	01A9' 7E      		LD	A,(HL)
 568:	01AA' B7      		OR	A
 569:	01AB' 2809    		JR	Z,PMSG$EXIT
 570:	01AD' 4F      		LD	C,A
 571:	01AE' E5      		PUSH	HL
 572:	01AF' CD0C00  		CALL	?CONO
 573:	01B2' E1      		POP	HL
 574:	01B3' 23      		INC	HL
 575:	01B4' 18F3    		JR	PMSG$LOOP
 576:	01B6'         	PMSG$EXIT:
 577:	01B6' D1      		POP	DE
 578:	01B7' C1      		POP	BC
 579:	01B8' C9      		RET
 580:			
 581:			
 582:	01B9'         	?PDEC0:		; print binary number 0-65535 from <HL>, with leading zeros
 583:	01B9' 0601    		LD	B,1
 584:	01BB' 1802    		JR	PDEC1
 585:			
 586:	01BD'         	?PDEC:		; print binary number 0-65535 from <HL>, no leading zeros
 587:			
 588:	01BD' 0600    		LD	B,0
 589:	01BF' 11F0D8  	PDEC1:	LD	DE,-10000
 590:	01C2' CDDE01  		CALL	SBCNT
 591:	01C5' 1118FC  		LD	DE,-1000
 592:	01C8' CDDE01  		CALL	SBCNT
 593:	01CB' 119CFF  		LD	DE,-100
 594:	01CE' CDDE01  		CALL	SBCNT
 595:	01D1' 11F6FF  		LD	DE,-10
 596:	01D4' CDDE01  		CALL	SBCNT
 597:	01D7' 7D      		LD	A,L
 598:	01D8' C630    		ADD	A,'0'
 599:	01DA' 4F      		LD	C,A
 600:	01DB' C30C00  		JP	?CONO
 601:			
 602:	01DE' 0E2F    	SBCNT:	LD	C,'0'-1
 603:	01E0' 0C      	SB1:	INC	C
 604:	01E1' 19      		ADD	HL,DE
 605:	01E2' 38FC    		JR	C,SB1
 606:	01E4' ED52    		SBC	HL,DE
 607:	01E6' 78      		LD	A,B
 608:	01E7' B7      		OR	A
 609:	01E8' 2006    		JR	NZ,SB2
 610:	01EA' 79      		LD	A,C
 611:	01EB' FE30    		CP	'0'
 612:	01ED' C8      		RET	Z
 613:	01EE' 0601    		LD	B,1
 614:	01F0' E5      	SB2:	PUSH	HL
 615:	01F1' C5      		PUSH	BC
 616:	01F2' CD0C00  		CALL	?CONO
 617:	01F5' C1      		POP	BC
 618:	01F6' E1      		POP	HL
 619:	01F7' C9      		RET
 620:			
 621:	01F8'         	?PDERR:
 622:	01F8' 21F500  		LD	HL,DRIVE$MSG
 623:	01FB' CDA701  		CALL	?PMSG			; error header
 624:	01FE' 3A3602  		LD	A,(@ADRV)
 625:	0201' C641    		ADD	A,'A'
 626:	0203' 4F      		LD	C,A
 627:	0204' CD0C00  		CALL	?CONO			; drive code
 628:	0207' 210701  		LD	HL,TRACK$MSG
 629:	020A' CDA701  		CALL	?PMSG			; track header
 630:	020D' 2A3802  		LD	HL,(@TRK)
 631:	0210' CDB901  		CALL	?PDEC0			; track number
 632:	0213' 210C01  		LD	HL,SECTOR$MSG
 633:	0216' CDA701  		CALL	?PMSG			; sector header
 634:	0219' 2A3A02  		LD	HL,(@SECT)
 635:	021C' CDB901  		CALL	?PDEC0			; sector number
 636:	021F' C9      		RET
 637:			
 638:			
 639:				; BNKSEL
 640:				;	Bank Select. Select CPU bank for further execution.
 641:			
 642:	0220'         	BNKSEL:;	ftrace "BNKSEL"
 643:	0220' 324002  		LD	(@CBNK),A		; remember current bank
 644:	0223' C30000  		JP	?BANK			; and go exit through users
 645:								; physical bank select routine
 646:			
 647:	0226'         	XOFFLIST:
 648:	0226' FFFFFFFF		DB 	-1,-1,-1,-1,-1,-1,-1,-1	; ctl-s clears to zero
	      FFFFFFFF
 649:	022E' FFFFFFFF		DB	-1,-1,-1,-1,-1,-1,-1,-1
	      FFFFFFFF
 650:			
 651:	FFFF'         		IF BANKED
 652:				DSEG	; following resides in banked memory
 653:			        ENDIF
 654:			
 655:				; Disk I/O interface routines
 656:			
 657:			
 658:				; SELDSK
 659:				;	Select Disk Drive. Drive code in <C>.
 660:				;	Invoke login procedure for drive
 661:				;	if this is first select. Return
 662:				;	address of disk parameter header
 663:				;	in <HL>
 664:			
 665:	0048"         	SELDSK:	ftrace "SELDSK"
 665:	0000"         		if ldrdbg
 665:				endif
 665:	0048"         		endm
 665:			
 666:	0048"         		hex8	c
 666:	0000"         		if ldrdbg
 666:				endif
 666:	0048"         		endm
 666:			
 667:	0048" CDBDFC  		CALL	BBDSKSEL
 668:	004B" 79      		LD	A,C
 669:	004C" 323602  		LD	(@ADRV),A		; save drive select code
 670:	004F" 69      		LD	L,C
 671:	0050" 2600    		LD	H,0
 672:	0052" 29      		ADD	HL,HL			; create index from drive code
 673:	0053" 010000  		LD	BC,@DTBL
 674:	0056" 09      		ADD	HL,BC			; get pointer to dispatch table
 675:	0057" 7E      		LD	A,(HL)
 676:	0058" 23      		INC	HL
 677:	0059" 66      		LD	H,(HL)
 678:	005A" 6F      		LD	L,A			; point at disk descriptor
 679:	005B" B4      		OR	H
 680:	005C" C8      		RET	Z			; if no entry in table, no disk
 681:	005D" 7B      		LD	A,E
 682:	005E" E601    		AND	1
 683:	0060" 2016    		JR	NZ,NOT$FIRST$SELECT	; examine login bit
 684:	0062" E5      		PUSH	HL
 685:	0063" EB      		EX	DE,HL			; put pointer in stack & <DE>
 686:	0064" 21FEFF  		LD	HL,-2
 687:	0067" 19      		ADD	HL,DE
 688:	0068" 7E      		LD	A,(HL)
 689:	0069" 323702  		LD	(@RDRV),A		; get relative drive
 690:	006C" 21FAFF  		LD	HL,-6
 691:	006F" 19      		ADD	HL,DE			; find LOGIN addr
 692:	0070" 7E      		LD	A,(HL)
 693:	0071" 23      		INC	HL
 694:	0072" 66      		LD	H,(HL)
 695:	0073" 6F      		LD	L,A			; get address of LOGIN routine
 696:	0074" CDA601  		CALL	IPCHL			; call LOGIN
 697:	0077" E1      		POP	HL			; recover DPH pointer
 698:	0078"         	NOT$FIRST$SELECT:
 699:	0078" C9      		RET
 700:			
 701:			
 702:				; HOME
 703:				;	Home selected drive. Treated as SETTRK(0).
 704:			
 705:	0079"         	HOME:
 706:	0079" 010000  		LD	BC,0			; same as set track zero
 707:			
 708:			
 709:				; SETTRK
 710:				;	Set Track. Saves track address from <BC>
 711:				;	in @TRK for further operations.
 712:			
 713:	007C"         	SETTRK:	ftrace "SETTRK"
 713:	0000"         		if ldrdbg
 713:				endif
 713:	007C"         		endm
 713:			
 714:	007C" ED433802		LD	(@TRK),BC
 715:	0080" CDABFC  		CALL	BBTRKSET
 716:	0083"         		hex16	b,c
 716:	0000"         		if ldrdbg
 716:				endif
 716:	0083"         		endm
 716:			
 717:			; 	call	tdrv
 718:	0083" C9      		RET
 719:			
 720:			
 721:				; SETSEC
 722:				;	Set Sector. Saves sector number from <BC>
 723:				;	in @sect for further operations.
 724:			
 725:	0084"         	SETSEC:
 726:	0084"         		FTRACE "SETSEC"
 726:	0000"         		if ldrdbg
 726:				endif
 726:	0084"         		endm
 726:			
 727:	0084" 3A4500  		LD	A,(FDRVBUF)		; select...
 728:	0087" FE02    		CP	2			; is floppy ?
 729:	0089" FA9800  		JP	M,SECIN			; yes
 730:	008C" FE0E    		CP	14			; is IDE ?
 731:	008E" FA9800  		JP	M,SECIN			; yes
 732:	0091" FE0F    		CP	15			; virtual hd ?
 733:	0093" 2802    		JR	Z,SECADJ		; yes (P:)
 734:	0095" 1801    		JR	SECIN			; no, virtual floppy (O:)
 735:			
 736:	0097" 03      	SECADJ:	INC	BC
 737:	0098" ED433A02	SECIN:	LD	(@SECT),BC
 738:	009C"         		hex16	b,c
 738:	0000"         		if ldrdbg
 738:				endif
 738:	009C"         		endm
 738:			
 739:	009C" CDB1FC  		CALL	BBSECSET
 740:	009F" C9      		RET
 741:			
 742:			
 743:				; SETDMA
 744:				;	Set Disk Memory Address. Saves DMA address
 745:				;	from <BC> in @DMA and sets @DBNK to @CBNK
 746:				;	so that further disk operations take place
 747:				;	in current bank.
 748:			
 749:	00A0"         	SETDMA:	ftrace "SETDMA"
 749:	0000"         		if ldrdbg
 749:				endif
 749:	00A0"         		endm
 749:			
 750:	00A0" ED433C02		LD	(@DMA),BC
 751:	00A4" CDB7FC  		CALL	BBDMASET
 752:	00A7"         		hex16	b,c
 752:	0000"         		if ldrdbg
 752:				endif
 752:	00A7"         		endm
 752:			
 753:	00A7" 3A4002  		LD	A,(@CBNK)		; default DMA bank is current bank
 754:								; fall through to set DMA bank
 755:			
 756:			
 757:				; SETBNK
 758:				;	Set Disk Memory Bank. Saves bank number
 759:				;	in @DBNK for future disk data
 760:				;	transfers.
 761:			
 762:	00AA"         	SETBNK:	ftrace "SETBNK"
 762:	0000"         		if ldrdbg
 762:				endif
 762:	00AA"         		endm
 762:			
 763:	00AA"         		hex8	a
 763:	0000"         		if ldrdbg
 763:				endif
 763:	00AA"         		endm
 763:			
 764:	00AA" 323F02  		LD	(@DBNK),A
 765:	00AD" C9      		RET
 766:			
 767:			
 768:				; SECTRN
 769:				;	Sector Translate. Indexes skew table in <DE>
 770:				;	with sector in <BC>. Returns physical sector
 771:				;	in <HL>. If no skew table (<DE>=0) then
 772:				;	returns physical=logical.
 773:			
 774:	00AE"         	SECTRN:	ftrace "SECTRN"
 774:	0000"         		if ldrdbg
 774:				endif
 774:	00AE"         		endm
 774:			
 775:	00AE" 69      		LD	L,C
 776:	00AF" 60      		LD	H,B
 777:	00B0" 7A      		LD	A,D
 778:	00B1" B3      		OR	E
 779:	00B2" C8      		RET	Z
 780:	00B3" EB      		EX	DE,HL
 781:	00B4" 09      		ADD	HL,BC
 782:	00B5" 6E      		LD	L,(HL)
 783:	00B6" 2600    		LD	H,0
 784:	00B8" C9      		RET
 785:			
 786:			
 787:				; READ
 788:				;	Read physical record from currently selected drive.
 789:				;	Finds address of proper read routine from
 790:				;	extended disk parameter header (XDPH).
 791:			
 792:	00B9"         	READ:	ftrace "READ"
 792:	0000"         		if ldrdbg
 792:				endif
 792:	00B9"         		endm
 792:			
 793:	00B9" 2A3602  		LD	HL,(@ADRV)
 794:	00BC" 2600    		LD	H,0
 795:	00BE" 29      		ADD	HL,HL			; get drive code and double it
 796:	00BF" 110000  		LD	DE,@DTBL
 797:	00C2" 19      		ADD	HL,DE			; make address of table entry
 798:	00C3" 7E      		LD	A,(HL)
 799:	00C4" 23      		INC	HL
 800:	00C5" 66      		LD	H,(HL)
 801:	00C6" 6F      		LD	L,A 			; fetch table entry
 802:	00C7" E5      		PUSH	HL			; save address of table
 803:	00C8" 11F8FF  		LD	DE,-8
 804:	00CB" 19      		ADD	HL,DE			; point to read routine address
 805:	00CC" 1813    		JR	RW$COMMON		; use common code
 806:			
 807:			
 808:				; WRITE
 809:				;	Write physical sector from currently selected drive.
 810:				;	Finds address of proper write routine from
 811:				;	extended disk parameter header (XDPH).
 812:			
 813:	00CE"         	WRITE:	ftrace "WRITE"
 813:	0000"         		if ldrdbg
 813:				endif
 813:	00CE"         		endm
 813:			
 814:	00CE" 2A3602  		LD	HL,(@ADRV)
 815:	00D1" 2600    		LD	H,0
 816:	00D3" 29      		ADD	HL,HL			; get drive code and double it
 817:	00D4" 110000  		LD	DE,@DTBl
 818:	00D7" 19      		ADD	HL,DE			; make address of table entry
 819:	00D8" 7E      		LD	A,(HL)
 820:	00D9" 23      		INC	HL
 821:	00DA" 66      		LD	H,(HL)
 822:	00DB" 6F      		LD	L,A			; fetch table entry
 823:	00DC" E5      		PUSH	HL			; save address of table
 824:	00DD" 11F6FF  		LD	DE,-10
 825:	00E0" 19      		ADD	HL,DE			; point to write routine address
 826:			
 827:	00E1"         	RW$COMMON:
 828:	00E1" 7E      		LD	A,(HL)
 829:	00E2" 23      		INC	HL
 830:	00E3" 66      		LD	H,(HL)
 831:	00E4" 6F      		LD	L,A			; get address of routine
 832:	00E5" D1      		POP	DE			; recover address of table
 833:	00E6" 1B      		DEC	DE
 834:	00E7" 1B      		DEC	DE			; point to relative drive
 835:	00E8" 1A      		LD	A,(DE)
 836:	00E9" 323702  		LD	(@RDRV),A		; get relative drive code and post it
 837:	00EC" 13      		INC	DE
 838:	00ED" 13      		INC	DE			; point to DPH again
 839:	00EE"         		hex16	h,l
 839:	0000"         		if ldrdbg
 839:				endif
 839:	00EE"         		endm
 839:			
 840:	00EE" E9      		JP	(HL)			; leap to driver
 841:			
 842:			
 843:				; MULTIO
 844:				;	Set multiple sector count. Saves passed count in
 845:				;	@CNT
 846:			
 847:	00EF"         	MULTIO:	ftrace "MULTIO"
 847:	0000"         		if ldrdbg
 847:				endif
 847:	00EF"         		endm
 847:			
 848:	00EF" 323E02  		LD	(@CNT),A
 849:	00F2" C9      		RET
 850:			
 851:			
 852:				; FLUSH
 853:				;	BIOS deblocking buffer flush. Not implemented.
 854:			
 855:	00F3"         	FLUSH:
 856:	00F3" AF      		XOR	A
 857:	00F4" C9      		RET				; return with no error
 858:			
 859:				; error message components
 860:			
 861:	00F5" 0D0A0742	DRIVE$MSG:	DB	CR,LF,BELL,'BIOS Error on ',0
	      494F5320
	      4572726F
	      72206F6E
	      2000
 862:	0107" 3A20542D	TRACK$MSG:	DB	': T-',0
	      00
 863:	010C" 2C20532D	SECTOR$MSG:	DB	', S-',0
	      00
 864:			
 865:				; disk communication data items
 866:			
 867:				CSEG	; in common memory
 868:			
 869:	0236'         	@ADRV:	DS	1		; currently selected disk drive
 870:	0237'         	@RDRV:	DS	1		; controller relative disk drive
 871:	0238'         	@TRK:	DS	2		; current track number
 872:	023A'         	@SECT:	DS	2		; current sector number
 873:	023C'         	@DMA:	DS	2		; current DMA address
 874:	023E' 00      	@CNT:	DB	0		; record count for multisector transfer
 875:	023F' 00      	@DBNK:	DB	0		; bank for DMA operations
 876:			
 877:				CSEG	; common memory
 878:			
 879:	0240' 00      	@CBNK:	DB	0		; bank for processor operations
 880:			
 881:	0000'         		IF LDRDBG
1161:				ENDIF
1162:			
1163:	0241'         		END



Statistics:

     5	passes
     0	jr promotions
   512	symbols
     0	bytes

    25	macro calls
   683	macro bytes
     0	invented symbols



Symbol Table:

?auxi             15'     (public)
?auxis            36'     (public)
?auxo             12'     (public)
?auxos            39'     (public)
?bank              0      (extern)
?bnksl            51'     (public)
?boot              0'     (public)
?ci                0      (extern)
?cinit             0      (extern)
?cist              0      (extern)
?co                0      (extern)
?conin             9'     (public)
?cono              c'     (public)
?conos            33'     (public)
?const             6'     (public)
?cost              0      (extern)
?devin            3f'     (public)
?drtbl            42'     (public)
?dvtbl            3c'     (public)
?flush            48'     (public)
?home             18'     (public)
?init              0      (extern)
?ldccp             0      (extern)
?list              f'     (public)
?lists            2d'     (public)
?mltio            45'     (public)
?mov              4b'     (public)
?move              0      (extern)
?pdec            1bd'     (public)
?pdec0           1b9'    
?pderr           1f8'     (public)
?pmsg            1a7'     (public)
?read             27'     (public)
?rlccp             0      (extern)
?sctrn            30'     (public)
?sldsk            1b'     (public)
?stbnk            54'     (public)
?stdma            24'     (public)
?stsec            21'     (public)
?sttrk            1e'     (public)
?tim              4e'     (public)
?wboot             3'     (public)
?write            2a'     (public)
?xmov             57'     (public)
?xmove             0      (extern)
@adrv            236'     (public)
@aivec             0      (extern)
@aovec             0      (extern)
@bios$stack    =  da'     (public)
@bnkbf             0      (extern)
@cbnk            240'     (public)
@civec             0      (extern)
@cnt             23e'     (public)
@covec             0      (extern)
@ctbl              0      (extern)
@dbnk            23f'     (public)
@dma             23c'     (public)
@dtbl              0      (extern)
@lovec             0      (extern)
@mxtpa             0      (extern)
@rdrv            237'     (public)
@sect            23a'     (public)
@trk             238'     (public)
altprnprt      =   3     
appbuf         =  2d     
auxin            18b'    
auxist           172'    
auxost           106'    
auxout            e7'    
banked         =ffffffff 
baud$110       =   3     
baud$1200      =   8     
baud$134       =   4     
baud$150       =   5     
baud$1800      =   9     
baud$19200     =   f     
baud$2400      =   a     
baud$300       =   6     
baud$3600      =   b     
baud$4800      =   c     
baud$50        =   1     
baud$600       =   7     
baud$7200      =   d     
baud$75        =   2     
baud$9600      =   e     
baud$none      =   0     
bbappp         =   e     
bbbase         =f000     
bbcalret       =fd5a     
bbcbank        =   c     
bbcomn         =fc00     
bbconin        =fd94     
bbconout       =fd9f     
bbconst        =fdaa     
bbcpboot       =fcc3     
bbcrtcini      =fc03     
bbcrtfill      =fc09     
bbcstck        =   d     
bbcurset       =fc21     
bbdebug        =ffffffff 
bbdiv16        =fcdb     
bbdmaset       =fcb7     
bbdprmset      =fd17     
bbdriveid      =fcf3     
bbdsksel       =fcbd     
bbeidck        =fd23     
bbepmngr       =fd1d     
bbexec         =fd29     
bbfdrvsel      =fcd5     
bbfhome        =fc81     
bbflopio       =fc93     
bbfread        =fc87     
bbfwrite       =fc8d     
bbhdboot       =fd0b     
bbhdgeo        =fd05     
bbhdinit       =fced     
bbhdrd         =fcff     
bbhdwr         =fcf9     
bbimgp         =   4     
bbinictc       =fc57     
bbldpart       =fd11     
bbmul16        =fce1     
bboffcal       =fce7     
bbpag          =   f     
bbprcvblk      =fc6f     
bbprnchr       =fc99     
bbpsndblk      =fc63     
bbrdtime       =fca5     
bbrdvdsk       =fc75     
bbresctc       =fc5d     
bbsecset       =fcb1     
bbsidset       =fccf     
bbstack        =fec0     
bbstbase       =fe9c     
bbsttim        =fc9f     
bbtrkset       =fcab     
bbu0ini        =fc39     
bbu1ini        =fc51     
bbu1rx         =fc45     
bbu1st         =fc4b     
bbu1tx         =fc3f     
bbuplchr       =fc69     
bbvcpmbt       =fcc9     
bbvoid         =fd6a     
bbwrvdsk       =fc7b     
bell           =   7     
bldoffs        =3000     
blifastblok    =  60     
blifastline    =  6a     
blislowblok    =  40     
blislowline    =  4a     
blist             ec'    
bnksel           220'    
boot               0"    
boot$1            63'    
btpasiz        =   6     
c$init$loop       10"    
ccp            = 100     
cdisk          =   4     
ci$next          191'    
ci$rdy           1a2'    
ci1              165'    
cis$next         177'    
cist1            153'    
clkio          =   6     
clkrst         =   7     
clksclk        =   5     
cmdid          =  ec     
cmdinit        =  91     
cmdread        =  20     
cmdrecal       =  10     
cmdspindown    =  e0     
cmdspinup      =  e1     
cmdwrite       =  30     
cnfbyte        =  26     
co$next           f1'    
colbuf         =  4f     
conin            186'    
conost           101'    
conout            e2'    
const            16d'    
copsys         =  2c     
cos$next         110'    
cost1            15c'    
coster           124'    
cr             =   d     
crt6545adst    =  8c     
crt6545data    =  8d     
crtbase        =  80     
crtbeepport    =  8f     
crtblinkbit    =   0     
crthilitbit    =   3     
crtkeybcnt     =  87     
crtkeybdat     =  85     
crtmodebit     =   4     
crtprntcnt     =  83     
crtprntdat     =  81     
crtram0cnt     =  82     
crtram0dat     =  80     
crtram1cnt     =  86     
crtram1dat     =  84     
crtram2cnt     =  8a     
crtram2dat     =  88     
crtram3port    =  8e     
crtrevrsbit    =   1     
crtservcnt     =  8b     
crtservdat     =  89     
crtunderbit    =   2     
crtwidthbit    =   1     
ctc0tc         =  29     
ctc0tchi       =  20     
ctc1tc         =  28     
ctc1tc100hz    =   5     
ctc1tc10hz     =  30     
ctc1tc25hz     =  13     
ctc1tc2hz      =  f4     
ctc1tc50hz     =   a     
ctcbase        =  e8     
ctcchan0       =  e8     
ctcchan1       =  e9     
ctcchan2       =  ea     
ctcchan3       =  eb     
ctlq           =  11     
ctls           =  13     
curpbuf        =  48     
cursoroff      =  20     
cursoron       =   a     
cursshp        =  4a     
d$init$loop       22"    
d$init$next       40"    
delay          =fd85     
devtbl            da'    
dly1           =fd89     
dly2           =fd87     
dosetjmps         85'    
dostx          =fe6f     
drive$msg         f5"    
dselbf         =  4e     
eep29c         =   4     
eep29ee        =   1     
eep29xe        =   2     
eepage0        =  c0     
eeproglock     =  10     
eepsta         =f000     
eepunsupp      =   8     
eerineprom     =  80     
esc            =  1b     
false          =   0     
fdcbase        =  d0     
fdccmdstatr    =  d0     
fdcdatareg     =  d7     
fdcdrvrcnt     =  d6     
fdcreadc       =  88     
fdcreset       =  d0     
fdcrestc       =   7     
fdcsectreg     =  d2     
fdcseekc       =  17     
fdctrakreg     =  d1     
fdcwritc       =  a8     
fdrvbuf        =  45     
ff             =   c     
fifblok        =   b     
fifoend        =  25     
fifokb         =  1a     
fifosto        =   f     
fifou0         =   f     
fifsize        =   8     
fin            =fdc4     
fixblock       =   0     
flush             f3"    
fout           =fde1     
frdpbuf        =  41     
fsecbuf        =  43     
fsekbuf        =  3f     
fstat          =fdb5     
ftrace             0     
ftrkbuf        =  46     
getdrv            de'    
hex16             eb     
hex8             1d5     
hmempag        =   b     
home              79"    
idea0line      =   1     
idea1line      =   2     
idea2line      =   4     
idecs0line     =   8     
idecs1line     =  10     
ideporta       =  e0     
ideportb       =  e1     
ideportc       =  e2     
ideportctrl    =  e3     
iderdline      =  40     
iderstline     =  80     
idewrline      =  20     
imtpag         =  ff     
imtsiz         = 400     
in$scan          18e'    
intrdi         =fe0f     
intren         =fdfe     
iobyte         =   3     
ipchl            1a6'    
ist$scan         175'    
kbdbyte        =  4d     
keybstrbbit    =   7     
ldrdbg         =   0     
lf             =   a     
listst           10b'    
maxblk         =  14     
mb$in$out      =   3     
mb$input       =   1     
mb$output      =   2     
mb$serial      =   8     
mb$soft$baud   =   4     
mb$xon$xoff    =  10     
menaprt        =  21     
miobyte        =  4c     
mmgetp         =fd78     
mmpmap         =fd6b     
mmtpapag       =  ef     
mmuport        =  20     
mmutstaddr     =d000     
mmutstpage     =   d     
monmaj         =  33     
monmin         =  34     
mscnt          =  f6     
multio            ef"    
mzmac          =   1     
not$first$select   78"    
not$out$device    fb'    
not$q            147'    
not$s            14d'    
ost$scan         10e'    
out$scan          ef'    
pdec1            1bf'    
pio2bit2       =   2     
pio2bit3       =   3     
pio2bit4       =   4     
pmsg$exit        1b6'    
pmsg$loop        1a9'    
ppakstb        =   1     
ppcntrp        =   2     
ppdatap        =   3     
ppdini         =   0     
ppdokg         =   2     
ppdrdy         =   4     
ppdstp         =   6     
ppstrob        =   0     
ppuack         =   7     
ppuini         =   1     
ppuokg         =   3     
ppurdy         =   5     
prntbusybit    =   0     
prvtop         =  4f     
r0brdl         =   0     
r0rxtx         =   0     
r1brdm         =   1     
r1ier          =   1     
r2fcr          =   2     
r2iir          =   2     
r3lcr          =   3     
r4mcr          =   4     
r5lsr          =   5     
r6msr          =   6     
r7spr          =   7     
ram0buf        =  3b     
ram1buf        =  3c     
ram2buf        =  3d     
ram3buf        =  3e     
ramtbl         =e000     
read              b9"    
readcfg8255    =  92     
regastatus     =  16     
regcommand     =   f     
regcontrol     =  16     
regcyllsb      =   c     
regcylmsb      =   d     
regdata        =   8     
regerr         =   9     
regseccnt      =   a     
regsector      =   b     
regshd         =   e     
regstatus      =   f     
rldrom         =fe85     
rsrvbuf        =  2f     
rst7sp1        =  38     
rst7sp2        =  39     
rst7sp3        =  3a     
rtbsiz         = 3c0     
rw$common         e1"    
sb1              1e0'    
sb2              1f0'    
sbcnt            1de'    
sconin         =fc2d     
sconout        =fc27     
sconst         =fc33     
secadj            97"    
secin             98"    
sector$msg       10c"    
sectrn            ae"    
seldsk            48"    
setbnk            aa"    
setdma            a0"    
setjumps          78'    
setsec            84"    
settrk            7c"    
sintvec        =fff0     
srxrsm         =fe6d     
srxstp         =fe69     
sysbase        =f000     
syscmlo        =fec0     
syscom         =fc00     
syshertz       =  13     
sytimr         =fe19     
tblblk         =  30     
tdesclen       =  14     
tiaddrlen      =   4     
timrcon        =  27     
tmpbyte        =  4b     
tnamelen       =   8     
tpa            = 100     
tpagelen       =   2     
track$msg        107"    
trnpag         =   d     
true           =ffffffff 
tsizelen       =   4     
tx0            =fe77     
tx01           =fe79     
u0defspeed     =   6     
u0isr          =fe25     
u1defspeed     =   c     
u1isr          =fe5b     
u1nul          =fe65     
uart0          =  c0     
uart0base      =  c0     
uart0br        =  2b     
uart1          =  c8     
uart115k2      =   1     
uart1200       =  60     
uart19k2       =   6     
uart1base      =  c8     
uart1br        =  2a     
uart2400       =  30     
uart38k4       =   3     
uart4800       =  18     
uart57k6       =   2     
uart9600       =   c     
uastav         =fe90     
uastkb         =fe92     
uisre          =fe50     
uisri          =fe35     
vconin         =fc15     
vconout        =fc0f     
vconst         =fc1b     
vdbufsz        =   a     
vdrdsec        =   0     
vdwrsec        =   1     
voidisr        =fe22     
wboot             6c'    
write             ce"    
writecfg8255   =  80     
xofc           =  13     
xofflist         226'    
xonc           =  11     
zdstime            0      (extern)
zpm3           =   0     
