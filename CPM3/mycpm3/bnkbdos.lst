   1:			
   2:				TITLE	'CP/M BDOS Interface, BDOS, Version 3.0 Dec, 1982'
   3:			;*****************************************************************
   4:			;*****************************************************************
   5:			;**                                                             **
   6:			;**   B a s i c    D i s k   O p e r a t i n g   S y s t e m    **
   7:			;**								**
   8:			;**            I n t e r f a c e   M o d u l e                  **
   9:			;**                                                             **
  10:			;*****************************************************************
  11:			;*****************************************************************
  12:			;
  13:			;	Copyright (c) 1978, 1979, 1980, 1981, 1982
  14:			;	Digital Research
  15:			;	Box 579, Pacific Grove
  16:			;	California
  17:			;
  18:			;       December 1982
  19:			;
  20:	FFFF'         	ON	EQU	-1
  21:	0000'         	OFF	EQU	0
  22:	FFFF'         	TRUE	EQU	ON
  23:	0000'         	FALSE	EQU	OFF
  24:			;
  25:	0000'         	MPM	EQU	OFF
  26:	FFFF'         	BANKED	EQU	ON
  27:			
  28:			;
  29:			; [JCE] Have the date and copyright messages in only one source file
  30:			;
  31:			@BDATE	MACRO
  32:				DEFB	'101198'
  33:				ENDM
  34:			
  35:			@LCOPY	MACRO
  36:				DEFB	'COPYRIGHT 1998, '
  37:				DEFB	'CALDERA, INC.   '
  38:				ENDM
  39:			
  40:			@SCOPY	MACRO
  41:				DEFB	'(C) 98 CALDERA'
  42:				ENDM
  43:			;
  44:			;	equates for non graphic characters
  45:			;
  46:			
  47:	0001'         	CTLA	EQU	01H		; control a
  48:	0002'         	CTLB	EQU	02H		; control b
  49:	0003'         	CTLC	EQU	03H		; control c
  50:	0005'         	CTLE	EQU	05H		; physical eol
  51:	0006'         	CTLF	EQU	06H		; control f
  52:	0007'         	CTLG	EQU	07H		; control g
  53:	0008'         	CTLH	EQU	08H		; backspace
  54:	000B'         	CTLK	EQU	0BH		; control k
  55:	0010'         	CTLP	EQU	10H		; prnt toggle
  56:	0011'         	CTLQ	EQU	11H		; start screen
  57:	0012'         	CTLR	EQU	12H		; repeat line
  58:	0013'         	CTLS	EQU	13H		; stop screen
  59:	0015'         	CTLU	EQU	15H		; line delete
  60:	0017'         	CTLW	EQU	17H		; control w
  61:	0018'         	CTLX	EQU	18H		; =ctl-u
  62:	001A'         	CTLZ	EQU	1AH		; end of file
  63:	007F'         	RUBOUT	EQU	7FH		; char delete
  64:	0009'         	TAB	EQU	09H		; tab char
  65:	000D'         	CR	EQU	0DH		; carriage return
  66:	000A'         	LF	EQU	0AH		; line feed
  67:	005E'         	CTL	EQU	5EH		; up arrow
  68:			
  69:			; 	ORG	0000H
  70:	0000'         	BASE		EQU	$
  71:			
  72:			; Base page definitions
  73:			
  74:	FC00'         	BNKBDOS$PG 	EQU	BASE+0FC00H
  75:	FD00'         	RESBDOS$PG 	EQU	BASE+0FD00H
  76:	FB00'         	SCB$PG		EQU	BASE+0FB00H
  77:	FF00'         	BIOS$PG 	EQU	BASE+0FF00H
  78:			
  79:			; Bios equates
  80:			
  81:	FF00'         	BIOS		EQU	BIOS$PG
  82:	FF00'         	BOOTF		EQU	BIOS$PG		; 00. cold boot function
  83:			
  84:	FFFF'         		IF BANKED
  85:			
  86:	FB68'         	WBOOTF		EQU	SCB$PG+68H	; 01. warm boot function
  87:	FB6E'         	CONSTF		EQU	SCB$PG+6EH	; 02. console status function
  88:	FB74'         	CONINF		EQU	SCB$PG+74H	; 03. console input function
  89:	FB7A'         	CONOUTF 	EQU	SCB$PG+7AH	; 04. console output function
  90:	FB80'         	LISTF		EQU	SCB$PG+80H	; 05. list output function
  91:			
  92:				ELSE
 100:				ENDIF
 101:			
 102:	FF12'         	PUNCHF		EQU	BIOS$PG+18	; 06. punch output function
 103:	FF15'         	READERF 	EQU	BIOS$PG+21	; 07. reader input function
 104:	FF18'         	HOMEF		EQU	BIOS$PG+24	; 08. disk home function
 105:	FF1B'         	SELDSKF 	EQU	BIOS$PG+27	; 09. select disk function
 106:	FF1E'         	SETTRKF 	EQU	BIOS$PG+30	; 10. set track function
 107:	FF21'         	SETSECF 	EQU	BIOS$PG+33	; 11. set sector function
 108:	FF24'         	SETDMAF 	EQU	BIOS$PG+36	; 12. set dma function
 109:	FF27'         	READF		EQU	BIOS$PG+39	; 13. read disk function
 110:	FF2A'         	WRITEF		EQU	BIOS$PG+42	; 14. write disk function
 111:	FF2D'         	LISTSTF 	EQU	BIOS$PG+45	; 15. list status function
 112:	FF30'         	SECTRAN 	EQU	BIOS$PG+48	; 16. sector translate
 113:	FF33'         	CONOUTSTF 	EQU	BIOS$PG+51	; 17. console output status function
 114:	FF36'         	AUXINSTF 	EQU	BIOS$PG+54	; 18. aux input status function
 115:	FF39'         	AUXOUTSTF 	EQU	BIOS$PG+57	; 19. aux output status function
 116:	FF3C'         	DEVTBLF 	EQU	BIOS$PG+60	; 20. retunr device table address fx
 117:	FF3F'         	DEVINITF 	EQU	BIOS$PG+63	; 21. initialize device function
 118:	FF42'         	DRVTBLF 	EQU	BIOS$PG+66	; 22. return drive table address
 119:	FF45'         	MULTIOF 	EQU	BIOS$PG+69	; 23. multiple i/o function
 120:	FF48'         	FLUSHF		EQU	BIOS$PG+72	; 24. flush function
 121:	FF4B'         	MOVEF		EQU	BIOS$PG+75	; 25. memory move function
 122:	FF4E'         	TIMEF		EQU	BIOS$PG+78	; 26. system get/set time function
 123:	FF51'         	SELMEMF	 	EQU	BIOS$PG+81	; 27. select memory function
 124:	FF54'         	SETBNKF 	EQU	BIOS$PG+84	; 28. set dma bank function
 125:	FF57'         	XMOVEF		EQU	BIOS$PG+87	; 29. extended move function
 126:			
 127:	FFFF'         		IF BANKED
 128:			
 129:			; System Control Block equates
 130:			
 131:	FB90'         	OLOG		EQU	SCB$PG+090H
 132:	FB92'         	RLOG		EQU	SCB$PG+092H
 133:			
 134:	FB9C'         	SCB		EQU	SCB$PG+09CH
 135:			
 136:			; Expansion Area - 6 bytes
 137:			
 138:	FB9C'         	HASHL		EQU	SCB$PG+09CH
 139:	FB9D'         	HASH		EQU	SCB$PG+09DH
 140:	FBA1'         	VERSION 	EQU	SCB$PG+0A1H
 141:			
 142:			; Utilities Section - 8 bytes
 143:			
 144:	FBA2'         	UTIL$FLGS 	EQU	SCB$PG+0A2H
 145:	FBA6'         	DSPL$FLGS 	EQU	SCB$PG+0A6H
 146:			
 147:			; CLP Section - 4 bytes
 148:			
 149:	FBAA'         	CLP$FLGS 	EQU	SCB$PG+0AAH
 150:	FBAC'         	CLP$ERRCDE 	EQU	SCB$PG+0ACH
 151:			
 152:			; CCP Section - 8 bytes
 153:			
 154:	FBAE'         	CCP$COMLEN 	EQU	SCB$PG+0AEH
 155:	FBAF'         	CCP$CURDRV 	EQU	SCB$PG+0AFH
 156:	FBB0'         	CCP$CURUSR 	EQU	SCB$PG+0B0H
 157:	FBB1'         	CCP$CONBUFF 	EQU	SCB$PG+0B1H
 158:	FBB3'         	CCP$FLGS 	EQU	SCB$PG+0B3H
 159:			
 160:			; Device I/O Section - 32 bytes
 161:			
 162:	FBB6'         	CONWIDTH 	EQU	SCB$PG+0B6H
 163:	FBB7'         	COLUMN		EQU	SCB$PG+0B7H
 164:	FBB8'         	CONPAGE 	EQU	SCB$PG+0B8H
 165:	FBB9'         	CONLINE 	EQU	SCB$PG+0B9H
 166:	FBBA'         	CONBUFFADD 	EQU	SCB$PG+0BAH
 167:	FBBC'         	CONBUFFLEN 	EQU	SCB$PG+0BCH
 168:	FBBE'         	CONIN$RFLG 	EQU	SCB$PG+0BEH
 169:	FBC0'         	CONOUT$RFLG 	EQU	SCB$PG+0C0H
 170:	FBC2'         	AUXIN$RFLG 	EQU	SCB$PG+0C2H
 171:	FBC4'         	AUXOUT$RFLG 	EQU	SCB$PG+0C4H
 172:	FBC6'         	LSTOUT$RFLG 	EQU	SCB$PG+0C6H
 173:	FBC8'         	PAGE$MODE 	EQU	SCB$PG+0C8H
 174:	FBC9'         	PM$DEFAULT 	EQU	SCB$PG+0C9H
 175:	FBCA'         	CTLH$ACT 	EQU	SCB$PG+0CAH
 176:	FBCB'         	RUBOUT$ACT 	EQU	SCB$PG+0CBH
 177:	FBCC'         	TYPE$AHEAD 	EQU	SCB$PG+0CCH
 178:	FBCD'         	CONTRAN 	EQU	SCB$PG+0CDH
 179:	FBCF'         	CONMODE 	EQU	SCB$PG+0CFH
 180:	FBD3'         	OUTDELIM 	EQU	SCB$PG+0D3H
 181:	FBD4'         	LISTCP		EQU	SCB$PG+0D4H
 182:	FBD5'         	QFLAG		EQU	SCB$PG+0D5H
 183:			
 184:			; BDOS Section - 42 bytes
 185:			
 186:	FBD6'         	SCBADD		EQU	SCB$PG+0D6H
 187:	FBD8'         	DMAAD		EQU	SCB$PG+0D8H
 188:	FBDA'         	OLDDSK		EQU	SCB$PG+0DAH
 189:	FBDB'         	INFO		EQU	SCB$PG+0DBH
 190:	FBDD'         	RESEL		EQU	SCB$PG+0DDH
 191:	FBDE'         	RELOG		EQU	SCB$PG+0DEH
 192:	FBDF'         	FX		EQU	SCB$PG+0DFH
 193:	FBE0'         	USRCODE 	EQU	SCB$PG+0E0H
 194:	FBE1'         	DCNT		EQU	SCB$PG+0E1H
 195:			;searcha	equ	scb$pg+0e3h
 196:	FBE5'         	SEARCHL 	EQU	SCB$PG+0E5H
 197:	FBE6'         	MULTCNT 	EQU	SCB$PG+0E6H
 198:	FBE7'         	ERRORMODE 	EQU	SCB$PG+0E7H
 199:	FBE8'         	SEARCHCHAIN 	EQU	SCB$PG+0E8H
 200:	FBEC'         	TEMP$DRIVE 	EQU	SCB$PG+0ECH
 201:	FBED'         	ERRDRV		EQU	SCB$PG+0EDH
 202:	FBF0'         	MEDIA$FLAG 	EQU	SCB$PG+0F0H
 203:	FBF3'         	BDOS$FLAGS 	EQU	SCB$PG+0F3H
 204:	FBF4'         	STAMP		EQU	SCB$PG+0F4H
 205:	FBF9'         	COMMONBASE 	EQU	SCB$PG+0F9H
 206:	FBFB'         	ERROR		EQU	SCB$PG+0FBH	;jmp error$sub
 207:	FBFE'         	BDOSADD 	EQU	SCB$PG+0FEH
 208:			
 209:			; Resbdos equates
 210:			
 211:	FD00'         	RESBDOS 	EQU	RESBDOS$PG
 212:	FD09'         	MOVE$OUT 	EQU	RESBDOS$PG+9	; a=bank #, hl=dest, de=srce
 213:	FD0C'         	MOVE$TPA 	EQU	RESBDOS$PG+0CH	; a=bank #, hl=dest, de=srce
 214:	FD0F'         	SRCH$HASH 	EQU	RESBDOS$PG+0FH	; a=bank #, hl=hash table addr
 215:	FD12'         	HASHMX		EQU	RESBDOS$PG+12H	; max hash search dcnt
 216:	FD14'         	RD$DIR$FLAG 	EQU	RESBDOS$PG+14H	; directory read flag
 217:	FD15'         	MAKE$XFCB 	EQU	RESBDOS$PG+15H	; make function flag
 218:	FD16'         	FIND$XFCB 	EQU	RESBDOS$PG+16H	; search function flag
 219:	FD17'         	XDCNT		EQU	RESBDOS$PG+17H	; dcnt save for empty fcb,
 220:				; user 0 fcb, or xfcb
 221:	FD19'         	XDMAAD		EQU	RESBDOS$PG+19H	; resbdos dma copy area addr
 222:	FD1B'         	CURDMA		EQU	RESBDOS$PG+1BH	; current dma
 223:	FD1D'         	COPY$CR$ONLY 	EQU	RESBDOS$PG+1DH; dont restore fcb flag
 224:	FD1E'         	USER$INFO 	EQU	RESBDOS$PG+1EH	; user fcb address
 225:	FD20'         	KBCHAR		EQU	RESBDOS$PG+20H	; conbdos look ahead char
 226:	FD21'         	QCONINX 	EQU	RESBDOS$PG+21H	; qconin mov a,m routine
 227:			
 228:				ELSE
 233:				ENDIF
 234:			
 235:			;
 236:	0000' 36353433	SERIAL:	DEFB	'654321'
	      3231
 237:			;
 238:			;	Enter here from the user's program with function number in c,
 239:			;	and information address in d,e
 240:			;
 241:			
 242:	0006'         	BDOSE:	; Arrive here from user programs
 243:	0006' EB      		EX	DE,HL
 244:	0007' 22DBFB  		LD	(INFO),HL
 245:	000A' EB      		EX	DE,HL		; info=de, de=info
 246:			
 247:	000B' 79      		LD	A,C
 248:	000C' 32DFFB  		LD	(FX),A
 249:	000F' FE0E    		CP	14
 250:	0011' DA3B00  		JP	C,BDOSE2
 251:	0014' 210000  		LD	HL,0
 252:	0017' 229828  		LD	(DIR$CNT),HL	; dircnt,multnum = 0
 253:	001A' 3ADAFB  		LD	A,(OLDDSK)
 254:	001D' 32A428  		LD	(SELDSK),A	; Set seldsk
 255:			
 256:	FFFF'         		IF BANKED
 257:	0020' 3D      		DEC	A
 258:	0021' 32BC28  		LD	(COPY$CR$INIT),A
 259:				ENDIF
 260:			
 261:				; If mult$cnt ~= 1 then read or write commands
 262:				; are handled by the shell
 263:	0024' 3AE6FB  		LD	A,(MULTCNT)
 264:	0027' 3D      		DEC	A
 265:	0028' CA3B00  		JP	Z,BDOSE2
 266:	002B' 219500  		LD	HL,MULT$FXS
 267:	002E'         	BDOSE1:
 268:	002E' 7E      		LD	A,(HL)
 269:	002F' B7      		OR	A
 270:	0030' CA3B00  		JP	Z,BDOSE2
 271:	0033' B9      		CP	C
 272:	0034' CA3403  		JP	Z,SHELL
 273:	0037' 23      		INC	HL
 274:	0038' C32E00  		JP	BDOSE1
 275:	003B'         	BDOSE2:
 276:	003B' 7B      		LD	A,E
 277:	003C' 329E28  		LD	(LINFO),A	; linfo = low(info) - don't equ
 278:	003F' 210000  		LD	HL,0
 279:	0042' 229F0D  		LD	(ARET),HL	; Return value defaults to 0000
 280:	0045' 22DDFB  		LD	(RESEL),HL	; resel,relog = 0
 281:				; Save user's stack pointer, set to local stack
 282:	0048' 39      		ADD	HL,SP
 283:	0049' 223203  		LD	(ENTSP),HL	; entsp = stackptr
 284:			
 285:	0000'         		IF NOT BANKED
 287:				ENDIF
 288:			
 289:	004C' 213B28  		LD	HL,GOBACK	; Return here after all functions
 290:	004F' E5      		PUSH	HL		; jmp goback equivalent to ret
 291:	0050' 79      		LD	A,C
 292:	0051' FE33    		CP	NFUNCS
 293:	0053' D25D00  		JP	NC,HIGH$FXS	; Skip if invalid #
 294:	0056' 4B      		LD	C,E		; possible output character to c
 295:	0057' 21C600  		LD	HL,FUNCTAB
 296:	005A' C36F00  		JP	BDOS$JMP
 297:				; look for functions 98 ->
 298:	005D'         	HIGH$FXS:
 299:	005D' FE80    		CP	128
 300:	005F' D25C01  		JP	NC,TEST$152
 301:	0062' D662    		SUB	98
 302:	0064' DAC015  		JP	C,LRET$EQ$FF	; Skip if function < 98
 303:	0067' FE0F    		CP	NFUNCS2
 304:	0069' D2C015  		JP	NC,LRET$EQ$FF
 305:	006C' 212C01  		LD	HL,FUNCTAB2
 306:	006F'         	BDOS$JMP:
 307:	006F' 5F      		LD	E,A
 308:	0070' 1600    		LD	D,0		; de=func, hl=.ciotab
 309:	0072' 19      		ADD	HL,DE
 310:	0073' 19      		ADD	HL,DE
 311:	0074' 5E      		LD	E,(HL)
 312:	0075' 23      		INC	HL
 313:	0076' 56      		LD	D,(HL)		; de=functab(func)
 314:	0077' 2ADBFB  		LD	HL,(INFO)	; info in de for later xchg
 315:	007A' EB      		EX	DE,HL
 316:	007B' E9      		JP	(HL)		; dispatched
 317:			
 318:			;	   CAUTION: In banked systems only,
 319:			;          error$sub is referenced indirectly by the SCB ERROR
 320:			; 	   field in RESBDOS as (0fc7ch).  This value is converted
 321:			; 	   to the actual address of error$sub by GENSYS.  If the offset
 322:			; 	   of error$sub is changed, the SCB ERROR value must also
 323:			; 	   be changed.
 324:			
 325:			;
 326:			;	error subroutine
 327:			;
 328:			
 329:	007C'         	ERROR$SUB:
 330:	007C' 0600    		LD	B,0
 331:	007E' C5      		PUSH	BC
 332:	007F' 0D      		DEC	C
 333:	0080' 214A01  		LD	HL,ERRTBL
 334:	0083' 09      		ADD	HL,BC
 335:	0084' 09      		ADD	HL,BC
 336:	0085' 5E      		LD	E,(HL)
 337:	0086' 23      		INC	HL
 338:	0087' 56      		LD	D,(HL)
 339:	0088' EB      		EX	DE,HL
 340:	0089' CD8002  		CALL	ERRFLG
 341:	008C' C1      		POP	BC
 342:	008D' 3AE7FB  		LD	A,(ERRORMODE)
 343:	0090' B7      		OR	A
 344:	0091' C0      		RET	NZ
 345:	0092' C32303  		JP	REBOOTE
 346:			
 347:	0095' 14152122	MULT$FXS: DEFB	20,21,33,34,40,0
	      2800
 348:			
 349:	FFFF'         		IF BANKED
 350:	009B'         		@LCOPY
 350:	009B' 636F7079		defb	'copyright 1998, '
	      72696768
	      74203139
	      39382C20
 350:	00AB' 63616C64		defb	'caldera, inc.   '
	      6572612C
	      20696E63
	      2E202020
 350:	00BB'         		endm
 350:			
 351:	00BB'         		@BDATE
 351:	00BB' 31303131		defb	'101198'
	      3938
 351:	00C1'         		endm
 351:			
 352:	00C1'         		DEFS	5
 353:				ELSE
 365:				ENDIF
 366:			
 367:			;	dispatch table for functions
 368:			
 369:	00C6'         	FUNCTAB:
 370:	00C6' 2F03C203		DEFW	REBOOTX1, FUNC1, FUNC2, FUNC3
	      2805010A
 371:	00CE' 12FF80FB		DEFW	PUNCHF, LISTF, FUNC6, FUNC7
	      070A2B0A
 372:	00D6' 310A370A		DEFW	FUNC8, FUNC9, FUNC10, FUNC11
	      C8063D0A
 373:	000C'         	DISKF	EQU	($-FUNCTAB)/2	; disk funcs
 374:	00DE' 7D218321		DEFW	FUNC12,FUNC13,FUNC14,FUNC15
	      9621A021
 375:	00E6' 87229B22		DEFW	FUNC16,FUNC17,FUNC18,FUNC19
	      EC22F522
 376:	00EE' FB220423		DEFW	FUNC20,FUNC21,FUNC22,FUNC23
	      0D23EF23
 377:	00F6' F523FB23		DEFW	FUNC24,FUNC25,FUNC26,FUNC27
	      01240824
 378:	00FE' D3111124		DEFW	FUNC28,FUNC29,FUNC30,FUNC31
	      17242324
 379:	0106' 2D244124		DEFW	FUNC32,FUNC33,FUNC34,FUNC35
	      4A245324
 380:	010E' 401E5924		DEFW	FUNC36,FUNC37,FUNC38,FUNC39
	      750A750A
 381:	0116' 4A24C015		DEFW	FUNC40,LRET$EQ$FF,FUNC42,FUNC43
	      750A750A
 382:	011E' 7D248B24		DEFW	FUNC44,FUNC45,FUNC46,FUNC47
	      9024CD24
 383:	0126' DF242A25		DEFW	FUNC48,FUNC49,FUNC50
	      5025
 384:	0033'         	NFUNCS	EQU	($-FUNCTAB)/2
 385:			
 386:	012C'         	FUNCTAB2:
 387:	012C' E824C825		DEFW	FUNC98,FUNC99
 388:	0130' A6261F27		DEFW	FUNC100,FUNC101,FUNC102,FUNC103
	      28276427
 389:	0138' F127FE27		DEFW	FUNC104,FUNC105,FUNC106,FUNC107
	      13281E28
 390:	0140' 27287B0A		DEFW	FUNC108,FUNC109,FUNC110,FUNC111
	      890A950A
 391:	0148' 950A    		DEFW	FUNC112
 392:			
 393:	000F'         	NFUNCS2 EQU	($-FUNCTAB2)/2
 394:			
 395:	014A'         	ERRTBL:
 396:	014A' 410D    		DEFW	PERMSG
 397:	014C' 670D    		DEFW	RODMSG
 398:	014E' 580D    		DEFW	ROFMSG
 399:	0150' 4A0D    		DEFW	SELMSG
 400:	0152' 0000    		DEFW	0
 401:	0154' 0000    		DEFW	0
 402:	0156' 760D    		DEFW	PASSMSG
 403:	0158' 850D    		DEFW	FXSTSMSG
 404:	015A' 910D    		DEFW	WILDMSG
 405:			
 406:	015C'         	TEST$152:
 407:	015C' FE98    		CP	152
 408:	015E' C0      		RET	NZ
 409:			
 410:			;
 411:			;	PARSE version 3.0b  Oct 08 1982 - Doug Huskey
 412:			;
 413:			;
 414:				; DE->.(.filename,.fcb)
 415:				;
 416:				; filename = [d:]file[.type][;password]
 417:				;
 418:				; fcb assignments
 419:				;
 420:				;   0     => drive, 0 = default, 1 = A, 2 = B, ...
 421:				;   1-8   => file, converted to upper case,
 422:				;            padded with blanks (left justified)
 423:				;   9-11  => type, converted to upper case,
 424:				;	     padded with blanks (left justified)
 425:				;   12-15 => set to zero
 426:				;   16-23 => password, converted to upper case,
 427:				;	     padded with blanks
 428:				;   24-25 => 0000h
 429:				;   26    => length of password (0 - 8)
 430:				;
 431:				; Upon return, HL is set to FFFFH if DE locates
 432:				;            an invalid file name;
 433:				; otherwise, HL is set to 0000H if the delimiter
 434:				;            following the file name is a 00H (NULL)
 435:				; 	     or a 0DH (CR);
 436:				; otherwise, HL is set to the address of the delimiter
 437:				;            following the file name.
 438:				;
 439:	015F' 212924  		LD	HL,STHL$RET
 440:	0162' E5      		PUSH	HL
 441:	0163' 2ADBFB  		LD	HL,(INFO)
 442:	0166' 5E      		LD	E,(HL)		;get first parameter
 443:	0167' 23      		INC	HL
 444:	0168' 56      		LD	D,(HL)
 445:	0169' D5      		PUSH	DE		;save .filename
 446:	016A' 23      		INC	HL
 447:	016B' 5E      		LD	E,(HL)		;get second parameter
 448:	016C' 23      		INC	HL
 449:	016D' 56      		LD	D,(HL)
 450:	016E' E1      		POP	HL		;DE=.fcb  HL=.filename
 451:	016F' EB      		EX	DE,HL
 452:	0170'         	PARSE0:
 453:	0170' E5      		PUSH	HL		;save .fcb
 454:	0171' AF      		XOR	A
 455:	0172' 77      		LD	(HL),A		;clear drive byte
 456:	0173' 23      		INC	HL
 457:	0174' 010B20  		LD	BC,20H*256+11
 458:	0177' CD6C02  		CALL	PAD		;pad name and type w/ blanks
 459:	017A' 010400  		LD	BC,4
 460:	017D' CD6C02  		CALL	PAD		;EXT, S1, S2, RC = 0
 461:	0180' 010820  		LD	BC,20H*256+8
 462:	0183' CD6C02  		CALL	PAD		;pad password field w/ blanks
 463:	0186' 010C00  		LD	BC,12
 464:	0189' CD6C02  		CALL	PAD		;zero 2nd 1/2 of map, cr, r0 - r2
 465:			;
 466:			;	skip spaces
 467:			;
 468:	018C' CD7302  		CALL	SKPS
 469:			;
 470:			;	check for drive
 471:			;
 472:	018F' 1A      		LD	A,(DE)
 473:	0190' FE3A    		CP	':'		;is this a drive?
 474:	0192' 1B      		DEC	DE
 475:	0193' E1      		POP	HL
 476:	0194' E5      		PUSH	HL		;HL = .fcb
 477:	0195' C2AC01  		JP	NZ,PARSE$NAME
 478:			;
 479:			;	Parse the drive-spec
 480:			;
 481:	0198'         	PARSEDRV:
 482:	0198' CD4D02  		CALL	DELIM
 483:	019B' CAE001  		JP	Z,PARSE$OK
 484:	019E' D641    		SUB	'A'
 485:	01A0' DAF601  		JP	C,PERROR1
 486:	01A3' FE10    		CP	16
 487:	01A5' D2F601  		JP	NC,PERROR1
 488:	01A8' 13      		INC	DE
 489:	01A9' 13      		INC	DE		;past the ':'
 490:	01AA' 3C      		INC	A		;set drive relative to 1
 491:	01AB' 77      		LD	(HL),A		;store the drive in FCB(0)
 492:			;
 493:			;	Parse the file-name
 494:			;
 495:	01AC'         	PARSE$NAME:
 496:	01AC' 23      		INC	HL		;HL = .fcb(1)
 497:	01AD' CD4D02  		CALL	DELIM
 498:	01B0' CAE001  		JP	Z,PARSE$OK
 499:	01B3' 010007  		LD	BC,7*256
 500:			
 501:	01B6' 1A      	PARSE6:	LD	A,(DE)		;get a character
 502:	01B7' FE2E    		CP	'.'		;file-type next?
 503:	01B9' CACA01  		JP	Z,PARSE$TYPE	;branch to file-type processing
 504:	01BC' FE3B    		CP	';'
 505:	01BE' CAFB01  		JP	Z,PARSEPW
 506:	01C1' CD1902  		CALL	GFC		;process one character
 507:	01C4' C2B601  		JP	NZ,PARSE6	;loop if not end of name
 508:	01C7' C3E001  		JP	PARSE$OK
 509:			;
 510:			;	Parse the file-type
 511:			;
 512:	01CA'         	PARSE$TYPE:
 513:	01CA' 13      		INC	DE		;advance past dot
 514:	01CB' E1      		POP	HL
 515:	01CC' E5      		PUSH	HL		;HL =.fcb
 516:	01CD' 010900  		LD	BC,9
 517:	01D0' 09      		ADD	HL,BC		;HL =.fcb(9)
 518:	01D1' 010002  		LD	BC,2*256
 519:			
 520:	01D4' 1A      	PARSE8:	LD	A,(DE)
 521:	01D5' FE3B    		CP	';'
 522:	01D7' CAFB01  		JP	Z,PARSEPW
 523:	01DA' CD1902  		CALL	GFC		;process one character
 524:	01DD' C2D401  		JP	NZ,PARSE8	;loop if not end of type
 525:			;
 526:	01E0'         	PARSE$OK:
 527:	01E0' C1      		POP	BC
 528:	01E1' D5      		PUSH	DE
 529:	01E2' CD7302  		CALL	SKPS		;skip trailing blanks and tabs
 530:	01E5' 1B      		DEC	DE
 531:	01E6' CD4D02  		CALL	DELIM		;is next nonblank char a delim?
 532:	01E9' E1      		POP	HL
 533:	01EA' C0      		RET	NZ		;no
 534:	01EB' 210000  		LD	HL,0
 535:	01EE' B7      		OR	A
 536:	01EF' C8      		RET	Z		;return zero if delim = 0
 537:	01F0' FE0D    		CP	CR
 538:	01F2' C8      		RET	Z		;return zero if delim = cr
 539:	01F3' EB      		EX	DE,HL
 540:	01F4' C9      		RET
 541:			;
 542:			;	handle parser error
 543:			;
 544:	01F5'         	PERROR:
 545:	01F5' C1      		POP	BC		;throw away return addr
 546:	01F6'         	PERROR1:
 547:	01F6' C1      		POP	BC
 548:	01F7' 21FFFF  		LD	HL,0FFFFH
 549:	01FA' C9      		RET
 550:			;
 551:			;	Parse the password
 552:			;
 553:	01FB'         	PARSEPW:
 554:	01FB' 13      		INC	DE
 555:	01FC' E1      		POP	HL
 556:	01FD' E5      		PUSH	HL
 557:	01FE' 011000  		LD	BC,16
 558:	0201' 09      		ADD	HL,BC
 559:	0202' 010107  		LD	BC,7*256+1
 560:	0205'         	PARSEPW1:
 561:	0205' CD1902  		CALL	GFC
 562:	0208' C20502  		JP	NZ,PARSEPW1
 563:	020B' 3E07    		LD	A,7
 564:	020D' 90      		SUB	B
 565:	020E' E1      		POP	HL
 566:	020F' E5      		PUSH	HL
 567:	0210' 011A00  		LD	BC,26
 568:	0213' 09      		ADD	HL,BC
 569:	0214' 77      		LD	(HL),A
 570:	0215' 1A      		LD	A,(DE)		;delimiter in A
 571:	0216' C3E001  		JP	PARSE$OK
 572:			;
 573:			;	get next character of name, type or password
 574:			;
 575:	0219' CD4D02  	GFC:	CALL	DELIM		;check for end of filename
 576:	021C' C8      		RET	Z		;return if so
 577:	021D' FE20    		CP	' '		;check for control characters
 578:	021F' 13      		INC	DE
 579:	0220' DAF501  		JP	C,PERROR	;error if control characters encountered
 580:	0223' 04      		INC	B		;error if too big for field
 581:	0224' 05      		DEC	B
 582:	0225' FAF501  		JP	M,PERROR
 583:	0228' 0C      		INC	C
 584:	0229' 0D      		DEC	C
 585:	022A' C23202  		JP	NZ,GFC1
 586:	022D' FE2A    		CP	'*'		;trap "match rest of field" character
 587:	022F' CA3702  		JP	Z,SETMATCH
 588:	0232' 77      	GFC1:	LD	(HL),A		;put character in fcb
 589:	0233' 23      		INC	HL
 590:	0234' 05      		DEC	B		;decrement field size counter
 591:	0235' B7      		OR	A		;clear zero flag
 592:	0236' C9      		RET
 593:			;;
 594:	0237'         	SETMATCH:
 595:	0237' 363F    		LD	(HL),'?'	;set match one character
 596:	0239' 23      		INC	HL
 597:	023A' 05      		DEC	B
 598:	023B' F23702  		JP	P,SETMATCH
 599:	023E' C9      		RET
 600:			;
 601:			;	check for delimiter
 602:			;
 603:			;	entry:	A = character
 604:			;	exit:	z = set if char is a delimiter
 605:			;
 606:	023F' 0D09202E	DELIMITERS: DEFB	CR,TAB,' .,:;[]=<>|',0
	      2C3A3B5B
	      5D3D3C3E
	      7C00
 607:			
 608:	024D' 1A      	DELIM:	LD	A,(DE)	;get character
 609:	024E' E5      		PUSH	HL
 610:	024F' 213F02  		LD	HL,DELIMITERS
 611:	0252' BE      	DELIM1:	CP	(HL)		;is char in table
 612:	0253' CA5D02  		JP	Z,DELIM2
 613:	0256' 34      		INC	(HL)
 614:	0257' 35      		DEC	(HL)		;end of table? (0)
 615:	0258' 23      		INC	HL
 616:	0259' C25202  		JP	NZ,DELIM1
 617:	025C' B7      		OR	A		;reset zero flag
 618:	025D' E1      	DELIM2:	POP	HL
 619:	025E' C8      		RET	Z
 620:				;
 621:				;	not a delimiter, convert to upper case
 622:				;
 623:	025F' FE61    		CP	'a'
 624:	0261' D8      		RET	C
 625:	0262' FE7B    		CP	'z'+1
 626:	0264' D26902  		JP	NC,DELIM3
 627:	0267' E65F    		AND	05FH
 628:	0269' E67F    	DELIM3:	AND	07FH
 629:	026B' C9      		RET			;return with zero set if so
 630:			;
 631:			;	pad with blanks or zeros
 632:			;
 633:	026C' 70      	PAD:	LD	(HL),B
 634:	026D' 23      		INC	HL
 635:	026E' 0D      		DEC	C
 636:	026F' C26C02  		JP	NZ,PAD
 637:	0272' C9      		RET
 638:			;
 639:			;	skip blanks and tabs
 640:			;
 641:	0273' 1A      	SKPS:	LD	A,(DE)
 642:	0274' 13      		INC	DE
 643:	0275' FE20    		CP	' '		;skip spaces & tabs
 644:	0277' CA7302  		JP	Z,SKPS
 645:	027A' FE09    		CP	TAB
 646:	027C' CA7302  		JP	Z,SKPS
 647:	027F' C9      		RET
 648:			;
 649:			;	end of PARSE
 650:			;
 651:			
 652:	0280'         	ERRFLG:
 653:				; report error to console, message address in hl
 654:	0280' E5      		PUSH	HL
 655:	0281' CD8205  		CALL	CRLF		; stack mssg address, new line
 656:	0284' 3AAA28  		LD	A,(ADRIVE)
 657:	0287' C641    		ADD	A,'A'
 658:	0289' 323D0D  		LD	(DSKERR),A	; current disk name
 659:	028C' 012F0D  		LD	BC,DSKMSG
 660:			
 661:	FFFF'         		IF BANKED
 662:	028F' CDEE02  		CALL	ZPRINT		; the error message
 663:				ELSE
 665:				ENDIF
 666:			
 667:	0292' C1      		POP	BC
 668:			
 669:	FFFF'         		IF BANKED
 670:	0293' 3AF3FB  		LD	A,(BDOS$FLAGS)
 671:	0296' 17      		RLA
 672:	0297' D2EE02  		JP	NC,ZPRINT
 673:	029A' CDEE02  		CALL	ZPRINT		; error message tail
 674:	029D' 3ADFFB  		LD	A,(FX)
 675:	02A0' 0630    		LD	B,30H
 676:	02A2' 210B03  		LD	HL,PR$FX1
 677:	02A5' FE64    		CP	100
 678:	02A7' DAAF02  		JP	C,ERRFLG1
 679:	02AA' 3631    		LD	(HL),31H
 680:	02AC' 23      		INC	HL
 681:	02AD' D664    		SUB	100
 682:	02AF'         	ERRFLG1:
 683:	02AF' D60A    		SUB	10
 684:	02B1' DAB802  		JP	C,ERRFLG2
 685:	02B4' 04      		INC	B
 686:	02B5' C3AF02  		JP	ERRFLG1
 687:	02B8'         	ERRFLG2:
 688:	02B8' 70      		LD	(HL),B
 689:	02B9' 23      		INC	HL
 690:	02BA' C63A    		ADD	A,3AH
 691:	02BC' 77      		LD	(HL),A
 692:	02BD' 23      		INC	HL
 693:	02BE' 3620    		LD	(HL),20H
 694:	02C0' 210E03  		LD	HL,PR$FCB
 695:	02C3' 3600    		LD	(HL),0
 696:	02C5' 3ADDFB  		LD	A,(RESEL)
 697:	02C8' B7      		OR	A
 698:	02C9' CAE502  		JP	Z,ERRFLG3
 699:	02CC' 3620    		LD	(HL),20H
 700:	02CE' D5      		PUSH	DE
 701:	02CF' 2ADBFB  		LD	HL,(INFO)
 702:	02D2' 23      		INC	HL
 703:	02D3' EB      		EX	DE,HL
 704:	02D4' 211603  		LD	HL,PR$FCB1
 705:	02D7' 0E08    		LD	C,8
 706:	02D9' CD290E  		CALL	MOVE
 707:	02DC' 362E    		LD	(HL),'.'
 708:	02DE' 23      		INC	HL
 709:	02DF' 0E03    		LD	C,3
 710:	02E1' CD290E  		CALL	MOVE
 711:	02E4' D1      		POP	DE
 712:	02E5'         	ERRFLG3:
 713:	02E5' CD8205  		CALL	CRLF
 714:	02E8' 01FB02  		LD	BC,PR$FX
 715:	02EB' C3EE02  		JP	ZPRINT
 716:			
 717:	02EE'         	ZPRINT:
 718:	02EE' 0A      		LD	A,(BC)
 719:	02EF' B7      		OR	A
 720:	02F0' C8      		RET	Z
 721:	02F1' C5      		PUSH	BC
 722:	02F2' 4F      		LD	C,A
 723:	02F3' CD2805  		CALL	TABOUT
 724:	02F6' C1      		POP	BC
 725:	02F7' 03      		INC	BC
 726:	02F8' C3EE02  		JP	ZPRINT
 727:			
 728:	02FB' 42444F53	PR$FX:	DEFB	'BDOS Function = '
	      2046756E
	      6374696F
	      6E203D20
 729:	030B' 202020  	PR$FX1:	DEFB	'   '
 730:	030E' 2046696C	PR$FCB:	DEFB	' File = '
	      65203D20
 731:	0316'         	PR$FCB1:DEFS	12
 732:	0322' 00      		DEFB	0
 733:			
 734:				ELSE
 736:				ENDIF
 737:			
 738:	0323'         	REBOOTE:
 739:	0323' 21FDFF  		LD	HL,0FFFDH
 740:	0326' C32C03  		JP	REBOOTX0	; BDOS error
 741:	0329'         	REBOOTX:
 742:			;;;	lxi h,0fffeh ; CTL-C error
 743:	0329' CD242D  		CALL	PATCH$1E25	;[JCE] DRI Patch 13
 744:	032C'         	REBOOTX0:
 745:	032C' 22ACFB  		LD	(CLP$ERRCDE),HL
 746:	032F'         	REBOOTX1:
 747:	032F' C368FB  		JP	WBOOTF
 748:			
 749:	0332'         	ENTSP:	DEFS	2	; entry stack pointer
 750:			
 751:	0334'         	SHELL:
 752:	0334' 210000  		LD	HL,0
 753:	0337' 39      		ADD	HL,SP
 754:	0338' 226603  		LD	(SHELL$SP),HL
 755:			
 756:	0000'         		IF NOT BANKED
 758:				ENDIF
 759:			
 760:	033B' 21A203  		LD	HL,SHELL$RTN
 761:	033E' E5      		PUSH	HL
 762:	033F' CD090E  		CALL	SAVE$RR
 763:	0342' CD8903  		CALL	SAVE$DMA
 764:	0345' 3AE6FB  		LD	A,(MULTCNT)
 765:	0348'         	MULT$IO:
 766:	0348' F5      		PUSH	AF
 767:	0349' 329928  		LD	(MULT$NUM),A
 768:	034C' CD7403  		CALL	CBDOS
 769:	034F' B7      		OR	A
 770:	0350' C29903  		JP	NZ,SHELL$ERR
 771:	0353' 3ADFFB  		LD	A,(FX)
 772:	0356' FE21    		CP	33
 773:	0358' D4FE0D  		CALL	NC,INCR$RR
 774:	035B' CD7F03  		CALL	ADV$DMA
 775:	035E' F1      		POP	AF
 776:	035F' 3D      		DEC	A
 777:	0360' C24803  		JP	NZ,MULT$IO
 778:	0363' 67      		LD	H,A
 779:	0364' 6F      		LD	L,A
 780:	0365' C9      		RET
 781:			
 782:	0366'         	SHELL$SP:
 783:	0366' 0000    		DEFW	0
 784:			
 785:	0368' C7C7C7C7		DEFW	0C7C7H,0C7C7H,0C7C7H,0C7C7H,0C7C7H
	      C7C7C7C7
	      C7C7
 786:			
 787:	0372'         	SHELL$STK: ; shell has 5 level stack
 788:	0372' 0000    	HOLD$DMA: DEFW	0
 789:			
 790:	0374'         	CBDOS:
 791:	0374' 3ADFFB  		LD	A,(FX)
 792:	0377' 4F      		LD	C,A
 793:	0378'         	CBDOS1:
 794:	0378' 2ADBFB  		LD	HL,(INFO)
 795:	037B' EB      		EX	DE,HL
 796:	037C' C33B00  		JP	BDOSE2
 797:			
 798:	037F'         	ADV$DMA:
 799:	037F' 2AD8FB  		LD	HL,(DMAAD)
 800:	0382' 118000  		LD	DE,80H
 801:	0385' 19      		ADD	HL,DE
 802:	0386' C39303  		JP	RESET$DMA1
 803:			
 804:	0389'         	SAVE$DMA:
 805:	0389' 2AD8FB  		LD	HL,(DMAAD)
 806:	038C' 227203  		LD	(HOLD$DMA),HL
 807:	038F' C9      		RET
 808:			
 809:	0390'         	RESET$DMA:
 810:	0390' 2A7203  		LD	HL,(HOLD$DMA)
 811:	0393'         	RESET$DMA1:
 812:	0393' 22D8FB  		LD	(DMAAD),HL
 813:	0396' C3BF12  		JP	SETDMA
 814:			
 815:	0399'         	SHELL$ERR:
 816:	0399' C1      		POP	BC
 817:	039A' 3C      		INC	A
 818:	039B' C8      		RET	Z
 819:	039C' 3AE6FB  		LD	A,(MULTCNT)
 820:	039F' 90      		SUB	B
 821:	03A0' 67      		LD	H,A
 822:	03A1' C9      		RET
 823:			
 824:	03A2'         	SHELL$RTN:
 825:	03A2' E5      		PUSH	HL
 826:	03A3' 3ADFFB  		LD	A,(FX)
 827:	03A6' FE21    		CP	33
 828:	03A8' D4190E  		CALL	NC,RESET$RR
 829:	03AB' CD9003  		CALL	RESET$DMA
 830:	03AE' D1      		POP	DE
 831:	03AF' 2A6603  		LD	HL,(SHELL$SP)
 832:	03B2' F9      		LD	SP,HL
 833:	03B3' EB      		EX	DE,HL
 834:	03B4' 7D      		LD	A,L
 835:	03B5' 44      		LD	B,H
 836:	03B6' C9      		RET
 837:			
 839:			
 840:			
 841:				TITLE	'CP/M Bdos Interface, Bdos, Version 3.0 Nov, 1982'
 842:			;*****************************************************************
 843:			;*****************************************************************
 844:			;**                                                             **
 845:			;**   B a s i c    D i s k   O p e r a t i n g   S y s t e m    **
 846:			;**								**
 847:			;**               C o n s o l e   P o r t i o n                 **
 848:			;**                                                             **
 849:			;*****************************************************************
 850:			;*****************************************************************
 851:			;
 852:			;       November 1982
 853:			;
 854:			;
 855:			;	Console handlers
 856:			;
 857:	03B7'         	CONIN:
 858:				;read console character to A
 859:	03B7' 2120FD  		LD	HL,KBCHAR
 860:	03BA' 7E      		LD	A,(HL)
 861:	03BB' 3600    		LD	(HL),0
 862:	03BD' B7      		OR	A
 863:	03BE' C0      		RET	NZ
 864:				;no previous keyboard character ready
 865:	03BF' C374FB  		JP	CONINF		;get character externally
 866:				;ret
 867:			;
 868:	03C2'         	CONECH:
 869:	03C2' 21720A  		LD	HL,STA$RET
 870:	03C5' E5      		PUSH	HL
 871:	03C6'         	CONECH0:
 872:				;read character with echo
 873:	03C6' CDB703  		CALL	CONIN
 874:	03C9' CDF003  		CALL	ECHOC
 875:	03CC' DAD603  		JP	C,CONECH1	;echo character?
 876:				;character must be echoed before return
 877:	03CF' F5      		PUSH	AF
 878:	03D0' 4F      		LD	C,A
 879:	03D1' CD2805  		CALL	TABOUT
 880:	03D4' F1      		POP	AF
 881:	03D5' C9      		RET
 882:	03D6'         	CONECH1:
 883:	03D6' CD1304  		CALL	TEST$CTLS$MODE
 884:	03D9' C0      		RET	NZ
 885:	03DA' FE13    		CP	CTLS
 886:	03DC' C2E503  		JP	NZ,CONECH2
 887:	03DF' CD5E04  		CALL	CONBRK2
 888:	03E2' C3C603  		JP	CONECH0
 889:	03E5'         	CONECH2:
 890:	03E5' FE11    		CP	CTLQ
 891:	03E7' CAC603  		JP	Z,CONECH0
 892:	03EA' FE10    		CP	CTLP
 893:	03EC' CAC603  		JP	Z,CONECH0
 894:	03EF' C9      		RET
 895:			;
 896:	03F0'         	ECHOC:
 897:				;echo character if graphic
 898:				;cr, lf, tab, or backspace
 899:	03F0' FE0D    		CP	CR
 900:	03F2' C8      		RET	Z		;carriage return?
 901:	03F3' FE0A    		CP	LF
 902:	03F5' C8      		RET	Z		;line feed?
 903:	03F6' FE09    		CP	TAB
 904:	03F8' C8      		RET	Z		;tab?
 905:	03F9' FE08    		CP	CTLH
 906:	03FB' C8      		RET	Z		;backspace?
 907:	03FC' FE20    		CP	' '
 908:	03FE' C9      		RET			;carry set if not graphic
 909:			;
 910:	03FF'         	CONSTX:
 911:	03FF' 3A20FD  		LD	A,(KBCHAR)
 912:	0402' B7      		OR	A
 913:	0403' C29A04  		JP	NZ,CONB1
 914:	0406' CD6EFB  		CALL	CONSTF
 915:	0409' E601    		AND	1
 916:	040B' C9      		RET
 917:			;
 918:	FFFF'         		IF BANKED
 919:			
 920:	040C'         	SET$CTLS$MODE:
 921:				;SET CTLS STATUS OR INPUT FLAG FOR QUEUE MANAGER
 922:	040C' 21D5FB  		LD	HL,QFLAG
 923:	040F' 3640    		LD	(HL),40H
 924:	0411' E3      		EX	(SP),HL
 925:	0412' E9      		JP	(HL)
 926:			
 927:				ENDIF
 928:			;
 929:	0413'         	TEST$CTLS$MODE:
 930:				;RETURN WITH Z FLAG RESET IF CTL-S CTL-Q CHECKING DISABLED
 931:	0413' 47      		LD	B,A
 932:	0414' 3ACFFB  		LD	A,(CONMODE)
 933:	0417' E602    		AND	2
 934:	0419' 78      		LD	A,B
 935:	041A' C9      		RET
 936:			;
 937:	041B'         	CONBRK:	;check for character ready
 938:	041B' CD1304  		CALL	TEST$CTLS$MODE
 939:	041E' C2FF03  		JP	NZ,CONSTX
 940:	0421' 3A20FD  		LD	A,(KBCHAR)
 941:	0424' B7      		OR	A
 942:	0425' C25004  		JP	NZ,CONBRK1	;skip if active kbchar
 943:				;no active kbchar, check external break
 944:				;DOES BIOS HAVE TYPE AHEAD?
 945:	FFFF'         		IF BANKED
 946:	0428' 3ACCFB  		LD	A,(TYPE$AHEAD)
 947:	042B' 3C      		INC	A
 948:	042C' CAFF03  		JP	Z,CONSTX	;YES
 949:				ENDIF
 950:				;CONBRKX CALLED BY CONOUT
 951:			
 952:	042F'         	CONBRKX:
 953:				;HAS CTL-S INTERCEPT BEEN DISABLED?
 954:	042F' CD1304  		CALL	TEST$CTLS$MODE
 955:	0432' C0      		RET	NZ		;YES
 956:				;DOES KBCHAR CONTAIN CTL-S?
 957:	0433' 3A20FD  		LD	A,(KBCHAR)
 958:	0436' FE13    		CP	CTLS
 959:	0438' CA5004  		JP	Z,CONBRK1	;YES
 960:	FFFF'         		IF BANKED
 961:	043B' CD0C04  		CALL	SET$CTLS$MODE
 962:				ENDIF
 963:				;IS A CHARACTER READY FOR INPUT?
 964:	043E' CD6EFB  		CALL	CONSTF
 965:	FFFF'         		IF BANKED
 966:	0441' E1      		POP	HL
 967:	0442' 3600    		LD	(HL),0
 968:				ENDIF
 969:	0444' E601    		AND	1
 970:	0446' C8      		RET	Z		;NO
 971:				;character ready, read it
 972:	FFFF'         		IF BANKED
 973:	0447' CD0C04  		CALL	SET$CTLS$MODE
 974:				ENDIF
 975:	044A' CD74FB  		CALL	CONINF
 976:	FFFF'         		IF BANKED
 977:	044D' E1      		POP	HL
 978:	044E' 3600    		LD	(HL),0
 979:				ENDIF
 980:	0450'         	CONBRK1:
 981:	0450' FE13    		CP	CTLS
 982:	0452' C27F04  		JP	NZ,CONB0	;check stop screen function
 983:				;DOES KBCHAR CONTAIN A CTL-S?
 984:	0455' 2120FD  		LD	HL,KBCHAR
 985:	0458' BE      		CP	(HL)
 986:	0459' C25E04  		JP	NZ,CONBRK2	;NO
 987:	045C' 3600    		LD	(HL),0		; KBCHAR = 0
 988:				;found ctls, read next character
 989:	045E'         	CONBRK2:
 990:			
 991:	FFFF'         		IF BANKED
 992:	045E' CD0C04  		CALL	SET$CTLS$MODE
 993:				ENDIF
 994:	0461' CD74FB  		CALL	CONINF		;to A
 995:	FFFF'         		IF BANKED
 996:	0464' E1      		POP	HL
 997:	0465' 3600    		LD	(HL),0
 998:				ENDIF
 999:	0467' FE03    		CP	CTLC
1000:	0469' C27504  		JP	NZ,CONBRK3
1001:	046C' 3ACFFB  		LD	A,(CONMODE)
1002:	046F' E608    		AND	08H
1003:	0471' CA2903  		JP	Z,REBOOTX
1004:	0474' AF      		XOR	A
1005:	0475'         	CONBRK3:
1006:	0475' D611    		SUB	CTLQ
1007:	0477' C8      		RET	Z		; RETURN WITH A = ZERO IF CTLQ
1008:	0478' 3C      		INC	A
1009:	0479' CDA004  		CALL	CONB3
1010:	047C' C35E04  		JP	CONBRK2
1011:	047F'         	CONB0:
1012:	047F' 2120FD  		LD	HL,KBCHAR
1013:			
1014:	0482' 47      		LD	B,A
1015:				;IS CONMODE(1) TRUE?
1016:	0483' 3ACFFB  		LD	A,(CONMODE)
1017:	0486' 1F      		RRA
1018:	0487' D28E04  		JP	NC,$+7		;NO
1019:				;DOES KBCHAR = CTLC?
1020:	048A' 3E03    		LD	A,CTLC
1021:	048C' BE      		CP	(HL)
1022:	048D' C8      		RET	Z		;YES - RETURN
1023:	048E' 78      		LD	A,B
1024:			
1025:	048F' FE11    		CP	CTLQ
1026:	0491' CA9D04  		JP	Z,CONB2
1027:	0494' FE10    		CP	CTLP
1028:	0496' CA9D04  		JP	Z,CONB2
1029:				;character in accum, save it
1030:	0499' 77      		LD	(HL),A
1031:	049A'         	CONB1:
1032:				;return with true set in accumulator
1033:	049A' 3E01    		LD	A,1
1034:	049C' C9      		RET
1035:	049D'         	CONB2:
1036:	049D' AF      		XOR	A
1037:	049E' 77      		LD	(HL),A
1038:	049F' C9      		RET
1039:	04A0'         	CONB3:
1040:	04A0' CCA904  		CALL	Z,TOGGLE$LISTCP
1041:	04A3' 0E07    		LD	C,7
1042:	04A5' C47AFB  		CALL	NZ,CONOUTF
1043:	04A8' C9      		RET
1044:			;
1045:	04A9'         	TOGGLE$LISTCP:
1046:				; IS PRINTER ECHO DISABLED?
1047:	04A9' 3ACFFB  		LD	A,(CONMODE)
1048:	04AC' E614    		AND	14H
1049:	04AE' C2BB04  		JP	NZ,TOGGLE$L1	;YES
1050:	04B1' 21D4FB  		LD	HL,LISTCP
1051:	04B4' 3E01    		LD	A,1
1052:	04B6' AE      		XOR	(HL)
1053:	04B7' E601    		AND	1
1054:	04B9' 77      		LD	(HL),A
1055:	04BA' C9      		RET
1056:	04BB'         	TOGGLE$L1:
1057:	04BB' AF      		XOR	A
1058:	04BC' C9      		RET
1059:			;
1060:	04BD'         	QCONOUTF:
1061:				;DOES FX = INPUT?
1062:	04BD' 3ADFFB  		LD	A,(FX)
1063:	04C0' 3D      		DEC	A
1064:	04C1' CA7AFB  		JP	Z,CONOUTF	;YES
1065:				;IS ESCAPE SEQUENCE DECODING IN EFFECT?
1066:	04C4' 78      		LD	A,B
1067:			;;;	ANI 8		;[JCE] DRI Patch 13
1068:	04C5' E610    		AND	10H
1069:	04C7' C27AFB  		JP	NZ,SCONOUTF	;YES
1070:	04CA' C37AFB  		JP	CONOUTF
1071:			;
1072:	04CD'         	CONOUT:
1073:				;compute character position/write console char from C
1074:				;compcol = true if computing column position
1075:	04CD' 3ABC0A  		LD	A,(COMPCOL)
1076:	04D0' B7      		OR	A
1077:	04D1' C2F604  		JP	NZ,COMPOUT
1078:				;write the character, then compute the column
1079:				;write console character from C
1080:				;B ~= 0 -> ESCAPE SEQUENCE DECODING
1081:	04D4' 3ACFFB  		LD	A,(CONMODE)
1082:	04D7' E614    		AND	14H
1083:	04D9' 47      		LD	B,A
1084:	04DA' C5      		PUSH	BC
1085:				;CALL CONBRKX FOR OUTPUT FUNCTIONS ONLY
1086:	04DB' 3ADFFB  		LD	A,(FX)
1087:	04DE' 3D      		DEC	A
1088:	04DF' C42F04  		CALL	NZ,CONBRKX
1089:	04E2' C1      		POP	BC
1090:	04E3' C5      		PUSH	BC		;recall/save character
1091:	04E4' CDBD04  		CALL	QCONOUTF	;externally, to console
1092:	04E7' C1      		POP	BC
1093:				;SKIP ECHO WHEN CONMODE & 14H ~= 0
1094:	04E8' 78      		LD	A,B
1095:	04E9' B7      		OR	A
1096:	04EA' C2F604  		JP	NZ,COMPOUT
1097:	04ED' C5      		PUSH	BC		;recall/save character
1098:				;may be copying to the list device
1099:	04EE' 3AD4FB  		LD	A,(LISTCP)
1100:	04F1' B7      		OR	A
1101:	04F2' C480FB  		CALL	NZ,LISTF	;to printer, if so
1102:	04F5' C1      		POP	BC		;recall the character
1103:	04F6'         	COMPOUT:
1104:	04F6' 79      		LD	A,C		;recall the character
1105:				;and compute column position
1106:	04F7' 21B7FB  		LD	HL,COLUMN	;A = char, HL = .column
1107:	04FA' FE7F    		CP	RUBOUT
1108:	04FC' C8      		RET	Z		;no column change if nulls
1109:	04FD' 34      		INC	(HL)		;column = column + 1
1110:	04FE' FE20    		CP	' '
1111:	0500' D0      		RET	NC		;return if graphic
1112:				;not graphic, reset column position
1113:	0501' 35      		DEC	(HL)		;column = column - 1
1114:	0502' 7E      		LD	A,(HL)
1115:	0503' B7      		OR	A
1116:	0504' C8      		RET	Z		;return if at zero
1117:				;not at zero, may be backspace or end line
1118:	0505' 79      		LD	A,C		;character back to A
1119:	0506' FE08    		CP	CTLH
1120:	0508' C20D05  		JP	NZ,NOTBACKSP
1121:				;backspace character
1122:	050B' 35      		DEC	(HL)		;column = column - 1
1123:	050C' C9      		RET
1124:	050D'         	NOTBACKSP:
1125:				;not a backspace character, eol?
1126:	050D' FE0D    		CP	CR
1127:	050F' C0      		RET	NZ		;return if not
1128:				;end of line, column = 0
1129:	0510' 3600    		LD	(HL),0		;column = 0
1130:	0512' C9      		RET
1131:			;
1132:	0513'         	CTLOUT:
1133:				;send C character with possible preceding up-arrow
1134:	0513' 79      		LD	A,C
1135:	0514' CDF003  		CALL	ECHOC		;cy if not graphic (or special case)
1136:	0517' D22805  		JP	NC,TABOUT	;skip if graphic, tab, cr, lf, or ctlh
1137:				;send preceding up arrow
1138:	051A' F5      		PUSH	AF
1139:	051B' 0E5E    		LD	C,CTL
1140:	051D' CDCD04  		CALL	CONOUT		;up arrow
1141:	0520' F1      		POP	AF
1142:	0521' F640    		OR	40H		;becomes graphic letter
1143:	0523' 4F      		LD	C,A		;ready to print
1144:	FFFF'         		IF BANKED
1145:	0524' CDC005  		CALL	CHK$COLUMN
1146:	0527' C8      		RET	Z
1147:				ENDIF
1148:				;(drop through to tabout)
1149:			;
1150:	0528'         	TABOUT:
1151:				;IS FX AN INPUT FUNCTION?
1152:	0528' 3ADFFB  		LD	A,(FX)
1153:	052B' 3D      		DEC	A
1154:	052C' CA3705  		JP	Z,TABOUT1	;YES - ALWAYS EXPAND TABS FOR ECHO
1155:				;HAS TAB EXPANSION BEEN DISABLED OR
1156:				;ESCAPE SEQUENCE DECODING BEEN ENABLED?
1157:	052F' 3ACFFB  		LD	A,(CONMODE)
1158:	0532' E614    		AND	14H
1159:	0534' C2CD04  		JP	NZ,CONOUT	;YES
1160:	0537'         	TABOUT1:
1161:				;expand tabs to console
1162:	0537' 79      		LD	A,C
1163:	0538' FE09    		CP	TAB
1164:	053A' C2CD04  		JP	NZ,CONOUT	;direct to conout if not
1165:				;tab encountered, move to next tab position
1166:	053D'         	TAB0:
1167:			
1168:	FFFF'         		IF BANKED
1169:	053D' 3ADFFB  		LD	A,(FX)
1170:	0540' FE01    		CP	1
1171:	0542' C24905  		JP	NZ,TAB1
1172:	0545' CDC005  		CALL	CHK$COLUMN
1173:	0548' C8      		RET	Z
1174:	0549'         	TAB1:
1175:				ENDIF
1176:			
1177:	0549' 0E20    		LD	C,' '
1178:	054B' CDCD04  		CALL	CONOUT		;another blank
1179:	054E' 3AB7FB  		LD	A,(COLUMN)
1180:	0551' E607    		AND	111B		;column mod 8 = 0 ?
1181:	0553' C23D05  		JP	NZ,TAB0		;back for another if not
1182:	0556' C9      		RET
1183:			;
1184:			;
1185:	0557'         	BACKUP:
1186:				;back-up one screen position
1187:	0557' CD6505  		CALL	PCTLH
1188:			
1189:	FFFF'         		IF BANKED
1190:	055A' 3ABF0A  		LD	A,(COMCHR)
1191:	055D' FE01    		CP	CTLA
1192:	055F' C8      		RET	Z
1193:				ENDIF
1194:			
1195:	0560' 0E20    		LD	C,' '
1196:	0562' CD7AFB  		CALL	CONOUTF
1197:			;	(drop through to pctlh)				;
1198:	0565'         	PCTLH:
1199:				;send ctlh to console without affecting column count
1200:	0565' 0E08    		LD	C,CTLH
1201:	0567' C37AFB  		JP	CONOUTF
1202:				;ret
1203:			;
1204:	056A'         	CRLFP:
1205:				;print #, cr, lf for ctlx, ctlu, ctlr functions
1206:				;then move to strtcol (starting column)
1207:	056A' 0E23    		LD	C,'#'
1208:	056C' CDCD04  		CALL	CONOUT
1209:	056F' CD8205  		CALL	CRLF
1210:				;column = 0, move to position strtcol
1211:	0572'         	CRLFP0:
1212:	0572' 3AB7FB  		LD	A,(COLUMN)
1213:	0575' 21BD0A  		LD	HL,STRTCOL
1214:	0578' BE      		CP	(HL)
1215:	0579' D0      		RET	NC		;stop when column reaches strtcol
1216:	057A' 0E20    		LD	C,' '
1217:	057C' CDCD04  		CALL	CONOUT		;print blank
1218:	057F' C37205  		JP	CRLFP0
1219:			;;
1220:			;
1221:	0582'         	CRLF:
1222:				;carriage return line feed sequence
1223:	0582' 0E0D    		LD	C,CR
1224:	0584' CDCD04  		CALL	CONOUT
1225:	0587' 0E0A    		LD	C,LF
1226:	0589' C3CD04  		JP	CONOUT
1227:				;ret
1228:			;
1229:	058C'         	PRINT:
1230:				;print message until M(BC) = '$'
1231:	058C' 21D3FB  		LD	HL,OUTDELIM
1232:	058F' 0A      		LD	A,(BC)
1233:	0590' BE      		CP	(HL)
1234:	0591' C8      		RET	Z		;stop on $
1235:				;more to print
1236:	0592' 03      		INC	BC
1237:	0593' C5      		PUSH	BC
1238:	0594' 4F      		LD	C,A		;char to C
1239:	0595' CD2805  		CALL	TABOUT		;another character printed
1240:	0598' C1      		POP	BC
1241:	0599' C38C05  		JP	PRINT
1242:			;
1243:	059C'         	QCONIN:
1244:			
1245:	FFFF'         		IF BANKED
1246:	059C' 2A280D  		LD	HL,(APOS)
1247:	059F' 7E      		LD	A,(HL)
1248:	05A0' 322A0D  		LD	(CTLA$SW),A
1249:				ENDIF
1250:				;IS BUFFER ADDRESS = 0?
1251:	05A3' 2ABAFB  		LD	HL,(CONBUFFADD)
1252:	05A6' 7D      		LD	A,L
1253:	05A7' B4      		OR	H
1254:	05A8' CAB703  		JP	Z,CONIN		;YES
1255:				;IS CHARACTER IN BUFFER < 5?
1256:			
1257:	FFFF'         		IF BANKED
1258:	05AB' CD21FD  		CALL	QCONINX		; mov a,m with bank 1 switched in
1259:				ELSE
1261:				ENDIF
1262:			
1263:	05AE' 23      		INC	HL
1264:	05AF' B7      		OR	A
1265:	05B0' C2B605  		JP	NZ,QCONIN1	; NO
1266:	05B3' 210000  		LD	HL,0
1267:	05B6'         	QCONIN1:
1268:	05B6' 22BAFB  		LD	(CONBUFFADD),HL
1269:	05B9' 22BCFB  		LD	(CONBUFFLEN),HL
1270:	05BC' C0      		RET	NZ		; NO
1271:	05BD' C3B703  		JP	CONIN
1272:			
1273:	FFFF'         		IF BANKED
1274:			
1275:	05C0'         	CHK$COLUMN:
1276:	05C0' 3AB6FB  		LD	A,(CONWIDTH)
1277:	05C3' 5F      		LD	E,A
1278:	05C4' 3AB7FB  		LD	A,(COLUMN)
1279:	05C7' BB      		CP	E
1280:	05C8' C9      		RET
1281:			;
1282:	05C9'         	EXPAND:
1283:	05C9' EB      		EX	DE,HL
1284:	05CA' 2A280D  		LD	HL,(APOS)
1285:	05CD' EB      		EX	DE,HL
1286:	05CE'         	EXPAND1:
1287:	05CE' 1A      		LD	A,(DE)
1288:	05CF' B7      		OR	A
1289:	05D0' C8      		RET	Z
1290:	05D1' 13      		INC	DE
1291:	05D2' 23      		INC	HL
1292:	05D3' 77      		LD	(HL),A
1293:	05D4' 04      		INC	B
1294:	05D5' C3CE05  		JP	EXPAND1
1295:			;
1296:	05D8'         	COPY$XBUFF:
1297:	05D8' 78      		LD	A,B
1298:	05D9' B7      		OR	A
1299:	05DA' C8      		RET	Z
1300:	05DB' C5      		PUSH	BC
1301:	05DC' 48      		LD	C,B
1302:	05DD' E5      		PUSH	HL
1303:	05DE' EB      		EX	DE,HL
1304:	05DF' 13      		INC	DE
1305:	05E0' 21C20B  		LD	HL,XBUFF
1306:	05E3' CD290E  		CALL	MOVE
1307:	05E6' 3600    		LD	(HL),0
1308:	05E8' 22260D  		LD	(XPOS),HL
1309:	05EB' E1      		POP	HL
1310:	05EC' C1      		POP	BC
1311:	05ED' C9      		RET
1312:			;
1313:	05EE'         	COPY$CBUFF:
1314:	05EE' 3AB4FB  		LD	A,(CCP$FLGS+1)
1315:	05F1' 17      		RLA
1316:	05F2' D0      		RET	NC
1317:	05F3' 21C20B  		LD	HL,XBUFF
1318:	05F6' 11C10A  		LD	DE,CBUFF
1319:	05F9' 0C      		INC	C
1320:	05FA' C20A06  		JP	NZ,COPY$CBUFF1
1321:	05FD' EB      		EX	DE,HL
1322:	05FE' 78      		LD	A,B
1323:	05FF' B7      		OR	A
1324:	0600' C8      		RET	Z
1325:	0601' 32C00A  		LD	(CBUFF$LEN),A
1326:	0604' D5      		PUSH	DE
1327:	0605' 010F06  		LD	BC,COPY$CBUFF2
1328:	0608' C5      		PUSH	BC
1329:	0609' 47      		LD	B,A
1330:	060A'         	COPY$CBUFF1:
1331:	060A' 04      		INC	B
1332:	060B' 48      		LD	C,B
1333:	060C' C3290E  		JP	MOVE
1334:	060F'         	COPY$CBUFF2:
1335:	060F' E1      		POP	HL
1336:	0610' 2B      		DEC	HL
1337:	0611' 3600    		LD	(HL),0
1338:	0613' C9      		RET
1339:			;
1340:	0614'         	SAVE$COL:
1341:	0614' 3AB7FB  		LD	A,(COLUMN)
1342:	0617' 322C0D  		LD	(SAVE$COLUMN),A
1343:	061A' C9      		RET
1344:			;
1345:	061B'         	CLEAR$RIGHT:
1346:	061B' 3AB7FB  		LD	A,(COLUMN)
1347:	061E' 212D0D  		LD	HL,CTLA$COLUMN
1348:	0621' BE      		CP	(HL)
1349:	0622' D0      		RET	NC
1350:	0623' 0E20    		LD	C,20H
1351:	0625' CDCD04  		CALL	CONOUT
1352:	0628' C31B06  		JP	CLEAR$RIGHT
1353:			;
1354:	062B'         	REVERSE:
1355:	062B' 3A2C0D  		LD	A,(SAVE$COLUMN)
1356:	062E' 21B7FB  		LD	HL,COLUMN
1357:	0631' BE      		CP	(HL)
1358:	0632' D0      		RET	NC
1359:	0633' 0E08    		LD	C,CTLH
1360:	0635' CDCD04  		CALL	CONOUT
1361:	0638' C32B06  		JP	REVERSE
1362:			;
1363:	063B'         	CHK$BUFFER$SIZE:
1364:	063B' C5      		PUSH	BC
1365:	063C' E5      		PUSH	HL
1366:	063D' 2A280D  		LD	HL,(APOS)
1367:	0640' 1E00    		LD	E,0
1368:	0642'         	CBS1:
1369:	0642' 7E      		LD	A,(HL)
1370:	0643' B7      		OR	A
1371:	0644' CA4C06  		JP	Z,CBS2
1372:	0647' 1C      		INC	E
1373:	0648' 23      		INC	HL
1374:	0649' C34206  		JP	CBS1
1375:	064C'         	CBS2:
1376:	064C' 78      		LD	A,B
1377:	064D' 83      		ADD	A,E
1378:	064E' B9      		CP	C
1379:	064F' F5      		PUSH	AF
1380:	0650' 0E07    		LD	C,7
1381:	0652' D47AFB  		CALL	NC,CONOUTF
1382:	0655' F1      		POP	AF
1383:	0656' E1      		POP	HL
1384:	0657' C1      		POP	BC
1385:	0658' D8      		RET	C
1386:	0659' D1      		POP	DE
1387:	065A' D1      		POP	DE
1388:	065B' C3FF06  		JP	READNX
1389:			;
1390:	065E'         	REFRESH:
1391:	065E' 3A2A0D  		LD	A,(CTLA$SW)
1392:	0661' B7      		OR	A
1393:	0662' C8      		RET	Z
1394:	0663' 3ABF0A  		LD	A,(COMCHR)
1395:	0666' FE01    		CP	CTLA
1396:	0668' C8      		RET	Z
1397:	0669' FE06    		CP	CTLF
1398:	066B' C8      		RET	Z
1399:	066C' FE17    		CP	CTLW
1400:	066E' C8      		RET	Z
1401:	066F'         	REFRESH0:
1402:	066F' E5      		PUSH	HL
1403:	0670' C5      		PUSH	BC
1404:	0671' CD1406  		CALL	SAVE$COL
1405:	0674' 2A280D  		LD	HL,(APOS)
1406:	0677'         	REFRESH1:
1407:	0677' 7E      		LD	A,(HL)
1408:	0678' B7      		OR	A
1409:	0679' CA9306  		JP	Z,REFRESH2
1410:	067C' 4F      		LD	C,A
1411:	067D' CDC005  		CALL	CHK$COLUMN
1412:	0680' DA8A06  		JP	C,REFRESH05
1413:	0683' 7B      		LD	A,E
1414:	0684' 32B7FB  		LD	(COLUMN),A
1415:	0687' C39306  		JP	REFRESH2
1416:	068A'         	REFRESH05:
1417:	068A' E5      		PUSH	HL
1418:	068B' CD1305  		CALL	CTLOUT
1419:	068E' E1      		POP	HL
1420:	068F' 23      		INC	HL
1421:	0690' C37706  		JP	REFRESH1
1422:	0693'         	REFRESH2:
1423:	0693' 3AB7FB  		LD	A,(COLUMN)
1424:	0696' 322E0D  		LD	(NEW$CTLA$COL),A
1425:	0699'         	REFRESH3:
1426:	0699' CD1B06  		CALL	CLEAR$RIGHT
1427:	069C' CD2B06  		CALL	REVERSE
1428:	069F' 3A2E0D  		LD	A,(NEW$CTLA$COL)
1429:	06A2' 322D0D  		LD	(CTLA$COLUMN),A
1430:	06A5' C1      		POP	BC
1431:	06A6' E1      		POP	HL
1432:	06A7' C9      		RET
1433:			;
1434:	06A8'         	INIT$APOS:
1435:	06A8' 21250D  		LD	HL,APOSI
1436:	06AB' 22280D  		LD	(APOS),HL
1437:	06AE' AF      		XOR	A
1438:	06AF' 322A0D  		LD	(CTLA$SW),A
1439:	06B2' C9      		RET
1440:			;
1441:	06B3'         	INIT$XPOS:
1442:	06B3' 21C20B  		LD	HL,XBUFF
1443:	06B6' 22260D  		LD	(XPOS),HL
1444:	06B9' C9      		RET
1445:			;
1446:	06BA'         	SET$CTLA$COLUMN:
1447:	06BA' 212A0D  		LD	HL,CTLA$SW
1448:	06BD' 7E      		LD	A,(HL)
1449:	06BE' B7      		OR	A
1450:	06BF' C0      		RET	NZ
1451:	06C0' 34      		INC	(HL)
1452:	06C1' 3AB7FB  		LD	A,(COLUMN)
1453:	06C4' 322D0D  		LD	(CTLA$COLUMN),A
1454:	06C7' C9      		RET
1455:			;
1456:	06C8'         	READI:
1457:	06C8' CDC005  		CALL	CHK$COLUMN
1458:	06CB' D48205  		CALL	NC,CRLF
1459:	06CE' 3AC00A  		LD	A,(CBUFF$LEN)
1460:	06D1' 47      		LD	B,A
1461:	06D2' 0E00    		LD	C,0
1462:	06D4' CDEE05  		CALL	COPY$CBUFF
1463:				ELSE
1474:				ENDIF
1475:			
1476:	06D7'         	READ:	;read to info address (max length, current length, buffer)
1477:			
1478:	FFFF'         		IF BANKED
1479:	06D7' CDB306  		CALL	INIT$XPOS
1480:	06DA' CDA806  		CALL	INIT$APOS
1481:	06DD'         	READX:
1482:	06DD' CD5E06  		CALL	REFRESH
1483:	06E0' AF      		XOR	A
1484:	06E1' 322B0D  		LD	(CTLW$SW),A
1485:	06E4'         	READX1:
1486:			
1487:				ENDIF
1488:			
1489:	06E4' 3E01    		LD	A,1
1490:	06E6' 32DFFB  		LD	(FX),A
1491:	06E9' 3AB7FB  		LD	A,(COLUMN)
1492:	06EC' 32BD0A  		LD	(STRTCOL),A	;save start for ctl-x, ctl-h
1493:	06EF' 2ADBFB  		LD	HL,(INFO)
1494:	06F2' 4E      		LD	C,(HL)
1495:	06F3' 23      		INC	HL
1496:	06F4' E5      		PUSH	HL
1497:	06F5' AF      		XOR	A
1498:	06F6' 47      		LD	B,A
1499:	06F7' 32BE0A  		LD	(SAVEPOS),A
1500:	06FA' B9      		CP	C
1501:	06FB' C2FF06  		JP	NZ,$+4
1502:	06FE' 0C      		INC	C
1503:				;B = current buffer length,
1504:				;C = maximum buffer length,
1505:				;HL= next to fill - 1
1506:	06FF'         	READNX:
1507:				;read next character, BC, HL active
1508:	06FF' C5      		PUSH	BC
1509:	0700' E5      		PUSH	HL		;blen, cmax, HL saved
1510:	0701'         	READN0:
1511:			
1512:	FFFF'         		IF BANKED
1513:	0701' 3A2B0D  		LD	A,(CTLW$SW)
1514:	0704' B7      		OR	A
1515:	0705' CC9C05  		CALL	Z,QCONIN
1516:	0708'         	NXTLINE:
1517:	0708' 32BF0A  		LD	(COMCHR),A
1518:				ELSE
1520:				ENDIF
1521:			
1522:				;ani 7fh ;mask parity bit
1523:	070B' E1      		POP	HL
1524:	070C' C1      		POP	BC		;reactivate counters
1525:	070D' FE0D    		CP	CR
1526:	070F' CAE709  		JP	Z,READEN	;end of line?
1527:	0712' FE0A    		CP	LF
1528:	0714' CAE709  		JP	Z,READEN	;also end of line
1529:			
1530:	FFFF'         		IF BANKED
1531:	0717' FE06    		CP	CTLF
1532:	0719' C23507  		JP	NZ,NOT$CTLF
1533:	071C'         	DO$CTLF:
1534:	071C' CDC005  		CALL	CHK$COLUMN
1535:	071F' 1D      		DEC	E
1536:	0720' BB      		CP	E
1537:	0721' D2FF06  		JP	NC,READNX
1538:	0724'         	DO$CTLF0:
1539:	0724' EB      		EX	DE,HL
1540:	0725' 2A280D  		LD	HL,(APOS)
1541:	0728' 7E      		LD	A,(HL)
1542:	0729' B7      		OR	A
1543:	072A' CA6F07  		JP	Z,CTLW$L15
1544:	072D' 23      		INC	HL
1545:	072E' 22280D  		LD	(APOS),HL
1546:	0731' EB      		EX	DE,HL
1547:	0732' C34D09  		JP	NOTR
1548:	0735'         	NOT$CTLF:
1549:	0735' FE17    		CP	CTLW
1550:	0737' C29A07  		JP	NZ,NOT$CTLW
1551:	073A'         	DO$CTLW:
1552:	073A' EB      		EX	DE,HL
1553:	073B' 2A280D  		LD	HL,(APOS)
1554:	073E' 7E      		LD	A,(HL)
1555:	073F' B7      		OR	A
1556:	0740' CA6007  		JP	Z,CTLW$L1
1557:	0743' EB      		EX	DE,HL
1558:	0744' CDC005  		CALL	CHK$COLUMN
1559:	0747' 1D      		DEC	E
1560:	0748' BB      		CP	E
1561:	0749' EB      		EX	DE,HL
1562:	074A' DA5507  		JP	C,CTLW$L0
1563:	074D' EB      		EX	DE,HL
1564:	074E' CD6F06  		CALL	REFRESH0
1565:	0751' EB      		EX	DE,HL
1566:	0752' C36A07  		JP	CTLW$L13
1567:	0755'         	CTLW$L0:
1568:	0755' 2A280D  		LD	HL,(APOS)
1569:	0758' 7E      		LD	A,(HL)
1570:	0759' 23      		INC	HL
1571:	075A' 22280D  		LD	(APOS),HL
1572:	075D' C39107  		JP	CTLW$L3
1573:	0760'         	CTLW$L1:
1574:	0760' 212A0D  		LD	HL,CTLA$SW
1575:	0763' 7E      		LD	A,(HL)
1576:	0764' 3600    		LD	(HL),0
1577:	0766' B7      		OR	A
1578:	0767' CA7307  		JP	Z,CTLW$L2
1579:	076A'         	CTLW$L13:
1580:	076A' 212B0D  		LD	HL,CTLW$SW
1581:	076D' 3600    		LD	(HL),0
1582:	076F'         	CTLW$L15:
1583:	076F' EB      		EX	DE,HL
1584:	0770' C3FF06  		JP	READNX
1585:	0773'         	CTLW$L2:
1586:	0773' 3A2B0D  		LD	A,(CTLW$SW)
1587:	0776' B7      		OR	A
1588:	0777' C28207  		JP	NZ,CTLW$L25
1589:	077A' 78      		LD	A,B
1590:	077B' B7      		OR	A
1591:	077C' C26F07  		JP	NZ,CTLW$L15
1592:	077F' CDB306  		CALL	INIT$XPOS
1593:	0782'         	CTLW$L25:
1594:	0782' 2A260D  		LD	HL,(XPOS)
1595:	0785' 7E      		LD	A,(HL)
1596:	0786' B7      		OR	A
1597:	0787' 322B0D  		LD	(CTLW$SW),A
1598:	078A' CA6F07  		JP	Z,CTLW$L15
1599:	078D' 23      		INC	HL
1600:	078E' 22260D  		LD	(XPOS),HL
1601:	0791'         	CTLW$L3:
1602:	0791' 212B0D  		LD	HL,CTLW$SW
1603:	0794' 3617    		LD	(HL),CTLW
1604:	0796' EB      		EX	DE,HL
1605:	0797' C34D09  		JP	NOTR
1606:	079A'         	NOT$CTLW:
1607:	079A' FE01    		CP	CTLA
1608:	079C' C2C507  		JP	NZ,NOT$CTLA
1609:	079F'         	DO$CTLA:
1610:				;do we have any characters to back over?
1611:	079F' 3ABD0A  		LD	A,(STRTCOL)
1612:	07A2' 57      		LD	D,A
1613:	07A3' 3AB7FB  		LD	A,(COLUMN)
1614:	07A6' BA      		CP	D
1615:	07A7' CAFF06  		JP	Z,READNX
1616:	07AA' 32BC0A  		LD	(COMPCOL),A	;COL > 0
1617:	07AD' 78      		LD	A,B
1618:	07AE' B7      		OR	A
1619:	07AF' CA0B09  		JP	Z,LINELEN
1620:				;characters remain in buffer, backup one
1621:	07B2' 05      		DEC	B		;remove one character
1622:				;compcol > 0 marks repeat as length compute
1623:				;backup one position in xbuff
1624:	07B3' E5      		PUSH	HL
1625:	07B4' CDBA06  		CALL	SET$CTLA$COLUMN
1626:	07B7' D1      		POP	DE
1627:	07B8' 2A280D  		LD	HL,(APOS)
1628:	07BB' 2B      		DEC	HL
1629:	07BC' 22280D  		LD	(APOS),HL
1630:	07BF' 1A      		LD	A,(DE)
1631:	07C0' 77      		LD	(HL),A
1632:	07C1' EB      		EX	DE,HL
1633:	07C2' C30B09  		JP	LINELEN
1634:	07C5'         	NOT$CTLA:
1635:	07C5' FE02    		CP	CTLB
1636:	07C7' C20B08  		JP	NZ,NOT$CTLB
1637:	07CA'         	DO$CTLB:
1638:	07CA' 3ABE0A  		LD	A,(SAVEPOS)
1639:	07CD' B8      		CP	B
1640:	07CE' C2DC07  		JP	NZ,CTLB$L0
1641:	07D1' 3E17    		LD	A,CTLW
1642:	07D3' 322A0D  		LD	(CTLA$SW),A
1643:	07D6' 32BF0A  		LD	(COMCHR),A
1644:	07D9' C33A07  		JP	DO$CTLW
1645:	07DC'         	CTLB$L0:
1646:	07DC' EB      		EX	DE,HL
1647:	07DD' 2A280D  		LD	HL,(APOS)
1648:	07E0' 04      		INC	B
1649:	07E1'         	CTLB$L1:
1650:	07E1' 05      		DEC	B
1651:	07E2' 3ABE0A  		LD	A,(SAVEPOS)
1652:	07E5' B8      		CP	B
1653:	07E6' CAF007  		JP	Z,CTLB$L2
1654:	07E9' 2B      		DEC	HL
1655:	07EA' 1A      		LD	A,(DE)
1656:	07EB' 77      		LD	(HL),A
1657:	07EC' 1B      		DEC	DE
1658:	07ED' C3E107  		JP	CTLB$L1
1659:	07F0'         	CTLB$L2:
1660:	07F0' 22280D  		LD	(APOS),HL
1661:	07F3' C5      		PUSH	BC
1662:	07F4' D5      		PUSH	DE
1663:	07F5' CDBA06  		CALL	SET$CTLA$COLUMN
1664:	07F8'         	CTLB$L3:
1665:	07F8' 3AB7FB  		LD	A,(COLUMN)
1666:	07FB' 47      		LD	B,A
1667:	07FC' 3ABD0A  		LD	A,(STRTCOL)
1668:	07FF' B8      		CP	B
1669:	0800' CA0107  		JP	Z,READN0
1670:	0803' 0E08    		LD	C,CTLH
1671:	0805' CDCD04  		CALL	CONOUT
1672:	0808' C3F807  		JP	CTLB$L3
1673:	080B'         	NOT$CTLB:
1674:	080B' FE0B    		CP	CTLK
1675:	080D' C21E08  		JP	NZ,NOT$CTLK
1676:	0810' EB      		EX	DE,HL
1677:	0811' 21250D  		LD	HL,APOSI
1678:	0814' 22280D  		LD	(APOS),HL
1679:	0817' EB      		EX	DE,HL
1680:	0818' CD5E06  		CALL	REFRESH
1681:	081B' C3FF06  		JP	READNX
1682:	081E'         	NOT$CTLK:
1683:	081E' FE07    		CP	CTLG
1684:	0820' C22D08  		JP	NZ,NOT$CTLG
1685:	0823' 3A2A0D  		LD	A,(CTLA$SW)
1686:	0826' B7      		OR	A
1687:	0827' CAFF06  		JP	Z,READNX
1688:	082A' C32407  		JP	DO$CTLF0
1689:	082D'         	NOT$CTLG:
1690:				ENDIF
1691:			
1692:	082D' FE08    		CP	CTLH
1693:	082F' C25008  		JP	NZ,NOTH		;backspace?
1694:	0832' 3ACAFB  		LD	A,(CTLH$ACT)
1695:	0835' 3C      		INC	A
1696:	0836' CA5C08  		JP	Z,DO$RUBOUT
1697:	0839'         	DO$CTLH:
1698:				;do we have any characters to back over?
1699:	0839' 3ABD0A  		LD	A,(STRTCOL)
1700:	083C' 57      		LD	D,A
1701:	083D' 3AB7FB  		LD	A,(COLUMN)
1702:	0840' BA      		CP	D
1703:	0841' CAFF06  		JP	Z,READNX
1704:	0844' 32BC0A  		LD	(COMPCOL),A	;COL > 0
1705:	0847' 78      		LD	A,B
1706:	0848' B7      		OR	A
1707:	0849' CA4D08  		JP	Z,$+4
1708:				;characters remain in buffer, backup one
1709:	084C' 05      		DEC	B		;remove one character
1710:				;compcol > 0 marks repeat as length compute
1711:	084D' C30B09  		JP	LINELEN		;uses same code as repeat
1712:	0850'         	NOTH:
1713:				;not a backspace
1714:	0850' FE7F    		CP	RUBOUT
1715:	0852' C27308  		JP	NZ,NOTRUB	;rubout char?
1716:	0855' 3ACBFB  		LD	A,(RUBOUT$ACT)
1717:	0858' 3C      		INC	A
1718:	0859' CA3908  		JP	Z,DO$CTLH
1719:	085C'         	DO$RUBOUT:
1720:	FFFF'         		IF BANKED
1721:	085C' 3E7F    		LD	A,RUBOUT
1722:	085E' 32BF0A  		LD	(COMCHR),A
1723:	0861' 3A2A0D  		LD	A,(CTLA$SW)
1724:	0864' B7      		OR	A
1725:	0865' C23908  		JP	NZ,DO$CTLH
1726:				ENDIF
1727:				;rubout encountered, rubout if possible
1728:	0868' 78      		LD	A,B
1729:	0869' B7      		OR	A
1730:	086A' CAFF06  		JP	Z,READNX	;skip if len=0
1731:				;buffer has characters, resend last char
1732:	086D' 7E      		LD	A,(HL)
1733:	086E' 05      		DEC	B
1734:	086F' 2B      		DEC	HL		;A = last char
1735:				;blen=blen-1, next to fill - 1 decremented
1736:	0870' C37109  		JP	RDECH1		;act like this is an echo
1737:	0873'         	NOTRUB:
1738:				;not a rubout character, check end line
1739:	0873' FE05    		CP	CTLE
1740:	0875' C29208  		JP	NZ,NOTE		;physical end line?
1741:				;yes, save active counters and force eol
1742:	0878' C5      		PUSH	BC
1743:	0879' 78      		LD	A,B
1744:	087A' 32BE0A  		LD	(SAVEPOS),A
1745:	087D' E5      		PUSH	HL
1746:	FFFF'         		IF BANKED
1747:	087E' 3A2A0D  		LD	A,(CTLA$SW)
1748:	0881' B7      		OR	A
1749:	0882' C41B06  		CALL	NZ,CLEAR$RIGHT
1750:				ENDIF
1751:	0885' CD8205  		CALL	CRLF
1752:	FFFF'         		IF BANKED
1753:	0888' CD5E06  		CALL	REFRESH
1754:				ENDIF
1755:	088B' AF      		XOR	A
1756:	088C' 32BD0A  		LD	(STRTCOL),A	;start position = 00
1757:	088F' C30107  		JP	READN0		;for another character
1758:	0892'         	NOTE:
1759:				;not end of line, list toggle?
1760:	0892' FE10    		CP	CTLP
1761:	0894' C2A208  		JP	NZ,NOTP		;skip if not ctlp
1762:				;list toggle - change parity
1763:	0897' E5      		PUSH	HL		;save next to fill - 1
1764:	0898' C5      		PUSH	BC
1765:	0899' AF      		XOR	A
1766:	089A' CDA004  		CALL	CONB3
1767:	089D' C1      		POP	BC
1768:	089E' E1      		POP	HL
1769:	089F' C3FF06  		JP	READNX		;for another char
1770:	08A2'         	NOTP:
1771:				;not a ctlp, line delete?
1772:	08A2' FE18    		CP	CTLX
1773:	08A4' C2C408  		JP	NZ,NOTX
1774:	08A7' E1      		POP	HL		;discard start position
1775:				;loop while column > strtcol
1776:	08A8'         	BACKX:
1777:	08A8' 3ABD0A  		LD	A,(STRTCOL)
1778:	08AB' 21B7FB  		LD	HL,COLUMN
1779:	FFFF'         		IF BANKED
1780:	08AE' BE      		CP	(HL)
1781:	08AF' DABD08  		JP	C,BACKX1
1782:	08B2' 2A280D  		LD	HL,(APOS)
1783:	08B5' 7E      		LD	A,(HL)
1784:	08B6' B7      		OR	A
1785:	08B7' C2DD06  		JP	NZ,READX
1786:	08BA' C3D706  		JP	READ
1787:	08BD'         	BACKX1:
1788:				ELSE
1791:				ENDIF
1792:	08BD' 35      		DEC	(HL)		;column = column - 1
1793:	08BE' CD5705  		CALL	BACKUP		;one position
1794:	08C1' C3A808  		JP	BACKX
1795:	08C4'         	NOTX:
1796:				;not a control x, control u?
1797:				;not control-X, control-U?
1798:	08C4' FE15    		CP	CTLU
1799:	08C6' C2D508  		JP	NZ,NOTU		;skip if not
1800:	FFFF'         		IF BANKED
1801:	08C9' E3      		EX	(SP),HL
1802:	08CA' CDD805  		CALL	COPY$XBUFF
1803:	08CD' E3      		EX	(SP),HL
1804:				ENDIF
1805:				;delete line (ctlu)
1806:	08CE'         	DO$CTLU:
1807:	08CE' CD6A05  		CALL	CRLFP		;physical eol
1808:	08D1' E1      		POP	HL		;discard starting position
1809:	08D2' C3D706  		JP	READ		;to start all over
1810:	08D5'         	NOTU:
1811:				;not line delete, repeat line?
1812:	08D5' FE12    		CP	CTLR
1813:	08D7' C24D09  		JP	NZ,NOTR
1814:	08DA' AF      		XOR	A
1815:	08DB' 32BE0A  		LD	(SAVEPOS),A
1816:	FFFF'         		IF BANKED
1817:	08DE' EB      		EX	DE,HL
1818:	08DF' CDA806  		CALL	INIT$APOS
1819:	08E2' EB      		EX	DE,HL
1820:	08E3' 78      		LD	A,B
1821:	08E4' B7      		OR	A
1822:	08E5' CACE08  		JP	Z,DO$CTLU
1823:	08E8' EB      		EX	DE,HL
1824:	08E9' 2A280D  		LD	HL,(APOS)
1825:	08EC' 04      		INC	B
1826:	08ED'         	CTLR$L1:
1827:	08ED' 05      		DEC	B
1828:	08EE' CAF808  		JP	Z,CTLR$L2
1829:	08F1' 2B      		DEC	HL
1830:	08F2' 1A      		LD	A,(DE)
1831:	08F3' 77      		LD	(HL),A
1832:	08F4' 1B      		DEC	DE
1833:	08F5' C3ED08  		JP	CTLR$L1
1834:	08F8'         	CTLR$L2:
1835:	08F8' 22280D  		LD	(APOS),HL
1836:	08FB' C5      		PUSH	BC
1837:	08FC' D5      		PUSH	DE
1838:	08FD' CD6A05  		CALL	CRLFP
1839:	0900' 3E17    		LD	A,CTLW
1840:	0902' 322B0D  		LD	(CTLW$SW),A
1841:	0905' 322A0D  		LD	(CTLA$SW),A
1842:	0908' C30107  		JP	READN0
1843:				ENDIF
1844:	090B'         	LINELEN:
1845:				;repeat line, or compute line len (ctlh)
1846:				;if compcol > 0
1847:	090B' C5      		PUSH	BC
1848:	090C' CD6A05  		CALL	CRLFP		;save line length
1849:	090F' C1      		POP	BC
1850:	0910' E1      		POP	HL
1851:	0911' E5      		PUSH	HL
1852:	0912' C5      		PUSH	BC
1853:				;bcur, cmax active, beginning buff at HL
1854:	0913'         	REP0:
1855:	0913' 78      		LD	A,B
1856:	0914' B7      		OR	A
1857:	0915' CA2E09  		JP	Z,REP1		;count len to 00
1858:	0918' 23      		INC	HL
1859:	0919' 4E      		LD	C,(HL)		;next to print
1860:	091A' 05      		DEC	B
1861:	091B' D1      		POP	DE
1862:	091C' D5      		PUSH	DE
1863:	091D' 7A      		LD	A,D
1864:	091E' 90      		SUB	B
1865:	091F' 57      		LD	D,A
1866:	0920' C5      		PUSH	BC
1867:	0921' E5      		PUSH	HL		;count length down
1868:	0922' 3ABE0A  		LD	A,(SAVEPOS)
1869:	0925' BA      		CP	D
1870:	0926' DC1305  		CALL	C,CTLOUT
1871:	0929' E1      		POP	HL
1872:	092A' C1      		POP	BC		;recall remaining count
1873:	092B' C31309  		JP	REP0		;for the next character
1874:	092E'         	REP1:
1875:				;end of repeat, recall lengths
1876:				;original BC still remains pushed
1877:	092E' E5      		PUSH	HL		;save next to fill
1878:	092F' 3ABC0A  		LD	A,(COMPCOL)
1879:	0932' B7      		OR	A		;>0 if computing length
1880:	0933' CA0107  		JP	Z,READN0	;for another char if so
1881:				;column position computed for ctlh
1882:	0936' 21B7FB  		LD	HL,COLUMN
1883:	0939' 96      		SUB	(HL)		;diff > 0
1884:	093A' 32BC0A  		LD	(COMPCOL),A	;count down below
1885:				;move back compcol-column spaces
1886:	093D'         	BACKSP:
1887:				;move back one more space
1888:	093D' CD5705  		CALL	BACKUP		;one space
1889:	0940' 21BC0A  		LD	HL,COMPCOL
1890:	0943' 35      		DEC	(HL)
1891:	0944' C23D09  		JP	NZ,BACKSP
1892:	FFFF'         		IF BANKED
1893:	0947' CD5E06  		CALL	REFRESH
1894:				ENDIF
1895:	094A' C30107  		JP	READN0		;for next character
1896:	094D'         	NOTR:
1897:				;not a ctlr, place into buffer
1898:				;IS BUFFER FULL?
1899:	094D' F5      		PUSH	AF
1900:	094E' 78      		LD	A,B
1901:	094F' B9      		CP	C
1902:	0950' DA5E09  		JP	C,RDECH0	;NO
1903:				;DISCARD CHARACTER AND RING BELL
1904:	0953' F1      		POP	AF
1905:	0954' C5      		PUSH	BC
1906:	0955' E5      		PUSH	HL
1907:	0956' 0E07    		LD	C,7
1908:	0958' CD7AFB  		CALL	CONOUTF
1909:	095B' C30107  		JP	READN0
1910:	095E'         	RDECH0:
1911:			
1912:	FFFF'         		IF BANKED
1913:	095E' 3ABF0A  		LD	A,(COMCHR)
1914:	0961' FE07    		CP	CTLG
1915:	0963' CA6D09  		JP	Z,RDECH05
1916:	0966' 3A2A0D  		LD	A,(CTLA$SW)
1917:	0969' B7      		OR	A
1918:	096A' C43B06  		CALL	NZ,CHK$BUFFER$SIZE
1919:	096D'         	RDECH05:
1920:				ENDIF
1921:			
1922:	096D' F1      		POP	AF
1923:	096E' 23      		INC	HL
1924:	096F' 77      		LD	(HL),A		;character filled to mem
1925:	0970' 04      		INC	B		;blen = blen + 1
1926:	0971'         	RDECH1:
1927:				;look for a random control character
1928:	0971' C5      		PUSH	BC
1929:	0972' E5      		PUSH	HL		;active values saved
1930:	0973' 4F      		LD	C,A		;ready to print
1931:	FFFF'         		IF BANKED
1932:	0974' CD1406  		CALL	SAVE$COL
1933:				ENDIF
1934:	0977' CD1305  		CALL	CTLOUT		;may be up-arrow C
1935:	097A' E1      		POP	HL
1936:	097B' C1      		POP	BC
1937:	FFFF'         		IF BANKED
1938:	097C' 3ABF0A  		LD	A,(COMCHR)
1939:	097F' FE07    		CP	CTLG
1940:	0981' CA3908  		JP	Z,DO$CTLH
1941:	0984' FE7F    		CP	RUBOUT
1942:	0986' CA8C09  		JP	Z,RDECH2
1943:	0989' CD5E06  		CALL	REFRESH
1944:	098C'         	RDECH2:
1945:				ENDIF
1946:	098C' 3ACFFB  		LD	A,(CONMODE)
1947:	098F' E608    		AND	08H
1948:			;;;			JNZ NOTC	;[JCE] DRI Patch 13
1949:	0991' C29709  		JP	NZ,PATCH$064B
1950:			
1951:	0994' 7E      		LD	A,(HL)		;recall char
1952:	0995' FE03    		CP	CTLC		;set flags for reboot test
1953:	0997' 78      	PATCH$064B: LD	A,B		;move length to A
1954:	0998' C2A009  		JP	NZ,NOTC		;skip if not a control c
1955:	099B' FE01    		CP	1		;control C, must be length 1
1956:	099D' CA2903  		JP	Z,REBOOTX	;reboot if blen = 1
1957:				;length not one, so skip reboot
1958:	09A0'         	NOTC:
1959:				;not reboot, are we at end of buffer?
1960:	FFFF'         		IF BANKED
1961:	09A0' B9      		CP	C
1962:	09A1' D2E009  		JP	NC,BUFFER$FULL
1963:				ELSE
1965:				ENDIF
1966:			
1967:	FFFF'         		IF BANKED
1968:	09A4' C5      		PUSH	BC
1969:	09A5' E5      		PUSH	HL
1970:	09A6' CDC005  		CALL	CHK$COLUMN
1971:	09A9' DA0107  		JP	C,READN0
1972:	09AC' 3A2A0D  		LD	A,(CTLA$SW)
1973:	09AF' B7      		OR	A
1974:	09B0' CAC009  		JP	Z,DO$NEWLINE
1975:	09B3' 3ABF0A  		LD	A,(COMCHR)
1976:	09B6' FE17    		CP	CTLW
1977:	09B8' CAC509  		JP	Z,BACK$ONE
1978:	09BB' FE06    		CP	CTLF
1979:	09BD' CAC509  		JP	Z,BACK$ONE
1980:			
1981:	09C0'         	DO$NEWLINE:
1982:	09C0' 3E05    		LD	A,CTLE
1983:	09C2' C30807  		JP	NXTLINE
1984:			
1985:	09C5'         	BACK$ONE:
1986:				;back up to previous character
1987:	09C5' E1      		POP	HL
1988:	09C6' C1      		POP	BC
1989:	09C7' 05      		DEC	B
1990:	09C8' EB      		EX	DE,HL
1991:	09C9' 2A280D  		LD	HL,(APOS)
1992:	09CC' 2B      		DEC	HL
1993:	09CD' 22280D  		LD	(APOS),HL
1994:	09D0' 1A      		LD	A,(DE)
1995:	09D1' 77      		LD	(HL),A
1996:	09D2' EB      		EX	DE,HL
1997:	09D3' 2B      		DEC	HL
1998:	09D4' C5      		PUSH	BC
1999:	09D5' E5      		PUSH	HL
2000:	09D6' CD2B06  		CALL	REVERSE
2001:				;disable ctlb or ctlw
2002:	09D9' AF      		XOR	A
2003:	09DA' 322B0D  		LD	(CTLW$SW),A
2004:	09DD' C30107  		JP	READN0
2005:			
2006:	09E0'         	BUFFER$FULL:
2007:	09E0' AF      		XOR	A
2008:	09E1' 322B0D  		LD	(CTLW$SW),A
2009:	09E4' C3FF06  		JP	READNX
2010:				ENDIF
2011:	09E7'         	READEN:
2012:				;end of read operation, store blen
2013:	FFFF'         		IF BANKED
2014:	09E7' CDC905  		CALL	EXPAND
2015:				ENDIF
2016:	09EA' E1      		POP	HL
2017:	09EB' 70      		LD	(HL),B		;M(current len) = B
2018:	FFFF'         		IF BANKED
2019:	09EC' C5      		PUSH	BC
2020:	09ED' CDD805  		CALL	COPY$XBUFF
2021:	09F0' C1      		POP	BC
2022:	09F1' 0EFF    		LD	C,0FFH
2023:	09F3' CDEE05  		CALL	COPY$CBUFF
2024:				ENDIF
2025:	09F6' 210000  		LD	HL,0
2026:	09F9' 22BAFB  		LD	(CONBUFFADD),HL
2027:	09FC' 0E0D    		LD	C,CR
2028:	09FE' C3CD04  		JP	CONOUT		;return carriage
2029:				;ret
2030:			;
2031:	03C2'         	FUNC1	EQU	CONECH
2032:				;return console character with echo
2033:			;
2034:	0528'         	FUNC2 	EQU	TABOUT
2035:				;write console character with tab expansion
2036:			;
2037:	0A01'         	FUNC3:
2038:				;return reader character
2039:	0A01' CD15FF  		CALL	READERF
2040:	0A04' C3720A  		JP	STA$RET
2041:			;
2042:			;func4:	equated to punchf
2043:				;write punch character
2044:			;
2045:			;func5:	equated to listf
2046:				;write list character
2047:				;write to list device
2048:			;
2049:	0A07'         	FUNC6:
2050:				;direct console i/o - read if 0ffh
2051:	0A07' 79      		LD	A,C
2052:	0A08' 3C      		INC	A
2053:	0A09' CA200A  		JP	Z,DIRINP	;0ffh => 00h, means input mode
2054:	0A0C' 3C      		INC	A
2055:	0A0D' CA170A  		JP	Z,DIRSTAT	;0feh => direct STATUS function
2056:	0A10' 3C      		INC	A
2057:	0A11' CA250A  		JP	Z,DIRINP1	;0fdh => direct input, no status
2058:	0A14' C37AFB  		JP	CONOUTF
2059:	0A17'         	DIRSTAT:
2060:				;0feH in C for status
2061:	0A17' CDFF03  		CALL	CONSTX
2062:	0A1A' C2C015  		JP	NZ,LRET$EQ$FF
2063:	0A1D' C3720A  		JP	STA$RET
2064:	0A20'         	DIRINP:
2065:	0A20' CDFF03  		CALL	CONSTX		;status check
2066:	0A23' B7      		OR	A
2067:	0A24' C8      		RET	Z		;skip, return 00 if not ready
2068:				;character is ready, get it
2069:	0A25'         	DIRINP1:
2070:	0A25' CDB703  		CALL	CONIN		;to A
2071:	0A28' C3720A  		JP	STA$RET
2072:			;
2073:	0A2B'         	FUNC7:
2074:	0A2B' CD36FF  		CALL	AUXINSTF
2075:	0A2E' C3720A  		JP	STA$RET
2076:			;
2077:	0A31'         	FUNC8:
2078:	0A31' CD39FF  		CALL	AUXOUTSTF
2079:	0A34' C3720A  		JP	STA$RET
2080:			;
2081:	0A37'         	FUNC9:
2082:				;write line until $ encountered
2083:	0A37' EB      		EX	DE,HL		;was lhld info
2084:	0A38' 4D      		LD	C,L
2085:	0A39' 44      		LD	B,H		;BC=string address
2086:	0A3A' C38C05  		JP	PRINT		;out to console
2087:			
2088:	06C8'         	FUNC10	EQU	READI
2089:				;read a buffered console line
2090:			
2091:	0A3D'         	FUNC11:
2092:				;IS CONMODE(1) TRUE?
2093:	0A3D' 3ACFFB  		LD	A,(CONMODE)
2094:	0A40' 1F      		RRA
2095:	0A41' D26F0A  		JP	NC,NORMAL$STATUS;NO
2096:				;CTL-C ONLY STATUS CHECK
2097:	FFFF'         		IF BANKED
2098:	0A44' 21D5FB  		LD	HL,QFLAG
2099:	0A47' 3680    		LD	(HL),80H
2100:	0A49' E5      		PUSH	HL
2101:				ENDIF
2102:	0A4A' 21680A  		LD	HL,CTLC$STAT$RET
2103:	0A4D' E5      		PUSH	HL
2104:				;DOES KBCHAR = CTL-C?
2105:	0A4E' 3A20FD  		LD	A,(KBCHAR)
2106:	0A51' FE03    		CP	CTLC
2107:	0A53' CA9A04  		JP	Z,CONB1		;YES
2108:				;IS THERE A READY CHARACTER?
2109:	0A56' CD6EFB  		CALL	CONSTF
2110:	0A59' B7      		OR	A
2111:	0A5A' C8      		RET	Z		;NO
2112:				;IS THE READY CHARACTER A CTL-C?
2113:	0A5B' CD74FB  		CALL	CONINF
2114:	0A5E' FE03    		CP	CTLC
2115:	0A60' CA7F04  		JP	Z,CONB0		;YES
2116:	0A63' 3220FD  		LD	(KBCHAR),A
2117:	0A66' AF      		XOR	A
2118:	0A67' C9      		RET
2119:			
2120:	0A68'         	CTLC$STAT$RET:
2121:			
2122:	FFFF'         		IF BANKED
2123:	0A68' CD720A  		CALL	STA$RET
2124:	0A6B' E1      		POP	HL
2125:	0A6C' 3600    		LD	(HL),0
2126:	0A6E' C9      		RET
2127:				ELSE
2129:				ENDIF
2130:			
2131:	0A6F'         	NORMAL$STATUS:
2132:				;check console status
2133:	0A6F' CD1B04  		CALL	CONBRK
2134:				;(drop through to sta$ret)
2135:	0A72'         	STA$RET:
2136:				;store the A register to aret
2137:	0A72' 329F0D  		LD	(ARET),A
2138:	0A75'         	FUNC$RET: ;
2139:	0A75' C9      		RET			;jmp goback (pop stack for non cp/m functions)
2140:			;
2141:	0A76'         	SETLRET1:
2142:				;set lret = 1
2143:	0A76' 3E01    		LD	A,1
2144:	0A78' C3720A  		JP	STA$RET		;
2145:			;
2146:	0A7B'         	FUNC109:;GET/SET CONSOLE MODE
2147:				;DOES DE = 0FFFFH?
2148:	0A7B' 7A      		LD	A,D
2149:	0A7C' A3      		AND	E
2150:	0A7D' 3C      		INC	A
2151:	0A7E' 2ACFFB  		LD	HL,(CONMODE)
2152:	0A81' CA2924  		JP	Z,STHL$RET	;YES - RETURN CONSOLE MODE
2153:	0A84' EB      		EX	DE,HL
2154:	0A85' 22CFFB  		LD	(CONMODE),HL
2155:	0A88' C9      		RET			;NO - SET CONSOLE MODE
2156:			;
2157:	0A89'         	FUNC110:;GET/SET FUNCTION 9 DELIMITER
2158:	0A89' 21D3FB  		LD	HL,OUTDELIM
2159:				;DOES DE = 0FFFFH?
2160:	0A8C' 7A      		LD	A,D
2161:	0A8D' A3      		AND	E
2162:	0A8E' 3C      		INC	A
2163:	0A8F' 7E      		LD	A,(HL)
2164:	0A90' CA720A  		JP	Z,STA$RET	;YES - RETURN DELIMITER
2165:	0A93' 73      		LD	(HL),E
2166:	0A94' C9      		RET			;NO - SET DELIMITER
2167:			;
2168:	0A95'         	FUNC111:;PRINT BLOCK TO CONSOLE
2169:	0A95'         	FUNC112:;LIST BLOCK
2170:	0A95' EB      		EX	DE,HL
2171:	0A96' 5E      		LD	E,(HL)
2172:	0A97' 23      		INC	HL
2173:	0A98' 56      		LD	D,(HL)
2174:	0A99' 23      		INC	HL
2175:	0A9A' 4E      		LD	C,(HL)
2176:	0A9B' 23      		INC	HL
2177:	0A9C' 46      		LD	B,(HL)
2178:	0A9D' EB      		EX	DE,HL
2179:				;HL = ADDR OF STRING
2180:				;BC = LENGTH OF STRING
2181:	0A9E'         	BLK$OUT:
2182:	0A9E' 78      		LD	A,B
2183:	0A9F' B1      		OR	C
2184:	0AA0' C8      		RET	Z
2185:	0AA1' C5      		PUSH	BC
2186:	0AA2' E5      		PUSH	HL
2187:	0AA3' 4E      		LD	C,(HL)
2188:	0AA4' 3ADFFB  		LD	A,(FX)
2189:	0AA7' FE6F    		CP	111
2190:	0AA9' CAB20A  		JP	Z,BLK$OUT1
2191:	0AAC' CD80FB  		CALL	LISTF
2192:	0AAF' C3B50A  		JP	BLK$OUT2
2193:	0AB2'         	BLK$OUT1:
2194:	0AB2' CD2805  		CALL	TABOUT
2195:	0AB5'         	BLK$OUT2:
2196:	0AB5' E1      		POP	HL
2197:	0AB6' 23      		INC	HL
2198:	0AB7' C1      		POP	BC
2199:	0AB8' 0B      		DEC	BC
2200:	0AB9' C39E0A  		JP	BLK$OUT
2201:			
2202:	FB7A'         	SCONOUTF EQU	CONOUTF
2203:			
2204:			;
2205:			;	data areas
2206:			;
2207:	0ABC' 00      	COMPCOL:DEFB	0		;true if computing column position
2208:	0ABD' 00      	STRTCOL:DEFB	0		;starting column position after read
2209:			
2210:	0000'         		IF NOT BANKED
2214:				ENDIF
2215:			
2216:	0ABE' 00      	SAVEPOS:DEFB	0		;POSITION IN BUFFER CORRESPONDING TO
2217:				;BEGINNING OF LINE
2218:	FFFF'         		IF BANKED
2219:			
2220:	0ABF' 00      	COMCHR:	DEFB	0
2221:	0AC0' 00      	CBUFF$LEN: DEFB	0
2222:	0AC1'         	CBUFF:	DEFS	256
2223:	0BC1' 00      		DEFB	0
2224:	0BC2' 00      	XBUFF:	DEFB	0
2225:	0BC3'         		DEFS	354
2226:	0D25' 00      	APOSI:	DEFB	0
2227:	0D26' 0000    	XPOS:	DEFW	0
2228:	0D28' 0000    	APOS:	DEFW	0
2229:	0D2A' 00      	CTLA$SW:DEFB	0
2230:	0D2B' 00      	CTLW$SW:DEFB	0
2231:	0D2C' 00      	SAVE$COLUMN: DEFB	0
2232:	0D2D' 00      	CTLA$COLUMN: DEFB	0
2233:	0D2E' 00      	NEW$CTLA$COL: DEFB	0
2234:			
2235:				ENDIF
2236:			
2237:			;	end of BDOS Console module
2238:			
2239:			;
2240:			;**********************************************************************
2241:			;*****************************************************************
2242:			;
2243:			;	Error Messages
2244:			
2245:	FFFF'         		IF BANKED
2246:			
2247:	0000'         	MD	EQU	0
2248:			
2249:				ELSE
2253:				ENDIF
2254:			
2255:	0D2F' 43502F4D	DSKMSG:	DEFB	'CP/M Error On '
	      20457272
	      6F72204F
	      6E20
2256:	0D3D' 203A2000	DSKERR:	DEFB	' : ',MD
2257:	0D41' 4469736B	PERMSG:	DEFB	'Disk I/O',MD
	      20492F4F
	      00
2258:	0D4A' 496E7661	SELMSG:	DEFB	'Invalid Drive',MD
	      6C696420
	      44726976
	      6500
2259:	0D58' 52656164	ROFMSG:	DEFB	'Read/Only File',MD
	      2F4F6E6C
	      79204669
	      6C6500
2260:	0D67' 52656164	RODMSG:	DEFB	'Read/Only Disk',MD
	      2F4F6E6C
	      79204469
	      736B00
2261:			
2262:	FFFF'         		IF NOT MPM
2263:			
2264:	0D76'         	PASSMSG:
2265:			
2266:	FFFF'         		IF BANKED
2267:	0D76' 50617373		DEFB	'Password Error',MD
	      776F7264
	      20457272
	      6F7200
2268:				ENDIF
2269:			
2270:	0D85'         	FXSTSMSG:
2271:	0D85' 46696C65		DEFB	'File Exists',MD
	      20457869
	      73747300
2272:			
2273:	0D91'         	WILDMSG:
2274:	0D91' 3F20696E		DEFB	'? in Filename',MD
	      2046696C
	      656E616D
	      6500
2275:			
2276:				ENDIF
2277:			
2278:	0000'         		IF MPM
2288:				ENDIF
2289:			
2290:			;*****************************************************************
2291:			;*****************************************************************
2292:			;
2293:			;	common values shared between bdosi and bdos
2294:			
2295:	0000'         		IF MPM
2299:				ENDIF
2300:			
2301:	0D9F'         	ARET:	DEFS	2		; address value to return
2302:	0D9F'         	LRET	EQU	ARET		; low(aret)
2303:			
2304:			;*****************************************************************
2305:			;*****************************************************************
2306:			;**								**
2307:			;**   b a s i c    d i s k   o p e r a t i n g	 s y s t e m	**
2308:			;**								**
2309:			;*****************************************************************
2310:			;*****************************************************************
2311:			
2312:			;	literal constants
2313:			
2314:	FFFF'         	ENDDIR	EQU	0FFFFH		; end of directory
2315:	0001'         	LBYTE	EQU	1		; number of bytes for "byte" type
2316:	0002'         	LWORD	EQU	2		; number of bytes for "word" type
2317:			
2318:			;	fixed addresses in low memory
2319:			
2320:	005C'         	TFCB	EQU	005CH		; default fcb location
2321:	0080'         	TBUFF	EQU	0080H		; default buffer location
2322:			
2323:			;	error message handlers
2324:			
2325:	0DA1'         	ROD$ERROR:
2326:				; report read/only disk error
2327:	0DA1' 0E02    		LD	C,2
2328:	0DA3' C3B20D  		JP	GOERR
2329:			
2330:	0DA6'         	ROF$ERROR:
2331:				; report read/only file error
2332:	0DA6' 0E03    		LD	C,3
2333:	0DA8' C3B20D  		JP	GOERR
2334:			
2335:	0DAB'         	SEL$ERROR:
2336:				; report select error
2337:	0DAB' 0E04    		LD	C,4
2338:				; Invalidate curdsk to force select call
2339:				; at next curselect call
2340:	0DAD' 3EFF    		LD	A,0FFH
2341:	0DAF' 32A928  		LD	(CURDSK),A
2342:			
2343:	0DB2'         	GOERR:
2344:				; hl = .errorhandler, call subroutine
2345:	0DB2' 61      		LD	H,C
2346:	0DB3' 2EFF    		LD	L,0FFH
2347:	0DB5' 229F0D  		LD	(ARET),HL
2348:			
2349:	0000'         		IF MPM
2355:				ELSE
2356:			
2357:	0DB8'         	GOERR1:
2358:	0DB8' 3AAA28  		LD	A,(ADRIVE)
2359:	0DBB' 32EDFB  		LD	(ERRDRV),A
2360:	0DBE' 3AE7FB  		LD	A,(ERRORMODE)
2361:	0DC1' 3C      		INC	A
2362:	0DC2' C4FBFB  		CALL	NZ,ERROR
2363:				ENDIF
2364:			
2365:	0DC5'         	RTN$PHY$ERRS:
2366:			
2367:	0000'         		IF MPM
2371:				ENDIF
2372:			
2373:				; Return 0ffffh if fx = 27 or 31
2374:			
2375:	0DC5' 3ADFFB  		LD	A,(FX)
2376:	0DC8' FE1B    		CP	27
2377:	0DCA' CA3528  		JP	Z,GOBACK0
2378:	0DCD' FE1F    		CP	31
2379:	0DCF' CA3528  		JP	Z,GOBACK0
2380:	0DD2' C33B28  		JP	GOBACK
2381:			
2382:	0000'         		IF MPM
2392:				ENDIF
2393:			
2394:	FFFF'         		IF BANKED
2395:			
2396:	0DD5'         	SET$COPY$CR$ONLY:
2397:	0DD5' 3ABC28  		LD	A,(COPY$CR$INIT)
2398:	0DD8' 321DFD  		LD	(COPY$CR$ONLY),A
2399:	0DDB' C9      		RET
2400:			
2401:	0DDC'         	RESET$COPY$CR$ONLY:
2402:	0DDC' AF      		XOR	A
2403:	0DDD' 32BC28  		LD	(COPY$CR$INIT),A
2404:	0DE0' 321DFD  		LD	(COPY$CR$ONLY),A
2405:	0DE3' C9      		RET
2406:			
2407:				ENDIF
2408:			
2409:	0DE4'         	BDE$E$BDE$M$HL:
2410:	0DE4' 7B      		LD	A,E
2411:	0DE5' 95      		SUB	L
2412:	0DE6' 5F      		LD	E,A
2413:	0DE7' 7A      		LD	A,D
2414:	0DE8' 9C      		SBC	A,H
2415:	0DE9' 57      		LD	D,A
2416:	0DEA' D0      		RET	NC
2417:	0DEB' 05      		DEC	B
2418:	0DEC' C9      		RET
2419:			
2420:	0DED'         	BDE$E$BDE$P$HL:
2421:	0DED' 7B      		LD	A,E
2422:	0DEE' 85      		ADD	A,L
2423:	0DEF' 5F      		LD	E,A
2424:	0DF0' 7A      		LD	A,D
2425:	0DF1' 8C      		ADC	A,H
2426:	0DF2' 57      		LD	D,A
2427:	0DF3' D0      		RET	NC
2428:	0DF4' 04      		INC	B
2429:	0DF5' C9      		RET
2430:			
2431:	0DF6'         	SHL3BV:
2432:	0DF6' 0C      		INC	C
2433:	0DF7'         	SHL3BV1:
2434:	0DF7' 0D      		DEC	C
2435:	0DF8' C8      		RET	Z
2436:	0DF9' 29      		ADD	HL,HL
2437:	0DFA' 8F      		ADC	A,A
2438:	0DFB' C3F70D  		JP	SHL3BV1
2439:			
2440:	0DFE'         	INCR$RR:
2441:	0DFE' CD3710  		CALL	GET$RRA
2442:	0E01' 34      		INC	(HL)
2443:	0E02' C0      		RET	NZ
2444:	0E03' 23      		INC	HL
2445:	0E04' 34      		INC	(HL)
2446:	0E05' C0      		RET	NZ
2447:	0E06' 23      		INC	HL
2448:	0E07' 34      		INC	(HL)
2449:	0E08' C9      		RET
2450:			
2451:	0E09'         	SAVE$RR:
2452:	0E09' CD120E  		CALL	SAVE$RR2
2453:	0E0C' EB      		EX	DE,HL
2454:	0E0D'         	SAVE$RR1:
2455:	0E0D' 0E03    		LD	C,3
2456:	0E0F' C3290E  		JP	MOVE		; ret
2457:	0E12'         	SAVE$RR2:
2458:	0E12' CD3710  		CALL	GET$RRA
2459:	0E15' 11AE28  		LD	DE,SAVE$RANR
2460:	0E18' C9      		RET
2461:			
2462:	0E19'         	RESET$RR:
2463:	0E19' CD120E  		CALL	SAVE$RR2
2464:	0E1C' C30D0E  		JP	SAVE$RR1	; ret
2465:			
2466:	0E1F'         	COMPARE:
2467:	0E1F' 1A      		LD	A,(DE)
2468:	0E20' BE      		CP	(HL)
2469:	0E21' C0      		RET	NZ
2470:	0E22' 23      		INC	HL
2471:	0E23' 13      		INC	DE
2472:	0E24' 0D      		DEC	C
2473:	0E25' C8      		RET	Z
2474:	0E26' C31F0E  		JP	COMPARE
2475:			
2476:			;
2477:			;	local subroutines for bios interface
2478:			;
2479:			
2480:	0E29'         	MOVE:
2481:				; Move data length of length c from source de to
2482:				; destination given by hl
2483:	0E29' 0C      		INC	C		; in case it is zero
2484:	0E2A'         	MOVE0:
2485:	0E2A' 0D      		DEC	C
2486:	0E2B' C8      		RET	Z		; more to move
2487:	0E2C' 1A      		LD	A,(DE)
2488:	0E2D' 77      		LD	(HL),A		; one byte moved
2489:	0E2E' 13      		INC	DE
2490:	0E2F' 23      		INC	HL		; to next byte
2491:	0E30' C32A0E  		JP	MOVE0
2492:			
2493:	0E33'         	SELECTDISK:
2494:				; Select the disk drive given by register D, and fill
2495:				; the base addresses curtrka - alloca, then fill
2496:				; the values of the disk parameter block
2497:	0E33' 4A      		LD	C,D		; current disk# to c
2498:				; lsb of e = 0 if not yet logged - in
2499:	0E34' CD1BFF  		CALL	SELDSKF		; hl filled by call
2500:				; hl = 0000 if error, otherwise disk headers
2501:	0E37' 7C      		LD	A,H
2502:	0E38' B5      		OR	L
2503:	0E39' C8      		RET	Z		; Return with C flag reset if select error
2504:				; Disk header block address in hl
2505:	0E3A' 5E      		LD	E,(HL)
2506:	0E3B' 23      		INC	HL
2507:	0E3C' 56      		LD	D,(HL)
2508:	0E3D' 23      		INC	HL		; de=.tran
2509:	0E3E' 226928  		LD	(CDRMAXA),HL
2510:	0E41' 23      		INC	HL
2511:	0E42' 23      		INC	HL		; .cdrmax
2512:	0E43' 226B28  		LD	(CURTRKA),HL
2513:	0E46' 23      		INC	HL
2514:	0E47' 23      		INC	HL		; hl=.currec
2515:	0E48' 226D28  		LD	(CURRECA),HL
2516:	0E4B' 23      		INC	HL
2517:	0E4C' 23      		INC	HL		; hl=.buffa
2518:	0E4D' 23      		INC	HL
2519:	0E4E' 226F28  		LD	(DRVLBLA),HL
2520:	0E51' 23      		INC	HL
2521:	0E52' 227128  		LD	(LSN$ADD),HL
2522:	0E55' 23      		INC	HL
2523:	0E56' 23      		INC	HL
2524:				; de still contains .tran
2525:	0E57' EB      		EX	DE,HL
2526:	0E58' 229A28  		LD	(TRANV),HL	; .tran vector
2527:	0E5B' 217328  		LD	HL,DPBADDR	; de= source for move, hl=dest
2528:	0E5E' 0E0D    		LD	C,ADDLIST
2529:	0E60' CD290E  		CALL	MOVE		; addlist filled
2530:				; Now fill the disk parameter block
2531:	0E63' 2A7328  		LD	HL,(DPBADDR)
2532:	0E66' EB      		EX	DE,HL		; de is source
2533:	0E67' 218028  		LD	HL,SECTPT	; hl is destination
2534:	0E6A' 0E11    		LD	C,DPBLIST
2535:	0E6C' CD290E  		CALL	MOVE		; data filled
2536:				; Now set single/double map mode
2537:	0E6F' 2A8528  		LD	HL,(MAXALL)	; largest allocation number
2538:	0E72' 7C      		LD	A,H		; 00 indicates < 255
2539:	0E73' 21A328  		LD	HL,SINGLE
2540:	0E76' 36FF    		LD	(HL),TRUE	; Assume a=00
2541:	0E78' B7      		OR	A
2542:	0E79' CA7E0E  		JP	Z,RETSELECT
2543:				; high order of maxall not zero, use double dm
2544:	0E7C' 3600    		LD	(HL),FALSE
2545:	0E7E'         	RETSELECT:
2546:				; C flag set indicates successful select
2547:	0E7E' 37      		SCF
2548:	0E7F' C9      		RET
2549:			
2550:	0E80'         	HOME:
2551:				; Move to home position, then offset to start of dir
2552:	0E80' CD18FF  		CALL	HOMEF
2553:	0E83' AF      		XOR	A		; constant zero to accumulator
2554:	0E84' 2A6B28  		LD	HL,(CURTRKA)
2555:	0E87' 77      		LD	(HL),A
2556:	0E88' 23      		INC	HL
2557:	0E89' 77      		LD	(HL),A		; curtrk=0000
2558:	0E8A' 2A6D28  		LD	HL,(CURRECA)
2559:	0E8D' 77      		LD	(HL),A
2560:	0E8E' 23      		INC	HL
2561:	0E8F' 77      		LD	(HL),A		; currec=0000
2562:	0E90' 23      		INC	HL
2563:	0E91' 77      		LD	(HL),A		; currec high byte=00
2564:			
2565:	0000'         		IF MPM
2568:				ENDIF
2569:			
2570:	0E92' C9      		RET
2571:			
2572:	0E93'         	RDBUFF:
2573:				; Read buffer and check condition
2574:	0E93' 3E01    		LD	A,1
2575:	0E95' 32B428  		LD	(READF$SW),A
2576:	0E98' CD27FF  		CALL	READF		; current drive, track, sector, dma
2577:	0E9B' C3A50E  		JP	DIOCOMP		; Check for i/o errors
2578:			
2579:	0E9E'         	WRBUFF:
2580:				; Write buffer and check condition
2581:				; write type (wrtype) is in register c
2582:	0E9E' AF      		XOR	A
2583:	0E9F' 32B428  		LD	(READF$SW),A
2584:	0EA2' CD2AFF  		CALL	WRITEF		; current drive, track, sector, dma
2585:	0EA5'         	DIOCOMP:; Check for disk errors
2586:	0EA5' B7      		OR	A
2587:	0EA6' C8      		RET	Z
2588:	0EA7' 4F      		LD	C,A
2589:	0EA8' CDB60E  		CALL	CHK$MEDIA$FLAG
2590:	0EAB' 79      		LD	A,C
2591:	0EAC' FE03    		CP	3
2592:	0EAE' DAB20D  		JP	C,GOERR
2593:	0EB1' 0E01    		LD	C,1
2594:	0EB3' C3B20D  		JP	GOERR
2595:			
2596:	0EB6'         	CHK$MEDIA$FLAG:
2597:				; A = 0ffh -> media changed
2598:	0EB6' 3C      		INC	A
2599:	0EB7' C0      		RET	NZ
2600:			
2601:	FFFF'         		IF BANKED
2602:				; Handle media changes as I/O errors for
2603:				; permanent drives
2604:	0EB8' CDEB0E  		CALL	CHKSIZ$EQ$8000H
2605:	0EBB' C8      		RET	Z
2606:				ENDIF
2607:			
2608:				; BIOS says media change occurred
2609:				; Is disk logged-in?
2610:	0EBC' 2A6528  		LD	HL,(DLOG)
2611:	0EBF' CD1D11  		CALL	TESTVECTOR
2612:	0EC2' 0E01    		LD	C,1
2613:	0EC4' C8      		RET	Z		; no - return error
2614:	0EC5' CDB211  		CALL	MEDIA$CHANGE
2615:	0EC8' E1      		POP	HL		; Discard return address
2616:				; Was this a flush operation (fx = 48)?
2617:	0EC9' 3ADFFB  		LD	A,(FX)
2618:	0ECC' FE30    		CP	48
2619:	0ECE' C8      		RET	Z		; yes
2620:				; Is this a flush to another drive?
2621:	0ECF' 21AA28  		LD	HL,ADRIVE
2622:	0ED2' 3AA428  		LD	A,(SELDSK)
2623:	0ED5' BE      		CP	(HL)
2624:	0ED6' C2E60E  		JP	NZ,RESET$RELOG
2625:				; Bail out if fx = read, write, close, or search next
2626:	0ED9' CD1312  		CALL	CHK$EXIT$FXS
2627:				; Is this a directory read operation?
2628:	0EDC' 3AB428  		LD	A,(READF$SW)
2629:	0EDF' B7      		OR	A
2630:	0EE0' C0      		RET	NZ		; yes
2631:				; Error - directory write operation
2632:	0EE1' 0E02    		LD	C,2
2633:	0EE3' C3B20D  		JP	GOERR		; Return disk read/only error
2634:			
2635:	0EE6'         	RESET$RELOG:
2636:				; Reset relog if flushing to another drive
2637:	0EE6' AF      		XOR	A
2638:	0EE7' 32DEFB  		LD	(RELOG),A
2639:	0EEA' C9      		RET
2640:			
2641:	FFFF'         		IF BANKED
2642:			
2643:	0EEB'         	CHKSIZ$EQ$8000H:
2644:				; Return with Z flag set if drive permanent
2645:				; with no checksum vector
2646:	0EEB' 2A8B28  		LD	HL,(CHKSIZ)
2647:	0EEE' 3E80    		LD	A,80H
2648:	0EF0' BC      		CP	H
2649:	0EF1' C0      		RET	NZ
2650:	0EF2' AF      		XOR	A
2651:	0EF3' BD      		CP	L
2652:	0EF4' C9      		RET
2653:			
2654:				ENDIF
2655:			
2656:	0EF5'         	SEEKDIR:
2657:				; Seek the record containing the current dir entry
2658:			
2659:	0000'         		IF MPM
2676:				ENDIF
2677:			
2678:	0EF5' 2AE1FB  		LD	HL,(DCNT)	; directory counter to hl
2679:	0EF8' 0E02    		LD	C,DSKSHF
2680:	0EFA' CDAB10  		CALL	HLROTR		; value to hl
2681:	0EFD' 229128  		LD	(DREC),HL
2682:			
2683:	0000'         		IF MPM
2697:				ELSE
2698:	0F00' 0600    		LD	B,0
2699:	0F02' EB      		EX	DE,HL
2700:				ENDIF
2701:			
2702:	0F03'         	SET$ARECORD:
2703:	0F03' 21AB28  		LD	HL,ARECORD
2704:	0F06' 73      		LD	(HL),E
2705:	0F07' 23      		INC	HL
2706:	0F08' 72      		LD	(HL),D
2707:	0F09' 23      		INC	HL
2708:	0F0A' 70      		LD	(HL),B
2709:	0F0B' C9      		RET
2710:			
2711:	0F0C'         	SEEK:
2712:				; Seek the track given by arecord (actual record)
2713:			
2714:	0F0C' 2A6B28  		LD	HL,(CURTRKA)
2715:	0F0F' 4E      		LD	C,(HL)
2716:	0F10' 23      		INC	HL
2717:	0F11' 46      		LD	B,(HL)		; bc = curtrk
2718:	0F12' C5      		PUSH	BC		; s0 = curtrk
2719:	0F13' 2A6D28  		LD	HL,(CURRECA)
2720:	0F16' 5E      		LD	E,(HL)
2721:	0F17' 23      		INC	HL
2722:	0F18' 56      		LD	D,(HL)
2723:	0F19' 23      		INC	HL
2724:	0F1A' 46      		LD	B,(HL)		; bde = currec
2725:	0F1B' 2AAB28  		LD	HL,(ARECORD)
2726:	0F1E' 3AAD28  		LD	A,(ARECORD+2)
2727:	0F21' 4F      		LD	C,A		; chl = arecord
2728:	0F22'         	SEEK0:
2729:	0F22' 7D      		LD	A,L
2730:	0F23' 93      		SUB	E
2731:	0F24' 7C      		LD	A,H
2732:	0F25' 9A      		SBC	A,D
2733:	0F26' 79      		LD	A,C
2734:	0F27' 98      		SBC	A,B
2735:	0F28' E5      		PUSH	HL		; Save low(arecord)
2736:	0F29' D2390F  		JP	NC,SEEK1	; if arecord >= currec then go to seek1
2737:	0F2C' 2A8028  		LD	HL,(SECTPT)
2738:	0F2F' CDE40D  		CALL	BDE$E$BDE$M$HL	; currec = currec - sectpt
2739:	0F32' E1      		POP	HL
2740:	0F33' E3      		EX	(SP),HL
2741:	0F34' 2B      		DEC	HL
2742:	0F35' E3      		EX	(SP),HL		; curtrk = curtrk - 1
2743:	0F36' C3220F  		JP	SEEK0
2744:	0F39'         	SEEK1:
2745:	0F39' 2A8028  		LD	HL,(SECTPT)
2746:	0F3C' CDED0D  		CALL	BDE$E$BDE$P$HL	; currec = currec + sectpt
2747:	0F3F' E1      		POP	HL		; Restore low(arecord)
2748:	0F40' 7D      		LD	A,L
2749:	0F41' 93      		SUB	E
2750:	0F42' 7C      		LD	A,H
2751:	0F43' 9A      		SBC	A,D
2752:	0F44' 79      		LD	A,C
2753:	0F45' 98      		SBC	A,B
2754:	0F46' DA500F  		JP	C,SEEK2		; if arecord < currec then go to seek2
2755:	0F49' E3      		EX	(SP),HL
2756:	0F4A' 23      		INC	HL
2757:	0F4B' E3      		EX	(SP),HL		; curtrk = curtrk + 1
2758:	0F4C' E5      		PUSH	HL		; save low (arecord)
2759:	0F4D' C3390F  		JP	SEEK1
2760:	0F50'         	SEEK2:
2761:	0F50' E3      		EX	(SP),HL
2762:	0F51' E5      		PUSH	HL		; hl,s0 = curtrk, s1 = low(arecord)
2763:	0F52' 2A8028  		LD	HL,(SECTPT)
2764:	0F55' CDE40D  		CALL	BDE$E$BDE$M$HL	; currec = currec - sectpt
2765:	0F58' E1      		POP	HL
2766:	0F59' D5      		PUSH	DE
2767:	0F5A' C5      		PUSH	BC
2768:	0F5B' E5      		PUSH	HL		; hl,s0 = curtrk,
2769:				; s1 = high(arecord,currec), s2 = low(currec),
2770:				; s3 = low(arecord)
2771:	0F5C' EB      		EX	DE,HL
2772:	0F5D' 2A8D28  		LD	HL,(OFFSET)
2773:	0F60' 19      		ADD	HL,DE
2774:	0F61' 44      		LD	B,H
2775:	0F62' 4D      		LD	C,L
2776:	0F63' 22FB28  		LD	(TRACK),HL
2777:	0F66' CD1EFF  		CALL	SETTRKF		; call bios settrk routine
2778:				; Store curtrk
2779:	0F69' D1      		POP	DE
2780:	0F6A' 2A6B28  		LD	HL,(CURTRKA)
2781:	0F6D' 73      		LD	(HL),E
2782:	0F6E' 23      		INC	HL
2783:	0F6F' 72      		LD	(HL),D
2784:				; Store currec
2785:	0F70' C1      		POP	BC
2786:	0F71' D1      		POP	DE
2787:	0F72' 2A6D28  		LD	HL,(CURRECA)
2788:	0F75' 73      		LD	(HL),E
2789:	0F76' 23      		INC	HL
2790:	0F77' 72      		LD	(HL),D
2791:	0F78' 23      		INC	HL
2792:	0F79' 70      		LD	(HL),B		; currec = bde
2793:	0F7A' C1      		POP	BC		; bc = low(arecord), de = low(currec)
2794:	0F7B' 79      		LD	A,C
2795:	0F7C' 93      		SUB	E
2796:	0F7D' 6F      		LD	L,A		; hl = bc - de
2797:	0F7E' 78      		LD	A,B
2798:	0F7F' 9A      		SBC	A,D
2799:	0F80' 67      		LD	H,A
2800:	0F81' CD9D0F  		CALL	SHR$PHYSHF
2801:	0F84' 44      		LD	B,H
2802:	0F85' 4D      		LD	C,L
2803:			
2804:	0F86' 2A9A28  		LD	HL,(TRANV)
2805:	0F89' EB      		EX	DE,HL		; bc=sector#, de=.tran
2806:	0F8A' CD30FF  		CALL	SECTRAN		; hl = tran(sector)
2807:	0F8D' 4D      		LD	C,L
2808:	0F8E' 44      		LD	B,H		; bc = tran(sector)
2809:	0F8F' 22FD28  		LD	(SECTOR),HL
2810:	0F92' CD21FF  		CALL	SETSECF		; sector selected
2811:	0F95' 2A1BFD  		LD	HL,(CURDMA)
2812:	0F98' 4D      		LD	C,L
2813:	0F99' 44      		LD	B,H
2814:	0F9A' C324FF  		JP	SETDMAF
2815:				; ret
2816:	0F9D'         	SHR$PHYSHF:
2817:	0F9D' 3A8F28  		LD	A,(PHYSHF)
2818:	0FA0' 4F      		LD	C,A
2819:	0FA1' C3AB10  		JP	HLROTR
2820:			
2821:			;	file control block (fcb) constants
2822:			
2823:	00E5'         	EMPTY	EQU	0E5H		; empty directory entry
2824:	007F'         	LSTREC	EQU	127		; last record# on extent
2825:	0080'         	RECSIZ	EQU	128		; record size
2826:	0020'         	FCBLEN	EQU	32		; file control block size
2827:	0004'         	DIRREC	EQU	RECSIZ/FCBLEN	; directory fcbs / record
2828:	0002'         	DSKSHF	EQU	2		; log2(dirrec)
2829:	0003'         	DSKMSK	EQU	DIRREC-1
2830:	0005'         	FCBSHF	EQU	5		; log2(fcblen)
2831:			
2832:	000C'         	EXTNUM	EQU	12		; extent number field
2833:	001F'         	MAXEXT	EQU	31		; largest extent number
2834:	000D'         	UBYTES	EQU	13		; unfilled bytes field
2835:	000E'         	MODNUM	EQU	14		; data module number
2836:			
2837:	0040'         	MAXMOD	EQU	64		; largest module number
2838:			
2839:	0080'         	FWFMSK	EQU	80H		; file write flag is high order modnum
2840:	000F'         	NAMLEN	EQU	15		; name length
2841:	000F'         	RECCNT	EQU	15		; record count field
2842:	0010'         	DSKMAP	EQU	16		; disk map field
2843:	001F'         	LSTFCB	EQU	FCBLEN-1
2844:	0020'         	NXTREC	EQU	FCBLEN
2845:	0021'         	RANREC	EQU	NXTREC+1	; random record field (2 bytes)
2846:			
2847:			;	reserved file indicators
2848:			
2849:	0009'         	ROFILE	EQU	9	; high order of first type char
2850:	000A'         	INVIS	EQU	10		; invisible file in dir command
2851:			
2852:			;	utility functions for file access
2853:			
2854:	0FA4'         	DM$POSITION:
2855:				; Compute disk map position for vrecord to hl
2856:	0FA4' 218228  		LD	HL,BLKSHF
2857:	0FA7' 4E      		LD	C,(HL)		; shift count to c
2858:	0FA8' 3AA828  		LD	A,(VRECORD)	; current virtual record to a
2859:	0FAB'         	DMPOS0:
2860:	0FAB' B7      		OR	A
2861:	0FAC' 1F      		RRA
2862:	0FAD' 0D      		DEC	C
2863:	0FAE' C2AB0F  		JP	NZ,DMPOS0
2864:				; a = shr(vrecord,blkshf) = vrecord/2**(sect/block)
2865:	0FB1' 47      		LD	B,A		; Save it for later addition
2866:	0FB2' 3E08    		LD	A,8
2867:	0FB4' 96      		SUB	(HL)		; 8-blkshf to accumulator
2868:	0FB5' 4F      		LD	C,A		; extent shift count in register c
2869:	0FB6' 3AA628  		LD	A,(EXTVAL)	; extent value ani extmsk
2870:	0FB9'         	DMPOS1:
2871:				; blkshf = 3,4,5,6,7, c=5,4,3,2,1
2872:				; shift is 4,3,2,1,0
2873:	0FB9' 0D      		DEC	C
2874:	0FBA' CAC20F  		JP	Z,DMPOS2
2875:	0FBD' B7      		OR	A
2876:	0FBE' 17      		RLA
2877:	0FBF' C3B90F  		JP	DMPOS1
2878:	0FC2'         	DMPOS2:
2879:				; Arrive here with a = shl(ext and extmsk,7-blkshf)
2880:	0FC2' 80      		ADD	A,B		; Add the previous shr(vrecord,blkshf) value
2881:				; a is one of the following values, depending upon alloc
2882:				; bks blkshf
2883:				; 1k   3     v/8 + extval * 16
2884:				; 2k   4     v/16+ extval * 8
2885:				; 4k   5     v/32+ extval * 4
2886:				; 8k   6     v/64+ extval * 2
2887:				; 16k  7     v/128+extval * 1
2888:	0FC3' C9      		RET			; with dm$position in a
2889:			
2890:	0FC4'         	GETDMA:
2891:	0FC4' 2ADBFB  		LD	HL,(INFO)
2892:	0FC7' 111000  		LD	DE,DSKMAP
2893:	0FCA' 19      		ADD	HL,DE
2894:	0FCB' C9      		RET
2895:			
2896:	0FCC'         	GETDM:
2897:				; Return disk map value from position given by bc
2898:	0FCC' CDC40F  		CALL	GETDMA
2899:	0FCF' 09      		ADD	HL,BC		; Index by a single byte value
2900:	0FD0' 3AA328  		LD	A,(SINGLE)	; single byte/map entry?
2901:	0FD3' B7      		OR	A
2902:	0FD4' CADA0F  		JP	Z,GETDMD	; Get disk map single byte
2903:	0FD7' 6E      		LD	L,(HL)
2904:	0FD8' 60      		LD	H,B
2905:	0FD9' C9      		RET			; with hl=00bb
2906:	0FDA'         	GETDMD:
2907:	0FDA' 09      		ADD	HL,BC		; hl=.fcb(dm+i*2)
2908:				; double precision value returned
2909:	0FDB' 7E      		LD	A,(HL)
2910:	0FDC' 23      		INC	HL
2911:	0FDD' 66      		LD	H,(HL)
2912:	0FDE' 6F      		LD	L,A
2913:	0FDF' C9      		RET
2914:			
2915:	0FE0'         	INDEX:
2916:				; Compute disk block number from current fcb
2917:	0FE0' CDA40F  		CALL	DM$POSITION	; 0...15 in register a
2918:	0FE3' 329F28  		LD	(DMINX),A
2919:	0FE6' 4F      		LD	C,A
2920:	0FE7' 0600    		LD	B,0
2921:	0FE9' CDCC0F  		CALL	GETDM		; value to hl
2922:	0FEC' 22AB28  		LD	(ARECORD),HL
2923:	0FEF' 7D      		LD	A,L
2924:	0FF0' B4      		OR	H
2925:	0FF1' C9      		RET
2926:			
2927:	0FF2'         	ATRAN:
2928:				; Compute actual record address, assuming index called
2929:			
2930:			;	arecord = shl(arecord,blkshf)
2931:			
2932:	0FF2' 3A8228  		LD	A,(BLKSHF)
2933:	0FF5' 4F      		LD	C,A
2934:	0FF6' 2AAB28  		LD	HL,(ARECORD)
2935:	0FF9' AF      		XOR	A
2936:	0FFA' CDF60D  		CALL	SHL3BV
2937:	0FFD' 22AB28  		LD	(ARECORD),HL
2938:	1000' 32AD28  		LD	(ARECORD+2),A
2939:			
2940:	1003' 22B128  		LD	(ARECORD1),HL	; Save low(arecord)
2941:			
2942:			;	arecord = arecord or (vrecord and blkmsk)
2943:			
2944:	1006' 3A8328  		LD	A,(BLKMSK)
2945:	1009' 4F      		LD	C,A
2946:	100A' 3AA828  		LD	A,(VRECORD)
2947:	100D' A1      		AND	C
2948:	100E' 47      		LD	B,A		; Save vrecord & blkmsk in reg b & blk$off
2949:	100F' 329328  		LD	(BLK$OFF),A
2950:	1012' 21AB28  		LD	HL,ARECORD
2951:	1015' B6      		OR	(HL)
2952:	1016' 77      		LD	(HL),A
2953:	1017' C9      		RET
2954:			
2955:	1018'         	GET$ATTS:
2956:				; Get volatile attributes starting at f'5
2957:				; info locates fcb
2958:	1018' 2ADBFB  		LD	HL,(INFO)
2959:	101B' 110800  		LD	DE,8
2960:	101E' 19      		ADD	HL,DE		; hl = .fcb(f'8)
2961:	101F' 0E04    		LD	C,4
2962:	1021'         	GET$ATTS$LOOP:
2963:	1021' 7E      		LD	A,(HL)
2964:	1022' 87      		ADD	A,A
2965:	1023' F5      		PUSH	AF
2966:	1024' 7A      		LD	A,D
2967:	1025' 1F      		RRA
2968:	1026' 57      		LD	D,A
2969:	1027' F1      		POP	AF
2970:	1028' 0F      		RRCA
2971:	1029' 77      		LD	(HL),A
2972:	102A' 2B      		DEC	HL
2973:	102B' 0D      		DEC	C
2974:	102C' C22110  		JP	NZ,GET$ATTS$LOOP
2975:	102F' 7A      		LD	A,D
2976:	1030' C9      		RET
2977:			
2978:	1031'         	GETS1:
2979:				; Get current s1 field to a
2980:	1031' CD3F10  		CALL	GETEXTA
2981:	1034' 23      		INC	HL
2982:	1035' 7E      		LD	A,(HL)
2983:	1036' C9      		RET
2984:			
2985:	1037'         	GET$RRA:
2986:				; Get current ran rec field address to hl
2987:	1037' 2ADBFB  		LD	HL,(INFO)
2988:	103A' 112100  		LD	DE,RANREC
2989:	103D' 19      		ADD	HL,DE		; hl=.fcb(ranrec)
2990:	103E' C9      		RET
2991:			
2992:	103F'         	GETEXTA:
2993:				; Get current extent field address to hl
2994:	103F' 2ADBFB  		LD	HL,(INFO)
2995:	1042' 110C00  		LD	DE,EXTNUM
2996:	1045' 19      		ADD	HL,DE		; hl=.fcb(extnum)
2997:	1046' C9      		RET
2998:			
2999:	1047'         	GETRCNTA:
3000:				; Get reccnt address to hl
3001:	1047' 2ADBFB  		LD	HL,(INFO)
3002:	104A' 110F00  		LD	DE,RECCNT
3003:	104D' 19      		ADD	HL,DE
3004:	104E' C9      		RET
3005:			
3006:	104F'         	GETFCBA:
3007:				; Compute reccnt and nxtrec addresses for get/setfcb
3008:	104F' CD4710  		CALL	GETRCNTA
3009:	1052' EB      		EX	DE,HL		; de=.fcb(reccnt)
3010:	1053' 211100  		LD	HL,[NXTREC-RECCNT]
3011:	1056' 19      		ADD	HL,DE		; hl=.fcb(nxtrec)
3012:	1057' C9      		RET
3013:			
3014:	1058'         	GETFCB:
3015:				; Set variables from currently addressed fcb
3016:	1058' CD4F10  		CALL	GETFCBA		; addresses in de, hl
3017:	105B' 7E      		LD	A,(HL)
3018:	105C' 32A828  		LD	(VRECORD),A	; vrecord=fcb(nxtrec)
3019:	105F' EB      		EX	DE,HL
3020:	1060' 7E      		LD	A,(HL)
3021:	1061' B7      		OR	A
3022:	1062' C26D10  		JP	NZ,GETFCB0
3023:	1065' CD9714  		CALL	GET$DIR$EXT
3024:	1068' 4F      		LD	C,A
3025:	1069' CDFD17  		CALL	SET$RC
3026:	106C' 7E      		LD	A,(HL)
3027:	106D'         	GETFCB0:
3028:	106D' FE81    		CP	81H
3029:	106F' DA7410  		JP	C,GETFCB1
3030:	1072' 3E80    		LD	A,80H
3031:	1074'         	GETFCB1:
3032:	1074' 32A528  		LD	(RCOUNT),A	; rcount=fcb(reccnt) or 80h
3033:	1077' CD3F10  		CALL	GETEXTA		; hl=.fcb(extnum)
3034:	107A' 3A8428  		LD	A,(EXTMSK)	; extent mask to a
3035:	107D' A6      		AND	(HL)		; fcb(extnum) and extmsk
3036:	107E' 32A628  		LD	(EXTVAL),A
3037:	1081' C9      		RET
3038:			
3039:	1082'         	SETFCB:
3040:				; Place values back into current fcb
3041:	1082' CD4F10  		CALL	GETFCBA		; addresses to de, hl
3042:				; fcb(cr) = vrecord
3043:	1085' 3AA828  		LD	A,(VRECORD)
3044:	1088' 77      		LD	(HL),A
3045:				; Is fx < 22? (sequential read or write)
3046:	1089' 3ADFFB  		LD	A,(FX)
3047:	108C' FE16    		CP	22
3048:	108E' D29210  		JP	NC,$+4		; no
3049:				; fcb(cr) = fcb(cr) + 1
3050:	1091' 34      		INC	(HL)
3051:	1092' EB      		EX	DE,HL
3052:	1093' 7E      		LD	A,(HL)
3053:	1094' FE80    		CP	80H
3054:	1096' D0      		RET	NC		; dont reset fcb(rc) if > 7fh
3055:	1097' 3AA528  		LD	A,(RCOUNT)
3056:	109A' 77      		LD	(HL),A		; fcb(reccnt)=rcount
3057:	109B' C9      		RET
3058:			
3059:	109C'         	ZERO$EXT$MOD:
3060:	109C' CD3F10  		CALL	GETEXTA
3061:	109F' 72      		LD	(HL),D
3062:	10A0' 23      		INC	HL
3063:	10A1' 23      		INC	HL
3064:	10A2' 72      		LD	(HL),D
3065:	10A3' C9      		RET
3066:			
3067:	10A4'         	ZERO:
3068:	10A4' 70      		LD	(HL),B
3069:	10A5' 23      		INC	HL
3070:	10A6' 0D      		DEC	C
3071:	10A7' C8      		RET	Z
3072:	10A8' C3A410  		JP	ZERO
3073:			
3074:	10AB'         	HLROTR:
3075:				; hl rotate right by amount c
3076:	10AB' 0C      		INC	C		; in case zero
3077:	10AC' 0D      	HLROTR0:DEC	C
3078:	10AD' C8      		RET	Z		; return when zero
3079:	10AE' 7C      		LD	A,H
3080:	10AF' B7      		OR	A
3081:	10B0' 1F      		RRA
3082:	10B1' 67      		LD	H,A		; high byte
3083:	10B2' 7D      		LD	A,L
3084:	10B3' 1F      		RRA
3085:	10B4' 6F      		LD	L,A		; low byte
3086:	10B5' C3AC10  		JP	HLROTR0
3087:			
3088:	10B8'         	COMPUTE$CS:
3089:				; Compute checksum for current directory buffer
3090:	10B8' 2A6728  		LD	HL,(BUFFA)	; current directory buffer
3091:	10BB' 010400  		LD	BC,4		; b = 0, c = 4
3092:	10BE'         	COMPUTE$CS0:
3093:	10BE' 1620    		LD	D,32		; size of fcb
3094:	10C0' AF      		XOR	A		; clear checksum value
3095:	10C1'         	COMPUTE$CS1:
3096:	10C1' 86      		ADD	A,(HL)
3097:	10C2' 23      		INC	HL
3098:	10C3' 15      		DEC	D
3099:	10C4' C2C110  		JP	NZ,COMPUTE$CS1
3100:	10C7' A8      		XOR	B
3101:	10C8' 47      		LD	B,A
3102:	10C9' 0D      		DEC	C
3103:	10CA' C2BE10  		JP	NZ,COMPUTE$CS0
3104:	10CD' C9      		RET			; with checksum in a
3105:			
3106:	0000'         		IF MPM
3170:				ENDIF
3171:			
3172:	10CE'         	CHECK$FCB:
3173:			
3174:	0000'         		IF MPM
3211:				ELSE
3212:	10CE' CD3110  		CALL	GETS1
3213:	10D1' 2A7128  		LD	HL,(LSN$ADD)
3214:	10D4' BE      		CP	(HL)
3215:	10D5' C4E310  		CALL	NZ,CHK$MEDIA$FCB
3216:				ENDIF
3217:			
3218:	10D8'         	CHEK$FCB:
3219:	10D8' 3AB528  		LD	A,(HIGH$EXT)
3220:			
3221:	0000'         		IF MPM
3228:				ELSE
3229:	10DB' B7      		OR	A
3230:	10DC' C8      		RET	Z
3231:				ENDIF
3232:			
3233:	10DD' 2ADBFB  		LD	HL,(INFO)
3234:	10E0' AF      		XOR	A
3235:	10E1' 77      		LD	(HL),A		; fcb(0) = 0
3236:	10E2'         	CHEK$FCB1:
3237:			
3238:	0000'         		IF MPM
3240:				ELSE
3241:	10E2' C9      		RET
3242:			
3243:	10E3'         	CHK$MEDIA$FCB:
3244:				; fcb(s1) ~= DPH login sequence # field
3245:				; Is fcb addr < bdosadd?
3246:			
3247:	FFFF'         		IF BANKED
3248:	10E3' 2A1EFD  		LD	HL,(USER$INFO)
3249:				ELSE
3251:				ENDIF
3252:			
3253:	10E6' EB      		EX	DE,HL
3254:	10E7' 2AFEFB  		LD	HL,(BDOSADD)
3255:	10EA' CD7F11  		CALL	SUBDH
3256:	10ED' D2F710  		JP	NC,CHK$MEDIA1	; no
3257:				; Is rlog(drive) true?
3258:	10F0' 2A92FB  		LD	HL,(RLOG)
3259:	10F3' CD1D11  		CALL	TESTVECTOR
3260:	10F6' C8      		RET	Z		; no
3261:	10F7'         	CHK$MEDIA1:
3262:				; Return invalid fcb error code
3263:	10F7' E1      		POP	HL
3264:	10F8' E1      		POP	HL
3265:	10F9'         	CHK$MEDIA2:
3266:	10F9' 3E0A    		LD	A,10
3267:	10FB' C3720A  		JP	STA$RET
3268:				ENDIF
3269:			
3270:	10FE'         	HLROTL:
3271:				; Rotate the mask in hl by amount in c
3272:	10FE' 0C      		INC	C		; may be zero
3273:	10FF' 0D      	HLROTL0:DEC	C
3274:	1100' C8      		RET	Z		; return if zero
3275:	1101' 29      		ADD	HL,HL
3276:	1102' C3FF10  		JP	HLROTL0
3277:			
3278:	1105'         	SET$DLOG:
3279:	1105' 116528  		LD	DE,DLOG
3280:	1108'         	SET$CDISK:
3281:				; Set a "1" value in curdsk position of bc
3282:	1108' 3AA928  		LD	A,(CURDSK)
3283:	110B'         	SET$CDISK1:
3284:	110B' 4F      		LD	C,A		; Ready parameter for shift
3285:	110C' 210100  		LD	HL,1		; number to shift
3286:	110F' CDFE10  		CALL	HLROTL		; hl = mask to integrate
3287:	1112' 1A      		LD	A,(DE)
3288:	1113' B5      		OR	L
3289:	1114' 12      		LD	(DE),A
3290:	1115' 13      		INC	DE
3291:	1116' 1A      		LD	A,(DE)
3292:	1117' B4      		OR	H
3293:	1118' 12      		LD	(DE),A
3294:	1119' C9      		RET
3295:			
3296:	111A'         	NOWRITE:
3297:				; Return true if dir checksum difference occurred
3298:	111A' 2A6328  		LD	HL,(RODSK)
3299:			
3300:	111D'         	TESTVECTOR:
3301:	111D' 3AA928  		LD	A,(CURDSK)
3302:	1120'         	TESTVECTOR1:
3303:	1120' 4F      		LD	C,A
3304:	1121' CDAB10  		CALL	HLROTR
3305:	1124' 7D      		LD	A,L
3306:	1125' E601    		AND	1B
3307:	1127' C9      		RET			; non zero if curdsk bit on
3308:			
3309:	1128'         	CHECK$RODIR:
3310:				; Check current directory element for read/only status
3311:	1128' CD4011  		CALL	GETDPTRA	; address of element
3312:			
3313:	112B'         	CHECK$ROFILE:
3314:				; Check current buff(dptr) or fcb(0) for r/o status
3315:	112B' CD3211  		CALL	RO$TEST
3316:	112E' D0      		RET	NC		; Return if not set
3317:	112F' C3A60D  		JP	ROF$ERROR	; Exit to read only disk message
3318:			
3319:	1132'         	RO$TEST:
3320:	1132' 110900  		LD	DE,ROFILE
3321:	1135' 19      		ADD	HL,DE
3322:	1136' 7E      		LD	A,(HL)
3323:	1137' 17      		RLA
3324:	1138' C9      		RET			; carry set if r/o
3325:			
3326:	1139'         	CHECK$WRITE:
3327:				; Check for write protected disk
3328:	1139' CD1A11  		CALL	NOWRITE
3329:	113C' C8      		RET	Z		; ok to write if not rodsk
3330:	113D' C3A10D  		JP	ROD$ERROR	; read only disk error
3331:			
3332:	1140'         	GETDPTRA:
3333:				; Compute the address of a directory element at
3334:				; positon dptr in the buffer
3335:			
3336:	1140' 2A6728  		LD	HL,(BUFFA)
3337:	1143' 3AB728  		LD	A,(DPTR)
3338:	1146'         	ADDH:
3339:				; hl = hl + a
3340:	1146' 85      		ADD	A,L
3341:	1147' 6F      		LD	L,A
3342:	1148' D0      		RET	NC
3343:				; overflow to h
3344:	1149' 24      		INC	H
3345:	114A' C9      		RET
3346:			
3347:	114B'         	GETMODNUM:
3348:				; Compute the address of the module number
3349:				; bring module number to accumulator
3350:				; (high order bit is fwf (file write flag)
3351:	114B' 2ADBFB  		LD	HL,(INFO)
3352:	114E' 110E00  		LD	DE,MODNUM
3353:	1151' 19      		ADD	HL,DE		; hl=.fcb(modnum)
3354:	1152' 7E      		LD	A,(HL)
3355:	1153' C9      		RET			; a=fcb(modnum)
3356:			
3357:	1154'         	CLRMODNUM:
3358:				; Clear the module number field for user open/make
3359:	1154' CD4B11  		CALL	GETMODNUM
3360:	1157' 3600    		LD	(HL),0		; fcb(modnum)=0
3361:	1159' C9      		RET
3362:			
3363:	115A'         	CLR$EXT:
3364:				; fcb ext = fcb ext & 1fh
3365:	115A' CD3F10  		CALL	GETEXTA
3366:	115D' 7E      		LD	A,(HL)
3367:	115E' E61F    		AND	00011111B
3368:	1160' 77      		LD	(HL),A
3369:	1161' C9      		RET
3370:			
3371:	1162'         	SETFWF:
3372:	1162' CD4B11  		CALL	GETMODNUM	; hl=.fcb(modnum), a=fcb(modnum)
3373:				; Set fwf (file write flag) to "1"
3374:	1165' F680    		OR	FWFMSK
3375:	1167' 77      		LD	(HL),A		; fcb(modnum)=fcb(modnum) or 80h
3376:				; also returns non zero in accumulator
3377:	1168' C9      		RET
3378:			
3379:	1169'         	COMPCDR:
3380:				; Return cy if cdrmax > dcnt
3381:	1169' 2AE1FB  		LD	HL,(DCNT)
3382:	116C' EB      		EX	DE,HL		; de = directory counter
3383:	116D' 2A6928  		LD	HL,(CDRMAXA)	; hl=.cdrmax
3384:	1170' 7B      		LD	A,E
3385:	1171' 96      		SUB	(HL)		; low(dcnt) - low(cdrmax)
3386:	1172' 23      		INC	HL		; hl = .cdrmax+1
3387:	1173' 7A      		LD	A,D
3388:	1174' 9E      		SBC	A,(HL)		; hig(dcnt) - hig(cdrmax)
3389:				; condition dcnt - cdrmax  produces cy if cdrmax>dcnt
3390:	1175' C9      		RET
3391:			
3392:	1176'         	SETCDR:
3393:				; if not (cdrmax > dcnt) then cdrmax = dcnt+1
3394:	1176' CD6911  		CALL	COMPCDR
3395:	1179' D8      		RET	C		; Return if cdrmax > dcnt
3396:				; otherwise, hl = .cdrmax+1, de = dcnt
3397:	117A' 13      		INC	DE
3398:	117B' 72      		LD	(HL),D
3399:	117C' 2B      		DEC	HL
3400:	117D' 73      		LD	(HL),E
3401:	117E' C9      		RET
3402:			
3403:	117F'         	SUBDH:
3404:				; Compute hl = de - hl
3405:	117F' 7B      		LD	A,E
3406:	1180' 95      		SUB	L
3407:	1181' 6F      		LD	L,A
3408:	1182' 7A      		LD	A,D
3409:	1183' 9C      		SBC	A,H
3410:	1184' 67      		LD	H,A
3411:	1185' C9      		RET
3412:			
3413:	1186'         	NEWCHECKSUM:
3414:	1186' 0EFE    		LD	C,0FEH		; Drop through to compute new checksum
3415:	1188'         	CHECKSUM:
3416:				; Compute current checksum record and update the
3417:				; directory element if c=true, or check for = if not
3418:				; drec < chksiz?
3419:	1188' 2A9128  		LD	HL,(DREC)
3420:	118B' EB      		EX	DE,HL
3421:	118C' 2A8B28  		LD	HL,(CHKSIZ)
3422:	118F' 7C      		LD	A,H
3423:	1190' E67F    		AND	7FH
3424:	1192' 67      		LD	H,A		; Mask off permanent drive bit
3425:	1193' CD7F11  		CALL	SUBDH		; de-hl
3426:	1196' D0      		RET	NC		; Skip checksum if past checksum vector size
3427:				; drec < chksiz, so continue
3428:	1197' C5      		PUSH	BC		; Save init flag
3429:	1198' CDB810  		CALL	COMPUTE$CS	; Check sum value to a
3430:	119B' 2A7528  		LD	HL,(CHECKA)	; address of check sum vector
3431:	119E' EB      		EX	DE,HL
3432:	119F' 2A9128  		LD	HL,(DREC)
3433:	11A2' 19      		ADD	HL,DE		; hl = .check(drec)
3434:	11A3' C1      		POP	BC		; Recall true=0ffh or false=00 to c
3435:	11A4' 0C      		INC	C		; 0ffh produces zero flag
3436:	11A5' CAC611  		JP	Z,INITIAL$CS
3437:	11A8' 0C      		INC	C		; 0feh produces zero flag
3438:	11A9' CAD111  		JP	Z,UPDATE$CS
3439:			
3440:	0000'         		IF MPM
3443:				ENDIF
3444:			
3445:				; not initializing, compare
3446:	11AC' BE      		CP	(HL)		; compute$cs=check(drec)?
3447:	11AD' C8      		RET	Z		; no message if ok
3448:				; checksum error, are we beyond
3449:				; the end of the disk?
3450:	11AE' CD1A11  		CALL	NOWRITE
3451:			;;;			rnz	;[JCE] DRI Patch 13
3452:	11B1' 00      		NOP
3453:			
3454:	11B2'         	MEDIA$CHANGE:
3455:	11B2' CD5212  		CALL	DISCARD$DATA
3456:			
3457:	0000'         		IF MPM
3459:				ELSE
3460:	11B5' 3EFF    		LD	A,0FFH
3461:	11B7' 32DEFB  		LD	(RELOG),A
3462:	11BA' 329CFB  		LD	(HASHL),A
3463:	11BD' CDE811  		CALL	SET$RLOG
3464:				ENDIF
3465:			
3466:				; Reset the drive
3467:			
3468:	11C0' CD0511  		CALL	SET$DLOG
3469:	11C3' C35A24  		JP	RESET$37X
3470:			
3471:	0000'         		IF MPM
3476:				ENDIF
3477:			
3478:	11C6'         	INITIAL$CS:
3479:				; initializing the checksum
3480:	11C6' BE      		CP	(HL)
3481:	11C7' 77      		LD	(HL),A
3482:	11C8' C8      		RET	Z
3483:				; or 1 into login seq # if media change
3484:	11C9' 2A7128  		LD	HL,(LSN$ADD)
3485:	11CC' 3E01    		LD	A,1
3486:	11CE' B6      		OR	(HL)
3487:	11CF' 77      		LD	(HL),A
3488:	11D0' C9      		RET
3489:			
3490:	11D1'         	UPDATE$CS:
3491:				; updating the checksum
3492:	11D1' 77      		LD	(HL),A
3493:	11D2' C9      		RET
3494:			
3495:	11D3'         	SET$RO:
3496:				; Set current disk to read/only
3497:	11D3' 3AA428  		LD	A,(SELDSK)
3498:	11D6' 116328  		LD	DE,RODSK
3499:	11D9' CD0B11  		CALL	SET$CDISK1	; sets bit to 1
3500:				; high water mark in directory goes to max
3501:	11DC' 2A8728  		LD	HL,(DIRMAX)
3502:	11DF' 23      		INC	HL
3503:	11E0' EB      		EX	DE,HL		; de = directory max
3504:	11E1' 2A6928  		LD	HL,(CDRMAXA)	; hl = .cdrmax
3505:	11E4' 73      		LD	(HL),E
3506:	11E5' 23      		INC	HL
3507:	11E6' 72      		LD	(HL),D		; cdrmax = dirmax
3508:	11E7' C9      		RET
3509:			
3510:	11E8'         	SET$RLOG:
3511:				; rlog(seldsk) = true
3512:	11E8' 2A90FB  		LD	HL,(OLOG)
3513:	11EB' CD1D11  		CALL	TESTVECTOR
3514:	11EE' C8      		RET	Z
3515:	11EF' 1192FB  		LD	DE,RLOG
3516:	11F2' C30811  		JP	SET$CDISK
3517:			
3518:	11F5'         	TST$LOG$FXS:
3519:	11F5' 3A8C28  		LD	A,(CHKSIZ+1)
3520:	11F8' E680    		AND	80H
3521:	11FA' C0      		RET	NZ
3522:	11FB' 21C028  		LD	HL,LOG$FXS
3523:	11FE'         	TST$LOG0:
3524:	11FE' 3ADFFB  		LD	A,(FX)
3525:	1201' 47      		LD	B,A
3526:	1202'         	TST$LOG1:
3527:	1202' 7E      		LD	A,(HL)
3528:	1203' B8      		CP	B
3529:	1204' C8      		RET	Z
3530:	1205' 23      		INC	HL
3531:	1206' B7      		OR	A
3532:	1207' C20212  		JP	NZ,TST$LOG1
3533:	120A' 3C      		INC	A
3534:	120B' C9      		RET
3535:			
3536:	120C'         	TEST$MEDIA$FLAG:
3537:	120C' 2A7128  		LD	HL,(LSN$ADD)
3538:	120F' 23      		INC	HL
3539:	1210' 7E      		LD	A,(HL)
3540:	1211' B7      		OR	A
3541:	1212' C9      		RET
3542:			
3543:	1213'         	CHK$EXIT$FXS:
3544:	1213' 213B28  		LD	HL,GOBACK
3545:	1216' E5      		PUSH	HL
3546:				; does fx = read or write function?
3547:				; and is drive removable?
3548:	1217' 21CD28  		LD	HL,RW$FXS
3549:	121A' CDFE11  		CALL	TST$LOG0
3550:	121D' CAF910  		JP	Z,CHK$MEDIA2	; yes
3551:				; is fx = close or searchn function?
3552:				; and is drive removable?
3553:	1220' 21D428  		LD	HL,SC$FXS
3554:	1223' CDFE11  		CALL	TST$LOG0
3555:	1226' CAC015  		JP	Z,LRET$EQ$FF	; yes
3556:	1229' E1      		POP	HL
3557:	122A' C9      		RET
3558:			
3559:	122B'         	TST$RELOG:
3560:	122B' 21DEFB  		LD	HL,RELOG
3561:	122E' 7E      		LD	A,(HL)
3562:	122F' B7      		OR	A
3563:	1230' C8      		RET	Z
3564:	1231' 3600    		LD	(HL),0
3565:	1233'         	DRV$RELOG:
3566:	1233' CD6B1E  		CALL	CURSELECT
3567:	1236' 210000  		LD	HL,0
3568:	1239' 22E1FB  		LD	(DCNT),HL
3569:	123C' AF      		XOR	A
3570:	123D' 32B728  		LD	(DPTR),A
3571:	1240' C9      		RET
3572:			
3573:	1241'         	SET$LSN:
3574:	1241' 2A7128  		LD	HL,(LSN$ADD)
3575:	1244' 4E      		LD	C,(HL)
3576:	1245' CD3110  		CALL	GETS1
3577:	1248' 71      		LD	(HL),C
3578:	1249' C9      		RET
3579:			
3580:	124A'         	DISCARD$DATA$BCB:
3581:	124A' 2A7B28  		LD	HL,(DTABCBA)
3582:	124D' 0E04    		LD	C,4
3583:	124F' C35D12  		JP	DISCARD0
3584:			
3585:	1252'         	DISCARD$DATA:
3586:	1252' 2A7B28  		LD	HL,(DTABCBA)
3587:	1255' C35B12  		JP	DISCARD
3588:			
3589:	1258'         	DISCARD$DIR:
3590:	1258' 2A7928  		LD	HL,(DIRBCBA)
3591:			
3592:	125B'         	DISCARD:
3593:	125B' 0E01    		LD	C,1
3594:	125D'         	DISCARD0:
3595:	125D' 7D      		LD	A,L
3596:	125E' A4      		AND	H
3597:	125F' 3C      		INC	A
3598:	1260' C8      		RET	Z
3599:			
3600:	FFFF'         		IF BANKED
3601:	1261' 5E      		LD	E,(HL)
3602:	1262' 23      		INC	HL
3603:	1263' 56      		LD	D,(HL)
3604:	1264' EB      		EX	DE,HL
3605:	1265'         	DISCARD1:
3606:	1265' E5      		PUSH	HL
3607:	1266' C5      		PUSH	BC
3608:	1267' 11AA28  		LD	DE,ADRIVE
3609:	126A' CD1F0E  		CALL	COMPARE
3610:	126D' C1      		POP	BC
3611:	126E' E1      		POP	HL
3612:	126F' C27412  		JP	NZ,DISCARD2
3613:			
3614:	1272' 36FF    		LD	(HL),0FFH
3615:	1274'         	DISCARD2:
3616:	1274' 110D00  		LD	DE,13
3617:	1277' 19      		ADD	HL,DE
3618:	1278' 5E      		LD	E,(HL)
3619:	1279' 23      		INC	HL
3620:	127A' 56      		LD	D,(HL)
3621:	127B' EB      		EX	DE,HL
3622:	127C' 7D      		LD	A,L
3623:	127D' B4      		OR	H
3624:	127E' C8      		RET	Z
3625:	127F' C36512  		JP	DISCARD1
3626:				ELSE
3634:				ENDIF
3635:			
3636:	1282'         	GETBUFFA:
3637:	1282' D5      		PUSH	DE
3638:	1283' 110A00  		LD	DE,10
3639:	1286' 19      		ADD	HL,DE
3640:	1287' 5E      		LD	E,(HL)
3641:	1288' 23      		INC	HL
3642:	1289' 56      		LD	D,(HL)
3643:			
3644:	FFFF'         		IF BANKED
3645:	128A' 23      		INC	HL
3646:	128B' 7E      		LD	A,(HL)
3647:	128C' 32FA28  		LD	(BUFFER$BANK),A
3648:				ENDIF
3649:			
3650:	128F' EB      		EX	DE,HL
3651:	1290' D1      		POP	DE
3652:	1291' C9      		RET
3653:			
3654:	1292'         	RDDIR:
3655:				; Read a directory entry into the directory buffer
3656:	1292' CDF50E  		CALL	SEEKDIR
3657:	1295' 3E03    		LD	A,3
3658:	1297' C3A212  		JP	WRDIR0
3659:			
3660:	129A'         	SEEK$COPY:
3661:	129A'         	WRDIR:
3662:				; Write the current directory entry, set checksum
3663:	129A' CD3911  		CALL	CHECK$WRITE
3664:	129D' CD8611  		CALL	NEWCHECKSUM	; Initialize entry
3665:	12A0' 3E05    		LD	A,5
3666:	12A2'         	WRDIR0:
3667:	12A2' 210000  		LD	HL,0
3668:	12A5' 229628  		LD	(LAST$BLOCK),HL
3669:	12A8' 2A7928  		LD	HL,(DIRBCBA)
3670:			
3671:	FFFF'         		IF BANKED
3672:	12AB' FE05    		CP	5
3673:	12AD' C2B312  		JP	NZ,$+6
3674:	12B0' 2AF028  		LD	HL,(CURBCBA)
3675:				ENDIF
3676:			
3677:	12B3' CD5829  		CALL	DEBLOCK
3678:			
3679:	12B6'         	SETDATA:
3680:				; Set data dma address
3681:	12B6' 2AD8FB  		LD	HL,(DMAAD)
3682:	12B9' C3BF12  		JP	SETDMA		; to complete the call
3683:			
3684:	12BC'         	SETDIR1:
3685:	12BC' CD8212  		CALL	GETBUFFA
3686:			
3687:	12BF'         	SETDMA:
3688:				; hl=.dma address to set (i.e., buffa or dmaad)
3689:	12BF' 221BFD  		LD	(CURDMA),HL
3690:	12C2' C9      		RET
3691:			
3692:	12C3'         	DIR$TO$USER:
3693:			
3694:	FFFF'         		IF NOT MPM
3695:				; Copy the directory entry to the user buffer
3696:				; after call to search or searchn by user code
3697:	12C3' 2A6728  		LD	HL,(BUFFA)
3698:	12C6' EB      		EX	DE,HL		; source is directory buffer
3699:	12C7' 2A19FD  		LD	HL,(XDMAAD)	; destination is user dma address
3700:	12CA' 018000  		LD	BC,RECSIZ	; copy entire record
3701:	12CD' CD4BFF  		CALL	MOVEF
3702:				ENDIF
3703:				; Set lret to dcnt & 3 if search successful
3704:	12D0' 219F0D  		LD	HL,LRET
3705:	12D3' 7E      		LD	A,(HL)
3706:	12D4' 3C      		INC	A
3707:	12D5' C8      		RET	Z
3708:	12D6' 3AE1FB  		LD	A,(DCNT)
3709:	12D9' E603    		AND	DSKMSK
3710:	12DB' 77      		LD	(HL),A
3711:	12DC' C9      		RET
3712:			
3713:	12DD'         	MAKE$FCB$INV: ; Flag fcb as invalid
3714:				; Reset fcb write flag
3715:	12DD' CD6211  		CALL	SETFWF
3716:				; Set 1st two bytes of diskmap to ffh
3717:	12E0' 23      		INC	HL
3718:	12E1' 23      		INC	HL
3719:	12E2' 3EFF    		LD	A,0FFH
3720:	12E4' 77      		LD	(HL),A
3721:	12E5' 23      		INC	HL
3722:	12E6' 77      		LD	(HL),A
3723:	12E7' C9      		RET
3724:			
3725:	12E8'         	CHK$INV$FCB: ; Check for invalid fcb
3726:	12E8' CDC40F  		CALL	GETDMA
3727:	12EB' C3FB12  		JP	TEST$FFFF
3728:			
3729:	12EE'         	TST$INV$FCB: ; Test for invalid fcb
3730:	12EE' CDE812  		CALL	CHK$INV$FCB
3731:	12F1' C0      		RET	NZ
3732:	12F2' E1      		POP	HL
3733:	12F3' 3E09    		LD	A,9
3734:	12F5' C3720A  		JP	STA$RET
3735:				; lret = 9
3736:			
3737:	12F8'         	END$OF$DIR:
3738:				; Return zero flag if at end of directory, non zero
3739:				; if not at end (end of dir if dcnt = 0ffffh)
3740:	12F8' 21E1FB  		LD	HL,DCNT
3741:	12FB'         	TEST$FFFF:
3742:	12FB' 7E      		LD	A,(HL)		; may be 0ffh
3743:	12FC' 23      		INC	HL
3744:	12FD' BE      		CP	(HL)		; low(dcnt) = high(dcnt)?
3745:	12FE' C0      		RET	NZ		; non zero returned if different
3746:				; high and low the same, = 0ffh?
3747:	12FF' 3C      		INC	A		; 0ffh becomes 00 if so
3748:	1300' C9      		RET
3749:			
3750:	1301'         	SETENDDIR:
3751:				; Set dcnt to the end of the directory
3752:	1301' 21FFFF  		LD	HL,ENDDIR
3753:	1304' 22E1FB  		LD	(DCNT),HL
3754:	1307' C9      		RET
3755:			
3756:	1308'         	READ$DIR:
3757:	1308' CD0E13  		CALL	R$DIR
3758:	130B' C34013  		JP	R$DIR1
3759:			
3760:	130E'         	R$DIR:
3761:				; Read next directory entry, with c=true if initializing
3762:			
3763:	130E' 2A8728  		LD	HL,(DIRMAX)
3764:	1311' EB      		EX	DE,HL		; in preparation for subtract
3765:	1312' 2AE1FB  		LD	HL,(DCNT)
3766:	1315' 23      		INC	HL
3767:	1316' 22E1FB  		LD	(DCNT),HL	; dcnt=dcnt+1
3768:				; Continue while dirmax >= dcnt (dirmax-dcnt no cy)
3769:	1319' CD7F11  		CALL	SUBDH		; de-hl
3770:			
3771:	131C' DA0113  		JP	C,SETENDDIR
3772:			
3773:	131F'         	READ$DIR0:
3774:				; not at end of directory, seek next element
3775:				; initialization flag is in c
3776:	131F' 3AE1FB  		LD	A,(DCNT)
3777:	1322' E603    		AND	DSKMSK		; low(dcnt) and dskmsk
3778:	1324' 0605    		LD	B,FCBSHF	; to multiply by fcb size
3779:	1326'         	READ$DIR1:
3780:	1326' 87      		ADD	A,A
3781:	1327' 05      		DEC	B
3782:	1328' C22613  		JP	NZ,READ$DIR1
3783:				; a = (low(dcnt) and dskmsk) shl fcbshf
3784:	132B' 32B728  		LD	(DPTR),A	; ready for next dir operation
3785:	132E' B7      		OR	A
3786:	132F' C0      		RET	NZ		; Return if not a new record
3787:	1330'         	READ$DIR2:
3788:	1330' C5      		PUSH	BC		; Save initialization flag c
3789:	1331' CD9212  		CALL	RDDIR		; Read the directory record
3790:	1334' C1      		POP	BC		; Recall initialization flag
3791:	1335' 3ADEFB  		LD	A,(RELOG)
3792:	1338' B7      		OR	A
3793:	1339' C0      		RET	NZ
3794:	133A' C38811  		JP	CHECKSUM	; Checksum the directory elt
3795:			
3796:	133D'         	R$DIR2:
3797:	133D' CD3013  		CALL	READ$DIR2
3798:	1340'         	R$DIR1:
3799:	1340' 3ADEFB  		LD	A,(RELOG)
3800:	1343' B7      		OR	A
3801:	1344' C8      		RET	Z
3802:	1345' CD1312  		CALL	CHK$EXIT$FXS
3803:	1348' CD2B12  		CALL	TST$RELOG
3804:	134B' C39212  		JP	RDDIR
3805:			
3806:	134E'         	GETALLOCBIT:
3807:				; Given allocation vector position bc, return with byte
3808:				; containing bc shifted so that the least significant
3809:				; bit is in the low order accumulator position.  hl is
3810:				; the address of the byte for possible replacement in
3811:				; memory upon return, and d contains the number of shifts
3812:				; required to place the returned value back into position
3813:	134E' 79      		LD	A,C
3814:	134F' E607    		AND	111B
3815:	1351' 3C      		INC	A
3816:	1352' 5F      		LD	E,A
3817:	1353' 57      		LD	D,A
3818:				; d and e both contain the number of bit positions to shift
3819:			
3820:	1354' 60      		LD	H,B
3821:	1355' 69      		LD	L,C
3822:	1356' 0E03    		LD	C,3		; bc = bc shr 3
3823:	1358' CDAB10  		CALL	HLROTR		; hlrotr does not touch d and e
3824:	135B' 44      		LD	B,H
3825:	135C' 4D      		LD	C,L
3826:			
3827:	135D' 2A7728  		LD	HL,(ALLOCA)	; base address of allocation vector
3828:	1360' 09      		ADD	HL,BC
3829:	1361' 7E      		LD	A,(HL)		; byte to a, hl = .alloc(bc shr 3)
3830:				; Now move the bit to the low order position of a
3831:	1362' 07      	ROTL:	RLCA
3832:	1363' 1D      		DEC	E
3833:	1364' C26213  		JP	NZ,ROTL
3834:	1367' C9      		RET
3835:			
3836:	1368'         	SETALLOCBIT:
3837:				; bc is the bit position of alloc to set or reset.  the
3838:				; value of the bit is in register e.
3839:	1368' D5      		PUSH	DE
3840:	1369' CD4E13  		CALL	GETALLOCBIT	; shifted val a, count in d
3841:	136C' E6FE    		AND	11111110B	; mask low bit to zero (may be set)
3842:	136E' C1      		POP	BC
3843:	136F' B1      		OR	C		; low bit of c is masked into a
3844:				; jmp rotr ; to rotate back into proper position
3845:				; ret
3846:			
3847:	1370'         	ROTR:
3848:				; byte value from alloc is in register a, with shift count
3849:				; in register c (to place bit back into position), and
3850:				; target alloc position in registers hl, rotate and replace
3851:	1370' 0F      		RRCA
3852:	1371' 15      		DEC	D
3853:	1372' C27013  		JP	NZ,ROTR		; back into position
3854:	1375' 77      		LD	(HL),A		; back to alloc
3855:	1376' C9      		RET
3856:			
3857:	1377'         	COPY$ALV:
3858:				; If Z flag set, copy 1st ALV to 2nd
3859:				; Otherwise, copy 2nd ALV to 1st
3860:			
3861:	0000'         		IF NOT BANKED
3866:				ENDIF
3867:			
3868:	1377' F5      		PUSH	AF
3869:	1378' CDDE13  		CALL	GET$NALBS
3870:	137B' 44      		LD	B,H
3871:	137C' 4D      		LD	C,L
3872:	137D' 2A7728  		LD	HL,(ALLOCA)
3873:	1380' 54      		LD	D,H
3874:	1381' 5D      		LD	E,L
3875:	1382' 09      		ADD	HL,BC
3876:	1383' F1      		POP	AF
3877:	1384' CA4BFF  		JP	Z,MOVEF
3878:	1387' EB      		EX	DE,HL
3879:	1388' C34BFF  		JP	MOVEF
3880:			
3881:	138B'         	SCANDM$AB:
3882:				; Set/Reset 1st and 2nd ALV
3883:	138B' C5      		PUSH	BC
3884:	138C' CDA613  		CALL	SCANDM$A
3885:	138F' C1      		POP	BC
3886:				;jmp scandm$b
3887:			
3888:	1390'         	SCANDM$B:
3889:				; Set/Reset 2nd ALV
3890:			
3891:	0000'         		IF NOT BANKED
3895:				ENDIF
3896:			
3897:	1390' C5      		PUSH	BC
3898:	1391' CDDE13  		CALL	GET$NALBS
3899:	1394' EB      		EX	DE,HL
3900:	1395' 2A7728  		LD	HL,(ALLOCA)
3901:	1398' C1      		POP	BC
3902:	1399' E5      		PUSH	HL
3903:	139A' 19      		ADD	HL,DE
3904:	139B' 227728  		LD	(ALLOCA),HL
3905:	139E' CDA613  		CALL	SCANDM$A
3906:	13A1' E1      		POP	HL
3907:	13A2' 227728  		LD	(ALLOCA),HL
3908:	13A5' C9      		RET
3909:			
3910:	13A6'         	SCANDM$A:
3911:				; Set/Reset 1st ALV
3912:				; Scan the disk map addressed by dptr for non-zero
3913:				; entries, the allocation vector entry corresponding
3914:				; to a non-zero entry is set to the value of c (0,1)
3915:	13A6' CD4011  		CALL	GETDPTRA	; hl = buffa + dptr
3916:				; hl addresses the beginning of the directory entry
3917:	13A9' 111000  		LD	DE,DSKMAP
3918:	13AC' 19      		ADD	HL,DE		; hl now addresses the disk map
3919:	13AD' C5      		PUSH	BC		; Save the 0/1 bit to set
3920:	13AE' 0E11    		LD	C,FCBLEN-DSKMAP+1; size of single byte disk map + 1
3921:	13B0'         	SCANDM0:
3922:				; Loop once for each disk map entry
3923:	13B0' D1      		POP	DE		; Recall bit parity
3924:	13B1' 0D      		DEC	C
3925:	13B2' C8      		RET	Z		; all done scanning?
3926:				; no, get next entry for scan
3927:	13B3' D5      		PUSH	DE		; Replace bit parity
3928:	13B4' 3AA328  		LD	A,(SINGLE)
3929:	13B7' B7      		OR	A
3930:	13B8' CAC313  		JP	Z,SCANDM1
3931:				; single byte scan operation
3932:	13BB' C5      		PUSH	BC		; Save counter
3933:	13BC' E5      		PUSH	HL		; Save map address
3934:	13BD' 4E      		LD	C,(HL)
3935:	13BE' 0600    		LD	B,0		; bc=block#
3936:	13C0' C3C913  		JP	SCANDM2
3937:	13C3'         	SCANDM1:
3938:				; double byte scan operation
3939:	13C3' 0D      		DEC	C		; count for double byte
3940:	13C4' C5      		PUSH	BC		; Save counter
3941:	13C5' 4E      		LD	C,(HL)
3942:	13C6' 23      		INC	HL
3943:	13C7' 46      		LD	B,(HL)		; bc=block#
3944:	13C8' E5      		PUSH	HL		; Save map address
3945:	13C9'         	SCANDM2:
3946:				; Arrive here with bc=block#, e=0/1
3947:	13C9' 79      		LD	A,C
3948:	13CA' B0      		OR	B		; Skip if = 0000
3949:	13CB' CAD813  		JP	Z,SCANDM3
3950:	13CE' 2A8528  		LD	HL,(MAXALL)	; Check invalid index
3951:	13D1' 7D      		LD	A,L
3952:	13D2' 91      		SUB	C
3953:	13D3' 7C      		LD	A,H
3954:	13D4' 98      		SBC	A,B		; maxall - block#
3955:	13D5' D46813  		CALL	NC,SETALLOCBIT
3956:				; bit set to 0/1
3957:	13D8'         	SCANDM3:
3958:	13D8' E1      		POP	HL
3959:	13D9' 23      		INC	HL		; to next bit position
3960:	13DA' C1      		POP	BC		; Recall counter
3961:	13DB' C3B013  		JP	SCANDM0		; for another item
3962:			
3963:	13DE'         	GET$NALBS: ; Get # of allocation vector bytes
3964:	13DE' 2A8528  		LD	HL,(MAXALL)
3965:	13E1' 0E03    		LD	C,3
3966:				; number of bytes in allocation vector is (maxall/8)+1
3967:	13E3' CDAB10  		CALL	HLROTR
3968:	13E6' 23      		INC	HL
3969:	13E7' C9      		RET
3970:			
3971:	0000'         		IF MPM
3985:				ENDIF
3986:			
3987:	13E8'         	INITIALIZE:
3988:				; Initialize the current disk
3989:				; lret = false ; set to true if $ file exists
3990:				; Compute the length of the allocation vector - 2
3991:			
3992:	0000'         		IF MPM
4004:				ELSE
4005:			
4006:	13E8' CD0C12  		CALL	TEST$MEDIA$FLAG
4007:	13EB' 3600    		LD	(HL),0
4008:			;;;	call discard$data ;[JCE] DRI Patch 13
4009:			;;;	call discard$dir
4010:			
4011:				ENDIF
4012:			;[JCE] DRI Patch 13
4013:			
4014:	FFFF'         		IF BANKED
4015:			;;;	; Is drive permanent with no chksum vector?
4016:			;;;	call chksiz$eq$8000h
4017:			;;;	jnz initialize2 ; no
4018:			;;;	; Is this an initial login operation?
4019:			;;;	; register A = 0
4020:			;;;	lhld lsn$add
4021:			;;;	cmp m
4022:			;;;	mvi m,2
4023:			;;;	call test$media$flag
4024:			;;;	mvi m,0 ; Reset media change flag
4025:	13ED' CDEB0E  		CALL	CHKSIZ$EQ$8000H
4026:	13F0' C2FF13  		JP	NZ,PATCH$13FF
4027:	13F3' 2A7128  		LD	HL,(LSN$ADD)
4028:	13F6' BE      		CP	(HL)
4029:	13F7' 00      		NOP
4030:	13F8' 00      		NOP
4031:	13F9' CAFF13  		JP	Z,PATCH$13FF
4032:	13FC' C3402D  		JP	PATCH$2D40
4033:			
4034:	13FF'         	PATCH$13FF:
4035:			
4036:	13FF' CD5212  		CALL	DISCARD$DATA
4037:	1402' CD5812  		CALL	DISCARD$DIR
4038:			
4039:	1405'         	INITIALIZE2:
4040:				ELSE	;BANKED
4044:				ENDIF
4045:			
4046:	1405' CDDE13  		CALL	GET$NALBS	; Get # of allocation vector bytes
4047:	1408' 44      		LD	B,H
4048:	1409' 4D      		LD	C,L		; Count down bc til zero
4049:	140A' 2A7728  		LD	HL,(ALLOCA)	; base of allocation vector
4050:				; Fill the allocation vector with zeros
4051:	140D'         	INITIAL0:
4052:	140D' 3600    		LD	(HL),0
4053:	140F' 23      		INC	HL		; alloc(i)=0
4054:	1410' 0B      		DEC	BC		; Count length down
4055:	1411' 78      		LD	A,B
4056:	1412' B1      		OR	C
4057:	1413' C20D14  		JP	NZ,INITIAL0
4058:			
4059:	1416' 2A6F28  		LD	HL,(DRVLBLA)
4060:	1419' 77      		LD	(HL),A		; Zero out drive desc byte
4061:			
4062:				; Set the reserved space for the directory
4063:			
4064:	141A' 2A8928  		LD	HL,(DIRBLK)
4065:	141D' EB      		EX	DE,HL
4066:	141E' 2A7728  		LD	HL,(ALLOCA)	; hl=.alloc()
4067:	1421' 73      		LD	(HL),E
4068:	1422' 23      		INC	HL
4069:	1423' 72      		LD	(HL),D		; sets reserved directory blks
4070:				; allocation vector initialized, home disk
4071:	1424' CD800E  		CALL	HOME
4072:				; cdrmax = 3 (scans at least one directory record)
4073:	1427' 2A6928  		LD	HL,(CDRMAXA)
4074:	142A' 3604    		LD	(HL),4
4075:	142C' 23      		INC	HL
4076:	142D' 3600    		LD	(HL),0
4077:			
4078:	142F' CD0113  		CALL	SETENDDIR	; dcnt = enddir
4079:	1432' 2A7D28  		LD	HL,(HASHTBLA)
4080:	1435' 22B128  		LD	(ARECORD1),HL
4081:			
4082:				; Read directory entries and check for allocated storage
4083:			
4084:	1438'         	INITIAL2:
4085:	1438' 0EFF    		LD	C,TRUE
4086:	143A' CD0813  		CALL	READ$DIR
4087:	143D' CDF812  		CALL	END$OF$DIR
4088:	FFFF'         		IF BANKED
4089:	1440' CA6A2D  		JP	Z,PATCH$2D6A	;[JCE] DRI Patch 13
4090:				ELSE
4092:				ENDIF
4093:				; not end of directory, valid entry?
4094:	1443' CD4011  		CALL	GETDPTRA	; hl = buffa + dptr
4095:	1446' EB      		EX	DE,HL
4096:	1447' 2AB128  		LD	HL,(ARECORD1)
4097:	144A' 7C      		LD	A,H
4098:	144B' A5      		AND	L
4099:	144C' 3C      		INC	A
4100:	144D' EB      		EX	DE,HL
4101:				; is hashtbla ~= 0ffffh
4102:	144E' C48F2B  		CALL	NZ,INIT$HASH	; yes - call init$hash
4103:	1451' 3E21    		LD	A,21H
4104:	1453' BE      		CP	(HL)
4105:	1454' CA3814  		JP	Z,INITIAL2	; Skip date & time records
4106:			
4107:	1457' 3EE5    		LD	A,EMPTY
4108:	1459' BE      		CP	(HL)
4109:	145A' CA3814  		JP	Z,INITIAL2	; go get another item
4110:			
4111:	145D' 3E20    		LD	A,20H
4112:	145F' BE      		CP	(HL)
4113:	1460' CA7414  		JP	Z,DRV$LBL
4114:	1463' 3E10    		LD	A,10H
4115:	1465' A6      		AND	(HL)
4116:	1466' C26E14  		JP	NZ,INITIAL3
4117:			
4118:				; Now scan the disk map for allocated blocks
4119:			
4120:	1469' 0E01    		LD	C,1		; set to allocated
4121:	146B' CDA613  		CALL	SCANDM$A
4122:	146E'         	INITIAL3:
4123:	146E' CD7611  		CALL	SETCDR		; set cdrmax to dcnt
4124:	1471' C33814  		JP	INITIAL2	; for another entry
4125:			
4126:	1474'         	DRV$LBL:
4127:	1474' 110C00  		LD	DE,EXTNUM
4128:	1477' 19      		ADD	HL,DE
4129:	1478' 7E      		LD	A,(HL)
4130:	1479' 2A6F28  		LD	HL,(DRVLBLA)
4131:	147C' 77      		LD	(HL),A
4132:	147D' C36E14  		JP	INITIAL3
4133:			
4134:	1480'         	COPY$DIRLOC:
4135:				; Copy directory location to lret following
4136:				; delete, rename, ... ops
4137:			
4138:	1480' 3A9D28  		LD	A,(DIRLOC)
4139:	1483' C3720A  		JP	STA$RET
4140:				; ret
4141:			
4142:	1486'         	COMPEXT:
4143:				; Compare extent# in a with that in c, return nonzero
4144:				; if they do not match
4145:	1486' C5      		PUSH	BC		; Save c's original value
4146:	1487' F5      		PUSH	AF
4147:	1488' 3A8428  		LD	A,(EXTMSK)
4148:	148B' 2F      		CPL
4149:	148C' 47      		LD	B,A
4150:				; b has negated form of extent mask
4151:	148D' 79      		LD	A,C
4152:	148E' A0      		AND	B
4153:	148F' 4F      		LD	C,A		; low bits removed from c
4154:	1490' F1      		POP	AF
4155:	1491' A0      		AND	B		; low bits removed from a
4156:	1492' 91      		SUB	C
4157:	1493' E61F    		AND	MAXEXT		; Set flags
4158:	1495' C1      		POP	BC		; Restore original values
4159:	1496' C9      		RET
4160:			
4161:	1497'         	GET$DIR$EXT:
4162:				; Compute directory extent from fcb
4163:				; Scan fcb disk map backwards
4164:	1497' CD4F10  		CALL	GETFCBA		; hl = .fcb(vrecord)
4165:	149A' 0E10    		LD	C,16
4166:	149C' 41      		LD	B,C
4167:	149D' 0C      		INC	C
4168:	149E' C5      		PUSH	BC
4169:				; b=dskmap pos (rel to 0)
4170:	149F'         	GET$DE0:
4171:	149F' C1      		POP	BC
4172:	14A0' 0D      		DEC	C
4173:	14A1' AF      		XOR	A		; Compare to zero
4174:	14A2'         	GET$DE1:
4175:	14A2' 2B      		DEC	HL
4176:	14A3' 05      		DEC	B		; Decr dskmap position
4177:	14A4' BE      		CP	(HL)
4178:	14A5' C2AC14  		JP	NZ,GET$DE2	; fcb(dskmap(b)) ~= 0
4179:	14A8' 0D      		DEC	C
4180:	14A9' C2A214  		JP	NZ,GET$DE1
4181:				; c = 0 -> all blocks = 0 in fcb disk map
4182:	14AC'         	GET$DE2:
4183:	14AC' 79      		LD	A,C
4184:	14AD' 329F28  		LD	(DMINX),A
4185:	14B0' 3AA328  		LD	A,(SINGLE)
4186:	14B3' B7      		OR	A
4187:	14B4' 78      		LD	A,B
4188:	14B5' C2B914  		JP	NZ,GET$DE3
4189:	14B8' 1F      		RRA			; not single, divide blk idx by 2
4190:	14B9'         	GET$DE3:
4191:	14B9' C5      		PUSH	BC
4192:	14BA' E5      		PUSH	HL		; Save dskmap position & count
4193:	14BB' 6F      		LD	L,A
4194:	14BC' 2600    		LD	H,0		; hl = non-zero blk idx
4195:				; Compute ext offset from last non-zero
4196:				; block index by shifting blk idx right
4197:				; 7 - blkshf
4198:	14BE' 3A8228  		LD	A,(BLKSHF)
4199:	14C1' 57      		LD	D,A
4200:	14C2' 3E07    		LD	A,7
4201:	14C4' 92      		SUB	D
4202:	14C5' 4F      		LD	C,A
4203:	14C6' CDAB10  		CALL	HLROTR
4204:	14C9' 45      		LD	B,L
4205:				; b = ext offset
4206:	14CA' 3A8428  		LD	A,(EXTMSK)
4207:	14CD' B8      		CP	B
4208:	14CE' E1      		POP	HL
4209:	14CF' DA9F14  		JP	C,GET$DE0
4210:				; Verify computed extent offset <= extmsk
4211:	14D2' CD3F10  		CALL	GETEXTA
4212:	14D5' 4E      		LD	C,(HL)
4213:	14D6' 2F      		CPL
4214:	14D7' E61F    		AND	MAXEXT
4215:	14D9' A1      		AND	C
4216:	14DA' B0      		OR	B
4217:				; dir ext = (fcb ext & (~ extmsk) & maxext) | ext offset
4218:	14DB' C1      		POP	BC		; Restore stack
4219:	14DC' C9      		RET			; a = directory extent
4220:			
4221:	14DD'         	SEARCHI:
4222:				; search initialization
4223:	14DD' 2ADBFB  		LD	HL,(INFO)
4224:	14E0' 22A028  		LD	(SEARCHA),HL	; searcha = info
4225:	14E3'         	SEARCHI1:
4226:	14E3' 79      		LD	A,C
4227:	14E4' 32E5FB  		LD	(SEARCHL),A	; searchl = c
4228:	14E7' CDA62B  		CALL	SET$HASH
4229:	14EA' 3EFF    		LD	A,0FFH
4230:	14EC' 329D28  		LD	(DIRLOC),A	; changed if actually found
4231:	14EF' C9      		RET
4232:			
4233:	14F0'         	SEARCH$NAMLEN:
4234:	14F0' 0E0F    		LD	C,NAMLEN
4235:	14F2' C3F714  		JP	SEARCH
4236:	14F5'         	SEARCH$EXTNUM:
4237:	14F5' 0E0C    		LD	C,EXTNUM
4238:	14F7'         	SEARCH:
4239:				; Search for directory element of length c at info
4240:	14F7' CDDD14  		CALL	SEARCHI
4241:	14FA'         	SEARCH1:; entry point used by rename
4242:	14FA' CD0113  		CALL	SETENDDIR	; dcnt = enddir
4243:	14FD' CDF511  		CALL	TST$LOG$FXS
4244:	1500' CC800E  		CALL	Z,HOME
4245:				; (drop through to searchn)
4246:			
4247:	1503'         	SEARCHN:
4248:				; Search for the next directory element, assuming
4249:				; a previous call on search which sets searcha and
4250:				; searchl
4251:			
4252:	0000'         		IF MPM
4258:				ELSE
4259:	1503' AF      		XOR	A
4260:	1504' 32BE28  		LD	(USER0PASS),A
4261:				ENDIF
4262:			
4263:	1507' CD6B2C  		CALL	SEARCH$HASH
4264:	150A' C2BA15  		JP	NZ,SEARCH$FIN
4265:	150D' 0E00    		LD	C,FALSE
4266:	150F' CD0813  		CALL	READ$DIR	; Read next dir element
4267:	1512' CDF812  		CALL	END$OF$DIR
4268:	1515' CABA15  		JP	Z,SEARCH$FIN
4269:				; not end of directory, scan for match
4270:	1518' 2AA028  		LD	HL,(SEARCHA)
4271:	151B' EB      		EX	DE,HL		; de=beginning of user fcb
4272:	151C' 1A      		LD	A,(DE)		; first character
4273:	151D' FEE5    		CP	EMPTY		; Keep scanning if empty
4274:	151F' CA2A15  		JP	Z,SEARCHNEXT
4275:				; not empty, may be end of logical directory
4276:	1522' D5      		PUSH	DE		; Save search address
4277:	1523' CD6911  		CALL	COMPCDR		; past logical end?
4278:	1526' D1      		POP	DE		; Recall address
4279:	1527' D2BA15  		JP	NC,SEARCH$FIN	; artificial stop
4280:	152A'         	SEARCHNEXT:
4281:	152A' CD4011  		CALL	GETDPTRA	; hl = buffa+dptr
4282:	152D' 3AE5FB  		LD	A,(SEARCHL)
4283:	1530' 4F      		LD	C,A		; length of search to c
4284:	1531' 0600    		LD	B,0		; b counts up, c counts down
4285:			
4286:	1533' 7E      		LD	A,(HL)
4287:	1534' FEE5    		CP	EMPTY
4288:	1536' CCED15  		CALL	Z,SAVE$DCNT$POS1
4289:			
4290:	FFFF'         		IF BANKED
4291:	1539' AF      		XOR	A
4292:	153A' 32A228  		LD	(SAVE$XFCB),A
4293:	153D' 7E      		LD	A,(HL)
4294:	153E' E6EF    		AND	11101111B
4295:	1540' BE      		CP	(HL)
4296:	1541' CA5715  		JP	Z,SEARCHLOOP
4297:	1544' EB      		EX	DE,HL
4298:	1545' BE      		CP	(HL)
4299:	1546' EB      		EX	DE,HL
4300:	1547' C25715  		JP	NZ,SEARCHLOOP
4301:	154A' 3A16FD  		LD	A,(FIND$XFCB)
4302:	154D' B7      		OR	A
4303:	154E' CA0315  		JP	Z,SEARCHN
4304:	1551' 32A228  		LD	(SAVE$XFCB),A
4305:	1554' C39415  		JP	SEARCHOK
4306:				ENDIF
4307:			
4308:	1557'         	SEARCHLOOP:
4309:	1557' 79      		LD	A,C
4310:	1558' B7      		OR	A
4311:	1559' CA9B15  		JP	Z,ENDSEARCH
4312:	155C' 1A      		LD	A,(DE)
4313:	155D' FE3F    		CP	'?'
4314:	155F' CA9415  		JP	Z,SEARCHOK	; ? in user fcb
4315:				; Scan next character if not ubytes
4316:	1562' 78      		LD	A,B
4317:	1563' FE0D    		CP	UBYTES
4318:	1565' CA9415  		JP	Z,SEARCHOK
4319:				; not the ubytes field, extent field?
4320:	1568' FE0C    		CP	EXTNUM		; may be extent field
4321:	156A' CA7C15  		JP	Z,SEARCHEXT	; Skip to search extent
4322:	156D' FE0E    		CP	MODNUM
4323:	156F' 1A      		LD	A,(DE)
4324:	1570' CCB715  		CALL	Z,SEARCHMOD
4325:	1573' 96      		SUB	(HL)
4326:	1574' E67F    		AND	7FH		; Mask-out flags/extent modulus
4327:	1576' C2C715  		JP	NZ,SEARCHNM	; Skip if not matched
4328:	1579' C39415  		JP	SEARCHOK	; matched character
4329:	157C'         	SEARCHEXT:
4330:	157C' 1A      		LD	A,(DE)
4331:				; Attempt an extent # match
4332:	157D' C5      		PUSH	BC		; Save counters
4333:			
4334:	0000'         		IF MPM
4345:				ENDIF
4346:			
4347:	157E' 4E      		LD	C,(HL)		; directory character to c
4348:	157F' CD8614  		CALL	COMPEXT		; Compare user/dir char
4349:			
4350:	1582' 47      		LD	B,A
4351:	1583' 3ABE28  		LD	A,(USER0PASS)
4352:	1586' 3C      		INC	A
4353:	1587' CADE15  		JP	Z,SAVE$DCNT$POS2
4354:				; Disable search of user 0 if any fcb
4355:				; is found under the current user #
4356:	158A' AF      		XOR	A
4357:	158B' 32BD28  		LD	(SEARCH$USER0),A
4358:	158E' 78      		LD	A,B
4359:			
4360:	158F' C1      		POP	BC		; Recall counters
4361:	1590' B7      		OR	A		; Set flag
4362:	1591' C20315  		JP	NZ,SEARCHN	; Skip if no match
4363:	1594'         	SEARCHOK:
4364:				; current character matches
4365:	1594' 13      		INC	DE
4366:	1595' 23      		INC	HL
4367:	1596' 04      		INC	B
4368:	1597' 0D      		DEC	C
4369:	1598' C35715  		JP	SEARCHLOOP
4370:	159B'         	ENDSEARCH:
4371:				; entire name matches, return dir position
4372:			
4373:	FFFF'         		IF BANKED
4374:	159B' 3AA228  		LD	A,(SAVE$XFCB)
4375:	159E' 3C      		INC	A
4376:	159F' C2AD15  		JP	NZ,ENDSEARCH1
4377:	15A2' 3A18FD  		LD	A,(XDCNT+1)
4378:	15A5' FEFE    		CP	0FEH
4379:	15A7' CCEA15  		CALL	Z,SAVE$DCNT$POS0
4380:	15AA' C30315  		JP	SEARCHN
4381:	15AD'         	ENDSEARCH1:
4382:				ENDIF
4383:			
4384:	15AD' AF      		XOR	A
4385:	15AE' 329D28  		LD	(DIRLOC),A	; dirloc = 0
4386:	15B1' 329F0D  		LD	(LRET),A	; lret = 0
4387:				; successful search -
4388:				; return with zero flag reset
4389:	15B4' 47      		LD	B,A
4390:	15B5' 04      		INC	B
4391:	15B6' C9      		RET
4392:	15B7'         	SEARCHMOD:
4393:	15B7' E63F    		AND	3FH
4394:	15B9' C9      		RET			; Mask off high 2 bits
4395:	15BA'         	SEARCH$FIN:
4396:				; end of directory, or empty name
4397:			
4398:	15BA' CDED15  		CALL	SAVE$DCNT$POS1
4399:			
4400:				; Set dcnt = 0ffffh
4401:	15BD' CD0113  		CALL	SETENDDIR	; may be artifical end
4402:	15C0'         	LRET$EQ$FF:
4403:				; unsuccessful search -
4404:				; return with zero flag set
4405:				; lret,low(aret) = 0ffh
4406:	15C0' 3EFF    		LD	A,255
4407:	15C2' 47      		LD	B,A
4408:	15C3' 04      		INC	B
4409:	15C4' C3720A  		JP	STA$RET
4410:			
4411:	15C7'         	SEARCHNM: ; search no match routine
4412:	15C7' 78      		LD	A,B
4413:	15C8' B7      		OR	A
4414:	15C9' C20315  		JP	NZ,SEARCHN	; fcb(0)?
4415:	15CC' 7E      		LD	A,(HL)
4416:	15CD' B7      		OR	A
4417:	15CE' C20315  		JP	NZ,SEARCHN	; dir fcb(0)=0?
4418:	15D1' 3ABD28  		LD	A,(SEARCH$USER0)
4419:	15D4' B7      		OR	A
4420:	15D5' CA0315  		JP	Z,SEARCHN
4421:	15D8' 32BE28  		LD	(USER0PASS),A
4422:			
4423:	0000'         		IF MPM
4425:				ENDIF
4426:			
4427:	15DB' C39415  		JP	SEARCHOK
4428:			
4429:	0000'         		IF MPM
4452:				ENDIF
4453:			
4454:	15DE'         	SAVE$DCNT$POS2:
4455:				; Save directory position of matching fcb
4456:				; under user 0 with matching extent # & modnum = 0
4457:				; a = 0 on entry
4458:	15DE' B0      		OR	B
4459:	15DF' C1      		POP	BC
4460:	15E0' 010315  		LD	BC,SEARCHN
4461:	15E3' C5      		PUSH	BC
4462:	15E4' C0      		RET	NZ
4463:	15E5' 23      		INC	HL
4464:	15E6' 23      		INC	HL
4465:	15E7' 7E      		LD	A,(HL)
4466:	15E8' B7      		OR	A
4467:	15E9' C0      		RET	NZ
4468:				; Call if user0pass = 0ffh &
4469:				;	  dir fcb(extnum) = fcb(extnum)
4470:				;	  dir fcb(modnum) = 0
4471:	15EA'         	SAVE$DCNT$POS0:
4472:	15EA' CDF515  		CALL	SAVE$DCNT$POS	; Return to searchn
4473:	15ED'         	SAVE$DCNT$POS1:
4474:				; Save directory position of first empty fcb
4475:				; or the end of the directory
4476:			
4477:	15ED' E5      		PUSH	HL
4478:	15EE' 2A17FD  		LD	HL,(XDCNT)
4479:	15F1' 24      		INC	H
4480:	15F2' C2FB15  		JP	NZ,SAVE$DCNT$POS$RET; Return if h ~= 0ffh
4481:			
4482:			
4483:	15F5'         	SAVE$DCNT$POS:
4484:	15F5' 2AE1FB  		LD	HL,(DCNT)
4485:	15F8' 2217FD  		LD	(XDCNT),HL
4486:			
4487:	0000'         		IF MPM
4490:				ENDIF
4491:			
4492:	15FB'         	SAVE$DCNT$POS$RET:
4493:	15FB' E1      		POP	HL
4494:	15FC' C9      		RET
4495:			
4496:	FFFF'         		IF BANKED
4497:			
4498:	15FD'         	INIT$XFCB$SEARCH:
4499:	15FD' 3EFF    		LD	A,0FFH
4500:	15FF'         	INIT$XFCB$SEARCH1:
4501:	15FF' 3216FD  		LD	(FIND$XFCB),A
4502:	1602' 3EFE    		LD	A,0FEH
4503:	1604' 3218FD  		LD	(XDCNT+1),A
4504:	1607' C9      		RET
4505:			
4506:	1608'         	DOES$XFCB$EXIST:
4507:	1608' 3A18FD  		LD	A,(XDCNT+1)
4508:	160B' FEFE    		CP	0FEH
4509:	160D' C8      		RET	Z
4510:	160E' CD0A19  		CALL	SET$DCNT$DBLK
4511:	1611' AF      		XOR	A
4512:	1612' CDFF15  		CALL	INIT$XFCB$SEARCH1
4513:	1615' 2AA028  		LD	HL,(SEARCHA)
4514:	1618' 7E      		LD	A,(HL)
4515:	1619' F610    		OR	10H
4516:	161B' 77      		LD	(HL),A
4517:	161C' 0E0C    		LD	C,EXTNUM
4518:	161E' CDE314  		CALL	SEARCHI1
4519:	1621' C30315  		JP	SEARCHN
4520:			
4521:	1624'         	XDCNT$EQ$DCNT:
4522:	1624' 2AE1FB  		LD	HL,(DCNT)
4523:	1627' 2217FD  		LD	(XDCNT),HL
4524:	162A' C9      		RET
4525:			
4526:	162B'         	RESTORE$DIR$FCB:
4527:	162B' CD0A19  		CALL	SET$DCNT$DBLK
4528:	162E' 0E0F    		LD	C,NAMLEN
4529:	1630' CDDD14  		CALL	SEARCHI
4530:	1633' C30315  		JP	SEARCHN
4531:				ENDIF
4532:			
4533:	1636'         	DELETE:
4534:				; Delete the currently addressed file
4535:	1636' CD1810  		CALL	GET$ATTS
4536:			
4537:	FFFF'         		IF BANKED
4538:	1639' 32B328  		LD	(ATTRIBUTES),A
4539:				; Make search return matching fcbs and xfcbs
4540:	163C'         	DELETEX:
4541:	163C' 3EFE    		LD	A,0FEH
4542:	163E' CDFF15  		CALL	INIT$XFCB$SEARCH1
4543:				ELSE
4548:				ENDIF
4549:			
4550:			; Delete pass 1 - check r/o attributes and xfcb passwords
4551:			
4552:	1641' CDF514  		CALL	SEARCH$EXTNUM
4553:	1644' C8      		RET	Z
4554:			
4555:	1645'         	DELETE00:
4556:	1645' CA8416  		JP	Z,DELETE1
4557:			
4558:	FFFF'         		IF BANKED
4559:				; Is addressed dir fcb an xfcb?
4560:	1648' CD4011  		CALL	GETDPTRA
4561:	164B' 7E      		LD	A,(HL)
4562:	164C' E610    		AND	10H
4563:	164E' C26B16  		JP	NZ,DELETE01	; yes
4564:			
4565:	0000'         		IF MPM
4567:				ENDIF
4568:			
4569:				; Check r/o attribute if this is not an
4570:				; xfcb only delete operation.
4571:	1651' 3AB328  		LD	A,(ATTRIBUTES)
4572:	1654' 17      		RLA
4573:	1655' D42811  		CALL	NC,CHECK$RODIR
4574:				ELSE
4576:				ENDIF
4577:			
4578:	FFFF'         		IF BANKED
4579:				; Are xfcb passwords enabled?
4580:	1658' CD731F  		CALL	GET$DIR$MODE
4581:	165B' 17      		RLA
4582:	165C' DA7E16  		JP	C,DELETE02	; no
4583:				ENDIF
4584:			
4585:				; Is this a wild card delete operation?
4586:	165F' 2ADBFB  		LD	HL,(INFO)
4587:	1662' CD3917  		CALL	CHK$WILD
4588:	1665' CA7E16  		JP	Z,DELETE02	; yes
4589:				; Not wild & passwords inactive
4590:				; Skip to pass 2
4591:	1668' C38A16  		JP	DELETE11
4592:			
4593:	FFFF'         		IF BANKED
4594:			
4595:	166B'         	DELETE01:
4596:				; Check xfcb password if passwords enabled
4597:	166B' CD731F  		CALL	GET$DIR$MODE
4598:	166E' 17      		RLA
4599:	166F' D27E16  		JP	NC,DELETE02
4600:	1672' CDD420  		CALL	CHK$XFCB$PASSWORD
4601:	1675' CA7E16  		JP	Z,DELETE02
4602:	1678' CD851F  		CALL	CHK$PW$ERROR
4603:	167B' C33C16  		JP	DELETEX
4604:				ENDIF
4605:			
4606:	167E'         	DELETE02:
4607:	167E' CD0315  		CALL	SEARCHN
4608:	1681' C34516  		JP	DELETE00
4609:			
4610:			; Delete pass 2 - delete all matching fcbs and/or xfcbs.
4611:			
4612:	1684'         	DELETE1:
4613:	1684' CDF514  		CALL	SEARCH$EXTNUM
4614:			
4615:	1687'         	DELETE10:
4616:	1687' CA8014  		JP	Z,COPY$DIRLOC
4617:	168A'         	DELETE11:
4618:	168A' CD4011  		CALL	GETDPTRA
4619:			
4620:	FFFF'         		IF BANKED
4621:				; Is addressed dir fcb an xfcb?
4622:	168D' 7E      		LD	A,(HL)
4623:	168E' E610    		AND	10H
4624:	1690' C29B16  		JP	NZ,DELETE12	; yes
4625:	0000'         		IF MPM
4629:				ENDIF
4630:				; Is this delete operation xfcb only?
4631:	1693' 3AB328  		LD	A,(ATTRIBUTES)
4632:	1696' E680    		AND	80H
4633:	1698' C29D16  		JP	NZ,DELETE13	; yes
4634:				ENDIF
4635:			
4636:	169B'         	DELETE12:
4637:				; Delete dir fcb or xfcb
4638:				; if fcb free all alocated blocks.
4639:			
4640:	169B' 36E5    		LD	(HL),EMPTY
4641:			
4642:	FFFF'         		IF BANKED
4643:			
4644:	169D'         	DELETE13:
4645:	169D' F5      		PUSH	AF		; Z flag set => free FCB blocks
4646:				; Zero password mode byte in sfcb if sfcb exists
4647:				; Does sfcb exist?
4648:	169E' CD1021  		CALL	GETDTBA$8
4649:	16A1' B7      		OR	A
4650:	16A2' C2A616  		JP	NZ,$+4		; no
4651:				; Zero mode byte
4652:	16A5' 77      		LD	(HL),A
4653:				ENDIF
4654:			
4655:	16A6' CD9A12  		CALL	WRDIR
4656:	16A9' 0E00    		LD	C,0
4657:			
4658:	FFFF'         		IF BANKED
4659:	16AB' F1      		POP	AF
4660:	16AC' CC8B13  		CALL	Z,SCANDM$AB
4661:				ELSE
4663:				ENDIF
4664:			
4665:	16AF' CDC82C  		CALL	FIX$HASH
4666:	16B2' CD0315  		CALL	SEARCHN
4667:	16B5' C38716  		JP	DELETE10
4668:			
4669:	16B8'         	GET$BLOCK:
4670:				; Given allocation vector position bc, find the zero bit
4671:				; closest to this position by searching left and right.
4672:				; if found, set the bit to one and return the bit position
4673:				; in hl.  if not found (i.e., we pass 0 on the left, or
4674:				; maxall on the right), return 0000 in hl
4675:	16B8' 50      		LD	D,B
4676:	16B9' 59      		LD	E,C		; copy of starting position to de
4677:	16BA'         	RIGHTTST:
4678:	16BA' 2A8528  		LD	HL,(MAXALL)	; value of maximum allocation#
4679:	16BD' 7B      		LD	A,E
4680:	16BE' 95      		SUB	L
4681:	16BF' 7A      		LD	A,D
4682:	16C0' 9C      		SBC	A,H		; right=maxall?
4683:	16C1' D2EE16  		JP	NC,RETBLOCK0	; return block 0000 if so
4684:	16C4' 13      		INC	DE
4685:	16C5' C5      		PUSH	BC
4686:	16C6' D5      		PUSH	DE		; left, right pushed
4687:	16C7' 42      		LD	B,D
4688:	16C8' 4B      		LD	C,E		; ready right for call
4689:	16C9' CD4E13  		CALL	GETALLOCBIT
4690:	16CC' 1F      		RRA
4691:	16CD' D2E616  		JP	NC,RETBLOCK	; Return block number if zero
4692:	16D0' D1      		POP	DE
4693:	16D1' C1      		POP	BC		; Restore left and right pointers
4694:	16D2'         	LEFTTST:
4695:	16D2' 79      		LD	A,C
4696:	16D3' B0      		OR	B
4697:	16D4' CABA16  		JP	Z,RIGHTTST	; Skip if left=0000
4698:				; left not at position zero, bit zero?
4699:	16D7' 0B      		DEC	BC
4700:	16D8' D5      		PUSH	DE
4701:	16D9' C5      		PUSH	BC		; left,right pushed
4702:	16DA' CD4E13  		CALL	GETALLOCBIT
4703:	16DD' 1F      		RRA
4704:	16DE' D2E616  		JP	NC,RETBLOCK	; return block number if zero
4705:				; bit is one, so try the right
4706:	16E1' C1      		POP	BC
4707:	16E2' D1      		POP	DE		; left, right restored
4708:	16E3' C3BA16  		JP	RIGHTTST
4709:	16E6'         	RETBLOCK:
4710:	16E6' 17      		RLA
4711:	16E7' 3C      		INC	A		; bit back into position and set to 1
4712:				; d contains the number of shifts required to reposition
4713:	16E8' CD7013  		CALL	ROTR		; move bit back to position and store
4714:	16EB' E1      		POP	HL
4715:	16EC' D1      		POP	DE		; hl returned value, de discarded
4716:	16ED' C9      		RET
4717:	16EE'         	RETBLOCK0:
4718:				; cannot find an available bit, return 0000
4719:	16EE' 79      		LD	A,C
4720:	16EF' B0      		OR	B
4721:	16F0' C2D216  		JP	NZ,LEFTTST	; also at beginning
4722:	16F3' 210000  		LD	HL,0000H
4723:	16F6' C9      		RET
4724:			
4725:	16F7'         	COPY$DIR:
4726:				; Copy fcb information starting at c for e bytes
4727:				; into the currently addressed directory entry
4728:	16F7' 1680    		LD	D,80H
4729:	16F9'         	COPY$DIR0:
4730:	16F9' CD1017  		CALL	COPY$DIR2
4731:	16FC' 0C      		INC	C
4732:	16FD'         	COPY$DIR1:
4733:	16FD' 0D      		DEC	C
4734:	16FE' CA9A12  		JP	Z,SEEK$COPY
4735:	1701' 7E      		LD	A,(HL)
4736:	1702' A0      		AND	B
4737:	1703' C5      		PUSH	BC
4738:	1704' 47      		LD	B,A
4739:	1705' 1A      		LD	A,(DE)
4740:	1706' E67F    		AND	7FH
4741:	1708' B0      		OR	B
4742:	1709' 77      		LD	(HL),A
4743:	170A' C1      		POP	BC
4744:	170B' 23      		INC	HL
4745:	170C' 13      		INC	DE
4746:	170D' C3FD16  		JP	COPY$DIR1
4747:	1710'         	COPY$DIR2:
4748:	1710' D5      		PUSH	DE		; Save length for later
4749:	1711' 0600    		LD	B,0		; double index to bc
4750:	1713' 2ADBFB  		LD	HL,(INFO)	; hl = source for data
4751:	1716' 09      		ADD	HL,BC
4752:	1717' 23      		INC	HL
4753:	1718' 7E      		LD	A,(HL)
4754:	1719' D624    		SUB	'$'
4755:	171B' CC2517  		CALL	Z,SET$SUBMIT$FLAG
4756:	171E' 2B      		DEC	HL
4757:	171F' EB      		EX	DE,HL		; de=.fcb(c), source for copy
4758:	1720' CD4011  		CALL	GETDPTRA	; hl=.buff(dptr), destination
4759:	1723' C1      		POP	BC		; de=source, hl=dest, c=length
4760:	1724' C9      		RET
4761:			
4762:	1725'         	SET$SUBMIT$FLAG:
4763:	1725' 11B3FB  		LD	DE,CCP$FLGS
4764:	1728' 1A      		LD	A,(DE)
4765:	1729' F601    		OR	1
4766:	172B' 12      		LD	(DE),A
4767:	172C' C9      		RET
4768:			
4769:	172D'         	CHECK$WILD:
4770:				; Check for ? in file name or type
4771:	172D' 2ADBFB  		LD	HL,(INFO)
4772:	1730'         	CHECK$WILD0: ; entry point used by rename
4773:	1730' CD3917  		CALL	CHK$WILD
4774:	1733' C0      		RET	NZ
4775:	1734' 3E09    		LD	A,9
4776:	1736' C3E523  		JP	SET$ARET
4777:			
4778:	1739'         	CHK$WILD:
4779:	1739' 0E0B    		LD	C,11
4780:	173B'         	CHK$WILD1:
4781:	173B' 23      		INC	HL
4782:	173C' 3E3F    		LD	A,3FH
4783:	173E' 96      		SUB	(HL)
4784:	173F' E67F    		AND	7FH
4785:	1741' C8      		RET	Z
4786:	1742' 0D      		DEC	C
4787:	1743' C23B17  		JP	NZ,CHK$WILD1
4788:	1746' B7      		OR	A
4789:	1747' C9      		RET
4790:			
4791:	1748'         	COPY$USER$NO:
4792:	1748' 2ADBFB  		LD	HL,(INFO)
4793:	174B' 7E      		LD	A,(HL)
4794:	174C' 011000  		LD	BC,DSKMAP
4795:	174F' 09      		ADD	HL,BC
4796:	1750' 77      		LD	(HL),A
4797:	1751' C9      		RET
4798:			
4799:	1752'         	RENAME:
4800:				; Rename the file described by the first half of
4801:				; the currently addressed file control block. The
4802:				; new name is contained in the last half of the
4803:				; currently addressed file control block.  The file
4804:				; name and type are changed, but the reel number
4805:				; is ignored.  The user number is identical.
4806:			
4807:				; Verify that the new file name does not exist.
4808:				; Also verify that no wild chars exist in
4809:				; either filename.
4810:			
4811:	0000'         		IF MPM
4814:				ENDIF
4815:			
4816:				; Verify that no wild chars exist in 1st filename.
4817:	1752' CD2D17  		CALL	CHECK$WILD
4818:			
4819:	FFFF'         		IF BANKED
4820:				; Check password of file to be renamed.
4821:	1755' CD781F  		CALL	CHK$PASSWORD
4822:	1758' C4851F  		CALL	NZ,CHK$PW$ERROR
4823:				; Setup search to scan for xfcbs.
4824:	175B' CDFD15  		CALL	INIT$XFCB$SEARCH
4825:				ENDIF
4826:			
4827:				; Copy user number to 2nd filename
4828:	175E' CD4817  		CALL	COPY$USER$NO
4829:	1761' 22A028  		LD	(SEARCHA),HL
4830:			
4831:				; Verify no wild chars exist in 2nd filename
4832:	1764' CD3017  		CALL	CHECK$WILD0
4833:			
4834:				; Verify new filename does not already exist
4835:	1767' 0E0C    		LD	C,EXTNUM
4836:	1769' 2AA028  		LD	HL,(SEARCHA)
4837:	176C' CDE314  		CALL	SEARCHI1
4838:	176F' CDFA14  		CALL	SEARCH1
4839:	1772' C2E323  		JP	NZ,FILE$EXISTS	; New filename exists
4840:			
4841:	FFFF'         		IF BANKED
4842:				; If an xfcb exists for the new filename, delete it.
4843:	1775' CD0816  		CALL	DOES$XFCB$EXIST
4844:	1778' C48A16  		CALL	NZ,DELETE11
4845:				ENDIF
4846:			
4847:	177B' CD4817  		CALL	COPY$USER$NO
4848:			
4849:	FFFF'         		IF BANKED
4850:	177E' CDFD15  		CALL	INIT$XFCB$SEARCH
4851:				ENDIF
4852:			
4853:				; Search up to the extent field
4854:	1781' CDF514  		CALL	SEARCH$EXTNUM
4855:	1784' C8      		RET	Z
4856:	1785' CD2811  		CALL	CHECK$RODIR	; may be r/o file
4857:			
4858:	0000'         		IF MPM
4860:				ENDIF
4861:			
4862:				; Copy position 0
4863:	1788'         	RENAME0:
4864:				; not end of directory, rename next element
4865:	1788' 0E10    		LD	C,DSKMAP
4866:	178A' 1E0C    		LD	E,EXTNUM
4867:	178C' CDF716  		CALL	COPY$DIR
4868:				; element renamed, move to next
4869:			
4870:	178F' CDC82C  		CALL	FIX$HASH
4871:	1792' CD0315  		CALL	SEARCHN
4872:	1795' C28817  		JP	NZ,RENAME0
4873:	1798'         	RENAME1:
4874:			
4875:	FFFF'         		IF BANKED
4876:	1798' CD0816  		CALL	DOES$XFCB$EXIST
4877:	179B' CA8014  		JP	Z,COPY$DIRLOC
4878:	179E' CD4817  		CALL	COPY$USER$NO
4879:	17A1' C38817  		JP	RENAME0
4880:				ELSE
4882:				ENDIF
4883:			
4884:	17A4'         	INDICATORS:
4885:				; Set file indicators for current fcb
4886:	17A4' CD1810  		CALL	GET$ATTS	; Clear f5' through f8'
4887:	17A7' 32B328  		LD	(ATTRIBUTES),A
4888:			
4889:	FFFF'         		IF BANKED
4890:	17AA' CD781F  		CALL	CHK$PASSWORD
4891:	17AD' C4851F  		CALL	NZ,CHK$PW$ERROR
4892:				ENDIF
4893:			
4894:	17B0' CDF514  		CALL	SEARCH$EXTNUM	; through file type
4895:	17B3' C8      		RET	Z
4896:			
4897:	0000'         		IF MPM
4899:				ENDIF
4900:			
4901:	17B4'         	INDIC0:
4902:				; not end of directory, continue to change
4903:	17B4' 0E00    		LD	C,0
4904:	17B6' 1E0C    		LD	E,EXTNUM	; Copy name
4905:	17B8' CD1017  		CALL	COPY$DIR2
4906:	17BB' CD290E  		CALL	MOVE
4907:	17BE' 3AB328  		LD	A,(ATTRIBUTES)
4908:	17C1' E640    		AND	40H
4909:	17C3' CACE17  		JP	Z,INDIC1
4910:			
4911:				; If interface att f6' set, dir fcb(s1) = fcb(cr)
4912:			
4913:	17C6' E5      		PUSH	HL
4914:	17C7' CD4F10  		CALL	GETFCBA
4915:	17CA' 7E      		LD	A,(HL)
4916:	17CB' E1      		POP	HL
4917:	17CC' 23      		INC	HL
4918:	17CD' 77      		LD	(HL),A
4919:	17CE'         	INDIC1:
4920:	17CE' CD9A12  		CALL	SEEK$COPY
4921:	17D1' CD0315  		CALL	SEARCHN
4922:	17D4' CA8014  		JP	Z,COPY$DIRLOC
4923:	17D7' C3B417  		JP	INDIC0
4924:			
4925:	17DA'         	OPEN:
4926:				; Search for the directory entry, copy to fcb
4927:			;;;	call search$namlen	;[JCE] DRI Patch 13
4928:	17DA' CD832D  		CALL	PATCH$1E3E
4929:	17DD'         	OPEN1:
4930:	17DD' C8      		RET	Z		; Return with lret=255 if end
4931:				; not end of directory, copy fcb information
4932:	17DE'         	OPEN$COPY:
4933:	17DE' CD6211  		CALL	SETFWF
4934:	17E1' 5F      		LD	E,A
4935:	17E2' E5      		PUSH	HL
4936:	17E3' 2B      		DEC	HL
4937:	17E4' 2B      		DEC	HL
4938:	17E5' 56      		LD	D,(HL)
4939:	17E6' D5      		PUSH	DE		; Save extent# & module# with fcb write flag set
4940:	17E7' CD4011  		CALL	GETDPTRA
4941:	17EA' EB      		EX	DE,HL		; hl = .buff(dptr)
4942:	17EB' 2ADBFB  		LD	HL,(INFO)	; hl=.fcb(0)
4943:	17EE' 0E20    		LD	C,NXTREC	; length of move operation
4944:	17F0' CD290E  		CALL	MOVE		; from .buff(dptr) to .fcb(0)
4945:				; Note that entire fcb is copied, including indicators
4946:	17F3' CD9714  		CALL	GET$DIR$EXT
4947:	17F6' 4F      		LD	C,A
4948:				; Restore module # and extent #
4949:	17F7' D1      		POP	DE
4950:	17F8' E1      		POP	HL
4951:	17F9' 73      		LD	(HL),E
4952:	17FA' 2B      		DEC	HL
4953:	17FB' 2B      		DEC	HL
4954:	17FC' 72      		LD	(HL),D
4955:				; hl = .user extent#, c = dir extent#
4956:				; above move set fcb(reccnt) to dir(reccnt)
4957:				; if fcb ext < dir ext then fcb(reccnt) = fcb(reccnt) | 128
4958:				; if fcb ext = dir ext then fcb(reccnt) = fcb(reccnt)
4959:				; if fcb ext > dir ext then fcb(reccnt) = 0
4960:			
4961:	17FD'         	SET$RC:	; hl=.fcb(ext), c=dirext
4962:	17FD' 0600    		LD	B,0
4963:	17FF' EB      		EX	DE,HL
4964:	1800' 210300  		LD	HL,[RECCNT-EXTNUM]
4965:	1803' 19      		ADD	HL,DE
4966:				; Is fcb ext = dirext?
4967:	1804' 1A      		LD	A,(DE)
4968:	1805' 91      		SUB	C
4969:	1806' CA1218  		JP	Z,SET$RC2	; yes
4970:				; Is fcb ext > dirext?
4971:	1809' 78      		LD	A,B
4972:	180A' D21018  		JP	NC,SET$RC1	; yes - fcb(rc) = 0
4973:				; fcb ext  < dirext
4974:				; fcb(rc) = 128 | fcb(rc)
4975:	180D' 3E80    		LD	A,128
4976:	180F' B6      		OR	(HL)
4977:	1810'         	SET$RC1:
4978:	1810' 77      		LD	(HL),A
4979:	1811' C9      		RET
4980:	1812'         	SET$RC2:
4981:				; fcb ext = dirext
4982:	1812' 7E      		LD	A,(HL)
4983:	1813' B7      		OR	A
4984:	1814' C0      		RET	NZ		; ret if fcb(rc) ~= 0
4985:	1815'         	SET$RC3:
4986:	1815' 3600    		LD	(HL),0		; required by function 99
4987:	1817' 3A9F28  		LD	A,(DMINX)
4988:	181A' B7      		OR	A
4989:	181B' C8      		RET	Z		; ret if no blks in fcb
4990:	181C' 3680    		LD	(HL),128
4991:	181E' C9      		RET			; fcb(rc) = 128
4992:			
4993:	181F'         	MERGEZERO:
4994:				; hl = .fcb1(i), de = .fcb2(i),
4995:				; if fcb1(i) = 0 then fcb1(i) := fcb2(i)
4996:	181F' 7E      		LD	A,(HL)
4997:	1820' 23      		INC	HL
4998:	1821' B6      		OR	(HL)
4999:	1822' 2B      		DEC	HL
5000:	1823' C0      		RET	NZ		; return if = 0000
5001:	1824' 1A      		LD	A,(DE)
5002:	1825' 77      		LD	(HL),A
5003:	1826' 13      		INC	DE
5004:	1827' 23      		INC	HL		; low byte copied
5005:	1828' 1A      		LD	A,(DE)
5006:	1829' 77      		LD	(HL),A
5007:	182A' 1B      		DEC	DE
5008:	182B' 2B      		DEC	HL		; back to input form
5009:	182C' C9      		RET
5010:			
5011:	182D'         	RESTORE$RC:
5012:				; hl = .fcb(extnum)
5013:				; if fcb(rc) > 80h then fcb(rc) = fcb(rc) & 7fh
5014:	182D' E5      		PUSH	HL
5015:	182E' 110300  		LD	DE,[RECCNT-EXTNUM]
5016:	1831' 19      		ADD	HL,DE
5017:	1832' 7E      		LD	A,(HL)
5018:	1833' FE81    		CP	81H
5019:	1835' DA3B18  		JP	C,RESTORE$RC1
5020:	1838' E67F    		AND	7FH
5021:	183A' 77      		LD	(HL),A
5022:	183B'         	RESTORE$RC1:
5023:	183B' E1      		POP	HL
5024:	183C' C9      		RET
5025:			
5026:	183D'         	CLOSE:
5027:				; Locate the directory element and re-write it
5028:	183D' AF      		XOR	A
5029:	183E' 329F0D  		LD	(LRET),A
5030:			
5031:	0000'         		IF MPM
5033:				ENDIF
5034:			
5035:	1841' CD1A11  		CALL	NOWRITE
5036:	1844' C0      		RET	NZ		; Skip close if r/o disk
5037:				; Check file write flag - 0 indicates written
5038:	1845' CD4B11  		CALL	GETMODNUM	; fcb(modnum) in a
5039:	1848' E680    		AND	FWFMSK
5040:	184A' C0      		RET	NZ		; Return if bit remains set
5041:	184B'         	CLOSE1:
5042:	184B' CDE812  		CALL	CHK$INV$FCB
5043:	184E' CAF218  		JP	Z,MERGERR
5044:			
5045:	0000'         		IF MPM
5047:				ENDIF
5048:			
5049:			;;;	call get$dir$ext
5050:	1851' CDFC2C  		CALL	PATCH$1DFD	;[JCE] DRI patch 7
5051:			
5052:	1854' 4F      		LD	C,A
5053:	1855' 46      		LD	B,(HL)
5054:	1856' C5      		PUSH	BC
5055:				; b = original extent, c = directory extent
5056:				; Set fcb(ex) to directory extent
5057:	1857' 71      		LD	(HL),C
5058:				; Recompute fcb(rc)
5059:	1858' CD2D18  		CALL	RESTORE$RC
5060:				; Call set$rc if fcb ext > dir ext
5061:	185B' 79      		LD	A,C
5062:	185C' B8      		CP	B
5063:	185D' DCFD17  		CALL	C,SET$RC
5064:	1860' CD6C18  		CALL	CLOSE$FCB
5065:				; Restore original extent & reset fcb(rc)
5066:	1863' CD3F10  		CALL	GETEXTA
5067:	1866' C1      		POP	BC
5068:	1867' 4E      		LD	C,(HL)
5069:	1868' 70      		LD	(HL),B
5070:	1869' C3FD17  		JP	SET$RC		; Reset fcb(rc)
5071:			
5072:	186C'         	CLOSE$FCB:
5073:				; Locate file
5074:	186C' CDF014  		CALL	SEARCH$NAMLEN
5075:	186F' C8      		RET	Z		; Return if not found
5076:				; Merge the disk map at info with that at buff(dptr)
5077:	1870' 011000  		LD	BC,DSKMAP
5078:	1873' CD6726  		CALL	GET$FCB$ADDS
5079:	1876' 0E10    		LD	C,[FCBLEN-DSKMAP]; length of single byte dm
5080:	1878'         	MERGE0:
5081:	1878' 3AA328  		LD	A,(SINGLE)
5082:	187B' B7      		OR	A
5083:	187C' CA9318  		JP	Z,MERGED	; Skip to double
5084:				; This is a single byte map
5085:				; if fcb(i) = 0 then fcb(i) = buff(i)
5086:				; if buff(i) = 0 then buff(i) = fcb(i)
5087:				; if fcb(i) <> buff(i) then error
5088:	187F' 7E      		LD	A,(HL)
5089:	1880' B7      		OR	A
5090:	1881' 1A      		LD	A,(DE)
5091:	1882' C28618  		JP	NZ,FCBNZERO
5092:				; fcb(i) = 0
5093:	1885' 77      		LD	(HL),A		; fcb(i) = buff(i)
5094:	1886'         	FCBNZERO:
5095:	1886' B7      		OR	A
5096:	1887' C28C18  		JP	NZ,BUFFNZERO
5097:				; buff(i) = 0
5098:	188A' 7E      		LD	A,(HL)
5099:	188B' 12      		LD	(DE),A		; buff(i)=fcb(i)
5100:	188C'         	BUFFNZERO:
5101:	188C' BE      		CP	(HL)
5102:	188D' C2F218  		JP	NZ,MERGERR	; fcb(i) = buff(i)?
5103:	1890' C3A818  		JP	DMSET		; if merge ok
5104:	1893'         	MERGED:
5105:				; This is a double byte merge operation
5106:	1893' CD1F18  		CALL	MERGEZERO	; buff = fcb if buff 0000
5107:	1896' EB      		EX	DE,HL
5108:	1897' CD1F18  		CALL	MERGEZERO
5109:	189A' EB      		EX	DE,HL		; fcb = buff if fcb 0000
5110:				; They should be identical at this point
5111:	189B' 1A      		LD	A,(DE)
5112:	189C' BE      		CP	(HL)
5113:	189D' C2F218  		JP	NZ,MERGERR	; low same?
5114:	18A0' 13      		INC	DE
5115:	18A1' 23      		INC	HL		; to high byte
5116:	18A2' 1A      		LD	A,(DE)
5117:	18A3' BE      		CP	(HL)
5118:	18A4' C2F218  		JP	NZ,MERGERR	; high same?
5119:				; merge operation ok for this pair
5120:	18A7' 0D      		DEC	C		; extra count for double byte
5121:	18A8'         	DMSET:
5122:	18A8' 13      		INC	DE
5123:	18A9' 23      		INC	HL		; to next byte position
5124:	18AA' 0D      		DEC	C
5125:	18AB' C27818  		JP	NZ,MERGE0	; for more
5126:				; end of disk map merge, check record count
5127:				; de = .buff(dptr)+32, hl = .fcb(32)
5128:			
5129:	18AE' EB      		EX	DE,HL
5130:	18AF' 01ECFF  		LD	BC,-[FCBLEN-EXTNUM]
5131:	18B2' 09      		ADD	HL,BC
5132:	18B3' E5      		PUSH	HL
5133:	18B4' CD9714  		CALL	GET$DIR$EXT
5134:	18B7' D1      		POP	DE
5135:			
5136:				; hl = .fcb(extnum), de = .buff(dptr+extnum)
5137:			
5138:	18B8' CDF818  		CALL	COMPARE$EXTENTS
5139:			
5140:				; b=1 -> fcb(ext) ~= dir ext = buff(ext)
5141:				; b=2 -> fcb(ext) = dir ext ~= buff(ext)
5142:				; b=3 -> fcb(ext) = dir ext = buff(ext)
5143:			
5144:				; fcb(ext), buff(ext) = dir ext
5145:	18BB' 77      		LD	(HL),A
5146:	18BC' 12      		LD	(DE),A
5147:	18BD' C5      		PUSH	BC
5148:			
5149:	18BE' 010300  		LD	BC,[RECCNT-EXTNUM]
5150:	18C1' 09      		ADD	HL,BC
5151:	18C2' EB      		EX	DE,HL
5152:	18C3' 09      		ADD	HL,BC
5153:	18C4' C1      		POP	BC
5154:			
5155:				; hl = .buff(rc) , de = .fcb(rc)
5156:			
5157:	18C5' 05      		DEC	B
5158:	18C6' CAD918  		JP	Z,MRG$RC1	; fcb(rc) = buff(rc)
5159:			
5160:	18C9' 05      		DEC	B
5161:	18CA' CADA18  		JP	Z,MRG$RC2	; buff(rc) = fcb(rc)
5162:			
5163:	18CD' 1A      		LD	A,(DE)
5164:	18CE' BE      		CP	(HL)
5165:	18CF' DAD918  		JP	C,MRG$RC1	; Take larger rc
5166:	18D2' B7      		OR	A
5167:	18D3' C2DA18  		JP	NZ,MRG$RC2
5168:	18D6' CD1518  		CALL	SET$RC3
5169:			
5170:	18D9' EB      	MRG$RC1:EX	DE,HL
5171:			
5172:	18DA' 1A      	MRG$RC2:LD	A,(DE)
5173:	18DB' 77      		LD	(HL),A
5174:			
5175:	0000'         		IF MPM
5179:				ENDIF
5180:			
5181:				; Set t3' off indicating file update
5182:	18DC' CD4011  		CALL	GETDPTRA
5183:	18DF' 110B00  		LD	DE,11
5184:	18E2' 19      		ADD	HL,DE
5185:	18E3' 7E      		LD	A,(HL)
5186:	18E4' E67F    		AND	7FH
5187:	18E6' 77      		LD	(HL),A
5188:	18E7' CD6211  		CALL	SETFWF
5189:	18EA' 0E01    		LD	C,1
5190:	18EC' CD9013  		CALL	SCANDM$B	; Set 2nd ALV vector
5191:	18EF' C39A12  		JP	SEEK$COPY	; OK to "wrdir" here - 1.4 compat
5192:				; ret
5193:	18F2'         	MERGERR:
5194:				; elements did not merge correctly
5195:	18F2' CDDD12  		CALL	MAKE$FCB$INV
5196:	18F5' C3C015  		JP	LRET$EQ$FF
5197:			
5198:	18F8'         	COMPARE$EXTENTS:
5199:	18F8' 0601    		LD	B,1
5200:	18FA' BE      		CP	(HL)
5201:	18FB' C0      		RET	NZ
5202:	18FC' 04      		INC	B
5203:	18FD' EB      		EX	DE,HL
5204:	18FE' BE      		CP	(HL)
5205:	18FF' EB      		EX	DE,HL
5206:	1900' C0      		RET	NZ
5207:	1901' 04      		INC	B
5208:	1902' C9      		RET
5209:			
5210:	1903'         	SET$XDCNT:
5211:	1903' 21FFFF  		LD	HL,0FFFFH
5212:	1906' 2217FD  		LD	(XDCNT),HL
5213:	1909' C9      		RET
5214:			
5215:	190A'         	SET$DCNT$DBLK:
5216:	190A' 2A17FD  		LD	HL,(XDCNT)
5217:	190D'         	SET$DCNT$DBLK1:
5218:	190D' 3EFC    		LD	A,11111100B
5219:	190F' A5      		AND	L
5220:	1910' 6F      		LD	L,A
5221:	1911' 2B      		DEC	HL
5222:	1912' 22E1FB  		LD	(DCNT),HL
5223:			
5224:	0000'         		IF MPM
5227:				ENDIF
5228:			
5229:	1915' C9      		RET
5230:			
5231:	0000'         		IF MPM
5238:				ENDIF
5239:			
5240:	1916'         	MAKE:
5241:				; Create a new file by creating a directory entry
5242:				; then opening the file
5243:			
5244:			;;;	lxi h,xdcnt	;[JCE] DRI Patch 13
5245:	1916' CD762D  		CALL	PATCH$1E31
5246:			
5247:	1919' CDFB12  		CALL	TEST$FFFF
5248:	191C' C40A19  		CALL	NZ,SET$DCNT$DBLK
5249:			
5250:	191F' 2ADBFB  		LD	HL,(INFO)
5251:	1922' E5      		PUSH	HL		; Save fcb address, Look for E5
5252:	1923' 216228  		LD	HL,EFCB
5253:	1926' 22DBFB  		LD	(INFO),HL	; info = .empty
5254:	1929' 0E01    		LD	C,1
5255:			
5256:	192B' CDDD14  		CALL	SEARCHI
5257:	192E' CD0315  		CALL	SEARCHN
5258:			
5259:				; zero flag set if no space
5260:	1931' E1      		POP	HL		; Recall info address
5261:	1932' 22DBFB  		LD	(INFO),HL	; in case we return here
5262:	1935' C8      		RET	Z		; Return with error condition 255 if not found
5263:			
5264:	FFFF'         		IF BANKED
5265:				; Return early if making an xfcb
5266:	1936' 3A15FD  		LD	A,(MAKE$XFCB)
5267:	1939' B7      		OR	A
5268:	193A' C0      		RET	NZ
5269:				ENDIF
5270:			
5271:				; Clear the remainder of the fcb
5272:				; Clear s1 byte
5273:	193B' 110D00  		LD	DE,13
5274:	193E' 19      		ADD	HL,DE
5275:	193F' 72      		LD	(HL),D
5276:	1940' 23      		INC	HL
5277:				; Clear and save file write flag of modnum
5278:	1941' 7E      		LD	A,(HL)
5279:	1942' F5      		PUSH	AF
5280:	1943' E5      		PUSH	HL
5281:	1944' E63F    		AND	3FH
5282:	1946' 77      		LD	(HL),A
5283:	1947' 23      		INC	HL
5284:	1948' 3E01    		LD	A,1
5285:	194A' 0E11    		LD	C,FCBLEN-NAMLEN	; number of bytes to fill
5286:	194C'         	MAKE0:
5287:	194C' 72      		LD	(HL),D
5288:	194D' 23      		INC	HL
5289:	194E' 0D      		DEC	C
5290:	194F' C24C19  		JP	NZ,MAKE0
5291:	1952' 3D      		DEC	A
5292:	1953' 4A      		LD	C,D
5293:	1954' CC1221  		CALL	Z,GETDTBA
5294:	1957' B7      		OR	A
5295:	1958' 0E0A    		LD	C,10
5296:	195A' CA4C19  		JP	Z,MAKE0
5297:	195D' CD7611  		CALL	SETCDR		; may have extended the directory
5298:				; Now copy entry to the directory
5299:	1960' 0E00    		LD	C,0
5300:	1962' 112000  		LD	DE,FCBLEN
5301:	1965' CDF916  		CALL	COPY$DIR0
5302:				; and restore the file write flag
5303:	1968' E1      		POP	HL
5304:	1969' F1      		POP	AF
5305:	196A' 77      		LD	(HL),A
5306:				; and set the fcb write flag to "1"
5307:	196B' CDC82C  		CALL	FIX$HASH
5308:	196E' C36211  		JP	SETFWF
5309:			
5310:	1971'         	OPEN$REEL:
5311:				; Close the current extent, and open the next one
5312:				; if possible.	rmf is true if in read mode
5313:			
5314:	FFFF'         		IF BANKED
5315:	1971' CDDC0D  		CALL	RESET$COPY$CR$ONLY
5316:				ENDIF
5317:			
5318:	1974' CD3F10  		CALL	GETEXTA
5319:	1977' 7E      		LD	A,(HL)
5320:	1978' 4F      		LD	C,A
5321:	1979' 0C      		INC	C
5322:	197A' CD8614  		CALL	COMPEXT
5323:	197D' CADA19  		JP	Z,OPEN$REEL3
5324:	1980' E5      		PUSH	HL
5325:	1981' C5      		PUSH	BC
5326:	1982' CD3D18  		CALL	CLOSE
5327:	1985' C1      		POP	BC
5328:	1986' E1      		POP	HL
5329:	1987' 3A9F0D  		LD	A,(LRET)
5330:	198A' 3C      		INC	A
5331:	198B' C8      		RET	Z
5332:	198C' 3E1F    		LD	A,MAXEXT
5333:	198E' A1      		AND	C
5334:	198F' 77      		LD	(HL),A		; Incr extent field
5335:				; Advance to module & save
5336:	1990' 23      		INC	HL
5337:	1991' 23      		INC	HL
5338:	1992' 7E      		LD	A,(HL)
5339:	1993' 32A728  		LD	(SAVE$MOD),A
5340:	1996' C2A019  		JP	NZ,OPEN$REEL0	; Jump if in same module
5341:			
5342:	1999'         	OPEN$MOD:
5343:				; Extent number overflow, go to next module
5344:	1999' 34      		INC	(HL)		; fcb(modnum)=++1
5345:				; Module number incremented, check for overflow
5346:			
5347:	199A' 7E      		LD	A,(HL)
5348:	199B' E63F    		AND	3FH		; Mask high order bits
5349:			
5350:	199D' CAC919  		JP	Z,OPEN$R$ERR	; cannot overflow to zero
5351:			
5352:				; otherwise, ok to continue with new module
5353:	19A0'         	OPEN$REEL0:
5354:	19A0' CD0319  		CALL	SET$XDCNT	; Reset xdcnt for make
5355:			
5356:	0000'         		IF MPM
5358:				ENDIF
5359:			
5360:			;;;		call search$namlen	;[JCE] DRI Patch 13
5361:	19A3' CD832D  		CALL	PATCH$1E3E	;Next extent found?
5362:			
5363:	19A6' C2B919  		JP	NZ,OPEN$REEL1
5364:				; end of file encountered
5365:	19A9' 3A9C28  		LD	A,(RMF)
5366:	19AC' 3C      		INC	A		; 0ffh becomes 00 if read
5367:	19AD' CAC919  		JP	Z,OPEN$R$ERR	; sets lret = 1
5368:				; Try to extend the current file
5369:	19B0' CD1619  		CALL	MAKE
5370:				; cannot be end of directory
5371:	19B3' CAC919  		JP	Z,OPEN$R$ERR	; with lret = 1
5372:			
5373:	0000'         		IF MPM
5376:				ENDIF
5377:			
5378:	19B6' C3BC19  		JP	OPEN$REEL2
5379:	19B9'         	OPEN$REEL1:
5380:				; not end of file, open
5381:	19B9' CDDE17  		CALL	OPEN$COPY
5382:			
5383:	0000'         		IF MPM
5385:				ENDIF
5386:			
5387:	19BC'         	OPEN$REEL2:
5388:			
5389:	FFFF'         		IF NOT MPM
5390:	19BC' CD4112  		CALL	SET$LSN
5391:				ENDIF
5392:			
5393:	19BF' CD5810  		CALL	GETFCB		; Set parameters
5394:	19C2' AF      		XOR	A
5395:	19C3' 32A828  		LD	(VRECORD),A
5396:	19C6' C3720A  		JP	STA$RET		; lret = 0
5397:				; ret ; with lret = 0
5398:	19C9'         	OPEN$R$ERR:
5399:				; Restore module and extent
5400:	19C9' CD4B11  		CALL	GETMODNUM
5401:	19CC' 3AA728  		LD	A,(SAVE$MOD)
5402:	19CF' 77      		LD	(HL),A
5403:	19D0' 2B      		DEC	HL
5404:	19D1' 2B      		DEC	HL
5405:	19D2' 7E      		LD	A,(HL)
5406:	19D3' 3D      		DEC	A
5407:	19D4' E61F    		AND	1FH
5408:	19D6' 77      		LD	(HL),A
5409:	19D7' C3760A  		JP	SETLRET1	; lret = 1
5410:			
5411:	19DA'         	OPEN$REEL3:
5412:	19DA' 34      		INC	(HL)		; fcb(ex) = fcb(ex) + 1
5413:	19DB' CD9714  		CALL	GET$DIR$EXT
5414:	19DE' 4F      		LD	C,A
5415:				; Is new extent beyond dir$ext?
5416:	19DF' BE      		CP	(HL)
5417:	19E0' D2EC19  		JP	NC,OPEN$REEL4	; no
5418:	19E3' 35      		DEC	(HL)		; fcb(ex) = fcb(ex) - 1
5419:				; Is this a read fx?
5420:	19E4' 3A9C28  		LD	A,(RMF)
5421:	19E7' 3C      		INC	A
5422:	19E8' CA760A  		JP	Z,SETLRET1	; yes - Don't advance ext
5423:	19EB' 34      		INC	(HL)		; fcb(ex) = fcb(ex) + 1
5424:	19EC'         	OPEN$REEL4:
5425:	19EC' CD2D18  		CALL	RESTORE$RC
5426:	19EF' CDFD17  		CALL	SET$RC
5427:	19F2' C3BC19  		JP	OPEN$REEL2
5428:			
5429:	19F5'         	SEQDISKREAD:
5430:	19F5'         	DISKREAD: ; (may enter from seqdiskread)
5431:	19F5' CDEE12  		CALL	TST$INV$FCB	; Check for valid fcb
5432:	19F8' 3EFF    		LD	A,TRUE
5433:	19FA' 329C28  		LD	(RMF),A		; read mode flag = true (open$reel)
5434:			
5435:	0000'         		IF MPM
5437:				ENDIF
5438:			
5439:				; Read the next record from the current fcb
5440:	19FD' CD5810  		CALL	GETFCB		; sets parameters for the read
5441:	1A00'         	DISKREAD0:
5442:	1A00' 3AA828  		LD	A,(VRECORD)
5443:	1A03' 21A528  		LD	HL,RCOUNT
5444:	1A06' BE      		CP	(HL)		; vrecord-rcount
5445:				; Skip if rcount > vrecord
5446:	1A07' DA191A  		JP	C,RECORDOK
5447:			
5448:	0000'         		IF MPM
5452:				ENDIF
5453:			
5454:				; not enough records in the extent
5455:				; record count must be 128 to continue
5456:	1A0A' FE80    		CP	128		; vrecord = 128?
5457:	1A0C' C2760A  		JP	NZ,SETLRET1	; Skip if vrecord<>128
5458:	1A0F' CD7119  		CALL	OPEN$REEL	; Go to next extent if so
5459:				; Check for open ok
5460:	1A12' 3A9F0D  		LD	A,(LRET)
5461:	1A15' B7      		OR	A
5462:	1A16' C2760A  		JP	NZ,SETLRET1	; Stop at eof
5463:	1A19'         	RECORDOK:
5464:				; Arrive with fcb addressing a record to read
5465:			
5466:	FFFF'         		IF BANKED
5467:	1A19' CDD50D  		CALL	SET$COPY$CR$ONLY
5468:				ENDIF
5469:			
5470:	1A1C' CDE00F  		CALL	INDEX		; Z flag set if arecord = 0
5471:			
5472:	0000'         		IF MPM
5476:				ENDIF
5477:			
5478:	1A1F' CA760A  		JP	Z,SETLRET1	; Reading unwritten data
5479:	1A22'         	RECORDOK1:
5480:				; Record has been allocated, read it
5481:	1A22' CDF20F  		CALL	ATRAN		; arecord now a disk address
5482:	1A25' CD4D1A  		CALL	CHECK$NPRS
5483:	1A28' DA8210  		JP	C,SETFCB
5484:	1A2B' C23F1A  		JP	NZ,READ$DEBLOCK
5485:			
5486:	1A2E' CDB612  		CALL	SETDATA
5487:	1A31' CD0C0F  		CALL	SEEK		; to proper track,sector
5488:			
5489:	FFFF'         		IF BANKED
5490:	1A34' 3E01    		LD	A,1
5491:	1A36' CD54FF  		CALL	SETBNKF
5492:				ENDIF
5493:			
5494:	1A39' CD930E  		CALL	RDBUFF		; to dma address
5495:	1A3C' C38210  		JP	SETFCB		; Replace parameter
5496:			
5497:	1A3F'         	READ$DEBLOCK:
5498:	1A3F' 210000  		LD	HL,0
5499:	1A42' 229628  		LD	(LAST$BLOCK),HL
5500:	1A45' 3E01    		LD	A,1
5501:	1A47' CDFF28  		CALL	DEBLOCK$DTA
5502:	1A4A' C38210  		JP	SETFCB
5503:			
5504:	1A4D'         	CHECK$NPRS:
5505:				;
5506:				; on exit,  c flg	   -> no i/o operation
5507:				;	    z flg & ~c flg -> direct(physical) i/o operation
5508:				;	   ~z flg & ~c flg -> indirect(deblock) i/o operation
5509:				;
5510:				;	   Dir$cnt contains the number of 128 byte records
5511:				;	   to transfer directly.  This routine sets dir$cnt
5512:				;	   when initiating a sequence of direct physical
5513:				;	   i/o operations.  Dir$cnt is decremented each
5514:				;	   time check$nprs is called during such a sequence.
5515:				;
5516:				; Is direct transfer operation in progress?
5517:	1A4D' 3A9328  		LD	A,(BLK$OFF)
5518:	1A50' 47      		LD	B,A
5519:	1A51' 3A9028  		LD	A,(PHYMSK)
5520:	1A54' 4F      		LD	C,A
5521:	1A55' A0      		AND	B
5522:	1A56' F5      		PUSH	AF
5523:	1A57' 3A9828  		LD	A,(DIR$CNT)
5524:	1A5A' FE02    		CP	2
5525:	1A5C' DA681A  		JP	C,CHECK$NPR1	; no
5526:				; yes - Decrement direct record count
5527:	1A5F' 3D      		DEC	A
5528:	1A60' 329828  		LD	(DIR$CNT),A
5529:				; Are we at a new physical record?
5530:	1A63' F1      		POP	AF
5531:	1A64' 37      		SCF
5532:	1A65' C0      		RET	NZ		; no - ret with c flg set
5533:				; Perform physical i/o operation
5534:	1A66' AF      		XOR	A
5535:	1A67' C9      		RET			; Return with z flag set and c flag reset
5536:	1A68'         	CHECK$NPR1:
5537:				; Are we in mid-physical record?
5538:	1A68' F1      		POP	AF
5539:	1A69' CA721A  		JP	Z,CHECK$NPR11	; no
5540:	1A6C'         	CHECK$NPR1A:
5541:				; Is phymsk = 0?
5542:	1A6C' 79      		LD	A,C
5543:	1A6D' B7      		OR	A
5544:	1A6E' C8      		RET	Z		; yes - Don't deblock
5545:	1A6F'         	CHECK$NPR1B:
5546:				; Deblocking required
5547:	1A6F' F601    		OR	1
5548:	1A71' C9      		RET			; ret with z flg reset and c flg reset
5549:	1A72'         	CHECK$NPR11:
5550:	1A72' 79      		LD	A,C
5551:	1A73' 2F      		CPL
5552:	1A74' 57      		LD	D,A		; d = ~phymsk
5553:	1A75' 21A828  		LD	HL,VRECORD
5554:				; Is mult$num < 2?
5555:	1A78' 3A9928  		LD	A,(MULT$NUM)
5556:	1A7B' FE02    		CP	2
5557:	1A7D' DA6C1A  		JP	C,CHECK$NPR1A	; yes
5558:	1A80' 86      		ADD	A,(HL)
5559:	1A81' FE80    		CP	80H
5560:	1A83' DA881A  		JP	C,CHECK$NPR2
5561:	1A86' 3E80    		LD	A,80H
5562:	1A88'         	CHECK$NPR2: ; a = min(vrecord + mult$num),80h) = x
5563:	1A88' C5      		PUSH	BC		; Save low(arecord) & blkmsk, phymsk
5564:	1A89' 46      		LD	B,(HL)
5565:	1A8A' 367F    		LD	(HL),7FH	; vrecord = 7f
5566:	1A8C' C5      		PUSH	BC		; Save vrecord
5567:	1A8D' E5      		PUSH	HL		; Save .vrecord
5568:	1A8E' F5      		PUSH	AF		; Save x
5569:	1A8F' 3A8328  		LD	A,(BLKMSK)
5570:	1A92' 5F      		LD	E,A
5571:	1A93' 1C      		INC	E
5572:	1A94' 2F      		CPL
5573:	1A95' A0      		AND	B
5574:	1A96' 47      		LD	B,A
5575:				; b = vrecord & ~blkmsk
5576:				; e = blkmsk + 1
5577:	1A97' E1      		POP	HL		; h = x
5578:				; Is this a read function?
5579:	1A98' 3A9C28  		LD	A,(RMF)
5580:	1A9B' B7      		OR	A
5581:	1A9C' CAA71A  		JP	Z,CHECK$NPR21	; no
5582:				; Is rcount & ~phymsk < x?
5583:	1A9F' 3AA528  		LD	A,(RCOUNT)
5584:	1AA2' A2      		AND	D
5585:	1AA3' BC      		CP	H
5586:	1AA4' DAA81A  		JP	C,CHECK$NPR23	; yes
5587:	1AA7'         	CHECK$NPR21:
5588:	1AA7' 7C      		LD	A,H		; a = x
5589:	1AA8'         	CHECK$NPR23:
5590:	1AA8' 90      		SUB	B		; a = a - vrecord & ~blkmsk
5591:	1AA9' 4F      		LD	C,A		; c = max # of records from beginning of curr blk
5592:				; Is c < blkmsk+1?
5593:	1AAA' BB      		CP	E
5594:	1AAB' DA1C1B  		JP	C,CHECK$NPR8	; yes
5595:			
5596:	FFFF'         		IF BANKED
5597:	1AAE' C5      		PUSH	BC		; c = max # of records
5598:				; Compute maximum disk map position
5599:	1AAF' CDA40F  		CALL	DM$POSITION
5600:	1AB2' 47      		LD	B,A		; b = index of last block in extent
5601:				; Does the last block # = the current block #?
5602:	1AB3' 3A9F28  		LD	A,(DMINX)
5603:	1AB6' B8      		CP	B
5604:	1AB7' 5F      		LD	E,A
5605:	1AB8' CAFD1A  		JP	Z,CHECK$NPR5	; yes
5606:				; Compute # of blocks in sequence
5607:	1ABB' 4F      		LD	C,A
5608:	1ABC' C5      		PUSH	BC
5609:	1ABD' 0600    		LD	B,0
5610:	1ABF' CDCC0F  		CALL	GETDM		; hl = current block #
5611:	1AC2'         	CHECK$NPR4:
5612:				; Get next block #
5613:	1AC2' E5      		PUSH	HL
5614:	1AC3' 03      		INC	BC
5615:	1AC4' CDCC0F  		CALL	GETDM
5616:	1AC7' D1      		POP	DE
5617:	1AC8' 13      		INC	DE
5618:				; Does next block # = previous block # + 1?
5619:	1AC9' 7A      		LD	A,D
5620:	1ACA' 94      		SUB	H
5621:	1ACB' 57      		LD	D,A
5622:	1ACC' 7B      		LD	A,E
5623:	1ACD' 95      		SUB	L
5624:	1ACE' B2      		OR	D
5625:	1ACF' CAC21A  		JP	Z,CHECK$NPR4	; yes
5626:				; Is next block # = 0?
5627:	1AD2' 7C      		LD	A,H
5628:	1AD3' B5      		OR	L
5629:	1AD4' C2F51A  		JP	NZ,CHECK$NPR45	; no
5630:				; Is this a read function?
5631:	1AD7' 3A9C28  		LD	A,(RMF)
5632:	1ADA' B7      		OR	A
5633:	1ADB' C2F51A  		JP	NZ,CHECK$NPR45	; no
5634:				; Is next block # > maxall?
5635:	1ADE' 2A8528  		LD	HL,(MAXALL)
5636:	1AE1' 7D      		LD	A,L
5637:	1AE2' 93      		SUB	E
5638:	1AE3' 7C      		LD	A,H
5639:	1AE4' 9A      		SBC	A,D
5640:	1AE5' DAF51A  		JP	C,CHECK$NPR45	; yes
5641:				; Is next block # allocated?
5642:	1AE8' C5      		PUSH	BC
5643:	1AE9' D5      		PUSH	DE
5644:	1AEA' 42      		LD	B,D
5645:	1AEB' 4B      		LD	C,E
5646:	1AEC' CD4E13  		CALL	GETALLOCBIT
5647:	1AEF' E1      		POP	HL
5648:	1AF0' C1      		POP	BC
5649:	1AF1' 1F      		RRA
5650:	1AF2' D2C21A  		JP	NC,CHECK$NPR4	; no - it will be later
5651:	1AF5'         	CHECK$NPR45:
5652:	1AF5' 0D      		DEC	C
5653:	1AF6' D1      		POP	DE
5654:				; Is max dm position less than c?
5655:	1AF7' 7A      		LD	A,D
5656:	1AF8' B9      		CP	C
5657:	1AF9' DAFD1A  		JP	C,CHECK$NPR5	; yes
5658:	1AFC' 79      		LD	A,C		; no
5659:	1AFD'         	CHECK$NPR5: ; a = index of last block
5660:	1AFD' 93      		SUB	E
5661:	1AFE' 47      		LD	B,A
5662:	1AFF' 04      		INC	B		; b = # of consecutive blks
5663:	1B00' 3A8328  		LD	A,(BLKMSK)
5664:	1B03' 3C      		INC	A
5665:	1B04' 4F      		LD	C,A
5666:	1B05'         	CHECK$NPR6:
5667:	1B05' 05      		DEC	B
5668:	1B06' CA0D1B  		JP	Z,CHECK$NPR7
5669:	1B09' 81      		ADD	A,C
5670:	1B0A' C3051B  		JP	CHECK$NPR6
5671:	1B0D'         	CHECK$NPR7:
5672:	1B0D' C1      		POP	BC
5673:	1B0E' 41      		LD	B,C		; b = max # of records
5674:	1B0F' 4F      		LD	C,A		; c = (# of consecutive blks)*(blkmsk+1)
5675:	1B10' 3A9C28  		LD	A,(RMF)
5676:	1B13' B7      		OR	A
5677:	1B14' CA1C1B  		JP	Z,CHECK$NPR8
5678:	1B17' 78      		LD	A,B
5679:	1B18' B9      		CP	C
5680:	1B19' DA1D1B  		JP	C,CHECK$NPR9
5681:				ELSE
5683:				ENDIF
5684:			
5685:	1B1C'         	CHECK$NPR8:
5686:	1B1C' 79      		LD	A,C
5687:	1B1D'         	CHECK$NPR9:
5688:				; Restore vrecord
5689:	1B1D' E1      		POP	HL
5690:	1B1E' C1      		POP	BC
5691:	1B1F' 70      		LD	(HL),B
5692:	1B20' C1      		POP	BC
5693:				; a = max # of consecutive records including current blk
5694:				; b = low(arecord) & blkmsk
5695:				; c = phymsk
5696:				; Is mult$num > a - b
5697:	1B21' 219928  		LD	HL,MULT$NUM
5698:	1B24' 56      		LD	D,(HL)
5699:	1B25' 90      		SUB	B
5700:	1B26' BA      		CP	D
5701:	1B27' D22B1B  		JP	NC,CHECK$NPR10
5702:	1B2A' 57      		LD	D,A		; yes - use smaller value to compute dir$cnt
5703:	1B2B'         	CHECK$NPR10:
5704:				; Does this operation involve at least 1 physical record?
5705:	1B2B' 79      		LD	A,C
5706:	1B2C' 2F      		CPL
5707:	1B2D' A2      		AND	D
5708:	1B2E' 329828  		LD	(DIR$CNT),A
5709:	1B31' CA6F1A  		JP	Z,CHECK$NPR1B	; Deblocking required
5710:				; Flush any pending buffers before doing multiple reads
5711:	1B34' F5      		PUSH	AF
5712:	1B35' 3A9C28  		LD	A,(RMF)
5713:	1B38' B7      		OR	A
5714:	1B39' CA421B  		JP	Z,CHECK$NPR10A
5715:	1B3C' CD2025  		CALL	FLUSHX
5716:	1B3F' CDB612  		CALL	SETDATA
5717:	1B42'         	CHECK$NPR10A:
5718:	1B42' F1      		POP	AF
5719:	1B43' 67      		LD	H,A		; Save # of 128 byte records
5720:				; Does this operation involve more than 1 physical record?
5721:				; Register h contains number of 128 byte records
5722:	1B44' CD9D0F  		CALL	SHR$PHYSHF
5723:	1B47' 7C      		LD	A,H
5724:	1B48' FE01    		CP	1
5725:	1B4A' 4F      		LD	C,A
5726:	1B4B' C445FF  		CALL	NZ,MULTIOF	; yes - Make bios call
5727:	1B4E' AF      		XOR	A
5728:	1B4F' C9      		RET			; Return with z flg set
5729:			
5730:	0000'         		IF MPM
5759:				ENDIF
5760:			
5761:	1B50'         	RESET$FWF:
5762:	1B50' CD4B11  		CALL	GETMODNUM	; hl=.fcb(modnum), a=fcb(modnum)
5763:				; Reset the file write flag to mark as written fcb
5764:	1B53' E67F    		AND	(NOT FWFMSK) AND 0FFH; bit reset
5765:	1B55' 77      		LD	(HL),A		; fcb(modnum) = fcb(modnum) and 7fh
5766:	1B56' C9      		RET
5767:			
5768:	1B57'         	SET$FILEWF:
5769:	1B57' CD4B11  		CALL	GETMODNUM
5770:	1B5A' E640    		AND	01000000B
5771:	1B5C' F5      		PUSH	AF
5772:	1B5D' 7E      		LD	A,(HL)
5773:	1B5E' F640    		OR	01000000B
5774:	1B60' 77      		LD	(HL),A
5775:	1B61' F1      		POP	AF
5776:	1B62' C9      		RET
5777:			
5778:	1B63'         	SEQDISKWRITE:
5779:	1B63'         	DISKWRITE: ; (may enter here from seqdiskwrite above)
5780:	1B63' 3E00    		LD	A,FALSE
5781:	1B65' 329C28  		LD	(RMF),A		; read mode flag
5782:				; Write record to currently selected file
5783:			
5784:	1B68' CD3911  		CALL	CHECK$WRITE	; in case write protected
5785:			
5786:	FFFF'         		IF BANKED
5787:	1B6B' 3AB628  		LD	A,(XFCB$READ$ONLY)
5788:	1B6E' B7      		OR	A
5789:	1B6F' 3E03    		LD	A,3
5790:	1B71' C2E523  		JP	NZ,SET$ARET
5791:				ENDIF
5792:			
5793:	1B74' 3AB528  		LD	A,(HIGH$EXT)
5794:			
5795:	0000'         		IF MPM
5797:				ELSE
5798:	1B77' B7      		OR	A
5799:				ENDIF
5800:			
5801:				; Z flag reset if r/o mode
5802:	1B78' 3E03    		LD	A,3
5803:	1B7A' C2E523  		JP	NZ,SET$ARET
5804:			
5805:	1B7D' 2ADBFB  		LD	HL,(INFO)	; hl = .fcb(0)
5806:	1B80' CD2B11  		CALL	CHECK$ROFILE	; may be a read-only file
5807:			
5808:	1B83' CDEE12  		CALL	TST$INV$FCB	; Test for invalid fcb
5809:			
5810:	1B86' CD5321  		CALL	UPDATE$STAMP
5811:			
5812:	1B89' CD5810  		CALL	GETFCB		; to set local parameters
5813:	1B8C' 3AA828  		LD	A,(VRECORD)
5814:	1B8F' FE80    		CP	LSTREC+1	; vrecord-128
5815:	1B91' DA9C1B  		JP	C,DISKWRITE0
5816:	1B94' CD7119  		CALL	OPEN$REEL	; vrecord = 128, try to open next extent
5817:	1B97' 3A9F0D  		LD	A,(LRET)
5818:	1B9A' B7      		OR	A
5819:	1B9B' C0      		RET	NZ		; no available fcb
5820:	1B9C'         	DISKWRITE0:
5821:			
5822:	0000'         		IF MPM
5827:				ENDIF
5828:			
5829:				; Can write the next record, so continue
5830:	1B9C' CDE00F  		CALL	INDEX		; Z flag set if arecord = 0
5831:	1B9F' CABA1B  		JP	Z,DISKWRITE2
5832:				; Was the last write operation for the same block & drive?
5833:	1BA2' 21AA28  		LD	HL,ADRIVE
5834:	1BA5' 119528  		LD	DE,LASTDRIVE
5835:	1BA8' 0E03    		LD	C,3
5836:	1BAA' CD1F0E  		CALL	COMPARE
5837:	1BAD' CAB51B  		JP	Z,DISKWRITE15	; yes
5838:				; no - force preread in blocking/deblocking
5839:	1BB0' 3EFF    		LD	A,0FFH
5840:	1BB2' 329428  		LD	(LAST$OFF),A
5841:	1BB5'         	DISKWRITE15:
5842:			
5843:	0000'         		IF MPM
5861:				ENDIF
5862:			
5863:	1BB5' 0E00    		LD	C,0		; Marked as normal write operation for wrbuff
5864:	1BB7' C3111C  		JP	DISKWR1
5865:	1BBA'         	DISKWRITE2:
5866:			
5867:	0000'         		IF MPM
5870:				ENDIF
5871:			
5872:	FFFF'         		IF BANKED
5873:	1BBA' CDDC0D  		CALL	RESET$COPY$CR$ONLY
5874:				ENDIF
5875:			
5876:				; not allocated
5877:				; The argument to getblock is the starting
5878:				; position for the disk search, and should be
5879:				; the last allocated block for this file, or
5880:				; the value 0 if no space has been allocated
5881:	1BBD' CDA40F  		CALL	DM$POSITION
5882:	1BC0' 329F28  		LD	(DMINX),A	; Save for later
5883:	1BC3' 010000  		LD	BC,0000H	; May use block zero
5884:	1BC6' B7      		OR	A
5885:	1BC7' CAD11B  		JP	Z,NOPBLOCK	; Skip if no previous block
5886:				; Previous block exists at a
5887:	1BCA' 4F      		LD	C,A
5888:	1BCB' 0B      		DEC	BC		; Previous block # in bc
5889:	1BCC' CDCC0F  		CALL	GETDM		; Previous block # to hl
5890:	1BCF' 44      		LD	B,H
5891:	1BD0' 4D      		LD	C,L		; bc=prev block#
5892:	1BD1'         	NOPBLOCK:
5893:				; bc = 0000, or previous block #
5894:	1BD1' CDB816  		CALL	GET$BLOCK	; block # to hl
5895:				; Arrive here with block# or zero
5896:	1BD4' 7D      		LD	A,L
5897:	1BD5' B4      		OR	H
5898:	1BD6' C2DE1B  		JP	NZ,BLOCKOK
5899:				; Cannot find a block to allocate
5900:	1BD9' 3E02    		LD	A,2
5901:	1BDB' C3720A  		JP	STA$RET		; lret=2
5902:	1BDE'         	BLOCKOK:
5903:			
5904:	0000'         		IF MPM
5906:				ENDIF
5907:			
5908:				; allocated block number is in hl
5909:	1BDE' 22AB28  		LD	(ARECORD),HL
5910:	1BE1' 229628  		LD	(LAST$BLOCK),HL
5911:	1BE4' AF      		XOR	A
5912:	1BE5' 329428  		LD	(LAST$OFF),A
5913:	1BE8' 3AAA28  		LD	A,(ADRIVE)
5914:	1BEB' 329528  		LD	(LASTDRIVE),A
5915:	1BEE' EB      		EX	DE,HL		; block number to de
5916:	1BEF' 2ADBFB  		LD	HL,(INFO)
5917:	1BF2' 011000  		LD	BC,DSKMAP
5918:	1BF5' 09      		ADD	HL,BC		; hl=.fcb(dskmap)
5919:	1BF6' 3AA328  		LD	A,(SINGLE)
5920:	1BF9' B7      		OR	A		; Set flags for single byte dm
5921:	1BFA' 3A9F28  		LD	A,(DMINX)	; Recall dm index
5922:	1BFD' CA071C  		JP	Z,ALLOCWD	; Skip if allocating word
5923:				; Allocating a byte value
5924:	1C00' CD4611  		CALL	ADDH
5925:	1C03' 73      		LD	(HL),E		; single byte alloc
5926:	1C04' C30F1C  		JP	DISKWRU		; to continue
5927:	1C07'         	ALLOCWD:
5928:				; Allocate a word value
5929:	1C07' 4F      		LD	C,A
5930:	1C08' 0600    		LD	B,0		; double(dminx)
5931:	1C0A' 09      		ADD	HL,BC
5932:	1C0B' 09      		ADD	HL,BC		; hl=.fcb(dminx*2)
5933:	1C0C' 73      		LD	(HL),E
5934:	1C0D' 23      		INC	HL
5935:	1C0E' 72      		LD	(HL),D		; double wd
5936:	1C0F'         	DISKWRU:
5937:				; disk write to previously unallocated block
5938:	1C0F' 0E02    		LD	C,2		; marked as unallocated write
5939:	1C11'         	DISKWR1:
5940:				; Continue the write operation of no allocation error
5941:				; c = 0 if normal write, 2 if to prev unalloc block
5942:	1C11' C5      		PUSH	BC		; Save write flag
5943:	1C12' CDF20F  		CALL	ATRAN		; arecord set
5944:	1C15'         	DISKWR10:
5945:	1C15' 3ADFFB  		LD	A,(FX)
5946:	1C18' FE28    		CP	40
5947:	1C1A' C2841C  		JP	NZ,DISKWR11	; fx ~= wrt rndm zero fill
5948:	1C1D' 79      		LD	A,C
5949:	1C1E' 3D      		DEC	A
5950:	1C1F' 3D      		DEC	A
5951:	1C20' C2841C  		JP	NZ,DISKWR11	; old allocation
5952:			
5953:				; write random zero fill + new block
5954:			
5955:	1C23' C1      		POP	BC
5956:	1C24' F5      		PUSH	AF		; zero write flag
5957:	1C25' 2AAB28  		LD	HL,(ARECORD)
5958:	1C28' E5      		PUSH	HL
5959:	1C29' 219028  		LD	HL,PHYMSK
5960:	1C2C' 5E      		LD	E,(HL)
5961:	1C2D' 1C      		INC	E
5962:	1C2E' 57      		LD	D,A
5963:	1C2F' D5      		PUSH	DE
5964:	1C30' 2A7928  		LD	HL,(DIRBCBA)
5965:			
5966:	FFFF'         		IF BANKED
5967:	1C33' 5E      		LD	E,(HL)
5968:	1C34' 23      		INC	HL
5969:	1C35' 56      		LD	D,(HL)
5970:	1C36' EB      		EX	DE,HL
5971:	1C37'         	FILL00:
5972:	1C37' E5      		PUSH	HL
5973:	1C38' CD782B  		CALL	GET$NEXT$BCBA
5974:	1C3B' D1      		POP	DE
5975:	1C3C' C2371C  		JP	NZ,FILL00
5976:	1C3F' EB      		EX	DE,HL
5977:				ENDIF
5978:			
5979:				; Force prereads in blocking/deblocking
5980:				; Discard BCB
5981:	1C40' 3D      		DEC	A
5982:	1C41' 329428  		LD	(LAST$OFF),A
5983:	1C44' 77      		LD	(HL),A
5984:	1C45' CDBC12  		CALL	SETDIR1		; Set dma to BCB buffer
5985:				; Zero out BCB buffer
5986:	1C48' D1      		POP	DE
5987:	1C49' D5      		PUSH	DE
5988:	1C4A' AF      		XOR	A
5989:	1C4B'         	FILL0:
5990:	1C4B' 77      		LD	(HL),A
5991:	1C4C' 23      		INC	HL
5992:	1C4D' 14      		INC	D
5993:	1C4E' F24B1C  		JP	P,FILL0
5994:	1C51' 57      		LD	D,A
5995:	1C52' 1D      		DEC	E
5996:	1C53' C24B1C  		JP	NZ,FILL0
5997:				; Write 1st physical record of block
5998:	1C56' 2AB128  		LD	HL,(ARECORD1)
5999:	1C59' 0E02    		LD	C,2
6000:	1C5B'         	FILL1:
6001:	1C5B' 22AB28  		LD	(ARECORD),HL
6002:	1C5E' C5      		PUSH	BC
6003:	1C5F' CD4A12  		CALL	DISCARD$DATA$BCB
6004:	1C62' CD0C0F  		CALL	SEEK
6005:			
6006:	FFFF'         		IF BANKED
6007:	1C65' AF      		XOR	A
6008:	1C66' CD54FF  		CALL	SETBNKF
6009:				ENDIF
6010:			
6011:	1C69' C1      		POP	BC
6012:	1C6A' CD9E0E  		CALL	WRBUFF
6013:	1C6D' 2AAB28  		LD	HL,(ARECORD)
6014:	1C70' D1      		POP	DE
6015:	1C71' D5      		PUSH	DE
6016:				; Continue writing until blkmsk & arecord = 0
6017:	1C72' 19      		ADD	HL,DE
6018:	1C73' 3A8328  		LD	A,(BLKMSK)
6019:	1C76' A5      		AND	L
6020:	1C77' 0E00    		LD	C,0
6021:	1C79' C25B1C  		JP	NZ,FILL1
6022:				; Restore arecord
6023:	1C7C' E1      		POP	HL
6024:	1C7D' E1      		POP	HL
6025:	1C7E' 22AB28  		LD	(ARECORD),HL
6026:			
6027:	1C81' CDB612  		CALL	SETDATA		; Restore dma
6028:	1C84'         	DISKWR11:
6029:			
6030:	1C84' D1      		POP	DE
6031:	1C85' 3AA828  		LD	A,(VRECORD)
6032:	1C88' 57      		LD	D,A		; Load and save vrecord
6033:	1C89' D5      		PUSH	DE
6034:	1C8A' CD4D1A  		CALL	CHECK$NPRS
6035:			
6036:	1C8D' DABA1C  		JP	C,DONT$WRITE
6037:	1C90' CA9B1C  		JP	Z,WRITE
6038:			
6039:	1C93' 3E02    		LD	A,2		; deblock write code
6040:	1C95' CDFF28  		CALL	DEBLOCK$DTA
6041:	1C98' C3BA1C  		JP	DONT$WRITE
6042:	1C9B'         	WRITE:
6043:	1C9B' CDB612  		CALL	SETDATA
6044:	1C9E' CD0C0F  		CALL	SEEK
6045:			
6046:	FFFF'         		IF BANKED
6047:	1CA1' 3E01    		LD	A,1
6048:	1CA3' CD54FF  		CALL	SETBNKF
6049:				ENDIF
6050:			
6051:				; Discard matching BCB if write is direct
6052:	1CA6' CD4A12  		CALL	DISCARD$DATA$BCB
6053:			
6054:				; Set write flag to zero if arecord & blkmsk ~= 0
6055:			
6056:	1CA9' C1      		POP	BC
6057:	1CAA' C5      		PUSH	BC
6058:	1CAB' 3AAB28  		LD	A,(ARECORD)
6059:	1CAE' 218328  		LD	HL,BLKMSK
6060:	1CB1' A6      		AND	(HL)
6061:	1CB2' CAB71C  		JP	Z,WRITE0
6062:	1CB5' 0E00    		LD	C,0
6063:	1CB7'         	WRITE0:
6064:	1CB7' CD9E0E  		CALL	WRBUFF
6065:			
6066:	1CBA'         	DONT$WRITE:
6067:	1CBA' C1      		POP	BC		; c = 2 if a new block was allocated, 0 if not
6068:				; Increment record count if rcount<=vrecord
6069:	1CBB' 78      		LD	A,B
6070:	1CBC' 21A528  		LD	HL,RCOUNT
6071:	1CBF' BE      		CP	(HL)		; vrecord-rcount
6072:	1CC0' DAC71C  		JP	C,DISKWR2
6073:				; rcount <= vrecord
6074:	1CC3' 77      		LD	(HL),A
6075:	1CC4' 34      		INC	(HL)		; rcount = vrecord+1
6076:			
6077:	0000'         		IF MPM
6095:				ENDIF
6096:			
6097:	1CC5' 0E02    		LD	C,2		; Mark as record count incremented
6098:	1CC7'         	DISKWR2:
6099:				; a has vrecord, c=2 if new block or new record#
6100:	1CC7' 0D      		DEC	C
6101:	1CC8' 0D      		DEC	C
6102:	1CC9' C2CF1C  		JP	NZ,NOUPDATE
6103:	1CCC' CD501B  		CALL	RESET$FWF
6104:			
6105:	0000'         		IF MPM
6113:				ENDIF
6114:			
6115:	1CCF'         	NOUPDATE:
6116:				; Set file write flag if reset
6117:	1CCF' CD571B  		CALL	SET$FILEWF
6118:			
6119:	FFFF'         		IF BANKED
6120:	1CD2' C2DE1C  		JP	NZ,DISKWRITE3
6121:				; Reset fcb file write flag to ensure t3' gets
6122:				; reset by the close function
6123:	1CD5' CD501B  		CALL	RESET$FWF
6124:	1CD8' CDDC0D  		CALL	RESET$COPY$CR$ONLY
6125:	1CDB' C38210  		JP	SETFCB
6126:	1CDE'         	DISKWRITE3:
6127:	1CDE' CDD50D  		CALL	SET$COPY$CR$ONLY
6128:				ELSE
6130:				ENDIF
6131:	1CE1' C38210  		JP	SETFCB		; Replace parameters
6132:				; ret
6133:			
6134:	1CE4'         	RSEEK:
6135:				; Random access seek operation, c=0ffh if read mode
6136:				; fcb is assumed to address an active file control block
6137:				; (1st block of FCB = 0ffffh if previous bad seek)
6138:	1CE4' C5      		PUSH	BC		; Save r/w flag
6139:	1CE5' 2ADBFB  		LD	HL,(INFO)
6140:	1CE8' EB      		EX	DE,HL		; de will hold base of fcb
6141:	1CE9' 212100  		LD	HL,RANREC
6142:	1CEC' 19      		ADD	HL,DE		; hl=.fcb(ranrec)
6143:	1CED' 7E      		LD	A,(HL)
6144:	1CEE' E67F    		AND	7FH
6145:	1CF0' F5      		PUSH	AF		; record number
6146:	1CF1' 7E      		LD	A,(HL)
6147:	1CF2' 17      		RLA			; cy=lsb of extent#
6148:	1CF3' 23      		INC	HL
6149:	1CF4' 7E      		LD	A,(HL)
6150:	1CF5' 17      		RLA
6151:	1CF6' E61F    		AND	11111B		; a=ext#
6152:	1CF8' 4F      		LD	C,A		; c holds extent number, record stacked
6153:			
6154:	1CF9' 7E      		LD	A,(HL)
6155:	1CFA' E6F0    		AND	11110000B
6156:	1CFC' 23      		INC	HL
6157:	1CFD' B6      		OR	(HL)
6158:	1CFE' 0F      		RRCA
6159:	1CFF' 0F      		RRCA
6160:	1D00' 0F      		RRCA
6161:	1D01' 0F      		RRCA
6162:	1D02' 47      		LD	B,A
6163:				; b holds module #
6164:			
6165:				; Check high byte of ran rec <= 3
6166:	1D03' 7E      		LD	A,(HL)
6167:	1D04' E6FC    		AND	11111100B
6168:	1D06' E1      		POP	HL
6169:	1D07' 2E06    		LD	L,6
6170:	1D09' 7C      		LD	A,H
6171:			
6172:				; Produce error 6, seek past physical eod
6173:	1D0A' C2B01D  		JP	NZ,SEEKERR
6174:			
6175:				; otherwise, high byte = 0, a = sought record
6176:	1D0D' 212000  		LD	HL,NXTREC
6177:	1D10' 19      		ADD	HL,DE		; hl = .fcb(nxtrec)
6178:	1D11' 77      		LD	(HL),A		; sought rec# stored away
6179:			
6180:				; Arrive here with b=mod#, c=ext#, de=.fcb, rec stored
6181:				; the r/w flag is still stacked.  compare fcb values
6182:			
6183:	1D12' 3ADFFB  		LD	A,(FX)
6184:	1D15' FE63    		CP	99
6185:	1D17' CA6B1D  		JP	Z,RSEEK3
6186:				; Check module # first
6187:	1D1A' D5      		PUSH	DE
6188:	1D1B' CDE812  		CALL	CHK$INV$FCB
6189:	1D1E' D1      		POP	DE
6190:	1D1F' CA5B1D  		JP	Z,RANCLOSE
6191:	1D22' 210E00  		LD	HL,MODNUM
6192:	1D25' 19      		ADD	HL,DE
6193:	1D26' 78      		LD	A,B		; b=seek mod#
6194:	1D27' 96      		SUB	(HL)
6195:	1D28' E63F    		AND	3FH
6196:	1D2A' C25B1D  		JP	NZ,RANCLOSE	; same?
6197:				; Module matches, check extent
6198:	1D2D' 210C00  		LD	HL,EXTNUM
6199:	1D30' 19      		ADD	HL,DE
6200:	1D31' 7E      		LD	A,(HL)
6201:	1D32' B9      		CP	C
6202:	1D33' CAA41D  		JP	Z,SEEKOK2	; extents equal
6203:	1D36' CD8614  		CALL	COMPEXT
6204:	1D39' C25B1D  		JP	NZ,RANCLOSE
6205:				; Extent is in same directory fcb
6206:	1D3C' C5      		PUSH	BC
6207:	1D3D' CD9714  		CALL	GET$DIR$EXT
6208:	1D40' C1      		POP	BC
6209:	1D41' B9      		CP	C
6210:	1D42' D2501D  		JP	NC,RSEEK2	; jmp if dir$ext > ext
6211:	1D45' D1      		POP	DE
6212:	1D46' D5      		PUSH	DE
6213:	1D47' 1C      		INC	E
6214:	1D48' C2501D  		JP	NZ,RSEEK2	; jmp if write fx
6215:	1D4B' 1C      		INC	E
6216:	1D4C' D1      		POP	DE
6217:	1D4D' C3760A  		JP	SETLRET1	; error - reading unwritten data
6218:	1D50'         	RSEEK2:
6219:	1D50' 71      		LD	(HL),C		; fcb(ext) = c
6220:	1D51' 4F      		LD	C,A		; c = dir$ext
6221:				; hl=.fcb(ext),c=dir ext
6222:	1D52' CD2D18  		CALL	RESTORE$RC
6223:	1D55' CDFD17  		CALL	SET$RC
6224:	1D58' C3A11D  		JP	SEEKOK1
6225:	1D5B'         	RANCLOSE:
6226:	1D5B' C5      		PUSH	BC
6227:	1D5C' D5      		PUSH	DE		; Save seek mod#,ext#, .fcb
6228:	1D5D' CD3D18  		CALL	CLOSE		; Current extent closed
6229:	1D60' D1      		POP	DE
6230:	1D61' C1      		POP	BC		; Recall parameters and fill
6231:	1D62' 2E03    		LD	L,3		; Cannot close error #3
6232:	1D64' 3A9F0D  		LD	A,(LRET)
6233:	1D67' 3C      		INC	A
6234:	1D68' CAB01D  		JP	Z,SEEKERR
6235:	1D6B'         	RSEEK3:
6236:	1D6B' CD0319  		CALL	SET$XDCNT	; Reset xdcnt for make
6237:			
6238:	0000'         		IF MPM
6240:				ENDIF
6241:			
6242:	1D6E' 210C00  		LD	HL,EXTNUM
6243:	1D71' 19      		ADD	HL,DE
6244:	1D72' E5      		PUSH	HL
6245:	1D73' 56      		LD	D,(HL)
6246:	1D74' 71      		LD	(HL),C		; fcb(extnum)=ext#
6247:	1D75' 23      		INC	HL
6248:	1D76' 23      		INC	HL
6249:	1D77' 7E      		LD	A,(HL)
6250:	1D78' 5F      		LD	E,A
6251:	1D79' D5      		PUSH	DE
6252:	1D7A' E640    		AND	040H
6253:	1D7C' B0      		OR	B
6254:	1D7D' 77      		LD	(HL),A
6255:				; fcb(modnum)=mod#
6256:	1D7E' CDDA17  		CALL	OPEN		; Is the file present?
6257:	1D81' 3A9F0D  		LD	A,(LRET)
6258:	1D84' 3C      		INC	A
6259:	1D85' C29C1D  		JP	NZ,SEEKOK	; Open successful?
6260:				; Cannot open the file, read mode?
6261:	1D88' D1      		POP	DE
6262:	1D89' E1      		POP	HL
6263:	1D8A' C1      		POP	BC		; r/w flag to c (=0ffh if read)
6264:	1D8B' C5      		PUSH	BC
6265:	1D8C' E5      		PUSH	HL
6266:	1D8D' D5      		PUSH	DE		; Restore stack
6267:	1D8E' 2E04    		LD	L,4		; Seek to unwritten extent #4
6268:	1D90' 0C      		INC	C		; becomes 00 if read operation
6269:	1D91' CAA91D  		JP	Z,BADSEEK	; Skip to error if read operation
6270:				; Write operation, make new extent
6271:	1D94' CD1619  		CALL	MAKE
6272:	1D97' 2E05    		LD	L,5		; cannot create new extent #5
6273:	1D99' CAA91D  		JP	Z,BADSEEK	; no dir space
6274:			
6275:	0000'         		IF MPM
6277:				ENDIF
6278:			
6279:				; file make operation successful
6280:	1D9C'         	SEEKOK:
6281:	1D9C' C1      		POP	BC
6282:	1D9D' C1      		POP	BC		; Discard top 2 stacked items
6283:			
6284:	0000'         		IF MPM
6286:				ELSE
6287:	1D9E' CD4112  		CALL	SET$LSN
6288:				ENDIF
6289:			
6290:	1DA1'         	SEEKOK1:
6291:			
6292:	FFFF'         		IF BANKED
6293:	1DA1' CDDC0D  		CALL	RESET$COPY$CR$ONLY
6294:				ENDIF
6295:			
6296:	1DA4'         	SEEKOK2:
6297:	1DA4' C1      		POP	BC		; Discard r/w flag or .fcb(ext)
6298:	1DA5' AF      		XOR	A
6299:	1DA6' C3720A  		JP	STA$RET		; with zero set
6300:	1DA9'         	BADSEEK:
6301:				; Restore fcb(ext) & fcb(mod)
6302:	1DA9' D1      		POP	DE
6303:	1DAA' E3      		EX	(SP),HL		; Save error flag
6304:	1DAB' 72      		LD	(HL),D
6305:	1DAC' 23      		INC	HL
6306:	1DAD' 23      		INC	HL
6307:	1DAE' 73      		LD	(HL),E
6308:	1DAF' E1      		POP	HL		; Restore error flag
6309:	1DB0'         	SEEKERR:
6310:			
6311:	FFFF'         		IF BANKED
6312:	1DB0' CDDC0D  		CALL	RESET$COPY$CR$ONLY; Z flag set
6313:	1DB3' 3C      		INC	A		; Reset Z flag
6314:				ENDIF
6315:			
6316:	1DB4' C1      		POP	BC		; Discard r/w flag
6317:	1DB5' 7D      		LD	A,L
6318:	1DB6' C3720A  		JP	STA$RET		; lret=#, nonzero
6319:			
6320:	1DB9'         	RANDISKREAD:
6321:				; Random disk read operation
6322:	1DB9' 0EFF    		LD	C,TRUE		; marked as read operation
6323:	1DBB' CDE41C  		CALL	RSEEK
6324:	1DBE' CCF519  		CALL	Z,DISKREAD	; if seek successful
6325:	1DC1' C9      		RET
6326:			
6327:	1DC2'         	RANDISKWRITE:
6328:				; Random disk write operation
6329:	1DC2' 0E00    		LD	C,FALSE		; marked as write operation
6330:	1DC4' CDE41C  		CALL	RSEEK
6331:	1DC7' CC631B  		CALL	Z,DISKWRITE	; if seek successful
6332:	1DCA' C9      		RET
6333:			
6334:	1DCB'         	COMPUTE$RR:
6335:				; Compute random record position for getfilesize/setrandom
6336:	1DCB' EB      		EX	DE,HL
6337:	1DCC' 19      		ADD	HL,DE
6338:				; de=.buf(dptr) or .fcb(0), hl = .f(nxtrec/reccnt)
6339:	1DCD' 4E      		LD	C,(HL)
6340:	1DCE' 0600    		LD	B,0		; bc = 0000 0000 ?rrr rrrr
6341:	1DD0' 210C00  		LD	HL,EXTNUM
6342:	1DD3' 19      		ADD	HL,DE
6343:	1DD4' 7E      		LD	A,(HL)
6344:	1DD5' 0F      		RRCA
6345:	1DD6' E680    		AND	80H		; a=e000 0000
6346:	1DD8' 81      		ADD	A,C
6347:	1DD9' 4F      		LD	C,A
6348:	1DDA' 3E00    		LD	A,0
6349:	1DDC' 88      		ADC	A,B
6350:	1DDD' 47      		LD	B,A
6351:				; bc = 0000 000? errrr rrrr
6352:	1DDE' 7E      		LD	A,(HL)
6353:	1DDF' 0F      		RRCA
6354:	1DE0' E60F    		AND	0FH
6355:	1DE2' 80      		ADD	A,B
6356:	1DE3' 47      		LD	B,A
6357:				; bc = 000? eeee errrr rrrr
6358:	1DE4' 210E00  		LD	HL,MODNUM
6359:	1DE7' 19      		ADD	HL,DE
6360:	1DE8' 7E      		LD	A,(HL)		; a=xxmm mmmm
6361:	1DE9' 87      		ADD	A,A
6362:	1DEA' 87      		ADD	A,A
6363:	1DEB' 87      		ADD	A,A
6364:	1DEC' 87      		ADD	A,A		; cy=m a=mmmm 0000
6365:			
6366:	1DED' B7      		OR	A
6367:	1DEE' 80      		ADD	A,B
6368:	1DEF' 47      		LD	B,A
6369:	1DF0' F5      		PUSH	AF		; Save carry
6370:	1DF1' 7E      		LD	A,(HL)
6371:	1DF2' 1F      		RRA
6372:	1DF3' 1F      		RRA
6373:	1DF4' 1F      		RRA
6374:	1DF5' 1F      		RRA
6375:	1DF6' E603    		AND	00000011B	; a=0000 00mm
6376:	1DF8' 6F      		LD	L,A
6377:	1DF9' F1      		POP	AF
6378:	1DFA' 3E00    		LD	A,0
6379:	1DFC' 8D      		ADC	A,L		; Add carry
6380:	1DFD' C9      		RET
6381:			
6382:	1DFE'         	COMPARE$RR:
6383:	1DFE' 5F      		LD	E,A		; Save cy
6384:	1DFF' 79      		LD	A,C
6385:	1E00' 96      		SUB	(HL)
6386:	1E01' 57      		LD	D,A
6387:	1E02' 23      		INC	HL		; lst byte
6388:	1E03' 78      		LD	A,B
6389:	1E04' 9E      		SBC	A,(HL)
6390:	1E05' 23      		INC	HL		; middle byte
6391:	1E06' F5      		PUSH	AF
6392:	1E07' B2      		OR	D
6393:	1E08' 57      		LD	D,A
6394:	1E09' F1      		POP	AF
6395:	1E0A' 7B      		LD	A,E
6396:	1E0B' 9E      		SBC	A,(HL)		; carry if .fcb(ranrec) > directory
6397:	1E0C' C9      		RET
6398:			
6399:	1E0D'         	SET$RR:
6400:	1E0D' 73      		LD	(HL),E
6401:	1E0E' 2B      		DEC	HL
6402:	1E0F' 70      		LD	(HL),B
6403:	1E10' 2B      		DEC	HL
6404:	1E11' 71      		LD	(HL),C
6405:	1E12' C9      		RET
6406:			
6407:	1E13'         	GETFILESIZE:
6408:				; Compute logical file size for current fcb
6409:				; Zero the receiving ranrec field
6410:	1E13' CD3710  		CALL	GET$RRA
6411:	1E16' E5      		PUSH	HL		; Save position
6412:	1E17' 72      		LD	(HL),D
6413:	1E18' 23      		INC	HL
6414:	1E19' 72      		LD	(HL),D
6415:	1E1A' 23      		INC	HL
6416:	1E1B' 72      		LD	(HL),D		; =00 00 00
6417:	1E1C' CDF514  		CALL	SEARCH$EXTNUM
6418:	1E1F'         	GETSIZE:
6419:	1E1F' CA3E1E  		JP	Z,SETSIZE
6420:				; current fcb addressed by dptr
6421:	1E22' CD4011  		CALL	GETDPTRA
6422:	1E25' 110F00  		LD	DE,RECCNT	; ready for compute size
6423:	1E28' CDCB1D  		CALL	COMPUTE$RR
6424:				; a=0000 00mm bc = mmmm eeee errr rrrr
6425:				; Compare with memory, larger?
6426:	1E2B' E1      		POP	HL
6427:	1E2C' E5      		PUSH	HL		; Recall, replace .fcb(ranrec)
6428:	1E2D' CDFE1D  		CALL	COMPARE$RR
6429:	1E30' D40D1E  		CALL	NC,SET$RR
6430:	1E33' CD0315  		CALL	SEARCHN
6431:	1E36' 3E00    		LD	A,0
6432:	1E38' 329F0D  		LD	(ARET),A
6433:	1E3B' C31F1E  		JP	GETSIZE
6434:	1E3E'         	SETSIZE:
6435:			
6436:	1E3E' E1      		POP	HL		; Discard .fcb(ranrec)
6437:	1E3F' C9      		RET
6438:			
6439:	1E40'         	SETRANDOM:
6440:				; Set random record from the current file control block
6441:	1E40' EB      		EX	DE,HL
6442:	1E41' 112000  		LD	DE,NXTREC	; Ready params for computesize
6443:	1E44' CDCB1D  		CALL	COMPUTE$RR	; de=info, a=0000 00mm, bc=mmmm eeee errr rrrr
6444:	1E47' 212100  		LD	HL,RANREC
6445:	1E4A' 19      		ADD	HL,DE		; hl = .fcb(ranrec)
6446:	1E4B' 71      		LD	(HL),C
6447:	1E4C' 23      		INC	HL
6448:	1E4D' 70      		LD	(HL),B
6449:	1E4E' 23      		INC	HL
6450:	1E4F' 77      		LD	(HL),A		; to ranrec
6451:	1E50' C9      		RET
6452:			
6453:	1E51'         	DISK$SELECT:
6454:				; Select disk info for subsequent input or output ops
6455:	1E51' 32AA28  		LD	(ADRIVE),A
6456:	1E54'         	DISK$SELECT1: ; called by deblock
6457:	1E54' 77      		LD	(HL),A		; curdsk = seldsk or adrive
6458:	1E55' 57      		LD	D,A		; Save seldsk in register D for selectdisk call
6459:	1E56' 2A6528  		LD	HL,(DLOG)
6460:	1E59' CD1D11  		CALL	TESTVECTOR	; test$vector does not modify DE
6461:	1E5C' 5F      		LD	E,A
6462:	1E5D' D5      		PUSH	DE		; Send to seldsk, save for test below
6463:	1E5E' CD330E  		CALL	SELECTDISK
6464:	1E61' E1      		POP	HL		; Recall dlog vector
6465:	1E62' D2AB0D  		JP	NC,SEL$ERROR	; returns with C flag set if select ok
6466:				; Is the disk logged in?
6467:	1E65' 2D      		DEC	L		; reg l = 1 if so
6468:	1E66' C9      		RET
6469:			
6470:	1E67'         	TMPSELECT:
6471:	1E67' 21A428  		LD	HL,SELDSK
6472:	1E6A' 73      		LD	(HL),E
6473:			
6474:	1E6B'         	CURSELECT:
6475:	1E6B' 3AA428  		LD	A,(SELDSK)
6476:	1E6E' 21A928  		LD	HL,CURDSK
6477:	1E71' BE      		CP	(HL)
6478:	1E72' C2781E  		JP	NZ,SELECT
6479:	1E75' FEFF    		CP	0FFH
6480:	1E77' C0      		RET	NZ		; return if seldsk ~= ffh
6481:			
6482:	1E78'         	SELECT:
6483:	1E78' CD511E  		CALL	DISK$SELECT
6484:			
6485:	0000'         		IF MPM
6494:				ELSE
6495:	1E7B' C8      		RET	Z		; yes - drive previously logged in
6496:				ENDIF
6497:			
6498:	1E7C' CDE813  		CALL	INITIALIZE	; Log in the directory
6499:			
6500:				; Increment login sequence # if odd
6501:	1E7F' 2A7128  		LD	HL,(LSN$ADD)
6502:	1E82' 7E      		LD	A,(HL)
6503:	1E83' E601    		AND	1
6504:	1E85' F5      		PUSH	AF
6505:	1E86' 86      		ADD	A,(HL)
6506:	1E87' 77      		LD	(HL),A
6507:	1E88' F1      		POP	AF
6508:	1E89' C4E811  		CALL	NZ,SET$RLOG
6509:			
6510:	1E8C' CD0511  		CALL	SET$DLOG
6511:			
6512:	0000'         		IF MPM
6523:				ENDIF
6524:			
6525:	1E8F' C9      		RET
6526:			
6527:	1E90'         	RESELECTX:
6528:	1E90' AF      		XOR	A
6529:	1E91' 32B528  		LD	(HIGH$EXT),A
6530:			
6531:	FFFF'         		IF BANKED
6532:	1E94' 32B628  		LD	(XFCB$READ$ONLY),A
6533:				ENDIF
6534:			
6535:	1E97' C3B91E  		JP	RESELECT1
6536:			
6537:	1E9A'         	RESELECT:
6538:				; Check current fcb to see if reselection necessary
6539:	1E9A' 017F80  		LD	BC,807FH
6540:	1E9D' 2ADBFB  		LD	HL,(INFO)
6541:	1EA0' 110700  		LD	DE,7
6542:	1EA3' EB      		EX	DE,HL
6543:	1EA4' 19      		ADD	HL,DE
6544:			
6545:	FFFF'         		IF BANKED
6546:				; xfcb$read$only = 80h & fcb(7)
6547:	1EA5' 7E      		LD	A,(HL)
6548:	1EA6' A0      		AND	B
6549:	1EA7' 32B628  		LD	(XFCB$READ$ONLY),A
6550:				; fcb(7) = fcb(7) & 7fh
6551:	1EAA' 7E      		LD	A,(HL)
6552:	1EAB' A1      		AND	C
6553:	1EAC' 77      		LD	(HL),A
6554:				ENDIF
6555:			
6556:	0000'         		IF MPM
6573:				ELSE
6574:				; high$ext = 80h & fcb(8)
6575:	1EAD' 23      		INC	HL
6576:	1EAE' 7E      		LD	A,(HL)
6577:	1EAF' A0      		AND	B
6578:	1EB0' 32B528  		LD	(HIGH$EXT),A
6579:				; fcb(8) = fcb(8) & 7fh
6580:	1EB3' 7E      		LD	A,(HL)
6581:	1EB4' A1      		AND	C
6582:	1EB5' 77      		LD	(HL),A
6583:				ENDIF
6584:			
6585:				; fcb(ext) = fcb(ext) & 1fh
6586:	1EB6' CD5A11  		CALL	CLR$EXT
6587:	1EB9'         	RESELECT1:
6588:			
6589:	1EB9' 210000  		LD	HL,0
6590:			
6591:	FFFF'         		IF BANKED
6592:	1EBC' 2215FD  		LD	(MAKE$XFCB),HL	; make$xfcb,find$xfcb = 0
6593:				ENDIF
6594:	1EBF' 2217FD  		LD	(XDCNT),HL	; required by directory hashing
6595:			
6596:	1EC2' AF      		XOR	A
6597:	1EC3' 32BD28  		LD	(SEARCH$USER0),A
6598:	1EC6' 3D      		DEC	A
6599:	1EC7' 32DDFB  		LD	(RESEL),A	; Mark possible reselect
6600:	1ECA' 2ADBFB  		LD	HL,(INFO)
6601:	1ECD' 7E      		LD	A,(HL)		; drive select code
6602:	1ECE' 32BF28  		LD	(FCBDSK),A	; save drive code
6603:	1ED1' E61F    		AND	00011111B		; non zero is auto drive select
6604:	1ED3' 3D      		DEC	A		; Drive code normalized to 0..30, or 255
6605:	1ED4' 329E28  		LD	(LINFO),A	; Save drive code
6606:	1ED7' FEFF    		CP	0FFH
6607:	1ED9' CADF1E  		JP	Z,NOSELECT
6608:				; auto select function, seldsk saved above
6609:	1EDC' 32A428  		LD	(SELDSK),A
6610:	1EDF'         	NOSELECT:
6611:	1EDF' CD6B1E  		CALL	CURSELECT
6612:				; Set user code
6613:	1EE2' 3AE0FB  		LD	A,(USRCODE)	; 0...15
6614:	1EE5' 2ADBFB  		LD	HL,(INFO)
6615:	1EE8' 77      		LD	(HL),A
6616:	1EE9'         	NOSELECT0:
6617:				; Discard directory BCB's if drive is removable
6618:				; and fx = 15,17,19,22,23,30 etc.
6619:	1EE9' CDF511  		CALL	TST$LOG$FXS
6620:	1EEC' CC5812  		CALL	Z,DISCARD$DIR
6621:				; Check for media change on currently slected disk
6622:	1EEF' CDF51E  		CALL	CHECK$MEDIA
6623:				; Check for media change on any other disks
6624:	1EF2' C32F1F  		JP	CHECK$ALL$MEDIA
6625:			
6626:	1EF5'         	CHECK$MEDIA:
6627:				; Check media if DPH media flag set.
6628:				; Is DPH media flag set?
6629:	1EF5' CD0C12  		CALL	TEST$MEDIA$FLAG
6630:	1EF8' C8      		RET	Z		; no
6631:				; Test for media change by reading directory
6632:				; to current high water mark or until media change
6633:				; is detected.
6634:				; First reset DPH media flag & discard directory BCB's
6635:	1EF9' 3600    		LD	(HL),0
6636:	1EFB' CD5812  		CALL	DISCARD$DIR
6637:	1EFE' 2AE1FB  		LD	HL,(DCNT)
6638:	1F01' E5      		PUSH	HL
6639:	1F02' CD800E  		CALL	HOME
6640:	1F05' CD0113  		CALL	SETENDDIR
6641:	1F08'         	CHECK$MEDIA1:
6642:	1F08' 0E00    		LD	C,FALSE
6643:	1F0A' CD0E13  		CALL	R$DIR
6644:	1F0D' 21DEFB  		LD	HL,RELOG
6645:	1F10' 7E      		LD	A,(HL)
6646:	1F11' B7      		OR	A
6647:	1F12' CA241F  		JP	Z,CHECK$MEDIA2
6648:	1F15' 3600    		LD	(HL),0
6649:	1F17' E1      		POP	HL
6650:	1F18' 3ADFFB  		LD	A,(FX)
6651:	1F1B' FE30    		CP	48
6652:	1F1D' C8      		RET	Z
6653:	1F1E' CD3312  		CALL	DRV$RELOG
6654:	1F21' C31312  		JP	CHK$EXIT$FXS
6655:	1F24'         	CHECK$MEDIA2:
6656:	1F24' CD6911  		CALL	COMPCDR
6657:	1F27' DA081F  		JP	C,CHECK$MEDIA1
6658:	1F2A' E1      		POP	HL
6659:	1F2B' 22E1FB  		LD	(DCNT),HL
6660:	1F2E' C9      		RET
6661:			
6662:	1F2F'         	CHECK$ALL$MEDIA:
6663:				; This routine checks all logged-in drives for
6664:				; a set DPH media flag and pending buffers.  It reads
6665:				; the directory for these drives to verify that media
6666:				; has not changed.  If media has changed, the drives
6667:				; get reset (but not relogged-in).
6668:				; Is SCB media flag set?
6669:	1F2F' 21F0FB  		LD	HL,MEDIA$FLAG
6670:	1F32' 7E      		LD	A,(HL)
6671:	1F33' B7      		OR	A
6672:	1F34' C8      		RET	Z		; no
6673:				; Reset SCB media flag
6674:	1F35' 3600    		LD	(HL),0
6675:				; Test logged-in drives only
6676:	1F37' 2A6528  		LD	HL,(DLOG)
6677:	1F3A' 3E10    		LD	A,16
6678:	1F3C'         	CHK$AM1:
6679:	1F3C' 3D      		DEC	A
6680:	1F3D' 29      		ADD	HL,HL
6681:	1F3E' D2511F  		JP	NC,CHK$AM2
6682:				; A = drive #
6683:				; Select drive
6684:	1F41' F5      		PUSH	AF
6685:	1F42' E5      		PUSH	HL
6686:	1F43' 21A928  		LD	HL,CURDSK
6687:	1F46' CD511E  		CALL	DISK$SELECT
6688:				; Does drive have pending data buffers?
6689:	1F49' CD581F  		CALL	TEST$PENDING
6690:	1F4C' C4F51E  		CALL	NZ,CHECK$MEDIA	; yes
6691:	1F4F' E1      		POP	HL
6692:	1F50' F1      		POP	AF
6693:	1F51'         	CHK$AM2:
6694:	1F51' B7      		OR	A
6695:	1F52' C23C1F  		JP	NZ,CHK$AM1
6696:	1F55' C36B1E  		JP	CURSELECT
6697:			
6698:	1F58'         	TEST$PENDING:
6699:				; On return, Z flag reset if buffer pending
6700:			
6701:				; Does dta$bcba = 0ffffh
6702:	1F58' 2A7B28  		LD	HL,(DTABCBA)
6703:	1F5B' 7D      		LD	A,L
6704:	1F5C' A4      		AND	H
6705:	1F5D' 3C      		INC	A
6706:	1F5E' C8      		RET	Z		; yes
6707:			
6708:	FFFF'         		IF BANKED
6709:			
6710:	1F5F'         	TEST$P1:
6711:				; Does bcb addr = 0?
6712:	1F5F' 5E      		LD	E,(HL)
6713:	1F60' 23      		INC	HL
6714:	1F61' 56      		LD	D,(HL)
6715:	1F62' 7B      		LD	A,E
6716:	1F63' B2      		OR	D
6717:	1F64' C8      		RET	Z		; yes - no pending buffers
6718:	1F65' 210400  		LD	HL,4
6719:				ELSE
6721:				ENDIF
6722:			
6723:				; Is buffer pending?
6724:	1F68' 19      		ADD	HL,DE
6725:	1F69' 7E      		LD	A,(HL)
6726:	1F6A' B7      		OR	A		; A ~= 0 if so
6727:			
6728:	FFFF'         		IF BANKED
6729:	1F6B' C0      		RET	NZ		; yes
6730:				; no - advance to next bcb
6731:	1F6C' 210D00  		LD	HL,13
6732:	1F6F' 19      		ADD	HL,DE
6733:	1F70' C35F1F  		JP	TEST$P1
6734:				ELSE
6736:				ENDIF
6737:			
6738:	1F73'         	GET$DIR$MODE:
6739:	1F73' 2A6F28  		LD	HL,(DRVLBLA)
6740:	1F76' 7E      		LD	A,(HL)
6741:			
6742:	0000'         		IF NOT BANKED
6744:				ENDIF
6745:			
6746:	1F77' C9      		RET
6747:			
6748:	FFFF'         		IF BANKED
6749:			
6750:	1F78'         	CHK$PASSWORD:
6751:	1F78' CD731F  		CALL	GET$DIR$MODE
6752:	1F7B' E680    		AND	80H
6753:	1F7D' C8      		RET	Z
6754:			
6755:	1F7E'         	CHK$PW:	; Check password
6756:	1F7E' CD8320  		CALL	GETXFCB
6757:	1F81' C8      		RET	Z		; a = xfcb options
6758:	1F82' C30220  		JP	CMP$PW
6759:			
6760:	1F85'         	CHK$PW$ERROR:
6761:				; Disable special searches
6762:	1F85' AF      		XOR	A
6763:	1F86' 3218FD  		LD	(XDCNT+1),A
6764:				; pw$fcb = dir$xfcb
6765:	1F89' CD4011  		CALL	GETDPTRA
6766:	1F8C' EB      		EX	DE,HL
6767:	1F8D' 0E0C    		LD	C,12
6768:	1F8F' 21D728  		LD	HL,PW$FCB
6769:	1F92' E5      		PUSH	HL
6770:	1F93' CD290E  		CALL	MOVE
6771:	1F96' 1A      		LD	A,(DE)
6772:	1F97' 23      		INC	HL
6773:	1F98' 77      		LD	(HL),A
6774:	1F99' D1      		POP	DE
6775:	1F9A' 2ADBFB  		LD	HL,(INFO)
6776:	1F9D' 7E      		LD	A,(HL)
6777:	1F9E' 12      		LD	(DE),A
6778:				; push original info and xfcb password mode
6779:				; info = .pw$fcb
6780:	1F9F' E5      		PUSH	HL
6781:	1FA0' EB      		EX	DE,HL
6782:	1FA1' 22DBFB  		LD	(INFO),HL
6783:				; Does fcb(ext = 0, mod = 0) exist?
6784:	1FA4' CDF014  		CALL	SEARCH$NAMLEN
6785:	1FA7' CAE41F  		JP	Z,CHK$PWE2	; no
6786:				; Does sfcb exist for fcb ?
6787:	1FAA' CD1021  		CALL	GETDTBA$8
6788:	1FAD' B7      		OR	A
6789:	1FAE' C2D21F  		JP	NZ,CHK$PWE1	; no
6790:	1FB1' EB      		EX	DE,HL
6791:	1FB2' 21E428  		LD	HL,PW$MODE
6792:				; Is sfcb password mode nonzero?
6793:	1FB5' 46      		LD	B,(HL)
6794:	1FB6' 1A      		LD	A,(DE)
6795:	1FB7' 77      		LD	(HL),A
6796:	1FB8' B7      		OR	A
6797:	1FB9' CAE41F  		JP	Z,CHK$PWE2	; no
6798:				; Do password modes match?
6799:	1FBC' A8      		XOR	B
6800:	1FBD' E6E0    		AND	0E0H
6801:	1FBF' CAD21F  		JP	Z,CHK$PWE1	; yes
6802:				; no - update xfcb to match sfcb
6803:	1FC2' CD8320  		CALL	GETXFCB
6804:	1FC5' CAD21F  		JP	Z,CHK$PWE1	; no xfcb (error)
6805:	1FC8' 3AE428  		LD	A,(PW$MODE)
6806:	1FCB' 77      		LD	(HL),A
6807:	1FCC' CD1A11  		CALL	NOWRITE
6808:	1FCF' CC9A12  		CALL	Z,SEEK$COPY
6809:	1FD2'         	CHK$PWE1:
6810:	1FD2' E1      		POP	HL
6811:	1FD3' 22DBFB  		LD	(INFO),HL
6812:	1FD6' 3ADFFB  		LD	A,(FX)
6813:	1FD9' FE0F    		CP	15
6814:	1FDB' C8      		RET	Z
6815:	1FDC' FE16    		CP	22
6816:	1FDE' C8      		RET	Z
6817:			
6818:	1FDF'         	PW$ERROR: ; password error
6819:	1FDF' 3E07    		LD	A,7
6820:	1FE1' C3E523  		JP	SET$ARET
6821:			
6822:	1FE4'         	CHK$PWE2:
6823:	1FE4' AF      		XOR	A
6824:	1FE5' 32E428  		LD	(PW$MODE),A
6825:	1FE8' CD1A11  		CALL	NOWRITE
6826:	1FEB' C2FD1F  		JP	NZ,CHK$PWE3
6827:				; Delete xfcb
6828:	1FEE' CD8320  		CALL	GETXFCB
6829:	1FF1' F5      		PUSH	AF
6830:	1FF2' 2ADBFB  		LD	HL,(INFO)
6831:	1FF5' 7E      		LD	A,(HL)
6832:	1FF6' F610    		OR	10H
6833:	1FF8' 77      		LD	(HL),A
6834:	1FF9' F1      		POP	AF
6835:	1FFA' C48716  		CALL	NZ,DELETE10
6836:	1FFD'         	CHK$PWE3:
6837:				; Restore info
6838:	1FFD' E1      		POP	HL
6839:	1FFE' 22DBFB  		LD	(INFO),HL
6840:	2001' C9      		RET
6841:			
6842:	2002'         	CMP$PW:	; Compare passwords
6843:	2002' 23      		INC	HL
6844:	2003' 46      		LD	B,(HL)
6845:	2004' 78      		LD	A,B
6846:	2005' B7      		OR	A
6847:	2006' C21D20  		JP	NZ,CMP$PW2
6848:	2009' 54      		LD	D,H
6849:	200A' 5D      		LD	E,L
6850:	200B' 23      		INC	HL
6851:	200C' 23      		INC	HL
6852:	200D' 0E09    		LD	C,9
6853:	200F'         	CMP$PW1:
6854:	200F' 23      		INC	HL
6855:	2010' 7E      		LD	A,(HL)
6856:	2011' 0D      		DEC	C
6857:	2012' C8      		RET	Z
6858:	2013' B7      		OR	A
6859:	2014' CA0F20  		JP	Z,CMP$PW1
6860:	2017' FE20    		CP	20H
6861:	2019' CA0F20  		JP	Z,CMP$PW1
6862:	201C' EB      		EX	DE,HL
6863:	201D'         	CMP$PW2:
6864:	201D' 110A00  		LD	DE,[23-UBYTES]
6865:	2020' 19      		ADD	HL,DE
6866:	2021' EB      		EX	DE,HL
6867:	2022' 2A19FD  		LD	HL,(XDMAAD)
6868:	2025' 0E08    		LD	C,8
6869:	2027'         	CMP$PW3:
6870:	2027' 1A      		LD	A,(DE)
6871:	2028' A8      		XOR	B
6872:	2029' BE      		CP	(HL)
6873:	202A' C23420  		JP	NZ,CMP$PW4
6874:	202D' 1B      		DEC	DE
6875:	202E' 23      		INC	HL
6876:	202F' 0D      		DEC	C
6877:	2030' C22720  		JP	NZ,CMP$PW3
6878:	2033' C9      		RET
6879:	2034'         	CMP$PW4:
6880:	2034' 1B      		DEC	DE
6881:	2035' 0D      		DEC	C
6882:	2036' C23420  		JP	NZ,CMP$PW4
6883:	2039' 13      		INC	DE
6884:			
6885:	0000'         		IF MPM
6893:				ELSE
6894:	203A' 21E728  		LD	HL,DF$PASSWORD
6895:				ENDIF
6896:			
6897:	203D' 0E08    		LD	C,8
6898:	203F' C31F0E  		JP	COMPARE
6899:			
6900:	0000'         		IF MPM
6919:				ENDIF
6920:			
6921:	2042'         	SET$PW:	; Set password in xfcb
6922:	2042' E5      		PUSH	HL		; Save .xfcb(ex)
6923:	2043' 010800  		LD	BC,8		; b = 0, c = 8
6924:	2046' 110B00  		LD	DE,[23-EXTNUM]
6925:	2049' 19      		ADD	HL,DE
6926:	204A' EB      		EX	DE,HL
6927:	204B' 2A19FD  		LD	HL,(XDMAAD)
6928:	204E'         	SET$PW0:
6929:	204E' AF      		XOR	A
6930:	204F' F5      		PUSH	AF
6931:	2050'         	SET$PW1:
6932:	2050' 7E      		LD	A,(HL)
6933:	2051' 12      		LD	(DE),A
6934:	2052' B7      		OR	A
6935:	2053' CA5E20  		JP	Z,SET$PW2
6936:	2056' FE20    		CP	20H
6937:	2058' CA5E20  		JP	Z,SET$PW2
6938:	205B' 33      		INC	SP
6939:	205C' 33      		INC	SP
6940:	205D' F5      		PUSH	AF
6941:	205E'         	SET$PW2:
6942:	205E' 80      		ADD	A,B
6943:	205F' 47      		LD	B,A
6944:	2060' 1B      		DEC	DE
6945:	2061' 23      		INC	HL
6946:	2062' 0D      		DEC	C
6947:	2063' C25020  		JP	NZ,SET$PW1
6948:	2066' F1      		POP	AF
6949:	2067' B0      		OR	B
6950:	2068' E1      		POP	HL
6951:	2069' C27620  		JP	NZ,SET$PW3
6952:				; is fx = 100 (directory label)?
6953:	206C' 3ADFFB  		LD	A,(FX)
6954:	206F' FE64    		CP	100
6955:	2071' CA7620  		JP	Z,SET$PW3	; yes
6956:	2074' 3600    		LD	(HL),0		; zero xfcb(ex) - no password
6957:	2076'         	SET$PW3:
6958:	2076' 13      		INC	DE
6959:	2077' 0E08    		LD	C,8
6960:	2079'         	SET$PW4:
6961:	2079' 1A      		LD	A,(DE)
6962:	207A' A8      		XOR	B
6963:	207B' 12      		LD	(DE),A
6964:	207C' 13      		INC	DE
6965:	207D' 0D      		DEC	C
6966:	207E' C27920  		JP	NZ,SET$PW4
6967:	2081' 23      		INC	HL
6968:	2082' C9      		RET
6969:			
6970:	2083'         	GETXFCB:
6971:	2083' 2ADBFB  		LD	HL,(INFO)
6972:	2086' 7E      		LD	A,(HL)
6973:	2087' F5      		PUSH	AF
6974:	2088' F610    		OR	010H
6975:	208A' 77      		LD	(HL),A
6976:	208B' CDF514  		CALL	SEARCH$EXTNUM
6977:	208E' 3E00    		LD	A,0
6978:	2090' 329F0D  		LD	(LRET),A
6979:	2093' 2ADBFB  		LD	HL,(INFO)
6980:	2096' C1      		POP	BC
6981:	2097' 70      		LD	(HL),B
6982:	2098' C8      		RET	Z
6983:	2099'         	GETXFCB1:
6984:	2099' CD4011  		CALL	GETDPTRA
6985:	209C' EB      		EX	DE,HL
6986:	209D' 210C00  		LD	HL,EXTNUM
6987:	20A0' 19      		ADD	HL,DE
6988:	20A1' 7E      		LD	A,(HL)
6989:	20A2' E6E0    		AND	0E0H
6990:	20A4' F601    		OR	1
6991:	20A6' C9      		RET
6992:			
6993:	20A7'         	ADJUST$DMAAD:
6994:	20A7' E5      		PUSH	HL
6995:	20A8' 2A19FD  		LD	HL,(XDMAAD)
6996:	20AB' 19      		ADD	HL,DE
6997:	20AC' 2219FD  		LD	(XDMAAD),HL
6998:	20AF' E1      		POP	HL
6999:	20B0' C9      		RET
7000:			
7001:	20B1'         	INIT$XFCB:
7002:	20B1' CD7611  		CALL	SETCDR		; may have extended the directory
7003:	20B4' 011410  		LD	BC,1014H	; b=10h, c=20
7004:	20B7'         	INIT$XFCB0:
7005:				; b = fcb(0) logical or mask
7006:				; c = zero count
7007:	20B7' C5      		PUSH	BC
7008:	20B8' CD4011  		CALL	GETDPTRA
7009:	20BB' EB      		EX	DE,HL
7010:	20BC' 2ADBFB  		LD	HL,(INFO)
7011:	20BF' EB      		EX	DE,HL
7012:				; Zero extnum and modnum
7013:	20C0' 1A      		LD	A,(DE)
7014:	20C1' B0      		OR	B
7015:	20C2' 77      		LD	(HL),A
7016:	20C3' 13      		INC	DE
7017:	20C4' 23      		INC	HL
7018:	20C5' 0E0B    		LD	C,11
7019:	20C7' CD290E  		CALL	MOVE
7020:	20CA' C1      		POP	BC
7021:	20CB' 0C      		INC	C
7022:	20CC'         	INIT$XFCB1:
7023:	20CC' 0D      		DEC	C
7024:	20CD' C8      		RET	Z
7025:	20CE' 3600    		LD	(HL),0
7026:	20D0' 23      		INC	HL
7027:	20D1' C3CC20  		JP	INIT$XFCB1
7028:			
7029:	20D4'         	CHK$XFCB$PASSWORD:
7030:	20D4' CD9920  		CALL	GETXFCB1
7031:	20D7'         	CHK$XFCB$PASSWORD1:
7032:	20D7' E5      		PUSH	HL
7033:	20D8' CD0220  		CALL	CMP$PW
7034:	20DB' E1      		POP	HL
7035:	20DC' C9      		RET
7036:			
7037:				ENDIF
7038:			
7039:	20DD'         	STAMP1:
7040:	20DD' 0E00    		LD	C,0
7041:	20DF' C3E420  		JP	STAMP3
7042:	20E2'         	STAMP2:
7043:	20E2' 0E04    		LD	C,4
7044:	20E4'         	STAMP3:
7045:	20E4' CD1221  		CALL	GETDTBA
7046:	20E7' B7      		OR	A
7047:	20E8' C0      		RET	NZ
7048:	20E9' 119A12  		LD	DE,SEEK$COPY
7049:	20EC' D5      		PUSH	DE
7050:	20ED'         	STAMP4:
7051:			
7052:	0000'         		IF MPM
7057:				ELSE
7058:	20ED' 11F4FB  		LD	DE,STAMP
7059:				ENDIF
7060:			
7061:	20F0' E5      		PUSH	HL
7062:	20F1' D5      		PUSH	DE
7063:	20F2' 0E00    		LD	C,0
7064:	20F4' CD4EFF  		CALL	TIMEF		; does not modify hl,de
7065:	20F7' 0E04    		LD	C,4
7066:	20F9' CD1F0E  		CALL	COMPARE
7067:	20FC' 0E04    		LD	C,4
7068:	20FE' D1      		POP	DE
7069:	20FF' E1      		POP	HL
7070:	2100' C2290E  		JP	NZ,MOVE
7071:	2103' E1      		POP	HL
7072:	2104' C9      		RET
7073:			
7074:	2105'         	STAMP5:
7075:	2105' CD4011  		CALL	GETDPTRA
7076:	2108' 09      		ADD	HL,BC
7077:	2109' 11750A  		LD	DE,FUNC$RET
7078:	210C' D5      		PUSH	DE
7079:	210D' C3ED20  		JP	STAMP4
7080:			
7081:	FFFF'         		IF BANKED
7082:			
7083:	2110'         	GETDTBA$8:
7084:	2110' 0E08    		LD	C,8
7085:				ENDIF
7086:			
7087:	2112'         	GETDTBA:
7088:				; c = offset of sfcb subfield (0,4,8)
7089:				; Return with a = 0 if sfcb exists
7090:			
7091:				; Does fcb occupy 4th item of sector?
7092:	2112' 3AE1FB  		LD	A,(DCNT)
7093:	2115' E603    		AND	3
7094:	2117' FE03    		CP	3
7095:	2119' C8      		RET	Z		; yes
7096:	211A' 47      		LD	B,A
7097:	211B' 2A6728  		LD	HL,(BUFFA)
7098:	211E' 116000  		LD	DE,96
7099:	2121' 19      		ADD	HL,DE
7100:				; Does sfcb reside in 4th directory item?
7101:	2122' 7E      		LD	A,(HL)
7102:	2123' D621    		SUB	21H
7103:	2125' C0      		RET	NZ		; no
7104:				; hl = hl + 10*lret + 1 + c
7105:	2126' 78      		LD	A,B
7106:	2127' 87      		ADD	A,A
7107:	2128' 5F      		LD	E,A
7108:	2129' 87      		ADD	A,A
7109:	212A' 87      		ADD	A,A
7110:	212B' 83      		ADD	A,E
7111:	212C' 3C      		INC	A
7112:	212D' 81      		ADD	A,C
7113:	212E' 5F      		LD	E,A
7114:	212F' 19      		ADD	HL,DE
7115:	2130' AF      		XOR	A
7116:	2131' C9      		RET
7117:			
7118:	2132'         	QSTAMP:
7119:				; Is fcb 1st logical fcb for file?
7120:	2132' CD4021  		CALL	QDIRFCB1
7121:	2135' C0      		RET	NZ		; no
7122:	2136'         	QSTAMP1:
7123:				; Does directory label specify requested stamp?
7124:	2136' 2A6F28  		LD	HL,(DRVLBLA)
7125:	2139' 79      		LD	A,C
7126:	213A' A6      		AND	(HL)
7127:	213B' C21A11  		JP	NZ,NOWRITE	; yes - verify drive r/w
7128:	213E' 3C      		INC	A
7129:	213F' C9      		RET			; no - return with Z flag reset
7130:			
7131:	2140'         	QDIRFCB1:
7132:				; Routine to determine if fcb is 1st directory fcb
7133:				; for file
7134:				; Is fcb(ext) & ~extmsk & 00011111b = 0?
7135:	2140' 3A8428  		LD	A,(EXTMSK)
7136:	2143' F6E0    		OR	11100000B
7137:	2145' 2F      		CPL
7138:	2146' 47      		LD	B,A
7139:	2147' CD3F10  		CALL	GETEXTA
7140:	214A' 7E      		LD	A,(HL)
7141:	214B' A0      		AND	B
7142:	214C' C0      		RET	NZ		; no
7143:				; is fcb(mod) & 0011$1111B = 0?
7144:	214D' 23      		INC	HL
7145:	214E' 23      		INC	HL
7146:	214F' 7E      		LD	A,(HL)
7147:	2150' E63F    		AND	3FH
7148:	2152' C9      		RET			; Z flag set if zero
7149:			
7150:	2153'         	UPDATE$STAMP:
7151:				; Is update stamping requested on drive?
7152:	2153' 0E20    		LD	C,00100000B
7153:	2155' CD3621  		CALL	QSTAMP1
7154:	2158' C0      		RET	NZ		; no
7155:				; Has file been written to since it was opened?
7156:	2159' CD4B11  		CALL	GETMODNUM
7157:	215C' E640    		AND	40H
7158:	215E' C0      		RET	NZ		; yes - update stamp performed
7159:				; Search for 1st dir fcb
7160:	215F' CD3F10  		CALL	GETEXTA
7161:	2162' 46      		LD	B,(HL)
7162:	2163' 3600    		LD	(HL),0
7163:	2165' E5      		PUSH	HL
7164:	2166' 23      		INC	HL
7165:	2167' 23      		INC	HL
7166:	2168' 4E      		LD	C,(HL)
7167:	2169' 3600    		LD	(HL),0
7168:	216B' C5      		PUSH	BC
7169:				; Search from beginning of directory
7170:	216C' CDF014  		CALL	SEARCH$NAMLEN
7171:				; Perform update stamp if dir fcb 1 found
7172:	216F' C4E220  		CALL	NZ,STAMP2
7173:	2172' AF      		XOR	A
7174:	2173' 329F0D  		LD	(LRET),A
7175:				; Restore fcb extent and module fields
7176:	2176' C1      		POP	BC
7177:	2177' E1      		POP	HL
7178:	2178' 70      		LD	(HL),B
7179:	2179' 23      		INC	HL
7180:	217A' 23      		INC	HL
7181:	217B' 71      		LD	(HL),C
7182:	217C' C9      		RET
7183:			
7184:	0000'         		IF MPM
8106:				ENDIF
8107:			
8108:			;
8109:			;	individual function handlers
8110:			;
8111:			
8112:	217D'         	FUNC12:
8113:				; Return version number
8114:			
8115:	0000'         		IF MPM
8118:				ELSE
8119:	217D' 3AA1FB  		LD	A,(VERSION)
8120:	2180' C3720A  		JP	STA$RET		; lret = dvers (high = 00)
8121:				ENDIF
8122:			
8123:	2183'         	FUNC13:
8124:			
8125:	0000'         		IF MPM
8144:				ELSE
8145:	2183' 21FFFF  		LD	HL,0FFFFH
8146:	2186' CD5A24  		CALL	RESET$37X
8147:				ENDIF
8148:	2189' AF      		XOR	A
8149:	218A' 32DAFB  		LD	(OLDDSK),A	; Note that usrcode remains unchanged
8150:			
8151:	0000'         		IF MPM
8169:				ELSE
8170:	218D' 218000  		LD	HL,TBUFF
8171:	2190' 22D8FB  		LD	(DMAAD),HL	; dmaad = tbuff
8172:	2193' C3B612  		JP	SETDATA		; to data dma address
8173:				ENDIF
8174:			
8175:	2196'         	FUNC14:
8176:			
8177:	0000'         		IF MPM
8197:				ELSE
8198:	2196' CD671E  		CALL	TMPSELECT	; seldsk = reg e
8199:	2199' 3AA428  		LD	A,(SELDSK)
8200:	219C' 32DAFB  		LD	(OLDDSK),A
8201:	219F' C9      		RET
8202:				ENDIF
8203:			
8204:	21A0'         	FUNC15:
8205:				; Open file
8206:	21A0' CD5411  		CALL	CLRMODNUM	; Clear the module number
8207:			
8208:	0000'         		IF MPM
8228:				ELSE
8229:	21A3' CD901E  		CALL	RESELECTX
8230:				ENDIF
8231:			
8232:	21A6' CD2D17  		CALL	CHECK$WILD	; Check for wild chars in fcb
8233:			
8234:	0000'         		IF MPM
8253:				ENDIF
8254:			
8255:	21A9' 3AE0FB  		LD	A,(USRCODE)
8256:	21AC' B7      		OR	A
8257:	21AD' CAB921  		JP	Z,CALL$OPEN
8258:	21B0' 3EFE    		LD	A,0FEH
8259:	21B2' 3218FD  		LD	(XDCNT+1),A
8260:	21B5' 3C      		INC	A
8261:	21B6' 32BD28  		LD	(SEARCH$USER0),A
8262:			
8263:	0000'         		IF MPM
8265:				ENDIF
8266:			
8267:	21B9'         	CALL$OPEN:
8268:	21B9' CDDA17  		CALL	OPEN
8269:	21BC' CDE721  		CALL	OPENX		; returns if unsuccessful, a = 0
8270:	21BF' 21BD28  		LD	HL,SEARCH$USER0
8271:	21C2' BE      		CP	(HL)
8272:	21C3' C8      		RET	Z
8273:	21C4' 77      		LD	(HL),A
8274:	21C5' 3A18FD  		LD	A,(XDCNT+1)
8275:	21C8' FEFE    		CP	0FEH
8276:	21CA' C8      		RET	Z
8277:			;
8278:			;	file exists under user 0
8279:			;
8280:			
8281:	0000'         		IF MPM
8283:				ENDIF
8284:			
8285:	21CB' CD0A19  		CALL	SET$DCNT$DBLK
8286:			
8287:	0000'         		IF MPM
8289:				ELSE
8290:	21CE' 3E80    		LD	A,80H
8291:				ENDIF
8292:			
8293:	21D0' 32B528  		LD	(HIGH$EXT),A
8294:	21D3'         	OPEN$USER$ZERO:
8295:				; Set fcb user # to zero
8296:	21D3' 2ADBFB  		LD	HL,(INFO)
8297:	21D6' 3600    		LD	(HL),0
8298:	21D8' 0E0F    		LD	C,NAMLEN
8299:	21DA' CDDD14  		CALL	SEARCHI
8300:	21DD' CD0315  		CALL	SEARCHN
8301:	21E0' CDDD17  		CALL	OPEN1		; Attempt reopen under user zero
8302:	21E3' CDE721  		CALL	OPENX		; openx returns only if unsuccessful
8303:	21E6' C9      		RET
8304:	21E7'         	OPENX:
8305:	21E7' CDF812  		CALL	END$OF$DIR
8306:	21EA' C8      		RET	Z
8307:	21EB' CD4F10  		CALL	GETFCBA
8308:	21EE' 7E      		LD	A,(HL)
8309:	21EF' 3C      		INC	A
8310:	21F0' C2F721  		JP	NZ,OPENXA
8311:	21F3' 1B      		DEC	DE
8312:	21F4' 1B      		DEC	DE
8313:	21F5' 1A      		LD	A,(DE)
8314:	21F6' 77      		LD	(HL),A
8315:	21F7'         	OPENXA:
8316:				; open successful
8317:	21F7' E1      		POP	HL		; Discard return address
8318:				; Was file opened under user 0 after unsuccessful
8319:				; attempt to open under user n?
8320:			
8321:	0000'         		IF MPM
8347:				ELSE
8348:	21F8' 3AB528  		LD	A,(HIGH$EXT)
8349:	21FB' 17      		RLA
8350:	21FC' D21222  		JP	NC,OPENX0
8351:				ENDIF
8352:			
8353:				; Is file under user 0 a system file ?
8354:			
8355:	0000'         		IF MPM
8358:				ENDIF
8359:			
8360:	21FF' 2ADBFB  		LD	HL,(INFO)
8361:	2202' 110A00  		LD	DE,10
8362:	2205' 19      		ADD	HL,DE
8363:	2206' 7E      		LD	A,(HL)
8364:	2207' E680    		AND	80H
8365:	2209' C21222  		JP	NZ,OPENX0	; yes - open successful
8366:				; open fails
8367:	220C' 32B528  		LD	(HIGH$EXT),A
8368:	220F' C3C015  		JP	LRET$EQ$FF
8369:	2212'         	OPENX0:
8370:			
8371:	0000'         		IF MPM
8373:				ELSE
8374:	2212' CD4112  		CALL	SET$LSN
8375:				ENDIF
8376:			
8377:	FFFF'         		IF BANKED
8378:			
8379:				; Are passwords enabled on drive?
8380:	2215' CD731F  		CALL	GET$DIR$MODE
8381:	2218' E680    		AND	80H
8382:	221A' CA7622  		JP	Z,OPENX1A	; no
8383:				; Is this 1st dir fcb?
8384:	221D' CD4021  		CALL	QDIRFCB1
8385:	2220' C24E22  		JP	NZ,OPENX0A	; no
8386:				; Does sfcb exist?
8387:	2223' CD1021  		CALL	GETDTBA$8
8388:	2226' B7      		OR	A
8389:	2227' C24E22  		JP	NZ,OPENX0A	; no
8390:				; Is sfcb password mode read or write?
8391:	222A' 7E      		LD	A,(HL)
8392:	222B' E6C0    		AND	0C0H
8393:	222D' CA7622  		JP	Z,OPENX1A	; no
8394:				; Does xfcb exist?
8395:	2230' CD2416  		CALL	XDCNT$EQ$DCNT
8396:	2233' CD8320  		CALL	GETXFCB
8397:	2236' C25722  		JP	NZ,OPENX0B	; yes
8398:				; no - set sfcb password mode to zero
8399:	2239' CD2B16  		CALL	RESTORE$DIR$FCB
8400:	223C' C8      		RET	Z		; (error)
8401:				; Does sfcb still exist?
8402:	223D' CD1021  		CALL	GETDTBA$8
8403:	2240' B7      		OR	A
8404:	2241' C27622  		JP	NZ,OPENX1A	; no (error)
8405:				; sfcb password mode = 0
8406:	2244' 77      		LD	(HL),A
8407:				; update sfcb
8408:	2245' CD1A11  		CALL	NOWRITE
8409:	2248' CC9A12  		CALL	Z,SEEK$COPY
8410:	224B' C37622  		JP	OPENX1A
8411:	224E'         	OPENX0A:
8412:	224E' CD2416  		CALL	XDCNT$EQ$DCNT
8413:				; Does xfcb exist?
8414:	2251' CD8320  		CALL	GETXFCB
8415:	2254' CA7222  		JP	Z,OPENX1	; no
8416:	2257'         	OPENX0B:
8417:				; yes - check password
8418:	2257' CD0220  		CALL	CMP$PW
8419:	225A' CA7222  		JP	Z,OPENX1
8420:	225D' CD851F  		CALL	CHK$PW$ERROR
8421:	2260' 3AE428  		LD	A,(PW$MODE)
8422:	2263' E6C0    		AND	0C0H
8423:	2265' CA7222  		JP	Z,OPENX1
8424:	2268' E680    		AND	80H
8425:	226A' C2DF1F  		JP	NZ,PW$ERROR
8426:	226D' 3E80    		LD	A,080H
8427:	226F' 32B628  		LD	(XFCB$READ$ONLY),A
8428:	2272'         	OPENX1:
8429:	2272' CD2B16  		CALL	RESTORE$DIR$FCB
8430:	2275' C8      		RET	Z		; (error)
8431:	2276'         	OPENX1A:
8432:	2276' CD4112  		CALL	SET$LSN
8433:			
8434:	0000'         		IF MPM
8518:				ENDIF
8519:				ENDIF
8520:			
8521:	2279' 0E40    		LD	C,01000000B
8522:	227B'         	OPENX2:
8523:	227B' CD3221  		CALL	QSTAMP
8524:	227E' CCDD20  		CALL	Z,STAMP1
8525:	2281' 1190FB  		LD	DE,OLOG
8526:	2284' C30811  		JP	SET$CDISK
8527:			
8528:	2287'         	FUNC16:
8529:				; Close file
8530:	2287' CD9A1E  		CALL	RESELECT
8531:			
8532:	0000'         		IF MPM
8555:				ELSE
8556:	228A' CD4112  		CALL	SET$LSN
8557:	228D' CDD810  		CALL	CHEK$FCB
8558:	2290' CD3D18  		CALL	CLOSE
8559:				ENDIF
8560:			
8561:	2293' 3A9F0D  		LD	A,(LRET)
8562:	2296' 3C      		INC	A
8563:	2297' C8      		RET	Z
8564:			
8565:	2298' C31A25  		JP	FLUSH		; Flush buffers
8566:			
8567:	0000'         		IF MPM
8604:				ENDIF
8605:			
8606:	229B'         	FUNC17:
8607:				; Search for first occurrence of a file
8608:	229B' EB      		EX	DE,HL
8609:	229C' AF      		XOR	A
8610:	229D'         	CSEARCH:
8611:	229D' F5      		PUSH	AF
8612:	229E' 7E      		LD	A,(HL)
8613:	229F' FE3F    		CP	'?'
8614:	22A1' C2AF22  		JP	NZ,CSEARCH1	; no reselect if ?
8615:	22A4' CD6B1E  		CALL	CURSELECT
8616:	22A7' CDE91E  		CALL	NOSELECT0
8617:	22AA' 0E00    		LD	C,0
8618:	22AC' C3C322  		JP	CSEARCH3
8619:	22AF'         	CSEARCH1:
8620:	22AF' CD3F10  		CALL	GETEXTA
8621:	22B2' 7E      		LD	A,(HL)
8622:	22B3' FE3F    		CP	'?'
8623:	22B5' CABE22  		JP	Z,CSEARCH2
8624:	22B8' CD5A11  		CALL	CLR$EXT
8625:	22BB' CD5411  		CALL	CLRMODNUM
8626:	22BE'         	CSEARCH2:
8627:	22BE' CD901E  		CALL	RESELECTX
8628:	22C1' 0E0F    		LD	C,NAMLEN
8629:	22C3'         	CSEARCH3:
8630:	22C3' F1      		POP	AF
8631:	22C4' F5      		PUSH	AF
8632:	22C5' CADA22  		JP	Z,CSEARCH4
8633:				; dcnt = dcnt & 0fch
8634:	22C8' 2AE1FB  		LD	HL,(DCNT)
8635:	22CB' E5      		PUSH	HL
8636:	22CC' 3EFC    		LD	A,0FCH
8637:	22CE' A5      		AND	L
8638:	22CF' 6F      		LD	L,A
8639:	22D0' 22E1FB  		LD	(DCNT),HL
8640:	22D3' CD9212  		CALL	RDDIR
8641:	22D6' E1      		POP	HL
8642:	22D7' 22E1FB  		LD	(DCNT),HL
8643:	22DA'         	CSEARCH4:
8644:	22DA' F1      		POP	AF
8645:	22DB' 21C312  		LD	HL,DIR$TO$USER
8646:	22DE' E5      		PUSH	HL
8647:	22DF' CAF714  		JP	Z,SEARCH
8648:	22E2' 3AE5FB  		LD	A,(SEARCHL)
8649:	22E5' 4F      		LD	C,A
8650:	22E6' CDDD14  		CALL	SEARCHI
8651:	22E9' C30315  		JP	SEARCHN
8652:			
8653:	22EC'         	FUNC18:
8654:				; Search for next occurrence of a file name
8655:			
8656:	FFFF'         		IF BANKED
8657:	22EC' EB      		EX	DE,HL
8658:	22ED' 22A028  		LD	(SEARCHA),HL
8659:				ELSE
8662:				ENDIF
8663:			
8664:	22F0' F601    		OR	1
8665:	22F2' C39D22  		JP	CSEARCH
8666:			
8667:	22F5'         	FUNC19:
8668:				; Delete a file
8669:			;;;	call reselectx	;[JCE] DRI Patch 13
8670:	22F5' CD7D2D  		CALL	PATCH$1E38
8671:	22F8' C33616  		JP	DELETE
8672:			
8673:	22FB'         	FUNC20:
8674:				; Read a file
8675:	22FB' CD9A1E  		CALL	RESELECT
8676:	22FE' CDCE10  		CALL	CHECK$FCB
8677:	2301' C3F519  		JP	SEQDISKREAD
8678:			
8679:	2304'         	FUNC21:
8680:				; Write a file
8681:	2304' CD9A1E  		CALL	RESELECT
8682:	2307' CDCE10  		CALL	CHECK$FCB
8683:	230A' C3631B  		JP	SEQDISKWRITE
8684:			
8685:	230D'         	FUNC22:
8686:				; Make a file
8687:			
8688:	FFFF'         		IF BANKED
8689:	230D' CD1810  		CALL	GET$ATTS
8690:	2310' 32B328  		LD	(ATTRIBUTES),A
8691:				ENDIF
8692:			
8693:	2313' CD5A11  		CALL	CLR$EXT
8694:	2316' CD5411  		CALL	CLRMODNUM	; fcb mod = 0
8695:	2319' CD901E  		CALL	RESELECTX
8696:			
8697:	0000'         		IF MPM
8699:				ENDIF
8700:			
8701:	231C' CD2D17  		CALL	CHECK$WILD
8702:	231F' CD0319  		CALL	SET$XDCNT	; Reset xdcnt for make
8703:			
8704:	0000'         		IF MPM
8706:				ENDIF
8707:			
8708:	2322' CDDA17  		CALL	OPEN		; Verify file does not already exist
8709:			
8710:	0000'         		IF MPM
8712:				ENDIF
8713:			
8714:				; Does dir fcb for fcb exist?
8715:				; ora a required to reset carry
8716:	2325' CDF812  		CALL	END$OF$DIR
8717:	2328' B7      		OR	A
8718:	2329' CA3323  		JP	Z,MAKEA0	; no
8719:				; Is dir$ext < fcb(ext)?
8720:	232C' CD9714  		CALL	GET$DIR$EXT
8721:	232F' BE      		CP	(HL)
8722:	2330' D2E323  		JP	NC,FILE$EXISTS	; no
8723:	2333'         	MAKEA0:
8724:	2333' F5      		PUSH	AF		; carry set if dir fcb already exists
8725:			
8726:	0000'         		IF MPM
8762:				ENDIF
8763:			
8764:	FFFF'         		IF BANKED
8765:				; Is fcb 1st fcb for file?
8766:	2334' CD4021  		CALL	QDIRFCB1
8767:	2337' CA5923  		JP	Z,MAKEX04	; yes
8768:				; no - does dir lbl require passwords?
8769:	233A' CD731F  		CALL	GET$DIR$MODE
8770:	233D' E680    		AND	80H
8771:	233F' CA5923  		JP	Z,MAKEX04
8772:				; no - does xfcb exist with mode 1 or 2 password?
8773:	2342' CD8320  		CALL	GETXFCB
8774:	2345' CA5923  		JP	Z,MAKEX04
8775:				; yes - check password
8776:	2348' CDD720  		CALL	CHK$XFCB$PASSWORD1
8777:	234B' CA5923  		JP	Z,MAKEX04
8778:				; Verify password error
8779:	234E' CD851F  		CALL	CHK$PW$ERROR
8780:	2351' 3AE428  		LD	A,(PW$MODE)
8781:	2354' E6C0    		AND	0C0H
8782:	2356' C2DF1F  		JP	NZ,PW$ERROR
8783:	2359'         	MAKEX04:
8784:			
8785:				ENDIF
8786:			
8787:				; carry on stack indicates a make not required because
8788:				; of extent folding
8789:	2359' F1      		POP	AF
8790:	235A' D41619  		CALL	NC,MAKE
8791:			
8792:	0000'         		IF MPM
8794:				ENDIF
8795:			
8796:				; end$of$dir call either applies to above make or open call
8797:	235D' CDF812  		CALL	END$OF$DIR
8798:	2360' C8      		RET	Z		; Return if make unsuccessful
8799:			
8800:	FFFF'         		IF NOT MPM
8801:	2361' CD4112  		CALL	SET$LSN
8802:				ENDIF
8803:			
8804:	FFFF'         		IF BANKED
8805:			
8806:				; Are passwords activated by dir lbl?
8807:	2364' CD731F  		CALL	GET$DIR$MODE
8808:	2367' E680    		AND	80H
8809:	2369' CAD223  		JP	Z,MAKE3A
8810:				; Did user set password attribute?
8811:	236C' 3AB328  		LD	A,(ATTRIBUTES)
8812:	236F' E640    		AND	40H
8813:	2371' CAD223  		JP	Z,MAKE3A
8814:				; Is fcb file's 1st logical fcb?
8815:	2374' CD4021  		CALL	QDIRFCB1
8816:	2377' C2D223  		JP	NZ,MAKE3A
8817:				; yes - does xfcb already exist for file
8818:	237A' CD2416  		CALL	XDCNT$EQ$DCNT
8819:	237D' CD8320  		CALL	GETXFCB
8820:	2380' C29723  		JP	NZ,MAKE00	; yes
8821:				; Attempt to make xfcb
8822:	2383' 3EFF    		LD	A,0FFH
8823:	2385' 3215FD  		LD	(MAKE$XFCB),A
8824:	2388' CD1619  		CALL	MAKE
8825:	238B' C29723  		JP	NZ,MAKE00
8826:				; xfcb make failed - delete fcb that was created above
8827:	238E' CDF014  		CALL	SEARCH$NAMLEN
8828:	2391' CD8716  		CALL	DELETE10
8829:	2394' C3C015  		JP	LRET$EQ$FF	; Return with a = 0ffh
8830:			
8831:	2397'         	MAKE00:
8832:	2397' CDB120  		CALL	INIT$XFCB	; Initialize xfcb
8833:				; Get password mode from dma + 8
8834:	239A' EB      		EX	DE,HL
8835:	239B' 2A19FD  		LD	HL,(XDMAAD)
8836:	239E' 010800  		LD	BC,8
8837:	23A1' 09      		ADD	HL,BC
8838:	23A2' EB      		EX	DE,HL
8839:	23A3' 1A      		LD	A,(DE)
8840:	23A4' E6E0    		AND	0E0H
8841:	23A6' C2AB23  		JP	NZ,MAKE2
8842:	23A9' 3E80    		LD	A,080H		; default password mode is read protect
8843:	23AB'         	MAKE2:
8844:	23AB' 32E428  		LD	(PW$MODE),A
8845:				; Set xfcb password mode field
8846:	23AE' F5      		PUSH	AF
8847:	23AF' CD9920  		CALL	GETXFCB1
8848:	23B2' F1      		POP	AF
8849:	23B3' 77      		LD	(HL),A
8850:				; Set xfcb password and password checksum
8851:				; Fix hash table and write xfcb
8852:	23B4' CD4220  		CALL	SET$PW
8853:	23B7' 70      		LD	(HL),B
8854:	23B8' CD1927  		CALL	SDL3
8855:				; Return to fcb
8856:	23BB' CD2B16  		CALL	RESTORE$DIR$FCB
8857:	23BE' C8      		RET	Z
8858:				; Does sfcb exist?
8859:	23BF' 0E08    		LD	C,8
8860:	23C1' CD1221  		CALL	GETDTBA
8861:	23C4' B7      		OR	A
8862:	23C5' C2D223  		JP	NZ,MAKE3A	; no
8863:				; Place password mode in sfcb if sfcb exists
8864:	23C8' 3AE428  		LD	A,(PW$MODE)
8865:	23CB' 77      		LD	(HL),A
8866:	23CC' CD9A12  		CALL	SEEK$COPY
8867:	23CF' CD4112  		CALL	SET$LSN
8868:				ENDIF
8869:			
8870:	23D2'         	MAKE3A:
8871:	23D2' 0E50    		LD	C,01010000B
8872:			
8873:	0000'         		IF MPM
8890:				ELSE
8891:	23D4' CD7B22  		CALL	OPENX2
8892:	23D7' 0E20    		LD	C,00100000B
8893:	23D9' CD3221  		CALL	QSTAMP
8894:	23DC' C0      		RET	NZ
8895:	23DD' CDE220  		CALL	STAMP2
8896:	23E0' C3571B  		JP	SET$FILEWF
8897:				ENDIF
8898:			
8899:	23E3'         	FILE$EXISTS:
8900:	23E3' 3E08    		LD	A,8
8901:	23E5'         	SET$ARET:
8902:	23E5' 4F      		LD	C,A
8903:	23E6' 32A00D  		LD	(ARET+1),A
8904:	23E9' CDC015  		CALL	LRET$EQ$FF
8905:			
8906:	0000'         		IF MPM
8909:				ELSE
8910:	23EC' C3B80D  		JP	GOERR1
8911:				ENDIF
8912:			
8913:	0000'         		IF MPM
8926:				ENDIF
8927:			
8928:	23EF'         	FUNC23:
8929:				; Rename a file
8930:			;;;	call reselectx	;[JCE] DRI Patch 13
8931:	23EF' CD7D2D  		CALL	PATCH$1E38
8932:	23F2' C35217  		JP	RENAME
8933:			
8934:	23F5'         	FUNC24:
8935:				; Return the login vector
8936:	23F5' 2A6528  		LD	HL,(DLOG)
8937:	23F8' C32924  		JP	STHL$RET
8938:			
8939:	23FB'         	FUNC25:
8940:				; Return selected disk number
8941:	23FB' 3AA428  		LD	A,(SELDSK)
8942:	23FE' C3720A  		JP	STA$RET
8943:			
8944:	2401'         	FUNC26:
8945:			
8946:	0000'         		IF MPM
8957:				ENDIF
8958:			
8959:				; Set the subsequent dma address to info
8960:	2401' EB      		EX	DE,HL
8961:	2402' 22D8FB  		LD	(DMAAD),HL	; dmaad = info
8962:	2405' C3B612  		JP	SETDATA		; to data dma address
8963:			
8964:	2408'         	FUNC27:
8965:				; Return the login vector address
8966:	2408' CD6B1E  		CALL	CURSELECT
8967:	240B' 2A7728  		LD	HL,(ALLOCA)
8968:	240E' C32924  		JP	STHL$RET
8969:			
8970:	0000'         		IF MPM
8983:				ELSE
8984:			
8985:	11D3'         	FUNC28  EQU	SET$RO ; Write protect current disk
8986:			
8987:				ENDIF
8988:			
8989:	2411'         	FUNC29:
8990:				; Return r/o bit vector
8991:	2411' 2A6328  		LD	HL,(RODSK)
8992:	2414' C32924  		JP	STHL$RET
8993:			
8994:	2417'         	FUNC30:
8995:				; Set file indicators
8996:	2417' CD2D17  		CALL	CHECK$WILD
8997:			;;;	call reselectx	;[JCE] DRI Patch 13
8998:	241A' CD7D2D  		CALL	PATCH$1E38
8999:	241D' CDA417  		CALL	INDICATORS
9000:	2420' C38014  		JP	COPY$DIRLOC	; lret=dirloc
9001:			
9002:	2423'         	FUNC31:
9003:				; Return address of disk parameter block
9004:	2423' CD6B1E  		CALL	CURSELECT
9005:	2426' 2A7328  		LD	HL,(DPBADDR)
9006:	2429'         	STHL$RET:
9007:	2429' 229F0D  		LD	(ARET),HL
9008:	242C' C9      		RET
9009:			
9010:	242D'         	FUNC32:
9011:				; Set user code
9012:	242D' 3A9E28  		LD	A,(LINFO)
9013:	2430' FEFF    		CP	0FFH
9014:	2432' C23B24  		JP	NZ,SETUSRCODE
9015:				; Interrogate user code instead
9016:	2435' 3AE0FB  		LD	A,(USRCODE)
9017:	2438' C3720A  		JP	STA$RET		; lret=usrcode
9018:	243B'         	SETUSRCODE:
9019:	243B' E60F    		AND	0FH
9020:	243D' 32E0FB  		LD	(USRCODE),A
9021:			
9022:	0000'         		IF MPM
9032:				ENDIF
9033:			
9034:	2440' C9      		RET
9035:			
9036:	2441'         	FUNC33:
9037:				; Random disk read operation
9038:	2441' CD9A1E  		CALL	RESELECT
9039:	2444' CDCE10  		CALL	CHECK$FCB
9040:	2447' C3B91D  		JP	RANDISKREAD	; to perform the disk read
9041:			
9042:	244A'         	FUNC34:
9043:				; Random disk write operation
9044:	244A' CD9A1E  		CALL	RESELECT
9045:	244D' CDCE10  		CALL	CHECK$FCB
9046:	2450' C3C21D  		JP	RANDISKWRITE	; to perform the disk write
9047:			
9048:	2453'         	FUNC35:
9049:				; Return file size (0-262,144)
9050:	2453' CD9A1E  		CALL	RESELECT
9051:	2456' C3131E  		JP	GETFILESIZE
9052:			
9053:	1E40'         	FUNC36	EQU	SETRANDOM; Set random record
9054:			
9055:	2459'         	FUNC37:
9056:				; Drive reset
9057:			
9058:	0000'         		IF MPM
9062:				ELSE
9063:	2459' EB      		EX	DE,HL
9064:				ENDIF
9065:			
9066:	245A'         	RESET$37X:
9067:	245A' 7D      		LD	A,L
9068:	245B' 2F      		CPL
9069:	245C' 5F      		LD	E,A
9070:	245D' 7C      		LD	A,H
9071:	245E' 2F      		CPL
9072:	245F' 2A6528  		LD	HL,(DLOG)
9073:	2462' A4      		AND	H
9074:	2463' 57      		LD	D,A
9075:	2464' 7D      		LD	A,L
9076:	2465' A3      		AND	E
9077:	2466' 5F      		LD	E,A
9078:	2467' 2A6328  		LD	HL,(RODSK)
9079:	246A' EB      		EX	DE,HL
9080:	246B' 226528  		LD	(DLOG),HL
9081:			
9082:	0000'         		IF MPM
9085:				ELSE
9086:	246E' 7D      		LD	A,L
9087:	246F' A3      		AND	E
9088:	2470' 6F      		LD	L,A
9089:	2471' 7C      		LD	A,H
9090:	2472' A2      		AND	D
9091:	2473' 67      		LD	H,A
9092:				ENDIF
9093:			
9094:	2474' 226328  		LD	(RODSK),HL
9095:			
9096:	0000'         		IF MPM
9102:				ENDIF
9103:			
9104:				; Force select call in next curselect
9105:	2477' 3EFF    		LD	A,0FFH
9106:	2479' 32A928  		LD	(CURDSK),A
9107:	247C' C9      		RET
9108:			
9109:	0000'         		IF MPM
9215:				ELSE
9216:			
9217:	0A75'         	FUNC38	EQU	FUNC$RET
9218:	0A75'         	FUNC39	EQU	FUNC$RET
9219:			
9220:				ENDIF
9221:			
9222:	244A'         	FUNC40	EQU	FUNC34	; Write random with zero fill
9223:			
9224:	0000'         		IF MPM
9236:				ELSE
9237:			
9238:	0A75'         	FUNC42	EQU	FUNC$RET; Record lock
9239:	0A75'         	FUNC43	EQU	FUNC$RET	; Record unlock
9240:			
9241:				ENDIF
9242:			
9243:	247D'         	FUNC44:	; Set multi-sector count
9244:	247D' 7B      		LD	A,E
9245:	247E' B7      		OR	A
9246:	247F' CAC015  		JP	Z,LRET$EQ$FF
9247:	2482' FE81    		CP	129
9248:	2484' D2C015  		JP	NC,LRET$EQ$FF
9249:	2487' 32E6FB  		LD	(MULTCNT),A
9250:			
9251:	0000'         		IF MPM
9257:				ENDIF
9258:			
9259:	248A' C9      		RET
9260:			
9261:	248B'         	FUNC45:	; Set bdos error mode
9262:			
9263:	0000'         		IF MPM
9281:				ELSE
9282:	248B' 7B      		LD	A,E
9283:	248C' 32E7FB  		LD	(ERRORMODE),A
9284:				ENDIF
9285:			
9286:	248F' C9      		RET
9287:			
9288:	2490'         	FUNC46:
9289:				; Get free space
9290:				; Perform temporary select of specified drive
9291:	2490' CD671E  		CALL	TMPSELECT
9292:	2493' 2A7728  		LD	HL,(ALLOCA)
9293:	2496' EB      		EX	DE,HL		; de = alloc vector addr
9294:	2497' CDDE13  		CALL	GET$NALBS	; Get # alloc blocks
9295:				; hl = # of allocation vector bytes
9296:				; Count # of true bits in allocation vector
9297:	249A' 010000  		LD	BC,0		; bc = true bit accumulator
9298:	249D' 1A      	GSP1:	LD	A,(DE)
9299:	249E' B7      	GSP2:	OR	A
9300:	249F' CAAA24  		JP	Z,GSP4
9301:	24A2' 1F      	GSP3:	RRA
9302:	24A3' D2A224  		JP	NC,GSP3
9303:	24A6' 03      		INC	BC
9304:	24A7' C39E24  		JP	GSP2
9305:	24AA' 13      	GSP4:	INC	DE
9306:	24AB' 2B      		DEC	HL
9307:	24AC' 7D      		LD	A,L
9308:	24AD' B4      		OR	H
9309:	24AE' C29D24  		JP	NZ,GSP1
9310:				; hl = 0 when allocation vector processed
9311:				; Compute maxall + 1 - bc
9312:	24B1' 2A8528  		LD	HL,(MAXALL)
9313:	24B4' 23      		INC	HL
9314:	24B5' 7D      		LD	A,L
9315:	24B6' 91      		SUB	C
9316:	24B7' 6F      		LD	L,A
9317:	24B8' 7C      		LD	A,H
9318:	24B9' 98      		SBC	A,B
9319:	24BA' 67      		LD	H,A
9320:				; hl = # of available blocks on drive
9321:	24BB' 3A8228  		LD	A,(BLKSHF)
9322:	24BE' 4F      		LD	C,A
9323:	24BF' AF      		XOR	A
9324:	24C0' CDF60D  		CALL	SHL3BV
9325:				; ahl = # of available sectors on drive
9326:				; Store ahl in beginning of current dma
9327:	24C3' EB      		EX	DE,HL
9328:	24C4' 2A19FD  		LD	HL,(XDMAAD)
9329:	24C7' 73      		LD	(HL),E
9330:	24C8' 23      		INC	HL
9331:	24C9' 72      		LD	(HL),D
9332:	24CA' 23      		INC	HL
9333:	24CB' 77      		LD	(HL),A
9334:	24CC' C9      		RET
9335:			
9336:	0000'         		IF MPM
9340:				ELSE
9341:			
9342:	24CD'         	FUNC47:	; Chain to program
9343:	24CD' 21B3FB  		LD	HL,CCP$FLGS
9344:	24D0' 7E      		LD	A,(HL)
9345:	24D1' F680    		OR	80H
9346:	24D3' 77      		LD	(HL),A
9347:	24D4' 1C      		INC	E
9348:	24D5' C22F03  		JP	NZ,REBOOTX1
9349:	24D8' 7E      		LD	A,(HL)
9350:	24D9' F640    		OR	40H
9351:	24DB' 77      		LD	(HL),A
9352:	24DC' C32F03  		JP	REBOOTX1
9353:				ENDIF
9354:			
9355:	24DF'         	FUNC48:	; Flush buffers
9356:	24DF' CD2F1F  		CALL	CHECK$ALL$MEDIA
9357:	24E2' CD48FF  		CALL	FLUSHF
9358:	24E5' CDA50E  		CALL	DIOCOMP
9359:	24E8'         	FLUSH0:	; Function 98 entry point
9360:	24E8' 2A6528  		LD	HL,(DLOG)
9361:	24EB' 3E10    		LD	A,16
9362:	24ED'         	FLUSH1:
9363:	24ED' 3D      		DEC	A
9364:	24EE' 29      		ADD	HL,HL
9365:	24EF' D21525  		JP	NC,FLUSH5
9366:	24F2' F5      		PUSH	AF
9367:	24F3' E5      		PUSH	HL
9368:	24F4' 5F      		LD	E,A
9369:	24F5' CD671E  		CALL	TMPSELECT	; seldsk = e
9370:	24F8' 3ADFFB  		LD	A,(FX)
9371:	24FB' FE30    		CP	48
9372:	24FD' CA0625  		JP	Z,FLUSH3
9373:				; Function 98 - reset allocation
9374:				; Copy 2nd ALV over 1st ALV
9375:	2500' CD7713  		CALL	COPY$ALV
9376:	FFFF'         		IF BANKED
9377:	2503' C33A2D  		JP	PATCH$2D3A	;[JCE] DRI Patch 13
9378:				ELSE
9380:				ENDIF
9381:			
9382:	2506'         	FLUSH3:
9383:	2506' CD2025  		CALL	FLUSHX
9384:				; if e = 0ffh then discard buffers after possible flush
9385:	2509' 3A9E28  		LD	A,(LINFO)
9386:	250C' 3C      		INC	A
9387:	250D' C21325  		JP	NZ,FLUSH4
9388:	2510'         	FLUSH35:
9389:	2510' CD5212  		CALL	DISCARD$DATA
9390:	2513'         	FLUSH4:
9391:	2513' E1      		POP	HL
9392:	2514' F1      		POP	AF
9393:	2515'         	FLUSH5:
9394:	2515' B7      		OR	A
9395:	2516' C2ED24  		JP	NZ,FLUSH1
9396:	2519' C9      		RET
9397:			
9398:	251A'         	FLUSH:
9399:	251A' CD48FF  		CALL	FLUSHF
9400:	251D' CDA50E  		CALL	DIOCOMP
9401:	2520'         	FLUSHX:
9402:	2520' 3A9028  		LD	A,(PHYMSK)
9403:	2523' B7      		OR	A
9404:	2524' C8      		RET	Z
9405:	2525' 3E04    		LD	A,4
9406:	2527' C3FF28  		JP	DEBLOCK$DTA
9407:			
9408:	0000'         		IF MPM
9412:				ELSE
9413:			
9414:	252A'         	FUNC49:	; Get/Set system control block
9415:			
9416:	252A' EB      		EX	DE,HL
9417:	252B' 7E      		LD	A,(HL)
9418:	252C' FE63    		CP	99
9419:	252E' D0      		RET	NC
9420:	252F' EB      		EX	DE,HL
9421:	2530' 219CFB  		LD	HL,SCB
9422:	2533' 85      		ADD	A,L
9423:	2534' 6F      		LD	L,A
9424:	2535' EB      		EX	DE,HL
9425:	2536' 23      		INC	HL
9426:	2537' 7E      		LD	A,(HL)
9427:	2538' FEFE    		CP	0FEH
9428:	253A' D24525  		JP	NC,FUNC49$SET
9429:	253D' EB      		EX	DE,HL
9430:	253E' 5E      		LD	E,(HL)
9431:	253F' 23      		INC	HL
9432:	2540' 56      		LD	D,(HL)
9433:	2541' EB      		EX	DE,HL
9434:	2542' C32924  		JP	STHL$RET
9435:	2545'         	FUNC49$SET:
9436:	2545' 47      		LD	B,A
9437:	2546' 23      		INC	HL
9438:	2547' 7E      		LD	A,(HL)
9439:	2548' 12      		LD	(DE),A
9440:	2549' 04      		INC	B
9441:	254A' C8      		RET	Z
9442:	254B' 23      		INC	HL
9443:	254C' 13      		INC	DE
9444:	254D' 7E      		LD	A,(HL)
9445:	254E' 12      		LD	(DE),A
9446:	254F' C9      		RET
9447:				ENDIF
9448:			
9449:	0000'         		IF MPM
9453:				ELSE
9454:			
9455:	2550'         	FUNC50:	; Direct bios call
9456:				; de -> function (1 byte)
9457:				;	a  value (1 byte)
9458:				;	bc value (2 bytes)
9459:				;	de value (2 bytes)
9460:				;	hl value (2 bytes)
9461:			
9462:	2550' 21B025  		LD	HL,FUNC50$RET
9463:	2553' E5      		PUSH	HL
9464:	2554' EB      		EX	DE,HL
9465:			
9466:	FFFF'         		IF BANKED
9467:	2555' 7E      		LD	A,(HL)
9468:	2556' FE1B    		CP	27
9469:	2558' C8      		RET	Z
9470:	2559' FE0C    		CP	12
9471:	255B' C26225  		JP	NZ,DIRBIOS1
9472:	255E' 118B25  		LD	DE,DIRBIOS3
9473:	2561' D5      		PUSH	DE
9474:	2562'         	DIRBIOS1:
9475:	2562' FE09    		CP	9
9476:	2564' C26B25  		JP	NZ,DIRBIOS2
9477:	2567' 119025  		LD	DE,DIRBIOS4
9478:	256A' D5      		PUSH	DE
9479:	256B'         	DIRBIOS2:
9480:			
9481:				ENDIF
9482:			
9483:	256B' E5      		PUSH	HL
9484:	256C' 23      		INC	HL
9485:	256D' 23      		INC	HL
9486:	256E' 4E      		LD	C,(HL)
9487:	256F' 23      		INC	HL
9488:	2570' 46      		LD	B,(HL)
9489:	2571' 23      		INC	HL
9490:	2572' 5E      		LD	E,(HL)
9491:	2573' 23      		INC	HL
9492:	2574' 56      		LD	D,(HL)
9493:	2575' 23      		INC	HL
9494:	2576' 7E      		LD	A,(HL)
9495:	2577' 23      		INC	HL
9496:	2578' 66      		LD	H,(HL)
9497:	2579' 6F      		LD	L,A
9498:	257A' E3      		EX	(SP),HL
9499:	257B' 7E      		LD	A,(HL)
9500:	257C' E5      		PUSH	HL
9501:	257D' 6F      		LD	L,A
9502:	257E' 87      		ADD	A,A
9503:	257F' 85      		ADD	A,L
9504:			
9505:	2580' 2100FF  		LD	HL,BIOS
9506:			
9507:	2583' 85      		ADD	A,L
9508:	2584' 6F      		LD	L,A
9509:	2585' E3      		EX	(SP),HL
9510:	2586' 23      		INC	HL
9511:	2587' 7E      		LD	A,(HL)
9512:	2588' E1      		POP	HL
9513:	2589' E3      		EX	(SP),HL
9514:	258A' C9      		RET
9515:			
9516:	FFFF'         		IF BANKED
9517:			
9518:	258B'         	DIRBIOS3:
9519:	258B' 3E01    		LD	A,1
9520:	258D' C354FF  		JP	SETBNKF
9521:			
9522:	2590'         	DIRBIOS4:
9523:	2590' 7D      		LD	A,L
9524:	2591' B4      		OR	H
9525:	2592' C8      		RET	Z
9526:	2593' EB      		EX	DE,HL
9527:	2594' 210A00  		LD	HL,10
9528:	2597' 19      		ADD	HL,DE
9529:	2598' 3600    		LD	(HL),0		; Zero login sequence #
9530:	259A' 2AF9FB  		LD	HL,(COMMONBASE)
9531:	259D' CD7F11  		CALL	SUBDH
9532:	25A0' EB      		EX	DE,HL
9533:	25A1' D0      		RET	NC
9534:				; Copy DPH to common memory
9535:	25A2' EB      		EX	DE,HL
9536:	25A3' 2ADBFB  		LD	HL,(INFO)
9537:	25A6' 23      		INC	HL
9538:	25A7' E5      		PUSH	HL
9539:	25A8' 011900  		LD	BC,25
9540:	25AB' CD4BFF  		CALL	MOVEF
9541:	25AE' E1      		POP	HL
9542:	25AF' C9      		RET
9543:				ENDIF
9544:			
9545:	25B0'         	FUNC50$RET:
9546:			
9547:	FFFF'         		IF BANKED
9548:	25B0' 229F0D  		LD	(ARET),HL
9549:	25B3' 47      		LD	B,A
9550:	25B4' 2ADBFB  		LD	HL,(INFO)
9551:	25B7' 7E      		LD	A,(HL)
9552:	25B8' FE09    		CP	9
9553:	25BA' C8      		RET	Z
9554:	25BB' FE10    		CP	16
9555:	25BD' C8      		RET	Z
9556:	25BE' FE14    		CP	20
9557:	25C0' C8      		RET	Z
9558:	25C1' FE16    		CP	22
9559:	25C3' C8      		RET	Z
9560:	25C4' 78      		LD	A,B
9561:	25C5' C3720A  		JP	STA$RET
9562:				ELSE
9568:				ENDIF
9569:				ENDIF
9570:			
9571:	24E8'         	FUNC98	EQU	FLUSH0	; Reset Allocation
9572:			
9573:	25C8'         	FUNC99:	; Truncate file
9574:	25C8' CD901E  		CALL	RESELECTX
9575:	25CB' CD2D17  		CALL	CHECK$WILD
9576:			
9577:	FFFF'         		IF BANKED
9578:	25CE' CD781F  		CALL	CHK$PASSWORD
9579:	25D1' C4851F  		CALL	NZ,CHK$PW$ERROR
9580:				ENDIF
9581:			
9582:	25D4' 0EFF    		LD	C,TRUE
9583:	25D6' CDE41C  		CALL	RSEEK
9584:	25D9' C2C015  		JP	NZ,LRET$EQ$FF
9585:				; compute dir$fcb size
9586:	25DC' CD4011  		CALL	GETDPTRA
9587:	25DF' 110F00  		LD	DE,RECCNT
9588:	25E2' CDCB1D  		CALL	COMPUTE$RR	; cba = fcb size
9589:				; Is random rec # >= dir$fcb size
9590:	25E5' CD3710  		CALL	GET$RRA
9591:	25E8' CDFE1D  		CALL	COMPARE$RR
9592:	25EB' DAC015  		JP	C,LRET$EQ$FF	; yes ( > )
9593:	25EE' B2      		OR	D
9594:	25EF' CAC015  		JP	Z,LRET$EQ$FF	; yes ( = )
9595:				; Perform truncate
9596:	25F2' CD2811  		CALL	CHECK$RODIR	; may be r/o file
9597:	25F5' CD9A12  		CALL	WRDIR		; verify BIOS can write to disk
9598:	25F8' CD5321  		CALL	UPDATE$STAMP	; Set update stamp
9599:	25FB' CDF514  		CALL	SEARCH$EXTNUM
9600:	25FE'         	TRUNC1:
9601:	25FE' CA8014  		JP	Z,COPY$DIRLOC
9602:				; is dirfcb < fcb?
9603:	2601' CD7126  		CALL	COMPARE$MOD$EXT
9604:	2604' DA1C26  		JP	C,TRUNC2	; yes
9605:				; remove dirfcb blocks from allocation vector
9606:	2607' F5      		PUSH	AF
9607:	2608' 0E00    		LD	C,0
9608:	260A' CD8B13  		CALL	SCANDM$AB
9609:	260D' F1      		POP	AF
9610:				; is dirfcb = fcb?
9611:	260E' CA2226  		JP	Z,TRUNC3	; yes
9612:				; delete dirfcb
9613:	2611' CD4011  		CALL	GETDPTRA
9614:	2614' 36E5    		LD	(HL),EMPTY
9615:	2616' CDC82C  		CALL	FIX$HASH
9616:	2619'         	TRUNC15:
9617:	2619' CD9A12  		CALL	WRDIR
9618:	261C'         	TRUNC2:
9619:	261C' CD0315  		CALL	SEARCHN
9620:	261F' C3FE25  		JP	TRUNC1
9621:	2622'         	TRUNC3:
9622:	2622' CD5810  		CALL	GETFCB
9623:	2625' CDA40F  		CALL	DM$POSITION
9624:	2628' CD8B26  		CALL	ZERO$DM
9625:				; fcb(extnum) = dir$ext after blocks removed
9626:	262B' CD9714  		CALL	GET$DIR$EXT
9627:	262E' BE      		CP	(HL)
9628:	262F' 77      		LD	(HL),A
9629:	2630' F5      		PUSH	AF
9630:				; fcb(rc) = fcb(cr) + 1
9631:	2631' CD4F10  		CALL	GETFCBA
9632:	2634' 7E      		LD	A,(HL)
9633:	2635' 3C      		INC	A
9634:	2636' 12      		LD	(DE),A
9635:				; rc = 0 or 128 if dir$ext < fcb(extnum)
9636:	2637' F1      		POP	AF
9637:	2638' EB      		EX	DE,HL
9638:	2639' C41518  		CALL	NZ,SET$RC3
9639:				; rc = 0 if no blocks remain in fcb
9640:	263C' 3A9F28  		LD	A,(DMINX)
9641:	263F' B7      		OR	A
9642:	2640' CC1518  		CALL	Z,SET$RC3
9643:	2643' 010B00  		LD	BC,11
9644:	2646' CD6726  		CALL	GET$FCB$ADDS
9645:	2649' EB      		EX	DE,HL
9646:				; reset archive (t3') attribute bit
9647:	264A' 7E      		LD	A,(HL)
9648:	264B' E67F    		AND	7FH
9649:	264D' 77      		LD	(HL),A
9650:	264E' 23      		INC	HL
9651:	264F' 13      		INC	DE
9652:				; dirfcb(extnum) = fcb(extnum)
9653:	2650' 1A      		LD	A,(DE)
9654:	2651' 77      		LD	(HL),A
9655:				; advance to .fcb(reccnt) & .dirfcb(reccnt)
9656:	2652' 23      		INC	HL
9657:	2653' 3600    		LD	(HL),0
9658:	2655' 23      		INC	HL
9659:	2656' 23      		INC	HL
9660:	2657' 13      		INC	DE
9661:	2658' 13      		INC	DE
9662:	2659' 13      		INC	DE
9663:				; dirfcb_rc+dskmap = fcb_rc+dskmap
9664:	265A' 0E11    		LD	C,17
9665:	265C' CD290E  		CALL	MOVE
9666:				; restore non-erased blkidxs in allocation vector
9667:	265F' 0E01    		LD	C,1
9668:	2661' CD8B13  		CALL	SCANDM$AB
9669:	2664' C31926  		JP	TRUNC15
9670:			
9671:	2667'         	GET$FCB$ADDS:
9672:	2667' CD4011  		CALL	GETDPTRA
9673:	266A' 09      		ADD	HL,BC
9674:	266B' EB      		EX	DE,HL
9675:	266C' 2ADBFB  		LD	HL,(INFO)
9676:	266F' 09      		ADD	HL,BC
9677:	2670' C9      		RET
9678:			
9679:	2671'         	COMPARE$MOD$EXT:
9680:	2671' 010E00  		LD	BC,MODNUM
9681:	2674' CD6726  		CALL	GET$FCB$ADDS
9682:	2677' 7E      		LD	A,(HL)
9683:	2678' E63F    		AND	3FH
9684:	267A' 47      		LD	B,A
9685:				; compare dirfcb(modnum) to fcb(modnum)
9686:	267B' 1A      		LD	A,(DE)
9687:	267C' B8      		CP	B
9688:	267D' C0      		RET	NZ		; dirfcb(modnum) ~= fcb(modnum)
9689:	267E' 2B      		DEC	HL
9690:	267F' 2B      		DEC	HL
9691:	2680' 1B      		DEC	DE
9692:	2681' 1B      		DEC	DE
9693:				; compare dirfcb(extnum) to fcb(extnum)
9694:	2682' 1A      		LD	A,(DE)
9695:	2683' 4E      		LD	C,(HL)
9696:	2684' CD8614  		CALL	COMPEXT
9697:	2687' C8      		RET	Z		; dirfcb(extnum) = fcb(extnum)
9698:	2688' 1A      		LD	A,(DE)
9699:	2689' BE      		CP	(HL)
9700:	268A' C9      		RET
9701:			
9702:	268B'         	ZERO$DM:
9703:	268B' 3C      		INC	A
9704:	268C' 21A328  		LD	HL,SINGLE
9705:	268F' 34      		INC	(HL)
9706:	2690' CA9426  		JP	Z,ZERO$DM1
9707:	2693' 87      		ADD	A,A
9708:	2694'         	ZERO$DM1:
9709:	2694' 35      		DEC	(HL)
9710:	2695' CDC40F  		CALL	GETDMA
9711:	2698' 4F      		LD	C,A
9712:	2699' 0600    		LD	B,0
9713:	269B' 09      		ADD	HL,BC
9714:	269C' 3E10    		LD	A,16
9715:	269E'         	ZERO$DM2:
9716:	269E' B9      		CP	C
9717:	269F' C8      		RET	Z
9718:	26A0' 70      		LD	(HL),B
9719:	26A1' 23      		INC	HL
9720:	26A2' 0C      		INC	C
9721:	26A3' C39E26  		JP	ZERO$DM2
9722:			
9723:	FFFF'         		IF BANKED
9724:			
9725:	26A6'         	FUNC100:; Set directory label
9726:				; de -> .fcb
9727:				;	drive location
9728:				;	name & type fields user's discretion
9729:				;	extent field definition
9730:				;	bit 1 (80h): enable passwords on drive
9731:				;	bit 2 (40h): enable file access
9732:				;	bit 3 (20h): enable file update stamping
9733:				;	bit 4 (10h): enable file create stamping
9734:				;	bit 8 (01h): assign new password to dir lbl
9735:	26A6' CD901E  		CALL	RESELECTX
9736:	26A9' 2ADBFB  		LD	HL,(INFO)
9737:	26AC' 3621    		LD	(HL),21H
9738:	26AE' 0E01    		LD	C,1
9739:	26B0' CDF714  		CALL	SEARCH
9740:	26B3' C2BF26  		JP	NZ,SDL0
9741:	26B6' CD3F10  		CALL	GETEXTA
9742:	26B9' 7E      		LD	A,(HL)
9743:	26BA' E670    		AND	01110000B
9744:	26BC' C2C015  		JP	NZ,LRET$EQ$FF
9745:	26BF'         	SDL0:
9746:				; Does dir lbl exist on drive?
9747:	26BF' 2ADBFB  		LD	HL,(INFO)
9748:	26C2' 3620    		LD	(HL),20H
9749:	26C4' 0E01    		LD	C,1
9750:	26C6' CD0319  		CALL	SET$XDCNT
9751:	26C9' CDF714  		CALL	SEARCH
9752:	26CC' C2E426  		JP	NZ,SDL1
9753:				; no - make one
9754:	26CF' 3EFF    		LD	A,0FFH
9755:	26D1' 3215FD  		LD	(MAKE$XFCB),A
9756:	26D4' CD1619  		CALL	MAKE
9757:	26D7' C8      		RET	Z		; no dir space
9758:	26D8' CDB120  		CALL	INIT$XFCB
9759:	26DB' 011800  		LD	BC,24
9760:	26DE' CD0521  		CALL	STAMP5
9761:	26E1' CDDD20  		CALL	STAMP1
9762:	26E4'         	SDL1:
9763:				; Update date & time stamp
9764:	26E4' 011C00  		LD	BC,28
9765:	26E7' CD0521  		CALL	STAMP5
9766:	26EA' CDE220  		CALL	STAMP2
9767:				; Verify password - new dir lbl falls through
9768:	26ED' CDD420  		CALL	CHK$XFCB$PASSWORD
9769:	26F0' C2DF1F  		JP	NZ,PW$ERROR
9770:	26F3' 010000  		LD	BC,0
9771:	26F6' CDB720  		CALL	INIT$XFCB0
9772:				; Set dir lbl dta in extent field
9773:	26F9' 1A      		LD	A,(DE)
9774:	26FA' F601    		OR	1H
9775:	26FC' 77      		LD	(HL),A
9776:				; Low bit of dir lbl data set to indicate dir lbl exists
9777:				; Update drive's dir lbl vector element
9778:	26FD' E5      		PUSH	HL
9779:	26FE' 2A6F28  		LD	HL,(DRVLBLA)
9780:	2701' 77      		LD	(HL),A
9781:	2702' E1      		POP	HL
9782:	2703'         	SDL2:
9783:				; Assign new password to dir lbl or xfcb?
9784:	2703' 1A      		LD	A,(DE)
9785:	2704' E601    		AND	1
9786:	2706' CA1927  		JP	Z,SDL3
9787:				; yes - new password field is in 2nd 8 bytes of dma
9788:	2709' 110800  		LD	DE,8
9789:	270C' CDA720  		CALL	ADJUST$DMAAD
9790:	270F' CD4220  		CALL	SET$PW
9791:	2712' 70      		LD	(HL),B
9792:	2713' 11F8FF  		LD	DE,-8
9793:	2716' CDA720  		CALL	ADJUST$DMAAD
9794:	2719'         	SDL3:
9795:	2719' CDC82C  		CALL	FIX$HASH
9796:	271C' C39A12  		JP	SEEK$COPY
9797:				ELSE
9802:				ENDIF
9803:			
9804:	271F'         	FUNC101:
9805:				; Return directory label data
9806:				; Perform temporary select of specified drive
9807:	271F' CD671E  		CALL	TMPSELECT
9808:	2722' CD731F  		CALL	GET$DIR$MODE
9809:	2725' C3720A  		JP	STA$RET
9810:			
9811:	2728'         	FUNC102:
9812:				; Read file xfcb
9813:	2728' CD901E  		CALL	RESELECTX
9814:	272B' CD2D17  		CALL	CHECK$WILD
9815:	272E' CD9C10  		CALL	ZERO$EXT$MOD
9816:	2731' CDF014  		CALL	SEARCH$NAMLEN
9817:	2734' C8      		RET	Z
9818:	2735' CDC40F  		CALL	GETDMA
9819:	2738' 010800  		LD	BC,8
9820:	273B' CDA410  		CALL	ZERO
9821:	273E' E5      		PUSH	HL
9822:	273F' 0E00    		LD	C,0
9823:	2741' CD1221  		CALL	GETDTBA
9824:	2744' B7      		OR	A
9825:	2745' C25327  		JP	NZ,RXFCB2
9826:	2748' D1      		POP	DE
9827:	2749' EB      		EX	DE,HL
9828:	274A' 0E08    		LD	C,8
9829:			
9830:	FFFF'         		IF BANKED
9831:	274C' CD290E  		CALL	MOVE
9832:	274F' 1A      		LD	A,(DE)
9833:	2750' C35F27  		JP	RXFCB3
9834:				ELSE
9836:				ENDIF
9837:			
9838:	2753'         	RXFCB2:
9839:	2753' E1      		POP	HL
9840:	2754' 010800  		LD	BC,8
9841:			
9842:	FFFF'         		IF BANKED
9843:	2757' CDA410  		CALL	ZERO
9844:	275A' CD8320  		CALL	GETXFCB
9845:	275D' C8      		RET	Z
9846:	275E' 7E      		LD	A,(HL)
9847:	275F'         	RXFCB3:
9848:	275F' CD3F10  		CALL	GETEXTA
9849:	2762' 77      		LD	(HL),A
9850:	2763' C9      		RET
9851:				ELSE
9853:				ENDIF
9854:			
9855:	FFFF'         		IF BANKED
9856:			
9857:	2764'         	FUNC103:
9858:				; Write or update file xfcb
9859:	2764' CD901E  		CALL	RESELECTX
9860:				; Are passwords enabled in directory label?
9861:	2767' CD731F  		CALL	GET$DIR$MODE
9862:	276A' 17      		RLA
9863:	276B' D2C015  		JP	NC,LRET$EQ$FF	; no
9864:	276E' CD2D17  		CALL	CHECK$WILD
9865:				; Save .fcb(ext) & ext
9866:	2771' CD3F10  		CALL	GETEXTA
9867:	2774' 46      		LD	B,(HL)
9868:	2775' E5      		PUSH	HL
9869:	2776' C5      		PUSH	BC
9870:				; Set extent & mod to zero
9871:	2777' CD9C10  		CALL	ZERO$EXT$MOD
9872:				; Does file's 1st fcb exist in directory?
9873:	277A' CDF014  		CALL	SEARCH$NAMLEN
9874:				; Restore extent
9875:	277D' C1      		POP	BC
9876:	277E' E1      		POP	HL
9877:	277F' 70      		LD	(HL),B
9878:	2780' C8      		RET	Z		; no
9879:	2781' CD0319  		CALL	SET$XDCNT
9880:				; Does sfcb exist?
9881:	2784' CD1021  		CALL	GETDTBA$8
9882:	2787' B7      		OR	A
9883:	2788' CAE427  		JP	Z,WXFCB5	; yes
9884:				; No - Does xfcb exist?
9885:	278B' CD8320  		CALL	GETXFCB
9886:	278E' C2A127  		JP	NZ,WXFCB1	; yes
9887:	2791'         	WXFCB0:
9888:				; no - does file exist in directory?
9889:	2791' 3EFF    		LD	A,0FFH
9890:	2793' 3215FD  		LD	(MAKE$XFCB),A
9891:	2796' CDF514  		CALL	SEARCH$EXTNUM
9892:	2799' C8      		RET	Z
9893:				; yes - attempt to make xfcb for file
9894:	279A' CD1619  		CALL	MAKE
9895:	279D' C8      		RET	Z		; no dir space
9896:				; Initialize xfcb
9897:	279E' CDB120  		CALL	INIT$XFCB
9898:	27A1'         	WXFCB1:
9899:				; Verify password - new xfcb falls through
9900:	27A1' CDD420  		CALL	CHK$XFCB$PASSWORD
9901:	27A4' C2DF1F  		JP	NZ,PW$ERROR
9902:				; Set xfcb options data
9903:	27A7' E5      		PUSH	HL
9904:	27A8' CD3F10  		CALL	GETEXTA
9905:	27AB' D1      		POP	DE
9906:	27AC' EB      		EX	DE,HL
9907:	27AD' 7E      		LD	A,(HL)
9908:	27AE' B7      		OR	A
9909:	27AF' C2BE27  		JP	NZ,WXFCB2
9910:	27B2' 1A      		LD	A,(DE)
9911:	27B3' E601    		AND	1
9912:	27B5' C2BE27  		JP	NZ,WXFCB2
9913:	27B8' CD1927  		CALL	SDL3
9914:	27BB' C3CA27  		JP	WXFCB4
9915:	27BE'         	WXFCB2:
9916:	27BE' 1A      		LD	A,(DE)
9917:	27BF' E6E0    		AND	0E0H
9918:	27C1' C2C627  		JP	NZ,WXFCB3
9919:	27C4' 3E80    		LD	A,80H
9920:	27C6'         	WXFCB3:
9921:	27C6' 77      		LD	(HL),A
9922:	27C7' CD0327  		CALL	SDL2
9923:	27CA'         	WXFCB4:
9924:	27CA' CD9920  		CALL	GETXFCB1
9925:	27CD' 3D      		DEC	A
9926:	27CE' 32E428  		LD	(PW$MODE),A
9927:	27D1' CD9C10  		CALL	ZERO$EXT$MOD
9928:	27D4' CDF014  		CALL	SEARCH$NAMLEN
9929:	27D7' C8      		RET	Z
9930:	27D8' CD1021  		CALL	GETDTBA$8
9931:	27DB' B7      		OR	A
9932:	27DC' C0      		RET	NZ
9933:	27DD' 3AE428  		LD	A,(PW$MODE)
9934:	27E0' 77      		LD	(HL),A
9935:	27E1' C39A12  		JP	SEEK$COPY
9936:	27E4'         	WXFCB5:
9937:				; Take sfcb's password mode over xfcb's mode
9938:	27E4' 7E      		LD	A,(HL)
9939:	27E5' F5      		PUSH	AF
9940:	27E6' CD8320  		CALL	GETXFCB
9941:				; does xfcb exist?
9942:	27E9' C1      		POP	BC
9943:	27EA' CA9127  		JP	Z,WXFCB0	; no
9944:				; Set xfcb's password mode to sfcb's mode
9945:	27ED' 70      		LD	(HL),B
9946:	27EE' C3A127  		JP	WXFCB1
9947:			
9948:				ENDIF
9949:			
9950:	27F1'         	FUNC104:; Set current date and time
9951:			
9952:	0000'         		IF MPM
9954:				ELSE
9955:	27F1' 21F4FB  		LD	HL,STAMP
9956:				ENDIF
9957:	27F4' CD0E28  		CALL	COPY$STAMP
9958:	27F7' 3600    		LD	(HL),0
9959:	27F9' 0EFF    		LD	C,0FFH
9960:	27FB' C34EFF  		JP	TIMEF
9961:			
9962:	27FE'         	FUNC105:; Get current date and time
9963:			
9964:			
9965:			
9966:	0000'         		IF MPM
9968:				ELSE
9969:	27FE' 0E00    		LD	C,0
9970:	2800' CD4EFF  		CALL	TIMEF
9971:	2803' 21F4FB  		LD	HL,STAMP
9972:				ENDIF
9973:			
9974:	2806' EB      		EX	DE,HL
9975:	2807' CD0E28  		CALL	COPY$STAMP
9976:	280A' 1A      		LD	A,(DE)
9977:	280B' C3720A  		JP	STA$RET
9978:			
9979:	280E'         	COPY$STAMP:
9980:	280E' 0E04    		LD	C,4
9981:	2810' C3290E  		JP	MOVE		; ret
9982:			
9983:	0000'         		IF MPM
9990:				ENDIF
9991:			
9992:	FFFF'         		IF BANKED
9993:			
9994:	2813'         	FUNC106:; Set default password
9995:			
9996:	0000'         		IF MPM
10002:				ELSE
10003:	2813' 21EE28  		LD	HL,DF$PASSWORD+7
10004:				ENDIF
10005:	2816' EB      		EX	DE,HL
10006:	2817' 010800  		LD	BC,8
10007:	281A' E5      		PUSH	HL
10008:	281B' C34E20  		JP	SET$PW0
10009:				ELSE
10013:				ENDIF
10014:			
10015:	281E'         	FUNC107:; Return serial number
10016:			
10017:	0000'         		IF MPM
10020:				ELSE
10021:	281E' 210000  		LD	HL,SERIAL
10022:				ENDIF
10023:			
10024:	2821' EB      		EX	DE,HL
10025:	2822' 0E06    		LD	C,6
10026:	2824' C3290E  		JP	MOVE
10027:			
10028:	2827'         	FUNC108:; Get/Set program return code
10029:			
10030:				; Is de = 0ffffh?
10031:	2827' 7A      		LD	A,D
10032:	2828' A3      		AND	E
10033:	2829' 3C      		INC	A
10034:	282A' 2AACFB  		LD	HL,(CLP$ERRCDE)
10035:	282D' CA2924  		JP	Z,STHL$RET	; yes - return return code
10036:	2830' EB      		EX	DE,HL
10037:	2831' 22ACFB  		LD	(CLP$ERRCDE),HL
10038:	2834' C9      		RET			; no - set return code
10039:			
10040:	2835'         	GOBACK0:
10041:	2835' 21FFFF  		LD	HL,0FFFFH
10042:	2838' 229F0D  		LD	(ARET),HL
10043:	283B'         	GOBACK:
10044:				; Arrive here at end of processing to return to user
10045:	283B' 3ADDFB  		LD	A,(RESEL)
10046:	283E' B7      		OR	A
10047:	283F' CA5828  		JP	Z,RETMON
10048:			
10049:	0000'         		IF MPM
10053:				ENDIF
10054:			
10055:	2842' 2ADBFB  		LD	HL,(INFO)
10056:	2845' 3ABF28  		LD	A,(FCBDSK)
10057:	2848' 77      		LD	(HL),A		; fcb(0)=fcbdsk
10058:	FFFF'         		IF BANKED
10059:			
10060:				; fcb(7) = fcb(7) | xfcb$read$only
10061:	2849' 110700  		LD	DE,7
10062:	284C' 19      		ADD	HL,DE
10063:	284D' 3AB628  		LD	A,(XFCB$READ$ONLY)
10064:	2850' B6      		OR	(HL)
10065:	2851' 77      		LD	(HL),A
10066:			
10067:				ENDIF
10068:	0000'         		IF MPM
10082:				ELSE
10083:				; fcb(8) = fcb(8) | high$ext
10084:	FFFF'         		IF BANKED
10085:	2852' 23      		INC	HL
10086:				ELSE
10089:				ENDIF
10090:	2853' 3AB528  		LD	A,(HIGH$EXT)
10091:	2856' B6      		OR	(HL)
10092:	2857' 77      		LD	(HL),A
10093:				ENDIF
10094:			
10095:			;	return from the disk monitor
10096:			
10097:	2858'         	RETMON:
10098:	2858' 2A3203  		LD	HL,(ENTSP)
10099:	285B' F9      		LD	SP,HL
10100:	285C' 2A9F0D  		LD	HL,(ARET)
10101:	285F' 7D      		LD	A,L
10102:	2860' 44      		LD	B,H
10103:	2861' C9      		RET
10104:			;
10105:			;	data areas
10106:			;
10107:	2862' E5      	EFCB:		DEFB	EMPTY		; 0e5=available dir entry
10108:	2863' 0000    	RODSK:		DEFW	0		; read only disk vector
10109:	2865' 0000    	DLOG:		DEFW	0		; logged-in disks
10110:			
10111:	0000'         		IF MPM
10118:				ENDIF
10119:			
10120:	0000'         		IF NOT BANKED
10125:				ENDIF
10126:			
10127:	FFFF'         		IF NOT MPM
10128:			
10129:	2867'         	BUFFA:		DEFS	LWORD	; pointer to directory dma address
10130:			
10131:				ENDIF
10132:			
10133:			;
10134:			;	curtrka - alloca are set upon disk select
10135:			;	(data must be adjacent, do not insert variables)
10136:			;	(address of translate vector, not used)
10137:	2869'         	CDRMAXA:	DEFS	LWORD		; pointer to cur dir max value (2 bytes)
10138:	286B'         	CURTRKA:	DEFS	LWORD		; current track address (2)
10139:	286D'         	CURRECA:	DEFS	LWORD		; current record address (3)
10140:	286F'         	DRVLBLA:	DEFS	LWORD		; current drive label byte address (1)
10141:	2871'         	LSN$ADD:	DEFS	LWORD		; login sequence # address (1)
10142:				; +1 -> bios media change flag (1)
10143:	2873'         	DPBADDR:	DEFS	LWORD		; current disk parameter block address
10144:	2875'         	CHECKA:		DEFS	LWORD		; current checksum vector address
10145:	2877'         	ALLOCA:		DEFS	LWORD		; current allocation vector address
10146:	2879'         	DIRBCBA:	DEFS	LWORD		; dir bcb list head
10147:	287B'         	DTABCBA:	DEFS	LWORD		; data bcb list head
10148:	287D'         	HASHTBLA:
10149:	287D'         			DEFS	LWORD		; directory hash table address
10150:	287F'         			DEFS	LBYTE		; directory hash table bank
10151:			
10152:	000D'         	ADDLIST EQU	$-DPBADDR	; address list size
10153:			
10154:			;
10155:			;	       buffer control block format
10156:			;
10157:			; bcb format : drv(1) || rec(3) || pend(1) || sequence(1) ||
10158:			;	       0	 1	   4	      5
10159:			;
10160:			;	       track(2) || sector(2) || buffer$add(2) ||
10161:			;	       6	   8		10
10162:			;
10163:			;	       bank(1) || link(2)
10164:			;	       12	  13
10165:			;
10166:			
10167:			;	sectpt - offset obtained from disk parm block at dpbaddr
10168:			;	(data must be adjacent, do not insert variables)
10169:	2880'         	SECTPT:		DEFS	LWORD		; sectors per track
10170:	2882'         	BLKSHF:		DEFS	LBYTE		; block shift factor
10171:	2883'         	BLKMSK:		DEFS	LBYTE		; block mask
10172:	2884'         	EXTMSK:		DEFS	LBYTE		; extent mask
10173:	2885'         	MAXALL:		DEFS	LWORD		; maximum allocation number
10174:	2887'         	DIRMAX:		DEFS	LWORD		; largest directory number
10175:	2889'         	DIRBLK:		DEFS	LWORD		; reserved allocation bits for directory
10176:	288B'         	CHKSIZ:		DEFS	LWORD		; size of checksum vector
10177:	288D'         	OFFSET:		DEFS	LWORD		; offset tracks at beginning
10178:	288F'         	PHYSHF:		DEFS	LBYTE		; physical record shift
10179:	2890'         	PHYMSK:		DEFS	LBYTE		; physical record mask
10180:	0011'         	DPBLIST EQU	$-SECTPT	; size of area
10181:			;
10182:			;	local variables
10183:			;
10184:	2891'         	DREC:		DEFS	LWORD		; directory record number
10185:	2893'         	BLK$OFF:	DEFS	LBYTE		; record offset within block
10186:	2894'         	LAST$OFF: 	DEFS	LBYTE		; last offset within new block
10187:	2895'         	LASTDRIVE: 	DEFS	LBYTE	; drive of last new block
10188:	2896'         	LAST$BLOCK: 	DEFS	LWORD	; last new block
10189:			
10190:			; The following two variables are initialized as a pair on entry
10191:			
10192:	2898'         	DIR$CNT:	DEFS	LBYTE		; direct i/o count
10193:	2899'         	MULT$NUM: 	DEFS	LBYTE		; multi-sector number
10194:			
10195:	289A'         	TRANV:		DEFS	LWORD	; address of translate vector
10196:	289C'         	LOCK$UNLOCK:
10197:	289C'         	MAKE$FLAG:
10198:	289C'         	RMF:		DEFS	LBYTE		; read mode flag for open$reel
10199:	289D'         	INCR$PDCNT:
10200:	289D'         	DIRLOC:		DEFS	LBYTE		; directory flag in rename, etc.
10201:	289E'         	FREE$MODE:
10202:	289E'         	LINFO:		DEFS	LBYTE		; low(info)
10203:	289F'         	DMINX:		DEFS	LBYTE		; local for diskwrite
10204:			
10205:	0000'         		IF MPM
10209:				ENDIF
10210:	FFFF'         		IF BANKED
10211:			
10212:	28A0'         	SEARCHA:	DEFS	LWORD		; search address
10213:			
10214:				ENDIF
10215:			
10216:	FFFF'         		IF BANKED
10217:			
10218:	28A2'         	SAVE$XFCB:
10219:	28A2'         			DEFS	LBYTE		; search xfcb save flag
10220:			
10221:				ENDIF
10222:			
10223:	28A3'         	SINGLE:		DEFS	LBYTE	; set true if single byte allocation map
10224:			
10225:	0000'         		IF MPM
10229:				ENDIF
10230:			
10231:	28A4'         	SELDSK:		DEFS	LBYTE	; disk on entry to bdos
10232:	28A5'         	RCOUNT:		DEFS	LBYTE		; record count in current fcb
10233:	28A6'         	EXTVAL:		DEFS	LBYTE		; extent number and extmsk
10234:	28A7'         	SAVE$MOD:
10235:	28A7'         			DEFS	LBYTE		; open$reel module save field
10236:			
10237:	28A8'         	VRECORD:	DEFS	LBYTE		; current virtual record
10238:			
10239:	FFFF'         		IF NOT MPM
10240:			
10241:	28A9' FF      	CURDSK:		DEFB	0FFH	; current disk
10242:			
10243:				ENDIF
10244:			
10245:	28AA' FF      	ADRIVE:		DEFB	0FFH	; current blocking/deblocking disk
10246:	28AB'         	ARECORD:	DEFS	LWORD		; current actual record
10247:	28AD'         			DEFS	LBYTE
10248:			
10249:	28AE'         	SAVE$RANR: 	DEFS	3	; random record save area
10250:	28B1'         	ARECORD1: 	DEFS	LWORD		; current actual block# * blkmsk
10251:	28B3'         	ATTRIBUTES: 	DEFS	LBYTE	; make attribute hold area
10252:	28B4'         	READF$SW: 	DEFS	LBYTE		; BIOS read/write switch
10253:			
10254:			;******** following variable order critical *****************
10255:			
10256:	0000'         		IF MPM
10261:				ENDIF
10262:			
10263:	28B5'         	HIGH$EXT: 	DEFS	LBYTE	; fcb high ext bits
10264:			
10265:	FFFF'         		IF BANKED
10266:			
10267:	28B6'         	XFCB$READ$ONLY: DEFS	LBYTE	; xfcb read only flag
10268:			
10269:				ENDIF
10270:	0000'         		IF MPM
10295:				ENDIF
10296:			
10297:			;	local variables for directory access
10298:	28B7'         	DPTR:		DEFS	LBYTE		; directory pointer 0,1,2,3
10299:			
10300:	28B8'         	SAVE$HASH: 	DEFS	4	; hash code save area
10301:			
10302:	FFFF'         		IF BANKED
10303:			
10304:	28BC'         	COPY$CR$INIT: 	DEFS	LBYTE	; copy$cr$only initialization value
10305:			
10306:				ELSE
10311:				ENDIF
10312:			
10313:	0000'         		IF MPM
10320:				ENDIF
10321:			
10322:	28BD'         	SEARCH$USER0: 	DEFS	LBYTE	; search user 0 for file (open)
10323:			
10324:	28BE'         	USER0PASS: 	DEFS	LBYTE	; search user 0 pass flag
10325:			
10326:	28BF'         	FCBDSK:		DEFS	LBYTE	; disk named in fcb
10327:			
10328:	0000'         		IF MPM
10333:				ENDIF
10334:			
10335:	28C0' 0F101113	LOG$FXS:	DEFB	15,16,17,19,22,23,30,35,99,100,102,103,0
	      16171E23
	      63646667
	      00
10336:	28CD' 14152122	RW$FXS:		DEFB	20,21,33,34,40,41,0
	      282900
10337:	28D4' 101200  	SC$FXS:		DEFB	16,18,0
10338:			
10339:	0000'         		IF MPM
10343:				ENDIF
10344:	FFFF'         		IF BANKED
10345:			
10346:	28D7'         	PW$FCB:		DEFS	12	;1 |
10347:	28E3' 00      			DEFB	0		;2 |
10348:	28E4' 00      	PW$MODE:	DEFB	0		;3 |- Order critical
10349:	28E5' 00      			DEFB	0		;4 |
10350:	28E6' 00      			DEFB	0		;5 |
10351:			
10352:	28E7'         	DF$PASSWORD:	 DEFS	8
10353:			
10354:	0000'         		IF MPM
10356:				ENDIF
10357:				ENDIF
10358:			
10359:	28EF'         	PHY$OFF:	DEFS	LBYTE
10360:	28F0'         	CURBCBA:	DEFS	LWORD
10361:			
10362:	FFFF'         		IF BANKED
10363:			
10364:	28F2'         	LASTBCBA: 	DEFS	LWORD
10365:	28F4'         	ROOTBCBA: 	DEFS	LWORD
10366:	28F6'         	EMPTYBCBA: 	DEFS	LWORD
10367:	28F8'         	SEQBCBA:	DEFS	LWORD
10368:	28FA'         	BUFFER$BANK: 	DEFS	LBYTE
10369:			
10370:				ENDIF
10371:			
10372:	28FB'         	TRACK:		DEFS	LWORD
10373:	28FD'         	SECTOR:		DEFS	LWORD
10374:			
10375:			;	**************************
10376:			;	Blocking/Deblocking Module
10377:			;	**************************
10378:			
10379:	28FF'         	DEBLOCK$DTA:
10380:	28FF' 2A7B28  		LD	HL,(DTABCBA)
10381:			
10382:	FFFF'         		IF BANKED
10383:	2902' FE04    		CP	4
10384:	2904' C25829  		JP	NZ,DEBLOCK
10385:	2907'         	DEBLOCK$FLUSH:
10386:				; de = addr of 1st bcb
10387:	2907' 5E      		LD	E,(HL)
10388:	2908' 23      		INC	HL
10389:	2909' 56      		LD	D,(HL)
10390:				; Search for dirty bcb with lowest track #
10391:	290A' 21FFFF  		LD	HL,0FFFFH
10392:	290D' 22FB28  		LD	(TRACK),HL
10393:	2910' EB      		EX	DE,HL
10394:	2911'         	DEBLOCK$FLUSH1:
10395:				; Does current drive own bcb?
10396:	2911' 3AAA28  		LD	A,(ADRIVE)
10397:	2914' BE      		CP	(HL)
10398:	2915' C23C29  		JP	NZ,DEBLOCK$FLUSH2;no
10399:				; Is bcb's buffer pending?
10400:	2918' EB      		EX	DE,HL
10401:	2919' 210400  		LD	HL,4
10402:	291C' 19      		ADD	HL,DE
10403:	291D' 7E      		LD	A,(HL)
10404:	291E' EB      		EX	DE,HL
10405:	291F' 3C      		INC	A
10406:	2920' C23C29  		JP	NZ,DEBLOCK$FLUSH2; no
10407:				; Is bcb(6) < track?
10408:	2923' E5      		PUSH	HL
10409:	2924' 13      		INC	DE
10410:	2925' 13      		INC	DE
10411:	2926' EB      		EX	DE,HL
10412:	2927' 5E      		LD	E,(HL)
10413:	2928' 23      		INC	HL
10414:	2929' 56      		LD	D,(HL)
10415:				; Subdh computes hl = de - hl
10416:	292A' 2AFB28  		LD	HL,(TRACK)
10417:	292D' CD7F11  		CALL	SUBDH
10418:	2930' E1      		POP	HL
10419:	2931' D23C29  		JP	NC,DEBLOCK$FLUSH2; no
10420:				; yes - track = bcb(6) , sector = addr(bcb)
10421:	2934' EB      		EX	DE,HL
10422:	2935' 22FB28  		LD	(TRACK),HL
10423:	2938' EB      		EX	DE,HL
10424:	2939' 22FD28  		LD	(SECTOR),HL
10425:	293C'         	DEBLOCK$FLUSH2:
10426:				; Is this the last bcb?
10427:	293C' CD782B  		CALL	GET$NEXT$BCBA
10428:	293F' C21129  		JP	NZ,DEBLOCK$FLUSH1; no - hl = addr of next bcb
10429:				; Does track = ffff?
10430:	2942' 21FB28  		LD	HL,TRACK
10431:	2945' CDFB12  		CALL	TEST$FFFF
10432:	2948' C8      		RET	Z		; yes - no bcb to flush
10433:				; Flush bcb located by sector
10434:	2949' 2AFD28  		LD	HL,(SECTOR)
10435:	294C' AF      		XOR	A
10436:	294D' 3E04    		LD	A,4
10437:	294F' CD5829  		CALL	DEBLOCK
10438:	2952' 2A7B28  		LD	HL,(DTABCBA)
10439:	2955' C30729  		JP	DEBLOCK$FLUSH	; Repeat until no bcb's to flush
10440:				ENDIF
10441:			
10442:	2958'         	DEBLOCK:
10443:			
10444:				; BDOS Blocking/Deblocking routine
10445:				; a = 1 -> read command
10446:				; a = 2 -> write command
10447:				; a = 3 -> locate command
10448:				; a = 4 -> flush command
10449:				; a = 5 -> directory update
10450:			
10451:	2958' F5      		PUSH	AF		; Save z flag and deblock fx
10452:			
10453:				; phy$off = low(arecord) & phymsk
10454:				; low(arecord) = low(arecord) & ~phymsk
10455:	2959' CD512A  		CALL	DEBLOCK8
10456:	295C' 3AAB28  		LD	A,(ARECORD)
10457:	295F' 5F      		LD	E,A
10458:	2960' A0      		AND	B
10459:	2961' 32EF28  		LD	(PHY$OFF),A
10460:	2964' 7B      		LD	A,E
10461:	2965' A1      		AND	C
10462:	2966' 32AB28  		LD	(ARECORD),A
10463:			
10464:	FFFF'         		IF BANKED
10465:	2969' F1      		POP	AF
10466:	296A' F5      		PUSH	AF
10467:	296B' C4922A  		CALL	NZ,GET$BCBA
10468:				ENDIF
10469:			
10470:	296E' 22F028  		LD	(CURBCBA),HL
10471:	2971' CD8212  		CALL	GETBUFFA
10472:	2974' 221BFD  		LD	(CURDMA),HL
10473:				; hl = curbcba, de = .adrive, c = 4
10474:	2977' CD582A  		CALL	DEBLOCK9
10475:				; Is BCB discarded?
10476:	297A' 7E      		LD	A,(HL)
10477:	297B' 3C      		INC	A
10478:	297C' CAC229  		JP	Z,DEBLOCK2	; yes
10479:				; Is command flush?
10480:	297F' F1      		POP	AF
10481:	2980' F5      		PUSH	AF
10482:	2981' FE04    		CP	4
10483:	2983' D28D29  		JP	NC,DEBLOCK1	; yes
10484:				; Is referenced physical record already in buffer?
10485:			
10486:			;;;	call compare	;[JCE] DRI patch 7
10487:	2986' CD0B2D  		CALL	PATCH$1E0C
10488:			
10489:	2989' CAF229  		JP	Z,DEBLOCK45	; yes
10490:	298C' AF      		XOR	A
10491:	298D'         	DEBLOCK1:
10492:				; Does buffer contain an updated record?
10493:	298D' CD612A  		CALL	DEBLOCK10
10494:	2990' FE05    		CP	5
10495:	2992' CA9A29  		JP	Z,DEBLOCK15
10496:	2995' 7E      		LD	A,(HL)
10497:	2996' B7      		OR	A
10498:	2997' CAC229  		JP	Z,DEBLOCK2	; no
10499:	299A'         	DEBLOCK15:
10500:				; Reset record pending flag
10501:	299A' 3600    		LD	(HL),0
10502:				; Save arecord
10503:	299C' 2AAB28  		LD	HL,(ARECORD)
10504:	299F' E5      		PUSH	HL
10505:	29A0' 3AAD28  		LD	A,(ARECORD+2)
10506:	29A3' F5      		PUSH	AF
10507:				; Flush physical record buffer
10508:	29A4' CD582A  		CALL	DEBLOCK9
10509:	29A7' EB      		EX	DE,HL
10510:	29A8' CD290E  		CALL	MOVE
10511:				; Select drive to be flushed
10512:	29AB' 21A928  		LD	HL,CURDSK
10513:	29AE' 3AAA28  		LD	A,(ADRIVE)
10514:	29B1' BE      		CP	(HL)
10515:	29B2' C4541E  		CALL	NZ,DISK$SELECT1
10516:				; Write record if drive logged-in
10517:	29B5' 3E01    		LD	A,1
10518:	29B7' CC712A  		CALL	Z,DEBLOCK$IO
10519:				; Restore arecord
10520:	29BA' C1      		POP	BC
10521:	29BB' D1      		POP	DE
10522:	29BC' CD030F  		CALL	SET$ARECORD
10523:				; Restore selected drive
10524:	29BF' CD6B1E  		CALL	CURSELECT
10525:	29C2'         	DEBLOCK2:
10526:				; Is deblock command flush | dir write?
10527:	29C2' F1      		POP	AF
10528:	29C3' FE04    		CP	4
10529:	29C5' D0      		RET	NC		; yes - return
10530:				; Is deblock command write?
10531:	29C6' F5      		PUSH	AF
10532:	29C7' FE02    		CP	2
10533:	29C9' C2D629  		JP	NZ,DEBLOCK25	; no
10534:				; Is blk$off < last$off
10535:	29CC' 219428  		LD	HL,LAST$OFF
10536:	29CF' 3A9328  		LD	A,(BLK$OFF)
10537:	29D2' BE      		CP	(HL)
10538:	29D3' D2E029  		JP	NC,DEBLOCK3	; no
10539:	29D6'         	DEBLOCK25:
10540:				; Discard BCB on read operations in case
10541:				; I/O error occurs
10542:			;;;	lhld curbcba		;[JCE] DRI Patch 7
10543:	29D6' CD1B2D  		CALL	PATCH$1E1C
10544:	29D9' 36FF    		LD	(HL),0FFH
10545:				; Read physical record buffer
10546:	29DB' 3E02    		LD	A,2
10547:	29DD' C3E329  		JP	DEBLOCK35
10548:	29E0'         	DEBLOCK3:
10549:				; last$off = blk$off + 1
10550:	29E0' 3C      		INC	A
10551:	29E1' 77      		LD	(HL),A
10552:				; Place track & sector in bcb
10553:	29E2' AF      		XOR	A
10554:	29E3'         	DEBLOCK35:
10555:	29E3' CD712A  		CALL	DEBLOCK$IO
10556:	29E6'         	DEBLOCK4:
10557:	29E6' CD582A  		CALL	DEBLOCK9	; phypfx = adrive || arecord
10558:	29E9' CD290E  		CALL	MOVE
10559:	29EC' 3600    		LD	(HL),0		; zero pending flag
10560:			
10561:	FFFF'         		IF BANKED
10562:				; Zero logical record sequence
10563:	29EE' 23      		INC	HL
10564:	29EF' CD832B  		CALL	SET$BCB$SEQ
10565:				ENDIF
10566:			
10567:	29F2'         	DEBLOCK45:
10568:				; recadd = phybuffa + phy$off*80h
10569:	29F2' 3AEF28  		LD	A,(PHY$OFF)
10570:	29F5' 3C      		INC	A
10571:	29F6' 118000  		LD	DE,80H
10572:	29F9' 2180FF  		LD	HL,0FF80H
10573:	29FC'         	DEBLOCK5:
10574:	29FC' 19      		ADD	HL,DE
10575:	29FD' 3D      		DEC	A
10576:	29FE' C2FC29  		JP	NZ,DEBLOCK5
10577:	2A01' EB      		EX	DE,HL
10578:	2A02' 2A1BFD  		LD	HL,(CURDMA)
10579:	2A05' 19      		ADD	HL,DE
10580:				; If deblock command = locate then buffa = recadd; return
10581:	2A06' F1      		POP	AF
10582:	2A07' FE03    		CP	3
10583:	2A09' C2102A  		JP	NZ,DEBLOCK6
10584:	2A0C' 226728  		LD	(BUFFA),HL
10585:	2A0F' C9      		RET
10586:	2A10'         	DEBLOCK6:
10587:	2A10' EB      		EX	DE,HL
10588:	2A11' 2AD8FB  		LD	HL,(DMAAD)
10589:	2A14' 018000  		LD	BC,80H
10590:				; If deblock command = read
10591:	2A17' FE01    		CP	1
10592:			
10593:	FFFF'         		IF BANKED
10594:	2A19' C2332A  		JP	NZ,DEBLOCK7
10595:				; then move to tpa
10596:	2A1C' 3AFAFB  		LD	A,(COMMONBASE+1)
10597:	2A1F' 3D      		DEC	A
10598:	2A20' BA      		CP	D
10599:	2A21' DA0CFD  		JP	C,MOVE$TPA
10600:	2A24' 3AFA28  		LD	A,(BUFFER$BANK)
10601:	2A27' 4F      		LD	C,A
10602:	2A28' 0601    		LD	B,1
10603:	2A2A' CD692A  		CALL	DEBLOCK12
10604:	2A2D' 018000  		LD	BC,80H
10605:	2A30' C30CFD  		JP	MOVE$TPA
10606:	2A33'         	DEBLOCK7:
10607:			
10608:				ELSE
10610:				ENDIF
10611:			
10612:				; else move from dma
10613:	2A33' EB      		EX	DE,HL
10614:			
10615:	FFFF'         		IF BANKED
10616:	2A34' 3AFAFB  		LD	A,(COMMONBASE+1)
10617:	2A37' 3D      		DEC	A
10618:	2A38' BC      		CP	H
10619:	2A39' DA482A  		JP	C,DEBLOCK75
10620:	2A3C' 3AFA28  		LD	A,(BUFFER$BANK)
10621:	2A3F' 47      		LD	B,A
10622:	2A40' 0E01    		LD	C,1
10623:	2A42' CD692A  		CALL	DEBLOCK12
10624:	2A45' 018000  		LD	BC,80H
10625:	2A48'         	DEBLOCK75:
10626:			
10627:				ENDIF
10628:			
10629:	2A48' CD0CFD  		CALL	MOVE$TPA
10630:				; Set physical record pending flag for write command
10631:	2A4B' CD612A  		CALL	DEBLOCK10
10632:	2A4E' 36FF    		LD	(HL),0FFH
10633:	2A50' C9      		RET
10634:			
10635:	2A51'         	DEBLOCK8:
10636:	2A51' 3A9028  		LD	A,(PHYMSK)
10637:	2A54' 47      		LD	B,A
10638:	2A55' 2F      		CPL
10639:	2A56' 4F      		LD	C,A
10640:	2A57' C9      		RET
10641:			
10642:	2A58'         	DEBLOCK9:
10643:	2A58' 2AF028  		LD	HL,(CURBCBA)
10644:	2A5B' 11AA28  		LD	DE,ADRIVE
10645:	2A5E' 0E04    		LD	C,4
10646:	2A60' C9      		RET
10647:			
10648:	2A61'         	DEBLOCK10:
10649:	2A61' 110400  		LD	DE,4
10650:	2A64'         	DEBLOCK11:
10651:	2A64' 2AF028  		LD	HL,(CURBCBA)
10652:	2A67' 19      		ADD	HL,DE
10653:	2A68' C9      		RET
10654:			
10655:	FFFF'         		IF BANKED
10656:			
10657:	2A69'         	DEBLOCK12:
10658:	2A69' E5      		PUSH	HL
10659:	2A6A' D5      		PUSH	DE
10660:	2A6B' CD57FF  		CALL	XMOVEF
10661:	2A6E' D1      		POP	DE
10662:	2A6F' E1      		POP	HL
10663:	2A70' C9      		RET
10664:				ENDIF
10665:			
10666:	2A71'         	DEBLOCK$IO:
10667:				; a = 0 -> seek only
10668:				; a = 1 -> write
10669:				; a = 2 -> read
10670:	2A71' F5      		PUSH	AF
10671:	2A72' CD0C0F  		CALL	SEEK
10672:			
10673:	FFFF'         		IF BANKED
10674:	2A75' 3AFA28  		LD	A,(BUFFER$BANK)
10675:	2A78' CD54FF  		CALL	SETBNKF
10676:				ENDIF
10677:			
10678:	2A7B' 0E01    		LD	C,1
10679:	2A7D' F1      		POP	AF
10680:	2A7E' 3D      		DEC	A
10681:	2A7F' CA9E0E  		JP	Z,WRBUFF
10682:	2A82' F4930E  		CALL	P,RDBUFF
10683:				; Move track & sector to bcb
10684:	2A85' CD612A  		CALL	DEBLOCK10
10685:	2A88' 23      		INC	HL
10686:	2A89' 23      		INC	HL
10687:	2A8A' 11FB28  		LD	DE,TRACK
10688:	2A8D' 0E04    		LD	C,4
10689:	2A8F' C3290E  		JP	MOVE
10690:			
10691:	FFFF'         		IF BANKED
10692:			
10693:	2A92'         	GET$BCBA:
10694:			;;;	shld rootbcba	;[JCE] DRI Patch 13
10695:	2A92' CD302D  		CALL	PATCH$2D30
10696:	2A95' 11F3FF  		LD	DE,-13
10697:	2A98' 19      		ADD	HL,DE
10698:	2A99' 22F228  		LD	(LASTBCBA),HL
10699:	2A9C' CD782B  		CALL	GET$NEXT$BCBA
10700:	2A9F' E5      		PUSH	HL
10701:				; Is there only 1 bcb in list?
10702:	2AA0' CD782B  		CALL	GET$NEXT$BCBA
10703:	2AA3' E1      		POP	HL
10704:	2AA4' C8      		RET	Z		; yes - return
10705:	2AA5' EB      		EX	DE,HL
10706:	2AA6' 210000  		LD	HL,0
10707:	2AA9' 22F628  		LD	(EMPTYBCBA),HL
10708:	2AAC' 22F828  		LD	(SEQBCBA),HL
10709:	2AAF' EB      		EX	DE,HL
10710:	2AB0'         	GET$BCB1:
10711:				; Does bcb contain requested record?
10712:	2AB0' 22F028  		LD	(CURBCBA),HL
10713:	2AB3' CD582A  		CALL	DEBLOCK9
10714:	2AB6' CD1F0E  		CALL	COMPARE
10715:	2AB9' CA432B  		JP	Z,GET$BCB4	; yes
10716:				; Is bcb discarded?
10717:	2ABC' 2AF028  		LD	HL,(CURBCBA)
10718:	2ABF' 7E      		LD	A,(HL)
10719:	2AC0' 3C      		INC	A
10720:	2AC1' C2CE2A  		JP	NZ,GET$BCB11	; no
10721:	2AC4' EB      		EX	DE,HL
10722:	2AC5' 2AF228  		LD	HL,(LASTBCBA)
10723:	2AC8' 22F628  		LD	(EMPTYBCBA),HL
10724:	2ACB' C3F32A  		JP	GET$BCB14
10725:	2ACE'         	GET$BCB11:
10726:				; Does bcb contain record from current disk?
10727:	2ACE' 3AAA28  		LD	A,(ADRIVE)
10728:	2AD1' BE      		CP	(HL)
10729:	2AD2' C2F42A  		JP	NZ,GET$BCB15	; no
10730:	2AD5' EB      		EX	DE,HL
10731:	2AD6' 210500  		LD	HL,5
10732:	2AD9' 19      		ADD	HL,DE
10733:	2ADA' 3A9028  		LD	A,(PHYMSK)
10734:				; Is phymsk = 0?
10735:	2ADD' B7      		OR	A
10736:	2ADE' CAF32A  		JP	Z,GET$BCB14	; yes
10737:				; Does bcb(5) [bcb sequence] = phymsk?
10738:	2AE1' BE      		CP	(HL)
10739:	2AE2' C2F32A  		JP	NZ,GET$BCB14	; no
10740:			;;;	lhld seqbcba	;[JCE] DRI Patch 13
10741:			;;;	mov a,l
10742:			;;;	ora h
10743:	2AE5' 3A392D  		LD	A,(PATCH$2D39)
10744:	2AE8' B7      		OR	A
10745:	2AE9' 00      		NOP
10746:	2AEA' C2F32A  		JP	NZ,GET$BCB14
10747:	2AED' 2AF228  		LD	HL,(LASTBCBA)
10748:	2AF0' 22F828  		LD	(SEQBCBA),HL
10749:	2AF3'         	GET$BCB14:
10750:	2AF3' EB      		EX	DE,HL
10751:	2AF4'         	GET$BCB15:
10752:				; Advance to next bcb - list exhausted?
10753:	2AF4' E5      		PUSH	HL
10754:	2AF5' CD782B  		CALL	GET$NEXT$BCBA
10755:	2AF8' D1      		POP	DE
10756:	2AF9' CA042B  		JP	Z,GET$BCB2	; yes
10757:	2AFC' EB      		EX	DE,HL
10758:	2AFD' 22F228  		LD	(LASTBCBA),HL
10759:	2B00' EB      		EX	DE,HL
10760:	2B01' C3B02A  		JP	GET$BCB1
10761:	2B04'         	GET$BCB2:
10762:				; Matching bcb not found
10763:				; Was a sequentially accessed bcb encountered?
10764:			;;;	lhld seqbcba	;[JCE] DRI Patch 13
10765:	2B04' 2AF628  		LD	HL,(EMPTYBCBA)
10766:			
10767:	2B07' 7D      		LD	A,L
10768:	2B08' B4      		OR	H
10769:	2B09' C2142B  		JP	NZ,GET$BCB25	; yes
10770:				; Was a discarded bcb encountered?
10771:			;;;	lhld emptybcba	;[JCE] DRI Patch 13
10772:	2B0C' 2AF828  		LD	HL,(SEQBCBA)
10773:			
10774:	2B0F' 7D      		LD	A,L
10775:	2B10' B4      		OR	H
10776:	2B11' CA172B  		JP	Z,GET$BCB3	; no
10777:	2B14'         	GET$BCB25:
10778:	2B14' 22F228  		LD	(LASTBCBA),HL
10779:	2B17'         	GET$BCB3:
10780:				; Insert selected bcb at head of list
10781:	2B17' 2AF228  		LD	HL,(LASTBCBA)
10782:	2B1A' CD782B  		CALL	GET$NEXT$BCBA
10783:	2B1D' 22F028  		LD	(CURBCBA),HL
10784:	2B20' CD782B  		CALL	GET$NEXT$BCBA
10785:	2B23' EB      		EX	DE,HL
10786:	2B24' CD6D2B  		CALL	LAST$BCB$LINKS$DE
10787:	2B27' 2AF428  		LD	HL,(ROOTBCBA)
10788:	2B2A' 5E      		LD	E,(HL)
10789:	2B2B' 23      		INC	HL
10790:	2B2C' 56      		LD	D,(HL)
10791:	2B2D' 2AF028  		LD	HL,(CURBCBA)
10792:	2B30' 010D00  		LD	BC,13
10793:	2B33' 09      		ADD	HL,BC
10794:	2B34' 73      		LD	(HL),E
10795:	2B35' 23      		INC	HL
10796:	2B36' 72      		LD	(HL),D
10797:	2B37' 2AF028  		LD	HL,(CURBCBA)
10798:	2B3A' EB      		EX	DE,HL
10799:	2B3B' 2AF428  		LD	HL,(ROOTBCBA)
10800:	2B3E' 73      		LD	(HL),E
10801:	2B3F' 23      		INC	HL
10802:	2B40' 72      		LD	(HL),D
10803:	2B41' EB      		EX	DE,HL
10804:	2B42' C9      		RET
10805:	2B43'         	GET$BCB4:
10806:				; BCB matched arecord
10807:	2B43' 2AF028  		LD	HL,(CURBCBA)
10808:	2B46' 110500  		LD	DE,5
10809:	2B49' 19      		ADD	HL,DE
10810:				; Does bcb(5) = phy$off?
10811:	2B4A' 3AEF28  		LD	A,(PHY$OFF)
10812:	2B4D' BE      		CP	(HL)
10813:	2B4E' CA592B  		JP	Z,GET$BCB5	; yes
10814:				; Does bcb(5) + 1 = phy$off?
10815:	2B51' 34      		INC	(HL)
10816:	2B52' BE      		CP	(HL)
10817:	2B53' CA592B  		JP	Z,GET$BCB5	; yes
10818:	2B56' CD832B  		CALL	SET$BCB$SEQ
10819:	2B59'         	GET$BCB5:
10820:				; Is bcb at head of list?
10821:	2B59' 2AF028  		LD	HL,(CURBCBA)
10822:	2B5C' EB      		EX	DE,HL
10823:	2B5D' 2AF428  		LD	HL,(ROOTBCBA)
10824:	2B60' 7E      		LD	A,(HL)
10825:	2B61' 23      		INC	HL
10826:	2B62' 6E      		LD	L,(HL)
10827:	2B63' 67      		LD	H,A
10828:	2B64' CD7F11  		CALL	SUBDH
10829:	2B67' B5      		OR	L
10830:	2B68' EB      		EX	DE,HL
10831:	2B69' C8      		RET	Z		; yes
10832:	2B6A' C3172B  		JP	GET$BCB3	; no - insert bcb at head of list
10833:			
10834:	2B6D'         	LAST$BCB$LINKS$DE:
10835:	2B6D' 2AF228  		LD	HL,(LASTBCBA)
10836:	2B70' 010D00  		LD	BC,13
10837:	2B73' 09      		ADD	HL,BC
10838:	2B74' 73      		LD	(HL),E
10839:	2B75' 23      		INC	HL
10840:	2B76' 72      		LD	(HL),D
10841:	2B77' C9      		RET
10842:			
10843:	2B78'         	GET$NEXT$BCBA:
10844:	2B78' 010D00  		LD	BC,13
10845:	2B7B' 09      		ADD	HL,BC
10846:	2B7C' 5E      		LD	E,(HL)
10847:	2B7D' 23      		INC	HL
10848:	2B7E' 56      		LD	D,(HL)
10849:	2B7F' EB      		EX	DE,HL
10850:	2B80' 7C      		LD	A,H
10851:	2B81' B5      		OR	L
10852:	2B82' C9      		RET
10853:			
10854:	2B83'         	SET$BCB$SEQ:
10855:	2B83' 3AEF28  		LD	A,(PHY$OFF)
10856:	2B86' 77      		LD	(HL),A
10857:	2B87' B7      		OR	A
10858:	2B88' C8      		RET	Z
10859:	2B89' 3A9028  		LD	A,(PHYMSK)
10860:	2B8C' 3C      		INC	A
10861:	2B8D' 77      		LD	(HL),A
10862:	2B8E' C9      		RET
10863:			
10864:				ENDIF
10865:			
10866:	FFFF'         		IF NOT MPM
10867:	0000'         		IF NOT BANKED
11011:				ENDIF
11012:				ENDIF
11013:			
11014:			;	************************
11015:			;	Directory Hashing Module
11016:			;	************************
11017:			
11018:			; Hash format
11019:			; xxsuuuuu xxxxxxxx xxxxxxxx ssssssss
11020:			; x = hash code of fcb name field
11021:			; u = low 5 bits of fcb user field
11022:			;     1st bit is on for XFCB's
11023:			; s = shiftr(mod || ext,extshf)
11024:			
11025:	0000'         		IF NOT BANKED
11029:				ENDIF
11030:			
11031:	2B8F'         	INIT$HASH:
11032:				; de = .hash table entry
11033:				; hl = .dir fcb
11034:	2B8F' E5      		PUSH	HL
11035:	2B90' D5      		PUSH	DE
11036:	2B91' CDE02B  		CALL	GET$HASH
11037:				; Move computed hash to hash table entry
11038:	2B94' E1      		POP	HL
11039:	2B95' 119DFB  		LD	DE,HASH
11040:	2B98' 010400  		LD	BC,4
11041:			
11042:	FFFF'         		IF BANKED
11043:	2B9B' 3A7F28  		LD	A,(HASHTBLA+2)
11044:	2B9E' CD09FD  		CALL	MOVE$OUT
11045:				ELSE
11047:				ENDIF
11048:			
11049:				; Save next hash table entry address
11050:	2BA1' 22B128  		LD	(ARECORD1),HL
11051:				; Restore dir fcb address
11052:	2BA4' E1      		POP	HL
11053:	2BA5' C9      		RET
11054:			
11055:	2BA6'         	SET$HASH:
11056:				; Return if searchl = 0
11057:	2BA6' B7      		OR	A
11058:	2BA7' C8      		RET	Z
11059:				; Is searchl < 12 ?
11060:	2BA8' FE0C    		CP	12
11061:	2BAA' DADC2B  		JP	C,SET$HASH2	; yes - hashl = 0
11062:				; Is searchl = 12 ?
11063:	2BAD' 3E02    		LD	A,2
11064:	2BAF' CAB42B  		JP	Z,SET$HASH1	; yes - hashl = 2
11065:	2BB2' 3E03    		LD	A,3		; hashl = 3
11066:	2BB4'         	SET$HASH1:
11067:	2BB4' 329CFB  		LD	(HASHL),A
11068:	2BB7' EB      		EX	DE,HL
11069:				; Is dir hashing invoked for drive?
11070:	2BB8' CD642C  		CALL	TEST$HASH
11071:	2BBB' C8      		RET	Z		; no
11072:	2BBC' EB      		EX	DE,HL
11073:	2BBD' 3ADFFB  		LD	A,(FX)
11074:	2BC0' FE10    		CP	16
11075:	2BC2' CAE02B  		JP	Z,GET$HASH	; bdos fx = 16
11076:	2BC5' FE23    		CP	35
11077:	2BC7' CACF2B  		JP	Z,SET$HASH15
11078:	2BCA' FE14    		CP	20
11079:	2BCC' D2E02B  		JP	NC,GET$HASH	; bdos fx = 20 or above
11080:	2BCF'         	SET$HASH15:
11081:	2BCF' 3E02    		LD	A,2
11082:	2BD1' 329CFB  		LD	(HASHL),A	; bdos fx = 15,17,18,19, or 35
11083:				; if fcb wild then hashl = 0, hash = fcb(0)
11084:				;	      else hashl = 2, hash = get$hash
11085:	2BD4' E5      		PUSH	HL
11086:	2BD5' CD3917  		CALL	CHK$WILD
11087:	2BD8' E1      		POP	HL
11088:	2BD9' C2E02B  		JP	NZ,GET$HASH
11089:	2BDC'         	SET$HASH2:
11090:	2BDC' AF      		XOR	A
11091:	2BDD' 329CFB  		LD	(HASHL),A
11092:				; jmp get$hash
11093:			
11094:	2BE0'         	GET$HASH:
11095:				; hash(0) = fcb(0)
11096:	2BE0' 7E      		LD	A,(HL)
11097:	2BE1' 329DFB  		LD	(HASH),A
11098:	2BE4' 23      		INC	HL
11099:	2BE5' EB      		EX	DE,HL
11100:				; Don't compute hash for dir lbl & sfcb's
11101:	2BE6' 210000  		LD	HL,0
11102:	2BE9' E620    		AND	20H
11103:	2BEB' C21E2C  		JP	NZ,GET$HASH6
11104:				; b = 11, c = 8, ahl = 0
11105:				; Compute fcb name hash (000000xx xxxxxxxxx xxxxxxxx) (ahl)
11106:	2BEE' 01080B  		LD	BC,0B08H
11107:	2BF1'         	GET$HASH1:
11108:				; Don't shift if fcb(8)
11109:	2BF1' 0D      		DEC	C
11110:	2BF2' C5      		PUSH	BC
11111:	2BF3' CA062C  		JP	Z,GET$HASH3
11112:				; Don't shift if fcb(6)
11113:	2BF6' 0D      		DEC	C
11114:	2BF7' 0D      		DEC	C
11115:	2BF8' CA062C  		JP	Z,GET$HASH3
11116:				; ahl = ahl * 2
11117:	2BFB' 29      		ADD	HL,HL
11118:	2BFC' 8F      		ADC	A,A
11119:	2BFD' F5      		PUSH	AF
11120:	2BFE' 78      		LD	A,B
11121:				; is b odd?
11122:	2BFF' 1F      		RRA
11123:	2C00' DA072C  		JP	C,GET$HASH4	; yes
11124:				; ahl = ahl * 2 for even fcb(i)
11125:	2C03' F1      		POP	AF
11126:	2C04' 29      		ADD	HL,HL
11127:	2C05' 8F      		ADC	A,A
11128:	2C06'         	GET$HASH3:
11129:	2C06' F5      		PUSH	AF
11130:	2C07'         	GET$HASH4:
11131:				; a = fcb(i) & 7fh - 20h divided by 2 if even
11132:	2C07' 1A      		LD	A,(DE)
11133:	2C08' E67F    		AND	7FH
11134:	2C0A' D620    		SUB	20H
11135:	2C0C' 1F      		RRA
11136:	2C0D' D2112C  		JP	NC,GET$HASH5
11137:	2C10' 17      		RLA
11138:	2C11'         	GET$HASH5:
11139:				; ahl = ahl + a
11140:	2C11' 4F      		LD	C,A
11141:	2C12' 0600    		LD	B,0
11142:	2C14' F1      		POP	AF
11143:	2C15' 09      		ADD	HL,BC
11144:	2C16' CE00    		ADC	A,0
11145:	2C18' C1      		POP	BC
11146:				; advance to next fcb char
11147:	2C19' 13      		INC	DE
11148:	2C1A' 05      		DEC	B
11149:	2C1B' C2F12B  		JP	NZ,GET$HASH1
11150:	2C1E'         	GET$HASH6:
11151:				; ahl = 000000xx xxxxxxxx xxxxxxxx
11152:				; Store low 2 bytes of hash
11153:	2C1E' 229EFB  		LD	(HASH+1),HL
11154:	2C21' 219DFB  		LD	HL,HASH
11155:				; hash(0) = hash(0) (000uuuuu) | xx000000
11156:	2C24' E603    		AND	3
11157:	2C26' 0F      		RRCA
11158:	2C27' 0F      		RRCA
11159:	2C28' B6      		OR	(HL)
11160:	2C29' 77      		LD	(HL),A
11161:				; Does fcb(0) = e5h, 20h, or 21h?
11162:	2C2A' E620    		AND	20H
11163:	2C2C' C25B2C  		JP	NZ,GET$HASH9	; yes
11164:				; bc = 00000mmm mmmeeeee, m = module #, e = extent
11165:	2C2F' 1A      		LD	A,(DE)
11166:	2C30' E61F    		AND	1FH
11167:	2C32' 4F      		LD	C,A
11168:	2C33' 13      		INC	DE
11169:	2C34' 13      		INC	DE
11170:	2C35' 1A      		LD	A,(DE)
11171:	2C36' E63F    		AND	3FH
11172:	2C38' 0F      		RRCA
11173:	2C39' 0F      		RRCA
11174:	2C3A' 0F      		RRCA
11175:	2C3B' 57      		LD	D,A
11176:	2C3C' E607    		AND	7
11177:	2C3E' 47      		LD	B,A
11178:	2C3F' 7A      		LD	A,D
11179:	2C40' E6E0    		AND	0E0H
11180:	2C42' B1      		OR	C
11181:	2C43' 4F      		LD	C,A
11182:				; shift bc right by # of bits in extmsk
11183:	2C44' 3A8428  		LD	A,(EXTMSK)
11184:	2C47'         	GET$HASH7:
11185:	2C47' 1F      		RRA
11186:	2C48' D2562C  		JP	NC,GET$HASH8
11187:	2C4B' F5      		PUSH	AF
11188:	2C4C' 78      		LD	A,B
11189:	2C4D' 1F      		RRA
11190:	2C4E' 47      		LD	B,A
11191:	2C4F' 79      		LD	A,C
11192:	2C50' 1F      		RRA
11193:	2C51' 4F      		LD	C,A
11194:	2C52' F1      		POP	AF
11195:	2C53' C3472C  		JP	GET$HASH7
11196:	2C56'         	GET$HASH8:
11197:				; hash(0) = hash(0) (xx0uuuuu) | 00s00000
11198:	2C56' 78      		LD	A,B
11199:	2C57' E601    		AND	1
11200:	2C59' 0F      		RRCA
11201:	2C5A' 0F      		RRCA
11202:	2C5B'         	GET$HASH9:
11203:	2C5B' 0F      		RRCA
11204:	2C5C' B6      		OR	(HL)
11205:	2C5D' 77      		LD	(HL),A
11206:				; hash(3) = ssssssss
11207:	2C5E' 110300  		LD	DE,3
11208:	2C61' 19      		ADD	HL,DE
11209:	2C62' 71      		LD	(HL),C
11210:	2C63' C9      		RET
11211:			
11212:	2C64'         	TEST$HASH:
11213:	2C64' 2A7D28  		LD	HL,(HASHTBLA)
11214:	2C67' 7D      		LD	A,L
11215:	2C68' B4      		OR	H
11216:	2C69' 3C      		INC	A
11217:	2C6A' C9      		RET
11218:			
11219:	2C6B'         	SEARCH$HASH:
11220:				; Does hash table exist for drive?
11221:	2C6B' CD642C  		CALL	TEST$HASH
11222:	2C6E' C8      		RET	Z		; no
11223:				; Has dir hash search been disabled?
11224:	2C6F' 3A9CFB  		LD	A,(HASHL)
11225:	2C72' 3C      		INC	A
11226:	2C73' C8      		RET	Z		; yes
11227:				; Is searchl = 0?
11228:	2C74' 3AE5FB  		LD	A,(SEARCHL)
11229:	2C77' B7      		OR	A
11230:	2C78' C8      		RET	Z		; yes
11231:				; hashmx = cdrmaxa if searchl ~= 1
11232:				;	   dir$max if searchl = 1
11233:	2C79' 2A6928  		LD	HL,(CDRMAXA)
11234:	2C7C' 5E      		LD	E,(HL)
11235:	2C7D' 23      		INC	HL
11236:	2C7E' 56      		LD	D,(HL)
11237:	2C7F' EB      		EX	DE,HL
11238:	2C80' 3D      		DEC	A
11239:	2C81' C2872C  		JP	NZ,SEARCH$H0
11240:	2C84' 2A8728  		LD	HL,(DIRMAX)
11241:	2C87'         	SEARCH$H0:
11242:	2C87' 2212FD  		LD	(HASHMX),HL
11243:			
11244:	FFFF'         		IF BANKED
11245:				; call search$hash in resbdos, a = bank, hl = hash tbl addr
11246:	2C8A' 3A7F28  		LD	A,(HASHTBLA+2)
11247:	2C8D' 2A7D28  		LD	HL,(HASHTBLA)
11248:	2C90' CD0FFD  		CALL	SRCH$HASH
11249:				; Was search successful?
11250:	2C93' C2AE2C  		JP	NZ,SEARCH$H1	; no
11251:				; Is directory read required?
11252:	2C96' 3A14FD  		LD	A,(RD$DIR$FLAG)
11253:	2C99' B7      		OR	A
11254:	2C9A' 0E00    		LD	C,0
11255:	2C9C' C43D13  		CALL	NZ,R$DIR2	; yes if Z flag reset
11256:				; Is function = 18?
11257:	2C9F' 3ADFFB  		LD	A,(FX)
11258:	2CA2' D612    		SUB	18
11259:	2CA4' C8      		RET	Z		; Never reset dcnt for fx 18
11260:				; Was media change detected by above read?
11261:	2CA5' 3A9CFB  		LD	A,(HASHL)
11262:	2CA8' 3C      		INC	A
11263:	2CA9' CC0113  		CALL	Z,SETENDDIR	; yes
11264:	2CAC' AF      		XOR	A
11265:	2CAD' C9      		RET			; search$hash successful
11266:	2CAE'         	SEARCH$H1:
11267:				; Was search initiated from beginning of directory?
11268:	2CAE' CDF812  		CALL	END$OF$DIR
11269:	2CB1' C0      		RET	NZ		; no
11270:				; Is bdos fx = 15,17,19,22,23,30?
11271:	2CB2' CDF511  		CALL	TST$LOG$FXS
11272:	2CB5' C0      		RET	NZ		; no
11273:				; Disable hash & return successful
11274:	2CB6' 3EFF    		LD	A,0FFH
11275:	2CB8' 329CFB  		LD	(HASHL),A
11276:	2CBB' 2A6928  		LD	HL,(CDRMAXA)
11277:	2CBE' 5E      		LD	E,(HL)
11278:	2CBF' 23      		INC	HL
11279:	2CC0' 56      		LD	D,(HL)
11280:	2CC1' EB      		EX	DE,HL
11281:	2CC2' 2B      		DEC	HL
11282:	2CC3' CD0D19  		CALL	SET$DCNT$DBLK1
11283:	2CC6' AF      		XOR	A
11284:	2CC7' C9      		RET
11285:				ELSE
11456:				ENDIF
11457:			
11458:	2CC8'         	FIX$HASH:
11459:	2CC8' CD642C  		CALL	TEST$HASH
11460:	2CCB' C8      		RET	Z
11461:	2CCC' 21B828  		LD	HL,SAVE$HASH
11462:	2CCF' 119DFB  		LD	DE,HASH
11463:	2CD2' 010400  		LD	BC,4
11464:	2CD5' E5      		PUSH	HL
11465:	2CD6' D5      		PUSH	DE
11466:	2CD7' C5      		PUSH	BC
11467:	2CD8' CD4BFF  		CALL	MOVEF
11468:	2CDB' 2A7D28  		LD	HL,(HASHTBLA)
11469:	2CDE' E5      		PUSH	HL
11470:	2CDF' CD4011  		CALL	GETDPTRA
11471:	2CE2' CDE02B  		CALL	GET$HASH
11472:	2CE5' 2AE1FB  		LD	HL,(DCNT)
11473:	2CE8' 29      		ADD	HL,HL
11474:	2CE9' 29      		ADD	HL,HL
11475:	2CEA' D1      		POP	DE
11476:	2CEB' 19      		ADD	HL,DE
11477:	2CEC' C1      		POP	BC
11478:	2CED' D1      		POP	DE
11479:	2CEE' D5      		PUSH	DE
11480:	2CEF' C5      		PUSH	BC
11481:			
11482:	FFFF'         		IF BANKED
11483:	2CF0' 3A7F28  		LD	A,(HASHTBLA+2)
11484:	2CF3' CD09FD  		CALL	MOVE$OUT
11485:				ELSE
11487:				ENDIF
11488:			
11489:	2CF6' C1      		POP	BC
11490:	2CF7' E1      		POP	HL
11491:	2CF8' D1      		POP	DE
11492:	2CF9' C34BFF  		JP	MOVEF
11493:			
11494:	FFFF'         		IF NOT MPM
11495:	FFFF'         		IF BANKED
11496:			
11497:	2CFC'         	PATCH$1DFD: ;[JCE] DRI Patch 7
11498:	2CFC' 3A8C28  		LD	A,(CHKSIZ+1)
11499:	2CFF' 17      		RLA
11500:	2D00' DA9714  		JP	C,GET$DIR$EXT
11501:	2D03' 3EFF    		LD	A,0FFH
11502:	2D05' 32232D  		LD	(PATCH$1E24),A
11503:	2D08' C39714  		JP	GET$DIR$EXT
11504:			
11505:	2D0B'         	PATCH$1E0C:
11506:	2D0B' FE03    		CP	3
11507:	2D0D' C21F0E  		JP	NZ,COMPARE
11508:	2D10' 3A232D  		LD	A,(PATCH$1E24)
11509:	2D13' 3C      		INC	A
11510:	2D14' C21F0E  		JP	NZ,COMPARE
11511:	2D17' E1      		POP	HL
11512:	2D18' C3D629  		JP	DEBLOCK25
11513:			
11514:	2D1B'         	PATCH$1E1C:
11515:	2D1B' AF      		XOR	A
11516:	2D1C' 32232D  		LD	(PATCH$1E24),A
11517:	2D1F' 2AF028  		LD	HL,(CURBCBA)
11518:	2D22' C9      		RET
11519:			
11520:	2D23'         	PATCH$1E24:
11521:	2D23' 00      		DEFB	0
11522:			
11523:	2D24'         	PATCH$1E25:
11524:	2D24' 210000  		LD	HL,0
11525:	2D27' 22BAFB  		LD	(CONBUFFADD),HL
11526:	2D2A' 22B1FB  		LD	(CCP$CONBUFF),HL
11527:	2D2D' 2B      		DEC	HL
11528:	2D2E' 2B      		DEC	HL
11529:	2D2F' C9      		RET
11530:			
11531:	2D30'         	PATCH$2D30:
11532:	2D30' 22F428  		LD	(ROOTBCBA),HL
11533:	2D33' D603    		SUB	3
11534:	2D35' 32392D  		LD	(PATCH$2D39),A
11535:	2D38' C9      		RET
11536:			
11537:	2D39'         	PATCH$2D39:
11538:	2D39' 00      		DEFB	0
11539:			
11540:	2D3A'         	PATCH$2D3A:
11541:	2D3A' CD432D  		CALL	PATCH$2D43
11542:	2D3D' C31325  		JP	FLUSH4
11543:			
11544:	2D40'         	PATCH$2D40:
11545:	2D40' CD7713  		CALL	COPY$ALV
11546:	2D43'         	PATCH$2D43:
11547:	2D43' 2A7B28  		LD	HL,(DTABCBA)
11548:	2D46' 7D      		LD	A,L
11549:	2D47' A4      		AND	H
11550:	2D48' 3C      		INC	A
11551:	2D49' C8      		RET	Z
11552:	2D4A'         	PATCH$2D4A:
11553:	2D4A' 5E      		LD	E,(HL)
11554:	2D4B' 23      		INC	HL
11555:	2D4C' 56      		LD	D,(HL)
11556:	2D4D' 7A      		LD	A,D
11557:	2D4E' B3      		OR	E
11558:	2D4F' C8      		RET	Z
11559:	2D50' 21AA28  		LD	HL,ADRIVE
11560:	2D53' 1A      		LD	A,(DE)
11561:	2D54' BE      		CP	(HL)
11562:	2D55' C2632D  		JP	NZ,PATCH$2D63
11563:	2D58' 210400  		LD	HL,4
11564:	2D5B' 19      		ADD	HL,DE
11565:	2D5C' 3EFF    		LD	A,0FFH
11566:	2D5E' BE      		CP	(HL)
11567:	2D5F' C2632D  		JP	NZ,PATCH$2D63
11568:	2D62' 12      		LD	(DE),A
11569:	2D63'         	PATCH$2D63:
11570:	2D63' 210D00  		LD	HL,0DH
11571:	2D66' 19      		ADD	HL,DE
11572:	2D67' C34A2D  		JP	PATCH$2D4A
11573:			
11574:	2D6A'         	PATCH$2D6A:
11575:	2D6A' CD7713  		CALL	COPY$ALV
11576:	2D6D' 2A7128  		LD	HL,(LSN$ADD)
11577:	2D70' 7E      		LD	A,(HL)
11578:	2D71' B7      		OR	A
11579:	2D72' C0      		RET	NZ
11580:	2D73' 3602    		LD	(HL),2
11581:	2D75' C9      		RET
11582:			
11583:	2D76'         	PATCH$1E31:
11584:	2D76' CD3911  		CALL	CHECK$WRITE
11585:	2D79' 2117FD  		LD	HL,XDCNT
11586:	2D7C' C9      		RET
11587:			
11588:	2D7D'         	PATCH$1E38:
11589:	2D7D' CD901E  		CALL	RESELECTX
11590:	2D80' C33911  		JP	CHECK$WRITE
11591:			
11592:	2D83'         	PATCH$1E3E:
11593:	2D83' CD6211  		CALL	SETFWF
11594:	2D86' C3F014  		JP	SEARCH$NAMLEN
11595:			
11596:	2D89'         	LAST:
11597:			
11598:	2D89'         		DEFS	BASE + $2DFF - LAST
11599:			
11600:	2DFF' 00      		DEFB	0
11601:			
11602:				ENDIF	;BANKED
11603:			
11604:				ELSE	;not MPM
11646:				ENDIF
11647:			
11648:	2E00'         		END



Statistics:

     4	passes
     0	jr promotions
  1241	symbols
     0	bytes

     2	macro calls
   112	macro bytes
     0	invented symbols



Symbol Table:

@bdate             0     
@lcopy            17     
@scopy            51     
addh            1146'    
addlist        =   d     
adjust$dmaad    20a7'    
adrive          28aa'    
adv$dma          37f'    
alloca          2877'    
allocwd         1c07'    
apos             d28'    
aposi            d25'    
arecord         28ab'    
arecord1        28b1'    
aret             d9f'    
atran            ff2'    
attributes      28b3'    
auxin$rflg     =fbc2'    
auxinstf       =ff36'    
auxout$rflg    =fbc4'    
auxoutstf      =ff39'    
back$one         9c5'    
backsp           93d'    
backup           557'    
backx            8a8'    
backx1           8bd'    
badseek         1da9'    
banked         =ffffffff 
base           =   0'    
bde$e$bde$m$hl   de4'    
bde$e$bde$p$hl   ded'    
bdos$flags     =fbf3'    
bdos$jmp          6f'    
bdosadd        =fbfe'    
bdose              6'    
bdose1            2e'    
bdose2            3b'    
bios           =ff00'    
bios$pg        =ff00'    
blk$off         2893'    
blk$out          a9e'    
blk$out1         ab2'    
blk$out2         ab5'    
blkmsk          2883'    
blkshf          2882'    
blockok         1bde'    
bnkbdos$pg     =fc00'    
bootf          =ff00'    
buffa           2867'    
buffer$bank     28fa'    
buffer$full      9e0'    
buffnzero       188c'    
call$open       21b9'    
cbdos            374'    
cbdos1           378'    
cbs1             642'    
cbs2             64c'    
cbuff            ac1'    
cbuff$len        ac0'    
ccp$comlen     =fbae'    
ccp$conbuff    =fbb1'    
ccp$curdrv     =fbaf'    
ccp$curusr     =fbb0'    
ccp$flgs       =fbb3'    
cdrmaxa         2869'    
check$all$media 1f2f'    
check$fcb       10ce'    
check$media     1ef5'    
check$media1    1f08'    
check$media2    1f24'    
check$npr1      1a68'    
check$npr10     1b2b'    
check$npr10a    1b42'    
check$npr11     1a72'    
check$npr1a     1a6c'    
check$npr1b     1a6f'    
check$npr2      1a88'    
check$npr21     1aa7'    
check$npr23     1aa8'    
check$npr4      1ac2'    
check$npr45     1af5'    
check$npr5      1afd'    
check$npr6      1b05'    
check$npr7      1b0d'    
check$npr8      1b1c'    
check$npr9      1b1d'    
check$nprs      1a4d'    
check$rodir     1128'    
check$rofile    112b'    
check$wild      172d'    
check$wild0     1730'    
check$write     1139'    
checka          2875'    
checksum        1188'    
chek$fcb        10d8'    
chek$fcb1       10e2'    
chk$am1         1f3c'    
chk$am2         1f51'    
chk$buffer$size  63b'    
chk$column       5c0'    
chk$exit$fxs    1213'    
chk$inv$fcb     12e8'    
chk$media$fcb   10e3'    
chk$media$flag   eb6'    
chk$media1      10f7'    
chk$media2      10f9'    
chk$password    1f78'    
chk$pw          1f7e'    
chk$pw$error    1f85'    
chk$pwe1        1fd2'    
chk$pwe2        1fe4'    
chk$pwe3        1ffd'    
chk$wild        1739'    
chk$wild1       173b'    
chk$xfcb$password 20d4'    
chk$xfcb$password1 20d7'    
chksiz          288b'    
chksiz$eq$8000h  eeb'    
clear$right      61b'    
close           183d'    
close$fcb       186c'    
close1          184b'    
clp$errcde     =fbac'    
clp$flgs       =fbaa'    
clr$ext         115a'    
clrmodnum       1154'    
cmp$pw          2002'    
cmp$pw1         200f'    
cmp$pw2         201d'    
cmp$pw3         2027'    
cmp$pw4         2034'    
column         =fbb7'    
comchr           abf'    
commonbase     =fbf9'    
compare          e1f'    
compare$extents 18f8'    
compare$mod$ext 2671'    
compare$rr      1dfe'    
compcdr         1169'    
compcol          abc'    
compext         1486'    
compout          4f6'    
compute$cs      10b8'    
compute$cs0     10be'    
compute$cs1     10c1'    
compute$rr      1dcb'    
conb0            47f'    
conb1            49a'    
conb2            49d'    
conb3            4a0'    
conbrk           41b'    
conbrk1          450'    
conbrk2          45e'    
conbrk3          475'    
conbrkx          42f'    
conbuffadd     =fbba'    
conbufflen     =fbbc'    
conech           3c2'    
conech0          3c6'    
conech1          3d6'    
conech2          3e5'    
conin            3b7'    
conin$rflg     =fbbe'    
coninf         =fb74'    
conline        =fbb9'    
conmode        =fbcf'    
conout           4cd'    
conout$rflg    =fbc0'    
conoutf        =fb7a'    
conoutstf      =ff33'    
conpage        =fbb8'    
constf         =fb6e'    
constx           3ff'    
contran        =fbcd'    
conwidth       =fbb6'    
copy$alv        1377'    
copy$cbuff       5ee'    
copy$cbuff1      60a'    
copy$cbuff2      60f'    
copy$cr$init    28bc'    
copy$cr$only   =fd1d'    
copy$dir        16f7'    
copy$dir0       16f9'    
copy$dir1       16fd'    
copy$dir2       1710'    
copy$dirloc     1480'    
copy$stamp      280e'    
copy$user$no    1748'    
copy$xbuff       5d8'    
cr             =   d     
crlf             582'    
crlfp            56a'    
crlfp0           572'    
csearch         229d'    
csearch1        22af'    
csearch2        22be'    
csearch3        22c3'    
csearch4        22da'    
ctl            =  5e     
ctla           =   1     
ctla$column      d2d'    
ctla$sw          d2a'    
ctlb           =   2     
ctlb$l0          7dc'    
ctlb$l1          7e1'    
ctlb$l2          7f0'    
ctlb$l3          7f8'    
ctlc           =   3     
ctlc$stat$ret    a68'    
ctle           =   5     
ctlf           =   6     
ctlg           =   7     
ctlh           =   8     
ctlh$act       =fbca'    
ctlk           =   b     
ctlout           513'    
ctlp           =  10     
ctlq           =  11     
ctlr           =  12     
ctlr$l1          8ed'    
ctlr$l2          8f8'    
ctls           =  13     
ctlu           =  15     
ctlw           =  17     
ctlw$l0          755'    
ctlw$l1          760'    
ctlw$l13         76a'    
ctlw$l15         76f'    
ctlw$l2          773'    
ctlw$l25         782'    
ctlw$l3          791'    
ctlw$sw          d2b'    
ctlx           =  18     
ctlz           =  1a     
curbcba         28f0'    
curdma         =fd1b'    
curdsk          28a9'    
curreca         286d'    
curselect       1e6b'    
curtrka         286b'    
dcnt           =fbe1'    
deblock         2958'    
deblock$dta     28ff'    
deblock$flush   2907'    
deblock$flush1  2911'    
deblock$flush2  293c'    
deblock$io      2a71'    
deblock1        298d'    
deblock10       2a61'    
deblock11       2a64'    
deblock12       2a69'    
deblock15       299a'    
deblock2        29c2'    
deblock25       29d6'    
deblock3        29e0'    
deblock35       29e3'    
deblock4        29e6'    
deblock45       29f2'    
deblock5        29fc'    
deblock6        2a10'    
deblock7        2a33'    
deblock75       2a48'    
deblock8        2a51'    
deblock9        2a58'    
delete          1636'    
delete00        1645'    
delete01        166b'    
delete02        167e'    
delete1         1684'    
delete10        1687'    
delete11        168a'    
delete12        169b'    
delete13        169d'    
deletex         163c'    
delim            24d'    
delim1           252'    
delim2           25d'    
delim3           269'    
delimiters       23f'    
devinitf       =ff3f'    
devtblf        =ff3c'    
df$password     28e7'    
diocomp          ea5'    
dir$cnt         2898'    
dir$to$user     12c3'    
dirbcba         2879'    
dirbios1        2562'    
dirbios2        256b'    
dirbios3        258b'    
dirbios4        2590'    
dirblk          2889'    
dirinp           a20'    
dirinp1          a25'    
dirloc          289d'    
dirmax          2887'    
dirrec         =   4     
dirstat          a17'    
discard         125b'    
discard$data    1252'    
discard$data$bcb 124a'    
discard$dir     1258'    
discard0        125d'    
discard1        1265'    
discard2        1274'    
disk$select     1e51'    
disk$select1    1e54'    
diskf          =   c     
diskread        19f5'    
diskread0       1a00'    
diskwr1         1c11'    
diskwr10        1c15'    
diskwr11        1c84'    
diskwr2         1cc7'    
diskwrite       1b63'    
diskwrite0      1b9c'    
diskwrite15     1bb5'    
diskwrite2      1bba'    
diskwrite3      1cde'    
diskwru         1c0f'    
dlog            2865'    
dm$position      fa4'    
dmaad          =fbd8'    
dminx           289f'    
dmpos0           fab'    
dmpos1           fb9'    
dmpos2           fc2'    
dmset           18a8'    
do$ctla          79f'    
do$ctlb          7ca'    
do$ctlf          71c'    
do$ctlf0         724'    
do$ctlh          839'    
do$ctlu          8ce'    
do$ctlw          73a'    
do$newline       9c0'    
do$rubout        85c'    
does$xfcb$exist 1608'    
dont$write      1cba'    
dpbaddr         2873'    
dpblist        =  11     
dptr            28b7'    
drec            2891'    
drv$lbl         1474'    
drv$relog       1233'    
drvlbla         286f'    
drvtblf        =ff42'    
dskerr           d3d'    
dskmap         =  10     
dskmsg           d2f'    
dskmsk         =   3     
dskshf         =   2     
dspl$flgs      =fba6'    
dtabcba         287b'    
echoc            3f0'    
efcb            2862'    
empty          =  e5     
emptybcba       28f6'    
end$of$dir      12f8'    
enddir         =ffff     
endsearch       159b'    
endsearch1      15ad'    
entsp            332'    
errdrv         =fbed'    
errflg           280'    
errflg1          2af'    
errflg2          2b8'    
errflg3          2e5'    
error          =fbfb'    
error$sub         7c'    
errormode      =fbe7'    
errtbl           14a'    
expand           5c9'    
expand1          5ce'    
extmsk          2884'    
extnum         =   c     
extval          28a6'    
false          =   0     
fcbdsk          28bf'    
fcblen         =  20     
fcbnzero        1886'    
fcbshf         =   5     
file$exists     23e3'    
fill0           1c4b'    
fill00          1c37'    
fill1           1c5b'    
find$xfcb      =fd16'    
fix$hash        2cc8'    
flush           251a'    
flush0          24e8'    
flush1          24ed'    
flush3          2506'    
flush35         2510'    
flush4          2513'    
flush5          2515'    
flushf         =ff48'    
flushx          2520'    
free$mode       289e'    
func$ret         a75'    
func1          = 3c2'    
func10         = 6c8'    
func100         26a6'    
func101         271f'    
func102         2728'    
func103         2764'    
func104         27f1'    
func105         27fe'    
func106         2813'    
func107         281e'    
func108         2827'    
func109          a7b'    
func11           a3d'    
func110          a89'    
func111          a95'    
func112          a95'    
func12          217d'    
func13          2183'    
func14          2196'    
func15          21a0'    
func16          2287'    
func17          229b'    
func18          22ec'    
func19          22f5'    
func2          = 528'    
func20          22fb'    
func21          2304'    
func22          230d'    
func23          23ef'    
func24          23f5'    
func25          23fb'    
func26          2401'    
func27          2408'    
func28         =11d3'    
func29          2411'    
func3            a01'    
func30          2417'    
func31          2423'    
func32          242d'    
func33          2441'    
func34          244a'    
func35          2453'    
func36         =1e40'    
func37          2459'    
func38         = a75'    
func39         = a75'    
func40         =244a'    
func42         = a75'    
func43         = a75'    
func44          247d'    
func45          248b'    
func46          2490'    
func47          24cd'    
func48          24df'    
func49          252a'    
func49$set      2545'    
func50          2550'    
func50$ret      25b0'    
func6            a07'    
func7            a2b'    
func8            a31'    
func9            a37'    
func98         =24e8'    
func99          25c8'    
functab           c6'    
functab2         12c'    
fwfmsk         =  80     
fx             =fbdf'    
fxstsmsg         d85'    
get$atts        1018'    
get$atts$loop   1021'    
get$bcb1        2ab0'    
get$bcb11       2ace'    
get$bcb14       2af3'    
get$bcb15       2af4'    
get$bcb2        2b04'    
get$bcb25       2b14'    
get$bcb3        2b17'    
get$bcb4        2b43'    
get$bcb5        2b59'    
get$bcba        2a92'    
get$block       16b8'    
get$de0         149f'    
get$de1         14a2'    
get$de2         14ac'    
get$de3         14b9'    
get$dir$ext     1497'    
get$dir$mode    1f73'    
get$fcb$adds    2667'    
get$hash        2be0'    
get$hash1       2bf1'    
get$hash3       2c06'    
get$hash4       2c07'    
get$hash5       2c11'    
get$hash6       2c1e'    
get$hash7       2c47'    
get$hash8       2c56'    
get$hash9       2c5b'    
get$nalbs       13de'    
get$next$bcba   2b78'    
get$rra         1037'    
getallocbit     134e'    
getbuffa        1282'    
getdm            fcc'    
getdma           fc4'    
getdmd           fda'    
getdptra        1140'    
getdtba         2112'    
getdtba$8       2110'    
getexta         103f'    
getfcb          1058'    
getfcb0         106d'    
getfcb1         1074'    
getfcba         104f'    
getfilesize     1e13'    
getmodnum       114b'    
getrcnta        1047'    
gets1           1031'    
getsize         1e1f'    
getxfcb         2083'    
getxfcb1        2099'    
gfc              219'    
gfc1             232'    
goback          283b'    
goback0         2835'    
goerr            db2'    
goerr1           db8'    
gsp1            249d'    
gsp2            249e'    
gsp3            24a2'    
gsp4            24aa'    
hash           =fb9d'    
hashl          =fb9c'    
hashmx         =fd12'    
hashtbla        287d'    
high$ext        28b5'    
high$fxs          5d'    
hlrotl          10fe'    
hlrotl0         10ff'    
hlrotr          10ab'    
hlrotr0         10ac'    
hold$dma         372'    
home             e80'    
homef          =ff18'    
incr$pdcnt      289d'    
incr$rr          dfe'    
index            fe0'    
indic0          17b4'    
indic1          17ce'    
indicators      17a4'    
info           =fbdb'    
init$apos        6a8'    
init$hash       2b8f'    
init$xfcb       20b1'    
init$xfcb$search 15fd'    
init$xfcb$search1 15ff'    
init$xfcb0      20b7'    
init$xfcb1      20cc'    
init$xpos        6b3'    
initial$cs      11c6'    
initial0        140d'    
initial2        1438'    
initial3        146e'    
initialize      13e8'    
initialize2     1405'    
invis          =   a     
kbchar         =fd20'    
last            2d89'    
last$bcb$links$de 2b6d'    
last$block      2896'    
last$off        2894'    
lastbcba        28f2'    
lastdrive       2895'    
lbyte          =   1     
lefttst         16d2'    
lf             =   a     
linelen          90b'    
linfo           289e'    
listcp         =fbd4'    
listf          =fb80'    
liststf        =ff2d'    
lock$unlock     289c'    
log$fxs         28c0'    
lret           = d9f'    
lret$eq$ff      15c0'    
lsn$add         2871'    
lstfcb         =  1f     
lstout$rflg    =fbc6'    
lstrec         =  7f     
lword          =   2     
make            1916'    
make$fcb$inv    12dd'    
make$flag       289c'    
make$xfcb      =fd15'    
make0           194c'    
make00          2397'    
make2           23ab'    
make3a          23d2'    
makea0          2333'    
makex04         2359'    
maxall          2885'    
maxext         =  1f     
maxmod         =  40     
md             =   0     
media$change    11b2'    
media$flag     =fbf0'    
merge0          1878'    
merged          1893'    
mergerr         18f2'    
mergezero       181f'    
modnum         =   e     
move             e29'    
move$out       =fd09'    
move$tpa       =fd0c'    
move0            e2a'    
movef          =ff4b'    
mpm            =   0     
mrg$rc1         18d9'    
mrg$rc2         18da'    
mult$fxs          95'    
mult$io          348'    
mult$num        2899'    
multcnt        =fbe6'    
multiof        =ff45'    
namlen         =   f     
new$ctla$col     d2e'    
newchecksum     1186'    
nfuncs         =  33     
nfuncs2        =   f     
nopblock        1bd1'    
normal$status    a6f'    
noselect        1edf'    
noselect0       1ee9'    
not$ctla         7c5'    
not$ctlb         80b'    
not$ctlf         735'    
not$ctlg         82d'    
not$ctlk         81e'    
not$ctlw         79a'    
notbacksp        50d'    
notc             9a0'    
note             892'    
noth             850'    
notp             8a2'    
notr             94d'    
notrub           873'    
notu             8d5'    
notx             8c4'    
noupdate        1ccf'    
nowrite         111a'    
nxtline          708'    
nxtrec         =  20     
off            =   0     
offset          288d'    
olddsk         =fbda'    
olog           =fb90'    
on             =ffffffff 
open            17da'    
open$copy       17de'    
open$mod        1999'    
open$r$err      19c9'    
open$reel       1971'    
open$reel0      19a0'    
open$reel1      19b9'    
open$reel2      19bc'    
open$reel3      19da'    
open$reel4      19ec'    
open$user$zero  21d3'    
open1           17dd'    
openx           21e7'    
openx0          2212'    
openx0a         224e'    
openx0b         2257'    
openx1          2272'    
openx1a         2276'    
openx2          227b'    
openxa          21f7'    
outdelim       =fbd3'    
pad              26c'    
page$mode      =fbc8'    
parse$name       1ac'    
parse$ok         1e0'    
parse$type       1ca'    
parse0           170'    
parse6           1b6'    
parse8           1d4'    
parsedrv         198'    
parsepw          1fb'    
parsepw1         205'    
passmsg          d76'    
patch$064b       997'    
patch$13ff      13ff'    
patch$1dfd      2cfc'    
patch$1e0c      2d0b'    
patch$1e1c      2d1b'    
patch$1e24      2d23'    
patch$1e25      2d24'    
patch$1e31      2d76'    
patch$1e38      2d7d'    
patch$1e3e      2d83'    
patch$2d30      2d30'    
patch$2d39      2d39'    
patch$2d3a      2d3a'    
patch$2d40      2d40'    
patch$2d43      2d43'    
patch$2d4a      2d4a'    
patch$2d63      2d63'    
patch$2d6a      2d6a'    
pctlh            565'    
permsg           d41'    
perror           1f5'    
perror1          1f6'    
phy$off         28ef'    
phymsk          2890'    
physhf          288f'    
pm$default     =fbc9'    
pr$fcb           30e'    
pr$fcb1          316'    
pr$fx            2fb'    
pr$fx1           30b'    
print            58c'    
punchf         =ff12'    
pw$error        1fdf'    
pw$fcb          28d7'    
pw$mode         28e4'    
qconin           59c'    
qconin1          5b6'    
qconinx        =fd21'    
qconoutf         4bd'    
qdirfcb1        2140'    
qflag          =fbd5'    
qstamp          2132'    
qstamp1         2136'    
r$dir           130e'    
r$dir1          1340'    
r$dir2          133d'    
ranclose        1d5b'    
randiskread     1db9'    
randiskwrite    1dc2'    
ranrec         =  21     
rcount          28a5'    
rd$dir$flag    =fd14'    
rdbuff           e93'    
rddir           1292'    
rdech0           95e'    
rdech05          96d'    
rdech1           971'    
rdech2           98c'    
read             6d7'    
read$deblock    1a3f'    
read$dir        1308'    
read$dir0       131f'    
read$dir1       1326'    
read$dir2       1330'    
readen           9e7'    
readerf        =ff15'    
readf          =ff27'    
readf$sw        28b4'    
readi            6c8'    
readn0           701'    
readnx           6ff'    
readx            6dd'    
readx1           6e4'    
reboote          323'    
rebootx          329'    
rebootx0         32c'    
rebootx1         32f'    
reccnt         =   f     
recordok        1a19'    
recordok1       1a22'    
recsiz         =  80     
refresh          65e'    
refresh0         66f'    
refresh05        68a'    
refresh1         677'    
refresh2         693'    
refresh3         699'    
relog          =fbde'    
rename          1752'    
rename0         1788'    
rename1         1798'    
rep0             913'    
rep1             92e'    
resbdos        =fd00'    
resbdos$pg     =fd00'    
resel          =fbdd'    
reselect        1e9a'    
reselect1       1eb9'    
reselectx       1e90'    
reset$37x       245a'    
reset$copy$cr$only  ddc'    
reset$dma        390'    
reset$dma1       393'    
reset$fwf       1b50'    
reset$relog      ee6'    
reset$rr         e19'    
restore$dir$fcb 162b'    
restore$rc      182d'    
restore$rc1     183b'    
retblock        16e6'    
retblock0       16ee'    
retmon          2858'    
retselect        e7e'    
reverse          62b'    
righttst        16ba'    
rlog           =fb92'    
rmf             289c'    
ro$test         1132'    
rod$error        da1'    
rodmsg           d67'    
rodsk           2863'    
rof$error        da6'    
rofile         =   9     
rofmsg           d58'    
rootbcba        28f4'    
rotl            1362'    
rotr            1370'    
rseek           1ce4'    
rseek2          1d50'    
rseek3          1d6b'    
rtn$phy$errs     dc5'    
rubout         =  7f     
rubout$act     =fbcb'    
rw$fxs          28cd'    
rxfcb2          2753'    
rxfcb3          275f'    
save$col         614'    
save$column      d2c'    
save$dcnt$pos   15f5'    
save$dcnt$pos$ret 15fb'    
save$dcnt$pos0  15ea'    
save$dcnt$pos1  15ed'    
save$dcnt$pos2  15de'    
save$dma         389'    
save$hash       28b8'    
save$mod        28a7'    
save$ranr       28ae'    
save$rr          e09'    
save$rr1         e0d'    
save$rr2         e12'    
save$xfcb       28a2'    
savepos          abe'    
sc$fxs          28d4'    
scandm$a        13a6'    
scandm$ab       138b'    
scandm$b        1390'    
scandm0         13b0'    
scandm1         13c3'    
scandm2         13c9'    
scandm3         13d8'    
scb            =fb9c'    
scb$pg         =fb00'    
scbadd         =fbd6'    
sconoutf       =fb7a'    
sdl0            26bf'    
sdl1            26e4'    
sdl2            2703'    
sdl3            2719'    
search          14f7'    
search$extnum   14f5'    
search$fin      15ba'    
search$h0       2c87'    
search$h1       2cae'    
search$hash     2c6b'    
search$namlen   14f0'    
search$user0    28bd'    
search1         14fa'    
searcha         28a0'    
searchchain    =fbe8'    
searchext       157c'    
searchi         14dd'    
searchi1        14e3'    
searchl        =fbe5'    
searchloop      1557'    
searchmod       15b7'    
searchn         1503'    
searchnext      152a'    
searchnm        15c7'    
searchok        1594'    
sector          28fd'    
sectpt          2880'    
sectran        =ff30'    
seek             f0c'    
seek$copy       129a'    
seek0            f22'    
seek1            f39'    
seek2            f50'    
seekdir          ef5'    
seekerr         1db0'    
seekok          1d9c'    
seekok1         1da1'    
seekok2         1da4'    
sel$error        dab'    
seldsk          28a4'    
seldskf        =ff1b'    
select          1e78'    
selectdisk       e33'    
selmemf        =ff51'    
selmsg           d4a'    
seqbcba         28f8'    
seqdiskread     19f5'    
seqdiskwrite    1b63'    
serial             0'    
set$arecord      f03'    
set$aret        23e5'    
set$bcb$seq     2b83'    
set$cdisk       1108'    
set$cdisk1      110b'    
set$copy$cr$only  dd5'    
set$ctla$column  6ba'    
set$ctls$mode    40c'    
set$dcnt$dblk   190a'    
set$dcnt$dblk1  190d'    
set$dlog        1105'    
set$filewf      1b57'    
set$hash        2ba6'    
set$hash1       2bb4'    
set$hash15      2bcf'    
set$hash2       2bdc'    
set$lsn         1241'    
set$pw          2042'    
set$pw0         204e'    
set$pw1         2050'    
set$pw2         205e'    
set$pw3         2076'    
set$pw4         2079'    
set$rc          17fd'    
set$rc1         1810'    
set$rc2         1812'    
set$rc3         1815'    
set$rlog        11e8'    
set$ro          11d3'    
set$rr          1e0d'    
set$submit$flag 1725'    
set$xdcnt       1903'    
setallocbit     1368'    
setbnkf        =ff54'    
setcdr          1176'    
setdata         12b6'    
setdir1         12bc'    
setdma          12bf'    
setdmaf        =ff24'    
setenddir       1301'    
setfcb          1082'    
setfwf          1162'    
setlret1         a76'    
setmatch         237'    
setrandom       1e40'    
setsecf        =ff21'    
setsize         1e3e'    
settrkf        =ff1e'    
setusrcode      243b'    
shell            334'    
shell$err        399'    
shell$rtn        3a2'    
shell$sp         366'    
shell$stk        372'    
shl3bv           df6'    
shl3bv1          df7'    
shr$physhf       f9d'    
single          28a3'    
skps             273'    
srch$hash      =fd0f'    
sta$ret          a72'    
stamp          =fbf4'    
stamp1          20dd'    
stamp2          20e2'    
stamp3          20e4'    
stamp4          20ed'    
stamp5          2105'    
sthl$ret        2429'    
strtcol          abd'    
subdh           117f'    
tab            =   9     
tab0             53d'    
tab1             549'    
tabout           528'    
tabout1          537'    
tbuff          =  80     
temp$drive     =fbec'    
test$152         15c'    
test$ctls$mode   413'    
test$ffff       12fb'    
test$hash       2c64'    
test$media$flag 120c'    
test$p1         1f5f'    
test$pending    1f58'    
testvector      111d'    
testvector1     1120'    
tfcb           =  5c     
timef          =ff4e'    
tmpselect       1e67'    
toggle$l1        4bb'    
toggle$listcp    4a9'    
track           28fb'    
tranv           289a'    
true           =ffffffff 
trunc1          25fe'    
trunc15         2619'    
trunc2          261c'    
trunc3          2622'    
tst$inv$fcb     12ee'    
tst$log$fxs     11f5'    
tst$log0        11fe'    
tst$log1        1202'    
tst$relog       122b'    
type$ahead     =fbcc'    
ubytes         =   d     
update$cs       11d1'    
update$stamp    2153'    
user$info      =fd1e'    
user0pass       28be'    
usrcode        =fbe0'    
util$flgs      =fba2'    
version        =fba1'    
vrecord         28a8'    
wbootf         =fb68'    
wildmsg          d91'    
wrbuff           e9e'    
wrdir           129a'    
wrdir0          12a2'    
write           1c9b'    
write0          1cb7'    
writef         =ff2a'    
wxfcb0          2791'    
wxfcb1          27a1'    
wxfcb2          27be'    
wxfcb3          27c6'    
wxfcb4          27ca'    
wxfcb5          27e4'    
xbuff            bc2'    
xdcnt          =fd17'    
xdcnt$eq$dcnt   1624'    
xdmaad         =fd19'    
xfcb$read$only  28b6'    
xmovef         =ff57'    
xpos             d26'    
zero            10a4'    
zero$dm         268b'    
zero$dm1        2694'    
zero$dm2        269e'    
zero$ext$mod    109c'    
zprint           2ee'    
