   1:				TITLE	"ZSDOS File Copy Program"
   2:			;=======================================================================;
   3:			;				C O P Y					;
   4:			;-----------------------------------------------------------------------;
   5:			; Derived from MCOPY 4.0 by Richard Conn with Mods by Bruce Morgen(4.8),;
   6:			; Howard Goldstein (4.6), Michael Bate (4.4,5), Steven M. Cohen (4.3),	;
   7:			; Jay Sage, and Joe Wright (4.2)					;
   8:			;-----------------------------------------------------------------------;
   9:			; Changes for ZSDOS and DSLIB Copyright (C) 1988  by Harold F. Bower	;
  10:			;			All rights reserved				;
  11:			; This program is made available for non-commercial use.  Any commercial;
  12:			; use must be authorized by the express written consent of the author.	;
  13:			;-----------------------------------------------------------------------;
  14:			; COPY is a program which copies files between drives or between User	;
  15:			; areas.  If Date/Time Stamping is used, Create and Modify Stamps will	;
  16:			; be preserved.  Stamps are accessed through DSLIB routines.		;
  17:			;									;
  18:			; COPY MUST be linked with The Libraries, Version 4 as:			;
  19:			;									;
  20:			;	ZML COPY,DSLIB/,Z3LIB/,SYSLIB/					;
  21:			;									;
  22:			; Revisions:								;
  23:			;	1.72- Replaced DDIRQ & DDIRPACK library routines with source	;
  24:			;		modified to handle Joe Wright's NZTIME stamps along	;
  25:			;		with P2Dos, DateStamper(tm) and DosDisk(tm) Stamps.	;
  26:			;						  17 Jul 93  HFB	;
  27:			;	1.71- Deleted unique code in favor of GETMTOP/GZMTOP, deleted	;
  28:			;		ZFPARS subroutine for calls to ZPRSFN.	24 Mar 91, HFB	;
  29:			;	1.70- Added separate existence test for R/O files controlled by	;
  30:			;		new O switch.  R/O source files not erased by X option. ;
  31:			;		M option no longer restricts copy to one group of       ;
  32:			;		files.  Set attributes call only done when absolutely   ;
  33:			;		necessary for speed improvement.  Disk reset done for	;
  34:			;		all DOS's to ensure proper operation under DOSDISK or	;
  35:			;		SPEEDUP RSX.  Initialization improved; CRASHES UNDER	;
  36:			;		vanilla CCP fixed.  Top of memory calculation uses	;
  37:			;		extended environment if available.  Date comparisons	;
  38:			;		now done on all systems that support stamping, not just	;
  39:			;		ZSDOS.  Bug affecting ZRDOS Public restoration fixed.	;
  40:			;		Unnecessary external declarations removed.		;
  41:			;							1-9 Mar 91, HG	;
  42:			;	1.64- Changed local stack calculations		23 Jul 89, HFB	;
  43:			;	1.63- Corrected operation w/"vanilla" CP/M	16 Jul 89, HFB	;
  44:			;	1.62- Fixed not restoring entry DU w/o ZCPR3	 7 Jun 89, HFB	;
  45:			;	1.61- Fixed error in Help Name printout		 3 Jun 89, HFB	;
  46:			;	1.6 - Modified to operate without ZCPR3, maximum use of Vers 4	;
  47:			;		libraries, auto-search for COPY.CFG.	26 May 89, HFB	;
  48:			;	1.5 - Fixed obscure bug in buffer calcs, added Jay Sage's patch ;
  49:			;		to allow COPY DIR:FN.FT to copy to default DIR: rather	;
  50:			;		than BACKUP:, Added logic to inhibit /X if /M active.	;
  51:			;						  12 Mar-2 Apr 89, CWC  ;
  52:			;	1.4 - Corrected glitch in date comparisons	11 Dec 88, HFB	;
  53:			;	1.3 - Unlinked 'E' disable from 'R' and 'A', corrected lack of	;
  54:			;		sensing 'R' and 'X', Fall back to Create if no Modify	;
  55:			;		date, and print "undated" if neither present, ignore	;
  56:			;		erase with X-option if Verify Error.   3-5 Dec 88, HFB	;
  57:			;	1.2 - Added 'R' (Replace) option, changed 'X' option to Erase	;
  58:			;		source after copy. Release version	 2 Dec 88, HFB	;
  59:			;	1.1a- Fix glitch on DS only operation, allow rename in same	;
  60:			;		user area with different name		25 Nov 88, HFB	;
  61:			;	1.1 - Formal release version			17 Nov 88, HFB	;
  62:			;	1.0a-e -  Bug fix in E & N Options, Added Archive, Fixed /M bug	;
  63:			;		w/test in mcpy28, Restored CRC bypass if not verifying,	;
  64:			;		corrected glitch if no space on dest, Added File Exclude;
  65:			;		list, File rename, Archive only if file exists, test	;
  66:			;		dates on each file, Add Source open time to Access field;
  67:			;						 25 Sep-15 Nov 88, HFB	;
  68:			;	1.0 - Initial Release				18 Sep 88	;
  69:			;=======================================================================;
  70:			
  71:				include darkstar.equ
**** darkstar.equ ****
   1:			;****** Equ's file autogenerated by genequs ver: 1.0
   2:			;****** Input files:
   3:			;****** SysCommon.lst
   4:	FDC4'         	FIN            	EQU	0FDC4H
   5:	FD89'         	DLY1           	EQU	0FD89H
   6:	FD87'         	DLY2           	EQU	0FD87H
   7:	FDE1'         	FOUT           	EQU	0FDE1H
   8:	FE70'         	U1NUL          	EQU	0FE70H
   9:	FE25'         	U0ISR          	EQU	0FE25H
  10:	FE59'         	U1ISR          	EQU	0FE59H
  11:	FD85'         	DELAY          	EQU	0FD85H
  12:	FE4E'         	UISRE          	EQU	0FE4EH
  13:	FDB5'         	FSTAT          	EQU	0FDB5H
  14:	FE32'         	UISRI          	EQU	0FE32H
  15:	FC4B'         	BBU1ST         	EQU	0FC4BH
  16:	FC45'         	BBU1RX         	EQU	0FC45H
  17:	FC3F'         	BBU1TX         	EQU	0FC3FH
  18:	FD29'         	BBEXEC         	EQU	0FD29H
  19:	FCFF'         	BBHDRD         	EQU	0FCFFH
  20:	FD6A'         	BBVOID         	EQU	0FD6AH
  21:	FE86'         	UASTKB         	EQU	0FE86H
  22:	FD6B'         	MMPMAP         	EQU	0FD6BH
  23:	FE0F'         	INTRDI         	EQU	0FE0FH
  24:	FC2D'         	SCONIN         	EQU	0FC2DH
  25:	FC15'         	VCONIN         	EQU	0FC15H
  26:	FCDB'         	BBDIV16        	EQU	0FCDBH
  27:	FCF9'         	BBHDWR         	EQU	0FCF9H
  28:	FD78'         	MMGETP         	EQU	0FD78H
  29:	FDFE'         	INTREN         	EQU	0FDFEH
  30:	FE79'         	RLDROM         	EQU	0FE79H
  31:	FCE1'         	BBMUL16        	EQU	0FCE1H
  32:	FC00'         	SYSCOM         	EQU	0FC00H
  33:	FE84'         	UASTAV         	EQU	0FE84H
  34:	FE19'         	SYTIMR         	EQU	0FE19H
  35:	FC33'         	SCONST         	EQU	0FC33H
  36:	FC1B'         	VCONST         	EQU	0FC1BH
  37:	FC39'         	BBU0INI        	EQU	0FC39H
  38:	FC51'         	BBU1INI        	EQU	0FC51H
  39:	FC87'         	BBFREAD        	EQU	0FC87H
  40:	FD23'         	BBEIDCK        	EQU	0FD23H
  41:	FD05'         	BBHDGEO        	EQU	0FD05H
  42:	FEB4'         	BBSTACK        	EQU	0FEB4H
  43:	FC81'         	BBFHOME        	EQU	0FC81H
  44:	FD94'         	BBCONIN        	EQU	0FD94H
  45:	FC27'         	CRDUREG        	EQU	0FC27H
  46:	FFF0'         	SINTVEC        	EQU	0FFF0H
  47:	FEB4'         	SYSCMLO        	EQU	0FEB4H
  48:	FE22'         	VOIDISR        	EQU	0FE22H
  49:	FC9F'         	BBSTTIM        	EQU	0FC9FH
  50:	FDAA'         	BBCONST        	EQU	0FDAAH
  51:	FC27'         	SCONOUT        	EQU	0FC27H
  52:	FC0F'         	VCONOUT        	EQU	0FC0FH
  53:	FCE7'         	BBOFFCAL       	EQU	0FCE7H
  54:	FC57'         	BBINICTC       	EQU	0FC57H
  55:	FE90'         	BBSTBASE       	EQU	0FE90H
  56:	FC5D'         	BBRESCTC       	EQU	0FC5DH
  57:	FCA5'         	BBRDTIME       	EQU	0FCA5H
  58:	FD5A'         	BBCALRET       	EQU	0FD5AH
  59:	FCB7'         	BBDMASET       	EQU	0FCB7H
  60:	FC00'         	BBJTOBNK       	EQU	0FC00H
  61:	FCBD'         	BBDSKSEL       	EQU	0FCBDH
  62:	FCED'         	BBHDINIT       	EQU	0FCEDH
  63:	FCB1'         	BBSECSET       	EQU	0FCB1H
  64:	FD0B'         	BBHDBOOT       	EQU	0FD0BH
  65:	FC69'         	BBUPLCHR       	EQU	0FC69H
  66:	FC99'         	BBPRNCHR       	EQU	0FC99H
  67:	FCC9'         	BBVCPMBT       	EQU	0FCC9H
  68:	FC93'         	BBFLOPIO       	EQU	0FC93H
  69:	FD1D'         	BBEPMNGR       	EQU	0FD1DH
  70:	FCCF'         	BBSIDSET       	EQU	0FCCFH
  71:	FD11'         	BBLDPART       	EQU	0FD11H
  72:	FC75'         	BBRDVDSK       	EQU	0FC75H
  73:	FC8D'         	BBFWRITE       	EQU	0FC8DH
  74:	FCC3'         	BBCPBOOT       	EQU	0FCC3H
  75:	FC21'         	BBCURSET       	EQU	0FC21H
  76:	FCAB'         	BBTRKSET       	EQU	0FCABH
  77:	FC7B'         	BBWRVDSK       	EQU	0FC7BH
  78:	FD9F'         	BBCONOUT       	EQU	0FD9FH
  79:	FCF3'         	BBDRIVEID      	EQU	0FCF3H
  80:	FC63'         	BBPSNDBLK      	EQU	0FC63H
  81:	FC03'         	BBCRTCINI      	EQU	0FC03H
  82:	FC6F'         	BBPRCVBLK      	EQU	0FC6FH
  83:	FC09'         	BBCRTFILL      	EQU	0FC09H
  84:	FCD5'         	BBFDRVSEL      	EQU	0FCD5H
  85:	FD17'         	BBDPRMSET      	EQU	0FD17H
  86:			;****** EOF ***
  87:			
**** copy.asm ****
  72:			
  73:	0011'         	VERS	EQU	17		; Initial Release
  74:	0032'         	rev	equ	'2'		; Bug fix revision
  75:			DATE	  MACRO
  76:				DEFB	'17 Jul 93'	; Prompt Date for easy access
  77:				  ENDM
  78:			CDATE	  MACRO
  79:				DEFB	'18 Oct 14'	; Custom Prompt Date
  80:				  ENDM
  81:	000B'         	CVERS	EQU	11
  82:			
  83:			; SPECIAL Constants
  84:			
  85:	00C0'         	PLIM	EQU	4*48		; Size of buffer in pages (4 * nk)
  86:							;	[may be changed]
  87:	0010'         	FNSIZE	EQU	16		; Number of bytes in basic Nam.Typ fields
  88:	001F'         	ESIZE	EQU	FNSIZE+15	; Number of bytes/entry + Date Stamps
  89:			
  90:			; CP/M Constants
  91:			
  92:	0000'         	WB	EQU	0		; CP/M warm boot
  93:	0005'         	BDOSE	EQU	WB+5		; Bdos entry point
  94:	005C'         	FCB	EQU	WB+5CH		; Specified FCB
  95:	0080'         	BUFF	EQU	WB+80H		; Default buffer and input line
  96:			
  97:			; DOS Functions Used
  98:			
  99:	001A'         	SDMA	EQU	26		; Dos Command to set DMA transfer addr
 100:	0011'         	SRCHF	EQU	17		; Dos Command to Search for First file match
 101:	0012'         	SRCHN	EQU	18		; Dos Command to Search for Next file match
 102:			
 103:			; ASCII Constants, et al
 104:			
 105:	00FF'         	ON	EQU	0FFH		; On code
 106:	0000'         	OFF	EQU	0		; Off code
 107:	000D'         	CR	EQU	0DH		; <cr>
 108:	000A'         	LF	EQU	0AH		; <lf>
 109:	0009'         	TAB	EQU	09H		; Horizontal tab
 110:	0003'         	CTRLC	EQU	'C'-'@'		; ^c
 111:	002F'         	OPTC	EQU	'/'		; Option delimiter
 112:	0000'         	OPTS	EQU	0000H		; Skippable option table value
 113:			
 114:			; Library Routines used in this Program
 115:			
 116:				EXT	RETUD, LOGUD, PUTUD, GETUD, GETMTOP, INITFCB	; Syslib
 117:				EXT	F$EXIST, SETDMA, BDOS, CIN, COUT, CONDIN, CRLF	;   "
 118:				EXT	MOVEB, EPRINT, EPSTR, PFN1, F$DELETE, F$OPEN	;   "
 119:				EXT	F$MAKE, F$CLOSE, F$READ, F$WRITE, PAFDC, CAPS	;   "
 120:				EXT	CRC3INIT, CRC3CLR, CRC3UPD, CRC3DONE, CODEND	;   "
 121:				EXT	DIRMAX, DIRBUF, DPARAMS, @FNCMP, SORT, SSBINIT	;(DDIRQ)
 122:			
 123:				EXT	Z3INIT, ZPRSFN, GETQUIET, GETEFCB		; Z3Lib
 124:				EXT	GETMSG, PUTER2, STOPZEX, WHRENV			;   "
 125:				EXT	DIRTDU, DUNDR, GZMTOP				;   "
 126:			
 127:				EXT	GSTAMP, PSTAMP, TIMINI, DOSTYP, TIMTYP, RCLOCK	; Dslib
 128:				EXT	FINDCK, CKTDF, OPENTD, RWTD, CLOSTD, FSTNXT	;(DDIRQ)
 129:				EXT	P2UTIM, M2UTIM, BIN2BCD				;(DDIRQ)
 130:			
 131:			;------------------------------------------------------------------
 132:			; External ZCPR3 Environment Descriptor
 133:			
 134:	0000' C38300  		JP	START
 135:			
 136:	0003' 5A33454E		DEFB	'Z3ENV'		; This is a ZCPR3 utility
	      56
 137:	0008' 01      		DEFB	1		; External environment descriptor
 138:	0009' 0100    	Z3EADR:	DEFW	0001		; Dummy value to force WHRENV search
 139:			
 140:			; This section aligns to locations needed for ZCNFG auto-search for
 141:			; configuration file name.  It is aligned to Type-4 header values.
 142:			
 143:	000B' 0000    		DEFW	0000		; Filler for ZCNFG file name offset
 144:	000D' 434F5059		DEFB	'COPY    ',0	; Search for COPY.CFG
	      20202020
	      00
 145:			
 146:			; User-Definable Initial Flag Conditions
 147:			;  The default conditions for MCOPY may be readily patched by the user
 148:			;  via DDT for his desired default values
 149:			
 150:	0016'         	DEFTBL:
 151:	0016' FF      	DVERFLG: DEFB	ON		; Set verify
 152:	0017' 00      	DINSP:	 DEFB	OFF		; Set no inspect
 153:	0018' 00      	DSYSEXC: DEFB	OFF		; Set no $SYS file exclusion by default
 154:	0019' 00      	DNCOPY:	 DEFB	OFF		; Set no multiple copies by default
 155:	001A' FF      	DEXIST:	 DEFB	ON		; Existence testing on
 156:	001B' FF      	DEXTRO	 DEFB	ON		; Existence testing, R/O files, on
 157:	001C' 00      	DARCHV:	 DEFB	OFF		; Do not operate in Archive mode
 158:	001D' 00      	DREPL:	 DEFB	OFF		; Do Not restrict copy to Existing files
 159:			;---- All above entries copied to CPYTBL
 160:	001E' 00      	TYPDAT:	 DEFB	OFF		; Type of stamps to select in Source
 161:							; OFF = P2D/DosDisk, ON = DateStamper
 162:	001F' 00      	USEDDU:	 DEFB	OFF		; If on, default DU: given in next 3 fields
 163:	0020' 00      	DDUSER:	 DEFB	0		; Default destination user is 0
 164:	0021' 01      	DDDISK:	 DEFB	'B'-'A'		; Default destination disk is B
 165:	0022' 4241434B	BACKDIR: DEFB	'BACKUP  '	; Name of backup directory
	      55502020
 166:	002A' 21213F3F	EXCLUD:	 DEFB	'!!?????????'	; 8-name File Exclusion list
	      3F3F3F3F
	      3F3F3F
 167:	0035' 5B3F3F3F		 DEFB	'[??????]???'
	      3F3F3F5D
	      3F3F3F
 168:	0040' 3F3F3F3F		 DEFB	'????????$?$'
	      3F3F3F3F
	      243F24
 169:	004B' 20202020		 DEFB	'           '
	      20202020
	      202020
 170:	0056' 20202020		 DEFB	'           '
	      20202020
	      202020
 171:	0061' 20202020		 DEFB	'           '
	      20202020
	      202020
 172:	006C' 20202020		 DEFB	'           '
	      20202020
	      202020
 173:	0077' 20202020		 DEFB	'           '
	      20202020
	      202020
 174:	0082' 00      		 DEFB	0		; List terminator
 175:			
 176:			; Beginning of COPY Program
 177:			
 178:	0083'         	START:
 179:							; Set up Dynamic (whew!) Buffers
 180:	0083' ED73A900		LD	(STACK),SP	; Save incoming stack pointer
 181:	0087' 31A900  		LD	SP,STACK	; ..and set a local stack
 182:	008A' 211500  		LD	HL,DATABG	; Set program data area to 0
 183:	008D' 111600  		LD	DE,DATABG+1
 184:	0090' 019300  		LD	BC,STACK-DATABG-1
 185:	0093' 3600    		LD	(HL),0
 186:	0095' EDB0    		LDIR
 187:	0097' CD0000  		CALL	CODEND		; Determine free space
 188:	009A' CD0000  		CALL	CRC3INIT	; Create CRC table
 189:	009D' 24      		INC	H		; Allow 2 pages for CRC table
 190:	009E' 24      		INC	H
 191:	009F' 226300  		LD	(INLINE),HL	; Ptr to input line
 192:	00A2' 2E80    		LD	L,128
 193:	00A4' 222A00  		LD	(FCBS),HL	; Ptr to source FCB
 194:	00A7' 2EA4    		LD	L,128+36
 195:	00A9' 222C00  		LD	(FCBD),HL	; Ptr to dest FCB
 196:	00AC' 24      		INC	H
 197:	00AD' 2E00    		LD	L,0
 198:	00AF' 226500  		LD	(FREEBUF),HL	; Free space buffer
 199:			
 200:	00B2' CD0000  		CALL	EPRINT		; Print Banner
 201:	00B5' 434F5059		DEFB	'COPY  Version '
	      20205665
	      7273696F
	      6E20
 202:	00C3' 312E3732		DEFB	VERS/10+'0','.',VERS MOD 10 + '0',rev,' '
	      20
 203:	00C8'         		DATE
 204:	00D1' 00      		DEFB	0
 205:	00D2' CD0000  		CALL	EPRINT		; Print Custom Banner
 206:	00D5' 0D0A5A38		DEFB	CR,LF,'Z80DS Custom version '
	      30445320
	      43757374
	      6F6D2076
	      65727369
	      6F6E20
 207:	00EC' 312E31  		DEFB	CVERS/10+'0','.',CVERS MOD 10 + '0'
 208:	00EF' 20627920		DEFB	' by P.Betti '
	      502E4265
	      74746920
 209:	00FB'         		CDATE
 210:	0104' 00      		DEFB	0
 211:			
 212:	0105' 2A0900  		LD	HL,(Z3EADR)	; Get candidate ZCPR3 environment
 213:	0108' CD0000  		CALL	WHRENV
 214:	010B' 220900  		LD	(Z3EADR),HL	; ..and store validated ENV addr
 215:	010E' CD0000  		CALL	Z3INIT		; Initialize the ZCPR3 ENV and Z3LIB vectors
 216:	0111' CD0000  		CALL	TIMINI		; Initialize the Dos & Time System
 217:	0114' 3A0A00  		LD	A,(Z3EADR+1)	; Do we have a valid ENV?
 218:	0117' B7      		OR	A		;  (Page must be Non-Zero if valid)
 219:	0118' 2006    		JR	NZ,MSGS		; Have ENV, go do msg stuff
 220:	011A' 3D      		DEC	A
 221:	011B' 323300  		LD	(NOMSGS),A	; No env means no msg buffer
 222:	011E' 1819    		JR	SDFLGS
 223:			
 224:	0120' CD0000  	MSGS:	CALL	STOPZEX		; Prevent ZEX input
 225:			
 226:	0123' CD0000  		CALL	GETQUIET	; Get ZCPR3 quiet flag
 227:	0126' 323800  		LD	(QUIET),A	; ..and set local flag
 228:			
 229:	0129' CD0000  		CALL	GETMSG		; See if there is a message buffer
 230:	012C' 2007    		JR	NZ,HAVMSGS
 231:	012E' 3EFF    		LD	A,0FFH		; No message buffer - set indicator
 232:	0130' 323300  		LD	(NOMSGS),A
 233:	0133' 1804    		JR	SDFLGS
 234:			
 235:	0135' AF      	HAVMSGS: XOR	A		; There is a message buffer - clear
 236:	0136' CD0000  		CALL	PUTER2		; the error flag
 237:			
 238:			; Set Default Flags
 239:			
 240:	0139' 211600  	SDFLGS:	LD	HL,DEFTBL	; Copy default options to mem.
 241:	013C' 111B00  		LD	DE,CPYTBL
 242:	013F' 0608    		LD	B,TBLLEN
 243:	0141' CD0000  		CALL	MOVEB
 244:			
 245:			; Check for Backup Directory and establish it as default
 246:			;  If No Backup Directory or No ZCPR3, select default stored
 247:			
 248:	0144' CD0000  		CALL	RETUD		; Set Current DU in BC just in case
 249:	0147' 78      		LD	A,B		; Save disk
 250:	0148' 322300  		LD	(CDISK),A
 251:	014B' 3A1F00  		LD	A,(USEDDU)	; Fixed default for DU:?
 252:	014E' A7      		AND	A
 253:	014F' 2812    		JR	Z,DEFBAK	; ..jump if not and set current dest
 254:			
 255:	0151' 3A0A00  	DEFBK0:	LD	A,(Z3EADR+1)	; Any valid ENV?
 256:	0154' B7      		OR	A
 257:	0155' 2808    		JR	Z,DEFBK1	; ..get stored default if not
 258:	0157' 212200  		LD	HL,BACKDIR	; Pt to directory name
 259:	015A' CD0000  		CALL	DIRTDU		; Does it exist?
 260:	015D' 2004    		JR	NZ,DEFBAK	; ..jump if found and select
 261:	015F' ED4B2000	DEFBK1:	LD	BC,(DDUSER)	; Otherwise use default DU
 262:	0163' ED432600	DEFBAK:	LD	(DUSER),BC
 263:			
 264:	0167' CD0000  		CALL	PUTUD		; Save current Drive/User position
 265:	016A' ED5B6300		LD	DE,(INLINE)	; Input line save buffer
 266:	016E' 218100  		LD	HL,BUFF+1	; Pt to command line characters
 267:	0171' 067F    		LD	B,127		; Save 127 bytes (arbitrary)
 268:	0173' CD0000  		CALL	MOVEB
 269:	0176' EB      		EX	DE,HL		; Hl pts to input line
 270:			
 271:			; Set other flags (always defaults to "off")
 272:			
 273:	0177' AF      		XOR	A		; A=0
 274:	0178' 323900  		LD	(NOREPL),A	; Turn off "no copy if exists" option
 275:	017B' 323700  		LD	(XMOVE),A	; ..and "remove source after copy"
 276:			
 277:			; Check for empty Command Line and process Command Mode if so
 278:			; On Entry, HL pts to first char of string from CLINE
 279:			
 280:	017E' 7E      	START1:	LD	A,(HL)		; Get char
 281:	017F' B7      		OR	A		; Eol?
 282:	0180' CA3902  		JP	Z,MHELP		; Print help message if no input
 283:	0183' 23      		INC	HL		; Pt to next
 284:	0184' FE20    		CP	' '		; Just spaces?
 285:	0186' 28F6    		JR	Z,START1
 286:			
 287:			; Command Line was Not Empty -- Check for HELP request
 288:			
 289:	0188' 2B      		DEC	HL		; Pt to first char
 290:	0189' FE2F    		CP	OPTC		; If opening option, must be help
 291:	018B' CA3902  		JP	Z,MHELP
 292:			
 293:			; See if Options are available in the Command Line
 294:			
 295:	018E' 221500  		LD	(MFPTR),HL	; Set ptr to first char of file name specs
 296:							; ..Skip to end of File Name Specs
 297:	0191' 3A8000  		LD	A,(BUFF)	; Tail char. count
 298:	0194' 4F      		LD	C,A		; To C
 299:	0195' AF      		XOR	A		; Search for terminating null
 300:	0196' 47      		LD	B,A		; BC now has count
 301:	0197' EDB1    		CPIR			; Search..
 302:	0199' C23902  		JP	NZ,MHELP	; Not found, something screwy
 303:	019C' 2B      		DEC	HL		; Get last real char.
 304:	019D' 2B      		DEC	HL
 305:	019E' 7E      		LD	A,(HL)
 306:	019F' FE3A    		CP	':'		; Was it a dest. DU:/DIR: ?
 307:	01A1' 281E    		JR	Z,OVRIDE	; If so, non-option
 308:	01A3' 3E20    		LD	A,' '		; Search back for next blank
 309:	01A5' 0E0C    		LD	C,OPTLEN+1	; Range in (B)C
 310:	01A7' EDB9    		CPDR			; Search..
 311:	01A9' 2016    		JR	NZ,OVRIDE	; Not found, too long for option
 312:	01AB' 23      		INC	HL		; Bump point to potential option
 313:	01AC' 23      		INC	HL
 314:	01AD' CD8C0C  		CALL	OPTQ		; Test it thoroughly
 315:	01B0' 200F    		JR	NZ,OVRIDE	; Treat as option if Z returned
 316:			
 317:			; Scan for Option
 318:			
 319:	01B2' 7E      	OPTION:	LD	A,(HL)		; Get option char
 320:	01B3' B7      		OR	A		; Eol?
 321:	01B4' 280B    		JR	Z,OVRIDE	; Do mcopy
 322:	01B6' 23      		INC	HL		; Pt to next
 323:	01B7' E5      		PUSH	HL		; Save ptr
 324:	01B8' 21F601  		LD	HL,OPTTAB	; Pt to option table
 325:	01BB' CDDE01  		CALL	CMDER		; Process command
 326:	01BE' E1      		POP	HL		; Get ptr
 327:	01BF' 18F1    		JR	OPTION
 328:			
 329:			; Since the no replace mode is incompatible with the exist test
 330:			; mode, if norepl flag is on turn exist off
 331:			
 332:	01C1' 3A2100  	OVRIDE:	LD	A,(ARCHIV)	; Is this an Archive opn?
 333:	01C4' B7      		OR	A
 334:	01C5' 2006    		JR	NZ,OVRID1	; ..Supercede other ops if so
 335:	01C7' 3A2200  		LD	A,(REPLAC)	; Is this copy if Exist?
 336:	01CA' B7      		OR	A
 337:	01CB' 2804    		JR	Z,MCOP0V	; ..jump if not
 338:	01CD' AF      	OVRID1:	XOR	A
 339:	01CE' 323900  		LD	(NOREPL),A	; ..and No Replace is off
 340:	01D1' 3A1E00  	MCOP0V:	LD	A,(NCOPY)
 341:	01D4' B7      		OR	A
 342:	01D5' 2804    		JR	Z,OVRID2	; Test for multiple copy
 343:	01D7' AF      		XOR	A
 344:	01D8' 323700  		LD	(XMOVE),A	; clear source delete if multiple
 345:	01DB' C3F804  	OVRID2:	JP	MCOPY0
 346:			
 347:			; Command Processor -- Command letter in A, HL pts to Table
 348:			
 349:	01DE' 47      	CMDER:	LD	B,A		; Command in b
 350:	01DF' 7E      	CMDER1:	LD	A,(HL)		; Get command letter
 351:	01E0' B7      		OR	A		; Done?
 352:	01E1' 2838    		JR	Z,OHELP
 353:	01E3' B8      		CP	B		; Match?
 354:	01E4' 23      		INC	HL		; Pt to address
 355:	01E5' 200B    		JR	NZ,CMDER3
 356:	01E7' 5E      		LD	E,(HL)		; Get it in DE
 357:	01E8' 23      		INC	HL
 358:	01E9' 56      		LD	D,(HL)
 359:	01EA' EB      		EX	DE,HL		; HL pts to command address
 360:	01EB' 7D      		LD	A,L
 361:	01EC' B4      		OR	H		; Test for OPTS
 362:	01ED' C8      		RET	Z		; Return w/no action if so
 363:	01EE' 7E      		LD	A,(HL)		; Otherwise get option byte
 364:	01EF' 2F      		CPL			; Flip it
 365:	01F0' 77      		LD	(HL),A		; Put it back
 366:	01F1' C9      		RET
 367:			
 368:	01F2' 23      	CMDER3:	INC	HL		; Skip to next entry in table
 369:	01F3' 23      		INC	HL
 370:	01F4' 18E9    		JR	CMDER1
 371:			
 372:			; Option Command Table
 373:			
 374:	01F6' 20      	OPTTAB:	DEFB	' '		; Skip blanks
 375:	01F7' 0000    		DEFW	OPTS
 376:	01F9' 41      		DEFB	'A'		; Archive mode
 377:	01FA' 2100    		DEFW	ARCHIV
 378:	01FC' 45      		DEFB	'E'		; Exist test
 379:	01FD' 1F00    		DEFW	EXIST
 380:	01FF' 49      		DEFB	'I'		; Inspect
 381:	0200' 1C00    		DEFW	INSP
 382:	0202' 4D      		DEFB	'M'		; Multiple copy
 383:	0203' 1E00    		DEFW	NCOPY
 384:	0205' 4E      		DEFB	'N'		; No copy if file already on dest.
 385:	0206' 3900    		DEFW	NOREPL
 386:	0208' 51      		DEFB	'Q'		; Quiet
 387:	0209' 3800    		DEFW	QUIET
 388:	020B' 53      		DEFB	'S'		; System Exclude
 389:	020C' 1D00    		DEFW	SYSEXC
 390:	020E' 56      		DEFB	'V'		; Verify
 391:	020F' 1B00    		DEFW	VERFLG
 392:	0211' 58      		DEFB	'X'		; Remove Source after copy
 393:	0212' 3700    		DEFW	XMOVE
 394:	0214' 52      		DEFB	'R'		; Copy ONLY if Dest. Exists
 395:	0215' 2200    		DEFW	REPLAC
 396:	0217' 4F      		DEFB	'O'		; Existence test for R/O files
 397:	0218' 2000    		DEFW	EXRO
 398:	021A' 00      		DEFB	0		; End of table
 399:			
 400:			; Invalid Option Char --  Adjust Stack and Print Help
 401:			
 402:	021B' 3A3800  	OHELP:	LD	A,(QUIET)
 403:	021E' B7      		OR	A
 404:	021F' 3E07    		LD	A,7
 405:	0221' CC0000  		CALL	Z,COUT		; Beep if not muzzled
 406:	0224' CD0000  		CALL	EPRINT
 407:	0227' 0D0A4F70		DEFB	CR,LF,'Option error!',CR,LF,0
	      74696F6E
	      20657272
	      6F72210D
	      0A00
 408:			
 409:			; Print Help Message  (NOTE: DUSER set correctly by the time we get here)
 410:			
 411:	0239' CD0000  	MHELP:	CALL	EPRINT
 412:	023C' 0D0A5379		DEFB	CR,LF,'Syntax:'
	      6E746178
	      3A
 413:	0245' 0D0A2020		DEFB	CR,LF,'  ',0
	      00
 414:	024A' CD5C0C  		CALL	COMNAM		; "COPY" or EFCB name
 415:	024D' CD0000  		CALL	EPRINT
 416:	0250' 20646972		DEFB	' dir:[filename.typ]=[dir:]filename.typ,... [/]o...'
	      3A5B6669
	      6C656E61
	      6D652E74
	      79705D3D
	      5B646972
	      3A5D6669
	      6C656E61
	      6D652E74
	      79702C2E
	      2E2E205B
	      2F5D6F2E
	      2E2E
 417:	0282' 0D0A0909		DEFB	CR,LF,TAB,TAB,'(or)'
	      286F7229
 418:	028A' 0D0A2020		DEFB	CR,LF,'  ',0
	      00
 419:	028F' CD5C0C  		CALL	COMNAM		; "COPY" or EFCB name
 420:	0292' CD0000  		CALL	EPRINT
 421:	0295' 205B6469		DEFB	' [dir:]filename.typ dir:[filename.typ],... [/]o...'
	      723A5D66
	      696C656E
	      616D652E
	      74797020
	      6469723A
	      5B66696C
	      656E616D
	      652E7479
	      705D2C2E
	      2E2E205B
	      2F5D6F2E
	      2E2E
 422:	02C7' 0D0A0909		DEFB	CR,LF,TAB,TAB,'(or)'
	      286F7229
 423:	02CF' 0D0A2020		DEFB	CR,LF,'  ',0
	      00
 424:	02D4' CD5C0C  		CALL	COMNAM		; "COPY" or EFCB name
 425:	02D7' CD0000  		CALL	EPRINT
 426:	02DA' 205B6469		DEFB	' [dir:]filename.typ,... /o...'
	      723A5D66
	      696C656E
	      616D652E
	      7479702C
	      2E2E2E20
	      2F6F2E2E
	      2E
 427:	02F7' 0D0A0928		DEFB	CR,LF,TAB,'(Copies to ',0
	      436F7069
	      65732074
	      6F2000
 428:			
 429:	0306' ED4B2600		LD	BC,(DUSER)	; get default destination DU:
 430:	030A' CD4D0C  		CALL	PRNDU		; ..print it
 431:	030D' 04      		INC	B		; make drive one based for this
 432:	030E' 3A0A00  		LD	A,(Z3EADR+1)	; Do we have a valid ENV?
 433:	0311' B7      		OR	A
 434:	0312' C40000  		CALL	NZ,DUNDR	; Check for NDR for this one if ENV Ok
 435:	0315' 2804    		JR	Z,GOTBAK	; ..jump if no ENV or Name
 436:	0317' 23      		INC	HL		; point to name
 437:	0318' CD650C  		CALL	PRNNAM		; ..and print up to 8 chars
 438:			
 439:	031B' CD0000  	GOTBAK:	CALL	EPRINT
 440:	031E' 29      		DEFB	')'
 441:	031F' 0D0A4F70		DEFB	CR,LF,'Options:'
	      74696F6E
	      733A
 442:	0329' 0D0A2020		DEFB	CR,LF,'  A -- ',0  ; Copy only Non-Archive?
	      41202D2D
	      2000
 443:	0333' 3A2100  		LD	A,(ARCHIV)
 444:	0336' B7      		OR	A
 445:	0337' C4F004  		CALL	NZ,SAYNO	; ..FF is No copy if archived
 446:	033A' CD0000  		CALL	EPRINT
 447:	033D' 41726368		DEFB	'Archive Bit Control'
	      69766520
	      42697420
	      436F6E74
	      726F6C
 448:	0350' 0D0A2020		DEFB	CR,LF,'  E -- ',0
	      45202D2D
	      2000
 449:	035A' 3A1F00  		LD	A,(EXIST)
 450:	035D' B7      		OR	A
 451:	035E' C4F004  		CALL	NZ,SAYNO
 452:	0361' CD0000  		CALL	EPRINT
 453:	0364' 45786973		DEFB	'Existence Test'
	      74656E63
	      65205465
	      7374
 454:	0372' 0D0A2020		DEFB	CR,LF,'  I -- ',0
	      49202D2D
	      2000
 455:	037C' 3A1C00  		LD	A,(INSP)
 456:	037F' B7      		OR	A
 457:	0380' C4F004  		CALL	NZ,SAYNO
 458:	0383' CD0000  		CALL	EPRINT
 459:	0386' 496E7370		DEFB	'Inspect Files'
	      65637420
	      46696C65
	      73
 460:	0393' 0D0A2020		DEFB	CR,LF,'  M -- ',0
	      4D202D2D
	      2000
 461:	039D' 3A1E00  		LD	A,(NCOPY)
 462:	03A0' B7      		OR	A
 463:	03A1' C4F004  		CALL	NZ,SAYNO
 464:	03A4' CD0000  		CALL	EPRINT
 465:	03A7' 4D756C74		DEFB	'Multiple Copy'
	      69706C65
	      20436F70
	      79
 466:	03B4' 0D0A2020		DEFB	CR,LF,'  N -- NO Copy if Destination Exists'
	      4E202D2D
	      204E4F20
	      436F7079
	      20696620
	      44657374
	      696E6174
	      696F6E20
	      45786973
	      7473
 467:	03DA' 0D0A2020		DEFB	CR,LF,'  O -- ',0
	      4F202D2D
	      2000
 468:	03E4' 3A2000  		LD	A,(EXRO)
 469:	03E7' B7      		OR	A
 470:	03E8' C4F004  		CALL	NZ,SAYNO
 471:	03EB' CD0000  		CALL	EPRINT
 472:	03EE' 45786973		DEFB	'Existence test - R/O files'
	      74656E63
	      65207465
	      7374202D
	      20522F4F
	      2066696C
	      6573
 473:	0408' 0D0A2020		DEFB	CR,LF,'  Q -- ',0
	      51202D2D
	      2000
 474:	0412' 3A3800  		LD	A,(QUIET)
 475:	0415' B7      		OR	A
 476:	0416' C4F004  		CALL	NZ,SAYNO
 477:	0419' CD0000  		CALL	EPRINT
 478:	041C' 51756965		DEFB	'Quiet'
	      74
 479:	0421' 0D0A2020		DEFB	CR,LF,'  R -- ',0
	      52202D2D
	      2000
 480:	042B' 3A1D00  		LD	A,(DREPL)
 481:	042E' B7      		OR	A
 482:	042F' C4F004  		CALL	NZ,SAYNO
 483:	0432' CD0000  		CALL	EPRINT
 484:	0435' 5265706C		DEFB	'Replace Only Files existing'
	      61636520
	      4F6E6C79
	      2046696C
	      65732065
	      78697374
	      696E67
 485:	0450' 0D0A2020		DEFB	CR,LF,'  S -- ',0
	      53202D2D
	      2000
 486:	045A' 3A1D00  		LD	A,(SYSEXC)
 487:	045D' B7      		OR	A
 488:	045E' C4F004  		CALL	NZ,SAYNO
 489:	0461' CD0000  		CALL	EPRINT
 490:	0464' 53797374		DEFB	'System Files excluded'
	      656D2046
	      696C6573
	      20657863
	      6C756465
	      64
 491:	0479' 0D0A2020		DEFB	CR,LF,'  V -- ',0
	      56202D2D
	      2000
 492:	0483' 3A1B00  		LD	A,(VERFLG)
 493:	0486' B7      		OR	A
 494:	0487' C4F004  		CALL	NZ,SAYNO
 495:	048A' CD0000  		CALL	EPRINT
 496:	048D' 56657269		DEFB	'Verify'
	      6679
 497:	0493' 0D0A2020		DEFB	CR,LF,'  X -- Delete Source After Copy',CR,LF
	      58202D2D
	      2044656C
	      65746520
	      536F7572
	      63652041
	      66746572
	      20436F70
	      790D0A
 498:	04B6' 0A4E4F54		DEFB	LF,'NOTES: "R" and/or "A" turns off "N", "M" turns off "X"',0
	      45533A20
	      22522220
	      616E642F
	      6F722022
	      41222074
	      75726E73
	      206F6666
	      20224E22
	      2C20224D
	      22207475
	      726E7320
	      6F666620
	      22582200
 499:	04EE' 183A    		JR	RETSYS		; Return to Command Processor
 500:			
 501:	04F0' CD0000  	SAYNO:	CALL	EPRINT
 502:	04F3' 4E4F2000		DEFB	'NO ',0
 503:	04F7' C9      		RET
 504:			
 505:			; **** MCOPY of COMMAND LINE ****
 506:			
 507:	04F8' 31A900  	MCOPY0:	LD	SP,STACK	; Reset the Stack
 508:	04FB' 3A0000  		LD	A,(DOSTYP)	; Check Dos type
 509:	04FE' D652    		SUB	'R'		; Is it ZRDOS?
 510:	0500' 2010    		JR	NZ,NOTZRD	; ..jump if not
 511:	0502' 2A0900  		LD	HL,(Z3EADR)
 512:	0505' 117E00  		LD	DE,07EH
 513:	0508' 19      		ADD	HL,DE		; Point HL at PUBLIC bytes
 514:	0509' 5E      		LD	E,(HL)		; Get first PUBLIC byte in E
 515:	050A' 77      		LD	(HL),A		; Replace with a zero
 516:	050B' 23      		INC	HL		; Point to second byte
 517:	050C' 56      		LD	D,(HL)		; Get into D
 518:	050D' 77      		LD	(HL),A		; Replace with a zero
 519:	050E' ED536700		LD	(PUBS),DE	; Save for exit
 520:			
 521:	0512' CD2F05  	NOTZRD:	CALL	COPY		; Do the copy
 522:	0515' ED5B6700	CPM:	LD	DE,(PUBS)
 523:	0519' 7B      		LD	A,E
 524:	051A' B2      		OR	D
 525:	051B' 280A    		JR	Z,NOPUB
 526:	051D' 2A0900  		LD	HL,(Z3EADR)
 527:	0520' 017E00  		LD	BC,07EH
 528:	0523' 09      		ADD	HL,BC
 529:	0524' 73      		LD	(HL),E
 530:	0525' 23      		INC	HL
 531:	0526' 72      		LD	(HL),D
 532:	0527' CD0000  	NOPUB:	CALL	GETUD		; Restore the entry DU condition
 533:	052A' ED7BA900	RETSYS:	LD	SP,(STACK)	; Reset stack
 534:	052E' C9      		RET			; Return to opsys
 535:			
 536:			; **** Begin Multiple Copy Procedure ****
 537:			
 538:	052F' 3A1E00  	COPY:	LD	A,(NCOPY)	; Are we doing multiple copies?
 539:	0532' B7      		OR	A
 540:	0533' 2833    		JR	Z,NOPAUS	; ..jump if not
 541:	0535' CD0000  		CALL	EPRINT
 542:	0538' 0D0A202E		DEFB	CR,LF,' ...Any key starts copy, ^C Quits - ',0
	      2E2E416E
	      79206B65
	      79207374
	      61727473
	      20636F70
	      792C205E
	      43205175
	      69747320
	      2D2000
 543:	055F' CDC80B  		CALL	GETCH		; Get response in Uppercase
 544:	0562' CD0000  		CALL	CRLF		; Go to New Line
 545:	0565' FE03    		CP	CTRLC		; Is it an abort request (^c)?
 546:	0567' C8      		RET	Z		; ..exit here if so
 547:	0568' 2A1500  	NOPAUS:	LD	HL,(MFPTR)	; Pt to first file name
 548:	056B' 221700  		LD	(NXTPTR),HL	; Set ptr to next file name
 549:	056E' AF      		XOR	A		; A=0
 550:	056F' 323000  		LD	(VERCNT),A	; Zero error count
 551:	0572' 323400  		LD	(NORST),A	; Clear "no reset" flag
 552:			
 553:			; **** Main Copy Loop ****
 554:			
 555:	0575' 2A1700  	MCOPY:	LD	HL,(NXTPTR)	; Get ptr to next file name
 556:	0578' 7E      		LD	A,(HL)		; Get first char
 557:	0579' FE21    		CP	' '+1		; Done if <sp> or less
 558:	057B' 302B    		JR	NC,MCOPY1	; Continue with procedure
 559:			
 560:			; MCOPY of File Specs is now done
 561:			; Done with Copy Procedure -- Continue?
 562:			
 563:	057D' 3A1B00  	COPYT:	LD	A,(VERFLG)	; Verify?
 564:	0580' B7      		OR	A		; 0=no
 565:	0581' 281E    		JR	Z,COPYT1
 566:	0583' CD0000  		CALL	EPRINT		; New line & a blank
 567:	0586' 0D0A2000		DEFB	CR,LF,' ',0
 568:	058A' 3A5F00  		LD	A,(HAVFIL)	; Did we do anything?
 569:	058D' B7      		OR	A
 570:	058E' 2811    		JR	Z,COPYT1	; ..jump if not
 571:	0590' 3A3000  		LD	A,(VERCNT)	; Get error count
 572:	0593' CD0000  		CALL	PAFDC		; Print as decimal
 573:	0596' CD0000  		CALL	EPRINT
 574:	0599' 20457272		DEFB	' Errors',0
	      6F727300
 575:	05A1' 3A1E00  	COPYT1:	LD	A,(NCOPY)	; Multiple copies?
 576:	05A4' B7      		OR	A		; 0=no
 577:	05A5' C8      		RET	Z
 578:	05A6' 1887    		JR	COPY		; Copy again from the beginning
 579:			
 580:			; Begin Copy of File Group
 581:			
 582:	05A8' FE2C    	MCOPY1:	CP	','		; Skip comma separator if there
 583:	05AA' 2001    		JR	NZ,MCPY0
 584:	05AC' 23      		INC	HL		; Pt to char after comma
 585:	05AD' E5      	MCPY0:	PUSH	HL		; Preserve regs
 586:	05AE' 060B    		LD	B,11
 587:	05B0' 2A2C00  		LD	HL,(FCBD)	; Clear dest FileName
 588:	05B3' 23      		INC	HL
 589:	05B4' 3620    	INITLZ:	LD	(HL),' '
 590:	05B6' 23      		INC	HL
 591:	05B7' 10FB    		DJNZ	INITLZ		; ..loop til done
 592:	05B9' E1      		POP	HL		; Restore input pointer
 593:	05BA' 7E      		LD	A,(HL)		; Get next char
 594:	05BB' FE21    		CP	' '+1		; Check for error
 595:	05BD' DAC009  		JP	C,FORMERR
 596:	05C0' CD0000  		CALL	GETUD		; Return home
 597:	05C3' ED5B2A00		LD	DE,(FCBS)	; Pt to source FCB
 598:	05C7' AF      		XOR	A
 599:	05C8' CD0000  		CALL	ZPRSFN		; Extract file name data
 600:	05CB' CDAC09  		CALL	DUCVRT		; Convert DU into BC
 601:	05CE' 7E      		LD	A,(HL)		; Get delimiter
 602:	05CF' FE2C    		CP	','		; End of element?
 603:	05D1' 284C    		JR	Z,MCOPY2	; Form is dirs:fn.ft
 604:	05D3' FE3D    		CP	'='		; If '=', we have a new disk/user
 605:	05D5' 2822    		JR	Z,NEWDU
 606:	05D7' FE20    		CP	' '		; Test for reversed syntax
 607:	05D9' 2044    		JR	NZ,MCOPY2	; Nope, default b/u dest.
 608:	05DB' 23      		INC	HL		; Point to dest. DU:/DIR:
 609:	05DC' 7E      		LD	A,(HL)		; One more end-of-element test
 610:	05DD' FE2C    		CP	','
 611:	05DF' 283E    		JR	Z,MCOPY2
 612:	05E1' FE21    		CP	' '+1		; Invalid char. test
 613:	05E3' DAC009  		JP	C,FORMERR
 614:	05E6' C5      		PUSH	BC		; Save parsed DU in BC
 615:	05E7' ED5B2C00		LD	DE,(FCBD)	; Set Destination FCB
 616:	05EB' AF      		XOR	A
 617:	05EC' CD0000  		CALL	ZPRSFN		; Extract file name data
 618:	05EF' CDAC09  		CALL	DUCVRT		; Convert DU into BC
 619:	05F2' ED432600		LD	(DUSER),BC	; Poke as dest.
 620:	05F6' C1      		POP	BC		; Get back src. DU
 621:	05F7' 1826    		JR	MCOPY2		; and proceed..
 622:			
 623:			; Form is DIRD:=DIRS:FN.FT, So set Dest Disk/User
 624:			
 625:	05F9' ED432600	NEWDU:	LD	(DUSER),BC
 626:	05FD' E5      		PUSH	HL		; Preserve regs
 627:	05FE' C5      		PUSH	BC
 628:	05FF' ED5B2C00		LD	DE,(FCBD)	; ..and copy Source to dest
 629:	0603' 2A2A00  		LD	HL,(FCBS)
 630:	0606' 010C00  		LD	BC,12
 631:	0609' EDB0    		LDIR
 632:	060B' C1      		POP	BC		; Restore entry regs
 633:	060C' E1      		POP	HL
 634:			
 635:			; Now derive DIRS:FN.FT Form after the '='
 636:			
 637:	060D' 23      		INC	HL		; Pt to char beyond '='
 638:	060E' 7E      		LD	A,(HL)		; Get char
 639:	060F' FE21    		CP	' '+1		; Format error?
 640:	0611' DAC009  		JP	C,FORMERR
 641:	0614' ED5B2A00		LD	DE,(FCBS)	; Load FCB
 642:	0618' AF      		XOR	A
 643:	0619' CD0000  		CALL	ZPRSFN		; Get source name
 644:	061C' CDAC09  		CALL	DUCVRT		; Convert to DU in BC
 645:			
 646:			; Save ptr to next char after DIRS:FN.FT, and set source Disk/User
 647:			
 648:	061F' 221700  	MCOPY2:	LD	(NXTPTR),HL	; Save ptr to next char
 649:	0622' ED432400		LD	(SUSER),BC
 650:			
 651:	0626' 2A2C00  		LD	HL,(FCBD)	; Check for dest renaming
 652:	0629' 3E20    		LD	A,' '		; ..by looking for spaces
 653:	062B' CD7E0C  		CALL	SCAN11
 654:	062E' D60B    		SUB	11		; Sub no entry cnt fm space
 655:	0630' 326000  		LD	(RENFLG),A	; ..and save as flag
 656:	0633' 2814    		JR	Z,CKSAMU	; Jump if not renaming
 657:	0635' 2A2C00  		LD	HL,(FCBD)	; Check for ambiguous dest fn
 658:	0638' CD7C0C  		CALL	SCANQQ		; ..by counting "?"s
 659:	063B' C2000C  		JP	NZ,AMBERR	; ..jump error if ambiguous
 660:	063E' 2A2A00  		LD	HL,(FCBS)	; Check for ambiguous source
 661:	0641' CD7C0C  		CALL	SCANQQ		; ..by counting "?"s
 662:	0644' C2000C  		JP	NZ,AMBERR	; ..jump Error if ambiguous
 663:	0647' 1821    		JR	MCPYOK		; Else jump to Ok procedure
 664:			
 665:	0649' ED4B2400	CKSAMU:	LD	BC,(SUSER)	; Get Source DU
 666:	064D' 2A2600  		LD	HL,(DUSER)	; ..and Dest DU
 667:	0650' B7      		OR	A
 668:	0651' ED42    		SBC	HL,BC		; Dest dir must not equal source dir
 669:	0653' 2015    		JR	NZ,MCPYOK	; Not same, say its ok to go
 670:	0655' CD0000  		CALL	EPRINT
 671:	0658' 0D0A5372		DEFB	CR,LF,'Src=Dest Err',0
	      633D4465
	      73742045
	      727200
 672:	0667' C3B20A  		JP	SETEFLAG	; Set Error flag & exit
 673:			
 674:	066A' 3A2100  	MCPYOK:	LD	A,(ARCHIV)	; Are we in Archival mode?
 675:	066D' B7      		OR	A
 676:	066E' 2812    		JR	Z,COPYAA	; ..jump if not
 677:	0670' CD0000  		CALL	EPRINT		; Print archiving msg
 678:	0673' 0D0A4172		DEFB	CR,LF,'Archiving ',0
	      63686976
	      696E6720
	      00
 679:	0680' 180E    		JR	COPYBB
 680:			
 681:	0682' CD0000  	COPYAA:	CALL	EPRINT
 682:	0685' 0D0A436F		DEFB	CR,LF,'Copying ',0
	      7079696E
	      672000
 683:	0690' CD220C  	COPYBB:	CALL	PRTS2D		; Print "Source to Dest" msg
 684:	0693' 0E0D    		LD	C,13		; Prepare to Reset disk system
 685:	0695' 3A3400  		LD	A,(NORST)	; Is this first copy operation?
 686:	0698' B7      		OR	A
 687:	0699' CC0500  		CALL	Z,BDOSE		; Do reset if so
 688:	069C' CDFA0B  		CALL	DFLTAD		; Set to default DMA addr
 689:	069F' CD8B0B  		CALL	SETSR0		; Log Source, Set FCB & Init it
 690:	06A2' 2A6500  		LD	HL,(FREEBUF)	; Pt to buffer area
 691:	06A5' F6FF    		OR	0FFH		; Store Non-Zero wo we won't reset again
 692:	06A7' 323400  		LD	(NORST),A	; Store a non-zero so we won't reset again
 693:	06AA' CDE90C  		CALL	DDIRQ		; Load dir, select files, sort, etc
 694:	06AD' CAD109  		JP	Z,TPAOVFL	; Tpa overflow error?
 695:	06B0' 78      		LD	A,B		; Do we have any files?
 696:	06B1' B1      		OR	C
 697:	06B2' 280E    		JR	Z,SYSOK0	; Jump if No files
 698:	06B4' CD4A0B  		CALL	CHKXCL		; Check for excluded files
 699:	06B7' 3A2100  		LD	A,(ARCHIV)	; Copy only Non-Archived Files?
 700:	06BA' B7      		OR	A
 701:	06BB' C42E0B  		CALL	NZ,SELARC	; ..reselect directory if so
 702:	06BE' 78      		LD	A,B		; And see if any remain selected
 703:	06BF' B1      		OR	C
 704:	06C0' 2030    		JR	NZ,MCPY24	; ..jump if so
 705:	06C2' 323400  	SYSOK0:	LD	(NORST),A	; Clear flag - disk reset before next copy
 706:	06C5' CDB20A  		CALL	SETEFLAG	; Set Error flag
 707:	06C8' CD0000  		CALL	EPRINT
 708:	06CB' 0D0A204E		DEFB	CR,LF,' NO Files -- ^C to Abort ',0
	      4F204669
	      6C657320
	      2D2D205E
	      4320746F
	      2041626F
	      72742000
 709:	06E7' CDC80B  		CALL	GETCH		; Get response
 710:	06EA' FE03    		CP	CTRLC		; Abort?
 711:	06EC' CA7D05  		JP	Z,COPYT		; End test
 712:	06EF' C37505  		JP	MCOPY		; Continue with next
 713:			
 714:	06F2' 3A1C00  	MCPY24:	LD	A,(INSP)	; Inspect files?
 715:	06F5' B7      		OR	A		; 0=No
 716:	06F6' C4BB0A  		CALL	NZ,INSPF	; Inspect files if option selected
 717:	06F9' 78      		LD	A,B		; Did we select any files?
 718:	06FA' B1      		OR	C
 719:	06FB' 325F00  		LD	(HAVFIL),A
 720:	06FE' 28C2    		JR	Z,SYSOK0	; ..jump if not
 721:	0700' E5      		PUSH	HL		; Save ptr and count
 722:	0701' C5      		PUSH	BC
 723:	0702' 111F00  		LD	DE,ESIZE	; Skip to end of loaded files and mark..
 724:							; ..start of Work area
 725:	0705' 19      	MCPY25:	ADD	HL,DE		; Pt to next
 726:	0706' 0B      		DEC	BC		; Count down
 727:	0707' 78      		LD	A,B		; Done?
 728:	0708' B1      		OR	C
 729:	0709' 20FA    		JR	NZ,MCPY25
 730:			
 731:			; ..a better way to size the copy buffer would be to examine the alloc
 732:			;  size of the source and target disks and use n*maxalc for buffer
 733:			;  size, where n is adjusted to the amount of free memory available.
 734:			
 735:	070B' 221900  		LD	(WORKBF),HL	; Save ptr to beginning of work buffer
 736:	070E' 24      		INC	H		; Round buffer to page boundry
 737:	070F' CDC50C  		CALL	GETTOP		; Get Page of lowest OS component in A
 738:	0712' 94      		SUB	H		; Compute size of buffer area
 739:	0713' DAD109  		JP	C,TPAOVFL	; Abort if not enough tpa
 740:	0716' 2EC0    		LD	L,PLIM		; Set page limit
 741:	0718' BD      		CP	L		; PLIM pages left?
 742:	0719' 3801    		JR	C,PAGOK		; If smaller than PLIM, use it
 743:	071B' 7D      		LD	A,L		; Otherwise use PLIM (why PLIM?)
 744:	071C' 87      	PAGOK:	ADD	A,A		; Convert to # records
 745:	071D' 3002    		JR	NC,PAGOK0	; ..jump if less than 256 records
 746:	071F' 3EFF    		LD	A,0FFH		; Else set to 255 record limit
 747:	0721' 322E00  	PAGOK0:	LD	(PAGLIM),A	; Set page limit
 748:	0724' C1      		POP	BC		; Restore ptrs
 749:	0725' E1      		POP	HL
 750:			
 751:			; Main Copying Loop
 752:			;   File names are pted to by HL and BC=Number of Files
 753:			
 754:	0726' AF      	MCPY26:	XOR	A		; Clear the Verify error flag
 755:	0727' 326200  		LD	(CPYERR),A
 756:	072A' E5      		PUSH	HL		; Save regs
 757:	072B' C5      		PUSH	BC
 758:	072C' CDB30B  		CALL	ABORTCK		; Check for abort
 759:	072F' AF      		XOR	A		; Set flag for replacement abort check
 760:	0730' 326100  		LD	(REPLCK),A
 761:	0733' 3A0000  		LD	A,(TIMTYP)	; Can we do date stamping?
 762:	0736' 323A00  		LD	(DSFLAG),A	; Set indicator accordingly
 763:	0739' CD9D07  		CALL	MCOPYX		; Copy Source (HL) to Dest using work buffer
 764:	073C' CDCE0B  		CALL	PRDONE		; Print done message
 765:	073F' 3A6100  		LD	A,(REPLCK)	; Did we abort a replace request?
 766:	0742' B7      		OR	A
 767:	0743' 284A    		JR	Z,MCPY28	; ..bypass messages if so
 768:	0745' 3A3A00  		LD	A,(DSFLAG)	; Is DS function alive?
 769:	0748' B7      		OR	A
 770:	0749' 2812    		JR	Z,NODATE	; If not, no DS msg
 771:	074B' 3A3800  		LD	A,(QUIET)
 772:	074E' B7      		OR	A		; Are we operating Quietly?
 773:	074F' 200C    		JR	NZ,NODATE	; ..jump and don't print if Quiet
 774:	0751' CD0000  		CALL	EPRINT
 775:	0754' 20284461		DEFB	' (Dated)',0
	      74656429
	      00
 776:	075D' CDB30B  	NODATE:	CALL	ABORTCK		; Check for abort
 777:	0760' 3A2F00  		LD	A,(LSTCPY)	; Last file copied?
 778:	0763' B7      		OR	A		; 0=no
 779:	0764' 3A1B00  		LD	A,(VERFLG)	; Verify?
 780:	0767' 2826    		JR	Z,MCPY28
 781:	0769' B7      		OR	A		; 0=no
 782:	076A' C45F0A  		CALL	NZ,MCOPYV	; Do verify if active
 783:			
 784:	076D' 3A3700  		LD	A,(XMOVE)	; Should we erase source file?
 785:	0770' B7      		OR	A
 786:	0771' 281C    		JR	Z,MCPY28	; ..jump error msg if not
 787:	0773' 3A6200  		LD	A,(CPYERR)	; Was there an error in Verify?
 788:	0776' B7      		OR	A
 789:	0777' 2016    		JR	NZ,MCPY28	; ..don't erase if so
 790:	0779' CD8B0B  		CALL	SETSR0		; Log Source, Get FCB & Init it
 791:	077C' 210900  		LD	HL,9
 792:	077F' 19      		ADD	HL,DE
 793:	0780' CB7E    		BIT	7,(HL)		; See if file is R/O
 794:	0782' 200B    		JR	NZ,MCPY28	; Don't delete if R/O
 795:	0784' CD0000  		CALL	F$DELETE	; Delete the file
 796:	0787' CD0000  		CALL	EPRINT		; Clue that file erased
 797:	078A' 20285829		DEFB	' (X)',0
	      00
 798:			
 799:	078F' C1      	MCPY28:	POP	BC		; Get regs
 800:	0790' E1      		POP	HL
 801:	0791' 111F00  		LD	DE,ESIZE	; Pt to next file
 802:	0794' 19      		ADD	HL,DE		; Hl pts to next file
 803:	0795' 0B      		DEC	BC		; Count down
 804:	0796' 78      		LD	A,B
 805:	0797' B1      		OR	C
 806:	0798' 208C    		JR	NZ,MCPY26
 807:	079A' C37505  		JP	MCOPY		; Copy next file spec
 808:			
 809:			;.....
 810:			; Copy Source file pted to by HL to Destination
 811:			
 812:	079D' AF      	MCOPYX:	XOR	A		; Set no copy of last file
 813:	079E' 322F00  		LD	(LSTCPY),A	; Set flag
 814:			
 815:	07A1' 3A6000  		LD	A,(RENFLG)	; Are we renaming?
 816:	07A4' B7      		OR	A		; ..set flags
 817:	07A5' ED5B2C00		LD	DE,(FCBD)	; Set Destination FCB
 818:	07A9' 060C    		LD	B,12
 819:	07AB' CC0000  		CALL	Z,MOVEB		; Move Drive Name&Typ if not
 820:	07AE' ED5B2A00		LD	DE,(FCBS)	; Set Source FCB
 821:	07B2' CD0000  		CALL	MOVEB
 822:	07B5' 011000  		LD	BC,FNSIZE	; Offset to Stamp starting addr
 823:	07B8' 09      		ADD	HL,BC
 824:	07B9' 224100  		LD	(SRCTD),HL	; ..and save
 825:	07BC' CDA10B  		CALL	SETDS0		; Set Dest FCB & Init it
 826:	07BF' 62      		LD	H,D		; Copy FCB ptr to HL
 827:	07C0' 6B      		LD	L,E
 828:	07C1' 060B    		LD	B,11
 829:	07C3' 23      	CLRATT:	INC	HL		; Bump to next filename character
 830:	07C4' CBBE    		RES	7,(HL)		; Clear attribute bit
 831:	07C6' 10FB    		DJNZ	CLRATT
 832:	07C8' CDFA0B  		CALL	DFLTAD		; Limit "E5" schmutz to 80H-FFH
 833:	07CB' 0E11    		LD	C,17
 834:	07CD' CD0000  		CALL	BDOS		; Search for the file
 835:	07D0' 3C      		INC	A		; Was it found?
 836:	07D1' 67      		LD	H,A		; Save the flag in H
 837:	07D2' 3A2200  		LD	A,(REPLAC)	; Are we replacing existing?
 838:	07D5' B7      		OR	A
 839:	07D6' 7C      		LD	A,H		; ..preparing found test
 840:	07D7' 2802    		JR	Z,NOTX00	; ..jump if no replace
 841:	07D9' B7      		OR	A		; Found?
 842:	07DA' C8      		RET	Z		; ..return if no file
 843:			
 844:	07DB' CD0000  	NOTX00:	CALL	EPRINT
 845:	07DE' 0D0A202D		DEFB	CR,LF,' -> ',0
	      3E2000
 846:	07E5' 13      		INC	DE		; Point to first char of FileName
 847:	07E6' CD0000  		CALL	PFN1		; ..and print
 848:	07E9' 1B      		DEC	DE		; Back up to Drive byte
 849:	07EA' 7C      		LD	A,H		; Retrieve flag
 850:	07EB' 3D      		DEC	A		; Was file found?
 851:	07EC' FAEF08  		JP	M,FNF		; ..jump if File not found (0ffh)
 852:	07EF' 0F      		RRCA			; Convert directory code to offset in buffer
 853:	07F0' 0F      		RRCA
 854:	07F1' 0F      		RRCA
 855:	07F2' C689    		ADD	A,BUFF+9	; Point to T1 (R/O)
 856:	07F4' 6F      		LD	L,A
 857:	07F5' 2600    		LD	H,0
 858:	07F7' 7E      		LD	A,(HL)
 859:	07F8' E680    		AND	80H		; Isolate R/O bit
 860:	07FA' 323500  		LD	(ROFLG),A	; Save as a flag
 861:	07FD' 47      		LD	B,A		; Stash in B for a moment
 862:	07FE' 3A2000  		LD	A,(EXRO)	; Get R/O exist test flag
 863:	0801' A0      		AND	B		; And with R/O status
 864:	0802' 47      		LD	B,A		; Save result
 865:	0803' 3A1F00  		LD	A,(EXIST)	; Now get exist test flag
 866:	0806' B0      		OR	B		; Or with previous result
 867:	0807' 323600  		LD	(RPQFLG),A	; RPQFLG = ((EXRO AND ROFLG) OR EXIST)
 868:	080A' 3A3900  		LD	A,(NOREPL)	; Don't copy if already there?
 869:	080D' B7      		OR	A		; 0=copy anyway
 870:	080E' 2079    		JR	NZ,FFND		; ..jump & check file found by PUBlic if so
 871:	0810' 3A3800  	ISX00:	LD	A,(QUIET)	; Are we operating Quietly?
 872:	0813' B7      		OR	A
 873:	0814' 2073    		JR	NZ,FFND		; ..jump to bypass messages if so
 874:	0816' D5      		PUSH	DE
 875:	0817' 215000  		LD	HL,DESTTD	; Get Timestamp here
 876:	081A' CDBD0C  		CALL	GETSTMP		; .using DSLIB function
 877:	081D' D1      		POP	DE
 878:	081E' CD0000  		CALL	EPRINT
 879:	0821' 20205265		DEFB	'  Replac',0
	      706C6163
	      00
 880:	082A' 21E10C  		LD	HL,SUFFX1	; Assume ?e are prompting for overwrite
 881:	082D' 3A3600  		LD	A,(RPQFLG)	; ..now test our assumption
 882:	0830' B7      		OR	A
 883:	0831' 2003    		JR	NZ,EXIST0	; Jump if we want to pause
 884:	0833' 21E40C  		LD	HL,SUFFX2	; ..else print "ing"
 885:	0836' CD0000  	EXIST0:	CALL	EPSTR
 886:	0839' 3A3A00  		LD	A,(DSFLAG)	; Are we still using Stamps?
 887:	083C' B7      		OR	A
 888:	083D' 284A    		JR	Z,FFND		; ..jump if not
 889:	083F' D5      		PUSH	DE		; Save FCB
 890:	0840' 2A4100  		LD	HL,(SRCTD)	; Get the vector to source Stamps
 891:	0843' CD9909  		CALL	CHKDAT		; Set Mod/Create Date & check valid
 892:	0846' 2835    		JR	Z,UNDAT		; ..print Undated if No date
 893:	0848' EB      		EX	DE,HL		; Put Source Date addr in DE
 894:	0849' 215000  		LD	HL,DESTTD	; Set Dest date & check validity
 895:	084C' CD9909  		CALL	CHKDAT
 896:	084F' 282C    		JR	Z,UNDAT		; ..print Undated if No date
 897:	0851' 0605    		LD	B,5		; ..for 5 bytes
 898:	0853' 1A      	CTDLP:	LD	A,(DE)
 899:	0854' BE      		CP	(HL)		; Are they the same?
 900:	0855' 3810    		JR	C,NEWER		; .jump here if Newer version
 901:	0857' 2019    		JR	NZ,OLDER	; ..jump here if Older version
 902:	0859' 23      		INC	HL		; Else
 903:	085A' 13      		INC	DE		; .bump ptrs cause same
 904:	085B' 10F6    		DJNZ	CTDLP		; ..and loop til done (Same)
 905:	085D' CD0000  		CALL	EPRINT
 906:	0860' 53616D65		DEFB	'Same',0
	      00
 907:	0865' 1821    		JR	DATEX		; Rejoin code
 908:			
 909:	0867' CD0000  	NEWER:	CALL	EPRINT
 910:	086A' 4E657765		DEFB	'Newer',0
	      7200
 911:	0870' 1816    		JR	DATEX
 912:			
 913:	0872' CD0000  	OLDER:	CALL	EPRINT
 914:	0875' 4F6C6465		DEFB	'Older',0
	      7200
 915:	087B' 180B    		JR	DATEX
 916:			
 917:	087D' CD0000  	UNDAT:	CALL	EPRINT
 918:	0880' 556E6461		DEFB	'Undated',0
	      74656400
 919:	0888' D1      	DATEX:	POP	DE		; Restore FCB
 920:			
 921:	0889' 3A3500  	FFND:	LD	A,(ROFLG)
 922:	088C' B7      		OR	A		; Was file R/O
 923:	088D' 2808    		JR	Z,NORO		; Jump if not
 924:	088F' CD0000  		CALL	EPRINT
 925:	0892' 20522F4F		DEFB	' R/O',0
	      00
 926:	0897' 210700  	NORO:	LD	HL,7		; Offset to PUBlic/Path bit
 927:	089A' 19      		ADD	HL,DE
 928:	089B' CB7E    		BIT	7,(HL)		; Was it found via Public or Path?
 929:	089D' 280D    		JR	Z,NOTPUB	; ..jump if not
 930:	089F' CD0000  		CALL	EPRINT		; Else print additional prompt
 931:	08A2' 20285075		DEFB	' (Public)',0
	      626C6963
	      2900
 932:	08AC' 3A3900  	NOTPUB:	LD	A,(NOREPL)	; Are we in a No Replacement mode?
 933:	08AF' B7      		OR	A
 934:	08B0' 280C    		JR	Z,FFND0		; Jump if not
 935:	08B2' CD0000  		CALL	EPRINT
 936:	08B5' 2043616E		DEFB	' Can''t!',0
	      27742100
 937:	08BD' C9      		RET			; Return with no action (no replace)
 938:			
 939:	08BE' 3A3600  	FFND0:	LD	A,(RPQFLG)	; Do we need to propt user?
 940:	08C1' B7      		OR	A
 941:	08C2' 2819    		JR	Z,EAT1		; Jump if not to copy
 942:	08C4' CD0000  		CALL	EPRINT
 943:	08C7' 2028592F		DEFB	' (Y/[N])? ',0
	      5B4E5D29
	      3F2000
 944:	08D2' CDC80B  		CALL	GETCH		; Get response
 945:	08D5' FE0D    		CP	CR		; Yes?
 946:	08D7' C40000  		CALL	NZ,COUT		; ..echo if Not CR
 947:	08DA' FE59    		CP	'Y'		; Is it an explicit Yes?
 948:	08DC' C0      		RET	NZ		; ..return if no replace
 949:			
 950:	08DD' 3A3500  	EAT1:	LD	A,(ROFLG)	; Is this an R/O file?
 951:	08E0' B7      		OR	A
 952:	08E1' 2809    		JR	Z,EAT1A		; No need to set attributes if not
 953:	08E3' 210900  		LD	HL,9		; Offset to R/O attribute
 954:	08E6' 19      		ADD	HL,DE
 955:	08E7' CBBE    		RES	7,(HL)
 956:	08E9' CD8709  		CALL	DOATTR		; Make file R/W
 957:	08EC' CD0000  	EAT1A:	CALL	F$DELETE	; ..and delete it
 958:	08EF' CD0000  	FNF:	CALL	EPRINT
 959:	08F2' 2E2E00  		DEFB	'..',0
 960:	08F5' 3EFF    		LD	A,0FFH		; Set copy of last file
 961:	08F7' 322F00  		LD	(LSTCPY),A	; Set flag
 962:	08FA' 326100  		LD	(REPLCK),A	; ..and another to show No Replacement Abort
 963:	08FD' CD0000  		CALL	INITFCB		; Insure clean FCB
 964:	0900' CD0000  		CALL	F$MAKE		; Create new file
 965:	0903' 3C      		INC	A		; Check for full directory
 966:	0904' CA130A  		JP	Z,DIRFUL	; Report it
 967:			
 968:			; Open Source File in prep for Copy
 969:			
 970:	0907' CD0000  		CALL	CRC3CLR		; Clear CRC value in case we're verifying
 971:	090A' CD8B0B  		CALL	SETSR0		; Log Source, Initialize & Set FCB
 972:	090D' CD0000  		CALL	F$OPEN		; Open file
 973:			
 974:			; This loop, which starts at MCPYX, Copies the file from Source to Dest
 975:			
 976:	0910' CD970B  	MCPYX:	CALL	SETSRC		; Log Source & Set Src FCB
 977:	0913' 2A1900  		LD	HL,(WORKBF)	; Pt to buffer to copy into
 978:	0916' CD290A  		CALL	LOAD		; Load file into workbf
 979:	0919' 3A3100  		LD	A,(BCNT)	; If count=0, then done
 980:	091C' B7      		OR	A
 981:	091D' 2827    		JR	Z,MC2DONE
 982:			
 983:			; Copy to Disk
 984:			
 985:	091F' CDAC0B  		CALL	LOGD		; Log in destination
 986:	0922' 2A1900  		LD	HL,(WORKBF)	; Pt to buffer
 987:	0925' CD0000  	MCPYD1:	CALL	SETDMA		; Set dma address pted to by HL
 988:	0928' 118000  		LD	DE,128		; Incr HL by 128
 989:	092B' 19      		ADD	HL,DE		; HL pts to next block
 990:	092C' ED5B2C00		LD	DE,(FCBD)	; Write to destination file
 991:	0930' CD0000  		CALL	F$WRITE
 992:	0933' B7      		OR	A		; Ok?
 993:	0934' C2E109  		JP	NZ,MCPYDERR
 994:			
 995:			; Count down to next block
 996:			
 997:	0937' 3A3100  		LD	A,(BCNT)	; Get block count
 998:	093A' 3D      		DEC	A		; Count down
 999:	093B' 323100  		LD	(BCNT),A
1000:	093E' 20E5    		JR	NZ,MCPYD1
1001:	0940' 3A3200  		LD	A,(CONT)	; Continue?
1002:	0943' B7      		OR	A		; Cont if not zero
1003:	0944' 20CA    		JR	NZ,MCPYX
1004:			
1005:			; End of Copy Loop
1006:			
1007:	0946' CD970B  	MC2DONE: CALL	SETSRC		; Log source & Set FCB
1008:	0949' CD0000  		CALL	F$CLOSE
1009:			
1010:	094C' CDA80B  		CALL	SETDST		; Log Dest & Set FCB
1011:	094F' CD0000  		CALL	F$CLOSE
1012:			
1013:			; 	PUSH	DE
1014:			; 	LD	HL,TMPTIM	; Set Addr for Date & Time
1015:			; 	CALL	RCLOCK		; Attempt a clock read
1016:			; 	JR	NZ,NOCLOK	; ..jump if not good read
1017:			;
1018:			; 	LD	HL,(SRCTD)	; Set source TD
1019:			; 	LD	DE,5		; ..offset to Last Access
1020:			; 	ADD	HL,DE
1021:			; 	EX	DE,HL		; Put in DE reg for dest
1022:			; 	LD	HL,TMPTIM	; Point to source tim & dat
1023:			; 	LD	BC,5		; Move 5 bytes
1024:			; 	LDIR
1025:			; NOCLOK:	POP	DE
1026:	0952' D5      		PUSH	DE		; ..save pointer for attr set
1027:	0953' CD0000  		CALL	INITFCB		; Initialize FCB to start
1028:			; 	LD	HL,(SRCTD)	; Get addr of New file's Stamp
1029:			; 	CALL	PUTSTMP		; Attempt Put Stamp to Disk
1030:	0956' CD0000  		CALL	CRC3DONE	; Get CRC value in case Verifying
1031:	0959' 222800  		LD	(CRCVAL),HL	; Save CRC value or junk if Not Verifying
1032:						;..fall thru, set Attr of Dest to those of Source
1033:	095C' ED5B2A00		LD	DE,(FCBS)	; Source FCB contains orig attributes
1034:	0960' 13      		INC	DE		; Point to 1st attr
1035:	0961' 2A2C00  		LD	HL,(FCBD)	; Get destination FCB
1036:	0964' 23      		INC	HL		; ..and pt to 1st attr
1037:	0965' 0E00    		LD	C,0		; Clear C. Will have count of attributes set
1038:	0967' CD8F09  		CALL	CKATTR		; Check/Set 1st attr
1039:	096A' 13      		INC	DE		; Go to Attr F3
1040:	096B' 23      		INC	HL
1041:	096C' 0608    		LD	B,8		; Do 8 and end at Archive
1042:	096E' CD8F09  	CKATTL:	CALL	CKATTR		; Do a bit/byte
1043:	0971' 10FB    		DJNZ	CKATTL		; ..and loop til done
1044:	0973' D1      		POP	DE		; ...restore FCB pointer
1045:	0974' 79      		LD	A,C		; Any Attributes Set?
1046:	0975' B7      		OR	A
1047:	0976' C48709  		CALL	NZ,DOATTR	; Set the attributes if any need setting
1048:	0979' 3A2100  		LD	A,(ARCHIV)	; Are we in Archiving Mode?
1049:	097C' B7      		OR	A
1050:	097D' C8      		RET	Z		; ..return if not
1051:	097E' CD970B  		CALL	SETSRC		; Log source & Set FCB
1052:	0981' 210B00  		LD	HL,11		; Else offset to Archive Bit
1053:	0984' 19      		ADD	HL,DE
1054:	0985' CBFE    		SET	7,(HL)		; ..and Show that it has been Archived
1055:	0987' CD0000  	DOATTR:	CALL	INITFCB		; Init FCB pted to by DE
1056:	098A' 0E1E    		LD	C,30		; Set file attributes
1057:	098C' C30000  		JP	BDOS		; MCOPYX returns to caller via BDOS
1058:			
1059:			; Little routine to help with attribute setting
1060:			
1061:	098F' 1A      	CKATTR:	LD	A,(DE)		; Get source byte
1062:	0990' 17      		RLA			; ..and test attr
1063:	0991' 3003    		JR	NC,CKATT0	; Jump if not set
1064:	0993' CBFE    		SET	7,(HL)		; ..else set dest attr
1065:	0995' 0C      		INC	C		; ..and count it
1066:	0996' 13      	CKATT0:	INC	DE		; Advance to next byte
1067:	0997' 23      		INC	HL
1068:	0998' C9      		RET
1069:			
1070:			;.....
1071:			; Check validity of Mod/Create dates
1072:			; Enter: HL --> Create Date in std datespec
1073:			; Exit : HL --> Valid Mod/Create date field, or Create field if invalid
1074:			;	 AF = A=0, Zero flag set (Z) if invalid
1075:			;		A <> 0, Zero Flag Clear (NZ) if date valid
1076:			
1077:	0999' D5      	CHKDAT:	PUSH	DE		; Preserve other regs
1078:	099A' EB      		EX	DE,HL		; Put Create date addr in DE
1079:	099B' 210A00  		LD	HL,10		; Set offset to Modify field
1080:	099E' 19      		ADD	HL,DE		; ..and offset to Modify Date
1081:	099F' 7E      		LD	A,(HL)		; Is it valid?
1082:	09A0' 23      		INC	HL
1083:	09A1' B6      		OR	(HL)		; Or Year and Month
1084:	09A2' 2B      		DEC	HL		; ..back up to Year
1085:	09A3' 2005    		JR	NZ,CHKDA0	; Jump if Date valid
1086:	09A5' EB      		EX	DE,HL		; ..else put Create date addr in HL
1087:	09A6' 7E      		LD	A,(HL)		; Check validity
1088:	09A7' 23      		INC	HL
1089:	09A8' B6      		OR	(HL)
1090:	09A9' 2B      		DEC	HL
1091:	09AA' D1      	CHKDA0:	POP	DE		; Restore regs
1092:	09AB' C9      		RET			; ..with flags set
1093:			
1094:			;.....
1095:			; Convert Z3 FCB DU into DU in BC
1096:			
1097:	09AC' E5      	DUCVRT:	PUSH	HL		; Save regs
1098:	09AD' D5      		PUSH	DE
1099:	09AE' 1A      		LD	A,(DE)		; Get disk
1100:	09AF' B7      		OR	A		; Current?
1101:	09B0' 2004    		JR	NZ,DUCV1
1102:	09B2' 3A2300  		LD	A,(CDISK)	; Get current
1103:	09B5' 3C      		INC	A		; Add 1 for a=1
1104:	09B6' 3D      	DUCV1:	DEC	A		; A=0
1105:	09B7' 47      		LD	B,A
1106:	09B8' 210D00  		LD	HL,13		; Offset to user
1107:	09BB' 19      		ADD	HL,DE
1108:	09BC' 4E      		LD	C,(HL)		; Get user
1109:	09BD' D1      		POP	DE		; Restore regs
1110:	09BE' E1      		POP	HL
1111:	09BF' C9      		RET
1112:			
1113:			; Format Error
1114:			
1115:	09C0' CD0000  	FORMERR: CALL	EPRINT
1116:	09C3' 0D0A2045		DEFB	CR,LF,' Error: ',0
	      72726F72
	      3A2000
1117:	09CE' C30000  		JP	EPSTR		; Print error & return
1118:			
1119:			; TPA Overflow
1120:			
1121:	09D1' CD0000  	TPAOVFL: CALL	EPRINT
1122:	09D4' 0D0A5450		DEFB	CR,LF,'TPA Ovfl',0
	      41204F76
	      666C00
1123:	09DF' 182C    		JR	BADCOPY
1124:			
1125:			; Write Error
1126:			
1127:	09E1' CD0000  	MCPYDERR: CALL	EPRINT
1128:	09E4' 0D0A4469		DEFB	CR,LF,'Disk Full or Write Error !',0
	      736B2046
	      756C6C20
	      6F722057
	      72697465
	      20457272
	      6F722021
	      00
1129:	0A01' CDA80B  		CALL	SETDST		; Log in Dest & Set FCB
1130:	0A04' CD0000  		CALL	F$CLOSE		; ..and close the file
1131:	0A07' CD0000  		CALL	INITFCB		; Initialize the FCB
1132:	0A0A' CD0000  		CALL	F$DELETE	; ...then Kill it
1133:	0A0D' CDB20A  	BADCOPY: CALL	SETEFLAG	; Set ZCPR3 Error flag
1134:	0A10' C31505  		JP	CPM		; ..and return to OS
1135:			
1136:			; Directory Full Error
1137:			
1138:	0A13' CD0000  	DIRFUL:	CALL	EPRINT
1139:	0A16' 0D0A4469		DEFB	CR,LF,'Directory Full',0
	      72656374
	      6F727920
	      46756C6C
	      00
1140:	0A27' 18E4    		JR	BADCOPY
1141:			
1142:			;.....
1143:			; Load Buffer pted to by HL from file whose FCB is pted to by DE
1144:			;   On Output, BCNT=Number of blocks loaded (up to 128) and
1145:			;   CONT=0 if Done or 128 if Not Done
1146:			
1147:	0A29' AF      	LOAD:	XOR	A		; A=0
1148:	0A2A' 323100  		LD	(BCNT),A	; Set block count
1149:	0A2D' 323200  		LD	(CONT),A	; Turn off continuation flag
1150:			
1151:			; Main Copy Loop
1152:			
1153:	0A30' CD0000  	MCPY:	CALL	SETDMA		; Set DMA to block pted to by HL
1154:	0A33' CD0000  		CALL	F$READ		; ..and Read block
1155:	0A36' B7      		OR	A		; End of file?
1156:	0A37' C0      		RET	NZ		; ..return if so
1157:	0A38' 3A1B00  		LD	A,(VERFLG)	; Doing verify?
1158:	0A3B' B7      		OR	A		; ..set flags
1159:	0A3C' 280B    		JR	Z,LOAD1		; ...jump w/no CRC if No ver
1160:	0A3E' E5      		PUSH	HL		; Save ptr to DMA
1161:	0A3F' 0680    		LD	B,128		; Update CRC for 128 bytes
1162:	0A41' 7E      	MCPYCRC: LD	A,(HL)		; Get byte
1163:	0A42' CD0000  		CALL	CRC3UPD		; Update CRC
1164:	0A45' 23      		INC	HL		; Pt to next
1165:	0A46' 10F9    		DJNZ	MCPYCRC		; ..Count down and loop til done
1166:	0A48' E1      		POP	HL		; Retrieve ptr to DMA
1167:	0A49' 018000  	LOAD1:	LD	BC,128		; Set # bytes in Sector
1168:	0A4C' 09      		ADD	HL,BC		; ..and pt to nxt log sctr
1169:	0A4D' 3A3100  		LD	A,(BCNT)	; Get block count
1170:	0A50' 3C      		INC	A		; Increment it
1171:	0A51' 323100  		LD	(BCNT),A	; ..and store
1172:	0A54' 47      		LD	B,A		; Block count in B
1173:	0A55' 3A2E00  		LD	A,(PAGLIM)	; Get page limit (in records)
1174:	0A58' B8      		CP	B		; Buffer full?
1175:	0A59' 20D5    		JR	NZ,MCPY		; ..loop if not
1176:	0A5B' 323200  		LD	(CONT),A	; Else set continuation flag
1177:	0A5E' C9      		RET
1178:			
1179:			; Verify Phase
1180:			
1181:	0A5F' 3A3800  	MCOPYV:	LD	A,(QUIET)	; Check for quiet
1182:	0A62' B7      		OR	A		; Nz=quiet
1183:	0A63' 200E    		JR	NZ,MCPYV
1184:	0A65' CD0000  		CALL	EPRINT
1185:	0A68' 20205665		DEFB	'  Verify..',0
	      72696679
	      2E2E00
1186:	0A73' CD0000  	MCPYV:	CALL	CRC3CLR		; Clear crck value
1187:	0A76' CDA10B  		CALL	SETDS0		; Log in Dest, Set FCB & Init
1188:	0A79' CD0000  		CALL	F$OPEN		; Open file
1189:			
1190:			; **** Main Verify Loop ****
1191:			
1192:	0A7C' 2A1900  	VERLOOP: LD	HL,(WORKBF)	; Load input buffer from destination
1193:	0A7F' ED5B2C00		LD	DE,(FCBD)
1194:	0A83' CD290A  		CALL	LOAD		; Load and compute CRC value
1195:	0A86' 3A3100  		LD	A,(BCNT)	; Done if no bytes loaded
1196:	0A89' B7      		OR	A
1197:	0A8A' 2806    		JR	Z,VERCRC
1198:	0A8C' 3A3200  		LD	A,(CONT)	; Continue?
1199:	0A8F' B7      		OR	A		; 0=no
1200:	0A90' 20EA    		JR	NZ,VERLOOP
1201:			
1202:			; Verify Done
1203:			
1204:	0A92' CD0000  	VERCRC:	CALL	CRC3DONE	; Update complete, value in HL
1205:	0A95' ED5B2800		LD	DE,(CRCVAL)	; Get old CRC value into DE
1206:	0A99' AF      		XOR	A		; Clears carry flag
1207:	0A9A' ED52    		SBC	HL,DE		; Compare HL to DE
1208:	0A9C' CACE0B  		JP	Z,PRDONE	; Print done msg or fall thru to error msg
1209:						;..else fall thru to Verify Error
1210:	0A9F' 213000  		LD	HL,VERCNT	; Increment error count
1211:	0AA2' 34      		INC	(HL)
1212:	0AA3' CD0000  		CALL	EPRINT
1213:	0AA6' 202E2E42		DEFB	' ..Bad',0
	      616400
1214:	0AAD' 3EFF    		LD	A,0FFH		; Set flag to show error in Verify
1215:	0AAF' 326200  		LD	(CPYERR),A
1216:	0AB2'         	SETEFLAG:
1217:	0AB2' 3A3300  		LD	A,(NOMSGS)	; Set error flag if there
1218:	0AB5' B7      		OR	A		; Is a message buffer
1219:	0AB6' C0      		RET	NZ
1220:	0AB7' 2F      		CPL
1221:	0AB8' C30000  		JP	PUTER2
1222:			
1223:			; **** MCOPY Utilities ****
1224:			;.....
1225:			; Allow user to inspect files for Copy
1226:			;   First file name pted to by HL, BC = Number of files
1227:			;   On Exit, BC = Number of selected files
1228:			
1229:	0ABB' CD0000  	INSPF:	CALL	EPRINT
1230:	0ABE' 0D0A2049		DEFB	CR,LF,' Inspect -- '
	      6E737065
	      6374202D
	      2D20
1231:	0ACC' 5965732C		DEFB	'Yes, No (def), Skip Rest',0
	      204E6F20
	      28646566
	      292C2053
	      6B697020
	      52657374
	      00
1232:	0AE5' E5      		PUSH	HL		; Save ptr to first file
1233:	0AE6' C5      		PUSH	BC		; Save file count
1234:	0AE7' 111F00  		LD	DE,ESIZE	; Entries are esize bytes apart
1235:	0AEA' CBBE    	INSPF0:	RES	7,(HL)		; Clear MSB to mark file for no copy
1236:	0AEC' 19      		ADD	HL,DE		; Pt to next
1237:	0AED' 0B      		DEC	BC		; Count down
1238:	0AEE' 78      		LD	A,B		; Done?
1239:	0AEF' B1      		OR	C
1240:	0AF0' 20F8    		JR	NZ,INSPF0
1241:	0AF2' C1      		POP	BC		; Restore and save again
1242:	0AF3' E1      		POP	HL
1243:	0AF4' E5      		PUSH	HL
1244:	0AF5' C5      		PUSH	BC
1245:	0AF6' CD0000  	INSPF1:	CALL	CRLF		; New line
1246:	0AF9' EB      		EX	DE,HL		; Put FN in DE
1247:	0AFA' 13      		INC	DE		; ..and point to Name
1248:	0AFB' CD0000  		CALL	PFN1		; Print it
1249:	0AFE' 1B      		DEC	DE		; Re-align ptr to file entry
1250:	0AFF' EB      		EX	DE,HL		; Restore regs
1251:	0B00' CD0000  		CALL	EPRINT
1252:	0B03' 202D2028		DEFB	' - (Y/N/S)? ',0
	      592F4E2F
	      53293F20
	      00
1253:	0B10' CDC80B  		CALL	GETCH		; Get response
1254:	0B13' CD0000  		CALL	COUT		; Echo
1255:	0B16' FE53    		CP	'S'		; Skip?
1256:	0B18' 280F    		JR	Z,INSPFA
1257:	0B1A' FE59    		CP	'Y'		; Yes?
1258:	0B1C' 2002    		JR	NZ,INSPF2
1259:	0B1E' CBFE    		SET	7,(HL)		; Mark File
1260:	0B20' 111F00  	INSPF2:	LD	DE,ESIZE	; Pt to next file
1261:	0B23' 19      		ADD	HL,DE
1262:	0B24' 0B      		DEC	BC		; Count down
1263:	0B25' 78      		LD	A,B		; Done?
1264:	0B26' B1      		OR	C
1265:	0B27' 20CD    		JR	NZ,INSPF1
1266:	0B29' C1      	INSPFA:	POP	BC		; Get count
1267:	0B2A' E1      		POP	HL		; Get ptr to first file
1268:	0B2B' C30F0F  		JP	DIRPAK		; Repack directory
1269:			
1270:			;.....
1271:			; Select only files which do Not have Archive Bit set
1272:			; Enter:HL --> First name in Directory
1273:			;	BC = Number of Files
1274:			; Exit :BC = New Number of Files
1275:			;	HL --> First name in Directory
1276:			
1277:	0B2E' E5      	SELARC:	PUSH	HL		; Save values
1278:	0B2F' C5      		PUSH	BC
1279:	0B30' CBBE    	SELAR0:	RES	7,(HL)		; Set initially for No Select
1280:	0B32' EB      		EX	DE,HL		; Put file pointer in DE
1281:	0B33' 210B00  		LD	HL,11		; ..and offset by Archive Bit
1282:	0B36' 19      		ADD	HL,DE
1283:	0B37' CB7E    		BIT	7,(HL)		; Is it already Archived?
1284:	0B39' 2004    		JR	NZ,SELAR1	; ..jump if so to bypass
1285:	0B3B' 6B      		LD	L,E		; Else copy record start to HL
1286:	0B3C' 62      		LD	H,D
1287:	0B3D' CBFE    		SET	7,(HL)		; ..and select it
1288:	0B3F' 211F00  	SELAR1:	LD	HL,ESIZE	; Offset to Next record
1289:	0B42' 19      		ADD	HL,DE
1290:	0B43' 0B      		DEC	BC		; Decrement count
1291:	0B44' 78      		LD	A,B		; Are we out of records?
1292:	0B45' B1      		OR	C
1293:	0B46' 20E8    		JR	NZ,SELAR0	; ..loop if Not
1294:	0B48' 18DF    		JR	INSPFA		; Else exit by repacking directory
1295:			
1296:			;.....
1297:			; Delete files from the directory list in the EXCLUDE list
1298:			; Enter:HL --> First name in Directory
1299:			;	BC = Number of files
1300:			; Exit :BC = New number of files
1301:			;	HL --> First name in Directory
1302:			
1303:	0B4A' E5      	CHKXCL:	PUSH	HL		; Save values
1304:	0B4B' C5      		PUSH	BC
1305:	0B4C' 112A00  	CHKEX0:	LD	DE,EXCLUD	; Point to Exclude List
1306:	0B4F' CD620B  		CALL	CHKXXX		; Does it Match?
1307:	0B52' 2802    		JR	Z,CHKEX1	; ..jump if so (no select)
1308:	0B54' CBFE    		SET	7,(HL)		; Else select it
1309:	0B56' EB      	CHKEX1:	EX	DE,HL		; Advance to next entry
1310:	0B57' 211F00  		LD	HL,ESIZE
1311:	0B5A' 19      		ADD	HL,DE
1312:	0B5B' 0B      		DEC	BC		; Decrement file count
1313:	0B5C' 78      		LD	A,B		; Are we out of records?
1314:	0B5D' B1      		OR	C
1315:	0B5E' 20EC    		JR	NZ,CHKEX0	; ..loop if not
1316:	0B60' 18C7    		JR	INSPFA		; Else exit by repacking dir
1317:			
1318:			; Check current entry against exclude list
1319:			
1320:	0B62' C5      	CHKXXX:	PUSH	BC		; Preserve regs
1321:	0B63' E5      		PUSH	HL
1322:	0B64' 23      	CHKXX0:	INC	HL		; Step by User #
1323:	0B65' 060B    		LD	B,11		; Compare FN and FT
1324:	0B67' 1A      		LD	A,(DE)		; Any entry here?
1325:	0B68' FE20    		CP	' '		; ..not if 1st char is space
1326:	0B6A' 2812    		JR	Z,CHKXX2	; ...jump if no entry
1327:	0B6C' 1A      	CHKXX1:	LD	A,(DE)		; ..char by char
1328:	0B6D' FE3F    		CP	'?'		; Accomodate wildcard char
1329:	0B6F' 2805    		JR	Z,CHKX??	; ..jump if wild
1330:	0B71' 96      		SUB	(HL)		; Else compare to entry char
1331:	0B72' E67F    		AND	7FH		; ...masking MSB
1332:	0B74' 2008    		JR	NZ,CHKXX2	; Jump if not equal
1333:	0B76' 23      	CHKX??:	INC	HL		; Bump ptrs
1334:	0B77' 13      		INC	DE
1335:	0B78' 10F2    		DJNZ	CHKXX1		; ..loop til all checked
1336:	0B7A' AF      		XOR	A		; Clear A in case "?" at end
1337:	0B7B' E1      	CHKXX3:	POP	HL		; Restore regs..
1338:	0B7C' C1      		POP	BC		; ..leaving flags set
1339:	0B7D' C9      		RET
1340:			
1341:	0B7E' 13      	CHKXX2:	INC	DE		; Advance past Exc chars
1342:	0B7F' 10FD    		DJNZ	CHKXX2		; ..and loop til done
1343:	0B81' E1      		POP	HL		; Restore Dir entry ptr
1344:	0B82' E5      		PUSH	HL		; ..keeping it on stack
1345:	0B83' 1A      		LD	A,(DE)		; Are we at table end?
1346:	0B84' B7      		OR	A
1347:	0B85' 20DD    		JR	NZ,CHKXX0	; ..check another name if not
1348:	0B87' F6FF    		OR	0FFH		; Signify no match
1349:	0B89' 18F0    		JR	CHKXX3		; Else exit here
1350:			
1351:			;.....
1352:			; Log in Source User/Disk
1353:			
1354:	0B8B' ED5B2A00	SETSR0:	LD	DE,(FCBS)	; Get Source FCB addr
1355:	0B8F' CD0000  		CALL	INITFCB		; ..and Initialize it
1356:	0B92' 3A2500  		LD	A,(SDRIVE)	; Load Source drive byte
1357:	0B95' 3C      		INC	A		; ..prepared for FCB drive #
1358:	0B96' 12      		LD	(DE),A		; ...and save
1359:	0B97' ED5B2A00	SETSRC:	LD	DE,(FCBS)	; Get Source FCB addr again
1360:	0B9B' ED4B2400	LOGS:	LD	BC,(SUSER)
1361:	0B9F' 180F    		JR	LOGDS
1362:			
1363:			;.....
1364:			; Log in Destination User/Disk
1365:			
1366:	0BA1' ED5B2C00	SETDS0:	LD	DE,(FCBD)	; Get Destination FCB addr
1367:	0BA5' CD0000  		CALL	INITFCB		; ..and Initialize it
1368:	0BA8' ED5B2C00	SETDST:	LD	DE,(FCBD)	; Get Dest FCB addr again
1369:	0BAC' ED4B2600	LOGD:	LD	BC,(DUSER)
1370:	0BB0' C30000  	LOGDS:	JP	LOGUD
1371:			
1372:			;.....
1373:			; Check for Abort from Keyboard
1374:			
1375:	0BB3' CD0000  	ABORTCK: CALL	CONDIN		; Conditional input
1376:	0BB6' C8      		RET	Z
1377:	0BB7' FE03    		CP	CTRLC		; Abort?
1378:	0BB9' C0      		RET	NZ		; ..return if not
1379:	0BBA' CD0000  		CALL	EPRINT		; Else say we are aborting
1380:	0BBD' 0D0A4162		DEFB	CR,LF,'Abort',0
	      6F727400
1381:	0BC5' C31505  		JP	CPM		; ..and qui
1382:			
1383:			;.....
1384:			; Get a character from the keyboard converting to uppercase
1385:			
1386:	0BC8' CD0000  	GETCH:	CALL	CIN		; Get a char
1387:	0BCB' C30000  		JP	CAPS		; Convert to Uppercase and return
1388:			
1389:			;.....
1390:			; Print Done Message
1391:			
1392:	0BCE' 3A3800  	PRDONE:	LD	A,(QUIET)	; Check for quiet
1393:	0BD1' B7      		OR	A		; Nz=quiet
1394:	0BD2' C0      		RET	NZ
1395:	0BD3' 3A2F00  		LD	A,(LSTCPY)	; Last file copied?
1396:	0BD6' B7      		OR	A		; 0 = no
1397:	0BD7' 201A    		JR	NZ,DID
1398:	0BD9' 3A3900  		LD	A,(NOREPL)	; Not copied because already there?
1399:	0BDC' B7      		OR	A		; Nz = yes
1400:	0BDD' C8      		RET	Z
1401:	0BDE' CD0000  		CALL	EPRINT
1402:	0BE1' 20416C72		DEFB	' Already Present',0
	      65616479
	      20507265
	      73656E74
	      00
1403:	0BF2' C9      		RET
1404:			
1405:	0BF3' CD0000  	DID:	CALL	EPRINT
1406:	0BF6' 4F6B00  		DEFB	'Ok',0
1407:	0BF9' C9      		RET
1408:			
1409:			;.....
1410:			; Set DMA Address to Default buffer (80H)
1411:			
1412:	0BFA' 218000  	DFLTAD:	LD	HL,BUFF
1413:	0BFD' C30000  		JP	SETDMA		; Set it and return
1414:			
1415:			;.....
1416:			; Print error on Ambiguous Rename attempt w/secondary utility ID print
1417:			
1418:	0C00' CD0000  	AMBERR:	CALL	EPRINT
1419:	0C03' 0D0A4361		DEFB	CR,LF,'Can''t Rename Ambiguously -- ',0
	      6E277420
	      52656E61
	      6D652041
	      6D626967
	      756F7573
	      6C79202D
	      2D2000
1420:	0C22' ED4B2400	PRTS2D:	LD	BC,(SUSER)	; Print Source File ID
1421:	0C26' CD4D0C  		CALL	PRNDU		; Print source DU w/":"
1422:	0C29' ED5B2A00		LD	DE,(FCBS)	; Print file spec
1423:	0C2D' 13      		INC	DE		; Pt to file Name
1424:	0C2E' CD0000  		CALL	PFN1		; ..and print
1425:	0C31' CD0000  		CALL	EPRINT
1426:	0C34' 20746F20		DEFB	' to ',0
	      00
1427:	0C39' ED4B2600		LD	BC,(DUSER)
1428:	0C3D' CD4D0C  		CALL	PRNDU		; Print Dest DU w/":"
1429:	0C40' 3A6000  		LD	A,(RENFLG)	; Are we renaming?
1430:	0C43' B7      		OR	A
1431:	0C44' C8      		RET	Z		; ..return if not
1432:	0C45' ED5B2C00		LD	DE,(FCBD)	; Else print Dest file spec
1433:	0C49' 13      		INC	DE		; Pt to File Name
1434:	0C4A' C30000  		JP	PFN1		; ..print and return via Stack
1435:			
1436:			;.....
1437:			; PRINT "DU:" from values in BC register
1438:			
1439:	0C4D' 78      	PRNDU:	LD	A,B
1440:	0C4E' C641    		ADD	A,'A'
1441:	0C50' CD0000  		CALL	COUT
1442:	0C53' 79      		LD	A,C
1443:	0C54' CD0000  		CALL	PAFDC
1444:	0C57' 3E3A    		LD	A,':'
1445:	0C59' C30000  		JP	COUT
1446:			
1447:			;.....
1448:			; Print actual COMfile name if we can,
1449:			; otherwise print "COPY"
1450:			
1451:	0C5C' 3A0A00  	COMNAM:	LD	A,(Z3EADR+1)	; Do we have an environment?
1452:	0C5F' B7      		OR	A
1453:	0C60' C40000  		CALL	NZ,GETEFCB	; .Get EFCB name if so
1454:	0C63' 280E    		JR	Z,NOEFCB	; ..Print "COPY" if Not
1455:	0C65' 0608    	PRNNAM:	LD	B,8
1456:	0C67' 23      	COMNML:	INC	HL
1457:	0C68' 7E      		LD	A,(HL)
1458:	0C69' E67F    		AND	7FH
1459:	0C6B' FE20    		CP	' '
1460:	0C6D' C40000  		CALL	NZ,COUT
1461:	0C70' 10F5    		DJNZ	COMNML
1462:	0C72' C9      		RET
1463:			
1464:	0C73' CD0000  	NOEFCB:	CALL	EPRINT
1465:	0C76' 434F5059		DEFB	'COPY',0
	      00
1466:	0C7B' C9      		RET
1467:			
1468:			;.....
1469:			; Scan 11-char string for specified character ("?")
1470:			; Enter: HL --> Start of string -1
1471:			; Exit :  B = 0
1472:			;	  A = Count of specified character
1473:			; Destroys HL & C.  DE unaffected
1474:			
1475:	0C7C' 3E3F    	SCANQQ:	LD	A,'?'		; Set search for Quest Mrks
1476:	0C7E' 23      	SCAN11:	INC	HL		; Advance to name field
1477:	0C7F' 01000B  		LD	BC,11*256+0	; Counter (B) = 11, (C) = 0
1478:	0C82' BE      	SCAN1A:	CP	(HL)		; Compare a char
1479:	0C83' 2001    		JR	NZ,SCAN1B	; ..jump if not same
1480:	0C85' 0C      		INC	C		; Else bump found counter
1481:	0C86' 23      	SCAN1B:	INC	HL		; ..point to next
1482:	0C87' 10F9    		DJNZ	SCAN1A		; Loop til done
1483:	0C89' 79      		LD	A,C		; Set results in reg
1484:	0C8A' B7      		OR	A		; ..and set flags
1485:	0C8B' C9      		RET
1486:			
1487:			;.....
1488:			; AI (allegedly intelligent) routine to check for a string
1489:			; containing legal option letters ONLY.
1490:			
1491:	0C8C' 7E      	OPTQ:	LD	A,(HL)
1492:	0C8D' D62F    		SUB	OPTC		; Slash is explicit option delim
1493:	0C8F' 2006    		JR	NZ,NOSLSH	; If not slash, do char. check
1494:	0C91' 77      		LD	(HL),A		; If slash, null it out (A = 0)
1495:	0C92' 2B      		DEC	HL
1496:	0C93' 77      		LD	(HL),A		; Null out leading space
1497:	0C94' 23      		INC	HL		; Adjust pointer to options
1498:	0C95' 23      		INC	HL
1499:	0C96' C9      		RET			; Return with Z flag
1500:			
1501:	0C97' 54      	NOSLSH:	LD	D,H		; Copy into de
1502:	0C98' 5D      		LD	E,L
1503:	0C99' AF      		XOR	A		; Search for terminating null
1504:	0C9A' 010B00  		LD	BC,OPTLEN	; Range for search
1505:	0C9D' EDB1    		CPIR			; Do short search
1506:	0C9F' 2802    		JR	Z,DOOPTQ	; Found null, proceed
1507:	0CA1' EB      		EX	DE,HL		; Otherwise too long for options
1508:	0CA2' C9      		RET			; Return with NZ
1509:			
1510:	0CA3' D5      	DOOPTQ:	PUSH	DE
1511:	0CA4' 1B      		DEC	DE
1512:	0CA5' 13      	BLOOP:	INC	DE
1513:	0CA6' 1A      		LD	A,(DE)
1514:	0CA7' B7      		OR	A
1515:	0CA8' 280C    		JR	Z,OQDONE	; End of string, return with Z
1516:	0CAA' 060B    		LD	B,OPTLEN
1517:	0CAC' 21D60C  		LD	HL,OPTLTR
1518:	0CAF' BE      	LLOOP:	CP	(HL)
1519:	0CB0' 28F3    		JR	Z,BLOOP
1520:	0CB2' 23      		INC	HL
1521:	0CB3' 10FA    		DJNZ	LLOOP		; If B ticks down, a failure!
1522:	0CB5' 05      		DEC	B		; Cheap NZ return
1523:			
1524:	0CB6' E1      	OQDONE:	POP	HL
1525:	0CB7' C9      		RET
1526:			
1527:			;.....
1528:			; Consolidated vectors to Get and Put stamps with Error Detection
1529:			
1530:	0CB8' CD0000  	PUTSTMP: CALL	PSTAMP		; Attempt Put Stamp to Disk
1531:	0CBB' 1803    		JR	GETST0		; ..and vector down to Error stuff
1532:			
1533:	0CBD' CD0000  	GETSTMP: CALL	GSTAMP		; Try to Get File Stamp
1534:	0CC0' C0      	GETST0:	RET	NZ		; ..return if Good
1535:	0CC1' 323A00  		LD	(DSFLAG),A	; Else disable stamping w/0 in A
1536:	0CC4' C9      		RET			; ..and return
1537:			
1538:			;.....
1539:			; Get base of Lowest Operating System component (CCP or RSX) which
1540:			; is the Top of memory usable for a copy buffer.
1541:			
1542:	0CC5' E5      	GETTOP:	PUSH	HL		; Save HL around this call
1543:	0CC6' 2A0900  		LD	HL,(Z3EADR)	; Get Z3 environment (if any)
1544:	0CC9' 7D      		LD	A,L
1545:	0CCA' B4      		OR	H
1546:	0CCB' F5      		PUSH	AF		; Save flag state
1547:	0CCC' C40000  		CALL	NZ,GZMTOP	; .check extended ENV if in Z-System
1548:	0CCF' F1      		POP	AF
1549:	0CD0' CC0000  		CALL	Z,GETMTOP	; ..else calculate base/rsx
1550:	0CD3' 7C      		LD	A,H		; Get returned Page for exit
1551:	0CD4' E1      		POP	HL		; .restore regs
1552:	0CD5' C9      		RET			; ..and back
1553:			
1554:			;.....
1555:			; Text and character variables
1556:			
1557:	0CD6' 4145494D	OPTLTR:	DEFB	'AEIMNOQRSVX'	; Added 'R' and 'X'
	      4E4F5152
	      535658
1558:			OPTLST:	DEFS	0
1559:	000B'         	OPTLEN	EQU	OPTLST-OPTLTR
1560:			
1561:			; Various message suffixes
1562:			
1563:	0CE1' 652000  	SUFFX1:	DEFB	'e ',0
1564:	0CE4' 696E6720	SUFFX2:	DEFB	'ing ',0
	      00
1565:			
1566:			;====================================================================
1567:			; Extracted from DDIRQ routine in DSLIB, which is based on SDIRQ.Z80
1568:			;  Ver 1.5 (Syslib) by Richard Conn.		Harold F. Bower
1569:			;====================================================================
1570:			; Entry: HL - Points to Memory Buffer
1571:			;	 DE - Points to FCB for selection (36 bytes)
1572:			; Exit :  A <> 0, Zero Flag Clear (NZ) if Ok
1573:			;	      A = 0 and Zero flag Set (Z) if TPA Overflow
1574:			;	 HL - Points to first file in Buffer
1575:			;	 BC - Contains number of files in Buffer
1576:			; Special Requirements: DMA address set to default of 80H.
1577:			;====================================================================
1578:			
1579:	0CE9' D5      	DDIRQ:	PUSH	DE		; Save ptr to FCB
1580:	0CEA' 220500  		LD	(TFCB),HL	; Set ptr to temp FCB
1581:	0CED' 3A1E00  		LD	A,(TYPDAT)	; Get DS Flag
1582:	0CF0' B7      		OR	A		; Going for DateStamper Stamps?
1583:	0CF1' 2814    		JR	Z,DDIRV0	; ..jump if P2Dos type
1584:	0CF3' E5      		PUSH	HL		; Save regs while we test for DS Routines
1585:	0CF4' D5      		PUSH	DE
1586:	0CF5' F5      		PUSH	AF		; ..including flag byte in A
1587:	0CF6' CD0000  		CALL	FINDCK		; Is DateStaper alive and well?
1588:	0CF9' 2808    		JR	Z,NODS		; ..jump to P2D if not
1589:	0CFB' CD0000  		CALL	CKTDF		; Do we have a valid !!!TIME&.DAT file?
1590:	0CFE' 2803    		JR	Z,NODS		; ..jump to MS/P2D if not
1591:	0D00' F1      		POP	AF		; Else we have everything ready for DS, Do it
1592:	0D01' 1802    		JR	DSOK		; ..bypass defaulting to P2D and continue
1593:			
1594:	0D03' F1      	NODS:	POP	AF		; Restore flag byte
1595:	0D04' AF      		XOR	A		; ..Clear since No DS
1596:	0D05' D1      	DSOK:	POP	DE		; Restore rest of regs
1597:	0D06' E1      		POP	HL
1598:	0D07' 320400  	DDIRV0:	LD	(S2FLG),A	; ..and save
1599:	0D0A' 012400  		LD	BC,36		; Offset to after FCB
1600:	0D0D' 09      		ADD	HL,BC		; ..useable memory now starts at (HL)
1601:	0D0E' CD0000  		CALL	DPARAMS		; Set parameters to logged disk
1602:			
1603:			; Set values in the Sort Selection Block
1604:			
1605:	0D11' EB      		EX	DE,HL		; Save in DE while we set up SSB
1606:	0D12' 2A0000  		LD	HL,(DIRMAX)	; Get Max Number of DIR entries
1607:	0D15' 220900  		LD	(FCOUNT),HL	; ..save in SSB
1608:	0D18' 211F00  		LD	HL,ESIZE	; Get size of records
1609:	0D1B' 220B00  		LD	(ELSIZ),HL	; ..save in SSB
1610:	0D1E' 210000  		LD	HL,0		; Let SSBINIT set buffer addr
1611:	0D21' 220700  		LD	(DSTART),HL
1612:	0D24' 2D      		DEC	L		; (0-->FF) Use pointers for sorting, Re-Order
1613:	0D25' 221100  		LD	(PTRFLG),HL	; ..place in POINTR (L) and NOREC (H) in SSB
1614:	0D28' 21C40E  		LD	HL,DICOMP	; Address User Compare routine
1615:	0D2B' 220D00  		LD	(COMPIT),HL	; ..place addr in SSB
1616:	0D2E' EB      		EX	DE,HL		; Put Memory base back in HL
1617:	0D2F' 110700  		LD	DE,SSB		; .point to SSB
1618:	0D32' CD0000  		CALL	SSBINIT		; ..and Initialize the sort routine
1619:	0D35' 220000  		LD	(DIRBUF),HL	; Save returned Record Buffer Address
1620:	0D38' D1      		POP	DE		; Get ptr to FCB
1621:	0D39' C44D0D  		CALL	NZ,DIRLOAD	; Load directory w/o sizing info (if space)
1622:	0D3C' C8      		RET	Z		; Abort if TPA overflow
1623:	0D3D' 110700  		LD	DE,SSB		; Set parm for Sort routine
1624:	0D40' CD0000  		CALL	SORT		; ..and do it!
1625:	0D43' 2A0700  		LD	HL,(DSTART)	; .and load exit parms
1626:	0D46' ED4B0900		LD	BC,(FCOUNT)
1627:	0D4A' F6FF    		OR	0FFH		; Set Ok status and return
1628:	0D4C' C9      		RET
1629:			
1630:			
1631:			; Build Directory Table at DIRBUF
1632:			;   This is the optimal Directory Load Routine; It only loads unique file names
1633:			; from disk, but the information is not sufficient to compute the file sizes
1634:			;
1635:			; On Input : HL pts to Directory Buffer (ESIZE x N Max)
1636:			;	     DE pts to FCB (Only 12 bytes needed)
1637:			; On Output: BC is Number of Files
1638:			;	     A = 0 and Zero Flag set if TPA Overflow
1639:			
1640:	0D4D' 220700  	DIRLOAD: LD	(DSTART),HL	; Set start of Buffer area
1641:	0D50' 13      		INC	DE		; Pt to file name
1642:	0D51' 2A0500  		LD	HL,(TFCB)	; Pt to TFCB
1643:	0D54' AF      		XOR	A		; Else set for current user
1644:	0D55' 77      		LD	(HL),A		; Stash User Selects
1645:	0D56' 23      		INC	HL		; Pt to File Name in TFCB
1646:	0D57' 010B00  		LD	BC,11		; 11 Chars
1647:	0D5A' EB      		EX	DE,HL
1648:	0D5B' EDB0    		LDIR			; Copy the Name and Type
1649:	0D5D' EB      		EX	DE,HL
1650:			
1651:	0D5E' 0618    		LD	B,24		; 24 chars (Incl Zero EX)
1652:	0D60' AF      		XOR	A		; Zero rest of TFCB
1653:			
1654:	0D61' 77      	DLLOOP1: LD	(HL),A		; Store Zero
1655:	0D62' 23      		INC	HL		; Pt to next
1656:	0D63' 10FC    		DJNZ	DLLOOP1		; Count down
1657:			
1658:	0D65' 6F      		LD	L,A		; Initialize counters (A has null)
1659:	0D66' 67      		LD	H,A
1660:	0D67' 220900  		LD	(FCOUNT),HL	; Total Files on Disk = 0
1661:			
1662:			; Begin by setting default DMA address to 80H
1663:			
1664:	0D6A' 118000  		LD	DE,BUFF		; Set DMA address to default
1665:	0D6D' 0E1A    		LD	C,SDMA
1666:	0D6F' CD0500  		CALL	BDOSE
1667:			
1668:			; Now we begin scanning for files to place into the memory buffer
1669:			
1670:	0D72' 0E11    		LD	C,SRCHF		; Search for file
1671:	0D74' 1807    		JR	DIRLP1
1672:			
1673:	0D76' CDE90D  	DIRLP:	CALL	PENTRY		; Place entry in Dir
1674:	0D79' 2869    		JR	Z,DIRDNX	; Memory Overflow Error
1675:	0D7B' 0E12    		LD	C,SRCHN		; Search for Next match
1676:	0D7D' ED5B0500	DIRLP1:	LD	DE,(TFCB)	; Pt to FCB
1677:	0D81' CD0000  		CALL	FSTNXT
1678:	0D84' FEFF    		CP	255		; Done?
1679:	0D86' 20EE    		JR	NZ,DIRLP
1680:			
1681:	0D88' 3A0400  		LD	A,(S2FLG)	; Loading P2D/NZTIME Stamps?
1682:	0D8B' B7      		OR	A
1683:	0D8C' 2854    		JR	Z,DIRPDN	; ..jump to exit if so
1684:			
1685:			; We are using DateStamper stamps, so append stamps to FN.FT string
1686:			
1687:	0D8E' AF      		XOR	A		; Open T&D for Read-only
1688:	0D8F' CD0000  		CALL	OPENTD		; ..don't check errs cause CKTD was Ok
1689:	0D92' ED4B0900		LD	BC,(FCOUNT)	; Load this many records
1690:	0D96' 2A0700  		LD	HL,(DSTART)	; ..starting with this entry
1691:	0D99' 11FFFF  		LD	DE,0FFFFH	; Set dummy Random record # to force read
1692:			
1693:	0D9C' 78      	TDLOOP:	LD	A,B		; Are we done?
1694:	0D9D' B1      		OR	C
1695:	0D9E' 283F    		JR	Z,DIRDDN	; ..exit if so
1696:	0DA0' C5      		PUSH	BC		; Save count
1697:	0DA1' 011000  		LD	BC,FNSIZE	; Offset to RR #
1698:	0DA4' 09      		ADD	HL,BC
1699:	0DA5' 7E      		LD	A,(HL)		; Get Index #
1700:	0DA6' E5      		PUSH	HL		; Save index to entry TD Field
1701:	0DA7' F5      		PUSH	AF		; ..and index
1702:	0DA8' 23      		INC	HL
1703:	0DA9' 7E      		LD	A,(HL)		; Get RR # to HL
1704:	0DAA' 23      		INC	HL
1705:	0DAB' 66      		LD	H,(HL)
1706:	0DAC' 6F      		LD	L,A
1707:	0DAD' B7      		OR	A		; Compare current (DE) w/desired (HL)
1708:	0DAE' ED52    		SBC	HL,DE
1709:	0DB0' 19      		ADD	HL,DE
1710:	0DB1' 2812    		JR	Z,SAMREC	; ..jump if we already have the record
1711:	0DB3' EB      		EX	DE,HL		; Else put rec in DE
1712:	0DB4' D5      		PUSH	DE		; ..and save
1713:	0DB5' AF      		XOR	A
1714:	0DB6' CD0000  		CALL	RWTD		; Read the T&D file ignoring errors
1715:	0DB9' 221300  		LD	(TDBUF),HL	; Save TD buffer start addr
1716:	0DBC' 2006    		JR	NZ,TDRDOK	; ..jump if T&D File Read Ok
1717:	0DBE' 0680    		LD	B,128		; Else Null record (A already = 0)
1718:	0DC0' 77      	TDNULL:	LD	(HL),A
1719:	0DC1' 23      		INC	HL
1720:	0DC2' 10FC    		DJNZ	TDNULL		; Loop til sector filled
1721:	0DC4' D1      	TDRDOK:	POP	DE		; ..and restore RR #
1722:	0DC5' F1      	SAMREC:	POP	AF		; Restore record Index
1723:	0DC6' 87      		ADD	A,A		; ..and mult by 16 to get relative addr
1724:	0DC7' 87      		ADD	A,A
1725:	0DC8' 87      		ADD	A,A
1726:	0DC9' 87      		ADD	A,A
1727:	0DCA' 4F      		LD	C,A
1728:	0DCB' 0600    		LD	B,0
1729:	0DCD' 2A1300  		LD	HL,(TDBUF)
1730:	0DD0' 09      		ADD	HL,BC		; HL Now points at source T&D string in Buffer
1731:	0DD1' EB      		EX	DE,HL		; Swap regs..
1732:	0DD2' E3      		EX	(SP),HL		; ..to put RR # on stack, DEst adr in HL
1733:	0DD3' EB      		EX	DE,HL		; ...then Dest in DE, source in HL
1734:	0DD4' 010F00  		LD	BC,15		; Move all three stamps
1735:	0DD7' EDB0    		LDIR
1736:	0DD9' EB      		EX	DE,HL		; HL --> Next Dir entry
1737:	0DDA' D1      		POP	DE		; DE = RR # in Buff
1738:	0DDB' C1      		POP	BC		; BC = Count
1739:	0DDC' 0B      		DEC	BC
1740:	0DDD' 18BD    		JR	TDLOOP		; ..and loop til done
1741:			
1742:			; Now we are done with the Load -- Set up Return Values
1743:			
1744:	0DDF' CD0000  	DIRDDN:	CALL	CLOSTD		; Close the T&D tile for safety
1745:	0DE2' F6FF    	DIRPDN:	OR	0FFH		; Set Flags NZ for Load Ok
1746:	0DE4' ED4B0900	DIRDNX:	LD	BC,(FCOUNT)	; Get total number of files in BC
1747:	0DE8' C9      		RET
1748:			
1749:			
1750:			; PENTRY -- Place entry in Directory Buffer if not an erased entry
1751:			
1752:			; On Input:  A = 0-3 for Adr index in Buff of Entry FCB
1753:			;	     FCOUNT = Number of files in Dir so far
1754:			; On Output: FCOUNT = Number of files in dir so far
1755:			;	     A = 0 and Zero Flag Set if Memory Overflow Error
1756:			
1757:	0DE9' 320300  	PENTRY:	LD	(INDX),A	; Save index in case of P2Dos Stamp load
1758:	0DEC' D5      		PUSH	DE		; Save any DS Indices
1759:	0DED' C5      		PUSH	BC
1760:	0DEE' 0F      		RRCA			; Multiply by 32 for Offset computation
1761:	0DEF' 0F      		RRCA
1762:	0DF0' 0F      		RRCA
1763:			;;	AND	60H		; A = Byte Offset
1764:	0DF1' 118000  		LD	DE,BUFF		; Pt to Buffer Entry
1765:	0DF4' 6F      		LD	L,A		; Let HL = Offset
1766:	0DF5' 2600    		LD	H,0
1767:	0DF7' 19      		ADD	HL,DE		; HL = Ptr to FCB
1768:			
1769:	0DF8' 7E      		LD	A,(HL)
1770:	0DF9' FE20    		CP	20H		; Is it CP/M Plus Volume or T&D?
1771:	0DFB' D2860E  		JP	NC,PEDONE	; ..jump if so
1772:			
1773:			; HL = Adr of FCB in BUFF.  Check for attributes of file
1774:			
1775:	0DFE' E5      		PUSH	HL		; Save ptr
1776:	0DFF' 010A00  		LD	BC,10		; Pt to System Attribute
1777:	0E02' 09      		ADD	HL,BC
1778:	0E03' CB7E    		BIT	7,(HL)		; Check for System Attribute
1779:	0E05' E1      		POP	HL		; Restore ptr
1780:	0E06' 2806    		JR	Z,ATDIR		; ..jump if Not System File (Selflg in A)
1781:	0E08' 3A1D00  		LD	A,(SYSEXC)
1782:	0E0B' B7      		OR	A		; Are we including SYStem Files?
1783:	0E0C' 2078    		JR	NZ,PEDONE	; ..jump if Not
1784:						;..Else fall thru to continue
1785:			
1786:			; Increment total number of files
1787:			
1788:	0E0E' ED5B0900	ATDIR:	LD	DE,(FCOUNT)	; Total Files = Total Files + 1
1789:	0E12' 13      		INC	DE
1790:	0E13' ED530900		LD	(FCOUNT),DE
1791:			
1792:			; Copy FCB pted to by HL into Directory Buffer
1793:			
1794:	0E17' ED5B0000		LD	DE,(DIRBUF)	; Pt to Next Entry location
1795:	0E1B' 011000  		LD	BC,FNSIZE	; Number of Bytes/Entry
1796:	0E1E' EDB0    		LDIR			; Copy FCB into Memory Buffer
1797:	0E20' C1      		POP	BC		; Restore any DS indices
1798:	0E21' E1      		POP	HL
1799:	0E22' 3A0400  		LD	A,(S2FLG)	; Which method do we use?
1800:	0E25' B7      		OR	A
1801:	0E26' 280C    		JR	Z,USEMS		; ..jump if using MS/P2Dos/NZTime stamps
1802:	0E28' EB      		EX	DE,HL		; Put destination in HL
1803:	0E29' 70      		LD	(HL),B		; Stash index into T&D sector
1804:	0E2A' 23      		INC	HL
1805:	0E2B' 73      		LD	(HL),E		; ..and T&D Sector number
1806:	0E2C' 23      		INC	HL
1807:	0E2D' 72      		LD	(HL),D
1808:	0E2E' 23      		INC	HL
1809:	0E2F' EB      		EX	DE,HL		; Put Buffer pointer back in DE
1810:	0E30' 060C    		LD	B,ESIZE-FNSIZE-3
1811:	0E32' 1843    		JR	FILLIT		; Null out remaining
1812:			
1813:	0E34' 219000  	USEMS:	LD	HL,BUFF+16	; Point to DosDisk Flag bytes
1814:	0E37' 7E      		LD	A,(HL)		; Get first byte
1815:	0E38' FEFD    		CP	0FDH		; Is it the MS-DOS 40-byte flag?
1816:	0E3A' 2011    		JR	NZ,USEP2D	; ..jump if not
1817:	0E3C' 23      		INC	HL		; Else check second byte to be sure
1818:	0E3D' 96      		SUB	(HL)
1819:	0E3E' 200D    		JR	NZ,USEP2D	; ..jump if no match
1820:	0E40' 060A    		LD	B,10		; Ok, so null Create and Access fields
1821:	0E42' CDED0E  		CALL	NULLIT
1822:	0E45' 219600  		LD	HL,BUFF+22	; Point to source MS-DOS DateSpec
1823:	0E48' CD0000  		CALL	M2UTIM		; ..and do the conversions to DE
1824:	0E4B' 182D    		JR	P2DONE		; Continue with common code
1825:			
1826:	0E4D' 21E000  	USEP2D:	LD	HL,BUFF+60H	; Point to P2D Time indicator
1827:	0E50' 7E      		LD	A,(HL)
1828:	0E51' E67F    		AND	7FH		; Mask difference between Z2D and NZTime
1829:	0E53' FE21    		CP	21H		; Is there a valid time stamp flag?
1830:	0E55' 201E    		JR	NZ,NOTP2D	; ..jump if not
1831:	0E57' 3A0300  		LD	A,(INDX)	; Else calculate offset to correct entry
1832:	0E5A' 4F      		LD	C,A
1833:	0E5B' 87      		ADD	A,A		; *2
1834:	0E5C' 87      		ADD	A,A		; *4
1835:	0E5D' 81      		ADD	A,C		; *5
1836:	0E5E' 87      		ADD	A,A		; *10
1837:	0E5F' 3C      		INC	A		; +1
1838:	0E60' 4F      		LD	C,A		; Entries start at offset=1,11,21 decimal
1839:	0E61' 0600    		LD	B,0
1840:	0E63' 7E      		LD	A,(HL)		; Get Flag Byte (A1=NZTime, 21=P2Dos)
1841:	0E64' 09      		ADD	HL,BC		; Point to Stamp field for desired entry
1842:	0E65' 17      		RLA			; Is it NzTime?
1843:	0E66' 3823    		JR	C,USENZT	; ..jump if NZTime Stamping
1844:	0E68' CD0000  		CALL	P2UTIM		; ..and parse Create Stamp to Table
1845:	0E6B' 0605    		LD	B,5		; Null the Last Accessed field
1846:	0E6D' CDED0E  		CALL	NULLIT
1847:	0E70' CD0000  		CALL	P2UTIM		; Parse Modify Stamp
1848:	0E73' 1805    		JR	P2DONE		; ..and continue
1849:			
1850:	0E75' 060F    	NOTP2D:	LD	B,ESIZE-FNSIZE	; Set count to fill entire field
1851:	0E77' CDED0E  	FILLIT:	CALL	NULLIT		; Fill rest of time with Nulls
1852:	0E7A' ED530000	P2DONE:	LD	(DIRBUF),DE	; Set ptr to Next Entry
1853:	0E7E' CD0000  		CALL	GETMTOP		; Return highest avail addr in HL
1854:	0E81' 7C      		LD	A,H		; Get CCP page in A
1855:	0E82' 3D      		DEC	A		; ..and back one page in front of it
1856:	0E83' BA      		CP	D		; Is ptr to next entry beyond this?
1857:	0E84' C8      		RET	Z
1858:			
1859:	0E85' 11      		DEFB	11H		; Fall thru trashing DE
1860:			
1861:			; Done with PENTRY and No Error
1862:			
1863:	0E86' C1      	PEDONE:	POP	BC		; Clear the stack
1864:	0E87' D1      		POP	DE
1865:	0E88' F6FF    		OR	0FFH		; Set NZ for No Error
1866:	0E8A' C9      		RET
1867:			
1868:			; Gather File Stamps from NZTime-stamped directory
1869:			
1870:	0E8B' 220000  	USENZT:	LD	(IPTR),HL	; Save Pointer to input NZTime stamps
1871:	0E8E' 6E      		LD	L,(HL)
1872:	0E8F' 3A0300  		LD	A,(INDX)	; Get Index number (0,1,2)
1873:	0E92' 47      		LD	B,A		; .save
1874:	0E93' 3E08    		LD	A,8
1875:	0E95' 90      		SUB	B		; Compute current byte when starting
1876:	0E96' 4F      		LD	C,A		;  save
1877:	0E97' 04      		INC	B
1878:	0E98' 05      		DEC	B		; Is Input byte already aligned?
1879:	0E99' 2803    		JR	Z,USENZ1	; ..jump if so
1880:	0E9B' 29      	USENZ0:	ADD	HL,HL		; Else rotate input byte (H is don't care)
1881:	0E9C' 10FD    		DJNZ	USENZ0		; ..looping til done
1882:	0E9E' 3E03    	USENZ1:	LD	A,3		; Get all three stamps
1883:	0EA0' 320200  	USENZ2:	LD	(LPCTR),A	; Set Outer Loop Counter
1884:	0EA3' 0607    		LD	B,7
1885:	0EA5' CDF30E  		CALL	GBITS		; Get Year (7 bits)
1886:	0EA8' 0604    		LD	B,4
1887:	0EAA' CDF30E  		CALL	GBITS		; Month (4 bits)
1888:	0EAD' 0605    		LD	B,5
1889:	0EAF' CDF30E  		CALL	GBITS		; Day (5 bits)
1890:	0EB2' 0605    		LD	B,5
1891:	0EB4' CDF30E  		CALL	GBITS		; Hour (5 bits)
1892:	0EB7' 0606    		LD	B,6
1893:	0EB9' CDF30E  		CALL	GBITS		; Minute (6 bits)
1894:	0EBC' 3A0200  		LD	A,(LPCTR)
1895:	0EBF' 3D      		DEC	A		; Have we done all 3 fields?
1896:	0EC0' 20DE    		JR	NZ,USENZ2	; .loop if Not (saving new count)
1897:	0EC2' 18B6    		JR	P2DONE		; ..jump to exit when finished
1898:			
1899:			;========================================================================
1900:			; NAME - DICOMP.  Compare the directory entry pointed to by HL with that
1901:			;		addressed by DE.
1902:			; Entry: HL - Points to one FCB extracted entry
1903:			;	 DE - Points to second FCB extracted entry
1904:			; Exit :  F - Carry Set (C) means (DE) < (HL)
1905:			;		Zero Set (Z) means (DE) = (HL)
1906:			;		Non-Zero (NZ) and No Carry (NC) mans (DE) > (HL)
1907:			;========================================================================
1908:			
1909:	0EC4' C5      	DICOMP:	PUSH	BC		; Save count
1910:	0EC5' 060B    		LD	B,11		; 11 bytes for FN and FT
1911:	0EC7' E5      		PUSH	HL
1912:	0EC8' D5      		PUSH	DE
1913:	0EC9' 23      		INC	HL		; Pt to FN
1914:	0ECA' 13      		INC	DE
1915:	0ECB' CD0000  		CALL	@FNCMP		; Do comparison
1916:	0ECE' D1      		POP	DE
1917:	0ECF' E1      		POP	HL
1918:	0ED0' 2019    		JR	NZ,CMPEX
1919:	0ED2' 1A      		LD	A,(DE)		; Compare User Number
1920:	0ED3' BE      		CP	(HL)
1921:	0ED4' 2015    		JR	NZ,CMPEX	; ..exit if No match
1922:	0ED6' E5      		PUSH	HL		; Else save ptrs
1923:	0ED7' D5      		PUSH	DE
1924:	0ED8' 010E00  		LD	BC,14
1925:	0EDB' EB      		EX	DE,HL		; Swap
1926:	0EDC' 09      		ADD	HL,BC		; .offset File 1 to DM
1927:	0EDD' EB      		EX	DE,HL		; ..swap
1928:	0EDE' 09      		ADD	HL,BC		; ...offset File 2 to DM
1929:	0EDF' 1A      		LD	A,(DE)
1930:	0EE0' BE      		CP	(HL)		; Compare Data Modules
1931:	0EE1' 2006    		JR	NZ,CMPEX0	; ..jump if Not Same
1932:	0EE3' 2B      		DEC	HL		; Else back down to EXT
1933:	0EE4' 2B      		DEC	HL
1934:	0EE5' 1B      		DEC	DE
1935:	0EE6' 1B      		DEC	DE
1936:	0EE7' 1A      		LD	A,(DE)		; Fetch EX file 1
1937:	0EE8' BE      		CP	(HL)		; ..compare to EX file 2 and return status
1938:	0EE9' D1      	CMPEX0:	POP	DE		; Restore regs
1939:	0EEA' E1      		POP	HL
1940:	0EEB' C1      	CMPEX:	POP	BC		; Restore Count
1941:	0EEC' C9      		RET			; ..and exit
1942:			
1943:			;.....
1944:			; Fill the string addressed by DE with a zero for B bytes
1945:			
1946:	0EED' AF      	NULLIT:	XOR	A		; Load a cheap Null
1947:	0EEE' 12      	NULL0:	LD	(DE),A		; Stuff a byte
1948:	0EEF' 13      		INC	DE		; ..and advance
1949:	0EF0' 10FC    		DJNZ	NULL0		; Loop til done
1950:	0EF2' C9      		RET
1951:			
1952:			;.....
1953:			; NZTime Support Routine.  Gather # of bits speced from NZTIM, Return BCD Digit
1954:			; ENTER: L = Current working byte
1955:			;	DE = Ptr to Dest of Univ stamps
1956:			;	 C = Bit # currently in position (8..1)
1957:			;	 B = Number of bits to gather
1958:			; EXIT : A = BCD Conversion of # bits from entry
1959:			
1960:	0EF3' 2600    	GBITS:	LD	H,0		; Clear Bit Accumulator
1961:	0EF5' 29      	GBITS0:	ADD	HL,HL		; Shift B7 of L into B0 of H, H shifts left
1962:	0EF6' 0D      		DEC	C		; Have we shifted last of input Byte?
1963:	0EF7' 200D    		JR	NZ,GBITS1	; ..jump if Not
1964:			
1965:	0EF9' E5      		PUSH	HL		; Else need a byte, save regs
1966:	0EFA' 2A0000  		LD	HL,(IPTR)	; Get input ptr
1967:	0EFD' 23      		INC	HL		; .go to next byte
1968:	0EFE' 7E      		LD	A,(HL)		; ..fetch
1969:	0EFF' 220000  		LD	(IPTR),HL	; ...save updated ptr
1970:	0F02' E1      		POP	HL		; .(restore regs)
1971:	0F03' 6F      		LD	L,A		; Place new Input byte for shifting
1972:	0F04' 0E08    		LD	C,8		;  and init Bits Remaining counter
1973:			
1974:	0F06' 10ED    	GBITS1:	DJNZ	GBITS0		; ..Shift another if not done
1975:	0F08' 7C      		LD	A,H		; Else get completed output byte
1976:	0F09' CD0000  		CALL	BIN2BCD		; .make BCD for Universal
1977:	0F0C' 12      		LD	(DE),A		; ..store in Output
1978:	0F0D' 13      		INC	DE		; ...and advance to next digit
1979:	0F0E' C9      		RET
1980:			
1981:			;====================================================================
1982:			; Adapted from SDIR09.Z80 Ver 1.5 by Richard Conn to handle larger
1983:			; records needed by DSLib "type" routines.			HFB
1984:			;====================================================================
1985:			; Entry: HL - Points to a Directory Buffer
1986:			;	 BC - Contains the total number of files in Buffer
1987:			; Exit : BC - Number of Selected files.  Buffer is restructured
1988:			; Uses : BC
1989:			; Special Requirements: Required side effect is that the Flag
1990:			;	Extent (Set by DIR:) be correct.  In most cases, default
1991:			;	of 0 is Ok, except when extent size is greater than 16K
1992:			;====================================================================
1993:			
1994:	0F0F' E5      	DIRPAK:	PUSH	HL		; Save Regs
1995:	0F10' D5      		PUSH	DE
1996:	0F11' F5      		PUSH	AF
1997:	0F12' C5      		PUSH	BC		; Save counter
1998:	0F13' 010000  		LD	BC,0
1999:	0F16' ED430900		LD	(FCOUNT),BC	; Init file count
2000:	0F1A' 5D      		LD	E,L		; Copy Buffer start to DE
2001:	0F1B' 54      		LD	D,H
2002:			
2003:	0F1C' C1      	DPLOOP:	POP	BC		; Get counter
2004:	0F1D' 78      		LD	A,B		; Check for Done
2005:	0F1E' B1      		OR	C
2006:	0F1F' 281B    		JR	Z,DPDONE
2007:	0F21' 0B      		DEC	BC		; Count down
2008:	0F22' C5      		PUSH	BC		; Save counter
2009:	0F23' 011F00  		LD	BC,ESIZE	; Set number of bytes in entry
2010:	0F26' CB7E    		BIT	7,(HL)		; Does 1st byte indicate file is selected?
2011:	0F28' 280F    		JR	Z,DPNEXT	; ..jump and advance to next if not
2012:			
2013:			; Found Selected Entry
2014:			
2015:	0F2A' CBBE    		RES	7,(HL)		; Clear MSB of selected entry
2016:	0F2C' EDB0    		LDIR			; Copy the entry to current bottom of byffer
2017:	0F2E' ED4B0900		LD	BC,(FCOUNT)	; Increment File Count
2018:	0F32' 03      		INC	BC
2019:	0F33' ED430900		LD	(FCOUNT),BC
2020:	0F37' 18E3    		JR	DPLOOP		; Continue
2021:			
2022:			; Skip to Next Entry
2023:			
2024:	0F39' 09      	DPNEXT:	ADD	HL,BC		; Skip over entry
2025:	0F3A' 18E0    		JR	DPLOOP		; Continue
2026:			
2027:			; Compression Complete -- Set up returned values
2028:			
2029:	0F3C' ED4B0900	DPDONE:	LD	BC,(FCOUNT)	; Put File Count in BC
2030:	0F40' F1      		POP	AF		; Restore regs
2031:	0F41' D1      		POP	DE
2032:	0F42' E1      		POP	HL
2033:	0F43' C9      		RET
2034:			
2035:			;++++++++++++++++++++++++++++++++++++++++++++++++++++++
2036:			;		   D a t a    A r e a
2037:			;++++++++++++++++++++++++++++++++++++++++++++++++++++++
2038:			
2039:				DSEG
2040:			
2041:			;---- Data Storage/Buffers for DDIRQ Routine ----
2042:			
2043:	0000"         	IPTR:	DEFS	2		; Pointer for NZTime conversion
2044:	0002"         	LPCTR:	DEFS	1		; Loop Counter for NZTime conversion
2045:			
2046:	0003"         	INDX:	DEFS	1		; Directory index into sector
2047:	0004"         	S2FLG:	DEFS	1		; Secondary Select Flag (Sort & Stamp method)
2048:	0005"         	TFCB:	DEFS	2		; Address of Temporary FCB
2049:			
2050:	0007"         	SSB:				;\ Sort Selection Block:
2051:	0007"         	DSTART:	DEFS	2		;| Pointer to first Directory Entry
2052:	0009"         	FCOUNT:	DEFS	2		;| Tot Number of Files/Number of Selected Files
2053:	000B"         	ELSIZ:	DEFS	2		;| Size of each element
2054:	000D"         	COMPIT:	DEFS	2		;| Addr of compare routine
2055:	000F"         	ORDBUF:	DEFS	2		;| Addr of Order buffer
2056:	0011"         	PTRFLG:	DEFS	1		;| FF=Use ptrs, 0=No ptrs
2057:	0012"         		DEFS	1		;/ If Ptrflg<>0, FF=No reorder, 0=Reorder
2058:			
2059:	0013"         	TDBUF:	DEFS	2		; Temp storage loc'n for T&D Sector Buffer adr
2060:			
2061:			;---- End of Data area used by DDIRQ routine ----
2062:			; Pointers
2063:			
2064:	0015"         	DATABG	EQU	$
2065:	0015"         	MFPTR:	DEFS	2		; Ptr to first char of next fn spec
2066:	0017"         	NXTPTR:	DEFS	2		; Ptr to next fn spec in line
2067:	0019"         	WORKBF:	DEFS	2		; Ptr to beginning of work buffer
2068:			
2069:			;   ----- Do Not Change following values -----
2070:	001B"         	CPYTBL:				; ..flags copied from default table
2071:	001B"         	VERFLG:	DEFS	1		; Verify
2072:	001C"         	INSP:	DEFS	1		; Inspect
2073:	001D"         	SYSEXC:	DEFS	1		; Exclude system files
2074:	001E"         	NCOPY:	DEFS	1		; Multiple copy
2075:	001F"         	EXIST:	DEFS	1		; Test for existence flag
2076:	0020"         	EXRO:	DEFS	1		; Test for R/O existence flag
2077:	0021"         	ARCHIV:	DEFS	1		; Archive flag
2078:	0022"         	REPLAC:	DEFS	1		; Replace flag (Copy if exists)
2079:	0008"         	TBLLEN	EQU	$-CPYTBL
2080:			;	----- End of no change area -----
2081:			
2082:			; Disks and Users
2083:			
2084:	0023"         	CDISK:	DEFS	1		; Current disk
2085:	0024"         	SUSER:	DEFS	1		; Source user
2086:	0025"         	SDRIVE:	DEFS	1		; ..Source disk
2087:	0026"         	DUSER:	DEFS	1		; Destination user
2088:	0027"         		DEFS	1		; ..Destination disk
2089:			
2090:			; CRC Value
2091:			
2092:	0028"         	CRCVAL:	DEFS	2		; CRC check value
2093:			
2094:			; FCBS & FCBD
2095:			
2096:	002A"         	FCBS:	DEFS	2		; Source FCB
2097:	002C"         	FCBD:	DEFS	2		; Destination FCB
2098:			
2099:			; Counts and Flags
2100:			
2101:	002E"         	PAGLIM:	DEFS	1		; Max number of pages in work buffer
2102:	002F"         	LSTCPY:	DEFS	1		; Last file was copied flag
2103:	0030"         	VERCNT:	DEFS	1		; Error count
2104:	0031"         	BCNT:	DEFS	1		; Block count
2105:	0032"         	CONT:	DEFS	1		; Continue flag (0=no, 0FFH=yes)
2106:	0033"         	NOMSGS:	DEFS	1		; 0FFH if there is no ZCPR3 message buffer
2107:	0034"         	NORST:	DEFS	1		; Disk reset flag (0=do reset)
2108:	0035"         	ROFLG:	DEFS	1		; Dest file R/O flag
2109:	0036"         	RPQFLG:	DEFS	1		; Replace queery flag (0=replace w/o asking)
2110:	0037"         	XMOVE:	DEFS	1		; Delete source after copy flag (Move)
2111:	0038"         	QUIET:	DEFS	1		; Quiet
2112:	0039"         	NOREPL:	DEFS	1		; No copy if file already on dest. flag
2113:	003A"         	DSFLAG:	DEFS	1		; DateStamper active flag
2114:	003B"         	TMPTIM:	DEFS	6		; Temporary Clock Date/Time buffer
2115:	0041"         	SRCTD:	DEFS	15		; Source Time & Date buffer
2116:	0050"         	DESTTD:	DEFS	15		; Destination Time &Date Buffer
2117:	005F"         	HAVFIL:	DEFS	1		; Flag to indicate filecount. 0=No Files
2118:	0060"         	RENFLG:	DEFS	1		; 0 = No rename, <>0 for rename opn
2119:	0061"         	REPLCK:	DEFS	1		; Flag for Replacement abort (MCOPYX sets)
2120:	0062"         	CPYERR:	DEFS	1		; 0=No error in Verify, FF=Verify err
2121:			
2122:			; Dynamic Buffers
2123:			
2124:	0063"         	INLINE:	 DEFS	2		; Input line buffer
2125:	0065"         	FREEBUF: DEFS	2		; Free space buffer
2126:	0067"         	PUBS:	 DEFS	2		; ZRDOS PUBLIC bytes from ENV+0FEH
2127:	0069"         		 DEFS	64		; Space for local Stack
2128:	00A9"         	STACK:	 DEFS	2		; Opsys stack ptr
2129:			
2130:			; Print a string in [HL] up to '$'
2131:	00AB"         	PSTRING:
2132:	00AB" 7E      		LD	A,(HL)
2133:	00AC" FE24    		CP	'$'
2134:	00AE" C8      		RET	Z
2135:	00AF" 4F      		LD	C,A
2136:	00B0" CD9FFD  		CALL	BBCONOUT
2137:	00B3" 23      		INC	HL
2138:	00B4" C3AB00  		JP	PSTRING
2139:			
2140:			;;
2141:			;; Inline print
2142:			;;
2143:	00B7"         	DINLINE:
2144:	00B7" E3      		EX	(SP),HL			; get address of string (ret address)
2145:	00B8" CDAB00  		CALL	PSTRING
2146:	00BB" E3      		EX	(SP),HL			; load return address after the '$'
2147:	00BC" C9      		RET				; back to code immediately after string
2148:			
2149:	00BD" F5      	PHEX:	PUSH	AF
2150:	00BE" C5      		PUSH	BC
2151:	00BF" F5      		PUSH	AF
2152:	00C0" 0F      		RRCA
2153:	00C1" 0F      		RRCA
2154:	00C2" 0F      		RRCA
2155:	00C3" 0F      		RRCA
2156:	00C4" CDCE00  		CALL	ZCONV
2157:	00C7" F1      		POP	AF
2158:	00C8" CDCE00  		CALL	ZCONV
2159:	00CB" C1      		POP	BC
2160:	00CC" F1      		POP	AF
2161:	00CD" C9      		RET
2162:			;
2163:	00CE" E60F    	ZCONV:	AND	0FH		;HEX to ASCII and print it
2164:	00D0" C690    		ADD	A,90H
2165:	00D2" 27      		DAA
2166:	00D3" CE40    		ADC	A,40H
2167:	00D5" 27      		DAA
2168:	00D6" 4F      		LD	C,A
2169:	00D7" CD9FFD  		CALL	BBCONOUT
2170:	00DA" C9      		RET
2171:			
2172:	00DB"         	OLDSTACK:
2173:	00DB" 0000    		DEFW	0
2174:	00DD"         		DEFS	40
2175:	0105"         	NEWSTACK:
2176:	0105" 0000    		DEFW	0
2177:			
2178:			
2179:	0107"         		END



Statistics:

     6	passes
     0	jr promotions
   431	symbols
     0	bytes

     2	macro calls
   107	macro bytes
     0	invented symbols



Symbol Table:

@fncmp             0      (extern)
abortck          bb3'    
amberr           c00'    
archiv            21"    
atdir            e0e'    
backdir           22'    
badcopy          a0d'    
bbcalret       =fd5a     
bbconin        =fd94     
bbconout       =fd9f     
bbconst        =fdaa     
bbcpboot       =fcc3     
bbcrtcini      =fc03     
bbcrtfill      =fc09     
bbcurset       =fc21     
bbdiv16        =fcdb     
bbdmaset       =fcb7     
bbdprmset      =fd17     
bbdriveid      =fcf3     
bbdsksel       =fcbd     
bbeidck        =fd23     
bbepmngr       =fd1d     
bbexec         =fd29     
bbfdrvsel      =fcd5     
bbfhome        =fc81     
bbflopio       =fc93     
bbfread        =fc87     
bbfwrite       =fc8d     
bbhdboot       =fd0b     
bbhdgeo        =fd05     
bbhdinit       =fced     
bbhdrd         =fcff     
bbhdwr         =fcf9     
bbinictc       =fc57     
bbjtobnk       =fc00     
bbldpart       =fd11     
bbmul16        =fce1     
bboffcal       =fce7     
bbprcvblk      =fc6f     
bbprnchr       =fc99     
bbpsndblk      =fc63     
bbrdtime       =fca5     
bbrdvdsk       =fc75     
bbresctc       =fc5d     
bbsecset       =fcb1     
bbsidset       =fccf     
bbstack        =feb4     
bbstbase       =fe90     
bbsttim        =fc9f     
bbtrkset       =fcab     
bbu0ini        =fc39     
bbu1ini        =fc51     
bbu1rx         =fc45     
bbu1st         =fc4b     
bbu1tx         =fc3f     
bbuplchr       =fc69     
bbvcpmbt       =fcc9     
bbvoid         =fd6a     
bbwrvdsk       =fc7b     
bcnt              31"    
bdos               0      (extern)
bdose          =   5     
bin2bcd            0      (extern)
bloop            ca5'    
buff           =  80     
caps               0      (extern)
cdate             3a     
cdisk             23"    
chkda0           9aa'    
chkdat           999'    
chkex0           b4c'    
chkex1           b56'    
chkx??           b76'    
chkxcl           b4a'    
chkxx0           b64'    
chkxx1           b6c'    
chkxx2           b7e'    
chkxx3           b7b'    
chkxxx           b62'    
cin                0      (extern)
ckatt0           996'    
ckattl           96e'    
ckattr           98f'    
cksamu           649'    
cktdf              0      (extern)
clostd             0      (extern)
clratt           7c3'    
cmder            1de'    
cmder1           1df'    
cmder3           1f2'    
cmpex            eeb'    
cmpex0           ee9'    
codend             0      (extern)
comnam           c5c'    
comnml           c67'    
compit             d"    
condin             0      (extern)
cont              32"    
copy             52f'    
copyaa           682'    
copybb           690'    
copyt            57d'    
copyt1           5a1'    
cout               0      (extern)
cpm              515'    
cpyerr            62"    
cpytbl            1b"    
cr             =   d     
crc3clr            0      (extern)
crc3done           0      (extern)
crc3init           0      (extern)
crc3upd            0      (extern)
crcval            28"    
crdureg        =fc27     
crlf               0      (extern)
ctdlp            853'    
ctrlc          =   3     
cvers          =   b     
darchv            1c'    
databg         =  15"    
date               0     
datex            888'    
dddisk            21'    
ddirq            ce9'    
ddirv0           d07'    
dduser            20'    
defbak           163'    
defbk0           151'    
defbk1           15f'    
deftbl            16'    
delay          =fd85     
desttd            50"    
dexist            1a'    
dextro            1b'    
dfltad           bfa'    
dicomp           ec4'    
did              bf3'    
dinline           b7"    
dinsp             17'    
dirbuf             0      (extern)
dirddn           ddf'    
dirdnx           de4'    
dirful           a13'    
dirload          d4d'    
dirlp            d76'    
dirlp1           d7d'    
dirmax             0      (extern)
dirpak           f0f'    
dirpdn           de2'    
dirtdu             0      (extern)
dlloop1          d61'    
dly1           =fd89     
dly2           =fd87     
dncopy            19'    
doattr           987'    
dooptq           ca3'    
dostyp             0      (extern)
dparams            0      (extern)
dpdone           f3c'    
dploop           f1c'    
dpnext           f39'    
drepl             1d'    
dsflag            3a"    
dsok             d05'    
dstart             7"    
dsysexc           18'    
ducv1            9b6'    
ducvrt           9ac'    
dundr              0      (extern)
duser             26"    
dverflg           16'    
eat1             8dd'    
eat1a            8ec'    
elsiz              b"    
eprint             0      (extern)
epstr              0      (extern)
esize          =  1f     
exclud            2a'    
exist             1f"    
exist0           836'    
exro              20"    
f$close            0      (extern)
f$delete           0      (extern)
f$exist            0      (extern)
f$make             0      (extern)
f$open             0      (extern)
f$read             0      (extern)
f$write            0      (extern)
fcb            =  5c     
fcbd              2c"    
fcbs              2a"    
fcount             9"    
ffnd             889'    
ffnd0            8be'    
fillit           e77'    
fin            =fdc4     
findck             0      (extern)
fnf              8ef'    
fnsize         =  10     
formerr          9c0'    
fout           =fde1     
freebuf           65"    
fstat          =fdb5     
fstnxt             0      (extern)
gbits            ef3'    
gbits0           ef5'    
gbits1           f06'    
getch            bc8'    
getefcb            0      (extern)
getmsg             0      (extern)
getmtop            0      (extern)
getquiet           0      (extern)
getst0           cc0'    
getstmp          cbd'    
gettop           cc5'    
getud              0      (extern)
gotbak           31b'    
gstamp             0      (extern)
gzmtop             0      (extern)
havfil            5f"    
havmsgs          135'    
indx               3"    
initfcb            0      (extern)
initlz           5b4'    
inline            63"    
insp              1c"    
inspf            abb'    
inspf0           aea'    
inspf1           af6'    
inspf2           b20'    
inspfa           b29'    
intrdi         =fe0f     
intren         =fdfe     
iptr               0"    
isx00            810'    
lf             =   a     
lloop            caf'    
load             a29'    
load1            a49'    
logd             bac'    
logds            bb0'    
logs             b9b'    
logud              0      (extern)
lpctr              2"    
lstcpy            2f"    
m2utim             0      (extern)
mc2done          946'    
mcop0v           1d1'    
mcopy            575'    
mcopy0           4f8'    
mcopy1           5a8'    
mcopy2           61f'    
mcopyv           a5f'    
mcopyx           79d'    
mcpy             a30'    
mcpy0            5ad'    
mcpy24           6f2'    
mcpy25           705'    
mcpy26           726'    
mcpy28           78f'    
mcpycrc          a41'    
mcpyd1           925'    
mcpyderr         9e1'    
mcpyok           66a'    
mcpyv            a73'    
mcpyx            910'    
mfptr             15"    
mhelp            239'    
mmgetp         =fd78     
mmpmap         =fd6b     
moveb              0      (extern)
msgs             120'    
ncopy             1e"    
newdu            5f9'    
newer            867'    
newstack         105"    
nodate           75d'    
nods             d03'    
noefcb           c73'    
nomsgs            33"    
nopaus           568'    
nopub            527'    
norepl            39"    
noro             897'    
norst             34"    
noslsh           c97'    
notp2d           e75'    
notpub           8ac'    
notx00           7db'    
notzrd           512'    
null0            eee'    
nullit           eed'    
nxtptr            17"    
off            =   0     
ohelp            21b'    
older            872'    
oldstack          db"    
on             =  ff     
opentd             0      (extern)
optc           =  2f     
option           1b2'    
optlen         =   b     
optlst           ce1'    
optltr           cd6'    
optq             c8c'    
opts           =   0     
opttab           1f6'    
oqdone           cb6'    
ordbuf             f"    
ovrid1           1cd'    
ovrid2           1db'    
ovride           1c1'    
p2done           e7a'    
p2utim             0      (extern)
pafdc              0      (extern)
paglim            2e"    
pagok            71c'    
pagok0           721'    
pedone           e86'    
pentry           de9'    
pfn1               0      (extern)
phex              bd"    
plim           =  c0     
prdone           bce'    
prndu            c4d'    
prnnam           c65'    
prts2d           c22'    
pstamp             0      (extern)
pstring           ab"    
ptrflg            11"    
pubs              67"    
puter2             0      (extern)
putstmp          cb8'    
putud              0      (extern)
quiet             38"    
rclock             0      (extern)
renflg            60"    
replac            22"    
replck            61"    
retsys           52a'    
retud              0      (extern)
rev            =  32     
rldrom         =fe79     
roflg             35"    
rpqflg            36"    
rwtd               0      (extern)
s2flg              4"    
samrec           dc5'    
sayno            4f0'    
scan11           c7e'    
scan1a           c82'    
scan1b           c86'    
scanqq           c7c'    
sconin         =fc2d     
sconout        =fc27     
sconst         =fc33     
sdflgs           139'    
sdma           =  1a     
sdrive            25"    
selar0           b30'    
selar1           b3f'    
selarc           b2e'    
setdma             0      (extern)
setds0           ba1'    
setdst           ba8'    
seteflag         ab2'    
setsr0           b8b'    
setsrc           b97'    
sintvec        =fff0     
sort               0      (extern)
srchf          =  11     
srchn          =  12     
srctd             41"    
ssb                7"    
ssbinit            0      (extern)
stack             a9"    
start             83'    
start1           17e'    
stopzex            0      (extern)
suffx1           ce1'    
suffx2           ce4'    
suser             24"    
syscmlo        =feb4     
syscom         =fc00     
sysexc            1d"    
sysok0           6c2'    
sytimr         =fe19     
tab            =   9     
tbllen         =   8     
tdbuf             13"    
tdloop           d9c'    
tdnull           dc0'    
tdrdok           dc4'    
tfcb               5"    
timini             0      (extern)
timtyp             0      (extern)
tmptim            3b"    
tpaovfl          9d1'    
typdat            1e'    
u0isr          =fe25     
u1isr          =fe59     
u1nul          =fe70     
uastav         =fe84     
uastkb         =fe86     
uisre          =fe4e     
uisri          =fe32     
undat            87d'    
useddu            1f'    
usems            e34'    
usenz0           e9b'    
usenz1           e9e'    
usenz2           ea0'    
usenzt           e8b'    
usep2d           e4d'    
vconin         =fc15     
vconout        =fc0f     
vconst         =fc1b     
vercnt            30"    
vercrc           a92'    
verflg            1b"    
verloop          a7c'    
vers           =  11     
voidisr        =fe22     
wb             =   0     
whrenv             0      (extern)
workbf            19"    
xmove             37"    
z3eadr             9'    
z3init             0      (extern)
zconv             ce"    
zprsfn             0      (extern)
