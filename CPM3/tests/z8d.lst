   1:			;	title	*   *** Z8E - Z80 Debug Monitor ***    *
   2:			;	subttl	(C) Copyright 1984, 1985   by Richard A. Surwilo
   3:			
   4:			; -----------------------------------------------------------------------------
   5:			; Modified to be compatible with zmac assembler and to be run as a stand-alone
   6:			; debugger (without CP/M support)
   7:			; Feb 2006 - Piergiorgio Betti <pbetti@lpconsul.net>
   8:			; N.B. as of 20060620 this is partially true. Just console IO has been changed.
   9:			; -----------------------------------------------------------------------------
  10:			
  11:			;------------------------------------------------------------------------------
  12:			;
  13:			;  Copyright (C) 1984, 1985   by Richard A. Surwilo.  All rights reserved.
  14:			;
  15:			;  No part of this publication may be reproduced, transmitted, transcribed,
  16:			;  stored in a retrieval system, or translated into any language or computer
  17:			;  language in any form or by any means, electronic, mechanical, magnetic,
  18:			;  optical, chemical, manual or otherwise, without express prior written
  19:			;  permission of:
  20:			;
  21:			;      Richard  A. Surwilo  330 Calvin Court, Wyckoff, NJ 074816
  22:			;
  23:			;  Note:
  24:			;	    This program is distributed in violation of the restrictions
  25:			;	    on reproduction and transmission outlined above.  It would
  26:			;	    appear that Rick Surwilo released this program to the public
  27:			;	    domain without removing the notice.
  28:			;
  29:			;------------------------------------------------------------------------------
  30:			;
  31:			;                       Revision history
  32:			;  15 Feb 08	 v3.7	Switch to RST8 instead of RST38 and some other minor
  33:			;			fix to cope with ZDS interrupt handling
  34:			;
  35:			;  21 Feb 06	 v3.6	Modifified syntax for zmac cross-assembler
  36:			;			Piergiorgio Betti <pbetti@lpconsul.net>
  37:			;
  38:			;  27 Dec 88 jrs v3.5	Released 24 Jan 89.  Includes a few patches by
  39:			;			George Havach.
  40:			;
  41:			;		1.	Changed operation of <cr> in some commands to make
  42:			;			a more consistent user interface.  (I won't be
  43:			;			offended if users want it changed back - jrs.)
  44:			;
  45:			;		2.	Enhancement to patch 1.5:- altered the search for
  46:			;			"MACRO-80" sentinel in RPRN files to allow for a
  47:			;			TITLE pseudo-op.
  48:			;
  49:			;		3.	Shortened and improved the code for the 'I' command.
  50:			;
  51:			;		4.	Tested and corrected the ANSIXYCP module which I have
  52:			;			been supplying since May 1987.  The code has now been
  53:			;			incorporated into the main source file and can be
  54:			;			activated during assembly by setting "aterm equ true".
  55:			;
  56:			;		5.	Discarded the '#' command introduced in 3.3.11 as with
  57:			;			a minor adjustment the 'L' command with no file name
  58:			;			does the same thing.
  59:			;
  60:			;		6.	If S or J was last command issued then <cr> alone
  61:			;			repeats S or J in single-step mode.  Very useful for
  62:			;			stepping through a small section of a program.
  63:			;
  64:			;	(gah)	7.	Adapted a patch by George Havach to correct the display
  65:			;			of IX and IY in disassembled instructions when upper
  66:			;			case is set.
  67:			;
  68:			;	(gah)	8.	Made room for patching in 'clear screen' code at
  69:			;			MBANNR: for more dignified start-up.
  70:			;
  71:			;	(gah)	9.	Replaced tilde ("~") with period (".") as a general
  72:			;			substitute for non-displayable ASCII characters, for
  73:			;			consistency with practically every other screen-dump
  74:			;			utility.  [Retained "hazeltine" conditional - jrs]
  75:			;
  76:			;  12 Dec 88 jrs v3.4	Made patch 3.3.1 object-configurable because some
  77:			;			terminals, particularly those which have binary
  78:			;			cursor addressing, must use an offset of 80h to stop
  79:			;			the BDOS from expanding tabs and for those terminals
  80:			;			clearing bit 7 is nasty.
  81:			;
  82:			;   5 Dec 88 eg  v3.3	Included a number of fixes and features submitted by
  83:			;  (installed by jrs)	Eric Gans in January and March 88.
  84:			;
  85:			;		 1.	Clear bit 7 of characters sent to screen to avoid
  86:			;			strange effects on some computers (such as Kaypro
  87:			;			which prints graphic characters if bit 7 is on).
  88:			;
  89:			;		 2.	Allow 'z' command without an address to mean dis-
  90:			;			assemble from last instruction for last-specified
  91:			;			number of lines.
  92:			;
  93:			;		 3.	Allow 'g' command without an address to mean the
  94:			;			equivalent of 'g  pc'  or  'g  $' (i.e. continue
  95:			;			execution from current instruction).
  96:			;
  97:			;		 4.	Show absolute destination addresses when dis-
  98:			;			assembling relative jump instructions (jr and djnz).
  99:			;
 100:			;		 5.	Display flags along with registers when using the
 101:			;			's' and 'x' commands.
 102:			;
 103:			;		 6.	Allow easy refresh of the 'animated debug' screen
 104:			;			after program output has disturbed it.  Use 'j  #'
 105:			;			to force refresh.
 106:			;
 107:			;		 7.	After Z8E's internal disk I/O operations, reset
 108:			;			DMA to 80h for the benefit of target programs.
 109:			;
 110:			;		 8.	Allow cancellation of commands with CAN (ctrl-X)
 111:			;			when argument buffer is empty.  For example if you
 112:			;			have entered 'd  100' then first ^X erases the '100'
 113:			;			and the second cancels the 'd'.
 114:			;
 115:			;		 9.	Implement '>' command to change user number and so
 116:			;			allow loading of files from user areas other than
 117:			;			that from which Z8E was initiated.
 118:			;
 119:			;		10.	Implement '?' command to evaluate and display argument
 120:			;			expressions.  Accepts a register name as the first
 121:			;			operand.  (reg) allows indirect addressing so that,
 122:			;			for example, '?  (hl)' displays value at the memory
 123:			;			location whose address is contained in HL.
 124:			;
 125:			;		11.	Implement '#' command to recall and display the
 126:			;			highest address occupied by a program.
 127:			;
 128:			;   4 Dec 88 jrs v3.2	Expand asterisks in file names when using 'i' command.
 129:			;
 130:			;  27 Nov 88 jrs v3.1	Bug fix - deleted three spurious instructions from
 131:			;			the initialisation code which was added to support
 132:			;			breakpoint vectors at addresses other than 38h.
 133:			;
 134:			;  16 Nov 88 jrs v3.0	Bumped version number to regain sequence with USA.
 135:			;			Until now there were two independent streams of
 136:			;			development.  (A date prefixed by '-' denotes a
 137:			;			version from the "USA" stream).
 138:			;
 139:			;			Extended Jim Moore's idea of substituting RST 30h
 140:			;			(RST 6) for RST 38h (RST 7).  Now the breakpoint
 141:			;			vector address can be patched without re-assembling.
 142:			;
 143:			;  11 Nov 88 jrs v1.5	Added code to distinguish between RPRN files created
 144:			;			by Macro-80 and Z80ASM 1.3 so Z8E can load symbols
 145:			;			from either type of RPRN file.
 146:			;
 147:			;- 30 Nov 87 eg  v2.1	FCB and command tail initialisation routine supplied
 148:			;			by Eric Gans.  [Does not appear in the current source
 149:			;			as it duplicated v1.4 but consumed more code space.]
 150:			;
 151:			;  15 May 87 jrs v1.4	Implemented "I" command to initialise the command
 152:			;			tail at 80h and the default FCB name blocks at 5Ch
 153:			;			and 6Ch.
 154:			;
 155:			;			Renamed I(nput) command to L(oad) to make way for new
 156:			;			I(nitialise) command.  Documentation changed 13/6/87.
 157:			;
 158:			;			Filtered source code to all lower case.  Sometime
 159:			;			Between 1.0 And 1.2 The Comments Had Been Modified So
 160:			;			That Every Word Started With A Capital Letter And It
 161:			;			Really Did Look Quite Silly.
 162:			;
 163:			;  20 Apr 87 jrs v1.3	Fixed register display in animated debug mode.  Z8E
 164:			;			now handles EX AF,AF' and EXX instructions correctly.
 165:			;			Duplicates patch of 21 Oct 86 but was developed quite
 166:			;			independently and coded very differently.
 167:			;
 168:			;			Added equates to tailor the source to assemblers
 169:			;			other than M80.
 170:			;
 171:			;- 21 Oct 86 fh  v2.0	Fixed register display in animated debug mode.  Z8E
 172:			;  (installed by gmi)	now handles EX AF,AF' and EXX instructions correctly.
 173:			;
 174:			;  08 Mar 86 jrs v1.2	(No version number change - all mods purely cosmetic)
 175:			;			Modified org directives to bypass bug in m80
 176:			;			Added jterm conditional for testing
 177:			;			Added hazeltine conditional for tilde suppression
 178:			;			Changed dates to more universal format
 179:			;
 180:			;  16 Jan 86 ijb v1.2	Cursor addressing for post '=>' in jdbg75
 181:			;			to cover systems that have a destructive bs
 182:			;
 183:			;-  3 Dec 85 jgm v?.?	Added EQUates for breakpoint address so it could be
 184:			;			something other than 38h.
 185:			;
 186:			;  25 Sep 85 ras v1.1	Fix case bug
 187:			;			Fix usym bug
 188:			;			Clean up comments
 189:			;
 190:			;	ras = Richard Surwilo		Stamford, Connecticut
 191:			;	ijb = ?
 192:			;	jrs = Jon Saxton		Sydney, New South Wales
 193:			;	jgm = Jim Moore			Anaheim, California
 194:			;	eg  = Eric Gans			Los Angeles, California
 195:			;	fh  = Frankie Hogan
 196:			;	gbi = Gary Inman		Los Angeles, California
 197:			;	gah = George Havach		California
 198:			;
 199:			;------------------------------------------------------------------------------
 200:			;
 201:			include darkstar.equ
**** darkstar.equ ****
   1:			;****** Equ's file autogenerated by genequs ver: 1.0
   2:			;****** Input files:
   3:			;****** SysCommon.lst
   4:	FDC4          	FIN            	EQU	0FDC4H
   5:	FD89          	DLY1           	EQU	0FD89H
   6:	FD87          	DLY2           	EQU	0FD87H
   7:	FDE1          	FOUT           	EQU	0FDE1H
   8:	FE70          	U1NUL          	EQU	0FE70H
   9:	FE25          	U0ISR          	EQU	0FE25H
  10:	FE59          	U1ISR          	EQU	0FE59H
  11:	FD85          	DELAY          	EQU	0FD85H
  12:	FE4E          	UISRE          	EQU	0FE4EH
  13:	FDB5          	FSTAT          	EQU	0FDB5H
  14:	FE32          	UISRI          	EQU	0FE32H
  15:	FC4B          	BBU1ST         	EQU	0FC4BH
  16:	FC45          	BBU1RX         	EQU	0FC45H
  17:	FC3F          	BBU1TX         	EQU	0FC3FH
  18:	FD29          	BBEXEC         	EQU	0FD29H
  19:	FCFF          	BBHDRD         	EQU	0FCFFH
  20:	FD6A          	BBVOID         	EQU	0FD6AH
  21:	FE86          	UASTKB         	EQU	0FE86H
  22:	FD6B          	MMPMAP         	EQU	0FD6BH
  23:	FE0F          	INTRDI         	EQU	0FE0FH
  24:	FC2D          	SCONIN         	EQU	0FC2DH
  25:	FC15          	VCONIN         	EQU	0FC15H
  26:	FCDB          	BBDIV16        	EQU	0FCDBH
  27:	FCF9          	BBHDWR         	EQU	0FCF9H
  28:	FD78          	MMGETP         	EQU	0FD78H
  29:	FDFE          	INTREN         	EQU	0FDFEH
  30:	FE79          	RLDROM         	EQU	0FE79H
  31:	FCE1          	BBMUL16        	EQU	0FCE1H
  32:	FC00          	SYSCOM         	EQU	0FC00H
  33:	FE84          	UASTAV         	EQU	0FE84H
  34:	FE19          	SYTIMR         	EQU	0FE19H
  35:	FC33          	SCONST         	EQU	0FC33H
  36:	FC1B          	VCONST         	EQU	0FC1BH
  37:	FC39          	BBU0INI        	EQU	0FC39H
  38:	FC51          	BBU1INI        	EQU	0FC51H
  39:	FC87          	BBFREAD        	EQU	0FC87H
  40:	FD23          	BBEIDCK        	EQU	0FD23H
  41:	FD05          	BBHDGEO        	EQU	0FD05H
  42:	FEB4          	BBSTACK        	EQU	0FEB4H
  43:	FC81          	BBFHOME        	EQU	0FC81H
  44:	FD94          	BBCONIN        	EQU	0FD94H
  45:	FC27          	CRDUREG        	EQU	0FC27H
  46:	FFF0          	SINTVEC        	EQU	0FFF0H
  47:	FEB4          	SYSCMLO        	EQU	0FEB4H
  48:	FE22          	VOIDISR        	EQU	0FE22H
  49:	FC9F          	BBSTTIM        	EQU	0FC9FH
  50:	FDAA          	BBCONST        	EQU	0FDAAH
  51:	FC27          	SCONOUT        	EQU	0FC27H
  52:	FC0F          	VCONOUT        	EQU	0FC0FH
  53:	FCE7          	BBOFFCAL       	EQU	0FCE7H
  54:	FC57          	BBINICTC       	EQU	0FC57H
  55:	FE90          	BBSTBASE       	EQU	0FE90H
  56:	FC5D          	BBRESCTC       	EQU	0FC5DH
  57:	FCA5          	BBRDTIME       	EQU	0FCA5H
  58:	FD5A          	BBCALRET       	EQU	0FD5AH
  59:	FCB7          	BBDMASET       	EQU	0FCB7H
  60:	FC00          	BBJTOBNK       	EQU	0FC00H
  61:	FCBD          	BBDSKSEL       	EQU	0FCBDH
  62:	FCED          	BBHDINIT       	EQU	0FCEDH
  63:	FCB1          	BBSECSET       	EQU	0FCB1H
  64:	FD0B          	BBHDBOOT       	EQU	0FD0BH
  65:	FC69          	BBUPLCHR       	EQU	0FC69H
  66:	FC99          	BBPRNCHR       	EQU	0FC99H
  67:	FCC9          	BBVCPMBT       	EQU	0FCC9H
  68:	FC93          	BBFLOPIO       	EQU	0FC93H
  69:	FD1D          	BBEPMNGR       	EQU	0FD1DH
  70:	FCCF          	BBSIDSET       	EQU	0FCCFH
  71:	FD11          	BBLDPART       	EQU	0FD11H
  72:	FC75          	BBRDVDSK       	EQU	0FC75H
  73:	FC8D          	BBFWRITE       	EQU	0FC8DH
  74:	FCC3          	BBCPBOOT       	EQU	0FCC3H
  75:	FC21          	BBCURSET       	EQU	0FC21H
  76:	FCAB          	BBTRKSET       	EQU	0FCABH
  77:	FC7B          	BBWRVDSK       	EQU	0FC7BH
  78:	FD9F          	BBCONOUT       	EQU	0FD9FH
  79:	FCF3          	BBDRIVEID      	EQU	0FCF3H
  80:	FC63          	BBPSNDBLK      	EQU	0FC63H
  81:	FC03          	BBCRTCINI      	EQU	0FC03H
  82:	FC6F          	BBPRCVBLK      	EQU	0FC6FH
  83:	FC09          	BBCRTFILL      	EQU	0FC09H
  84:	FCD5          	BBFDRVSEL      	EQU	0FCD5H
  85:	FD17          	BBDPRMSET      	EQU	0FD17H
  86:			;****** EOF ***
  87:			
**** z8d.asm ****
 202:			;
 203:			
 204:	FFFF          	TRUE	EQU	-1
 205:	0000          	FALSE	EQU	0
 206:			
 207:			; The following equate setup an incarnation that will run without CP/M support
 208:			; It is hardware dependent (since calls are made directly to the monitor ROM)
 209:			; Here it is tailored for my Z80darkStar. Follow the STLONE symbol to find
 210:			; were customize the calls...
 211:			
 212:	0000          	STLONE	EQU FALSE
 213:			
 214:			;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 215:			; The following EQUates should both be set to FALSE to generate a "standard"
 216:			; Z8E.COM for distribution.  The JTERM is mine which I only put in for use
 217:			; while testing to save having to configure the object code for my terminal.
 218:			; (jrs 8 mar 86)  The ATERM is for an ANSI-compatible terminal such as a
 219:			; VT100 in which case setting ATERM to TRUE will cause the ANSIXYCP module
 220:			; to be included during assembly.  (jrs 28 dec 88)
 221:			
 222:	0000          	JTERM	EQU	FALSE		;Should always be false for distribution
 223:	0000          	ATERM	EQU	FALSE		;- - - ditto - - -
 224:	FFFF          	Z80DS	EQU	TRUE
 225:			
 226:			;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 227:			; The following equ should normally be set to 0.  It is only required if
 228:			; you have a Hazeltine terminal which uses tilde as a command character
 229:			
 230:	0000          	HAZELTINE EQU	FALSE
 231:			
 232:			;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 233:			; Configure this source to your favourite assembler by setting one of
 234:			; the following equates to true.  If you use an assembler not mentioned
 235:			; below then make up a new equate for it.
 236:			
 237:	0000          	M80	EQU	FALSE		;Microsoft's Macro-80
 238:	0000          	ASMB	EQU	FALSE		;Cromemco's Z80 assembler
 239:	FFFF          	SLR	EQU	TRUE		;SLR's lightning-fast Z80ASM assembler
 240:			
 241:			; (Note that there is no real distinction between M80 and SLR.  Either
 242:			;  assembler may be used with either EQUate set TRUE.)
 243:			;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 244:			
 245:	0000          	COMPACT	EQU	JTERM OR ATERM
 246:			
 247:	0000          	     IF	COMPACT
 253:			     ENDIF
 254:			
 255:	FFFF          	     IF	NOT ASMB
 256:				.Z80			;so M80 users don't need /z switch
 257:			     ENDIF
 258:			
 259:	0000          	     IF	ASMB
 264:			     ENDIF
 265:			
 266:	0010          	MAXBP	EQU	16		;Number	of breakpoints configured
 267:			
 268:	0008          	BS	EQU	08H		;ASCII 	backspace
 269:	0009          	TAB	EQU	09H		;	tab
 270:	000A          	LF	EQU	0AH		;	line feed
 271:	000C          	FORMF	EQU	0CH		;	form feed
 272:	000D          	CR	EQU	0DH		;	carriage return
 273:	001B          	ESC	EQU	1BH		;       escape
 274:	0018          	CTLX	EQU	'X' and	1fh	;	control	x - delete line
 275:	0003          	CTLC	EQU	'C' and	1fh	;	control	c - warm boot
 276:	001A          	EOF	EQU	'Z' and	1fh	;	control	z - logical eof
 277:	0027          	QUOTE	EQU	27H		;	quote
 278:	007E          	TILDE	EQU	7EH		;	tilde
 279:	007F          	DEL	EQU	7FH		;	del
 280:			
 281:	0005          	BDOS	EQU	5
 282:	005C          	FCB5C	EQU	5CH		;CP/M default FCB
 283:			
 284:	0000          	INOP	EQU	000		;Z80 instructions
 285:	00C3          	IJP	EQU	0C3H
 286:	00C9          	IRT	EQU	0C9H
 287:	00CF          	RST38	EQU	0CFH		; uses RST 8
 288:			
 289:	0080          	IOBUF	EQU	80H		;Disk read buffer for symbol loading
 290:			
 292:			
 293:			;******************************************************************************
 294:			;*
 295:			;*	nint:	  Initialization - relocating loader - symbol loader
 296:			;*
 297:			;*	Initialization:
 298:			;*	- Save system I	register
 299:			;*	- Determine max symbol length before loading symbol table
 300:			;*        permissable values are 6 and 14 which are converted to bit
 301:			;*	  masks by bumping by one
 302:			;*	- Set CP/M DMA address to 80h
 303:			;*	- Check first command line argument for (xx) where xx is the
 304:			;*	  number of slots in the symbol table to reserve.
 305:			;*	- Move first file name found in command line to local memory
 306:			;*	  since it will be loaded last.  At the end of initialization
 307:			;*	  (or symbol loading if required) this file name will be loaded
 308:			;*	  into the keyboard input buffer and the file will be loaded
 309:			;*	  just as if the user had entered the info as a Z8E command.
 310:			;*	- Move all subsequent file names in the	command	line buffer to
 311:			;*	  local input buffer (inbf) in low memory, where they can
 312:			;*	  be found by the parse	routine (prsr).
 313:			;*
 314:			;*	Relocating loader:
 315:			;*	- Move absolute	memory image of	Z8E to top of TPA
 316:			;*	- Adjust all addresses in relocated monitor to reflect new
 317:			;*	  execution area.  This is accomplished by repeated calls to
 318:			;*	  zlen to calculate instruction	lengths.
 319:			;*	- All addresses	< the absolute value of	z8eorg are considered
 320:			;*	  to be	absolute values	and are	not modified.
 321:			;*	- Relocate all address pointers	in command and operand jump
 322:			;*	  tables.
 323:			;*
 324:			;******************************************************************************
 325:			
 326:	FFFF          	      IF	M80 OR SLR
 327:				ASEG
 328:			      ENDIF
 329:			
 330:	0000          	      IF ASMB
 332:			      ENDIF
 333:			
 334:	0000          	      IF	ASMB
 338:			      ENDIF
 339:			
 340:			;     if	SLR or M80
 341:			;	Use :: at end of label name to generate a global symbol
 342:			;	when assembling to a .REL file (i.e. when using M80 or
 343:			;	when using Z80ASM with the /M switch).  Doing it this
 344:			;	way lets us assemble to a .REL file with either assembler
 345:			;	or directly to a .COM file with Z80ASM without changing
 346:			;	the source at all.
 347:			;     endif
 348:			
 349:	0100          		ORG	100H
 350:			
 351:	0100  C39001  		JP	NINT
 352:			
 353:	0000          	      IF	ASMB
 355:			      ELSE
 356:	0103          	RSTVEC:
 357:			      ENDIF
 358:	0103  08      		DEFB	08H		;Default (but patchable) breakpoint vector
 359:			
 360:	0000          	      IF	ASMB
 362:			      ELSE
 363:	0104          	COMASK:
 364:			      ENDIF
 365:	0104  7F      		DEFB	7FH		;Mask applied to characters before output
 366:							;to screen.  Patch to 0FFh if your terminal
 367:							;needs high-order bit set on occasions.
 368:			
 369:	0000          	      IF	ASMB
 371:			      ELSE
 372:	0105          	MBANNR:
 373:			      ENDIF
 374:	0000          	      IF	JTERM
 376:			      ENDIF
 377:	FFFF          	      IF	Z80DS
 378:	0105  0C      		DEFB	$0C
 379:			      ELSE
 381:			      ENDIF
 382:	0106  0D0A    		DEFB	CR,LF
 383:	0108  5A384420		DEFB	'Z8D  V3.7 - 15 Feb 08'
	      2056332E
	      37202D20
	      31352046
	      65622030
	      38
 384:	011D  0D0A    		DEFB	CR,LF
 385:	0000          	      IF STLONE
 387:			      ENDIF
 388:	011F  436F7079		DEFB	'Copyright (c) 1984, 1985  Richard A. Surwilo'
	      72696768
	      74202863
	      29203139
	      38342C20
	      31393835
	      20205269
	      63686172
	      6420412E
	      20537572
	      77696C6F
 389:	014B  0D0A    		DEFB	CR,LF
 390:	014D  436F7079		DEFB	'Copyright (c) 2006-2008 Piergiorgio Betti <pbetti@lpconsul.net>'
	      72696768
	      74202863
	      29203230
	      30362D32
	      30303820
	      50696572
	      67696F72
	      67696F20
	      42657474
	      69203C70
	      62657474
	      69406C70
	      636F6E73
	      756C2E6E
	      65743E
 391:	018C  0D0A0A  		DEFB	CR,LF,LF
 392:	018F  00      		DEFB	0
 393:			
 394:	0190          	NINT:
 395:	0190  F3      		DI			; disable interrupts in hardware
 396:			; 	CALL	GDISIN		; and lock monitor to reenable them
 397:	0191  31C930  		LD	SP,STACK
 398:	0194  ED57    		LD	A,I		;Save i reg for user
 399:	0196  32B82F  		LD	(IREG),A
 400:	0199  CD1C0A  		CALL	INIT
 401:	019C  110501  		LD	DE,MBANNR	;Dispense with formalities
 402:	019F  CD9E28  		CALL	PRINT
 403:			
 404:			; Patch code for a specific breakpoint routine address.
 405:			;
 406:			; Adapted from an idea by Jim Moore (3 Dec 85) but made object-patchable
 407:			; (jrs 15 Nov 88)
 408:			
 409:	01A2  3A0301  		LD	A,(RSTVEC)	;Get breakpoint vector address
 410:	01A5  6F      		LD	L,A
 411:	01A6  2600    		LD	H,0
 412:	01A8  22EF01  		LD	(NINT03+1),HL	;Patch the code
 413:	01AB  23      		INC	HL		;HL now holds rstVec+1
 414:	01AC  22B602  		LD	(NINT71+1),HL	;Patch some more code
 415:	01AF  F6C7    		OR	0C7H		;Convert vector address into RST xx
 416:	01B1  329714  		LD	(G400+1),A	;Patch the code
 417:	01B4  32C414  		LD	(G518+1),A
 418:			
 419:			; Patch code for terminal output - jrs 3.4
 420:	FFFF          	IF NOT STLONE
 421:	01B7  3A0401  		LD	A,(COMASK)	;Get console output character mask
 422:	01BA  32E225  		LD	(TTYO00+1),A
 423:			ENDIF
 424:			; Do config based on max length of symbol names
 425:			
 426:	01BD  3A322F  		LD	A,(MAXLEN)	;Check max symbol length
 427:	01C0  3C      		INC	A		;Create mask
 428:	01C1  FE0F    		CP	15
 429:	01C3  47      		LD	B,A		;B - maxlen mask - 15
 430:	01C4  3E3E    		LD	A,62		;A - maxlin disassembly line length (62)
 431:	01C6  0E44    		LD	C,68		;C - column to display first byte of memory
 432:							;    window for J command
 433:	01C8  1603    		LD	D,3		;D - bytes per line of memory window display
 434:	01CA  CAD501  		JP	Z,NINT00	;Z - max symbol length is 14
 435:			
 436:							;If not 14 - use default values
 437:	01CD  0607    		LD	B,7		;B - maxlen mask -  7
 438:	01CF  3E1E    		LD	A,30		;A - maxlin disassembly line length (30)
 439:	01D1  0E38    		LD	C,56		;C - column to display first byte of memory
 440:	01D3  1607    		LD	D,7		;    window for J command
 441:	01D5  32342F  	NINT00:	LD	(MAXLIN),A
 442:	01D8  78      		LD	A,B
 443:	01D9  32322F  		LD	(MAXLEN),A
 444:	01DC  79      		LD	A,C
 445:	01DD  32362F  		LD	(FWNDOW),A
 446:	01E0  7A      		LD	A,D
 447:	01E1  32372F  		LD	(NLMASK),A
 448:			
 449:			;Reset CP/M DMA address for those instances in which Z8E is used to debug
 450:			;itself.  Otherwise DMA address is left where Z8E stopped loading itself.
 451:			;(Last statement no longer true - see patch 3.3.1)
 452:			;IF NOT STLONE
 453:	01E4  118000  		LD	DE,80H
 454:	01E7  0E1A    		LD	C,26
 455:	01E9  CD0500  		CALL	BDOS
 456:			;ENDIF
 457:	01EC  3EC3    		LD	A,IJP		;Initialize where L80 fears to tread
 458:			
 459:			; The next instruction is PATCHED before it is executed
 460:	01EE  323800  	NINT03:	LD	(38H),A		;Init trap to breakpoint handler
 461:			;IF STLONE
 462:			;	JP	NINT55
 463:			;ENDIF
 464:	01F1  215D00  		LD	HL,5DH		;Save current contents of default fcb
 465:	01F4  7E      		LD	A,(HL)
 466:	01F5  FE28    		CP	'('		;Is first char in fcb a paren?
 467:	01F7  2B      		DEC	HL
 468:	01F8  2048    		JR	NZ,NINT25	;Not paren - no user symbol table requested
 469:	01FA  23      		INC	HL		;Point back to paren
 470:	01FB  110330  		LD	DE,INBF		;Start of input buffer here in low memory
 471:	01FE  060F    		LD	B,15		;Max chars in fcb following first paren
 472:	0200  23      	NINT05:	INC	HL		;Bump fcb pointer
 473:	0201  12      		LD	(DE),A		;Move char to low memory keyboard input buffer
 474:							;so that prsr thinks this is keyboard input
 475:	0202  13      		INC	DE		;Bump input buffer pointer
 476:	0203  7E      		LD	A,(HL)
 477:	0204  FE29    		CP	')'		;Look for trailing paren
 478:	0206  2807    		JR	Z,NINT10
 479:	0208  10F6    		DJNZ	NINT05		;Examine entire fcb at 5ch looking for paren
 480:	020A  215C00  		LD	HL,FCB5C	;Trailing paren not found - this must be
 481:							; kookie file name
 482:	020D  1833    		JR	NINT25		;Ignore
 483:			
 484:			;Call iarg to determine amount of space to allocate in user symbol table.
 485:			;This arg must be enclosed in parentheses and must appear after the first
 486:			;arg in the command line.  Since opening and closing parens were found
 487:			;add a pound sign to make this into default decimal number then call xval
 488:			;to evaluate.
 489:			
 490:	020F  EB      	NINT10:	EX	DE,HL		;HL - input buffer pointer
 491:	0210  3623    		LD	(HL),'#'	;Add trailing paren before calling iarg
 492:							;who will evaluate argument as if it was
 493:							;entered from keyboard
 494:	0212  23      		INC	HL
 495:	0213  77      		LD	(HL),A		;Restore trailing paren following pound sign
 496:	0214  23      		INC	HL
 497:	0215  3600    		LD	(HL),0		;Add end of line null
 498:	0217  CDD426  		CALL	IARG
 499:	021A  EB      		EX	DE,HL		;DE - evaluated argument
 500:	021B  215C00  		LD	HL,FCB5C
 501:	021E  2022    		JR	NZ,NINT25	;Arg error - ignore input
 502:	0220  218100  		LD	HL,81H		;Start of command line tail
 503:	0223  7E      	NINT15:	LD	A,(HL)
 504:	0224  3620    		LD	(HL),' '	;Replace the text which appeared between
 505:							;the parens and the parens themselves with
 506:							;spaces
 507:			
 508:	0226  FE29    		CP	')'		;Closing paren ends search
 509:	0228  2803    		JR	Z,NINT20
 510:	022A  23      		INC	HL		;Point to char following closing paren
 511:	022B  18F6    		JR	NINT15
 512:	022D  EB      	NINT20:	EX	DE,HL		;Arg to hl for mult times maxlen bytes per
 513:							;symbol table entry
 514:	022E  29      		ADD	HL,HL
 515:	022F  29      		ADD	HL,HL
 516:	0230  29      		ADD	HL,HL
 517:	0231  3A322F  		LD	A,(MAXLEN)	;8 or 16 bytes per symbol table entry?
 518:	0234  FE07    		CP	7
 519:	0236  CA3A02  		JP	Z,NINT22	;z - must be 8
 520:	0239  29      		ADD	HL,HL
 521:	023A  EB      	NINT22:	EX	DE,HL
 522:	023B  ED530F09		LD	(USYMBL),DE	;Save number of bytes to reserve
 523:	023F  216C00  		LD	HL,6CH		;since user symbol table arg was present then
 524:							;target file must be in default fcb number 2
 525:			
 526:	0242  11C409  	NINT25:	LD	DE,ZBUF		;Local buffer
 527:	0245  011000  		LD	BC,16
 528:	0248  EDB0    		LDIR			;Move FCB contents to local memory
 529:	024A  218000  		LD	HL,80H		;Command line buffer address
 530:	024D  7E      		LD	A,(HL)
 531:	024E  A7      		AND	A		;Test for no input
 532:	024F  2834    		JR	Z,NINT55	;No input - clear symbol table
 533:	0251  4F      		LD	C,A		;BC - number of	chars in command line buffer
 534:	0252  70      		LD	(HL),B		;Clear byte count
 535:	0253  09      		ADD	HL,BC		;Point to last char in buffer
 536:	0254  23      		INC	HL
 537:	0255  70      		LD	(HL),B		;Set end of line null after last char
 538:	0256  218100  		LD	HL,81H
 539:	0259  7E      	NINT30:	LD	A,(HL)		;Look for start	of first file name
 540:	025A  A7      		AND	A		;Found the end of line null?
 541:	025B  2828    		JR	Z,NINT55	;Z - no	files to load
 542:	025D  FE20    		CP	' '		;Leading space?
 543:	025F  2004    		JR	NZ,NINT35	;Not space - found start of file name
 544:	0261  23      		INC	HL
 545:	0262  0D      		DEC	C		;Decrement command line	byte count
 546:	0263  18F4    		JR	NINT30		;Keep looking for start	of file	name
 547:	0265  11D409  	NINT35:	LD	DE,ZNMBUF	;Save name here	for later display
 548:	0268  12      		LD	(DE),A
 549:	0269  13      		INC	DE
 550:	026A  23      	NINT40:	INC	HL		;Find first trailing space
 551:	026B  7E      		LD	A,(HL)
 552:	026C  FE20    		CP	' '
 553:	026E  2808    		JR	Z,NINT45	;Found space - move remainder of buffer
 554:	0270  12      		LD	(DE),A		;Save file name	character for display
 555:	0271  13      		INC	DE
 556:	0272  A7      		AND	A		;End of	line?
 557:	0273  2810    		JR	Z,NINT55	;z - only one file specified
 558:	0275  0D      		DEC	C
 559:	0276  18F2    		JR	NINT40
 560:	0278  79      	NINT45:	LD	A,C		;Check byte count
 561:	0279  FE52    		CP	INBFSZ		;versus	size of	our local input	buffer
 562:	027B  3802    		JR	C,NINT50	;carry - size is ok
 563:	027D  0E52    		LD	C,INBFSZ	;Only move as much as will fit
 564:	027F  110330  	NINT50:	LD	DE,INBF
 565:	0282  EDB0    		LDIR			;Move command line to local memory
 566:	0284  AF      		XOR	A
 567:			
 568:	0285  21000C  	NINT55:	LD	HL,Z8EORG	;clear local symbol table to nulls
 569:	0288  0610    		LD	B,Z8E-Z8EORG	;symbol	table size
 570:	028A  77      	NINT60:	LD	(HL),A		;nulls to entire local symbol table
 571:	028B  23      		INC	HL
 572:	028C  10FC    		DJNZ	NINT60
 573:	028E  2A0600  		LD	HL,(06)		;start of bdos
 574:			;IF STLONE
 575:			;	LD	HL,$EF00
 576:			;ENDIF
 577:	0291  6F      		LD	L,A		;init stack address to 256 boundary
 578:	0292  010025  		LD	BC,NMEM		;monitor size
 579:	0295  A7      		AND	A
 580:	0296  ED42    		SBC	HL,BC		;hl - starting address of z8e in upper
 581:							;memory
 582:	0298  22BF09  		LD	(Z8EB),HL	;monitor bias -	for relocation work
 583:	029B  ED5B0F09		LD	DE,(USYMBL)
 584:	029F  ED52    		SBC	HL,DE
 585:	02A1  22C109  		LD	(NTPA),HL	;end of	tpa - for symbol loading
 586:	02A4  7A      		LD	A,D		;check for no user symbol table
 587:	02A5  B3      		OR	E
 588:	02A6  2808    		JR	Z,NINT75	;no table - no clearing required
 589:	02A8  3600    	NINT70:	LD	(HL),0		;fill user symbol table with nulls
 590:	02AA  23      		INC	HL
 591:	02AB  1B      		DEC	DE
 592:	02AC  7A      		LD	A,D
 593:	02AD  B3      		OR	E
 594:	02AE  20F8    		JR	NZ,NINT70
 595:	02B0  EB      	NINT75:	EX	DE,HL		;hl - start of z8e in hi memory
 596:			
 597:	02B1  21A000  		LD	HL,BPHN-Z8EORG	;entry point to	breakpoint handler
 598:	02B4  19      		ADD	HL,DE
 599:			
 600:			; The next instruction will be PATCHED by the time it is executed.
 601:	02B5  223900  	NINT71:	LD	(39H),HL	;Init RST 38h trap location
 602:			
 603:	02B8  21000C  		LD	HL,Z8EORG
 604:	02BB  EDB0    		LDIR			;z8e now in hi memory - relocate addresses
 605:	02BD  2ABF09  		LD	HL,(Z8EB)	;recover hi memory starting address
 606:	02C0  111400  		LD	DE,Z8ECMD-Z8EORG
 607:	02C3  19      		ADD	HL,DE		;first instruction to relocate
 608:	02C4  EB      		EX	DE,HL
 609:	02C5  CDF31A  	NINT80:	CALL	ZLEN00		;calculate instruction length
 610:	02C8  62      		LD	H,D
 611:	02C9  6B      		LD	L,E		;de - current instruction   hl - ditto
 612:	02CA  0600    		LD	B,0
 613:	02CC  09      		ADD	HL,BC
 614:	02CD  EB      		EX	DE,HL		;de - next address to relocate
 615:	02CE  79      		LD	A,C		;test length
 616:	02CF  D603    		SUB	3
 617:	02D1  381B    		JR	C,NINT90	;one or	two byters are non-relocatable
 618:	02D3  4F      		LD	C,A
 619:	02D4  09      		ADD	HL,BC		;bump if four byter
 620:	02D5  7E      		LD	A,(HL)
 621:	02D6  21762A  		LD	HL,Z80R		;table of relocatable instructions
 622:	02D9  0E20    		LD	C,Z80RL		;size
 623:	02DB  EDB1    		CPIR
 624:	02DD  200F    		JR	NZ,NINT90	;nz - not relocatable
 625:	02DF  EB      		EX	DE,HL
 626:	02E0  2B      		DEC	HL		;point to address byte requiring bias
 627:	02E1  7E      		LD	A,(HL)
 628:	02E2  D60C    		SUB	Z8EORG SHR 8	;test for absolute address < z8eorg
 629:	02E4  3806    		JR	C,NINT85	;absolute - no relocation needed
 630:	0000          	IF STLONE
 635:			ENDIF
 636:	02E6  47      		LD	B,A
 637:	02E7  3AC009  		LD	A,(Z8EBH)	;hi order byte of address bias
 638:	02EA  80      		ADD	A,B		;plus upper byte of operand address
 639:	02EB  77      		LD	(HL),A		;set relocated address
 640:	02EC  23      	NINT85:	INC	HL
 641:	02ED  EB      		EX	DE,HL		;de - next address to test
 642:	02EE  01351D  	NINT90:	LD	BC,NREL-Z8EORG	;end of	relocatable portion of monitor
 643:	02F1  2ABF09  		LD	HL,(Z8EB)
 644:	02F4  09      		ADD	HL,BC		;hl - absolute end of relocated	monitor
 645:	02F5  A7      		AND	A
 646:	02F6  ED52    		SBC	HL,DE		;reached end?
 647:	02F8  30CB    		JR	NC,NINT80	;nc - more
 648:	02FA  112400  		LD	DE,NCMD+ZOPJTL	;size -	command	and operand jump tables
 649:	02FD  2ABF09  		LD	HL,(Z8EB)	;base of relocated monitor
 650:			;	LD	A,-(HIGH Z8EORG); [was:  ld a,-(z8eorg/256)]
 651:	0300  3EF4    		LD	A,-(Z8EORG/256)	;
 652:	0302  84      		ADD	A,H		;relocation bias byte to add to	ptrs
 653:	0303  57      		LD	D,A		;d - bias to add  e - count of pointers
 654:							;		      requiring relocation
 655:	0304  09      		ADD	HL,BC		;first point to	operand	names
 656:	0305  013000  		LD	BC,ZOPJTB	;add length of operand name table
 657:	0308  09      		ADD	HL,BC		;point to first	entry in jump table
 658:	0309  23      	NINT95:	INC	HL
 659:	030A  7E      		LD	A,(HL)		;hi byte jump table entry
 660:	030B  82      		ADD	A,D		;plus bias
 661:	030C  77      		LD	(HL),A		;replace in table
 662:	030D  23      		INC	HL
 663:	030E  1D      		DEC	E
 664:	030F  20F8    		JR	NZ,NINT95	;nz - more table entries to relocate
 665:			
 666:			
 667:			;******************************************************************************
 668:			;*
 669:			;*	ZSYM:	Symbol table build from	.sym and .prn files
 670:			;*
 671:			;*	LFCB called to parse the input buffer (inbf) in low memory.
 672:			;*	INBF contains the command line tail which bdos passed to us at
 673:			;*	80h and which we have since moved to inbf (so that prsr thinks
 674:			;*	it's just keyboard input).
 675:			;*
 676:			;*	All valid file names are opened for input.
 677:			;*
 678:			;*	If the file name terminates with a comma then we assume	the
 679:			;*	user is	specifying a bias which	is to be added to every	symbol
 680:			;*	loaded from the	file.
 681:			;*
 682:			;*	zsym	general	file handiling
 683:			;*	.sym	load L80 .sym file or load SLR .lst file
 684:			;*	.prn	load M80 .prn file or load SLR .prn file
 685:			;*
 686:			;*	Symbol table always begins on an 8 or 16 byte boundary
 687:			;*	depending on the value in maxlen.
 688:			;*
 689:			;******************************************************************************
 690:			
 691:	0311  CD501E  	ZSYM:	CALL	LFCB		;Initialize fcb
 692:	0314  C26C08  		JP	NZ,ZSTX		;nz - error
 693:	0317  11EC29  		LD	DE,MLDG		;Display loading message
 694:	031A  CD9B28  		CALL	NPRINT		;Output	crlf - then print
 695:	031D  115530  		LD	DE,PRSBF
 696:	0320  CD9E28  		CALL	PRINT		;Display file name
 697:	0323  79      		LD	A,C 		;lfcb returns delimeter in c reg
 698:	0324  32202F  		LD	(DELIM),A	;Temp save delimiter so we know if a bias has
 699:							;been specified
 700:	0327  CD3B26  		CALL	CRLF
 701:	032A  CDB71E  		CALL	LOPN		;Try to	open symbol table file
 702:	032D  3D      		DEC	A		;
 703:	032E  FA8B08  		JP	M,ZFNF		;m - file not found
 704:	0331  3A202F  		LD	A,(DELIM)	;Check delimeter
 705:	0334  FE2C    		CP	','
 706:	0336  210000  		LD	HL,00
 707:	0339  2048    		JR	NZ,ZSYM10	;nz - no comma means no	symbol bias
 708:	033B  CD561A  		CALL	PRSR		;Let prsr extract symbol bias
 709:	033E  C2AA08  		JP	NZ,ZOFF		;Parse error - use bias	of 0000
 710:	0341  32202F  		LD	(DELIM),A	;Save delimeter	which followed bias
 711:	0344  115530  		LD	DE,PRSBF
 712:	0347  210000  		LD	HL,00
 713:	034A  CDEF18  		CALL	XVAL		;Evaluate bias
 714:	034D  2834    		JR	Z,ZSYM10	;z - numeric bias specified
 715:			
 716:							;User has specified a bias in the form
 717:							; of a symbol name
 718:	034F  2AC109  		LD	HL,(NTPA)	;Check bias specified by symbol	name
 719:	0352  3A322F  		LD	A,(MAXLEN)
 720:	0355  2F      		CPL
 721:	0356  5F      		LD	E,A
 722:	0357  16FF    		LD	D,0FFH		;Lower end of TPA by amount equal to
 723:							; the value of maxlen negated to insert
 724:							; jump to bdos
 725:	0359  19      		ADD	HL,DE
 726:	035A  3A382F  		LD	A,(CASE)	;Check case of symbol table
 727:	035D  A7      		AND	A
 728:	035E  CA7103  		JP	Z,ZSYM05	;z - symbol names are already in upper case
 729:	0361  115530  		LD	DE,PRSBF	;prsr stored symbol name here
 730:	0364  1A      	ZSYM00:	LD	A,(DE)
 731:	0365  A7      		AND	A
 732:	0366  CA7103  		JP	Z,ZSYM05	;z - end of label symbol name
 733:	0369  CD2926  		CALL	ILCS		;Change each char in symbol name to lower case
 734:	036C  12      		LD	(DE),A
 735:	036D  13      		INC	DE		;Store converted character
 736:	036E  C36403  		JP	ZSYM00
 737:	0371  115530  	ZSYM05:	LD	DE,PRSBF
 738:	0374  CDF619  		CALL	FSYM00		;Search	symbol table
 739:	0377  C2AA08  		JP	NZ,ZOFF		;nz - not found
 740:	037A  3A322F  		LD	A,(MAXLEN)
 741:	037D  B5      		OR	L
 742:	037E  6F      		LD	L,A
 743:	037F  7E      		LD	A,(HL)		;Fetch hi order	address	associated
 744:							; with symbol
 745:	0380  2B      		DEC	HL
 746:	0381  6E      		LD	L,(HL)
 747:	0382  67      		LD	H,A		;HL - symbol value
 748:	0383  22122F  	ZSYM10:	LD	(BIAS),HL	;Bias to add to	each symbol address
 749:	0386  210000  		LD	HL,00
 750:	0389  3AE22F  		LD	A,(FCBTYP)
 751:	038C  ED4BC109		LD	BC,(NTPA)	;Current end of TPA
 752:	0390  FE53    		CP	'S'		;Is this a .sym	file?
 753:	0392  CAA403  		JP	Z,RFSYM		;RFSYM file loaded differently from RPRN
 754:	0395  FE4C    		CP	'L'
 755:	0397  C29B04  		JP	NZ,RPRN		;If not RLST then must be RPRN
 756:	039A  11D308  		LD	DE,RLSTXX	;Look for RLST string id string
 757:	039D  ED531109		LD	(PSTRNG),DE	;Store pointer to string to find
 758:	03A1  CDB608  		CALL	FSTRNG
 759:			
 760:							;BC - symbol table pointer
 761:			
 762:	03A4  3A322F  	RFSYM:	LD	A,(MAXLEN)	;Lower TPA address by 16 or 8
 763:	03A7  2F      		CPL
 764:	03A8  A1      		AND	C		;for storing next symbol and address
 765:	03A9  4F      		LD	C,A
 766:	03AA  3A322F  		LD	A,(MAXLEN)
 767:	03AD  2F      		CPL			;This is negate plus one
 768:	03AE  81      		ADD	A,C
 769:	03AF  4F      		LD	C,A
 770:	03B0  DAB403  		JP	C,RFSYM00	;Treat carry as complement of subtraction
 771:	03B3  05      		DEC	B
 772:	03B4          	RFSYM00:
 773:	03B4  EB      		EX	DE,HL
 774:	03B5  21D130  		LD	HL,STACK+8	;Check for monster symbol table	ready to eat us
 775:	03B8  A7      		AND	A
 776:	03B9  ED42    		SBC	HL,BC
 777:	03BB  D29408  		JP	NC,ZMEM		;End symbol load before	stack is clobbered
 778:	03BE  EB      		EX	DE,HL
 779:	03BF  3A322F  		LD	A,(MAXLEN)	;Load symbol length mask (7 or 15)
 780:	03C2  3D      		DEC	A		;
 781:	03C3  57      		LD	D,A		;D - actual max length of symbols (6 or 14)
 782:	03C4  AF      		XOR	A
 783:	03C5  02      	RFSYM10:	LD	(BC),A		;Init symbol table entry to nulls
 784:	03C6  03      		INC	BC
 785:	03C7  15      		DEC	D
 786:	03C8  20FB    		JR	NZ,RFSYM10
 787:	03CA  5A      		LD	E,D		;Clear DE for hex00
 788:	03CB  AF      		XOR	A
 789:	03CC  321509  		LD	(STAR),A	;Clear ** found flag
 790:	03CF  3E04    		LD	A,4		;Convert four bytes of address
 791:	03D1  32C309  		LD	(BYTES),A
 792:	03D4  CDD607  	RFSYM20:	CALL	NCHR		;Fetch next character in file
 793:	03D7  FE1A    		CP	EOF
 794:	03D9  CA5F06  		JP	Z,FEOF		;End of this symbol file
 795:	03DC  FE30    		CP	'0'
 796:	03DE  3051    		JR	NC,RFSYM25	;c -  must be control character or space
 797:							;nc - possible first char of address
 798:	03E0  FE0A    		CP	LF
 799:	03E2  CAF003  		JP	Z,RFSYM21
 800:	03E5  FE2A    		CP	'*'		;** in slr .sym file?
 801:	03E7  C2D403  		JP	NZ,RFSYM20
 802:	03EA  321509  		LD	(STAR),A
 803:	03ED  C33104  		JP	RFSYM25
 804:			
 805:	03F0          	RFSYM21:
 806:	03F0  CDD607  		CALL	NCHR		;Fetch char following lf
 807:	03F3  FE0D    		CP	CR
 808:	03F5  CA0D04  		JP	Z,RFSYM22	;z - consecutive crlf's means end of page
 809:	03F8  FE30    		CP	'0'
 810:	03FA  D23104  		JP	NC,RFSYM25	;nc - symbol address on new line
 811:	03FD  FE1A    		CP	EOF
 812:	03FF  CA5F06  		JP	Z,FEOF
 813:	0402  FE2A    		CP	'*'		;** ?
 814:	0404  C2D403  		JP	NZ,RFSYM20
 815:	0407  321509  		LD	(STAR),A
 816:	040A  C33104  		JP	RFSYM25
 817:			
 818:	040D          	RFSYM22:
 819:	040D  3AE22F  		LD	A,(FCBTYP)
 820:	0410  FE4C    		CP	'L'		;z80asm RLST file?
 821:	0412  CA1A04  		JP	Z,RFSYM23
 822:	0415  FE50    		CP	'P'		;macro 80 v3.4?
 823:	0417  C2D403  		JP	NZ,RFSYM20
 824:	041A          	RFSYM23:
 825:	041A  11D308  		LD	DE,RLSTXX	;Bypass inter-page verbiage
 826:	041D  ED531109		LD	(PSTRNG),DE
 827:	0421  CDB608  		CALL	FSTRNG
 828:	0424  FE1A    		CP	EOF
 829:	0426  CA5F06  		JP	Z,FEOF
 830:			
 831:	0429  CDD607  		CALL	NCHR
 832:	042C  FE1A    		CP	EOF
 833:	042E  CA5F06  		JP	Z,FEOF
 834:			
 835:			
 836:	0431  CD1108  	RFSYM25:	CALL	HEX00		;Have first char of address - convert
 837:	0434  CD5C08  		CALL	TOTSYM		;Bump total of symbols loaded
 838:	0437  3AE22F  		LD	A,(FCBTYP)	;Is this a RFSYM file?
 839:	043A  FE53    		CP	'S'
 840:	043C  C4D607  		CALL	NZ,NCHR		;Eat addrress/symbol separator for RLST file
 841:	043F  3A322F  		LD	A,(MAXLEN)
 842:	0442  3D      		DEC	A
 843:	0443  32C309  		LD	(BYTES),A	;Init max symbol length counter
 844:	0446  CDD607  	RFSYM30:	CALL	NCHR		;Read symbol name char
 845:	0449  FE09    		CP	TAB
 846:	044B  CA7E04  		JP	Z,RFSYM45
 847:	044E  FE0D    		CP	CR
 848:	0450  CA7E04  		JP	Z,RFSYM45
 849:	0453  FE20    		CP	' '
 850:	0455  CA7E04  		JP	Z,RFSYM45
 851:	0458  02      		LD	(BC),A
 852:	0459  3A382F  	        LD	A,(CASE)        ;Check user requested case
 853:	045C  A7      		AND	A
 854:	045D  280D    		JR	Z,RFSYM35	;z - upper case	requested by user
 855:	045F  0A      		LD	A,(BC)		;Recover char
 856:	0460  FE41    		CP	'A'
 857:	0462  3808    		JR	C,RFSYM35	;c - must be number
 858:	0464  FE5B    		CP	'Z'+1
 859:	0466  D26C04  		JP	NC,RFSYM35
 860:	0469  F620    		OR	20H
 861:	046B  02      		LD	(BC),A          ;Restore symbol name char as lower case
 862:	046C  03      	RFSYM35:	INC	BC
 863:	046D  3AC309  		LD	A,(BYTES)
 864:	0470  3D      		DEC	A
 865:	0471  32C309  		LD	(BYTES),A
 866:	0474  20D0    		JR	NZ,RFSYM30
 867:	0476  CDD607  	RFSYM40:	CALL	NCHR
 868:	0479  FE21    		CP	21H
 869:	047B  D27604  		JP	NC,RFSYM40
 870:	047E  3A1509  	RFSYM45:	LD	A,(STAR)	;Check if this was ** in address field
 871:	0481  A7      		AND	A
 872:	0482  C29204  		JP	NZ,RFSYM50
 873:	0485  3A1309  		LD	A,(RELCHR)	;Check for external symbol
 874:	0488  FE20    		CP	' '
 875:	048A  CAA403  		JP	Z,RFSYM		;Space means absolute
 876:	048D  FE27    		CP	QUOTE
 877:	048F  CAA403  		JP	Z,RFSYM		;Quote means relocatable
 878:	0492  3A322F  	RFSYM50:	LD	A,(MAXLEN)
 879:	0495  B1      		OR	C
 880:	0496  4F      		LD	C,A
 881:	0497  03      		INC	BC		;Point BC to next higher symbol block so
 882:							;that rewinding by maxlen bytes will actually
 883:							;overlay this symbol.  This ensures that
 884:							;external symbols are not kept in table.
 885:			
 886:	0498  C3A403  		JP RFSYM
 887:			
 888:			
 889:	049B          	RPRN:				;Don't yet know if this .prn file was
 890:							;generated by M80 or Z80ASM.  To find out
 891:							;I pull a dirty trick.  I force a read
 892:							;and look for a formfeed, up to 80 characters
 893:							;of program title, a HT and "MACRO-80" in the
 894:							;I/O buffer, then I reset the pointer so that
 895:							;the next character read comes from the
 896:							;beginning of the file.  Will probably get
 897:							;confused by a HT in the program title.
 898:							;  jrs 14/11/88, 22/12/88.
 899:			
 900:	049B  CDD607  		CALL	NCHR		;Force a read.  First byte of file is
 901:							; returned in A, pointer to next byte in HL
 902:	049E  FE0C    		CP	FORMF		;Test character
 903:	04A0  2017    		JR	NZ,RPRNBB	;Exit M80 testing now if not a formfeed
 904:	04A2  0652    		LD	B,82		;Maximum number of characters to search
 905:	04A4  3E09    		LD	A,TAB		;What to look for
 906:	04A6  EDB1    		CPIR
 907:	04A8  200F    		JR	NZ,RPRNBB	;If no tab then not an M80 .prn file
 908:	04AA  EB      		EX	DE,HL		;Point at strings to be compared
 909:	04AB  210409  		LD	HL,RM80XX
 910:	04AE  46      		LD	B,(HL)		;Number of bytes to compare
 911:	04AF  23      		INC	HL
 912:	04B0          	RPRNAA:
 913:	04B0  1A      		LD	A,(DE)		;Compare bytes
 914:	04B1  BE      		CP	(HL)
 915:	04B2  C2B904  		JP	NZ,RPRNBB	;Exit loop if different
 916:	04B5  23      		INC	HL		; otherwise step the pointers
 917:	04B6  13      		INC	DE
 918:	04B7  10F7    		DJNZ	RPRNAA		;Loop until difference encountered or
 919:	04B9          	RPRNBB:				; all bytes compared.
 920:	04B9  218000  		LD	HL,IOBUF	;Reset buffer pointer
 921:	04BC  ED4BC109		LD	BC,(NTPA)
 922:	04C0  C24706  		JP	NZ,RSLR		;If not M80 then do Z80ASM .prn file load
 923:			
 924:				; End of dirty trick code
 925:			
 926:	04C3  11E508  		LD	DE,RPRNXX
 927:	04C6  ED531109		LD	(PSTRNG),DE
 928:	04CA  CDB608  		CALL	FSTRNG
 929:	04CD  FE1A    		CP	EOF
 930:	04CF  C2DB04  		JP	NZ,RPRN00
 931:	04D2          	RPRNCC:
 932:	04D2  114C09  		LD	DE,MSYMNF       ;display symbol table not found message
 933:	04D5  CD9E28  		CALL	PRINT
 934:	04D8  C3C506  		JP	FEOF50          ;check for more symbol files to load
 935:			
 936:	04DB          	RPRN00:
 937:	04DB  ED4BC109		LD	BC,(NTPA)       ;bc - current end of the tpa
 938:	04DF  0B      		DEC	BC              ;this points us into the next lower
 939:			                                ;symbol table block
 940:							;this is first char of symbol table
 941:	04E0  AF      		XOR	A
 942:	04E1  B5      		OR	L		;get next byte from file but without bumping
 943:							;pointer allowing us to reread same char (in
 944:							;case it is last character in buffer
 945:			
 946:	04E2  CCDE07  		CALL	Z,ZDREAD		;only do true read if last character was last
 947:							;in buffer
 948:	04E5  7E      		LD	A,(HL)
 949:	04E6  FE30    		CP	'0'
 950:	04E8  DAF004  		JP	C,RPR325	;non-numeric: macro-80 v3.44
 951:			
 952:	04EB  FE3A    		CP	'9'+1
 953:	04ED  DA9805  		JP	C,RPR4		;numeric:     macro-80 v3.4
 954:			
 955:			
 956:			;Macro-80 v3.4 dec 1980 symbol table load
 957:			
 958:	04F0  3A322F  	RPR325:	LD	A,(MAXLEN)
 959:	04F3  2F      		CPL
 960:	04F4  A1      		AND	C               ;now rewind within 8 or 16 byte block
 961:							;(depending on maxlen) in order to point
 962:							;to first byte
 963:	04F5  4F      		LD	C,A
 964:			
 965:	04F6  EB      	        EX	DE,HL           ;de - save file buffer pointer
 966:	04F7  21D930  		LD	HL,STACK + 16   ;check for encroaching symbol table
 967:	04FA  ED42    		SBC	HL,BC           ;versus current symbol table address
 968:	04FC  D29408  		JP	NC,ZMEM         ;nc - out of memory
 969:	04FF  EB      		EX	DE,HL           ;return file buffer pointer
 970:	0500  3A322F  		LD	A,(MAXLEN)
 971:	0503  57      		LD	D,A
 972:	0504  15      		DEC	D		;d - symbol name length
 973:	0505  AF      		XOR	A
 974:	0506  5F      		LD	E,A
 975:	0507  02      	RPR330:	LD	(BC),A          ;pre-clear name portion of symbol table to
 976:			                                ;nulls
 977:	0508  03      		INC	BC
 978:	0509  15      		DEC	D               ;now any name less than maxlen chars in length
 979:	050A  C20705  		JP	NZ,RPR330       ;is terminated with a null
 980:	050D  3A322F  		LD	A,(MAXLEN)
 981:	0510  2F      		CPL
 982:	0511  A1      		AND	C
 983:	0512  4F      		LD	C,A
 984:	0513  CDD607  	RPR335:	CALL	NCHR            ;next char from file buffer
 985:	0516  FE21    		CP	21H
 986:	0518  D25E05  		JP	NC,RPR351	;nc - this is first character of symbol name
 987:	051B  FE1A    		CP	EOF		;end of	file?
 988:	051D  CA5F06  		JP	Z,FEOF
 989:	0520  FE0A    		CP	LF		;line feed?
 990:	0522  C21305  		JP	NZ,RPR335
 991:	0525  CDD607  	RPR340:	CALL	NCHR		;get character following line feed
 992:	0528  FE0D    		CP	CR
 993:	052A  CA3205  		JP	Z,RPR342
 994:	052D  FE0C    		CP	FORMF		;form feed?
 995:	052F  C25E05  		JP	NZ,RPR351
 996:	0532  1E03    	RPR342:	LD	E,3		;symbols resume	three lines hence following
 997:							;a form feed character - so count linefeeds
 998:	0534  FE0D    		CP	CR		;did we find cr or a formf?
 999:	0536  C23A05  		JP	NZ,RPR345	;nz - formf
1000:	0539  1D      		DEC	E		;just look for two lf's
1001:	053A  CDD607  	RPR345:	CALL	NCHR
1002:	053D  FE0A    		CP	LF
1003:	053F  C23A05  		JP	NZ,RPR345	;loop til three found
1004:	0542  1D      		DEC	E
1005:	0543  C23A05  		JP	NZ,RPR345
1006:			
1007:	0546  AF      		XOR	A
1008:	0547  B5      		OR	L		;get next byte from file but without bumping
1009:							;pointer allowing us to reread same char in
1010:							;case it is last character in buffer
1011:			
1012:	0548  CCDE07  		CALL	Z,ZDREAD		;only do true read if last character was last
1013:							;in buffer
1014:	054B  7E      		LD	A,(HL)
1015:	054C  FE0D    		CP	CR		;four crlf's is eof
1016:	054E  CA5F06  		JP	Z,FEOF
1017:			
1018:	0551  CDD607  	RPR350:	CALL	NCHR            ;next char from file
1019:	0554  FE1A    		CP	EOF
1020:	0556  CA5F06  		JP	Z,FEOF
1021:	0559  FE09    		CP	TAB
1022:	055B  CA7505  		JP	Z,RPR355
1023:	055E  02      	RPR351:	LD	(BC),A		;move character	of symbol name
1024:	055F  3A382F  		LD	A,(CASE)        ;check user requested case
1025:	0562  A7      		AND	A
1026:	0563  280C    		JR	Z,RPR352        ;z - user wants upper case
1027:	0565  0A      		LD	A,(BC)          ;get char back from symbol table
1028:	0566  FE41    		CP	'A'
1029:	0568  3807    		JR	C,RPR352        ;must be numeric - no case here
1030:	056A  FE5B    		CP	'Z'+1
1031:	056C  3003    		JR	NC,RPR352
1032:	056E  C620    		ADD	A,20H
1033:	0570  02      		LD	(BC),A          ;replace char with lower case equivalent
1034:	0571  03      	RPR352:	INC	BC
1035:	0572  C35105  		JP	RPR350
1036:			
1037:	0575  3E04    	RPR355:	LD	A,4
1038:	0577  32C309  		LD	(BYTES),A
1039:	057A  CDD607  	RPR357:	CALL	NCHR
1040:	057D  FE20    		CP	' '
1041:	057F  CA7A05  		JP	Z,RPR357
1042:			
1043:	0582  CD1108  		CALL	HEX00           ;now read the next four characters from the
1044:							;file and convert them to a hex address -
1045:							;store in symbol table entry
1046:			
1047:			
1048:	0585  3A1309  		LD	A,(RELCHR)      ;recover char which followed address
1049:			
1050:	0588  FE20    		CP	' '             ;this char followed address
1051:	058A  2805    		JR	Z,RPR370        ;microsoft absolute address
1052:	058C  FE27    		CP	QUOTE           ;relocatable address?
1053:	058E  C2F004  		JP	NZ,RPR325
1054:			                                ;by not rewinding the symbol table pointer
1055:			                                ;the next symbol will overlay this one.
1056:			
1057:	0591  0B      	RPR370:	DEC	BC
1058:	0592  CD5C08  		CALL	TOTSYM
1059:			
1060:	0595  C3F004  		JP	RPR325
1061:			
1062:			
1063:			;macro-80 v3.44 symbol loading routine
1064:			
1065:	0598  3A322F  	RPR4:	LD	A,(MAXLEN)	;lower tpa address by maxlen
1066:	059B  2F      		CPL
1067:	059C  A1      		AND	C		;for storing next symbol and address
1068:	059D  4F      		LD	C,A		;bc - next address of symbol table entry
1069:							;     on an 8 or 16 byte boundary
1070:	059E  EB      		EX	DE,HL
1071:	059F  21D130  		LD	HL,STACK+8	;check for monster symbol table
1072:	05A2  A7      		AND	A
1073:	05A3  ED42    		SBC	HL,BC
1074:	05A5  D29408  		JP	NC,ZMEM		;end symbol load before	stack is clobbered
1075:	05A8  EB      		EX	DE,HL
1076:	05A9  3A322F  		LD	A,(MAXLEN)
1077:	05AC  3D      		DEC	A		;pre-clear symbol table entry with nulls
1078:	05AD  57      		LD	D,A
1079:	05AE  AF      		XOR	A
1080:	05AF  02      	RPR410:	LD	(BC),A		;for length equal to maxlen
1081:	05B0  03      		INC	BC
1082:	05B1  15      		DEC	D
1083:	05B2  20FB    		JR	NZ,RPR410
1084:	05B4  5A      		LD	E,D		;clear de for hex00
1085:	05B5  3E04    		LD	A,4		;convert four bytes of address
1086:	05B7  32C309  		LD	(BYTES),A
1087:	05BA  CDD607  	RPR420:	CALL	NCHR		;fetch next character in file
1088:	05BD  FE1A    		CP	EOF
1089:	05BF  CA5F06  		JP	Z,FEOF
1090:	05C2  FE30    		CP	'0'
1091:	05C4  3028    		JR	NC,RPR425	;nc - address digit
1092:	05C6  FE0A    		CP	LF
1093:	05C8  C2BA05  		JP	NZ,RPR420	;nz - leading space or cr
1094:			
1095:			
1096:	05CB  CDD607  		CALL	NCHR		;check character following lf
1097:	05CE  FE0D    		CP	CR
1098:	05D0  CA5F06  		JP	Z,FEOF		;blank line is eof
1099:			
1100:	05D3  FE0C    		CP	FORMF		;form feed?
1101:	05D5  C2EE05  		JP	NZ,RPR425	;no - first character of next address
1102:			
1103:	05D8  1E03    		LD	E,3		;must be form feed
1104:	05DA  CDD607  	RPR421:	CALL	NCHR
1105:	05DD  FE0A    		CP	LF		;three lf's follow form feed before symbols
1106:							;resume on next page
1107:	05DF  C2DA05  		JP	NZ,RPR421
1108:	05E2  1D      		DEC	E
1109:	05E3  C2DA05  		JP	NZ,RPR421
1110:			
1111:	05E6  CDD607  		CALL	NCHR
1112:	05E9  FE1A    		CP	EOF
1113:	05EB  CA5F06  		JP	Z,FEOF
1114:			
1115:	05EE          	RPR425:
1116:	05EE  CD1108  		CALL	HEX00		;have first char of address - convert
1117:			
1118:	05F1  CDD607  		CALL	NCHR		;eat address/symbol separator
1119:			
1120:	05F4  3A322F  		LD	A,(MAXLEN)
1121:	05F7  3D      		DEC	A
1122:	05F8  32C309  		LD	(BYTES),A	;max chars to store in symbol table
1123:			
1124:			
1125:	05FB  CDD607  	RPR430:	CALL	NCHR		;read symbol name char
1126:	05FE  FE21    		CP	21H
1127:	0600  DA2E06  		JP	C,RPR440	;found separator
1128:	0603  02      		LD	(BC),A
1129:	0604  3A382F  	        LD	A,(CASE)        ;check user requested case
1130:	0607  A7      		AND	A
1131:	0608  280C    		JR	Z,RPR435	;c - upper case	requested by user
1132:	060A  0A      		LD	A,(BC)		;recover char
1133:	060B  FE41    		CP	'A'
1134:	060D  3807    		JR	C,RPR435	;c - must be number
1135:	060F  FE5B    		CP	'Z'+1
1136:	0611  3003    		JR	NC,RPR435
1137:	0613  F620    		OR	20H
1138:	0615  02      		LD	(BC),A          ;restore symbol name char as lower case
1139:	0616  03      	RPR435:	INC	BC              ;bump symbol table pointer
1140:	0617  3AC309  		LD	A,(BYTES)	;character counter
1141:	061A  3D      		DEC	A
1142:	061B  32C309  		LD	(BYTES),A
1143:	061E  C2FB05  		JP	NZ,RPR430	;not max length
1144:			
1145:			
1146:	0621  CDD607  	RPR438:	CALL	NCHR		;eat chars until next address found
1147:	0624  FE1A    		CP	EOF
1148:	0626  CA5F06  		JP	Z,FEOF
1149:	0629  FE20    		CP	' '		;found symbol/address
1150:	062B  C22106  		JP	NZ,RPR438
1151:			
1152:			
1153:	062E  3A322F  	RPR440:	LD	A,(MAXLEN)
1154:	0631  2F      		CPL
1155:	0632  A1      		AND	C
1156:	0633  4F      		LD	C,A
1157:			
1158:	0634  3A1309  		LD	A,(RELCHR)      ;recover char which followed address
1159:	0637  FE20    		CP	' '             ;this char followed address
1160:	0639  2805    		JR	Z,RPR450        ;microsoft absolute address
1161:	063B  FE27    		CP	QUOTE           ;relocatable address?
1162:	063D  C29805  		JP	NZ,RPR4	        ;nz - must be  external symbol. we don't
1163:			                                ;actually load them or count them in total.
1164:			                                ;by not rewinding the symbol table pointer
1165:			                                ;the next symbol will overlay this one.
1166:			
1167:	0640  0B      	RPR450:	DEC	BC
1168:	0641  CD5C08  		CALL	TOTSYM
1169:	0644  C39805  		JP	RPR4
1170:			
1171:			; SLR Z80ASM symbol table loading routines
1172:			
1173:	0647          	RSLR:
1174:	0647  11F008  		LD	DE,RSLRXX	;If this .prn file really is a Z80ASM
1175:	064A  ED531109		LD	(PSTRNG),DE	;product then we can use existing code
1176:	064E  CDB608  		CALL	FSTRNG		;to load the symbols.
1177:	0651  FE1A    		CP	EOF
1178:	0653  C2A403  		JP	NZ,RFSYM
1179:	0656  114C09  		LD	DE,MSYMNF       ;display symbol table not found message
1180:	0659  CD9E28  		CALL	PRINT
1181:	065C  C3C506  		JP	FEOF50          ;check for more symbol files to load
1182:			
1183:			
1184:	065F          	FEOF:                           ;We always pre-decrement the symbol table
1185:			                                ;pointer in anticipation of storing the next
1186:			                                ;symbol.  Now that we hit the end of a symbol
1187:			                                ;table we must adjust the pointer in
1188:			                                ;preparation for loading the symbols from the
1189:			                                ;next file (if there is one).
1190:	065F  3A322F  	        LD	A,(MAXLEN)
1191:	0662  6F      		LD	L,A
1192:	0663  2600    		LD	H,0
1193:	0665  2C      		INC	L
1194:	0666  09      		ADD	HL,BC           ;point to last loaded symbol
1195:	0667  44      		LD	B,H
1196:	0668  4D      		LD	C,L             ;bc - spare copy
1197:	0669  2F      		CPL
1198:	066A  A1      		AND	C
1199:	066B  4F      		LD	C,A
1200:	066C  ED43C109		LD	(NTPA),BC       ;save current end of tpa address
1201:	0670  3A1609  	        LD	A,(NSYMHI)      ;hi order number of symbols loaded (bcd)
1202:	0673  CDFB07  		CALL	HEXC            ;convert to ascii
1203:	0676  67      		LD	H,A             ;returned in a - move to h (other digit in l)
1204:	0677  221809  		LD	(MHEX),HL       ;store in message
1205:	067A  3A1709  		LD	A,(NSYMLO)
1206:	067D  CDFB07  		CALL	HEXC            ;convert lo order
1207:	0680  67      		LD	H,A
1208:	0681  221A09  		LD	(MHEX+2),HL
1209:	0684  111D09  		LD	DE,MSYMBB       ;display number of symbols loaded message
1210:	0687  0E09    		LD	C,9
1211:	0689  CD0500  		CALL	BDOS
1212:	068C  111809  		LD	DE,MHEX         ;now look thru ascii number of symbols to
1213:			                                ;strip leading zeros
1214:	068F  0603    		LD	B,3
1215:	0691  1A      	FEOF10:	LD	A,(DE)
1216:	0692  FE30    		CP	'0'
1217:	0694  2003    		JR	NZ,FEOF20       ;nz - found first non-zero
1218:	0696  13      		INC	DE
1219:	0697  10F8    		DJNZ	FEOF10          ;if first three chars zero - fall thru and
1220:			                                ;print the fourth regardless
1221:	0699  0E09    	FEOF20: LD      C,09
1222:	069B  CD0500  		CALL	BDOS            ;print the number as string ending with $
1223:	069E  CD3B26  		CALL	CRLF
1224:	06A1  2A0D09  		LD	HL,(TSYM)       ;now add in bcd total for this file to bcd
1225:			                                ;total for all files
1226:	06A4  ED5B1609		LD	DE,(NSYM)       ;tsym - total for all files
1227:			                                ;nsym - total for this file
1228:	06A8  7C      		LD	A,H
1229:	06A9  82      		ADD	A,D
1230:	06AA  27      		DAA
1231:	06AB  67      		LD	H,A
1232:	06AC  7D      		LD	A,L
1233:	06AD  8B      		ADC	A,E
1234:	06AE  27      		DAA
1235:	06AF  6F      		LD	L,A
1236:	06B0  220D09  		LD	(TSYM),HL
1237:	06B3  210000  		LD	HL,00           ;clear out total for next file
1238:	06B6  221609  		LD	(NSYM),HL
1239:	06B9  2ABF09  		LD	HL,(Z8EB)
1240:	06BC  110323  		LD	DE,SYMFLG-Z8EORG
1241:	06BF  19      		ADD	HL,DE           ;hl - pointer to symbol flag in hi memory
1242:	06C0  AF      		XOR	A
1243:	06C1  77      		LD	(HL),A		;zero -	symbol table present
1244:	06C2  32032F  		LD	(SYMFLG),A      ;also set flag in lo memory where we are
1245:			                                ;currently so that fsym knows theres a symbol
1246:			                                ;table to search thru if the user specified a
1247:			                                ;symbol name bias as part of the command line
1248:			
1249:	06C5  3A202F  	FEOF50:	LD	A,(DELIM)       ;check command line delimter
1250:	06C8  A7      		AND	A               ;test for end of line null
1251:	06C9  C21103  		JP	NZ,ZSYM         ;nz - not null means more files
1252:			
1253:			
1254:			
1255:			
1256:	06CC  2AC109  	LOAD:	LD	HL,(NTPA)	;current end of	memory
1257:	06CF  3A032F  		LD	A,(SYMFLG)	;check for symbol table
1258:	06D2  A7      		AND	A
1259:	06D3  2008    		JR	NZ,LOAD00	;nz - no symbol	table
1260:	06D5  57      		LD	D,A
1261:	06D6  3A322F  		LD	A,(MAXLEN)
1262:	06D9  5F      		LD	E,A		;de - length of a symbol table block
1263:	06DA  1C      		INC	E
1264:	06DB  ED52    		SBC	HL,DE		;compensate for	pre-increment of pointer
1265:	06DD  ED5B0600	LOAD00:	LD	DE,(06)		;de - real entry point to bdos
1266:	06E1  220600  		LD	(06),HL		;point to our origin in	hi memory
1267:	06E4  36C3    		LD	(HL),IJP		;init jump to bdos at start of z8e
1268:	06E6  23      		INC	HL
1269:	06E7  73      		LD	(HL),E
1270:	06E8  23      		INC	HL
1271:	06E9  72      		LD	(HL),D
1272:	06EA  1E00    		LD	E,0		;de - old start of bdos address in also our
1273:			                                ;ending address
1274:	06EC  2ABF09  		LD	HL,(Z8EB)       ;load out starting address in hi memory
1275:	06EF  011000  		LD	BC,Z8E-Z8EORG   ;fetch the number of bytes between z8e's base
1276:			                                ;address and the entry point of the command
1277:			                                ;processor  - internal symbol table size
1278:			
1279:	06F2  09      		ADD	HL,BC
1280:	06F3  44      		LD	B,H
1281:	06F4  4D      		LD	C,L		;BC - relocated	z8e address
1282:	06F5  EB      		EX	DE,HL           ;DE - entry point z8e   HL - old start of bdos
1283:	06F6  2B      		DEC	HL              ;HL - last byte in our memory
1284:	06F7  70      		LD	(HL),B
1285:	06F8  2B      		DEC	HL
1286:	06F9  71      		LD	(HL),C		;z8e (monitor entry point) on stack
1287:	06FA  F9      		LD	SP,HL           ;now set current stack to just below our
1288:			                                ;return address
1289:	06FB  EB      		EX	DE,HL           ;hl - relocated address z8e
1290:	06FC  23      		INC	HL
1291:	06FD  23      		INC	HL              ;hl - points to ld  sp,0000 instruction at the
1292:			                                ;start of the command processor. replace 0000
1293:			                                ;with the address bdos-1
1294:	06FE  73      		LD	(HL),E          ;set real stack address
1295:	06FF  23      		INC	HL
1296:	0700  72      		LD	(HL),D
1297:	0701  2ABF09  		LD	HL,(Z8EB)	;base of relocated code
1298:	0704  11D923  		LD	DE,FCB-Z8EORG	;relative offset from start of monitor
1299:	0707  19      		ADD	HL,DE
1300:	0708  EB      		EX	DE,HL		;de - fcb address in relocated monitor in hi
1301:			                                ;memory
1302:	0709  21C409  		LD	HL,ZBUF		;
1303:	070C  011000  		LD	BC,16
1304:	070F  EDB0    		LDIR			;init fcb with saved file name
1305:	0711  119709  		LD	DE,MZ8ELD	;print memory space occupied by	z8e
1306:	0714  CD9E28  		CALL	PRINT
1307:	0717  2ABF09  		LD	HL,(Z8EB)       ;display our base address in upper memory
1308:	071A  CD6426  		CALL	OUTADR
1309:	071D  3E2D    		LD	A,'-'
1310:	071F  CDDD25  		CALL	TTYO
1311:	0722  CD4D26  		CALL 	RSPACE
1312:	0725  CD4D26  		CALL	RSPACE
1313:	0728  2A0600  		LD	HL,(06)         ;this points to the new jump to bdos
1314:	072B  23      		INC	HL
1315:	072C  5E      		LD	E,(HL)          ;de - old start of bdos address
1316:	072D  23      		INC	HL
1317:	072E  56      		LD	D,(HL)
1318:	072F  EB      		EX	DE,HL
1319:	0730  2E00    		LD	L,0             ;256 byte boundary to bypass cp/m serial no.
1320:	0732  CD6426  		CALL	OUTADR
1321:			
1322:	0735  3A032F  		LD	A,(SYMFLG)      ;test for presence of symbol table
1323:	0738  A7      		AND	A
1324:	0739  204C    		JR	NZ,LOAD40       ;nz - no table
1325:	073B  118309  		LD	DE,MSYMLD       ;display start address of symbol table message
1326:	073E  CD9E28  		CALL	PRINT
1327:	0741  2A0600  		LD	HL,(06)         ;vector to bdos is start of symbol table
1328:	0744  CD6426  		CALL	OUTADR
1329:	0747  3E2D    		LD	A,'-'
1330:	0749  CDDD25  		CALL	TTYO
1331:	074C  CD4D26  		CALL	RSPACE
1332:	074F  CD4D26  		CALL	RSPACE
1333:	0752  2ABF09  		LD	HL,(Z8EB)       ;start of internal symbol table is end of
1334:			                                ;symbol table built from files
1335:	0755  2B      		DEC	HL
1336:	0756  CD6426  		CALL	OUTADR
1337:			
1338:	0759  3A0D09  		LD	A,(TSYMHI)      ;total number of symbols from all files (bcd)
1339:	075C  CDFB07  		CALL	HEXC            ;convert to ascii
1340:	075F  67      		LD	H,A             ;move hi order ascii digit to h
1341:	0760  221809  		LD	(MHEX),HL       ;store double ascii digit
1342:	0763  3A0E09  		LD	A,(TSYMLO)
1343:	0766  CDFB07  		CALL	HEXC            ;convert lo order
1344:	0769  67      		LD	H,A
1345:	076A  221A09  		LD	(MHEX+2),HL     ;save in string
1346:	076D  113809  		LD	DE,TSYMBB       ;total symbols message
1347:	0770  0E09    		LD	C,9
1348:	0772  CD0500  		CALL	BDOS
1349:	0775  111809  		LD	DE,MHEX         ;address of ascii digits
1350:	0778  0603    		LD	B,3             ;check for leading zeros
1351:	077A  1A      	LOAD20:	LD	A,(DE)
1352:	077B  FE30    		CP	'0'
1353:	077D  2003    		JR	NZ,LOAD30       ;nz - found first nz in string
1354:	077F  13      		INC	DE
1355:	0780  10F8    		DJNZ	LOAD20          ;check first three digits then fall thru and
1356:			                                ;print fourth regardless
1357:	0782  0E09    	LOAD30:	LD	C,09
1358:	0784  CD0500  		CALL	BDOS
1359:			
1360:	0787  2A0600  	LOAD40:	LD	HL,(06)
1361:	078A  2B      		DEC	HL              ;hl - address of new tpa
1362:	078B  11AB09  		LD	DE,MNVMEM       ;display address as memory available
1363:	078E  CD9E28  		CALL	PRINT
1364:	0791  CD6426  		CALL	OUTADR
1365:	0794  CD3B26  		CALL	CRLF
1366:	0797  3600    		LD	(HL),0          ;now store two zeros at the top of the tpa and
1367:			                                ;set stack pointer to this very same address.
1368:			                                ;this allows users to do a warm boot via ret
1369:			                                ;in the same way as if they had been loaded by
1370:			                                ;cp/m.
1371:	0799  2B      		DEC	HL
1372:	079A  3600    		LD	(HL),0
1373:	079C  ED4BBF09		LD	BC,(Z8EB)       ;our relocated address in hi memory
1374:	07A0  EB      		EX	DE,HL           ;de - last available location in tpa
1375:	07A1  21B123  		LD	HL,SPREG-Z8EORG ;address (relative to the start of z8e) where
1376:			                                ;we store the user stack pointer address
1377:	07A4  09      		ADD	HL,BC           ;hl - pointer to
1378:	07A5  73      		LD	(HL),E          ;save user stack in spreg in hi memory
1379:	07A6  23      		INC	HL
1380:	07A7  72      		LD	(HL),D
1381:	07A8  211000  		LD	HL,Z8E-Z8EORG
1382:	07AB  3AC509  		LD	A,(ZBUFNM)	;first char of file name
1383:	07AE  FE20    		CP	' '             ;do we have a file to load?
1384:	07B0  2813    		JR	Z,LOAD50        ;z - no
1385:	07B2  11EC29  		LD	DE,MLDG         ;display loading message and target file name
1386:	07B5  CD9B28  		CALL	NPRINT
1387:	07B8  11D409  		LD	DE,ZNMBUF
1388:	07BB  CD9E28  		CALL	PRINT
1389:			                                ;enter the monitor in hi memory at entry
1390:			                                ;point lldr10
1391:			
1392:	07BE  21A411  		LD	HL,LLDR10-Z8EORG
1393:	07C1  ED4BBF09		LD	BC,(Z8EB)
1394:	07C5  09      	LOAD50:	ADD	HL,BC           ;hl - actual address of lldr10 in hi memory
1395:	07C6  EB      		EX	DE,HL           ;now clear out the buffer at 80h so the user
1396:			                                ;program doesn't mistakenly think that our
1397:			                                ;command line tail is really his.
1398:	07C7  218000  		LD	HL,IOBUF
1399:	07CA  3600    		LD	(HL),0          ;set number of chars zero (80h)
1400:	07CC  23      		INC	HL
1401:	07CD  067F    		LD	B,127           ;clear until start of tpa
1402:	07CF  3620    	LOAD60:	LD	(HL),' '
1403:	07D1  23      		INC	HL
1404:	07D2  10FB    		DJNZ	LOAD60
1405:	07D4  EB      		EX	DE,HL           ;lldr10 address back to HL
1406:	07D5  E9      		JP	(HL)            ;Hi-ho, hi-ho to the loader we must go
1407:			
1408:			
1409:			
1411:			;This routine reads one char from the disk I/O
1412:			;buffer returning it in A. Upon entry we check
1413:			;the low order buffer pointer - 0 means we hit
1414:			;the  256 boundary (end of buffer) and a  read
1415:			;is needed.
1416:			
1417:	07D6  AF      	NCHR:	XOR	A
1418:	07D7  B5      		OR	L
1419:	07D8  CCDE07  		CALL	Z,ZDREAD
1420:	07DB  7E      		LD	A,(HL)
1421:	07DC  23      		INC	HL
1422:	07DD  C9      		RET
1423:			
1424:	07DE  C5      	ZDREAD:	PUSH	BC
1425:	07DF  D5      		PUSH	DE
1426:	07E0  11D92F  		LD	DE,FCB
1427:	07E3  0E14    		LD	C,20            ;sequential file read
1428:	07E5  CD0500  		CALL	BDOS
1429:	07E8  A7      		AND	A               ;test for error
1430:	07E9  218000  		LD	HL,IOBUF        ;assume ok - init i/o buffer address
1431:	07EC  D1      		POP	DE
1432:	07ED  C1      		POP	BC
1433:	07EE  C8      		RET	Z               ;z - no errors
1434:	07EF  114C09  		LD	DE,MSYMNF       ;display symbol table not found message
1435:	07F2  CD9E28  		CALL	PRINT
1436:	07F5  31C930  		LD	SP,STACK        ;reinit stack
1437:	07F8  C3C506  		JP	FEOF50          ;check for more symbol files to load
1438:			
1439:			
1440:			;hexc
1441:			;Convert byte in a to two ASCII hex digits.
1442:			;return: a - converted hi order digit
1443:			;        l -           lo order digit
1444:			
1445:	07FB  67      	HEXC:	LD	H,A
1446:	07FC  0F      		RRCA
1447:	07FD  0F      		RRCA
1448:	07FE  0F      		RRCA
1449:	07FF  0F      		RRCA
1450:	0800  CD0508  		CALL	HEXC00
1451:	0803  6F      		LD	L,A
1452:	0804  7C      		LD	A,H
1453:	0805  E60F    	HEXC00:	AND	0FH
1454:	0807  C690    		ADD	A,90H
1455:	0809  27      		DAA
1456:	080A  CE40    		ADC	A,40H
1457:	080C  27      		DAA
1458:	080D  C9      		RET
1459:			
1460:			
1461:			;hex:
1462:			;This routine is called by the symbol table
1463:			;building routines, .sym and .prn and its
1464:			;function is to convert ascii addresses
1465:			;into binary.  Since we are reading files in
1466:			;a known format we don't init any loop counts;
1467:			;instead, we look for delimeters.
1468:			
1469:			
1470:	080E  CDD607  	HEX:	CALL	NCHR            ;get char from disk i/o buffer
1471:	0811  FE3A    	HEX00:	CP	3AH             ;convert ascii to hex
1472:	0813  DA1808  		JP	C,HEX10         ;c - must be delimeter
1473:	0816  D607    		SUB	7
1474:	0818  D630    	HEX10:	SUB	'0'
1475:	081A  EB      		EX	DE,HL           ;shift hl left four
1476:	081B  29      		ADD	HL,HL
1477:	081C  29      		ADD	HL,HL
1478:	081D  29      		ADD	HL,HL
1479:	081E  29      		ADD	HL,HL
1480:	081F  B5      		OR	L               ;or in this new digit
1481:	0820  6F      		LD	L,A
1482:	0821  EB      		EX	DE,HL
1483:	0822  3AC309  		LD	A,(BYTES)
1484:	0825  3D      		DEC	A
1485:	0826  32C309  		LD	(BYTES),A
1486:	0829  C20E08  		JP	NZ,HEX
1487:	082C  CDD607  		CALL	NCHR
1488:	082F  FE49    		CP	'I'             ;global?
1489:	0831  CCD607  		CALL	Z,NCHR          ;z - need to read next to determine absolute
1490:			                                ;    or relocatable
1491:			
1492:	0834  321309  		LD	(RELCHR),A      ;we need to save this character for .prn files
1493:			                                ;so we can tell whether to add this symbol
1494:			                                ;to the count of symbols loaded.  if this
1495:			                                ;is an external name we skip the add.
1496:			
1497:	0837  FE20    		CP	' '             ;space means absolute
1498:	0839  280A    		JR	Z,HEX30         ;no bias added to absolute symbols
1499:	083B  3A122F  		LD	A,(BIASLO)
1500:	083E  83      		ADD	A,E             ;add in bias as specified by user or default
1501:			                                ;as initialized by us (zero)
1502:	083F  5F      		LD	E,A
1503:	0840  3A132F  		LD	A,(BIASHI)
1504:	0843  8A      		ADC	A,D
1505:	0844  57      		LD	D,A
1506:	0845  3A322F  	HEX30:	LD	A,(MAXLEN)      ;now point to last byte of symbol table
1507:			                                ;entry, which is where we will store
1508:			                                ;address just computed
1509:	0848  2F      		CPL
1510:	0849  A1      		AND	C
1511:	084A  4F      		LD	C,A
1512:	084B  3A322F  		LD	A,(MAXLEN)
1513:	084E  B1      		OR	C
1514:	084F  4F      		LD	C,A             ;never worry about carry - we always start
1515:			                                ;with 256 boundary
1516:	0850  7A      	        LD	A,D             ;store lo order symbol address
1517:	0851  02      		LD	(BC),A
1518:	0852  0B      		DEC	BC		;point to penultimate byte in block
1519:	0853  7B      		LD	A,E             ;hi order byte of address into symbol table
1520:	0854  02      		LD	(BC),A
1521:	0855  3A322F  		LD	A,(MAXLEN)	;mask to rewind symbol table pointer to the
1522:							;start of this block
1523:	0858  2F      		CPL
1524:	0859  A1      		AND	C
1525:	085A  4F      		LD	C,A
1526:	085B  C9      		RET
1527:			
1528:			
1529:	085C  111709  	TOTSYM:	LD	DE,NSYMLO       ;nsym - bcd running count of the number of
1530:	085F  1A      		LD	A,(DE)		;       symbols loaded so far
1531:	0860  C601    		ADD	A,1		;bump by one symbol
1532:	0862  27      		DAA	;keep bcd format
1533:	0863  12      		LD	(DE),A
1534:	0864  D0      		RET	NC
1535:	0865  1B      		DEC	DE              ;account for carry by bumping hi order byte
1536:	0866  1A      		LD	A,(DE)
1537:	0867  C601    		ADD	A,1
1538:	0869  27      		DAA
1539:	086A  12      		LD	(DE),A
1540:	086B  C9      		RET
1541:			
1542:			
1543:			;zstx:
1544:			;Possible syntax error was detected as lfcb tried to init the FCB.
1545:			;However, we never keep track of how many files appeared in the
1546:			;command line we just keep calling lfcb.  Hence, we will always get
1547:			;an error return at some point when the input buffer runs out of
1548:			;valid input.  We check for real syntax error or end of command
1549:			;line by examining the first byte of the parse buffer:  if zero then
1550:			;prsr found no valid characters in the input buffer and this is the
1551:			;end of input - else, lfcb found real syntax error.
1552:			
1553:			
1554:	086C  3A5530  	ZSTX:	LD	A,(PRSBF)
1555:	086F  A7      		AND	A		;real syntax error - or	end of input?
1556:	0870  CACC06  		JP	Z,LOAD          ;z - more files
1557:	0873  11EC29  		LD	DE,MLDG		;display loading message and symbol name
1558:							;to preserve the syntax used on good loads
1559:	0876  CD9B28  		CALL	NPRINT
1560:	0879  115530  		LD	DE,PRSBF	;display file name currently in parse buffer so
1561:							;user knows where goof was
1562:	087C  CD9E28  		CALL	PRINT
1563:	087F  CD3B26  		CALL	CRLF
1564:	0882  111B2A  		LD	DE,MSNTX	;now display syntax error
1565:	0885  CD9E28  		CALL	PRINT
1566:	0888  C3C506  		JP	FEOF50		;check for more files to load
1567:			
1568:			
1569:	088B  11F629  	ZFNF:	LD	DE,MFILNF	;display file not found
1570:	088E  CD9E28  		CALL	PRINT
1571:	0891  C3C506  		JP	FEOF50
1572:			
1573:			
1574:	0894  112A2A  	ZMEM:	LD	DE,MMEMXX	;display out of memory message
1575:	0897  CD9E28  		CALL	PRINT
1576:	089A  CD3B26  		CALL	CRLF
1577:	089D  21322F  		LD	HL,MAXLEN
1578:	08A0  6E      		LD	L,(HL)
1579:	08A1  2600    		LD	H,00
1580:	08A3  09      		ADD	HL,BC
1581:	08A4  22C109  		LD	(NTPA),HL
1582:	08A7  C3CC06  		JP	LOAD
1583:			
1584:			
1585:	08AA  116509  	ZOFF:	LD	DE,MINVOF	;display invalid offset using 0000 message
1586:	08AD  CD9E28  		CALL	PRINT
1587:	08B0  210000  		LD	HL,00
1588:	08B3  C38303  		JP	ZSYM10
1589:			
1590:			
1591:	08B6          	FSTRNG:
1592:	08B6  C5      		PUSH	BC
1593:	08B7  D5      		PUSH	DE
1594:	08B8          	FSTR00:
1595:	08B8  ED5B1109		LD	DE,(PSTRNG)     ;address of canned string pointer
1596:	08BC  1A      		LD	A,(DE)		;length
1597:	08BD  47      		LD	B,A
1598:	08BE  13      		INC	DE
1599:	08BF  CDD607  	FSTR10:	CALL	NCHR		;get char
1600:	08C2  FE1A    		CP	EOF
1601:	08C4  CAD008  		JP	Z,FSTR20
1602:	08C7  EB      		EX	DE,HL		;DE - buffer ptr  HL - "symbols:" string ptr
1603:	08C8  BE      		CP	(HL)
1604:	08C9  EB      		EX	DE,HL
1605:	08CA  C2B808  		JP	NZ,FSTR00	;mismatch read more from file
1606:	08CD  13      		INC	DE
1607:	08CE  10EF    		DJNZ	FSTR10          ;check entire string length
1608:	08D0  D1      	FSTR20:	POP	DE
1609:	08D1  C1      		POP	BC
1610:	08D2  C9      		RET
1611:			
1612:	08D3  11      	RLSTXX:	DEFB	RLSTSZ		;string length
1613:	08D4  53796D62		DEFB	'Symbol Table:'
	      6F6C2054
	      61626C65
	      3A
1614:	08E1  0D0A0D0A		DEFB	CR,LF,CR,LF
1615:	0011          	RLSTSZ	EQU	$ - RLSTXX - 1
1616:			
1617:			
1618:	08E5  0A      	RPRNXX:	DEFB	RPRNSZ		;string length
1619:	08E6  53796D62		DEFB	'Symbols:'	;string to search for in M80's .prn files
	      6F6C733A
1620:							;indicating start of symbol table
1621:	08EE  0D0A    		DEFB	CR,LF
1622:	000A          	RPRNSZ	EQU	$ - RPRNXX - 1
1623:			
1624:	08F0  13      	RSLRXX:	DEFB	RSLRSZ
1625:	08F1  53796D62		DEFB	'Symbols Detected.'
	      6F6C7320
	      44657465
	      63746564
	      2E
1626:	0902  0D0A    		DEFB	CR,LF
1627:	0013          	RSLRSZ	EQU	$ - RSLRXX - 1
1628:			
1629:	0904  08      	RM80XX:	DEFB	RM80SZ
1630:	0905  4D414352		DEFB	'MACRO-80'
	      4F2D3830
1631:	0008          	RM80SZ	EQU	$ - RM80XX - 1
1632:			
1633:	090D          	TSYM:
1634:	090D  00      	TSYMHI:	DEFB	0
1635:	090E  00      	TSYMLO:	DEFB	0
1636:			
1637:	090F  0000    	USYMBL:	DEFW	0
1638:			
1639:	0911  0000    	PSTRNG:	DEFW	0
1640:			
1641:	0913  00      	RELCHR:	DEFB	0
1642:			
1643:	0914  00      	BIDPRN:	DEFB	0
1644:			
1645:	0915  00      	STAR:	DEFB	0
1646:			
1647:	0916          	NSYM:
1648:	0916  00      	NSYMHI:	DEFB	0
1649:	0917  00      	NSYMLO:	DEFB	0
1650:	0918  20202020	MHEX:	DEFB	'    '
1651:	091C  24      		DEFB	'$'
1652:			
1653:	091D  4E756D62	MSYMBB:	DEFB	'Number Of Symbols Loaded: $'
	      6572204F
	      66205379
	      6D626F6C
	      73204C6F
	      61646564
	      3A2024
1654:			
1655:	0938  0D0A    	TSYMBB:	DEFB	CR,LF
1656:	093A  546F7461		DEFB	'Total Symbols:   $'
	      6C205379
	      6D626F6C
	      733A2020
	      2024
1657:			
1658:	094C  53796D62	MSYMNF:	DEFB	'Symbol Table Not Found'
	      6F6C2054
	      61626C65
	      204E6F74
	      20466F75
	      6E64
1659:	0962  0D0A00  		DEFB	CR,LF,0
1660:			
1661:	0965  496E7661	MINVOF:	DEFB	'Invalid Offset - Using 0000'
	      6C696420
	      4F666673
	      6574202D
	      20557369
	      6E672030
	      303030
1662:	0980  0D0A00  		DEFB	CR,LF,0
1663:			
1664:	0983  0D0A    	MSYMLD:	DEFB	CR,LF
1665:	0985  53796D62		DEFB	'Symbol Table:    '
	      6F6C2054
	      61626C65
	      3A202020
	      20
1666:	0996  00      		DEFB	0
1667:			
1668:	0997  0D0A    	MZ8ELD:	DEFB	CR,LF
1669:	0999  5A384520		DEFB	'Z8E Relocated:   '
	      52656C6F
	      63617465
	      643A2020
	      20
1670:	09AA  00      		DEFB	0
1671:			
1672:	09AB  0D0A    	MNVMEM:	DEFB	CR,LF
1673:	09AD  546F7020		DEFB	'Top Of Memory:   '
	      4F66204D
	      656D6F72
	      793A2020
	      20
1674:	09BE  00      		DEFB	00
1675:			
1676:	09BF  00      	Z8EB:	DEFB	00
1677:	09C0  00      	Z8EBH:	DEFB	00
1678:	09C1  0000    	NTPA:	DEFW	00
1679:			
1680:	09C3  00      	BYTES:	DEFB	00
1681:			
1682:	09C4  00      	ZBUF:	DEFB	00
1683:	09C5  00000000	ZBUFNM:	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	      00000000
	      00000000
	      000000
1684:	09D4          	ZNMBUF:
1685:	09D4 .. 0A1B 00		DEFS	72
1686:			; 	REPT	18
1687:			; 	DEFW	0,0
1688:			; 	ENDM
1689:	0000          	    IF	ASMB
1691:			    ELSE
1692:	0A1C          	INIT:
1693:			    ENDIF
1694:	0A1C  C9      		RET
1695:	0A1D .. 0B1B 00		DEFS	255
1697:			;******************************************************************************
1698:			;*
1699:			;*	z8e:	Entry point to monitor
1700:			;*
1701:			;*		Each command begins with the output of the '*' prompt.
1702:			;*		Command	character is validated by checking the cmd table,
1703:			;*
1704:			;*		Relative position of command letter in cmd table also used
1705:			;*		as index into command jump table jtcmd.
1706:			;*
1707:			;*		All commands entered with b = 0.
1708:			;*
1709:			;******************************************************************************
1710:			
1711:			
1712:	0C00          		ORG	($+255) AND 0FF00H
1713:			;was	org	256*(($+255)/256)
1714:			
1715:	0C00          	Z8EORG:
1716:							;Note: first three bytes here become a jump to
1717:	0C00 .. 0C0F 00		DEFS	16		;      BDOS after we are loaded
1718:							;
1719:							;This is the internal symbol table
1720:			
1721:	0C10  A7      	Z8E:	AND	A		;Any do-nothing	instruction with the sign
1722:							;bit set to indicate end of internal symbol
1723:							;table
1724:			
1725:	0C11  31      		DEFB	31H		;LD SP,nnnn - Load monitor stack pointer
1726:	0C12  0080    	Z8ESP:	DEFW	8000H		;Actual	address	filled in by nint at load
1727:							;time when we figure out where bdos is
1728:			
1729:	0C14  F3      	Z8ECMD:	DI			; lock interrupts and enable local RST38
1730:	0C15  0E31    		ld c,'1'
1731:	0C17  CD9FFD  		call bbconout
1732:	0C1A  CD94FD  		call bbconin
1733:	0C1D  CD531D  		CALL	ENAISR		;
1734:			; 	CALL	GDISIN		;
1735:	0C20  0E32    		ld c,'2'
1736:	0C22  CD9FFD  		call bbconout
1737:	0C25  CD94FD  		call bbconin
1738:	0C28  21100C  		LD	HL,Z8E
1739:	0C2B  E5      		PUSH	HL
1740:	0C2C  11D729  		LD	DE,PROMPT	;display prompt (asterisk)
1741:	0C2F  CD9B28  		CALL	NPRINT
1742:	0C32  0E33    		ld c,'3'
1743:	0C34  CD9FFD  		call bbconout
1744:	0C37  CD94FD  		call bbconin
1745:	0C3A  213A2F  		LD	HL,JSTEPF	;full screen debugging in effect?
1746:	0C3D  7E      		LD	A,(HL)
1747:	0C3E  A7      		AND	A
1748:	0C3F  201C    		JR	NZ,Z8E10	;nz - no
1749:			
1750:	0C41  0E34    		ld c,'4'
1751:	0C43  CD9FFD  		call bbconout
1752:	0C46  CD94FD  		call bbconin
1753:	0C49  0E0A    		LD	C,10
1754:	0C4B  CD5426  		CALL	SPACES		;If this was jdbg clear command line residue
1755:	0C4E  060A    		LD	B,10
1756:	0C50  CD6828  	Z8E00:	CALL	BKSP
1757:	0C53  10FB    		DJNZ	Z8E00
1758:	0C55  0E35    		ld c,'5'
1759:	0C57  CD9FFD  		call bbconout
1760:	0C5A  CD94FD  		call bbconin
1761:			
1762:	0C5D  CDFD25  	Z8E10:	CALL	INCHAR		;Read in command character
1763:	0C60  CD94FD  		call 	bbconin
1764:			
1765:			; +++ jrs 3.5.6 ++++++++++++++++++
1766:	0C63  FE0D    		CP	CR		;+Check for empty command line
1767:	0C65  2012    		JR	NZ,Z8E16	;+Something there - process it
1768:	0C67  3AE729  		LD	A,(LCMD)	;+Nothing - see if S or J was last command
1769:	0C6A  FE4A    		CP	'J'		;+Repeat 'J' command?
1770:	0C6C  CAB60D  		JP	Z,JDBG00	;+
1771:	0C6F  210100  		LD	HL,1		;+
1772:	0C72  FE53    		CP	'S'		;+Repeat 'S' command?
1773:	0C74  CAA315  		JP	Z,STEP40	;+
1774:	0C77  3E0D    		LD	A,CR		;+
1775:	0C79          	Z8E16:				;+
1776:			; ++++++++++++++++++++++++++++++++
1777:	0C79  CD3226  		CALL	IXLT		;Translate to upper case for compare
1778:	0C7C  32E729  		LD	(LCMD),A
1779:	0C7F  FE4A    		CP	'J'		;If command is anything but j then indicate
1780:							;that screen is corrupted.  at next invokation
1781:							;jdbg will know to repaint the screen.
1782:	0C81  2803    		JR	Z,Z8E20
1783:	0C83  323A2F  		LD	(JSTEPF),A	;Full screen flag nz - full screen debugging
1784:							;in progress
1785:			
1786:			
1787:	0C86  011B00  	Z8E20:	LD	BC,NCMD		;total number of commands
1788:	0C89  21AD29  		LD	HL,CMD		;table of ascii	command	characters
1789:	0C8C  EDB1    		CPIR
1790:	0C8E  C2A70D  		JP	NZ,EXXX		;command letter not found in table
1791:	0C91  217729  		LD	HL,JTCMD	;command jump table
1792:	0C94  09      		ADD	HL,BC
1793:	0C95  09      		ADD	HL,BC		;index into table
1794:	0C96  5E      		LD	E,(HL)		;lo order command processing routine
1795:	0C97  23      		INC	HL
1796:	0C98  56      		LD	D,(HL)		;upper address
1797:	0C99  0E03    		LD	C,3
1798:	0C9B  CD5426  		CALL	SPACES		;print spaces regardless
1799:	0C9E  EB      		EX	DE,HL		;hl - address of command processing routine
1800:	0C9F  E9      		JP	(HL)
1802:			;******************************************************************************
1803:			;*
1804:			;*	bphn:	breakpoint handler - rst38s land here
1805:			;*
1806:			;*		bphn   - bphn00	  save all user	registers
1807:			;*		bphn10 - bphn20	  check	that user pc matches entry in brktbl.
1808:			;*		bphn80		  special single step processing.
1809:			;*
1810:			;*	note:	sbps is	both a flag and	the count of the number	of step	bps.
1811:			;*		sbps is	set to 1 merely	to indicate that the single-stepping
1812:			;*		is in effect.  then the	number of step bps is added to one.
1813:			;*		hence, if 1 step bp was	set then  sbps = 2 and if 2 step bps
1814:			;*		were set (conditional jump, call, ret) sbps = 3.
1815:			;*
1816:			;******************************************************************************
1817:			
1818:	0CA0  22A52F  	BPHN:	LD	(HLREG),HL	;save user hl
1819:	0CA3  E1      		POP	HL		;pop breakpoint	pc from	stack
1820:	0CA4  ED73B12F		LD	(SPREG),SP	;save user sp
1821:	0CA8  ED7B120C		LD	SP,(Z8ESP)	;switch	to our stack
1822:	0CAC  2B      		DEC	HL		;point to location of rst instruction
1823:	0CAD  22AF2F  		LD	(PCREG),HL	;save user pc
1824:	0CB0  ED53A32F		LD	(DEREG),DE	;save user de
1825:	0CB4  ED43A12F		LD	(BCREG),BC	;save user bc
1826:	0CB8  F5      		PUSH	AF
1827:	0CB9  E1      		POP	HL		;user accumulator and flag to hl
1828:	0CBA  229F2F  		LD	(AFREG),HL	;save user af
1829:	0CBD  ED57    		LD	A,I
1830:	0CBF  67      		LD	H,A		;save user i reg
1831:	0CC0  ED5F    		LD	A,R
1832:	0CC2  6F      		LD	L,A		;save user r reg
1833:	0CC3  22B72F  		LD	(RREG),HL
1834:	0CC6  08      		EX	AF,AF'          ;Bank In Prime Regs
1835:	0CC7  D9      		EXX
1836:	0CC8  22AD2F  		LD	(HLPREG),HL	;save
1837:	0CCB  ED53AB2F		LD	(DEPREG),DE
1838:	0CCF  ED43A92F		LD	(BCPREG),BC
1839:	0CD3  F5      		PUSH	AF
1840:	0CD4  E1      		POP	HL
1841:	0CD5  22A72F  		LD	(AFPREG),HL
1842:	0CD8  DD22B32F		LD	(IXREG),IX	;save user ix
1843:	0CDC  FD22B52F		LD	(IYREG),IY	;save user iy
1844:	0CE0  3A1C2F  		LD	A,(BPS)
1845:	0CE3  A7      		AND	A		;check for zero	bp count
1846:	0CE4  CA980D  		JP	Z,BPXXX		;error - no bps	set
1847:	0CE7  47      		LD	B,A		;b - number of breakpoints
1848:	0CE8  21492F  		LD	HL,BRKTBL	;breakpoint storage table
1849:	0CEB  AF      		XOR	A
1850:	0CEC  4F      		LD	C,A		;init breakpoint found flag
1851:	0CED  5E      	BPHN10:	LD	E,(HL)
1852:	0CEE  23      		INC	HL
1853:	0CEF  56      		LD	D,(HL)		;de - breakpoint address
1854:	0CF0  23      		INC	HL
1855:	0CF1  7E      		LD	A,(HL)		;saved contents	of breakpoint address
1856:	0CF2  23      		INC	HL
1857:	0CF3  12      		LD	(DE),A		;replace rst 38	with actual data
1858:	0CF4  3AAF2F  		LD	A,(PCREGL)	;user pc - lo order
1859:	0CF7  AB      		XOR	E
1860:	0CF8  5F      		LD	E,A		;versus	breakpoint address in table
1861:	0CF9  3AB02F  		LD	A,(PCREGH)
1862:	0CFC  AA      		XOR	D		;check hi order
1863:	0CFD  B3      		OR	E
1864:	0CFE  2001    		JR	NZ,BPHN20	;no match - check next entry in	table
1865:	0D00  48      		LD	C,B		;pc found in table set c reg nz
1866:	0D01  10EA    	BPHN20:	DJNZ	BPHN10		;restore all user data
1867:	0D03  211B2F  		LD	HL,SBPS		;fetch number of step bps (0-2)
1868:	0D06  46      		LD	B,(HL)
1869:	0D07  AF      		XOR	A
1870:	0D08  77      		LD	(HL),A		;clear regardless
1871:	0D09  B1      		OR	C		;test bp found flag
1872:	0D0A  CA980D  		JP	Z,BPXXX		;z - bp	not in table
1873:	0D0D  23      		INC	HL		;point to bp count
1874:	0D0E  56      		LD	D,(HL)		;d - bp count
1875:	0D0F  05      		DEC	B
1876:	0D10  FA220D  		JP	M,BPHN30	;m - this was user bp not step or jdbg
1877:	0D13  7E      		LD	A,(HL)
1878:	0D14  90      		SUB	B		;subtract number of step bps from bp count
1879:	0D15  77      		LD	(HL),A		;restore bp count
1880:	0D16  3AE729  		LD	A,(LCMD)	;what command got us here?
1881:	0D19  FE53    		CP	'S'		;step?
1882:	0D1B  2861    		JR	Z,BPHN90	;step command - check count
1883:			
1884:							;now we know we have jdbg in progress.  need
1885:							;to check for user specified bp at the same
1886:							;address. if we find one stop trace.
1887:	0D1D  78      		LD	A,B		;number of step bps to accumulator (1 or 2).
1888:			
1889:	0D1E  91      		SUB	C		;compare number of step bps with the offset
1890:							;into the bp table where the current bp was
1891:							;found.  since step bps are always at the end
1892:							;of the table we can determine how bp was set.
1893:			
1894:	0D1F  D2630E  	 	JP	NC,JDBG30	;nc - we are at end of table so more tracing
1895:			
1896:	0D22  79      	BPHN30:	LD	A,C
1897:	0D23  ED44    		NEG
1898:	0D25  82      		ADD	A,D		;create index into pass count table
1899:	0D26  87      		ADD	A,A
1900:	0D27  217F2F  		LD	HL,PSCTBL	;pass count table
1901:	0D2A  85      		ADD	A,L
1902:	0D2B  6F      		LD	L,A
1903:	0D2C  3001    		JR	NC,BPHN35
1904:	0D2E  24      		INC	H
1905:	0D2F  5E      	BPHN35:	LD	E,(HL)
1906:	0D30  23      		INC	HL
1907:	0D31  56      		LD	D,(HL)		;de - pass count
1908:	0D32  7A      		LD	A,D
1909:	0D33  B3      		OR	E
1910:	0D34  2813    		JR	Z,BPHN50	;no count in effect
1911:	0D36  1B      		DEC	DE
1912:	0D37  72      		LD	(HL),D
1913:	0D38  2B      		DEC	HL
1914:	0D39  73      		LD	(HL),E		;restored updated count
1915:	0D3A  7A      		LD	A,D
1916:	0D3B  B3      		OR	E		;did it	just go	zero?
1917:	0D3C  280B    		JR	Z,BPHN50	;count just expired
1918:	0D3E  78      		LD	A,B		;pass count not zero - go or jdbg?
1919:	0D3F  A7      		AND	A
1920:	0D40  F2630E  		JP	P,JDBG30	;if step flag p we had step bps
1921:	0D43  2AAF2F  		LD	HL,(PCREG)
1922:	0D46  C36914  		JP	G100		;continue go command
1923:	0D49  B0      	BPHN50:	OR	B		;test if we had step bps
1924:	0D4A  FA5F0D  		JP	M,BPHN60	;this was go - print bp message
1925:	0D4D  3E58    		LD	A,'X'
1926:	0D4F  32E729  		LD	(LCMD),A	;clear command letter so xreg disassembles
1927:	0D52  CDB228  		CALL	HOME		;home cursor
1928:	0D55  CDD81F  		CALL	XREG
1929:	0D58  0616    		LD	B,22		;cursor on penultimate line
1930:	0D5A  0E00    		LD	C,00
1931:	0D5C  CDB528  		CALL	XYCP
1932:			
1933:	0D5F  11CF29  	BPHN60:	LD	DE,BPMSG	;print *bp*
1934:	0D62  CD9E28  		CALL	PRINT		;print message pointed to by de
1935:	0D65  2AAF2F  		LD	HL,(PCREG)
1936:	0D68  CD6426  		CALL	OUTADR		;display breakpoint address
1937:	0D6B  EB      		EX	DE,HL
1938:	0D6C  CD4B25  		CALL	FADR		;attempt to find label at this address
1939:	0D6F  EB      		EX	DE,HL		;de - bp address
1940:	0D70  C2100C  		JP	NZ,Z8E		;nz - no label found
1941:	0D73  3A322F  		LD	A,(MAXLEN)
1942:	0D76  3D      		DEC	A
1943:	0D77  4F      		LD	C,A		;c - max size of label
1944:	0D78  CDA728  		CALL	PRINTB
1945:	0D7B  C3100C  		JP	Z8E
1946:	0D7E  CDD81F  	BPHN90:	CALL	XREG		;display all registers
1947:	0D81  2A192F  		LD	HL,(NSTEP)	;fetch trace count
1948:	0D84  2B      		DEC	HL
1949:	0D85  7D      		LD	A,L
1950:	0D86  B4      		OR	H
1951:	0D87  CA100C  		JP	Z,Z8E		;count expired - prompt	for command
1952:	0D8A  CD9D25  		CALL	TTYQ		;test for abort	trace
1953:	0D8D  FE0D    		CP	CR
1954:	0D8F  CA100C  		JP	Z,Z8E
1955:	0D92  CD3B26  		CALL	CRLF		;
1956:	0D95  C3A315  		JP	STEP40		;continue trace
1957:			
1958:			
1959:	0D98  11C829  	BPXXX:	LD	DE,BPEMSG
1960:	0D9B  CD9E28  		CALL	PRINT
1961:	0D9E  2AAF2F  		LD	HL,(PCREG)
1962:	0DA1  CD6426  		CALL	OUTADR
1963:	0DA4  C3100C  		JP	Z8E
1964:			
1965:			
1966:	0DA7  EB      	EXXX:	EX	DE,HL
1967:	0DA8  11E829  		LD	DE,EMXXX
1968:	0DAB  CD9E28  		CALL	PRINT
1969:	0DAE  EB      		EX	DE,HL
1970:	0DAF  C9      		RET
1972:			;******************************************************************************
1973:			;*
1974:			;*	jdbg:	animated debugger
1975:			;*
1976:			;*	Jdbg allows the user to watch the Z80 CPU actually execute the
1977:			;*	code.  Jdbg displays 18 disassembled instructions on the screen
1978:			;*	as well as a user defined memory block referred to in the
1979:			;*	comments as a window.
1980:			;*
1981:			;*	Entry point jdbg:
1982:			;*
1983:			;*	Jdbg processes user input as a prelude to the actual animation
1984:			;*	of the code.  The user enters the starting address to animate
1985:			;*	optionally preceded by a subroutine qualifier.  The subroutine
1986:			;*	qualifier may be either a "*" which instructs Z8E not to trace
1987:			;*	any subroutines which are located below 100h (ie. bdos calls),
1988:			;*	or it may be a "/" which means no tracing of any subroutines.
1989:			;*	Jdbg will also paint the original screen with the register
1990:			;*	contents as well as the memory window.  The contents of the
1991:			;*	memory window are also moved into argbuf so that we can compare
1992:			;*	the 'old' contents with the 'new' contents once a the first bp
1993:			;*	is reached.
1994:			;*
1995:			;*	Entry point jdbg30:
1996:			;*
1997:			;* 	Entered here via bphn who determines that animation is in
1998:			;*	effect.  In order to cut down on superfluous cursor move-
1999:			;*	ment on the screen we compare the old register and memory
2000:			;*	window contents with the new contents following the latest
2001:			;*	bp.  We only output the changes.  Next we determine if the
2002:			;*	current pc exists in disassembled form somewhere on the
2003:			;*	screen; if not, we display 18 new disassembled instructions
2004:			;*	with the current pc as line one.
2005:			;*
2006:			;*	Exit jdbg95:
2007:			;*
2008:			;*	Save current register contents and jump to step40 for next
2009:			;*	single step.
2010:			;*
2011:			;******************************************************************************
2012:			
2013:	0DB0          	JDBG:
2014:	0DB0  CDB227  		CALL	IEDTBC		;get command line
2015:	0DB3  F2D90D  		JP	P,JDBG02	;p - have input
2016:			
2017:	0DB6  213B2F  	JDBG00:	LD	HL,LASTRO
2018:	0DB9  46      		LD	B,(HL)		;row position of arrow on screen
2019:	0DBA  0E12    		LD	C,18		;column
2020:	0DBC  CDB528  		CALL	XYCP
2021:	0DBF  0E02    		LD	C,2
2022:	0DC1  CD5426  		CALL	SPACES
2023:	0DC4  0617    		LD	B,17H
2024:	0DC6  0E00    		LD	C,00
2025:	0DC8  CDB528  		CALL	XYCP
2026:	0DCB  213A2F  		LD	HL,JSTEPF
2027:	0DCE  7E      		LD	A,(HL)
2028:	0DCF  3601    		LD	(HL),1
2029:	0DD1  A7      		AND	A
2030:	0DD2  CA530F  		JP	Z,JDBG90	;J was last means screen intact - just move
2031:							;arrow, else fall thru and repaint screen.
2032:							;Indicate single step
2033:	0DD5          	JDBG01:				;+ eg 3.3.6
2034:	0DD5  3E0A    		LD	A,10
2035:	0DD7  183F    		JR	JDBG10		;init timer
2036:			
2037:	0DD9  7E      	JDBG02:	LD	A,(HL)		;check first char of input
2038:	0DDA  FE23    		CP	'#'		;+ eg 3.3.6
2039:	0DDC  2007    		JR	NZ,JDBG2A	;+ Skip if not repaint request
2040:	0DDE  213A2F  		LD	HL,JSTEPF	;+
2041:	0DE1  3601    		LD	(HL),1		;+ Signal repaint request
2042:	0DE3  18F0    		JR	JDBG01		;+
2043:	0DE5          	JDBG2A:				;+
2044:	0DE5  EB      		EX	DE,HL		;de - save input buffer	address
2045:	0DE6  21182F  		LD	HL,WFLAG	;wflag tells us	whether	to trace subroutines
2046:							;or walk around	them
2047:	0DE9  36FF    		LD	(HL),0FFH	;conditionally assume trace all
2048:	0DEB  D62F    		SUB	'/'		;slash means don't trace any
2049:	0DED  2805    		JR	Z,JDBG03	;
2050:	0DEF  C605    		ADD	A,'/'-'*'	;check for star	- no trace of bdos subs
2051:	0DF1  2004    		JR	NZ,JDBG05
2052:	0DF3  3C      		INC	A		;set flag one to indicate no trace of subs
2053:							;at address < 100h (bdos calls)
2054:	0DF4  77      	JDBG03:	LD	(HL),A		;set wflag
2055:	0DF5  AF      		XOR	A		;if slash or space replace with	null in	inbf
2056:							;so parser will	ignore
2057:	0DF6  12      		LD	(DE),A
2058:	0DF7  CDD426  	JDBG05:	CALL	IARG		;now evaluate address
2059:	0DFA  280C    		JR	Z,JDBG08	;z - no error
2060:	0DFC  3A0230  		LD	A,(INBFNC)	;check number of characters
2061:	0DFF  3D      		DEC	A		;check for just / or just *
2062:	0E00  28B4    		JR	Z,JDBG00	;treat as single step
2063:	0E02  323A2F  		LD	(JSTEPF),A	;indicate screen corrupted
2064:	0E05  C3A70D  		JP	EXXX		;error -
2065:	0E08  22AF2F  	JDBG08:	LD	(PCREG),HL	;save address at which to start	tracing
2066:	0E0B  A7      		AND	A		;check delimter
2067:	0E0C  3E0A    		LD	A,10		;no delimeter use default timer value
2068:	0E0E  2808    		JR	Z,JDBG10
2069:	0E10  CDD426  		CALL	IARG		;check if user wants non-default timer
2070:	0E13  3E0A    		LD	A,10
2071:	0E15  2001    		JR	NZ,JDBG10	;error - use default
2072:	0E17  7D      		LD	A,L		;a - timer value as entered by user
2073:	0E18  32292F  	JDBG10:	LD	(TIMER),A
2074:	0E1B  0618    		LD	B,24		;xmit crlf's to clear screen
2075:	0E1D  CD3B26  	JDBG15:	CALL	CRLF		;clear screen
2076:	0E20  10FB    		DJNZ	JDBG15
2077:	0E22  CDA10F  		CALL	RGDISP		;display current user regs
2078:	0E25  CD6F0F  		CALL	ZWNW		;display disassembled window
2079:	0E28  3A452F  		LD	A,(WNWSIZ)
2080:	0E2B  A7      		AND	A		;test if window being displayed
2081:	0E2C  2830    		JR	Z,JDBG28
2082:	0E2E  11D72F  		LD	DE,WINDOW	;save user specified memory block til next bp
2083:	0E31  2A432F  		LD	HL,(WNWTAB)	;start of memory window address
2084:	0E34  010300  		LD	BC,3
2085:	0E37  3A362F  	JDBG20: LD	A,(FWNDOW)	;position cursor starting at column
2086:	0E3A  D606    		SUB	6
2087:	0E3C  CDAD0F  		CALL	CURS
2088:	0E3F  CD6426  	       	CALL	OUTADR		;display address of memory window
2089:	0E42  3A362F  	JDBG25:	LD	A,(FWNDOW)
2090:	0E45  CDAD0F  		CALL	CURS		;column position on screen of memory window
2091:							;is (rel pos * 3) + (fwndow)
2092:	0E48  7E      		LD	A,(HL)		;display this byte
2093:			
2094:	0E49  12      		LD	(DE),A		;save this byte in window between bps
2095:	0E4A  CD6E26  		CALL	OUTHEX
2096:	0E4D  04      		INC	B		;move and display user specifed number
2097:			                                ;of bytes (wnwsiz)
2098:	0E4E  3A452F  		LD	A,(WNWSIZ)
2099:	0E51  90      		SUB	B
2100:	0E52  280A    		JR	Z,JDBG28
2101:	0E54  23      		INC	HL
2102:	0E55  13      		INC	DE
2103:	0E56  3A372F  		LD	A,(NLMASK)	;check for new line time
2104:	0E59  A0      		AND	B
2105:	0E5A  20E6    		JR	NZ,JDBG25	;not end of line - display next byte else...
2106:	0E5C  18D9    		JR	JDBG20		;...display address first
2107:	0E5E  3E03    	JDBG28:	LD	A,3		;point to very first instruction
2108:	0E60  C3170F  		JP	JDBG75
2109:			
2110:			
2111:							;breakpoint handler jumps here for full
2112:							;screen single step
2113:	0E63  0E03    	JDBG30:	LD  	C,3
2114:	0E65  CD5426  		CALL	SPACES		;remove => from screen
2115:	0E68  41      		LD	B,C		;(c=0 after spaces executes)
2116:	0E69  219F2F  		LD	HL,REGCON	;new contents of registers following bp
2117:	0E6C  11BF2F  		LD	DE,REGSAV	;old prior to bp
2118:	0E6F  1A      	JDBG35:	LD	A,(DE)		;compare old vs new
2119:	0E70  BE      		CP	(HL)
2120:	0E71  23      		INC	HL
2121:	0E72  13      		INC	DE
2122:	0E73  2004    		JR	NZ,JDBG40	;different - display new
2123:	0E75  1A      		LD	A,(DE)		;check hi order byte of this reg pair
2124:	0E76  BE      		CP	(HL)
2125:	0E77  2827    		JR	Z,JDBG45	;z - hi and lo bytes the same so try next reg
2126:	0E79          	JDBG40:
2127:			;	ld	a,4		;col position of reg pair is (rel pos * 9) + 3
2128:			;	and	b
2129:			;	jr	z,jdbg42
2130:			;	ld	a,3
2131:			;	and	b		;- 9 bytes deleted here
2132:			;	inc	a
2133:	0E79  C5      		PUSH	BC		;+save register number
2134:	0E7A  48      		LD	C,B		;+move it to c while we build line number
2135:	0E7B  0600    		LD	B,0		;+assume first line for now
2136:	0E7D  3E07    		LD	A,7		;+regs-per-line mask
2137:	0E7F  B9      		CP	C		;+generate carry if second line
2138:	0E80  CB10    		RL	B		;+shift carry into line number
2139:	0E82  A1      		AND	C		;+generate line-relative register number
2140:	0E83  4F      		LD	C,A		;+col = reg * 9 + 3 if non-prime
2141:	0E84  87      		ADD	A,A		;+ *2
2142:	0E85  87      		ADD	A,A		;+ *4
2143:	0E86  87      		ADD	A,A		;+ *8
2144:	0E87  81      		ADD	A,C		;+ *9
2145:	0E88  CB51    		BIT	2,C		;+is it a prime (alternate) register?
2146:	0E8A  2803    		JR	Z,JDBG42	;+skip if not
2147:	0E8C  81      		ADD	A,C		;+*10
2148:	0E8D  D603    		SUB	3		;+col = reg * 10 if prime
2149:	0E8F          	JDBG42:
2150:	0E8F  C603    		ADD	A,3		;+
2151:	0E91  4F      		LD	C,A		;+
2152:	0E92  CDB528  		CALL	XYCP		;+
2153:	0E95  C1      		POP	BC		;+ added 29 bytes
2154:			
2155:			;	add	a,3		;- deleted another 5 bytes here
2156:			;	call	curs		;- nett cost = 14 bytes for new code
2157:			;				;- but we save 19 bytes in 'curs:' routine
2158:			
2159:	0E96  7E      		LD	A,(HL)		;display upper byte of reg contents
2160:	0E97  CD6E26  		CALL	OUTHEX
2161:	0E9A  2B      		DEC	HL		;rewind to pick up lo order byte
2162:	0E9B  7E      		LD	A,(HL)
2163:	0E9C  23      		INC	HL
2164:	0E9D  CD6E26  		CALL	OUTHEX		;display lo order
2165:	0EA0  23      	JDBG45:	INC	HL
2166:	0EA1  13      		INC	DE
2167:	0EA2  04      		INC	B
2168:	0EA3  3E0C    		LD	A,REGSIZ/2	;number of reg pairs to display
2169:	0EA5  90      		SUB	B
2170:	0EA6  20C7    		JR	NZ,JDBG35
2171:	0EA8  CD4D26  		CALL	RSPACE
2172:	0EAB  0601    		LD	B,1
2173:	0EAD  0E24    		LD	C,36
2174:	0EAF  CDB528  		CALL	XYCP
2175:			
2176:	0EB2  0600    		LD	B,0
2177:	0EB4  CDF71B  		CALL	PSWDSP		;now display flag reg mnemonics
2178:			
2179:	0EB7  3A452F  		LD	A,(WNWSIZ)	;check window size
2180:	0EBA  A7      		AND	A
2181:	0EBB  2821    		JR	Z,JDBG60	;z - no memory window in effect
2182:	0EBD  2A432F  		LD	HL,(WNWTAB)	;hl - address of start of window
2183:	0EC0  010300  		LD	BC,03
2184:	0EC3  11D72F  		LD	DE,WINDOW	;old contents of window stored here
2185:	0EC6  1A      	JDBG50:	LD	A,(DE)		;compare old vs new
2186:	0EC7  BE      		CP	(HL)
2187:	0EC8  280B    		JR	Z,JDBG55	;same - no reason to display
2188:	0ECA  3A362F  		LD	A,(FWNDOW)	;col position of byte is (rel pos * 3) + 50
2189:	0ECD  CDAD0F  		CALL	CURS
2190:	0ED0  7E      		LD	A,(HL)		;display byte
2191:			
2192:	0ED1  12      		LD	(DE),A		;we only need to move byte if it changed
2193:			
2194:	0ED2  CD6E26  		CALL	OUTHEX
2195:	0ED5  04      	JDBG55:	INC	B		;bump memory window byte count
2196:	0ED6  3A452F  		LD	A,(WNWSIZ)  	;max size
2197:	0ED9  23      		INC	HL
2198:	0EDA  13      		INC	DE
2199:	0EDB  90      		SUB	B
2200:	0EDC  20E8    		JR	NZ,JDBG50	;loop until entire window examined
2201:			
2202:	0EDE  3E12    	JDBG60:	LD	A,18		;init count of disassembled instructions
2203:	0EE0  321F2F  		LD	(JLINES),A
2204:	0EE3  ED5B0E2F		LD	DE,(ZASMFL)	;address of first disassembled instruction
2205:							;on screen
2206:	0EE7  2AAF2F  	JDBG65:	LD	HL,(PCREG)
2207:	0EEA  A7      		AND	A
2208:	0EEB  ED52    		SBC	HL,DE
2209:	0EED  2821    		JR	Z,JDBG70	;found - pc exists somewhere on screen
2210:	0EEF  CDF31A  		CALL	ZLEN00		;compute length	of this	instruction
2211:	0EF2  0600    		LD	B,0
2212:	0EF4  EB      		EX	DE,HL		;hl - address on disassembled instruction
2213:	0EF5  09      		ADD	HL,BC		;add length to compute address of next inline
2214:							;instruction for display
2215:	0EF6  EB      		EX	DE,HL		;de - restore new istruction pointer
2216:	0EF7  211F2F  		LD	HL,JLINES
2217:	0EFA  35      		DEC	(HL)		;dec screen line count
2218:	0EFB  20EA    		JR	NZ,JDBG65
2219:	0EFD  2AAF2F  		LD	HL,(PCREG)	;pc not	on screen - so current pc will be new
2220:							;first pc on screen
2221:	0F00  220E2F  		LD	(ZASMFL),HL
2222:	0F03  010003  		LD	BC,0300H	;cursor	row 4 -	col 1
2223:	0F06  CDB528  		CALL	XYCP
2224:	0F09  CD6F0F  		CALL	ZWNW		;instruction not on screen so paint a new
2225:							;screen	starting at current pc
2226:	0F0C  3E03    		LD	A,3		;disassembled instructions start on line 4
2227:	0F0E  1807    		JR	JDBG75
2228:	0F10  3A1F2F  	JDBG70:	LD	A,(JLINES)
2229:	0F13  ED44    		NEG
2230:	0F15  C615    		ADD	A,21		;a - screen row	on which to position cursor
2231:	0F17  323B2F  	JDBG75:	LD	(LASTRO),A	;save position of arrow
2232:	0F1A  47      		LD	B,A		;pass to xycp
2233:	0F1B  0E12    		LD	C,18		;pass column
2234:	0F1D  CDB528  		CALL	XYCP		;position cursor routine
2235:	0F20  11DB29  		LD	DE,MRROW
2236:	0F23  CD9E28  		CALL	PRINT
2237:	0F26  3A3B2F  		LD	A,(LASTRO)	;xy positioning added after '=>' as
2238:							;some systems have a destructive bs
2239:	0F29  0E11    		LD	C,17		;new cursor loc
2240:	0F2B  CDB528  		CALL	XYCP		;put it there
2241:	0F2E  3A3A2F  		LD	A,(JSTEPF)
2242:	0F31  3D      		DEC	A		;test if single stepping
2243:	0F32  CA610F  		JP	Z,JDBG95
2244:	0F35  CD9D25  		CALL	TTYQ
2245:	0F38  21292F  		LD	HL,TIMER
2246:	0F3B  46      		LD	B,(HL)
2247:	0F3C  2812    		JR	Z,JDBG80
2248:	0F3E  FE30    		CP	'0'
2249:	0F40  380A    		JR	C,JDBG78
2250:	0F42  FE3A    		CP	3AH
2251:	0F44  301B    		JR	NC,JDBG95
2252:	0F46  E60F    		AND	0FH
2253:	0F48  77      		LD	(HL),A
2254:	0F49  47      		LD	B,A
2255:	0F4A  1804    		JR	JDBG80
2256:	0F4C  FE0D    	JDBG78:	CP	CR		;carriage return ends command
2257:	0F4E  2811    		JR	Z,JDBG95
2258:			
2259:	0F50  CDD40F  	JDBG80:	CALL	CLOK
2260:			
2261:	0F53  11BF2F  	JDBG90:	LD	DE,REGSAV	;move current reg contents to save area
2262:	0F56  219F2F  		LD	HL,REGCON
2263:	0F59  011800  		LD	BC,REGSIZ
2264:	0F5C  EDB0    		LDIR
2265:	0F5E  C3A315  		JP	STEP40
2266:			
2267:			
2268:							;user requested abort from console
2269:	0F61  0616    	JDBG95: LD	B,22		;position cursor on line 23 for prompt
2270:	0F63  0E00    		LD	C,0
2271:	0F65  CDB528  		CALL	XYCP
2272:	0F68  AF      		XOR	A
2273:	0F69  323A2F  		LD	(JSTEPF),A	;indicate we have full screen of data
2274:	0F6C  C3100C  		JP	Z8E		;to z8e command processor
2275:			
2276:			
2277:			
2278:	0F6F          	ZWNW:				;display disassembly window
2279:	0F6F  3E12    		LD	A,18		;number of instructions to disassemble
2280:	0F71  2AAF2F  	ZWNW05:	LD	HL,(PCREG)
2281:	0F74  220E2F  		LD	(ZASMFL),HL	;save pc of first line
2282:	0F77  321F2F  	ZWNW10:	LD	(JLINES),A
2283:	0F7A  220C2F  		LD	(ZASMPC),HL	;save here as well
2284:	0F7D  118130  		LD	DE,ZASMBF+96	;disassemble in upper portion of buffer to
2285:							;prevent overlap with big memory windows.
2286:							;otherwise, every time we disassemble a new
2287:							;screen we have to repaint the window.
2288:			
2289:	0F80  CD8F20  		CALL	ZASM10		;disassemble first instruction
2290:	0F83  3E1E    		LD	A,30		;test line length
2291:	0F85  B9      		CP	C
2292:	0F86  2802    		JR	Z,ZWNW20
2293:	0F88  0E2A    		LD	C,42
2294:	0F8A  CDA728  	ZWNW20:	CALL	PRINTB
2295:	0F8D  CD3B26  		CALL	CRLF
2296:	0F90  2A102F  		LD	HL,(ZASMNX)	;hl - next address to disassemble
2297:	0F93  3A1F2F  		LD	A,(JLINES)
2298:	0F96  3D      		DEC	A
2299:	0F97  20DE    		JR	NZ,ZWNW10
2300:	0F99  0603    		LD	B,3		;position cursor next to next instruction
2301:							;to execute which is the first one on the
2302:							;screen - line 4  col 20
2303:	0F9B  0E14    		LD	C,20
2304:	0F9D  CDB528  		CALL	XYCP
2305:	0FA0  C9      		RET
2306:			
2307:			
2308:							;display regs at top of screen:
2309:	0FA1  CDB228  	RGDISP:	CALL	HOME		;home cursor
2310:	0FA4  CDD81F  		CALL	XREG		;display regs
2311:	0FA7  CDF71B  		CALL	PSWDSP		;display flag reg
2312:	0FAA  C33B26  		JP	CRLF
2313:			
2314:			
2315:			
2316:	0FAD  C5      	CURS:	PUSH	BC		;This routine has been simplified and shortened
2317:	0FAE  D5      		PUSH	DE		;by 19 bytes because it is no longer used for
2318:	0FAF  E5      		PUSH	HL		;register display positioning.  jrs 20/4/87
2319:	0FB0  57      		LD	D,A
2320:	0FB1  59      		LD	E,C		;save base row address
2321:			;	cp	3		;test if reg or memory window (3 is reg)
2322:			;	ld	a,7
2323:			;	jr	z,curs00	;z - regs are eight per line (first line)
2324:			
2325:	0FB2  3A372F  		LD	A,(NLMASK)
2326:	0FB5  A0      	CURS00:	AND	B		;item number mod lnmask is the relative pos of
2327:	0FB6  4F      		LD	C,A		;reg contents or memory data byte
2328:	0FB7  87      		ADD	A,A		;
2329:	0FB8  81      		ADD	A,C
2330:	0FB9  4F      		LD	C,A		;c - rel pos times three
2331:			
2332:			;	ld	a,d		;if base column address is < 50 then this is
2333:							;reg display
2334:			;	sub	3
2335:			;	ld	h,a
2336:			;	ld	a,c
2337:			;	jr	nz,curs20	;nz - not reg display - must be memory
2338:			;	add	a,a		;so multiply times three again
2339:			;	add	a,c		;times 9 in all for register display
2340:			
2341:	0FBA  82      	CURS20:	ADD	A,D		;add in base
2342:	0FBB  4F      		LD	C,A		;c - absolute col number
2343:			;	xor	a		;test if this is reg or memory window display
2344:			;	or	h
2345:			;	jr	z,curs30	;z - this is register display
2346:	0FBC  3A362F  		LD	A,(FWNDOW)
2347:	0FBF  FE44    		CP	68		;14-char symbols in effect?
2348:	0FC1  CAC60F  		JP	Z,CURS40
2349:	0FC4  CB38    	CURS30:	SRL	B
2350:	0FC6  3EFC    	CURS40:	LD	A,0FCH
2351:	0FC8  A0      		AND	B		;now compute row number
2352:	0FC9  0F      		RRCA
2353:	0FCA  0F      		RRCA
2354:	0FCB  83      		ADD	A,E		;base row address
2355:	0FCC  47      		LD	B,A		;b - absolute row number
2356:	0FCD  CDB528  		CALL	XYCP		;convert row and column to xy cursor address
2357:	0FD0  E1      		POP	HL
2358:	0FD1  D1      		POP	DE
2359:	0FD2  C1      		POP	BC
2360:	0FD3  C9      		RET
2361:			
2362:			
2363:			
2364:	0FD4          	CLOK:
2365:	0FD4  1632    		LD	D,50  		;idle loop - decrement to 0 and reload
2366:	0FD6  1E00    		LD	E,00
2367:	0FD8  05      		DEC	B		;user specified the loop counter
2368:	0FD9  F8      		RET	M
2369:	0FDA  1B      	CLOK10:	DEC	DE
2370:	0FDB  7B      		LD	A,E
2371:	0FDC  B2      		OR	D
2372:	0FDD  20FB    		JR	NZ,CLOK10
2373:	0FDF  18F3    		JR	CLOK
2374:			
2376:			;******************************************************************************
2377:			;*
2378:			;*	exam:	examine	memory and display in hex and ascii.  user is allowed
2379:			;*		to modify memory after every byte is displayed.	ilin called
2380:			;*		to parse input buffer into a single string of bytes which is
2381:			;*		returned in argbuf.  the byte count of the string is returned
2382:			;*		in argbc, and this number of bytes is transferred to the
2383:			;*		current	memory address.
2384:			;*
2385:			;*		user may optionally scan memory	by entering cr.	 command
2386:			;*		terminates when	a single space is entered.
2387:			;*
2388:			;*		enter:	b - 0
2389:			;*		       de - address at which to	display	first byte
2390:			;*
2391:			;******************************************************************************
2392:			
2393:	0FE1  CD8926  	EXAM:	CALL	ILIN
2394:	0FE4  C2A70D  		JP	NZ,EXXX
2395:	0FE7  EB      		EX	DE,HL
2396:	0FE8  CD5B26  	EXAM00:	CALL	NEWLIN
2397:	0FEB  1A      		LD	A,(DE)		;fetch byte to display regardless
2398:	0FEC  CD6227  		CALL	OUTBYT
2399:	0FEF  CD7227  		CALL	RBYTE
2400:	0FF2  20F4    		JR	NZ,EXAM00 	;nz - don't replace memory contents
2401:	0FF4  FE2E    		CP	'.'
2402:	0FF6  2005    		JR	NZ,EXAM10
2403:	0FF8  3A0230  		LD	A,(INBFNC)
2404:	0FFB  3D      		DEC	A
2405:	0FFC  C8      		RET	Z
2406:	0FFD  21BB2F  	EXAM10:	LD	HL,ARGBC	;byte count to c
2407:	1000  4E      		LD	C,(HL)
2408:	1001  0600    		LD	B,0
2409:	1003  ED53102F		LD	(EXAMPT),DE
2410:	1007  21BF2F  		LD	HL,ARGBF	;start of evaluated input
2411:	100A  EDB0    		LDIR
2412:	100C  3A2B2F  		LD	A,(TRMNTR)
2413:	100F  FE0D    		CP	CR
2414:	1011  28D5    		JR	Z,EXAM00
2415:	1013  ED5B102F		LD	DE,(EXAMPT)
2416:	1017  18CF    		JR	EXAM00
2418:			;------------------------------------------------------------------------------
2419:			;
2420:			;	hsym:	display symbol table
2421:			;
2422:			;	User may display the symbol table on the console.  If no arg
2423:			;	entered on command line then the entire table is dumped start-
2424:			;	ing with the first symbol.  If a valid symbol is entered then
2425:			;	we will try to find the symbol in the table; if found, the
2426:			;	table is dumped starting at that point.  If the symbol is not
2427:			;	found the user gets a ? and the command terminates.
2428:			;
2429:			;	Symbols are displayed in blocks of 32.  After each block the
2430:			;	user is given the opportunity of continuing or ending the
2431:			;	command:
2432:			;
2433:			;		cr - Terminate			\  jrs 27 Dec 88
2434:			;	    not cr - Display next block		/  v 3.5.1
2435:			;
2436:			;------------------------------------------------------------------------------
2437:			
2438:	1019  CD8926  	HSYM:	CALL	ILIN		;Read in line of data
2439:	101C  21100C  		LD	HL,Z8E		;Assume no symbol entered
2440:	101F  200F    		JR	NZ,HSYM10	;NZ - no input means display entire table
2441:	1021  115530  		LD	DE,PRSBF
2442:	1024  CDF319  		CALL	FSYM		;Attempt to find this symbol name in table
2443:	1027  C2A70D  		JP	NZ,EXXX		;Error - symbol	not found in symbol table
2444:	102A  3A322F  		LD	A,(MAXLEN)
2445:	102D  B5      		OR	L		;Point to next symbol table entry (next block)
2446:	102E  6F      		LD	L,A		;HL - ptr to last byte in this entry
2447:	102F  23      		INC	HL		;Now next entry toward hi memory
2448:	1030  3A322F  	HSYM10:	LD	A,(MAXLEN)	;Max size of symbol name
2449:	1033  4F      		LD	C,A
2450:	1034  0D      		DEC	C
2451:	1035  3C      		INC	A		;Make 8 or 16
2452:	1036  5F      		LD	E,A
2453:	1037  AF      		XOR	A
2454:	1038  57      		LD	D,A		;DE - size of symbol table entry
2455:	1039  ED52    		SBC	HL,DE		;Previous entry toward low memory
2456:	103B  7E      		LD	A,(HL)		;Null means this is unused slot is user
2457:							;defined symbol table
2458:	103C  A7      		AND	A
2459:	103D  28F1    		JR	Z,HSYM10
2460:	103F  3D      		DEC	A		;Neg means this is jp opcode (0c3h) of jump to
2461:							;BDOS
2462:	1040  F8      		RET	M
2463:	1041  3A322F  		LD	A,(MAXLEN)
2464:	1044  CB3F    		SRL	A
2465:	1046  CB3F    		SRL	A
2466:	1048  EE02    		XOR	2
2467:	104A  A0      		AND	B		;Check symbols per line count
2468:	104B  CC3B26  		CALL	Z,CRLF		;crlf every fourth
2469:	104E  05      		DEC	B		;Now decrement symbols per line count
2470:	104F  CDA728  		CALL	PRINTB		;Treat symbol table entry as a buffer and
2471:							;Six chars or until null, whichever is first
2472:	1052  0C      		INC	C		;Tack on two spaces
2473:	1053  0C      		INC	C
2474:	1054  CD5426  		CALL	SPACES
2475:	1057  3A322F  		LD	A,(MAXLEN)
2476:	105A  B5      		OR	L		;Point to last byte in symbol table block
2477:	105B  6F      		LD	L,A
2478:	105C  56      		LD	D,(HL)		;Upper byte of symbol address
2479:	105D  2B      		DEC	HL
2480:	105E  5E      		LD	E,(HL)		;Low order
2481:	105F  EB      		EX	DE,HL
2482:	1060  CD6426  		CALL	OUTADR		;HL - symbol address to display
2483:	1063  0E04    		LD	C,4
2484:	1065  CD5426  		CALL	SPACES		;Next symbol name starts 4 spaces to the right
2485:	1068  EB      		EX	DE,HL		;HL - symbol table pointer
2486:	1069  3A322F  		LD	A,(MAXLEN)
2487:	106C  2F      		CPL
2488:	106D  A5      		AND	L		;Rewind to point to byte zero of entry
2489:	106E  6F      		LD	L,A
2490:	106F  78      		LD	A,B
2491:	1070  E61F    		AND	31		;Displayed block of 32 symbols?
2492:	1072  20BC    		JR	NZ,HSYM10
2493:	1074  CD3B26  		CALL	CRLF
2494:	1077  CDBD25  		CALL	TTYI		;Test if user wants abort
2495:	107A  FE0D    		CP	CR
2496:	107C  20B2    		JR	NZ,HSYM10	;Not CR - continue (jrs v3.5.1)
2497:	107E  C9      		RET			;CR - end command
2499:			;*****************************************************************************
2500:			;*
2501:			;*	usym:   write symbol table to disk
2502:			;*
2503:			;*****************************************************************************
2504:			
2505:	107F  CDB227  	USYM:	CALL	IEDTBC		;get a command line
2506:	1082  F8      		RET	M		;no input ends command
2507:	1083  CD8D23  		CALL	BLDF		;build fcb
2508:	1086  C2DC1E  		JP	NZ,ESNTX	;syntax error
2509:	1089  21100C  		LD	HL,Z8E		;start at beginning
2510:	108C  3A032F  		LD	A,(SYMFLG)	;do we even have a symbol table?
2511:	108F  A7      		AND	A
2512:	1090  C0      		RET	NZ		;no table - end command
2513:	1091  0680    		LD	B,128		;disk write buffer size
2514:	1093  32102F  		LD	(LINES),A	;clear symbols per line counter
2515:	1096  11FD2F  		LD	DE,SYMBUF
2516:	1099  3A322F  	USYM10:	LD	A,(MAXLEN)
2517:	109C  4F      		LD	C,A		;max size of symbol name
2518:	109D  2F      		CPL
2519:	109E  A5      		AND	L		;rewind to byte zero of symbol table entry
2520:	109F  6F      		LD	L,A
2521:	10A0  78      		LD	A,B		;temp save buffer count
2522:	10A1  0600    		LD	B,0
2523:	10A3  ED42    		SBC	HL,BC
2524:	10A5  2B      		DEC	HL		;point to 8 or 16 byte boundary
2525:	10A6  47      		LD	B,A		;restore buffer count
2526:			
2527:	10A7  7E      		LD	A,(HL)		;null means this is unused slot in user
2528:							;defined symbol table
2529:	10A8  A7      		AND	A
2530:	10A9  28EE    		JR	Z,USYM10
2531:	10AB  3D      		DEC	A		;neg means this is jp opcode (0c3h) of jump to
2532:							;bdos
2533:	10AC  F2BC10  		JP	P,USYM20
2534:	10AF  CDF210  		CALL	PCRLF		;hit end of table - put crlf in buffer
2535:	10B2  3E1A    		LD	A,EOF
2536:	10B4  0601    		LD	B,1		;force buffer write
2537:	10B6  CD0A11  		CALL	PUTC		;put eof in file
2538:	10B9  C35223  		JP	CLOSEF		;this is a wrap
2539:			
2540:	10BC  3A322F  	USYM20:	LD	A,(MAXLEN)
2541:	10BF  B5      		OR	L
2542:	10C0  6F      		LD	L,A		;point to hi order byte of symbol address
2543:	10C1  CDFB10  		CALL	PBIN		;put address in buffer
2544:	10C4  3E20    		LD	A,' '
2545:	10C6  CD0A11  		CALL	PUTC		;followed by space just like l80
2546:	10C9  3A322F  		LD	A,(MAXLEN)
2547:	10CC  2F      		CPL
2548:	10CD  A5      		AND	L		;rewind to byte zero of symbol entry
2549:	10CE  6F      		LD	L,A
2550:			
2551:	10CF  0D      		DEC	C		;14 Sep 85   restore maxlen size as count
2552:			
2553:	10D0  7E      	USYM25:	LD	A,(HL)		;fetch char of symbol name
2554:	10D1  A7      		AND	A		;null?
2555:	10D2  2809    		JR	Z,USYM40	;name is less than 6 chars long
2556:	10D4  CD0A11  		CALL	PUTC		;put valid symbol name chars in buffer
2557:	10D7  0D      		DEC	C
2558:	10D8  2803    		JR	Z,USYM40	;z - just moved last char
2559:	10DA  23      		INC	HL
2560:	10DB  18F3    		JR	USYM25
2561:	10DD  3E09    	USYM40:	LD	A,TAB		;tab separates name and next address
2562:	10DF  CD0A11  		CALL	PUTC		;insert tab before address field
2563:	10E2  3A102F  		LD	A,(LINES)
2564:	10E5  3D      		DEC	A
2565:	10E6  32102F  		LD	(LINES),A
2566:	10E9  E603    		AND	3		;insert crlf every fourth symbol
2567:	10EB  20AC    		JR	NZ,USYM10
2568:	10ED  CDF210  		CALL	PCRLF
2569:	10F0  18A7    		JR	USYM10
2570:			
2571:			
2572:			
2573:	10F2  3E0D    	PCRLF:	LD	A,CR
2574:	10F4  CD0A11  		CALL	PUTC
2575:	10F7  3E0A    		LD	A,LF
2576:	10F9  180F    		JR	PUTC
2577:			
2578:			
2579:							;convert two byte binary address to ascii
2580:							;and put into buffer
2581:	10FB  CDFF10  	PBIN:	CALL	PBIN00
2582:	10FE  2B      		DEC	HL
2583:	10FF  7E      	PBIN00:	LD	A,(HL)
2584:	1100  CD7C26  		CALL	BINX
2585:	1103  CD0A11  		CALL	PUTC
2586:	1106  7E      		LD	A,(HL)
2587:	1107  CD8026  		CALL	BINX00
2588:			
2589:			
2590:	110A  12      	PUTC:	LD	(DE),A		;just like pascal - put char into buffer
2591:	110B  13      		INC	DE
2592:	110C  05      		DEC	B		;buffer count passed in b
2593:	110D  C0      		RET	NZ
2594:	110E  11FD2F  	PUTC00:	LD	DE,SYMBUF	;hit end of buffer - reinit pointer to start
2595:	1111  CD7123  		CALL	BDWRIT		;write current buffer [ras 14 sep 85]
2596:	1114  0680    		LD	B,128		;reinit tally
2597:	1116  C9      		RET
2599:			
2600:			;------------------------------------------------------------------------------
2601:			;
2602:			;	dump:  Dump memory in hex and ASCII
2603:			;
2604:			;	Memory is dumped in hex	and ASCII in user-specified block size.
2605:			;	If the D command is given without arguments then memory	is dumped
2606:			;	beginning at the address where we left off as store in blkptr.
2607:			;	User is	queried	after each block is dumped:
2608:			;
2609:			;		cr - End command			\  v 3.5.1
2610:			;	    Not	cr - Dump next consecutive block	/  jrs 27 Dec 88
2611:			;
2612:			;------------------------------------------------------------------------------
2613:			
2614:	1117  CDB227  	DUMP:	CALL	IEDTBC		;Solicit input
2615:	111A  F22611  		JP	P,DUMP00	;p - input present
2616:	111D  ED5B042F		LD	DE,(BSIZ)	;No input means	use previous block size
2617:	1121  2A062F  		LD	HL,(BLKPTR)	;   ...	and address
2618:	1124  1823    		JR	DUMP30
2619:	1126  CDD426  	DUMP00:	CALL	IARG		;Read in next arg (starting address)
2620:	1129  C2A70D  		JP	NZ,EXXX		;Invalid starting address
2621:	112C  EB      		EX	DE,HL		;DE - starting address to dump
2622:	112D  CDD426  		CALL	IARG		;Next arg (block size)
2623:	1130  2805    		JR	Z,DUMP15	;Z - no	errors
2624:	1132  210000  		LD	HL,000		;Default to block size of 256
2625:	1135  1809    		JR	DUMP20
2626:	1137  AF      	DUMP15:	XOR	A
2627:	1138  B4      		OR	H		;Test for block	size or	ending address
2628:	1139  2805    		JR	Z,DUMP20	;Less than 256 must be block size
2629:	113B  ED52    		SBC	HL,DE		;Compute size
2630:	113D  DAA70D  		JP	C,EXXX
2631:	1140  7D      	DUMP20:	LD	A,L
2632:	1141  B4      		OR	H
2633:	1142  2001    		JR	NZ,DUMP25
2634:	1144  24      		INC	H
2635:	1145  22042F  	DUMP25:	LD	(BSIZ),HL
2636:	1148  EB      		EX	DE,HL		;DE - block size   HL -	memory pointer
2637:	1149  0610    	DUMP30:	LD	B,16		;Init bytes-per-line count
2638:	114B  CD9D25  		CALL	TTYQ
2639:	114E  FE0D    		CP	CR
2640:	1150  C8      		RET	Z
2641:	1151  CD3B26  		CALL	CRLF		;Display current address on new line
2642:	1154  CD6426  		CALL	OUTADR
2643:	1157  0E02    		LD	C,2
2644:	1159  CD5426  		CALL	SPACES		;Hex display starts two	spaces right
2645:	115C  05      	DUMP40:	DEC	B		;Decrement column count
2646:	115D  7E      		LD	A,(HL)
2647:	115E  23      		INC	HL
2648:	115F  CD4A26  		CALL	OTHXSP		;Display memory	in hex
2649:	1162  0C      		INC	C		;Tally of hex bytes displayed
2650:	1163  1B      		DEC	DE		;Decrement block count
2651:	1164  7A      		LD	A,D
2652:	1165  B3      		OR	E		;Test for end of block
2653:	1166  2806    		JR	Z,DUMP50	;Z - end of block
2654:	1168  AF      		XOR	A
2655:	1169  B0      		OR	B		;End of	line?
2656:	116A  20F0    		JR	NZ,DUMP40	;Not end of line - dump	more in	hex
2657:	116C  181B    		JR	DUMP60
2658:	116E  3A052F  	DUMP50:	LD	A,(BSIZHI)
2659:	1171  A7      		AND	A		;Block size greater than 256?
2660:	1172  2007    		JR	NZ,DUMP55	;NZ - greater
2661:	1174  3A042F  		LD	A,(BSIZLO)
2662:	1177  E6F0    		AND	0F0H		;Block size less than 16?
2663:	1179  280E    		JR	Z,DUMP60	;Z - less
2664:	117B  3A042F  	DUMP55:	LD	A,(BSIZLO)
2665:	117E  E60F    		AND	0FH		;Block size multiple of	16?
2666:	1180  2807    		JR	Z,DUMP60	;Multiple of 16
2667:	1182  ED44    		NEG
2668:	1184  C610    		ADD	A,16
2669:	1186  47      		LD	B,A
2670:	1187  87      		ADD	A,A
2671:	1188  80      		ADD	A,B
2672:	1189  C603    	DUMP60:	ADD	A,3		;Plus three - begin ASCII display
2673:	118B  47      		LD	B,A		;Pad line until	ASCII display area
2674:	118C  CD4D26  	DUMP70:	CALL	RSPACE
2675:	118F  10FB    		DJNZ	DUMP70
2676:	1191  ED42    		SBC	HL,BC		;Rewind	memory point by	like amount
2677:	1193  7E      	DUMP80:	LD	A,(HL)		;Start ASCII display
2678:	1194  23      		INC	HL
2679:	1195  CD7328  		CALL	ASCI
2680:	1198  0D      		DEC	C
2681:	1199  20F8    		JR	NZ,DUMP80
2682:	119B  CD9D25  		CALL	TTYQ		;CR aborts command
2683:	119E  FE0D    		CP	CR
2684:	11A0  CA100C  		JP	Z,Z8E
2685:	11A3  7A      		LD	A,D		;Test for block	size tally expired
2686:	11A4  B3      		OR	E
2687:	11A5  20A2    		JR	NZ,DUMP30
2688:	11A7  ED5B042F		LD	DE,(BSIZ)	;Reinit	block size
2689:	11AB  CDBD25  		CALL	TTYI		;Query user for	more
2690:	11AE  FE0D    		CP	CR
2691:			; Next two lines replaced by inverted test - 27 Dec 88 - jrs - V 3.5.1
2692:			;	call	z,crlf
2693:			;	jr	z,dump30	;not cr	- next block
2694:			;----				(Comment on last line is wrong anyway!)
2695:	11B0  C43B26  		CALL	NZ,CRLF		;Not cr - next block
2696:	11B3  2094    		JR	NZ,DUMP30
2697:			;----
2698:	11B5  22062F  		LD	(BLKPTR),HL
2699:	11B8  C9      		RET			;end command
2701:			;******************************************************************************
2702:			;*
2703:			;*	rgst:  display and optionally modify individual	registers
2704:			;*
2705:			;*	call iedt:   read edited input into inbf
2706:			;*	call prsr:   parse input
2707:			;*	call mreg:   validate register name and	map into reg storage
2708:			;*	call iarg:   query user	for replacement
2709:			;*
2710:			;******************************************************************************
2711:			
2712:	11B9  0E20    	RGST:	LD	C,' '		;get edited input
2713:	11BB  0652    		LD	B,INBFSZ
2714:	11BD  CDB927  		CALL	IEDT
2715:	11C0  F8      		RET	M
2716:	11C1  3A2B2F  		LD	A,(TRMNTR)
2717:	11C4  FE20    		CP	' '
2718:	11C6  CC6828  		CALL	Z,BKSP
2719:	11C9  CD561A  		CALL	PRSR
2720:	11CC  B0      		OR	B		;unbalanced quotes (prime reg?)
2721:	11CD  F2DD11  		JP	P,RGST00
2722:	11D0  E67F    		AND	7FH
2723:	11D2  FE03    		CP	3
2724:	11D4  2063    		JR	NZ,RGST25
2725:	11D6  2B      		DEC	HL
2726:	11D7  7E      		LD	A,(HL)
2727:	11D8  D627    		SUB	QUOTE
2728:	11DA  205D    		JR	NZ,RGST25
2729:	11DC  77      		LD	(HL),A
2730:	11DD  3A0230  	RGST00:	LD	A,(INBFNC)	;number	of characters in buffer
2731:	11E0  FE04    		CP	4
2732:	11E2  3055    		JR	NC,RGST25	;error - too many chars
2733:	11E4  ED44    		NEG
2734:	11E6  C604    		ADD	A,4		;calculate space padding
2735:	11E8  4F      		LD	C,A
2736:	11E9  FE03    		CP	3		;was it	one?
2737:	11EB  200B    		JR	NZ,RGST10
2738:	11ED  1A      		LD	A,(DE)
2739:	11EE  CD3226  		CALL	IXLT
2740:	11F1  FE50    		CP	'P'
2741:	11F3  2003    		JR	NZ,RGST10
2742:	11F5  320230  		LD	(INBFNC),A	;any number > 2	indicates 16 bit register
2743:	11F8  CD5426  	RGST10:	CALL	SPACES
2744:	11FB  7E      		LD	A,(HL)		;check last char in parse buffer
2745:	11FC  D627    		SUB	QUOTE
2746:	11FE  2001    		JR	NZ,RGST15	;not quote
2747:	1200  77      		LD	(HL),A		;replace with null
2748:	1201  CD4E12  	RGST15:	CALL	MREG		;validate register name
2749:	1204  2033    		JR	NZ,RGST25	;error
2750:	1206  3A2A2F  		LD	A,(REGTRM)	;mreg stored char following reg	name
2751:	1209  A7      		AND	A
2752:	120A  202D    		JR	NZ,RGST25	;error - no operators allowed
2753:	120C  3A0230  		LD	A,(INBFNC)	;now check number of chars in buffer
2754:	120F  47      		LD	B,A		;save in b reg for 8 or	16 bit reg test
2755:	1210  3D      		DEC	A		;test for one -	8 bit reg
2756:	1211  0E03    		LD	C,3
2757:	1213  2807    		JR	Z,RGST20
2758:	1215  7E      		LD	A,(HL)
2759:	1216  CD6E26  		CALL	OUTHEX		;display byte of reg contents
2760:	1219  2B      		DEC	HL
2761:	121A  0E01    		LD	C,1
2762:	121C  7E      	RGST20:	LD	A,(HL)
2763:	121D  CD4A26  		CALL	OTHXSP
2764:	1220  CD5426  		CALL	SPACES		;reg c - number	of spaces to print
2765:	1223  EB      		EX	DE,HL		;de - save reg contents	pointer
2766:	1224  CD9526  	RGST22:	CALL	ISTR		;query user for	reg value replacement
2767:	1227  3A0230  		LD	A,(INBFNC)	;test number of	chars in input buffer
2768:	122A  3D      		DEC	A		;
2769:	122B  FA4512  		JP	M,RGST40	;none -	prompt for next	reg name
2770:	122E  CDA126  		CALL	IRSM
2771:	1231  280B    		JR	Z,RGST30
2772:	1233  3A0230  		LD	A,(INBFNC)
2773:	1236  A7      		AND	A
2774:	1237  28EB    		JR	Z,RGST22
2775:	1239  CDA70D  	RGST25:	CALL	EXXX
2776:	123C  1807    		JR	RGST40		;accept	new reg	name
2777:	123E  EB      	RGST30:	EX	DE,HL
2778:	123F  73      		LD	(HL),E
2779:	1240  05      		DEC	B		;test for 16 bit reg
2780:	1241  2802    		JR	Z,RGST40	;z - 8 bit reg
2781:	1243  23      		INC	HL
2782:	1244  72      		LD	(HL),D		;save upper byte of user input
2783:	1245  CD3B26  	RGST40:	CALL	CRLF
2784:	1248  CD5226  		CALL	SPACE5
2785:	124B  C3B911  		JP	RGST
2786:			
2787:			
2788:			
2789:	124E  0E17    	MREG:	LD	C,23		;number	of reserved operands
2790:	1250  CD5818  		CALL	OPRN00		;check validity	of register name
2791:	1253  1A      		LD	A,(DE)		;last char examined by operand routine
2792:	1254  CDDB1A  		CALL	OPRTOR
2793:	1257  C0      		RET	NZ		;error - not null or valid operator
2794:	1258  322A2F  		LD	(REGTRM),A	;save terminator character for rgst
2795:	125B  79      		LD	A,C
2796:	125C  FE11    		CP	17		;valid reg names are less than 17
2797:	125E  3805    		JR	C,MREG00	;so far	so good
2798:	1260  D617    		SUB	23		;last chance - may be pc
2799:	1262  C0      		RET	NZ		;error - invalid reg name
2800:	1263  3E0A    		LD	A,10		;make pc look like p for mapping
2801:	1265  21E42E  	MREG00:	LD	HL,REGMAP	;ptrs to register contents storage
2802:	1268  85      		ADD	A,L		;index into table by operand value
2803:	1269  6F      		LD	L,A
2804:	126A  3001    		JR	NC,MREG05
2805:	126C  24      		INC	H
2806:	126D  78      	MREG05:	LD	A,B		;b reg set m by	prsr if	trailing quote
2807:	126E  A7      		AND	A
2808:	126F  3E00    		LD	A,0		;assume	no quote - not prime reg
2809:	1271  F27612  		JP	P,MREG10	;p - correct assumption
2810:	1274  3E08    		LD	A,8		;bias pointer for prime	reg contents
2811:	1276  86      	MREG10:	ADD	A,(HL)
2812:	1277  4F      		LD	C,A		;save mapping byte
2813:	1278  E67F    		AND	7FH		;strip sign
2814:							;so iarg knows 16 bit reg pair
2815:	127A  219F2F  		LD	HL,REGCON	;use mapping byte to build pointer
2816:	127D  85      		ADD	A,L
2817:	127E  6F      		LD	L,A
2818:	127F  3001    		JR	NC,MREG50
2819:	1281  24      		INC	H
2820:	1282  AF      	MREG50:	XOR	A		;hl - pointer to register contents
2821:	1283  C9      		RET
2822:			
2824:			;******************************************************************************
2825:			;*
2826:			;*	qprt:	read and display / write to i/o	ports
2827:			;*
2828:			;*		contents of ports are displayed	and the	user is	queried
2829:			;*		input character	effects	the current port address:
2830:			;*
2831:			;*		space -	display	next sequential	port on	same line
2832:			;*		lf    -	display	next sequential	port on	new line
2833:			;*		cr    -	end command
2834:			;*		slash -	display	same port on same line
2835:			;*		^     -	display	previous port on new line
2836:			;*
2837:			;*		any other input	is treated as a	replacement byte and
2838:			;*		is output to the current port address.	any of the
2839:			;*		above characters may be	used to	continue the display.
2840:			;*
2841:			;*		enter: e  - port at which to begin display
2842:			;*
2843:			;******************************************************************************
2844:			
2845:	1284          	QPRT:
2846:	1284          	NPRT:
2847:	1284  AF      		XOR	A
2848:	1285  321F2F  		LD	(PARENF),A
2849:	1288  CDB227  	  	CALL	IEDTBC		;get port specified by user
2850:	128B  21472F  		LD	HL,PORT
2851:	128E  5E      		LD	E,(HL)
2852:	128F  FADA12  		JP	M,QPRT30	;m - no input means use last port number
2853:	1292  EB      		EX	DE,HL
2854:	1293  CDD426  	        CALL	IARG		;extract address
2855:	1296  C2A70D  		JP	NZ,EXXX
2856:	1299  EB      		EX	DE,HL 		;e - new port number
2857:	129A  73      		LD	(HL),E
2858:	129B  3A1F2F  		LD	A,(PARENF)
2859:	129E  FE28    		CP	'('
2860:	12A0  2038    		JR	NZ,QPRT30
2861:	12A2  0E02    		LD	C,2
2862:	12A4  CD5426  		CALL	SPACES
2863:	12A7  4B      	QPRT00:	LD	C,E
2864:	12A8  ED78    		IN	A,(C)
2865:	12AA  47      		LD	B,A
2866:	12AB  CD6E26  		CALL	OUTHEX
2867:	12AE  0E02    		LD	C,2
2868:	12B0  CD5426  		CALL	SPACES
2869:	12B3  0E08    		LD	C,8		;number of bits to display
2870:	12B5  CB20    	QPRT10:	SLA	B		;most significant bit to carry
2871:	12B7  3E30    		LD	A,'0'
2872:	12B9  CE00    		ADC	A,0		;carry makes it a 1
2873:	12BB  CDDD25  		CALL	TTYO
2874:	12BE  0D      		DEC	C
2875:	12BF  20F4    		JR	NZ,QPRT10
2876:	12C1  4B      		LD	C,E
2877:	12C2  0603    		LD	B,3
2878:	12C4  CD9D25  		CALL	TTYQ
2879:	12C7  FE0D    		CP	CR
2880:	12C9  C8      		RET	Z
2881:	12CA  CDD40F  		CALL	CLOK		;so we don't go faster than the terminal
2882:	12CD  59      		LD	E,C
2883:	12CE  78      		LD	A,B
2884:	12CF  A7      		AND	A
2885:	12D0  F0      		RET	P
2886:	12D1  060C    		LD	B,12
2887:	12D3  CD6828  	QPRT20:	CALL	BKSP
2888:	12D6  10FB    		DJNZ	QPRT20
2889:	12D8  18CD    		JR	QPRT00
2890:	12DA  CD3B26  	QPRT30:	CALL	CRLF
2891:	12DD  7B      		LD	A,E
2892:	12DE  32472F  		LD	(PORT),A
2893:	12E1  CD4A26  		CALL	OTHXSP
2894:	12E4  CD4D26  		CALL	RSPACE
2895:	12E7  4B      		LD	C,E
2896:	12E8  3AE729  		LD	A,(LCMD)
2897:	12EB  FE4E    		CP	'N'
2898:	12ED  2805    		JR	Z,QPRT50
2899:	12EF  ED78    	       	IN	A,(C)
2900:	12F1  CD6227  		CALL	OUTBYT
2901:	12F4  CD7227  	QPRT50:	CALL	RBYTE
2902:	12F7  3A2B2F  		LD	A,(TRMNTR)
2903:	12FA  200F    		JR	NZ,QPRT60
2904:	12FC  FE2E    		CP	'.'
2905:	12FE  C8      		RET	Z
2906:	12FF  21BB2F  		LD	HL,ARGBC
2907:	1302  46      		LD	B,(HL)
2908:	1303  21BF2F  		LD	HL,ARGBF
2909:	1306  4B      		LD	C,E		;port number
2910:	1307  EDB3    		OTIR
2911:	1309  18CF    		JR	QPRT30
2912:	130B  FE20    	QPRT60:	CP	' '
2913:	130D  20CB    		JR	NZ,QPRT30
2914:	130F  1B      		DEC	DE
2915:	1310  18C8    		JR	QPRT30
2916:			
2917:			
2919:			;******************************************************************************
2920:			;*
2921:			;*	break:	set breakpoint routine
2922:			;*
2923:			;*	breakpoint address storage table (brktbl) is examined and user
2924:			;*	specified breakpoint is	considered valid unless:
2925:			;*
2926:			;*		     - table full
2927:			;*		     - address already exists in table
2928:			;*
2929:			;*	optional pass counts can be specified by the user immediatley following
2930:			;*	the breakpoint if they are enclosed in parens.
2931:			;*
2932:			;*	entry point brk30:
2933:			;*	      entered from single step command to set breakpoint.  two table
2934:			;*	      slots are	permanently available for step breakpoints. step
2935:			;*	      routine calls with c pos to tell us not to look for more args
2936:			;*	      in the input buffer.
2937:			;*
2938:			;******************************************************************************
2939:			
2940:	1312  CDB227  	BREAK:	CALL	IEDTBC
2941:	1315  F8      		RET	M		;end command - no input
2942:	1316  0EFF    		LD	C,0FFH		;set neg - distinguish ourselves from step
2943:	1318  3A1C2F  	BRK10:	LD	A,(BPS)		;fetch current bp count
2944:	131B  FE10    		CP	MAXBP		;table full
2945:	131D  D2A70D  		JP	NC,EXXX		;full -	abort command
2946:	1320  47      		LD	B,A		;save current count
2947:	1321  CDD426  		CALL	IARG
2948:	1324  C2A70D  		JP	NZ,EXXX
2949:	1327  EB      		EX	DE,HL		;de - breakpoint address to set
2950:	1328  21492F  	BRK30:	LD	HL,BRKTBL
2951:	132B  AF      		XOR	A
2952:	132C  B0      		OR	B		;check for no breakpoints in effect
2953:	132D  2816    		JR	Z,BRK60		;none -	bypass check for duplicate
2954:	132F  7B      	BRK40:	LD	A,E
2955:	1330  BE      		CP	(HL)		;check lo order	address	match
2956:	1331  23      		INC	HL
2957:	1332  200D    		JR	NZ,BRK50	;no match - check next
2958:	1334  7A      		LD	A,D
2959:	1335  96      		SUB	(HL)		;check hi order
2960:	1336  2009    		JR	NZ,BRK50	;no match - check next
2961:	1338  B1      		OR	C
2962:	1339  F0      		RET	P
2963:	133A  211C2F  		LD	HL,BPS		;pointer to bp count
2964:	133D  7E      		LD	A,(HL)
2965:	133E  90      		SUB	B		;create	index into psctbl
2966:	133F  180C    		JR	BRK70
2967:	1341  23      	BRK50:	INC	HL
2968:	1342  23      		INC	HL		;bump past contents storage byte
2969:	1343  10EA    		DJNZ	BRK40
2970:	1345  73      	BRK60:	LD	(HL),E		;set in	table
2971:	1346  23      		INC	HL
2972:	1347  72      		LD	(HL),D
2973:	1348  211C2F  		LD	HL,BPS		;breakpoint count
2974:	134B  7E      		LD	A,(HL)		;fetch current count for user as index
2975:	134C  34      		INC	(HL)		;bump bp count
2976:	134D  117F2F  	BRK70:	LD	DE,PSCTBL	;base of pass count table
2977:	1350  87      		ADD	A,A		;two byte table
2978:	1351  83      		ADD	A,E
2979:	1352  5F      		LD	E,A
2980:	1353  3001    		JR	NC,BRK80
2981:	1355  14      		INC	D
2982:	1356  AF      	BRK80:	XOR	A
2983:	1357  12      		LD	(DE),A		;pre-clear pass	count table entry
2984:	1358  13      		INC	DE
2985:	1359  12      		LD	(DE),A
2986:	135A  B1      		OR	C		;test if this was step calling
2987:	135B  F0      		RET	P		;i'm positive it was
2988:	135C  3A202F  		LD	A,(DELIM)	;check delimeter which followed	bp address
2989:	135F  A7      		AND	A
2990:	1360  C8      		RET	Z		;end of	line null - terminate command
2991:	1361  FE2C    		CP	','		;check for pass	count delimeter
2992:	1363  C21813  		JP	NZ,BRK10	;not comma means treatt	this as	new bp
2993:	1366  CDD426  		CALL	IARG		;get next arg
2994:	1369  C2A70D  		JP	NZ,EXXX		;nz - evaluation error
2995:	136C  EB      		EX	DE,HL		;de - pass count as entered by user
2996:	136D  72      		LD	(HL),D		;store pass count in table
2997:	136E  2B      		DEC	HL
2998:	136F  73      		LD	(HL),E
2999:	1370  A7      		AND	A		;check delimeter
3000:	1371  C21813  		JP	NZ,BRK10	;nz - more arguments follow
3001:	1374  C9      		RET			;end of	line null - terminate command
3003:			
3004:			;******************************************************************************
3005:			;*
3006:			;*	cbreak:	clear breakpoint
3007:			;*
3008:			;*	breakpoint address storage table (brktbl) is examined and breakpoint
3009:			;*	is removed if found. breakpoint	is removed by bubbling up all bp
3010:			;*	addresses which	follow,	ditto for pass counts.
3011:			;*
3012:			;******************************************************************************
3013:			
3014:	1375  CDB227  	CBREAK:	CALL	IEDTBC
3015:	1378  F8      		RET	M		;no input ends command
3016:	1379  3A1C2F  		LD	A,(BPS)		;fetch breakpoint count
3017:	137C  B7      		OR	A		;any if	effect
3018:	137D  C8      		RET	Z		;no
3019:	137E  47      		LD	B,A		;temp save count
3020:	137F  CDD426  		CALL	IARG		;extract address to clear from input buffer
3021:	1382  11492F  		LD	DE,BRKTBL	;bp address storage table
3022:	1385  2813    		JR	Z,CBRK10
3023:	1387  3A5530  		LD	A,(PRSBF)
3024:	138A  FE2A    		CP	'*'
3025:	138C  C2A70D  		JP	NZ,EXXX
3026:	138F  3A0230  		LD	A,(INBFNC)
3027:	1392  3D      		DEC	A
3028:	1393  C2A70D  		JP	NZ,EXXX
3029:	1396  321C2F  		LD	(BPS),A
3030:	1399  C9      		RET
3031:			
3032:	139A  1A      	CBRK10:	LD	A,(DE)		;test lo order address for match
3033:	139B  BD      		CP	L
3034:	139C  13      		INC	DE
3035:	139D  2002    		JR	NZ,CBRK20	;no match - examine next entry
3036:	139F  1A      		LD	A,(DE)
3037:	13A0  BC      		CP	H		;versus	hi order bp address
3038:	13A1  13      	CBRK20:	INC	DE
3039:	13A2  13      		INC	DE		;bump past contents save location
3040:	13A3  2805    		JR	Z,CBRK30	;zero -	found bp in table
3041:	13A5  10F3    		DJNZ	CBRK10
3042:	13A7  C3A70D  		JP	EXXX		;error - breakpoint not	found
3043:	13AA  26FF    	CBRK30:	LD	H,0FFH		;rewind	to point to bp address
3044:	13AC  2EFD    		LD	L,-3
3045:	13AE  19      		ADD	HL,DE
3046:	13AF  EB      		EX	DE,HL		;de - ptr to bp	  hl - ptr to next bp
3047:	13B0  78      		LD	A,B		;multiply number of bps	remaining in table
3048:							;times three bytes per entry
3049:	13B1  87      		ADD	A,A
3050:	13B2  80      		ADD	A,B
3051:	13B3  4F      		LD	C,A		;init c	for ldir
3052:	13B4  78      		LD	A,B		;save number of	bps remaining
3053:	13B5  0600    		LD	B,0
3054:	13B7  EDB0    		LDIR			;bubble	up all remaining entries in table
3055:	13B9  4F      		LD	C,A		;
3056:	13BA  211C2F  		LD	HL,BPS		;address of bp count
3057:	13BD  7E      		LD	A,(HL)		;
3058:	13BE  35      		DEC	(HL)		;decrement system breakpoint count
3059:	13BF  91      		SUB	C		;compute relative number of pass count table
3060:							;entry we wish to clear
3061:	13C0  87      		ADD	A,A		;times two bytes per entry
3062:	13C1  6F      		LD	L,A
3063:	13C2  60      		LD	H,B		;cheap clear
3064:	13C3  117F2F  		LD	DE,PSCTBL
3065:	13C6  19      		ADD	HL,DE		;index into pass count table
3066:	13C7  EB      		EX	DE,HL
3067:	13C8  210200  		LD	HL,02
3068:	13CB  19      		ADD	HL,DE		;de - ptr to pass count	 hl - next in table
3069:	13CC  CB21    		SLA	C		;number	of pass	counts to move
3070:	13CE  EDB0    		LDIR
3071:	13D0  3A202F  		LD	A,(DELIM)	;recheck delimeter
3072:	13D3  A7      		AND	A
3073:	13D4  209F    		JR	NZ,CBREAK	;not end of line terminator - clear more
3074:	13D6  C9      		RET
3076:			;***********************************************************************
3077:			;*
3078:			;*     obreak:	output all breakpoints and associated pass counts to
3079:			;*		console.  search symbol	table for match, if symbol name
3080:			;*		found display it along with address.
3081:			;*
3082:			;*     wbreak:	wipe out (clear) all breakpoints currently in effect
3083:			;*
3084:			;*		entered:  b - zero
3085:			;*
3086:			;***********************************************************************
3087:			
3088:	13D7  3A1C2F  	OBREAK:	LD	A,(BPS)		;fetch bp count
3089:	13DA  3D      		DEC	A		;test for no breakpoints
3090:	13DB  F8      		RET	M		;m - none
3091:	13DC  47      		LD	B,A		;save count
3092:	13DD  21492F  	OBRK00:	LD	HL,BRKTBL	;base of breakpoint storage table
3093:	13E0  58      		LD	E,B		;use current breakpoint	count as index
3094:	13E1  1600    		LD	D,0		;clear
3095:	13E3  19      		ADD	HL,DE		;this is a three byte table
3096:	13E4  19      		ADD	HL,DE
3097:	13E5  19      		ADD	HL,DE
3098:	13E6  5E      		LD	E,(HL)		;fetch lo order	bp address
3099:	13E7  23      		INC	HL
3100:	13E8  56      		LD	D,(HL)		;upper address
3101:	13E9  EB      		EX	DE,HL
3102:	13EA  CD6426  		CALL	OUTADR		;display address
3103:	13ED  EB      		EX	DE,HL		;hl - breakpoint table
3104:	13EE  CD4B25  		CALL	FADR		;check symbol table for	name match
3105:							;   symbol table pointer returned in de
3106:							;   zero flag set if found
3107:	13F1  3A322F  		LD	A,(MAXLEN)
3108:	13F4  4F      		LD	C,A
3109:	13F5  0B      		DEC	BC		;max number of chars in	a symbol name
3110:	13F6  EB      		EX	DE,HL		;hl - symbol table address if
3111:	13F7  CCA728  		CALL	Z,PRINTB	;display name if found in symbol table
3112:	13FA  78      		LD	A,B
3113:	13FB  87      		ADD	A,A		;bp number times two
3114:	13FC  217F2F  		LD	HL,PSCTBL	;base of pass count table
3115:	13FF  85      		ADD	A,L
3116:	1400  6F      		LD	L,A
3117:	1401  3001    		JR	NC,OBRK10
3118:	1403  24      		INC	H
3119:	1404  5E      	OBRK10:	LD	E,(HL)		;lo order pass count
3120:	1405  23      		INC	HL
3121:	1406  56      		LD	D,(HL)		;upper byte
3122:	1407  7A      		LD	A,D		;test if pass count in effect
3123:	1408  B3      		OR	E
3124:	1409  2808    		JR	Z,OBRK20	;z - no	pass count for this bp
3125:	140B  0C      		INC	C
3126:	140C  CD5426  		CALL	SPACES
3127:	140F  EB      		EX	DE,HL
3128:	1410  CD6426  		CALL	OUTADR		;display pass count in hex
3129:	1413  CD3B26  	OBRK20:	CALL	CRLF
3130:	1416  0E05    		LD	C,5
3131:	1418  CD5426  		CALL	SPACES
3132:	141B  05      		DEC	B		;dec bp	count
3133:	141C  F2DD13  		JP	P,OBRK00
3134:	141F  C9      		RET
3135:			
3136:			
3137:			
3138:	1420  CDB227  	KDMP:	CALL	IEDTBC		;let user input address of memory to display
3139:	1423  F8      		RET	M		;no input ends command
3140:	1424  CDD426  		CALL	IARG		;evaluate user arg
3141:	1427  C2A70D  		JP	NZ,EXXX
3142:	142A  EB      		EX	DE,HL		;de - save memory address
3143:	142B  CDD426  		CALL	IARG		;now get count
3144:	142E  3E00    		LD	A,0
3145:	1430  2018    		JR	NZ,KDMP20	;error during input - display 00 bytes
3146:	1432  B4      		OR	H
3147:	1433  C2A70D  		JP	NZ,EXXX		;greater than 256 is error
3148:	1436  3A322F  		LD	A,(MAXLEN)	;max symbol length
3149:	1439  0602    		LD	B,2		;assume big names
3150:	143B  FE0F    		CP	15
3151:	143D  3E12    		LD	A,18		;number of disassembled lines displayed
3152:	143F  2802    		JR	Z,KDMP00
3153:	1441  0603    		LD	B,3		;double number of lines one extra time
3154:	1443  87      	KDMP00:	ADD	A,A		;times two
3155:	1444  10FD    		DJNZ	KDMP00
3156:	1446  BD      		CP	L
3157:	1447  3801    		JR	C,KDMP20	;if number of bytes specified by user is too
3158:							;large then use default
3159:	1449  7D      		LD	A,L		;use value specified by user
3160:	144A  ED53432F	KDMP20:	LD	(WNWTAB),DE
3161:	144E  32452F  		LD	(WNWSIZ),A
3162:	1451  C9      		RET
3164:			;**************************************************************************
3165:			;*
3166:			;*		     begin/resume execution of user program
3167:			;*
3168:			;*	address	entered:     execution begins at entered address
3169:			;*	no address entered:  execution resumed at specified by saved pc
3170:			;*
3171:			;*	breakpoint table examined:
3172:			;*	      -	memory contents	from each address is removed from user
3173:			;*		program	and saved in breakpoint	table
3174:			;*	      -	rst 38 instruction is placed at	each breakpoint	address
3175:			;*		in user	program
3176:			;*
3177:			;*	user registers restored
3178:			;*
3179:			;***************************************************************************
3180:			
3181:	1452  CDB227  	GO:	CALL	IEDTBC		;query user for	execution address
3182:			
3183:			;	ret	m		;- eg 3.3.3 no input - reprompt
3184:	1455  F25D14  		JP	P,G001		;+ Skip if argument supplied, else:
3185:	1458  2AAF2F  		LD	HL,(PCREG)	;+ Use current PC
3186:	145B  1806    		JR	G002		;+
3187:	145D          	G001:				;+
3188:	145D  CDD426  		CALL	IARG
3189:	1460  C2A70D  		JP	NZ,EXXX		;error - invalid argument
3190:	1463          	G002:				;+
3191:	1463  CD3B26  		CALL	CRLF
3192:	1466  CD3B26  		CALL	CRLF
3193:	1469  22272F  	G100:	LD	(JMPLO),HL	;store execution address
3194:	146C  3EC3    		LD	A,IJP
3195:	146E  32262F  		LD	(SJMP),A		;set jp	instruction
3196:	1471  32232F  		LD	(JMP2JP),A	;just in case
3197:	1474  3A1C2F  		LD	A,(BPS)		;check breakpoint count
3198:	1477  A7      		AND	A
3199:	1478  CA3015  		JP	Z,G600		;z - no	bps in effect -	no restoration needed
3200:	147B  47      		LD	B,A
3201:	147C  21492F  		LD	HL,BRKTBL
3202:	147F  0EFF    		LD	C,0FFH
3203:	1481  5E      	G300:	LD	E,(HL)
3204:	1482  23      		INC	HL
3205:	1483  56      		LD	D,(HL)		;de - breakpoint address removed from table
3206:	1484  23      		INC	HL		;point to contents save	byte in	table
3207:	1485  1A      		LD	A,(DE)
3208:	1486  77      		LD	(HL),A
3209:	1487  3A272F  		LD	A,(JMPLO)
3210:	148A  BB      		CP	E		;check if bp from table	matches	next pc
3211:	148B  2009    		JR	NZ,G400		;no match - set	breakpoint
3212:	148D  3A282F  		LD	A,(JMPHI)
3213:	1490  BA      		CP	D		;check hi order	next pc	address
3214:	1491  2003    		JR	NZ,G400		;no match - set	bp
3215:	1493  48      		LD	C,B		;set flag - current pc matches breakpoint
3216:	1494  1803    		JR	G500
3217:	1496  3ECF    	G400:	LD	A,RST38		;set rst38 instruction
3218:	1498  12      		LD	(DE),A		;save user byte	in brktbl
3219:	1499  23      	G500:	INC	HL
3220:	149A  10E5    		DJNZ	G300		;examine all entries
3221:	149C  0C      		INC	C		;current pc match breakpoint?
3222:	149D  CA3015  		JP	Z,G600		;z - no (c reg not 0ffh)
3223:	14A0  3A1B2F  		LD	A,(SBPS)	;check number of step breakpoints
3224:	14A3  A7      		AND	A		;tracing?
3225:	14A4  C23015  		JP	NZ,G600		;nz - this is trace
3226:			
3227:							;pc points to address in breakpoint table
3228:							;next instruction will not be executed where
3229:							;it resides.  it will be moved to our internal
3230:							;buffer (execbf) and executed there. then we
3231:							;set an rst38 at actual location in user
3232:							;program.  this allows us to debug loops in
3233:							;which only one bp is set.  otherwise we would
3234:							;not be able to set a bp at the address where
3235:							;the pc points and debugging loops would be
3236:							;impossible.
3237:	14A7  211F2F  		LD	HL,EXECBF
3238:	14AA  ED5B272F		LD	DE,(JMPLO)	;de - pointer to next instruction to execute
3239:	14AE  22272F  		LD	(JMPLO),HL	;execute buffer
3240:	14B1  0604    		LD	B,4		;clear execute buffer
3241:	14B3  3600    	G505:	LD	(HL),INOP
3242:	14B5  23      		INC	HL
3243:	14B6  10FB    		DJNZ	G505
3244:	14B8  CDF31A  		CALL	ZLEN00		;calculate length
3245:							;if instruction modifies pc then zlen lets us
3246:							;know by setting b reg nz and c contains
3247:							;instruction length
3248:			
3249:	14BB  222E2F  		LD	(JROPND),HL	;if this is a jr instruction we need to save
3250:							;address where we will be jumping
3251:			
3252:			
3253:							;default execbf has been initialized:
3254:							;
3255:							;four nops
3256:							;     jp   user program
3257:							;
3258:	14BE  EB      		EX	DE,HL		;hl - ptr to user instruction
3259:	14BF  111F2F  		LD	DE,EXECBF
3260:	14C2  7E      		LD	A,(HL)		;first object byte from	user program
3261:	14C3  36CF    	G518:	LD	(HL),RST38	;replace
3262:	14C5  C5      		PUSH	BC		;b - if nz this is a pc modifying instruction
3263:							;c - number of bytes of object code for this
3264:							;    instruction
3265:	14C6  12      	G520:	LD	(DE),A		;into execute buffer
3266:	14C7  13      		INC	DE
3267:	14C8  23      		INC	HL		;bump user program pointer
3268:	14C9  7E      		LD	A,(HL)		;next byte of instruction from user program
3269:	14CA  0D      		DEC	C
3270:	14CB  20F9    		JR	NZ,G520
3271:	14CD  C1      		POP	BC
3272:							;the four nops in execbf have now been replaced
3273:							;by from one to four bytes of actual user
3274:							;instruction.  if user instruction was shorter
3275:							;than four bytes the nops remain and are
3276:							;executed until the jump back to the user
3277:							;program at jmp2jp is reached.
3278:			
3279:			
3280:	14CE  22242F  		LD	(JMP2),HL	;address of next inline instruction within
3281:							;user code
3282:			
3283:	14D1  EB      		EX	DE,HL		;de - next inline instruction in user program
3284:	14D2  AF      		XOR	A
3285:	14D3  B0      		OR	B
3286:	14D4  285A    		JR	Z,G600		;z - the instruction in execbf is not a pc
3287:							;modifying instruction
3288:			
3289:	14D6  3A1F2F  		LD	A,(EXECBF)	;first byte of instruction
3290:	14D9  0D      		DEC	C		;one byte instruction?
3291:	14DA  2854    		JR	Z,G600
3292:	14DC  0D      		DEC	C
3293:	14DD  2827    		JR	Z,G550		;two byter
3294:	14DF  0D      		DEC	C
3295:	14E0  204E    		JR	NZ,G600		;nz - must be four byter
3296:	14E2  41      		LD	B,C		;clear for cpir
3297:	14E3  0E09    		LD	C,Z803SL	;test for call instruction
3298:	14E5  217E2A  		LD	HL,Z803S	;load list of first byte of call instructions
3299:	14E8  EDB1    		CPIR
3300:	14EA  2044    		JR	NZ,G600		;nz - not call
3301:			
3302:							;moving call instructions and executing them
3303:							;locally requires special processing because
3304:							;the z80 will store the address pc+3 on the
3305:							;stack.  in this case we do not want the
3306:							;address  execbf+3 on the stack.  we want the
3307:							;address of the actual location of the user
3308:							;instruction+3 on the stack.  we must do this
3309:							;by simulating a call instruction. we use the
3310:							;jp instruction which is equivalent to the
3311:							;call and we also push a computed return
3312:							;address on to the user stack pointed to by
3313:							;spreg.
3314:			
3315:	14EC  010800  		LD	BC,08		;point to jump instruction which is equivalent
3316:							;to call (call nz = jp nz)
3317:	14EF  09      		ADD	HL,BC
3318:	14F0  7E      		LD	A,(HL)		;fetch jump object byte
3319:	14F1  2AB12F  		LD	HL,(SPREG)	;push next pc onto user stack
3320:	14F4  2B      		DEC	HL		;decrement user sp
3321:	14F5  72      		LD	(HL),D		;de - "return address"
3322:	14F6  2B      		DEC	HL
3323:	14F7  73      		LD	(HL),E
3324:	14F8  22B12F  		LD	(SPREG),HL
3325:	14FB  321F2F  		LD	(EXECBF),A	;store jp op code
3326:	14FE  21242F  		LD	HL,JMP2		;if conditional call and we fall thru
3327:							;we need to go back to address of call
3328:							;in user program + 3
3329:	1501  73      		LD	(HL),E
3330:	1502  23      		INC	HL
3331:	1503  72      		LD	(HL),D
3332:	1504  182A    		JR	G600
3333:							;if next instruction to execute is a
3334:							;relative jump we need to replace it with
3335:							;an absolute equivalent.  this is because
3336:							;having relocated the user jr instruction
3337:							;into execbf we will undoubtedly be out of
3338:							;range of the destination.
3339:			
3340:	1506  0E06    	G550:	LD	C,Z802CL	;check if this is relative jump
3341:	1508  21702A  		LD	HL,Z802C
3342:	150B  A7      		AND	A		;clear carry
3343:	150C  EDB1    		CPIR
3344:	150E  2020    		JR	NZ,G600		;not a jr
3345:	1510  79      		LD	A,C
3346:	1511  01702A  		LD	BC,Z802C
3347:	1514  ED42    		SBC	HL,BC
3348:	1516  2B      		DEC	HL
3349:	1517  01872A  		LD	BC,Z803C
3350:	151A  09      		ADD	HL,BC		;point to equivalent absolute jump
3351:	151B  A7      		AND	A
3352:	151C  7E      		LD	A,(HL)
3353:	151D  211F2F  		LD	HL,EXECBF
3354:	1520  2005    		JR	NZ,G555		;nz - not last in list (not djnz)
3355:			
3356:							;replace djnz with  dec   b
3357:							;		    jp    nz,
3358:			
3359:	1522  3605    		LD	(HL),05		;dec b instruction
3360:	1524  23      		INC	HL
3361:	1525  3EC2    		LD	A,0C2H		;jp nz absolute
3362:	1527  77      	G555:	LD	(HL),A
3363:	1528  23      		INC	HL
3364:	1529  ED4B2E2F		LD	BC,(JROPND)	;if this is a conditional jr we need the
3365:							;absolute destination of the jump
3366:	152D  71      		LD	(HL),C
3367:	152E  23      		INC	HL
3368:	152F  70      		LD	(HL),B
3369:			
3370:	1530  FD2AB52F	G600:	LD	IY,(IYREG)	;restore user iy
3371:	1534  DD2AB32F		LD	IX,(IXREG)	;restore user ix
3372:	1538  3AB72F  		LD	A,(RREG)
3373:	153B  ED4F    		LD	R,A		;restore user r	reg
3374:	153D  3AB82F  		LD	A,(IREG)
3375:	1540  ED47    		LD	I,A		;restore user i	reg
3376:	1542  ED4BA92F		LD	BC,(BCPREG)	;restore user grade a prime regs
3377:	1546  ED5BAB2F		LD	DE,(DEPREG)
3378:	154A  2AA72F  		LD	HL,(AFPREG)
3379:	154D  E5      		PUSH	HL
3380:	154E  F1      		POP	AF
3381:	154F  2AAD2F  		LD	HL,(HLPREG)
3382:	1552  08      		EX	AF,AF'
3383:	1553  D9      		EXX
3384:	1554  2A9F2F  		LD	HL,(AFREG)	;restore user accumulator and flag
3385:	1557  E5      		PUSH	HL
3386:	1558  F1      		POP	AF
3387:	1559  ED4BA12F		LD	BC,(BCREG)	;restore user bc
3388:	155D  ED5BA32F		LD	DE,(DEREG)	;restore user de
3389:	1561  2AA52F  		LD	HL,(HLREG)	;restore user hl
3390:	1564  ED7BB12F		LD	SP,(SPREG)	;restore user sp
3391:	1568  C3262F  		JP	SJMP
3393:			;******************************************************************************
3394:			;*
3395:			;*	step:  Single step (trace) routine
3396:			;*
3397:			;*	Call zlen to determine where to	set breakpoint.
3398:			;*
3399:			;*		pass:	   de -	current	pc address
3400:			;*
3401:			;*		returned:  b:  z - next	instruction will not modify pc.
3402:			;*				   set bp at address specified by pc+length.
3403:			;*
3404:			;*			   b: nz - next	instruction will modify	pc (jumps,
3405:			;*				   calls, and returns) thus set	bp at address
3406:			;*				   returned in hl.
3407:			;*
3408:			;*			   c:	 - number of bytes in current instruction.
3409:			;*
3410:			;*		zlen handles secondary breakpoint to set for all conditional
3411:			;*		call, return, and jump instructions.
3412:			;*
3413:			;*	Call brk00 to set breakpoint.
3414:			;*
3415:			;*		pass:	   b - current number of breakpoints.
3416:			;*			  hl - address at which	to set breakpoint.
3417:			;*
3418:			;*	entry point step:    entered by	user via (s)ingle step command.
3419:			;*	entry point step40:  entered by	breakpoint handler - step count	nz
3420:			;*
3421:			;*	exit:	to go routine to resume	execution.
3422:			;*
3423:			;******************************************************************************
3424:			
3425:	156B  3EFF    	STEP:	LD	A,0FFH
3426:	156D  32182F  		LD	(WFLAG),A	;set trace subroutine flag on
3427:	1570  CDB227  		CALL	IEDTBC		;query user for	trace count
3428:	1573  210100  		LD	HL,0001
3429:	1576  FAA315  		JP	M,STEP40	;null input - step count of one
3430:	1579  CD561A  		CALL	PRSR
3431:	157C  C2A70D  		JP	NZ,EXXX
3432:	157F  1A      		LD	A,(DE)		;first character from parse buffer
3433:	1580  D62F    		SUB	'/'
3434:	1582  32182F  		LD	(WFLAG),A	;may be	slash -	no subroutine tracing
3435:	1585  210000  		LD	HL,00
3436:	1588  2009    		JR	NZ,STEP20
3437:	158A  12      		LD	(DE),A
3438:	158B  3A0230  		LD	A,(INBFNC)
3439:	158E  3D      		DEC	A
3440:	158F  23      		INC	HL
3441:	1590  2811    		JR	Z,STEP40
3442:	1592  2B      		DEC	HL
3443:	1593  CDEF18  	STEP20:	CALL	XVAL		;evaluate contents of parse buffer
3444:	1596  C2A70D  		JP	NZ,EXXX
3445:	1599  ED5BAF2F		LD	DE,(PCREG)
3446:	159D  1A      		LD	A,(DE)		;first byte of op code at current pc
3447:	159E  FEC7    		CP	0C7H		;test for rst
3448:	15A0  CAA70D  		JP	Z,EXXX		;no tracing of rsts
3449:	15A3  22192F  	STEP40:	LD	(NSTEP),HL	;save step count
3450:	15A6  211B2F  		LD	HL,SBPS		;set step flag nz - trace in effect
3451:	15A9  34      		INC	(HL)
3452:	15AA  ED5BAF2F		LD	DE,(PCREG)	;fetch current pc
3453:	15AE  CDF31A  		CALL	ZLEN00		;determine number of bytes in instruction
3454:	15B1  04      		INC	B		;test where to set breakpoint
3455:	15B2  1002    		DJNZ	STEP50		;nz - set at address in	hl
3456:	15B4  EB      		EX	DE,HL
3457:	15B5  09      		ADD	HL,BC		;z - set at address pc + instruction length
3458:	15B6  3A1C2F  	STEP50:	LD	A,(BPS)		;get current number of bps
3459:	15B9  47      		LD	B,A		;pass to set bp	routine	in b reg
3460:	15BA  EB      		EX	DE,HL		;de - bp address to set
3461:	15BB  CD2813  		CALL	BRK30
3462:	15BE  2AAF2F  		LD	HL,(PCREG)	;resume	execution at next pc
3463:	15C1  AF      		XOR	A
3464:	15C2  B0      		OR	B
3465:	15C3  C26914  		JP	NZ,G100		;nz - collision	with user bp
3466:	15C6  EB      		EX	DE,HL
3467:	15C7  211B2F  		LD	HL,SBPS		;step bp set by	brk30 -	bump count
3468:	15CA  34      		INC	(HL)
3469:	15CB  EB      		EX	DE,HL
3470:	15CC  C36914  		JP	G100
3472:			;******************************************************************************
3473:			;*
3474:			;*	asmblr:	z80 assembler
3475:			;*
3476:			;******************************************************************************
3477:			
3478:	15CF          	ASMBLR:
3479:	15CF  CD8926  		CALL	ILIN
3480:	15D2  C2A70D  		JP	NZ,EXXX
3481:	15D5  CD3B26  	ASM000:	CALL	CRLF
3482:	15D8  220C2F  		LD	(ZASMPC),HL	;save here as well
3483:	15DB  CD8C20  		CALL	ZASM08		;disassemble first instruction
3484:			
3485:	15DE          	ASM005:
3486:	15DE  2A0C2F  		LD	HL,(ASMBPC)
3487:	15E1  CD3B26  	ASM010:	CALL	CRLF
3488:	15E4  CD6426  		CALL	OUTADR		;display current assembly pc
3489:	15E7  0E16    		LD	C,22		;
3490:	15E9  CD5426  		CALL	SPACES		;leave room for	object code
3491:	15EC  3E03    		LD	A,3
3492:	15EE  21FD2F  		LD	HL,OBJBUF	;zero scratch object code buffer
3493:	15F1  71      	ASM015:	LD	(HL),C
3494:	15F2  23      		INC	HL
3495:	15F3  3D      		DEC	A
3496:	15F4  F2F115  		JP	P,ASM015
3497:	15F7  32102F  		LD	(OPRN01),A	;init operand key values to 0ffh
3498:	15FA  32132F  		LD	(OPRN02),A
3499:	15FD  CDB227  		CALL	IEDTBC		;get user input
3500:	1600  F8      		RET	M		;m - no	input ends command
3501:	1601  CD4526  		CALL	CRET
3502:	1604  CD561A  		CALL	PRSR		;parse to obtain label
3503:	1607  7E      		LD	A,(HL)		;check last character
3504:	1608  FE3A    		CP	':'
3505:	160A  202B    		JR	NZ,ASM040	;no colon found	- must be op code
3506:	160C  3600    		LD	(HL),0		;erase colon
3507:	160E  1A      		LD	A,(DE)		;fetch first char of label from	parse buffer
3508:	160F  FE41    		CP	'A'
3509:	1611  DAA51A  		JP	C,ASMXXL	;error - first character must be alpha
3510:	1614  FE7B    		CP	'z'+1
3511:	1616  D2A51A  		JP	NC,ASMXXL	;label error
3512:	1619  FE61    		CP	'a'
3513:	161B  3005    		JR	NC,ASM030
3514:	161D  FE5B    		CP	'Z'+1
3515:	161F  D2A51A  		JP	NC,ASMXXL
3516:	1622  210000  	ASM030:	LD	HL,00
3517:	1625  222C2F  		LD	(ISYMPT),HL	;clear pointer
3518:	1628  CD321A  		CALL	ISYM		;attempt to insert symbol into symbol table
3519:	162B  C2B51A  		JP	NZ,ASMXXT	;error - symbol	table full
3520:	162E  222C2F  		LD	(ISYMPT),HL	;save pointer to symbol	value in symbol	table
3521:	1631  CD561A  		CALL	PRSR		;extract opcode
3522:	1634  FADE15  		JP	M,ASM005	;m - statement contains	label only
3523:	1637  3A202F  	ASM040:	LD	A,(DELIM)	;check delimeter
3524:	163A  FE2C    		CP	','		;check for invalid terminator
3525:	163C  CAA91A  		JP	Z,ASMXXO
3526:	163F  0E49    		LD	C,73		;number	of opcodes in table as index
3527:	1641  0D      	ASM050:	DEC	C
3528:	1642  FAA91A  		JP	M,ASMXXO	;opcode	not found
3529:	1645  0600    		LD	B,0
3530:	1647  21B02D  		LD	HL,ZOPCNM	;table of opcode names
3531:	164A  09      		ADD	HL,BC
3532:	164B  09      		ADD	HL,BC		;index times four
3533:	164C  09      		ADD	HL,BC
3534:	164D  09      		ADD	HL,BC
3535:	164E  115530  		LD	DE,PRSBF	;start of parse	buffer
3536:	1651  0604    		LD	B,4
3537:	1653  1A      	ASM060:	LD	A,(DE)		;character from	parse buffer
3538:	1654  A7      		AND	A		;null?
3539:	1655  2002    		JR	NZ,ASM070
3540:	1657  3E20    		LD	A,' '		;for comparison	purposes
3541:	1659  CD3226  	ASM070:	CALL	IXLT		;force upper case for compare
3542:	165C  BE      		CP	(HL)
3543:	165D  20E2    		JR	NZ,ASM050	;mismatch - next opcode	name
3544:	165F  13      		INC	DE
3545:	1660  23      		INC	HL
3546:	1661  10F0    		DJNZ	ASM060		;must match all	four
3547:	1663  1A      		LD	A,(DE)		;null following	opcode?
3548:	1664  A7      		AND	A
3549:	1665  C2A91A  		JP	NZ,ASMXXO	;error - opcode	more than 4 characaters
3550:	1668  21262F  		LD	HL,IKEY		;relative position in table is key value
3551:	166B  71      		LD	(HL),C		;save opcode key value
3552:	166C  CD561A  		CALL	PRSR		;extract first operand
3553:	166F  FA9A16  		JP	M,ASM085	;m - none
3554:	1672  CD5518  		CALL	OPRN		;evaluate operand
3555:	1675  2047    		JR	NZ,ASMXXU	;error - bad first operand
3556:	1677  11102F  		LD	DE,OPRN01
3557:	167A  CDE31A  		CALL	OPNV		;save operand value and	key
3558:	167D  3A202F  		LD	A,(DELIM)
3559:	1680  FE2C    		CP	','
3560:	1682  2016    		JR	NZ,ASM085	;need comma for	two operands
3561:	1684  CD561A  		CALL	PRSR		;extract second	operand
3562:	1687  FAB11A  		JP	M,ASMXXS	;error - comma with no second operand
3563:	168A  FE2C    		CP	','
3564:	168C  CAB11A  		JP	Z,ASMXXS	;illegal line termination
3565:	168F  CD5518  		CALL	OPRN		;evaluate operand
3566:	1692  202A    		JR	NZ,ASMXXU	;error - bad second operand
3567:	1694  11132F  		LD	DE,OPRN02
3568:	1697  CDE31A  		CALL	OPNV		;save second operand value and key
3569:	169A  AF      	ASM085:	XOR	A
3570:	169B  4F      		LD	C,A
3571:	169C  21B02A  	ASM090:	LD	HL,ZOPCPT	;opcode	name pointer table
3572:	169F  0600    		LD	B,0
3573:	16A1  09      		ADD	HL,BC		;index into table
3574:	16A2  3A262F  		LD	A,(IKEY)	;fetch opcode key value
3575:	16A5  BE      		CP	(HL)		;check for match
3576:	16A6  2013    		JR	NZ,ASM095	;
3577:	16A8  24      		INC	H		;point to first	operand	table
3578:	16A9  11102F  		LD	DE,OPRN01	;address of first operand key value
3579:	16AC  CD8A17  		CALL	OPNM		;check validity
3580:	16AF  200A    		JR	NZ,ASM095	;no match - next
3581:	16B1  47      		LD	B,A		;save modified key value
3582:	16B2  24      		INC	H		;point to second operand table
3583:	16B3  11132F  		LD	DE,OPRN02	;address of second operand key value
3584:	16B6  CD8A17  		CALL	OPNM
3585:	16B9  2808    		JR	Z,IBLD		;match - attempt final resolution
3586:	16BB  0C      	ASM095:	INC	C		;bump index
3587:	16BC  20DE    		JR	NZ,ASM090	;nz - check more
3588:	16BE  3E55    	ASMXXU:	LD	A,'U'		;error
3589:	16C0  C3BB1A  		JP	ASMXXX
3590:			
3591:			
3592:			
3593:			
3594:	16C3  21FD2F  	IBLD:	LD	HL,OBJBUF	;object	code temp buffer
3595:	16C6  5F      		LD	E,A		;save second operand key
3596:	16C7  7E      		LD	A,(HL)		;check first byte of object buffer
3597:	16C8  A7      		AND	A		;null?
3598:	16C9  79      		LD	A,C		;instruction key to accumulator	regardless
3599:	16CA  4B      		LD	C,E		;save second operand modified key
3600:	16CB  2801    		JR	Z,IBLD00	;z - not ix or iy instruction
3601:	16CD  23      		INC	HL		;point to byte two of object code
3602:	16CE  FE40    	IBLD00:	CP	40H
3603:	16D0  3844    		JR	C,IBLD55	;c - 8080 instruction
3604:	16D2  FEA0    		CP	0A0H
3605:	16D4  300B    		JR	NC,IBLD10	;nc - not ed instruction
3606:	16D6  36ED    		LD	(HL),0EDH	;init byte one of object code
3607:	16D8  23      		INC	HL
3608:	16D9  FE80    		CP	80H		;check which ed	instruction we have
3609:	16DB  3839    		JR	C,IBLD55	;c - this is exact object byte
3610:	16DD  C620    		ADD	A,20H		;add bias to obtain object byte
3611:	16DF  1835    		JR	IBLD55
3612:	16E1  FEE0    	IBLD10:	CP	0E0H
3613:	16E3  3004    		JR	NC,IBLD20
3614:	16E5  C620    		ADD	A,20H		;8080 type - range 0c0h	to 0ffh
3615:	16E7  182D    		JR	IBLD55		;object	byte built
3616:	16E9  FEE8    	IBLD20:	CP	0E8H
3617:	16EB  3824    		JR	C,IBLD50	;8 bit reg-reg arithmetic or logic
3618:	16ED  FEF7    		CP	0F7H		;check for halt	disguised as ld (hl),(hl)
3619:	16EF  2004    		JR	NZ,IBLD30
3620:	16F1  3E76    		LD	A,76H		;halt object code
3621:	16F3  1821    		JR	IBLD55
3622:	16F5  FEF8    	IBLD30:	CP	0F8H
3623:	16F7  3018    		JR	NC,IBLD50	;8 bit reg-reg load
3624:	16F9  57      		LD	D,A		;temp save instruction key value
3625:	16FA  3AFD2F  		LD	A,(OBJBUF)
3626:	16FD  A7      		AND	A		;check for previously stored first object byte
3627:	16FE  7A      		LD	A,D
3628:	16FF  36CB    		LD	(HL),0CBH	;init byte regardless
3629:	1701  23      		INC	HL
3630:	1702  2801    		JR	Z,IBLD40	;z - not ix or iy instruction
3631:	1704  23      		INC	HL		;bump object code pointer - this is four byter
3632:	1705  C6A8    	IBLD40:	ADD	A,0A8H		;add bias for comparison purposes
3633:	1707  FE98    		CP	98H
3634:	1709  3806    		JR	C,IBLD50	;c - shift or rotate instruction
3635:	170B  0F      		RRCA
3636:	170C  0F      		RRCA
3637:	170D  E6C0    		AND	0C0H		;this is skeleton for bit instuctions
3638:	170F  1805    		JR	IBLD55
3639:	1711  87      	IBLD50:	ADD	A,A		;form skeleton
3640:	1712  87      		ADD	A,A
3641:	1713  87      		ADD	A,A
3642:	1714  C680    		ADD	A,80H
3643:	1716  77      	IBLD55:	LD	(HL),A		;store object byte
3644:	1717  AF      		XOR	A
3645:	1718  B1      		OR	C		;second	operand	need more processing?
3646:	1719  11132F  		LD	DE,OPRN02
3647:	171C  C4C817  		CALL	NZ,RSLV		;resolve second	operand
3648:	171F  C2B91A  		JP	NZ,ASMXXV	;error - invalid operand size
3649:	1722  11102F  		LD	DE,OPRN01
3650:	1725  78      		LD	A,B
3651:	1726  A7      		AND	A		;first operand resolvedX
3652:	1727  C4C817  		CALL	NZ,RSLV		;more work to do
3653:	172A  C2B91A  		JP	NZ,ASMXXV	;error - invalid operand size
3654:	172D  3A262F  		LD	A,(IKEY)
3655:	1730  D643    		SUB	67		;org directive?
3656:	1732  2007    		JR	NZ,IBLD60
3657:	1734  56      		LD	D,(HL)
3658:	1735  2B      		DEC	HL
3659:	1736  5E      		LD	E,(HL)
3660:	1737  EB      		EX	DE,HL
3661:	1738  C3D515  		JP	ASM000		;z - org directive
3662:	173B  11FD2F  	IBLD60:	LD	DE,OBJBUF
3663:	173E  3831    		JR	C,IBLD70	;c - instruction  nc - directive
3664:	1740  47      		LD	B,A		;number	of bytes for defb or defw or ddb
3665:	1741  13      		INC	DE		;point past erroneous assembled	opcode
3666:	1742  13      		INC	DE
3667:	1743  D603    		SUB	3		;test for ddb
3668:	1745  382E    		JR	C,IBLD75	;c - must be defb or defw
3669:	1747  3D      		DEC	A
3670:	1748  201E    		JR	NZ,IBLD65	;nz - must be ddb
3671:	174A  56      		LD	D,(HL)		;must be equ
3672:	174B  2B      		DEC	HL
3673:	174C  5E      		LD	E,(HL)
3674:	174D  2A2C2F  		LD	HL,(ISYMPT)	;fetch pointer to entry	in symbol table
3675:	1750  7C      		LD	A,H
3676:	1751  B5      		OR	L
3677:	1752  CABE16  		JP	Z,ASMXXU	;error - no label on equ statement
3678:	1755  72      		LD	(HL),D
3679:	1756  2B      		DEC	HL
3680:	1757  73      		LD	(HL),E		;store value of	symbol in symbol table
3681:	1758  0E06    		LD	C,6
3682:	175A  CD5426  		CALL	SPACES
3683:	175D  7A      		LD	A,D
3684:	175E  CD4A26  		CALL	OTHXSP
3685:	1761  7B      		LD	A,E
3686:	1762  CD4A26  		CALL	OTHXSP
3687:	1765  C3DE15  		JP	ASM005		;ready for next	input
3688:	1768  05      	IBLD65:	DEC	B		;set count of object bytes to 2
3689:	1769  4E      		LD	C,(HL)		;exchange hi and lo order bytes	for ddb
3690:	176A  2B      		DEC	HL
3691:	176B  7E      		LD	A,(HL)
3692:	176C  71      		LD	(HL),C		;new hi order
3693:	176D  23      		INC	HL
3694:	176E  77      		LD	(HL),A		;new hi order replaces old lo order
3695:	176F  1804    		JR	IBLD75
3696:	1771  CDF31A  	IBLD70:	CALL	ZLEN00		;compute length	of instruction in bytes
3697:	1774  41      		LD	B,C		;b - number of bytes of	object code
3698:	1775  2A0C2F  	IBLD75:	LD	HL,(ASMBPC)
3699:	1778  CD6426  		CALL	OUTADR		;re-display current location counter
3700:	177B  1A      	IBLD80:	LD	A,(DE)		;move from scratch object buffer
3701:	177C  77      		LD	(HL),A		;into address pointed to by location counter
3702:	177D  23      		INC	HL
3703:	177E  13      		INC	DE
3704:	177F  CD4A26  		CALL	OTHXSP		;display each object code byte
3705:	1782  10F7    		DJNZ	IBLD80
3706:	1784  220C2F  	IBLD90:	LD	(ASMBPC),HL
3707:	1787  C3DE15  		JP	ASM005		;next input from user
3708:			
3709:			
3710:			
3711:			
3712:	178A  1A      	OPNM:	LD	A,(DE)		;key value computed by operand routine
3713:	178B  AE      		XOR	(HL)		;compare with table operand table entry
3714:	178C  C8      		RET	Z		;true match of operand key values
3715:	178D  AE      		XOR	(HL)		;restore
3716:	178E  87      		ADD	A,A		;86 all	no operand key values (0ffh)
3717:	178F  F8      		RET	M
3718:	1790  7E      		LD	A,(HL)		;fetch table entry
3719:	1791  E67F    		AND	7FH		;sans paren flag for comparison	purposes
3720:	1793  FE1B    		CP	1BH		;check table entry 8 bit - 16 bit - $ rel ?
3721:	1795  380B    		JR	C,OPNM00	;c - none of the above
3722:	1797  1A      		LD	A,(DE)		;fetch computed	key
3723:	1798  AE      		XOR	(HL)		;compare with paren flags
3724:	1799  F8      		RET	M		;error - paren mismatch
3725:	179A  1A      		LD	A,(DE)		;fetch key once	more
3726:	179B  E67F    		AND	7FH		;remove	paren flag
3727:	179D  FE17    		CP	17H		;computed as 8 bit - 16	bit - $	rel?
3728:	179F  2820    		JR	Z,OPNM40	;so far	so good
3729:	17A1  C9      		RET			;
3730:	17A2  FE19    	OPNM00:	CP	19H		;check for 8 bit reg
3731:	17A4  300C    		JR	NC,OPNM20	;8 bit register	match
3732:	17A6  FE18    		CP	18H		;table says must be hl - ix - iy
3733:	17A8  C0      		RET	NZ		;computed key disagrees
3734:	17A9  1A      		LD	A,(DE)		;fetch computed	key
3735:	17AA  E607    		AND	7		;computed as hl	- ix - iy ?
3736:	17AC  C0      		RET	NZ		;no
3737:	17AD  1A      	OPNM10:	LD	A,(DE)		;fetch computed	key
3738:	17AE  AE      		XOR	(HL)
3739:	17AF  F8      		RET	M		;error - paren mismatch	on hl -	ix - iy
3740:	17B0  180F    		JR	OPNM40
3741:	17B2  1A      	OPNM20:	LD	A,(DE)		;fetch computed	key of 8 bit reg
3742:	17B3  A7      		AND	A		;
3743:	17B4  2002    		JR	NZ,OPNM30	;nz - not (hl)
3744:	17B6  3D      		DEC	A		;error - 8 bit (hl) missing parens
3745:	17B7  C9      		RET
3746:	17B8  FE08    	OPNM30:	CP	8		;test user entered valid 8 bit reg
3747:	17BA  3805    		JR	C,OPNM40	;c - ok
3748:	17BC  A7      		AND	A		;test if no carry caused by paren flag
3749:	17BD  F0      		RET	P		;error - this is not 8 bit reg with parens
3750:	17BE  E607    		AND	7		;psuedo	8 bit reg: (hl)	(ix) (iy)?
3751:	17C0  C0      		RET	NZ		;no
3752:	17C1  7E      	OPNM40:	LD	A,(HL)		;fetch table entry
3753:	17C2  E67F    		AND	7FH
3754:	17C4  D618    		SUB	18H		;make values 18	thru 1f	relative zero
3755:	17C6  BF      		CP	A		;zero means match
3756:	17C7  C9      		RET
3757:			
3758:	17C8  3D      	RSLV:	DEC	A
3759:	17C9  2804    		JR	Z,RSLV00	;z - 8 bit reg (bits 0-2 of object byte)
3760:	17CB  3D      		DEC	A
3761:	17CC  2011    		JR	NZ,RSLV20	;nz - not 8 bit	reg (bits 3-5 of object	byte)
3762:	17CE  3D      		DEC	A		;make neg to indicate shift left required
3763:	17CF  4F      	RSLV00:	LD	C,A
3764:	17D0  1A      		LD	A,(DE)		;fetch computed	operand	key
3765:	17D1  E607    		AND	07		;lo three bits specify reg
3766:	17D3  EE06    		XOR	6		;create	true object code bits
3767:	17D5  0C      		INC	C		;test if bits 0-2 or bits 3-5
3768:	17D6  2003    		JR	NZ,RSLV10	;nz - 0	thru 2
3769:	17D8  87      		ADD	A,A
3770:	17D9  87      		ADD	A,A
3771:	17DA  87      		ADD	A,A
3772:	17DB  B6      	RSLV10:	OR	(HL)		;or with skeleton
3773:	17DC  77      		LD	(HL),A		;into scratch object buffer
3774:	17DD  BF      		CP	A		;set zero - no error
3775:	17DE  C9      		RET
3776:	17DF  13      	RSLV20:	INC	DE		;point to low order of operand value
3777:	17E0  4E      		LD	C,(HL)		;c - current skeleton  (if needed)
3778:	17E1  23      		INC	HL		;bump object code buffer pointer
3779:	17E2  3D      		DEC	A
3780:	17E3  201D    		JR	NZ,RSLV30	;nz - not relative jump
3781:	17E5  EB      		EX	DE,HL		;save object code pointer in de
3782:	17E6  7E      		LD	A,(HL)
3783:	17E7  23      		INC	HL
3784:	17E8  66      		LD	H,(HL)
3785:	17E9  6F      		LD	L,A		;hl - operand value computed by	xval
3786:	17EA  78      		LD	A,B
3787:	17EB  ED4B0C2F		LD	BC,(ASMBPC)	;current location counter
3788:	17EF  03      		INC	BC
3789:	17F0  03      		INC	BC
3790:	17F1  ED42    		SBC	HL,BC		;calculate displacement	from current counter
3791:	17F3  EB      		EX	DE,HL		;de - displacement  hl - object	code pointer
3792:	17F4  47      		LD	B,A		;restore b reg
3793:	17F5  7B      		LD	A,E		;lo order displacement
3794:	17F6  14      		INC	D		;test hi order
3795:	17F7  2803    		JR	Z,RSLV25	;must have been	ff (backward displacement)
3796:	17F9  15      		DEC	D
3797:	17FA  C0      		RET	NZ		;error - hi order not zero or ff
3798:	17FB  2F      		CPL			;set sign bit for valid	forward	displacement
3799:	17FC  EE80    	RSLV25:	XOR	80H		;toggle	sign bit
3800:	17FE  F8      		RET	M		;error - sign bit disagrees with upper byte
3801:	17FF  73      		LD	(HL),E		;store displacement object byte
3802:	1800  BF      		CP	A		;set zero flag - no errors
3803:	1801  C9      		RET
3804:	1802  3D      	RSLV30:	DEC	A
3805:	1803  2014    		JR	NZ,RSLV40	;nz - not 8 bit	immediate
3806:	1805  3E36    		LD	A,36H		;test for reg indirect - (hl),nn
3807:	1807  B9      		CP	C
3808:	1808  2007    		JR	NZ,RSLV35
3809:	180A  3AFD2F  		LD	A,(OBJBUF)	;test first object byte
3810:	180D  B9      		CP	C
3811:	180E  2801    		JR	Z,RSLV35	;z - (hl),nn
3812:	1810  23      		INC	HL		;must be (ix+index),nn	or  (iy+index),nn
3813:	1811  1A      	RSLV35:	LD	A,(DE)		;move lo order operand value to	object buffer
3814:	1812  77      		LD	(HL),A
3815:	1813  13      		INC	DE
3816:	1814  1A      		LD	A,(DE)		;test hi order
3817:	1815  A7      		AND	A		;
3818:	1816  C8      		RET	Z		;z - must be 0 thru +255
3819:	1817  3C      		INC	A		;error if not -1 thru -256
3820:	1818  C9      		RET
3821:	1819  3D      	RSLV40:	DEC	A
3822:	181A  2008    		JR	NZ,RSLV50	;nz - not 16 bit operand
3823:	181C  1A      		LD	A,(DE)		;move both bytes of operand to object buffer
3824:	181D  77      		LD	(HL),A
3825:	181E  23      		INC	HL
3826:	181F  13      		INC	DE
3827:	1820  1A      		LD	A,(DE)		;byte two
3828:	1821  77      		LD	(HL),A
3829:	1822  BF      		CP	A		;set zero flag - no errors of course
3830:	1823  C9      		RET
3831:	1824  3D      	RSLV50:	DEC	A		;test restart instruction or bit number
3832:	1825  200D    		JR	NZ,RSLV60	;nz - bit or interrupt mode number
3833:	1827  1A      		LD	A,(DE)		;check restart value specified
3834:	1828  E6C7    		AND	0C7H		;betweed 0 and 38h?
3835:	182A  C0      		RET	NZ		;error
3836:	182B  1A      		LD	A,(DE)		;fetch lo order	operand	value
3837:	182C  F6C7    		OR	0C7H		;or with instruction skeleton
3838:	182E  2B      		DEC	HL
3839:	182F  77      		LD	(HL),A		;rewind	object code pointer
3840:	1830  13      		INC	DE
3841:	1831  1A      		LD	A,(DE)		;check hi order	operand	value
3842:	1832  A7      		AND	A		;error if not zero
3843:	1833  C9      		RET
3844:	1834  2B      	RSLV60:	DEC	HL		;rewind	object code buffer pointer
3845:	1835  1A      		LD	A,(DE)
3846:	1836  E6F8    		AND	0F8H		;ensure	bit number in range 0 -	7
3847:	1838  C0      		RET	NZ		;error
3848:	1839  3A262F  		LD	A,(IKEY)	;fetch opcode key value
3849:	183C  D613    		SUB	13H		;is this bit number of interrupt mode number?
3850:	183E  1A      		LD	A,(DE)		;fetch operand value regardless
3851:	183F  200D    		JR	NZ,RSLV70	;nz - bit number
3852:	1841  3646    		LD	(HL),46H
3853:	1843  E603    		AND	03		;im 0?
3854:	1845  C8      		RET	Z
3855:	1846  3656    		LD	(HL),56H
3856:	1848  3D      		DEC	A		;im 1?
3857:	1849  C8      		RET	Z
3858:	184A  365E    		LD	(HL),5EH
3859:	184C  3D      		DEC	A		;error if not im 2
3860:	184D  C9      		RET
3861:	184E  87      	RSLV70:	ADD	A,A		;shift bit number left three
3862:	184F  87      		ADD	A,A
3863:	1850  87      		ADD	A,A
3864:	1851  B6      		OR	(HL)		;or with skeleton
3865:	1852  77      		LD	(HL),A
3866:	1853  BF      		CP	A		;indicate no error
3867:	1854  C9      		RET
3868:			
3869:			
3870:			
3871:	1855  011600  	OPRN:	LD	BC,22		;count of reserved operand
3872:	1858  115530  	OPRN00:	LD	DE,PRSBF	;buffer	contains operand
3873:	185B  7E      		LD	A,(HL)		;last character	of operand in parse buffer
3874:	185C  D629    		SUB	')'
3875:	185E  2007    		JR	NZ,OPRN20	;not paren
3876:	1860  77      		LD	(HL),A		;remove	trailing paren - replace with null
3877:	1861  1A      		LD	A,(DE)		;check first character of parse	buffer
3878:	1862  D628    		SUB	'('
3879:	1864  C0      		RET	NZ		;error - unbalanced parens
3880:	1865  12      		LD	(DE),A		;remove	leading	paren -	replace	with null
3881:	1866  13      		INC	DE		;point to next character in parse buffer
3882:	1867  213529  	OPRN20:	LD	HL,ZOPNM	;index into reserved operand name table
3883:	186A  79      		LD	A,C
3884:	186B  87      		ADD	A,A		;index times two
3885:	186C  85      		ADD	A,L
3886:	186D  6F      		LD	L,A
3887:	186E  3001    		JR	NC,OPRN25
3888:	1870  24      		INC	H
3889:	1871  1A      	OPRN25:	LD	A,(DE)		;from parse buffer
3890:	1872  CD3226  		CALL	IXLT		;translate to upper case for compare
3891:	1875  BE      		CP	(HL)		;versus	table entry
3892:	1876  13      		INC	DE
3893:	1877  205D    		JR	NZ,OPRN70	;no match - check next
3894:	1879  1A      		LD	A,(DE)		;check second character
3895:	187A  CD3226  		CALL	IXLT		;translate to upper case
3896:	187D  A7      		AND	A		;if null - this	is one character reg name
3897:	187E  2002    		JR	NZ,OPRN30
3898:	1880  3E20    		LD	A,' '		;for comparison	purposes
3899:	1882  23      	OPRN30:	INC	HL		;bump table pointer
3900:	1883  96      		SUB	(HL)
3901:	1884  2050    		JR	NZ,OPRN70	;no match - check next
3902:	1886  13      		INC	DE		;have match - bump buffer pointer
3903:	1887  B0      		OR	B		;
3904:	1888  C0      		RET	NZ		;nz - mreg calling
3905:	1889  79      		LD	A,C		;check index value
3906:	188A  E607    		AND	07
3907:	188C  2050    		JR	NZ,OPRN80	;not hl	ix iy -	check for residue
3908:	188E  1A      		LD	A,(DE)
3909:	188F  CDDB1A  		CALL	OPRTOR		;check for expression operator
3910:	1892  204D    		JR	NZ,OPRN85	;no operator but not end of operand
3911:	1894  3E18    		LD	A,RIX OR RIY	;special ix iy hl processing
3912:	1896  A1      		AND	C		;test for index	reg
3913:	1897  2805    		JR	Z,OPRN35	;z - must be hl
3914:	1899  E610    		AND	10H		;transform index into 0ddh or ofdh
3915:	189B  87      		ADD	A,A
3916:	189C  C6DD    		ADD	A,0DDH		;a - first byte	of index reg opcode
3917:	189E  4F      	OPRN35:	LD	C,A		;temp save first object	byte
3918:	189F  21FD2F  		LD	HL,OBJBUF
3919:	18A2  AE      		XOR	(HL)
3920:	18A3  280A    		JR	Z,OPRN40	;z - first operand matches second
3921:	18A5  B9      		CP	C
3922:	18A6  C0      		RET	NZ		;illegal ix iy hl combination
3923:	18A7  3A102F  		LD	A,(OPRN01)
3924:	18AA  A7      		AND	A		;test if index reg was first operand
3925:	18AB  2002    		JR	NZ,OPRN40
3926:	18AD  3D      		DEC	A		;error - hl illegal as second
3927:	18AE  C9      		RET
3928:			
3929:			
3930:	18AF  71      	OPRN40:	LD	(HL),C		;init first byte of object code
3931:	18B0  3A5530  		LD	A,(PRSBF)
3932:	18B3  A7      		AND	A		;check for previously removed parens
3933:	18B4  79      		LD	A,C
3934:	18B5  0E00    		LD	C,0
3935:	18B7  2025    		JR	NZ,OPRN80	;no parens - no	indexed	displacement
3936:	18B9  A7      		AND	A		;check for ix or iy indexed instruction
3937:	18BA  2822    		JR	Z,OPRN80	;z - not index reg instruction
3938:			
3939:	18BC  ED62    		SBC	HL,HL		;clear hl
3940:	18BE  1A      		LD	A,(DE)		;index reg displacement	processing
3941:	18BF  A7      		AND	A		;test for default displacement
3942:	18C0  C4EF18  		CALL	NZ,XVAL		;not zero - evaluate
3943:	18C3  201C    		JR	NZ,OPRN85	;nz - displacement in error
3944:	18C5  0E00    		LD	C,00
3945:	18C7  7D      		LD	A,L
3946:	18C8  32FF2F  		LD	(OBJBUF+2),A	;displacement always third byte
3947:	18CB  24      		INC	H		;check upper byte of index value
3948:	18CC  2803    		JR	Z,OPRN50	;must have been	0ffh
3949:	18CE  25      		DEC	H
3950:	18CF  C0      		RET	NZ		;error - index not -128	to +127
3951:	18D0  2F      		CPL
3952:	18D1  EE80    	OPRN50:	XOR	80H		;check sign bit
3953:	18D3  F8      		RET	M		;bit on	- index	out of range
3954:	18D4  BF      		CP	A		;no error - set	zero flag
3955:	18D5  C9      		RET
3956:	18D6  0D      	OPRN70:	DEC	C		;decrement reserved operand table index
3957:	18D7  FAE118  		JP	M,OPRN85	;m - not a reserved operand
3958:	18DA  1B      		DEC	DE		;rewind	parse buffer pointer
3959:	18DB  C36718  		JP	OPRN20		;next table entry
3960:	18DE  1A      	OPRN80:	LD	A,(DE)		;check for end of parse	buffer
3961:	18DF  A7      		AND	A
3962:	18E0  C8      		RET	Z		;found end of line null
3963:	18E1  115530  	OPRN85:	LD	DE,PRSBF	;rewind	to start of input
3964:	18E4  AF      		XOR	A
3965:	18E5  B0      		OR	B
3966:	18E6  C0      		RET	NZ		;nz - this was mreg calling
3967:	18E7  ED62    		SBC	HL,HL		;clear hl
3968:	18E9  CDEF18  		CALL	XVAL		;evaluate operand
3969:	18EC  0E17    		LD	C,17H		;assume	numeric	operand	found
3970:	18EE  C9      		RET
3971:			
3972:			
3973:	18EF  1A      	XVAL:	LD	A,(DE)		;check first char of parse buffer
3974:	18F0  A7      		AND	A
3975:	18F1  2001    		JR	NZ,XVAL00
3976:	18F3  13      		INC	DE		;bump past previously removed paren
3977:	18F4  22272F  	XVAL00:	LD	(MEXP),HL	;init expression accumulator
3978:	18F7  AF      		XOR	A
3979:	18F8  32222F  		LD	(BASE10),A	;clear upper digit decimal accumulator
3980:	18FB  ED62    		SBC	HL,HL		;clear hl
3981:	18FD  22302F  		LD	(FNDSYM),HL	;clear symbol found flag
3982:	1900  222E2F  		LD	(PASS2),HL
3983:	1903  1A      	XVAL05:	LD	A,(DE)		;char from parse buffer
3984:	1904  CD3226  		CALL	IXLT		;translate to upper case
3985:	1907  4F      		LD	C,A		;save character
3986:	1908  13      		INC	DE		;bump parse buffer pointer
3987:	1909  FE30    		CP	'0'		;check for valid ascii hex digit
3988:	190B  3833    		JR	C,XVAL25
3989:	190D  FE3A    		CP	':'
3990:	190F  3817    		JR	C,XVAL15
3991:	1911  FE41    		CP	'A'
3992:	1913  382B    		JR	C,XVAL25
3993:	1915  FE47    		CP	'G'
3994:	1917  3027    		JR	NC,XVAL25
3995:	1919  AF      		XOR	A		;check number entered flag (b reg sign bit)
3996:	191A  B0      		OR	B
3997:	191B  FA2219  		JP	M,XVAL10	;m - this was not first	char
3998:	191E  3A032F  		LD	A,(SYMFLG)	;check if symbol table present in memory
3999:	1921  A7      		AND	A
4000:	1922  79      	XVAL10:	LD	A,C		;input character back to accumulator
4001:	1923  F24019  		JP	P,XVAL25	;p - have symbol table or invalid hex digit
4002:	1926  D607    		SUB	7
4003:	1928  D630    	XVAL15:	SUB	'0'		;ascii hex to hex nibble
4004:	192A  87      		ADD	A,A		;shift left five - hi bit of nibble to carry
4005:	192B  87      		ADD	A,A
4006:	192C  87      		ADD	A,A
4007:	192D  87      		ADD	A,A
4008:	192E  87      		ADD	A,A
4009:	192F  0E04    		LD	C,4		;loop count
4010:	1931  ED6A    	XVAL20:	ADC	HL,HL		;hl left into carry - rotate carry into	hl
4011:	1933  8F      		ADC	A,A		;next bit of nibble into carry
4012:	1934  0D      		DEC	C
4013:	1935  20FA    		JR	NZ,XVAL20
4014:	1937  32222F  		LD	(BASE10),A	;store what was	shifted	left out of hl
4015:	193A  3E80    		LD	A,80H		;set sign of b - number	entered	flag
4016:	193C  B0      		OR	B
4017:	193D  47      		LD	B,A
4018:	193E  18C3    		JR	XVAL05		;next character
4019:			
4020:	1940  CDDB1A  	XVAL25:	CALL	OPRTOR		;have expression operator?
4021:	1943  280D    		JR	Z,XVAL30
4022:	1945  3A2E2F  		LD	A,(PASS2)
4023:	1948  A7      		AND	A
4024:	1949  C0      		RET	NZ
4025:	194A  3A2F2F  		LD	A,(PASS2+1)
4026:	194D  A7      		AND	A
4027:	194E  CA5D19  		JP	Z,XVAL35
4028:	1951  C9      		RET
4029:			
4030:	1952  AF      	XVAL30:	XOR	A
4031:	1953  B0      		OR	B		;check number entered flag
4032:	1954  79      		LD	A,C		;restore unmodified input character to a
4033:	1955  C2D719  		JP	NZ,XVAL90	;nz - take care	of previous operator
4034:	1958  A7      		AND	A		;end of	line null?
4035:	1959  C8      		RET	Z		;
4036:	195A  41      		LD	B,C		;this operator was first char of parse buffer
4037:	195B  18A6    		JR	XVAL05		;extract what follows this leading operator
4038:			
4039:	195D  79      	XVAL35:	LD	A,C		;recover character
4040:	195E  FE23    		CP	'#'		;decimal processing?
4041:	1960  2029    		JR	NZ,XVAL50	;nz - not decimal
4042:	1962  78      		LD	A,B		;check number entered flag
4043:	1963  EE80    		XOR	80H		;toggle
4044:	1965  F8      		RET	M		;error - pound sign with no number
4045:	1966  47      		LD	B,A
4046:	1967  C5      		PUSH	BC
4047:	1968  D5      		PUSH	DE
4048:	1969  EB      		EX	DE,HL		;save hex number in de
4049:	196A  21222F  		LD	HL,BASE10
4050:	196D  3E06    		LD	A,6
4051:	196F  BE      		CP	(HL)		;check ten thousands digit
4052:	1970  3814    		JR	C,XVAL40	;error - obviously greater than	65535
4053:	1972  ED67    		RRD			;nibble	to accumulator
4054:	1974  23      	 	INC	HL
4055:	1975  72      		LD	(HL),D		;store hex number in temp buffer
4056:	1976  23      		INC	HL
4057:	1977  73      		LD	(HL),E		;lo order hex number
4058:	1978  2B      		DEC	HL		;point back to upper byte
4059:	1979  5F      		LD	E,A
4060:	197A  AF      		XOR	A
4061:	197B  57      		LD	D,A		;de - hex nibble
4062:	197C  CD8328  		CALL	BCDX		;convert hi order byte
4063:	197F  2005    		JR	NZ,XVAL40	;nz - error detected during conversion
4064:	1981  23      		INC	HL		;bump to lo byte to convert
4065:	1982  CD8328  		CALL	BCDX
4066:	1985  EB      		EX	DE,HL		;hl - converted	value
4067:	1986  D1      	XVAL40:	POP	DE
4068:	1987  C1      		POP	BC
4069:	1988  2841    		JR	Z,XVAL65	;z - no	errors detected
4070:	198A  C9      		RET
4071:			
4072:			
4073:			
4074:	198B  FE27    	XVAL50:	CP	QUOTE		;ascii literal processing
4075:	198D  200F    		JR	NZ,XVAL60	;nz - not quote
4076:	198F  EB      		EX	DE,HL		;
4077:	1990  5E      		LD	E,(HL)		;fetch literal from buffer
4078:	1991  23      		INC	HL
4079:	1992  BE      		CP	(HL)		;trailing quote	found?
4080:	1993  2805    		JR	Z,XVAL55	;found
4081:	1995  53      		LD	D,E		;make literal just fetch hi order of operand
4082:	1996  5E      		LD	E,(HL)		;fetch new literal as lo order
4083:	1997  23      		INC	HL
4084:	1998  BE      		CP	(HL)		;trailing quote?
4085:	1999  C0      		RET	NZ		;error - more than two chars between quotes
4086:	199A  EB      	XVAL55:	EX	DE,HL		;de - parse buffer ptr	 hl - operand
4087:	199B  13      		INC	DE		;bump past trailing quote
4088:	199C  182D    		JR	XVAL65
4089:			
4090:			
4091:	199E  1B      	XVAL60:	DEC	DE		;point to start	of operand in parse buffer
4092:	199F  ED532E2F		LD	(PASS2),DE
4093:	19A3  CDF319  		CALL	FSYM		;search	symbol table
4094:	19A6  CAC219  		JP	Z,XVAL62	;symbol	found
4095:	19A9  1A      		LD	A,(DE)
4096:	19AA  13      		INC	DE
4097:	19AB  FE24    		CP	'$'		;check for pc relative expression
4098:	19AD  C2B519  		JP	NZ,XVAL61
4099:	19B0  2A0C2F  		LD	HL,(ASMBPC)	;current location value	is expression value
4100:	19B3  1816    		JR	XVAL65
4101:							;symbol not found - retry evaluation process
4102:							;with pass2 flag set.  now token must be a
4103:							;valid hex digit or error
4104:	19B5  ED5B2E2F	XVAL61:	LD	DE,(PASS2)
4105:	19B9  78      		LD	A,B
4106:	19BA  F680    		OR	80H		;set sign in b - valid digit detected which
4107:							;tells xval this must be hex number
4108:	19BC  47      		LD	B,A
4109:	19BD  ED62    		SBC	HL,HL		;clear hex number accumulator
4110:	19BF  C30319  		JP	XVAL05
4111:	19C2  3A322F  	XVAL62:	LD	A,(MAXLEN)	;point to last byte of sym table entry
4112:	19C5  B5      		OR	L
4113:	19C6  6F      		LD	L,A
4114:	19C7  7E      		LD	A,(HL)		;hi order symbol address
4115:	19C8  2B      		DEC	HL
4116:	19C9  6E      		LD	L,(HL)		;lo order
4117:	19CA  67      		LD	H,A
4118:	19CB  78      	XVAL65:	LD	A,B		;check number entered flag
4119:	19CC  A7      		AND	A
4120:	19CD  F8      		RET	M		;error - numbers entered previous to symbol
4121:	19CE  EE80    		XOR	80H		;toggle	flag
4122:	19D0  47      		LD	B,A
4123:	19D1  1A      		LD	A,(DE)		;check char following symbol name in buffer
4124:	19D2  4F      		LD	C,A		;make it new current character
4125:	19D3  13      		INC	DE
4126:	19D4  C35219  		JP	XVAL30
4127:			
4128:			
4129:			
4130:			
4131:			
4132:	19D7  4F      	XVAL90:	LD	C,A		;temp save operator
4133:	19D8  3E80    		LD	A,80H		;toggle	number entered flag
4134:	19DA  A8      		XOR	B
4135:	19DB  F8      		RET	M		;return	nz - consecutive operators
4136:	19DC  41      		LD	B,C		;new on	deck operator
4137:	19DD  FE2D    		CP	'-'		;test last operator
4138:	19DF  D5      		PUSH	DE		;save buffer pointer
4139:	19E0  2005    		JR	NZ,XVAL95	;nz - addition
4140:	19E2  EB      		EX	DE,HL
4141:	19E3  ED62    		SBC	HL,HL		;clear
4142:	19E5  ED52    		SBC	HL,DE		;force current value neg by subtraction from 0
4143:	19E7  EB      	XVAL95:	EX	DE,HL
4144:	19E8  2A272F  		LD	HL,(MEXP)	;fetch accumulated operand total
4145:	19EB  19      		ADD	HL,DE		;add in	current
4146:	19EC  D1      		POP	DE		;restore buffer	pointer
4147:	19ED  78      		LD	A,B		;check operator	that got us here
4148:	19EE  A7      		AND	A		;end of	line null?
4149:	19EF  C2F418  		JP	NZ,XVAL00	;no -
4150:	19F2  C9      		RET			;operand processing complete
4151:			
4152:			
4153:			
4154:	19F3          	FSYM:
4155:	19F3  2A0600  		LD	HL,(06)		;de - buffer   hl - symbol table
4156:	19F6  3A322F  	FSYM00:	LD	A,(MAXLEN)
4157:	19F9  A5      		AND	L
4158:	19FA  4F      		LD	C,A
4159:	19FB  78      		LD	A,B		;temp save
4160:	19FC  0600    		LD	B,0
4161:	19FE  EB      		EX	DE,HL		;de - symbol table ptr	hl - parse buffer
4162:	19FF  ED42    		SBC	HL,BC		;rewind	parse buffer to	start of symbol
4163:	1A01  EB      		EX	DE,HL		;de - parse buffer  hl - symbol	table pointer
4164:	1A02  47      		LD	B,A		;restore b reg
4165:	1A03  3A322F  		LD	A,(MAXLEN)
4166:	1A06  B5      		OR	L
4167:	1A07  6F      		LD	L,A
4168:	1A08  23      		INC	HL		;next block of symbol table
4169:	1A09  7E      		LD	A,(HL)		;first character of symbol name
4170:	1A0A  3D      		DEC	A
4171:	1A0B  F8      		RET	M		;end of	table
4172:	1A0C  3A322F  		LD	A,(MAXLEN)
4173:	1A0F  3D      		DEC	A
4174:	1A10  4F      		LD	C,A		;chars per symbol
4175:	1A11  1A      	FSYM10:	LD	A,(DE)		;fetch char from buffer
4176:	1A12  CDDB1A  		CALL	OPRTOR
4177:	1A15  2008    		JR	NZ,FSYM20	;nz - not operator or end of line null
4178:	1A17  7E      		LD	A,(HL)
4179:	1A18  A7      		AND	A		;null means end	of symbol name in symbol table
4180:	1A19  20DB    		JR	NZ,FSYM00
4181:	1A1B  22302F  		LD	(FNDSYM),HL	;set symbol found flag nz -
4182:	1A1E  C9      		RET
4183:	1A1F  BE      	FSYM20:	CP	(HL)
4184:	1A20  20D4    		JR	NZ,FSYM00
4185:	1A22  23      		INC	HL
4186:	1A23  13      		INC	DE
4187:	1A24  0D      		DEC	C
4188:	1A25  20EA    		JR	NZ,FSYM10
4189:	1A27  22302F  		LD	(FNDSYM),HL	;set symbol found flag nz -
4190:	1A2A  1A      	FSYM30:	LD	A,(DE)
4191:	1A2B  CDDB1A  		CALL	OPRTOR
4192:	1A2E  C8      		RET	Z
4193:	1A2F  13      		INC	DE
4194:	1A30  18F8    		JR	FSYM30
4195:			
4196:			
4197:			
4198:	1A32  CDF319  	ISYM:	CALL	FSYM		;search	for symbol in table
4199:	1A35  2806    		JR	Z,ISYM00	;z - symbol found
4200:	1A37  7E      		LD	A,(HL)		;test for empty	slot in	table
4201:	1A38  A7      		AND	A
4202:	1A39  C0      		RET	NZ		;symbol	table full
4203:	1A3A  32032F  		LD	(SYMFLG),A	;indicate non-empty symbol table
4204:	1A3D  3A322F  	ISYM00:	LD	A,(MAXLEN)	;rewind	point to start of table	entry
4205:	1A40  4F      		LD	C,A
4206:	1A41  2F      		CPL
4207:	1A42  A5      		AND	L
4208:	1A43  6F      		LD	L,A
4209:	1A44  EB      		EX	DE,HL		;de - pointer to start of symbol
4210:	1A45  215530  		LD	HL,PRSBF
4211:	1A48  0600    		LD	B,0		;move symbol from parse	buffer to table
4212:	1A4A  0D      		DEC	C
4213:	1A4B  EDB0    		LDIR
4214:	1A4D  2A0C2F  		LD	HL,(ASMBPC)	;fetch value of	symbol
4215:	1A50  EB      		EX	DE,HL		;hl - pointer to address storage
4216:	1A51  73      		LD	(HL),E		;lo order current location into	table
4217:	1A52  23      		INC	HL
4218:	1A53  72      		LD	(HL),D		;upper byte
4219:	1A54  AF      		XOR	A
4220:	1A55  C9      		RET
4222:			;******************************************************************************
4223:			;*
4224:			;*	prsr:	command	line parse routine
4225:			;*
4226:			;*	prsr will extract one argument from the	input buffer (inbf) and
4227:			;*	write it into the parse	buffer (prsbf).	an argument is treated
4228:			;*	as starting with the first non-delimeter character encountered
4229:			;*	in the input buffer and ends with the next delimeter found.
4230:			;*	all intervening	characters between the two delimeters are
4231:			;*	treated	as the argument	and are	moved to prsbf.
4232:			;*
4233:			;*	as each character is extracted from inbf a zero is written back
4234:			;*	to replace it.  thus a program which needs to extract multiple args
4235:			;*	need not save pointers in between calls	since prsr is trained
4236:			;*	to strip leading delimeters while looking for the start	of an
4237:			;*	argument:
4238:			;*
4239:			;*	     delimeters: null, space, comma
4240:			;*
4241:			;*	exit:	    de - starting address of parse buffer
4242:			;*		     b - sign bit: set if unbalanced parens, else sign reset
4243:			;*			 bits 6-0: number of chars in the parse	buffer
4244:			;*		     a - actual	delimter char which caused to terminate
4245:			;*		     f - zero flag set if no error
4246:			;*		quoflg - set equal to ascii quote if at	leeat one quote	found
4247:			;*
4248:			;*	error exit:  f - zero flag reset
4249:			;*
4250:			;******************************************************************************
4251:			
4252:	1A56  AF      	PRSR:	XOR	A
4253:	1A57  32172F  		LD	(QUOFLG),A	;clear quote flag
4254:	1A5A  215530  		LD	HL,PRSBF	;start of parser scratch buffer
4255:	1A5D  0652    		LD	B,PRSBFZ	;buffer	size
4256:	1A5F  48      		LD	C,B
4257:	1A60  3600    	PRSR10:	LD	(HL),0		;clear parse buffer to nulls
4258:	1A62  23      		INC	HL
4259:	1A63  10FB    		DJNZ	PRSR10
4260:	1A65  215530  		LD	HL,PRSBF	;start of parse	buffer
4261:	1A68  110330  		LD	DE,INBF		;start of input	buffer
4262:	1A6B  0E51    		LD	C,INBFL		;max size of input buffer
4263:	1A6D  1A      	PRSR20:	LD	A,(DE)		;from input buffer
4264:	1A6E  EB      		EX	DE,HL
4265:	1A6F  3600    		LD	(HL),0		;erase as we pick from input buffer
4266:	1A71  EB      		EX	DE,HL
4267:	1A72  0D      		DEC	C		;decrement buffer size tally
4268:	1A73  F8      		RET	M		;error -  end of input buffer reached
4269:	1A74  13      		INC	DE		;bump input buffer pointer
4270:	1A75  CDD31A  		CALL	ZDLM00		;check for delimeter
4271:	1A78  28F3    		JR	Z,PRSR20	;delimeter found - continue search
4272:	1A7A  321F2F  		LD	(PARENF),A
4273:	1A7D  0E52    		LD	C,NPRSBF-PRSBF	;parse buffer size
4274:	1A7F  77      	PRSR30:	LD	(HL),A
4275:	1A80  A7      		AND	A
4276:	1A81  281B    		JR	Z,PRSR60	;end of	line null always ends parse
4277:	1A83  FE27    		CP	QUOTE		;quote?
4278:	1A85  2007    		JR	NZ,PRSR50
4279:	1A87  32172F  		LD	(QUOFLG),A
4280:	1A8A  78      		LD	A,B		;quote found - toggle flag
4281:	1A8B  EE80    		XOR	80H
4282:	1A8D  47      		LD	B,A
4283:	1A8E  0D      	PRSR50:	DEC	C		;decrement buffer size tally
4284:	1A8F  F8      		RET	M		;error - end of	parse buffer reached
4285:	1A90  1A      		LD	A,(DE)		;next char from	input buffer
4286:	1A91  EB      		EX	DE,HL
4287:	1A92  3600    		LD	(HL),0		;clear as we remove
4288:	1A94  EB      		EX	DE,HL
4289:	1A95  13      		INC	DE
4290:	1A96  04      		INC	B		;bumping character count tests quote flag
4291:	1A97  F4D01A  		CALL	P,ZDLM		;only look for delimeters if quote flag off
4292:	1A9A  23      		INC	HL		;bump parse buffer pointer
4293:	1A9B  20E2    		JR	NZ,PRSR30
4294:	1A9D  2B      		DEC	HL
4295:	1A9E  115530  	PRSR60:	LD	DE,PRSBF	;return	pointing to start of parse buffer
4296:	1AA1  32202F  		LD	(DELIM),A
4297:	1AA4  C9      		RET			;zero flag set - no errors
4298:			
4299:			
4300:			
4301:	1AA5  3E4C    	ASMXXL:	LD	A,'L'
4302:	1AA7  1812    		JR	ASMXXX
4303:	1AA9  3E4F    	ASMXXO:	LD	A,'O'
4304:	1AAB  180E    		JR	ASMXXX
4305:	1AAD  3E50    	ASMXXP:	LD	A,'P'
4306:	1AAF  180A    		JR	ASMXXX
4307:	1AB1  3E53    	ASMXXS:	LD	A,'S'
4308:	1AB3  1806    		JR	ASMXXX
4309:	1AB5  3E54    	ASMXXT:	LD	A,'T'
4310:	1AB7  1802    		JR	ASMXXX
4311:	1AB9  3E56    	ASMXXV:	LD	A,'V'
4312:			
4313:	1ABB  32E529  	ASMXXX:	LD	(ASMFLG),A
4314:	1ABE  CD4526  		CALL	CRET
4315:	1AC1  2A0C2F  		LD	HL,(ASMBPC)
4316:	1AC4  CD6426  		CALL	OUTADR
4317:	1AC7  11DE29  		LD	DE,MXXXX
4318:	1ACA  CD9E28  		CALL	PRINT
4319:	1ACD  C3E115  		JP	ASM010
4320:			
4321:			
4322:	1AD0  FE2C    	ZDLM:	CP	','
4323:	1AD2  C8      		RET	Z
4324:	1AD3  A7      	ZDLM00:	AND	A
4325:	1AD4  C8      		RET	Z
4326:	1AD5  FE09    		CP	TAB
4327:	1AD7  C8      		RET	Z
4328:	1AD8  FE20    		CP	' '
4329:	1ADA  C9      		RET
4330:			
4331:	1ADB  FE2B    	OPRTOR: CP	'+'
4332:	1ADD  C8      		RET	Z
4333:	1ADE  FE2D    		CP	'-'
4334:	1AE0  C8      		RET	Z
4335:	1AE1  A7      		AND	A
4336:	1AE2  C9      		RET
4337:			
4338:			
4339:			
4340:	1AE3  EB      	OPNV:	EX	DE,HL		;de - operand value  hl	- operand key storage
4341:	1AE4  3A5530  		LD	A,(PRSBF)	;check first byte of parse buffer
4342:	1AE7  A7      		AND	A		;if null - paren was removed
4343:	1AE8  79      		LD	A,C		;key value to accumulator
4344:	1AE9  2002    		JR	NZ,OPNV00	;nz - no paren
4345:	1AEB  F680    		OR	80H		;found null - set paren	flag
4346:	1AED  77      	OPNV00:	LD	(HL),A		;store key value
4347:	1AEE  23      		INC	HL
4348:	1AEF  73      		LD	(HL),E		;lo order operand value
4349:	1AF0  23      		INC	HL
4350:	1AF1  72      		LD	(HL),D		;hi order
4351:	1AF2  C9      		RET
4352:			
4353:			
4355:			;******************************************************************************
4356:			;*
4357:			;*	zlen:  determine the number of bytes in	a z80 instruction
4358:			;*
4359:			;*
4360:			;*	entry point zlen00: used to return instruction length.
4361:			;*
4362:			;*			    de:	 address of instruction
4363:			;*
4364:			;*	return:	 b:  z - inline	instruction (next pc will be pc	plus length)
4365:			;*		    nz - pc modifying instruction such as call,	 jump, or ret
4366:			;*			 (see hl below)
4367:			;*		 c:	 number	of bytes in this instruction.
4368:			;*		de:	 preserved
4369:			;*		hl:	 next pc following the execution of the	instruction
4370:			;*			 pointed to by de.
4371:			;*
4372:			;******************************************************************************
4373:			
4374:	1AF3  1A      	ZLEN00:	LD	A,(DE)		;fetch first byte of op	code
4375:	1AF4  FECB    		CP	0CBH		;test for shift/bit manipulation instruction
4376:	1AF6  010200  		LD	BC,02
4377:	1AF9  C8      		RET	Z		;10-4 this is a	cb and length is always	2
4378:	1AFA  FEED    		CP	0EDH		;test for fast eddie
4379:	1AFC  201B    		JR	NZ,ZLEN15	;
4380:	1AFE  13      		INC	DE		;fetch byte two	of ed instruction
4381:	1AFF  1A      		LD	A,(DE)
4382:	1B00  1B      		DEC	DE		;restore pointer
4383:	1B01  21902A  		LD	HL,Z80ED	;ed four byter table
4384:	1B04  0E06    		LD	C,Z80EDL	;length
4385:	1B06  EDB1    		CPIR
4386:	1B08  0E04    		LD	C,4		;assume	ed four	byter
4387:	1B0A  C8      		RET	Z		;correct assumption
4388:	1B0B  0E02    		LD	C,2		;set length for	return - if not	2 must be 4
4389:	1B0D  FE45    		CP	45H		;test for retn
4390:	1B0F  2803    		JR	Z,ZLEN10
4391:	1B11  FE4D    		CP	4DH		;test for reti
4392:	1B13  C0      		RET	NZ		;non-pc	modifying two byte ed
4393:	1B14  3EC9    	ZLEN10:	LD	A,0C9H		;treat as ordinary return instruction
4394:	1B16  C3D11B  		JP	ZLEN80
4395:	1B19  FEDD    	ZLEN15:	CP	0DDH		;check for dd and fd index reg instructions
4396:	1B1B  2804    		JR	Z,ZLEN20
4397:	1B1D  FEFD    		CP	0FDH
4398:	1B1F  2029    		JR	NZ,ZLEN40
4399:	1B21  13      	ZLEN20:	INC	DE		;fetch byte two	of index reg instruction
4400:	1B22  1A      		LD	A,(DE)
4401:	1B23  1B      		DEC	DE		;restore pointer
4402:	1B24  FEE9    		CP	0E9H		;check for reg indirect	jump
4403:	1B26  200C    		JR	NZ,ZLEN30	;
4404:	1B28  04      		INC	B		;reg indirect jump - set pc modified flag nz
4405:	1B29  1A      		LD	A,(DE)		;recheck for ix	or iy
4406:	1B2A  2AB32F  		LD	HL,(IXREG)	;assume	ix
4407:	1B2D  FEDD    		CP	0DDH
4408:	1B2F  C8      		RET	Z		;correct assumption
4409:	1B30  2AB52F  		LD	HL,(IYREG)
4410:	1B33  C9      		RET
4411:	1B34  214B2A  	ZLEN30:	LD	HL,Z80FD	;check for dd or fd two	byter
4412:	1B37  0E0B    		LD	C,Z80FDL
4413:	1B39  EDB1    		CPIR
4414:	1B3B  0E02    		LD	C,2		;assume	two
4415:	1B3D  C8      		RET	Z
4416:	1B3E  21562A  		LD	HL,Z80F4	;not two - try four
4417:	1B41  0E05    		LD	C,Z80F4L
4418:	1B43  EDB1    		CPIR
4419:	1B45  0E04    		LD	C,4		;assume	four
4420:	1B47  C8      		RET	Z		;correct assumption
4421:	1B48  0D      		DEC	C		;must be three
4422:	1B49  C9      		RET
4423:	1B4A  E6C7    	ZLEN40:	AND	0C7H		;check for 8 bit immediate load
4424:	1B4C  FE06    		CP	06
4425:	1B4E  0E02    		LD	C,2		;assume	so
4426:	1B50  C8      		RET	Z
4427:	1B51  0D      		DEC	C		;assume	one byte op code
4428:	1B52  1A      		LD	A,(DE)
4429:	1B53  FE3F    		CP	3FH
4430:	1B55  3803    		JR	C,ZLEN50	;opcodes 0 - 3f	require	further	investigation
4431:	1B57  FEC0    		CP	0C0H		;8 bit reg-reg loads and arithmetics do	not
4432:	1B59  D8      		RET	C
4433:	1B5A  21762A  	ZLEN50:	LD	HL,Z803		;check for three byter
4434:	1B5D  0E1A    		LD	C,Z803L
4435:	1B5F  EDB1    		CPIR
4436:	1B61  2036    		JR	NZ,ZLEN60	;nz - not three
4437:	1B63  217E2A  		LD	HL,Z803S	;established three byter - test conditional
4438:	1B66  0E12    		LD	C,Z803CL
4439:	1B68  EDB1    		CPIR
4440:	1B6A  0E03    		LD	C,3		;set length
4441:	1B6C  C0      		RET	NZ		;nz - three byte inline	instruction
4442:	1B6D  217E2A  		LD	HL,Z803S
4443:	1B70  0E09    		LD	C,Z803SL	;now weed out jumps from calls
4444:	1B72  EDB1    		CPIR
4445:	1B74  0E03    		LD	C,3
4446:	1B76  41      		LD	B,C		;set pc	modified flag -	we have	call or	jump
4447:	1B77  EB      		EX	DE,HL
4448:	1B78  23      		INC	HL
4449:	1B79  5E      		LD	E,(HL)
4450:	1B7A  23      		INC	HL
4451:	1B7B  56      		LD	D,(HL)		;de - address from instruction
4452:	1B7C  EB      		EX	DE,HL
4453:	1B7D  1B      		DEC	DE
4454:	1B7E  1B      		DEC	DE		;restore instruction pointer
4455:	1B7F  2805    		JR	Z,ZLEN55	;z - this is a call
4456:	1B81  FEC3    		CP	IJP		;test for unconditional jump
4457:	1B83  2057    		JR	NZ,ZLEN85
4458:	1B85  C9      		RET
4459:	1B86  3A182F  	ZLEN55:	LD	A,(WFLAG)	;test for no subroutine	trace flag
4460:	1B89  A7      		AND	A		;zero means no sub tracing
4461:	1B8A  47      		LD	B,A		;clear for return - if sub trace off
4462:	1B8B  C8      		RET	Z		;subroutine trace off -	return with b reg 00
4463:							;so bp is set at next inline instruction
4464:	1B8C  05      		DEC	B
4465:	1B8D  2003    		JR	NZ,ZLEN58
4466:	1B8F  78      		LD	A,B
4467:	1B90  B4      		OR	H
4468:	1B91  C8      		RET	Z
4469:	1B92  1A      	ZLEN58:	LD	A,(DE)		;recover call object byte
4470:	1B93  41      		LD	B,C		;set nz	- pc modifying instruction
4471:	1B94  FECD    		CP	0CDH		;unconditional call??
4472:	1B96  2044    		JR	NZ,ZLEN85	;zlen85	- set secondary	breakpoint if tracing
4473:	1B98  C9      		RET
4474:			
4475:	1B99  21652A  	ZLEN60:	LD	HL,Z802
4476:	1B9C  0E11    		LD	C,Z802L		;test for two byter
4477:	1B9E  EDB1    		CPIR
4478:	1BA0  201C    		JR	NZ,ZLEN70	;not two
4479:	1BA2  21702A  		LD	HL,Z802C	;test for relative jump
4480:	1BA5  0E06    		LD	C,Z802CL
4481:	1BA7  EDB1    		CPIR
4482:	1BA9  0E02    		LD	C,2		;in any	case length is two
4483:	1BAB  C0      		RET	NZ		;nz - not relative jump
4484:	1BAC  60      		LD	H,B		;clear
4485:	1BAD  04      		INC	B		;set pc	modified flag nz
4486:	1BAE  13      		INC	DE		;fetch relative	displacement
4487:	1BAF  1A      		LD	A,(DE)
4488:	1BB0  6F      		LD	L,A
4489:	1BB1  87      		ADD	A,A		;test forward or backward
4490:	1BB2  3001    		JR	NC,ZLEN65	;p - forward
4491:	1BB4  25      		DEC	H		;set hl	negative
4492:	1BB5  19      	ZLEN65:	ADD	HL,DE		;compute distance from instruction
4493:	1BB6  23      		INC	HL		;adjust	for built in bias
4494:	1BB7  1B      		DEC	DE		;restore pointer
4495:	1BB8  1A      		LD	A,(DE)		;fetch first byte of instruction
4496:	1BB9  FE18    		CP	18H		;uncondtional jump?
4497:	1BBB  201F    		JR	NZ,ZLEN85	;conditional - set secondary bp	if tracing
4498:	1BBD  C9      		RET
4499:	1BBE  215B2A  	ZLEN70:	LD	HL,Z801		;check for return instruction
4500:	1BC1  0E0A    		LD	C,Z801L
4501:	1BC3  EDB1    		CPIR
4502:	1BC5  0E01    		LD	C,1		;length	must be	1 in any case
4503:	1BC7  C0      		RET	NZ
4504:	1BC8  FEE9    		CP	0E9H
4505:	1BCA  2005    		JR	NZ,ZLEN80	;nz - not  jp (hl)
4506:	1BCC  04      		INC	B		;set pc	modified flag
4507:	1BCD  2AA52F  		LD	HL,(HLREG)	;next pc contained in hlreg
4508:	1BD0  C9      		RET
4509:	1BD1  2AB12F  	ZLEN80:	LD	HL,(SPREG)	;return	instructions hide next pc in stack
4510:	1BD4  46      		LD	B,(HL)
4511:	1BD5  23      		INC	HL
4512:	1BD6  66      		LD	H,(HL)
4513:	1BD7  68      		LD	L,B		;hl - return address removed from stack
4514:	1BD8  41      		LD	B,C		;set b nz - pc modification flag
4515:	1BD9  FEC9    		CP	0C9H
4516:	1BDB  C8      		RET	Z		;unconditional return
4517:	1BDC  3A1B2F  	ZLEN85:	LD	A,(SBPS)	;count of special step breakpoints
4518:	1BDF  A7      		AND	A		;test for zero
4519:	1BE0  C8      		RET	Z		;zero -	monitor	is not tracing
4520:	1BE1  3A1C2F  		LD	A,(BPS)		;fetch number of bps currently in effect
4521:	1BE4  47      		LD	B,A		;pass to set breakpoint	routine	in b reg
4522:	1BE5  EB      		EX	DE,HL		;de - bp to set
4523:	1BE6  CD2813  		CALL	BRK30		;set conditional breakpoint
4524:	1BE9  AF      		XOR	A
4525:	1BEA  B0      		OR	B
4526:	1BEB  0600    		LD	B,0
4527:	1BED  ED5BAF2F		LD	DE,(PCREG)	;for setting inline bp - condition not m
4528:	1BF1  C0      		RET	NZ		;nz - collision	with user bp
4529:	1BF2  211B2F  		LD	HL,SBPS
4530:	1BF5  34      		INC	(HL)		;bump count of step bps
4531:	1BF6  C9      		RET
4533:			;******************************************************************************
4534:			;*
4535:			;*	pswDsp:	display	current	state of flag register
4536:			;*
4537:			;*	pswbit:	table of bit masks with	which to test f	reg.
4538:			;*		two byte entry per bit (sign, zero, carry, parity).
4539:			;*
4540:			;*	pswmap - table of offsets into operand name table featuring a
4541:			;*		 two byte entry	for each flag bit.
4542:			;*		 bit 4 (unused by z80) from pswbit entry is on/off flag
4543:			;*		 lo bytes are the off states (p	nz nc po).
4544:			;*		 hi bytes are the on states  (m	 z  c pe).
4545:			;*
4546:			;*	- current state	of flag	register is displayed
4547:			;*	- user queried for changes
4548:			;*	- input	is parsed and tested for valid flag reg	mnemonics
4549:			;*	- if valid mnemonic found flag bit is set or reset accordingly
4550:			;*
4551:			;*	exit:	to z8e for next	command
4552:			;*
4553:			;******************************************************************************
4554:			
4555:	1BF7  110300  	PSWDSP:	LD	DE,3
4556:	1BFA  0600    		LD	B,0			;+ eg 3.3.5a
4557:	1BFC  21D42E  	PSW00:	LD	HL,PSWBIT		;table of bit mask for flags
4558:	1BFF  19      		ADD	HL,DE			;
4559:	1C00  19      		ADD	HL,DE			;index times two
4560:	1C01  7B      		LD	A,E
4561:	1C02  ED44    		NEG				;now calculate index into pswmap
4562:	1C04  C603    		ADD	A,3
4563:	1C06  87      		ADD	A,A
4564:	1C07  4F      		LD	C,A
4565:	1C08  3A9F2F  		LD	A,(FREG)		;fetch current flag of user
4566:	1C0B  E6F7    		AND	0F7H
4567:	1C0D  A6      		AND	(HL)			;unused	bit in flag - ensure it's off
4568:	1C0E  21DC2E  		LD	HL,PSWMAP
4569:	1C11  09      		ADD	HL,BC			;pointer to mnemonic is	8 bytes	away
4570:	1C12  2801    		JR	Z,PSW10			;this is an off	bit (nz	nc p po)
4571:	1C14  23      		INC	HL			;on
4572:	1C15  4E      	PSW10:	LD	C,(HL)			;fetch index into operand name table
4573:	1C16  213529  		LD	HL,ZOPNM
4574:	1C19  09      		ADD	HL,BC			;two bytes per table entry
4575:	1C1A  09      		ADD	HL,BC
4576:	1C1B  0E02    		LD	C,2			;print both chars of mnemonic name
4577:	1C1D  CDA728  		CALL	PRINTB
4578:	1C20  CD4D26  		CALL	RSPACE
4579:	1C23  1D      		DEC	E			;do all	four flag bits
4580:	1C24  F2FC1B  		JP	P,PSW00
4581:	1C27  CD3B26  		CALL	CRLF
4582:	1C2A  3AE729  		LD	A,(LCMD)
4583:			
4584:			;	cp	'J'			;- eg 3.3.5a
4585:			;	ret	z			;-
4586:	1C2D  FE50    		CP	'P'			;+ Routine can now be called from
4587:	1C2F  C0      		RET	NZ			;+  elsewhere
4588:			
4589:	1C30  CD5226  		CALL	SPACE5
4590:	1C33  CDB227  	PSW50:	CALL	IEDTBC
4591:	1C36  F8      		RET	M			;no input
4592:	1C37  CD561A  	PSW55:	CALL	PRSR
4593:	1C3A  C0      		RET	NZ			;parse error - end command
4594:	1C3B  011601  		LD	BC,116H			;
4595:	1C3E  CD6718  		CALL	OPRN20			;check validity	of this	token
4596:	1C41  79      		LD	A,C
4597:	1C42  010800  		LD	BC,PSWCNT		;number	of flag	reg mnemonics
4598:	1C45  21DC2E  		LD	HL,PSWMAP
4599:	1C48  EDB1    		CPIR				;check table
4600:	1C4A  C2A70D  		JP	NZ,EXXX			;error - nmemonic not found
4601:	1C4D  21D42E  		LD	HL,PSWBIT		;bit mask table
4602:	1C50  09      		ADD	HL,BC
4603:	1C51  7E      		LD	A,(HL)			;fetch mask
4604:	1C52  EB      		EX	DE,HL			;
4605:	1C53  219F2F  		LD	HL,FREG			;de - mask ptr	 hl - user flag	ptr
4606:	1C56  E608    		AND	08			;bit says turn on or off
4607:	1C58  1A      		LD	A,(DE)			;new copy of mask
4608:	1C59  2005    		JR	NZ,PSW60		;nz - turn on
4609:	1C5B  2F      		CPL
4610:	1C5C  A6      		AND	(HL)			;and with current user flag
4611:	1C5D  77      		LD	(HL),A			;return	flag reg with bit now off
4612:	1C5E  18D7    		JR	PSW55			;check for more	input
4613:	1C60  E6F7    	PSW60:	AND	0F7H			;turn off on/off flag (bit 4)
4614:	1C62  B6      		OR	(HL)
4615:	1C63  77      		LD	(HL),A			;now turn on specified bit
4616:	1C64  18D1    		JR	PSW55
4618:			;******************************************************************************
4619:			;*
4620:			;*	movb:	move memory
4621:			;*
4622:			;*	call bcde to fetch destination block address and byte count
4623:			;*	call prsr
4624:			;*	check for head to head or tail to tail move
4625:			;*
4626:			;*	exit: to z8e for next command
4627:			;*
4628:			;******************************************************************************
4629:			
4630:	1C66  CD8425  	MOVB:	CALL	BCDE		;bc - byte count  de - destination  hl - source
4631:	1C69  C2A70D  		JP	NZ,EXXX		;input error ends command
4632:	1C6C  AF      		XOR	A
4633:	1C6D  ED52    		SBC	HL,DE
4634:	1C6F  8F      		ADC	A,A
4635:	1C70  19      		ADD	HL,DE
4636:	1C71  09      		ADD	HL,BC
4637:	1C72  2B      		DEC	HL
4638:	1C73  EB      		EX		DE,HL		;de - address of last byte of source block
4639:	1C74  ED52    		SBC	HL,DE
4640:	1C76  8F      		ADC	A,A
4641:	1C77  19      		ADD	HL,DE		;hl - original destination address
4642:	1C78  EB      		EX	DE,HL
4643:	1C79  FE03    		CP	3
4644:	1C7B  2007    		JR	NZ,MOVB00	;head to head
4645:	1C7D  EB      		EX	DE,HL
4646:	1C7E  09      		ADD	HL,BC
4647:	1C7F  2B      		DEC	HL
4648:	1C80  EB      		EX	DE,HL
4649:	1C81  EDB8    		LDDR
4650:	1C83  C9      		RET
4651:	1C84  23      	MOVB00:	INC	HL
4652:	1C85  A7      		AND	A
4653:	1C86  ED42    		SBC	HL,BC
4654:	1C88  EDB0    		LDIR
4655:	1C8A  C9      		RET
4657:			;******************************************************************************
4658:			;*
4659:			;*	yfil:	fill memory
4660:			;*
4661:			;*	call bcde to get byte count, starting address, and fill byte
4662:			;*
4663:			;*	exit:	to z8e for next	command
4664:			;*
4665:			;******************************************************************************
4666:			
4667:	1C8B  CD8425  	YFIL:	CALL	BCDE		;bc - byte count  de - fill byte  hl - block
4668:	1C8E  C2A70D  		JP	NZ,EXXX		;input error ends command
4669:	1C91  EB      		EX	DE,HL
4670:	1C92  21BF2F  	YFIL00:	LD	HL,ARGBF
4671:	1C95  3ABB2F  		LD	A,(ARGBC)
4672:	1C98  EDA0    	YFIL10:	LDI
4673:	1C9A  04      		INC	B
4674:	1C9B  1003    		DJNZ	YFIL20
4675:	1C9D  0C      		INC	C
4676:	1C9E  0D      		DEC	C
4677:	1C9F  C8      		RET	Z
4678:	1CA0  3D      	YFIL20:	DEC	A
4679:	1CA1  20F5    		JR	NZ,YFIL10
4680:	1CA3  18ED    		JR	YFIL00
4682:			;*********************************************************************
4683:			;
4684:			;	CUSER	Change user routine	EG	5 Jan 88
4685:			;
4686:			;	10 Jan 88	Added check for bad args
4687:			;
4688:			;	Uses '>' as command
4689:			;
4690:			;*********************************************************************
4691:			
4692:	1CA5  CDB227  	CUSER:	CALL 	IEDTBC
4693:	1CA8  F8      		RET		M
4694:	1CA9  CDD426  		CALL		IARG		; gets user in HL as a hex no
4695:	1CAC  C2A70D  		JP		NZ,EXXX		; don't allow bad (would go to user 0)
4696:	1CAF  7C      		LD		A,H
4697:	1CB0  B7      		OR		A
4698:	1CB1  C2A70D  		JP		NZ,EXXX		; 2 - byte user number?
4699:	1CB4  7D      		LD		A,L
4700:	1CB5  FE10    		CP		10H
4701:	1CB7  3807    		JR		C,CUSOK		; you can enter user in hex or decimal with '#'
4702:	1CB9  D606    		SUB		6		; else convert to decimal
4703:	1CBB  FE10    		CP		10H		; see if still too big
4704:	1CBD  D2A70D  		JP	NC,EXXX
4705:	1CC0  0E20    	CUSOK:	LD 	C,32
4706:	1CC2  5F      		LD		E,A
4707:	1CC3  C30500  		JP		BDOS		; change user
4708:			
4709:			;*******************************************************************
4710:			;
4711:			;	QEVAL - expression evaluator	EG 10 Jan 88
4712:			;
4713:			;	Uses '?' as command
4714:			;
4715:			;*******************************************************************
4716:	1CC6  CDB227  	QEVAL: 	CALL 	IEDTBC		; get input
4717:	1CC9  F8      		RET		M		; none
4718:	1CCA  CDD426  		CALL		IARG		; Z8E does all the real work
4719:	1CCD  C2A70D  		JP		NZ,EXXX		; check for valid arg
4720:	1CD0  CD3B26  		CALL		CRLF
4721:	1CD3  7C      		LD		A,H		; see if 1 byte
4722:	1CD4  B7      		OR		A
4723:	1CD5  201E    		JR		NZ,QEV01	; 2-byte number
4724:	1CD7  7D      		LD		A,L
4725:	1CD8  CD6E26  		CALL		OUTHEX		; hex byte
4726:	1CDB  7D      		LD		A,L
4727:	1CDC  FE7F    		CP		7FH		; see if printable
4728:	1CDE  D0      		RET		NC
4729:	1CDF  FE20    		CP		' '
4730:	1CE1  D8      		RET		C
4731:	1CE2  0E03    		LD		C,3
4732:	1CE4  CD5426  		CALL		SPACES		; even up with spaces
4733:	1CE7  3E27    		LD		A,27H		; quote
4734:	1CE9  CDDD25  		CALL		TTYO
4735:	1CEC  7D      		LD		A,L		; show char
4736:	1CED  CDDD25  		CALL		TTYO
4737:	1CF0  3E27    		LD		A,27H
4738:	1CF2  C3DD25  		JP		TTYO
4739:	1CF5  C36426  	QEV01:	JP 	OUTADR		; output 2-byte result
4740:			
4741:			;***********************************************************
4742:			;
4743:			;	GADR - Get program addr data	EG 20 Feb 88
4744:			;
4745:			;	Uses '#' as command
4746:			;
4747:			;	Deleted 5/Jan/89 by jrs - unnecessary as L command
4748:			;	with no file name (now) does the same thing.
4749:			;
4750:			;************************************************************
4751:			;gadr:	ld 	hl,(loadn)
4752:			;	ld 	c,10		; out-of-memory flag
4753:			;	jp 	lbin22
4755:			;------------------------------------------------------------------------------
4756:			;
4757:			;	Initialise default FCB fields and command line	(16 may 87  jrs)
4758:			;
4759:			;	Calls iedtbc to get command tail
4760:			;	      lfcb   twice to extract file names
4761:			;
4762:			;	exit:	FCB name fields at 5Ch and 6Ch initialised
4763:			;		Command tail set up at 80h
4764:			;
4765:			;------------------------------------------------------------------------------
4766:			
4767:	1CF8          	IFCB:				;(Condensed, improved version - jrs 27 Dec 88)
4768:			
4769:	1CF8  CDB227  		CALL	IEDTBC		;Get command tail
4770:	1CFB  2B      		DEC	HL		;Point at input buffer length
4771:	1CFC  E5      		PUSH	HL		;Save input buffer pointer
4772:	1CFD  215C00  		LD	HL,FCB5C	;Zero out the default FCB
4773:	1D00  0620    		LD	B,32
4774:	1D02  3600    	IFCB00:	LD	(HL),0
4775:	1D04  23      		INC	HL
4776:	1D05  10FB    		DJNZ	IFCB00
4777:	1D07  2E5D    		LD	L,FCB5C+1	;Blank out the two file names
4778:	1D09  CD431D  		CALL	IBLANK
4779:	1D0C  2E6D    		LD	L,FCB5C+17
4780:	1D0E  CD431D  		CALL	IBLANK
4781:	1D11  E1      		POP	HL		;Get input buffer pointer
4782:	1D12  118000  		LD	DE,80H		;Destination is command line buffer
4783:	1D15  46      		LD	B,(HL)		;Get input buffer length
4784:	1D16  78      		LD	A,B		;Load length ready to put in command buffer
4785:	1D17  04      		INC	B		;Account for the length byte itself
4786:	1D18          	IFCB02:
4787:	1D18  12      		LD	(DE),A		;Store character in command buffer
4788:	1D19  13      		INC	DE		;Increment pointers
4789:	1D1A  23      		INC	HL
4790:	1D1B  7E      		LD	A,(HL)		;Load character from input buffer
4791:	1D1C  CD3226  		CALL	IXLT		;Translate to upper case
4792:	1D1F  10F7    		DJNZ	IFCB02		;Loop until all copied
4793:	1D21  AF      		XOR	A		;Terminate the command buffer properly
4794:	1D22  12      		LD	(DE),A
4795:	1D23  CD501E  		CALL	LFCB		;Get a file name (if any)
4796:	1D26  200B    		JR	NZ,IFCB12	;Skip if error
4797:	1D28  115C00  		LD	DE,FCB5C	;Copy FCB to default FCB at 5ch
4798:	1D2B  21D92F  		LD	HL,FCB
4799:	1D2E  010C00  		LD	BC,12		;(only move 12 bytes)
4800:	1D31  EDB0    		LDIR
4801:	1D33          	IFCB12:
4802:	1D33  CD501E  		CALL	LFCB		;Do second file name (if any)
4803:	1D36  C0      		RET	NZ		;Exit now if error
4804:	1D37  21D92F  		LD	HL,FCB		;Copy file name part of FCB to
4805:	1D3A  116C00  		LD	DE,FCB5C+16	; second segment of default FCB
4806:	1D3D  010C00  		LD	BC,12
4807:	1D40  EDB0    		LDIR
4808:	1D42  C9      		RET
4809:			
4810:	1D43          	IBLANK:				;Blank out 11 bytes at HL
4811:	1D43  060B    		LD	B,11
4812:	1D45  3620    	IBL00:	LD	(HL),' '
4813:	1D47  23      		INC	HL
4814:	1D48  10FB    		DJNZ	IBL00
4815:	1D4A  C9      		RET
4816:			
4817:			; I originally intended that the following code should be used to expand
4818:			; asterisks in file names but I never invoked it anywhere!  Eventually
4819:			; someone complained and I corrected the omission by adding some code to
4820:			; the LFCB routine.  When I (re)discovered this code I noticed that it was
4821:			; longer than the code added to LFCB so I commented it out.  I am leaving
4822:			; it here because LFCB was never intended to handle ambiguous file names.
4823:			; I don't think there is a problem but should there turn out to be some
4824:			; sort of wierd conflict then it should be easy to activate this little
4825:			; routine.	jrs 27 Dec 88
4826:			;
4827:			;iwild:				;Expand asterisks in file names
4828:			;	ld	bc,8		;Enter with HL pointing at FCB+1
4829:			;	call	iexp		; i.e. first byte of file name.
4830:			;	ld	bc,3
4831:			;;	call	iexp
4832:			;;	ret
4833:			;iexp:
4834:			;	ld	a,'*'
4835:			;	cpir
4836:			;	ret	nz
4837:			;	inc	bc
4838:			;	dec	hl
4839:			;iexp10:
4840:			;	ld	(hl),'?'
4841:			;	inc	hl
4842:			;	dec	c
4843:			;	ret	z
4844:			;	jr	iexp10
4845:			
4846:	1D4B  F5      	DISISR:	PUSH	AF
4847:	1D4C  3EC9    		LD 	A,IRT
4848:	1D4E  323800  		LD	($0038),A
4849:	1D51  F1      		POP	AF
4850:	1D52  C9      		RET
4851:			
4852:	1D53  F5      	ENAISR:	PUSH	AF
4853:	1D54  3EC3    		LD 	A,IJP
4854:	1D56  323800  		LD	($0038),A
4855:	1D59  F1      		POP	AF
4856:	1D5A  C9      		RET
4857:			
4859:			;******************************************************************************
4860:			;*
4861:			;*	lldr:	Load file
4862:			;*	User may supply	optional load bias if file name ends with comma.
4863:			;*
4864:			;*	lfcb:	Parse input buffer (inbf) and init FCB
4865:			;*
4866:			;*		Return:	z  - FCB initialized
4867:			;*			nz - syntax error
4868:			;*
4869:			;*	lopn:	Attempt to open file
4870:			;*
4871:			;*		Return:	nz - file opened
4872:			;*			 z - file not found
4873:			;*
4874:			;*	lmem:	Test if sufficient memory available for loading
4875:			;*
4876:			;*		Return: nc - out of memory
4877:			;*
4878:			;*	lbin: Loader
4879:			;*
4880:			;*		Eof found:     end command
4881:			;*		Out of memory: query user whether to continue
4882:			;*
4883:			;******************************************************************************
4884:			
4885:	1D5B  CD4B1D  	LLDR:	CALL	DISISR
4886:	1D5E  CDB227  		CALL	IEDTBC		;Get file name
4887:	1D61  F2711D  		JP	P,LLDR00     	;P - have input in inbf
4888:	1D64  2A0A2F  		LD	HL,(LOADN)
4889:	1D67  7D      		LD	A,L
4890:	1D68  B4      		OR	H
4891:	1D69  CAA70D  		JP	Z,EXXX
4892:			;	ld	c,a		;-
4893:	1D6C  0E0A    		LD	C,10		;+ 3.5.5 jrs 5/jan/89
4894:	1D6E  C3D51D  		JP	LBIN22
4895:	1D71  CD3B26  	LLDR00:	CALL	CRLF
4896:	1D74  CD501E  		CALL	LFCB		;Init FCB with name and	drive
4897:	1D77  C2DC1E  		JP	NZ,ESNTX	;nz - syntax error
4898:	1D7A  11EC29  		LD	DE,MLDG		;Display loading string
4899:	1D7D  CD9B28  		CALL	NPRINT
4900:	1D80  115530  		LD	DE,PRSBF
4901:	1D83  1A      		LD	A,(DE)		;A - first char	of file	name
4902:	1D84  47      		LD	B,A
4903:	1D85  CD9E28  		CALL	PRINT
4904:	1D88  3E2C    		LD	A,','
4905:	1D8A  B9      		CP	C		;C - terminator	following file name (from lfcb)
4906:	1D8B  210001  		LD	HL,100H		;Assume	no bias
4907:	1D8E  200C    		JR	NZ,LLDR05	;NZ - no comma means no	load bias
4908:	1D90  CDD426  		CALL	IARG		;Check for load	bias
4909:	1D93  C2DC1E  		JP	NZ,ESNTX	;Error - bad argument
4910:	1D96  CDD21E  		CALL	IMEM		;Check available memory
4911:	1D99  D2E11E  		JP	NC,EMEMXX	;Out of	memory
4912:	1D9C  22082F  	LLDR05:	LD	(LOADB),HL	;Save load bias
4913:	1D9F  3E2E    		LD	A,'.'		;Test if file name is period
4914:	1DA1  90      		SUB	B
4915:	1DA2  2809    		JR	Z,LBIN		;File name is period - no open needed
4916:	1DA4  CD4B1D  	LLDR10:	CALL	DISISR
4917:	1DA7  CDB71E  		CALL	LOPN		;Attempt to open file -	entry from nint
4918:	1DAA  CAE91E  		JP	Z,EFILNF	;Z - file not found
4919:			
4920:			
4921:	1DAD          	LBIN:
4922:	1DAD  2A082F  		LD	HL,(LOADB)	;Fetch starting	load address
4923:	1DB0  E5      	LBIN00:	PUSH	HL
4924:	1DB1  EB      		EX	DE,HL
4925:	1DB2  0E1A    		LD	C,26		;Set CP/M DMA address
4926:	1DB4  CD0500  		CALL	BDOS
4927:	1DB7  11D92F  		LD	DE,FCB
4928:	1DBA  0E14    		LD	C,20		;CP/M sequential file read
4929:	1DBC  CD0500  		CALL	BDOS
4930:	1DBF  D1      		POP	DE		;Recover DMA address
4931:	1DC0  218000  		LD	HL,80H
4932:	1DC3  19      		ADD	HL,DE		;Compute next DMA address
4933:	1DC4  32252F  		LD	(CFLAG),A	;Save EOF indicator as continuation flag
4934:	1DC7  4F      		LD	C,A
4935:	1DC8  A7      		AND	A
4936:	1DC9  2005    		JR	NZ,LBIN20	;NZ - end of file
4937:	1DCB  CDD21E  		CALL	IMEM		;Test if memory	available to load next sector
4938:	1DCE  38E0    		JR	C,LBIN00	;C - not out of	memory
4939:	1DD0  EB      	LBIN20:	EX	DE,HL
4940:	1DD1  2B      		DEC	HL
4941:	1DD2  220A2F  		LD	(LOADN),HL	;End of load address
4942:	1DD5  11072A  	LBIN22: LD	DE,MLODM	;Print loaded message
4943:	1DD8  CD9B28  		CALL	NPRINT
4944:	1DDB  EB      		EX	DE,HL		;DE - ending address of	load
4945:	1DDC  2A082F  		LD	HL,(LOADB)
4946:	1DDF  CD6426  		CALL	OUTADR		;Display starting address of load
4947:	1DE2  EB      		EX	DE,HL
4948:	1DE3  CD6426  		CALL	OUTADR		;Display ending	address
4949:	1DE6  A7      		AND	A
4950:	1DE7  ED52    		SBC	HL,DE
4951:	1DE9  24      		INC	H
4952:	1DEA  11112A  		LD	DE,MLODPG
4953:	1DED  CD9B28  		CALL	NPRINT		;Display pages string
4954:	1DF0  6F      		LD	L,A		;zero L	reg
4955:	1DF1  7C      		LD	A,H		;Hi byte of ending address is number of pages
4956:	1DF2  FE64    		CP	100
4957:	1DF4  380E    		JR	C,LBIN30	;Less than 100
4958:	1DF6  2E32    		LD	L,'2'
4959:	1DF8  D6C8    		SUB	200
4960:	1DFA  3003    		JR	NC,LBIN25	;Greater than 200
4961:	1DFC  2D      		DEC	L		;change	to ASCII 1
4962:	1DFD  C664    		ADD	A,100		;Restore actual page count less 100
4963:	1DFF  67      	LBIN25:	LD	H,A		;Save page count
4964:	1E00  7D      		LD	A,L
4965:	1E01  CDDD25  		CALL	TTYO
4966:	1E04  162F    	LBIN30:	LD	D,2FH
4967:	1E06  7C      		LD	A,H
4968:	1E07  14      	LBIN35:	INC	D		;Tens and units	decimal	conversion loop
4969:	1E08  D60A    		SUB	10
4970:	1E0A  30FB    		JR	NC,LBIN35
4971:	1E0C  C60A    		ADD	A,10		;Restore remainder
4972:	1E0E  5F      		LD	E,A		;Temp save while we print tens
4973:	1E0F  7A      		LD	A,D
4974:	1E10  2C      		INC	L
4975:	1E11  2D      		DEC	L		;Test L	reg
4976:	1E12  2002    		JR	NZ,LBIN40	;NZ - ASCII 1 or 2 in L
4977:	1E14  FE30    		CP	'0'		;Suppress leading zero - less than 10 pages
4978:	1E16  C4DD25  	LBIN40:	CALL	NZ,TTYO		;Print tens digit
4979:	1E19  7B      		LD	A,E
4980:	1E1A  F630    		OR	'0'
4981:	1E1C  CDDD25  		CALL	TTYO		;Print units
4982:	1E1F  CD3B26  		CALL	CRLF
4983:			;	xor	a		;- eg 3.3.7a Test eof flag
4984:			;	or	c		;-
4985:	1E22  79      		LD	A,C		;+ Test EOF flag
4986:	1E23  FE0A    		CP	10		;+ Was it set by GADR (see 3.3.11)
4987:	1E25  CA100C  		JP	Z,Z8E		;+ Exit if so
4988:	1E28  B7      		OR	A		;+
4989:			;	jp	nz,z8e		;- nz - true eof means file loading complete
4990:	1E29  201A    		JR	NZ,Z8EJ		;+
4991:	1E2B  112A2A  		LD	DE,MMEMXX	;Print "out of memory" message
4992:	1E2E  CD9E28  		CALL	PRINT
4993:	1E31  11382A  		LD	DE,MCNTU
4994:	1E34  CD9E28  		CALL	PRINT		;Print continue? prompt
4995:	1E37  CDFD25  		CALL	INCHAR
4996:	1E3A  CD3226  		CALL	IXLT		;Make sure its upper case
4997:	1E3D  FE59    		CP	'Y'
4998:	1E3F  CD3B26  		CALL	CRLF
4999:	1E42  CAAD1D  		JP	Z,LBIN		;User wants more loading
5000:	1E45          	Z8EJ:				;+
5001:	1E45  0E1A    		LD	C,26		;+ "Set DMA" function
5002:	1E47  118000  		LD	DE,80H		;+ Restore default DMA for user program
5003:	1E4A  CD0500  		CALL	BDOS		;+
5004:	1E4D  C3100C  		JP	Z8E		;Next command
5005:			
5006:			
5007:	1E50  CD561A  	LFCB:	CALL	PRSR		;parse input buffer to extract file name
5008:	1E53  57      		LD	D,A		;save char which terminated file name
5009:	1E54  3E0E    		LD	A,14
5010:	1E56  B8      		CP	B		;over 14 chars is ng file name
5011:	1E57  D8      		RET	C
5012:	1E58  48      		LD	C,B		;b and c - byte	count of file name
5013:	1E59  100D    		DJNZ	LFCB00		;test for only one char	in name
5014:	1E5B  3A5530  		LD	A,(PRSBF)	;only one - is it period?
5015:	1E5E  D62E    		SUB	'.'
5016:	1E60  2006    		JR	NZ,LFCB00
5017:	1E62  4A      		LD	C,D		;return	terminator
5018:	1E63  3A252F  		LD	A,(CFLAG)	;continuation allowed?
5019:	1E66  A7      		AND	A		;let lldr decide
5020:	1E67  C9      		RET
5021:	1E68  0600    	LFCB00:	LD	B,0
5022:	1E6A  3E3A    		LD	A,':'		;check for drive specifier in input
5023:	1E6C  EDB9    		CPDR
5024:	1E6E  41      		LD	B,C		;b - number of chars preceding colon
5025:	1E6F  4A      		LD	C,D		;return	terminator in c
5026:	1E70  11D92F  		LD	DE,FCB
5027:	1E73  3E00    		LD	A,0
5028:	1E75  200A    		JR	NZ,LFCB10	;nz - no colon
5029:	1E77  05      		DEC	B
5030:	1E78  C0      		RET	NZ		;syntax	error -	more than one char
5031:	1E79  7E      		LD	A,(HL)		;fetch drive specifier
5032:	1E7A  CD3226  		CALL	IXLT
5033:	1E7D  77      		LD	(HL),A		;back to parse buffer as upper case
5034:	1E7E  D640    		SUB	40H		;make name into	number
5035:	1E80  23      		INC	HL
5036:	1E81          	LFCB10:
5037:	1E81  12      	       	LD	(DE),A		;store drive number in fcb
5038:	1E82  3E20    		LD	A,' '
5039:	1E84  060B    		LD	B,11		;clear file name in fcb	to spaces
5040:	1E86  13      	LFCB20:	INC	DE
5041:	1E87  12      		LD	(DE),A
5042:	1E88  10FC    		DJNZ	LFCB20
5043:	1E8A  0608    		LD	B,8		;max chars allowed in file name
5044:	1E8C  11DA2F  		LD	DE,FCBNAM
5045:	1E8F  CD9A1E  	LFCB30:	CALL	LFCB90
5046:	1E92  F8      		RET	M		;error - too many chars	in file	name
5047:	1E93  0603    		LD	B,3		;max chars allowed in file type
5048:	1E95  11E22F  		LD	DE,FCBTYP
5049:	1E98  A7      		AND	A
5050:	1E99  C8      		RET	Z		;z - no	file type after	all
5051:			
5052:			
5053:			
5054:	1E9A  23      	LFCB90:	INC	HL		;Bump buffer pointer
5055:	1E9B  7E      		LD	A,(HL)
5056:	1E9C  A7      		AND	A		;Test for null at end of file name
5057:	1E9D  C8      		RET	Z		;Null found - nothing more to parse
5058:	1E9E  CD3226  		CALL	IXLT
5059:	1EA1  77      		LD	(HL),A		;Translate parse buffer	to upper case
5060:	1EA2  FE2E    		CP	'.'
5061:	1EA4  C8      		RET	Z		;Period	found -	move file type into FCB
5062:			
5063:			; --- Added 4 Dec 88 --- jrs
5064:	1EA5  FE2A    		CP	'*'		;Expandable wildcard?
5065:	1EA7  2806    		JR	Z,LFCB95
5066:			; --- end of added code ---
5067:	1EA9  05      		DEC	B		;Dec max chars allowed
5068:	1EAA  F8      		RET	M		;Error if name or extension is too long
5069:							; or a character follows an asterisk
5070:	1EAB  12      		LD	(DE),A		;Upper case only into FCB
5071:	1EAC  13      		INC	DE
5072:	1EAD  18EB    		JR	LFCB90
5073:			; --- Added 4 Dec 88 --- jrs
5074:	1EAF          	LFCB95:
5075:	1EAF  3E3F    		LD	A,'?'
5076:	1EB1          	LFCB96:
5077:	1EB1  12      		LD	(DE),A
5078:	1EB2  13      		INC	DE
5079:	1EB3  10FC    		DJNZ	LFCB96
5080:	1EB5  18E3    		JR	LFCB90
5081:			; --- end of added code ---
5082:	1EB7          	LOPN:
5083:	1EB7  21DA2F  		LD	HL,FCBNAM	;test for file name present
5084:	1EBA  7E      		LD	A,(HL)
5085:	1EBB  FE20    		CP	' '
5086:	1EBD  C8      		RET	Z		;space found means not file
5087:			;;	dec	hl
5088:			;;	ld	a,(hl)		;drive specifier
5089:			;;	and	a		;test for default drive
5090:			;	jr	z,lopn00	;z - default means no selection	required
5091:			;	dec	a		;select	drive
5092:			;	ld	e,a
5093:			;	ld	c,14
5094:			;	call	bdos
5095:	1EBE  11D92F  	LOPN00:	LD	DE,FCB
5096:	1EC1  0618    		LD	B,NFCB-FCBEXT
5097:	1EC3  21E52F  		LD	HL,FCBEXT	;clear remainder of fcb
5098:	1EC6  3600    	LOPN10:	LD	(HL),0
5099:	1EC8  23      		INC	HL
5100:	1EC9  10FB    		DJNZ	LOPN10
5101:	1ECB  0E0F    		LD	C,15
5102:	1ECD  CD0500  		CALL	BDOS		;tell bdos to open file
5103:	1ED0  3C      		INC	A		;test open return code
5104:	1ED1  C9      		RET			;nz - open ok
5105:			
5106:	1ED2  EB      	IMEM:	EX	DE,HL		;de - next load	address
5107:	1ED3  7A      		LD	A,D
5108:	1ED4  210700  		LD	HL,07		;ptr to	prt to start of	z8e
5109:	1ED7  BE      		CP	(HL)
5110:	1ED8  EB      		EX	DE,HL
5111:	1ED9  D8      		RET	C		;c - not out of memory
5112:	1EDA  EB      		EX	DE,HL
5113:	1EDB  C9      		RET			;de - last address loaded plus one
5114:			
5115:	1EDC  111B2A  	ESNTX:	LD	DE,MSNTX	;print syntax error
5116:	1EDF  180B    		JR	EPRINT
5117:			
5118:	1EE1  112A2A  	EMEMXX:	LD	DE,MMEMXX	;print out of memory
5119:	1EE4  CD9B28  		CALL	NPRINT
5120:	1EE7  1803    		JR	EPRINT
5121:			
5122:	1EE9  11F629  	EFILNF:	LD	DE,MFILNF	;print file not	found
5123:			
5124:	1EEC  CD9B28  	EPRINT:	CALL	NPRINT
5125:	1EEF  C3100C  		JP	Z8E
5127:			;*****************************************************************************
5128:			;*
5129:			;*            write memory segment to disk command
5130:			;*
5131:			;*****************************************************************************
5132:			
5133:	1EF2  CDB227  	WRIT:	CALL	IEDTBC		;fetch line of input
5134:	1EF5  F8      		RET	M		;no input -
5135:	1EF6  CD8D23  		CALL	BLDF		;build fcb with first arg in buffer
5136:	1EF9  20E1    		JR	NZ,ESNTX	;oops - syntax error
5137:	1EFB  3A202F  		LD	A,(DELIM)	;check char that terminated file name
5138:	1EFE  A7      		AND	A
5139:	1EFF  2009    		JR	NZ,WRIT10	;nz - not null means user entered addresses
5140:			
5141:	1F01  ED5B082F		LD	DE,(LOADB)	;use default begin and end address of the last
5142:	1F05  2A0A2F  		LD	HL,(LOADN)	;file loaded
5143:	1F08  1812    		JR	WRIT30
5144:	1F0A  CDD426  	WRIT10:	CALL	IARG		;get address
5145:	1F0D  C2A70D  		JP	NZ,EXXX		;invalid address
5146:	1F10  EB      		EX	DE,HL
5147:	1F11  FE20    		CP	' '		;space terminator
5148:	1F13  C2A70D  		JP	NZ,EXXX		;anything but is error
5149:	1F16  CDD426  	WRIT20:	CALL	IARG		;get end address
5150:	1F19  C2A70D  		JP	NZ,EXXX
5151:	1F1C  22102F  	WRIT30:	LD	(ENDW),HL	;save address of where to end writing
5152:	1F1F  EB      		EX	DE,HL
5153:	1F20  0E03    		LD	C,3
5154:	1F22  CD5426  		CALL	SPACES
5155:	1F25  CD6426  		CALL	OUTADR
5156:	1F28  EB      		EX	DE,HL
5157:	1F29  0E06    		LD	C,6
5158:	1F2B  CD5426  		CALL	SPACES
5159:	1F2E  CD7123  	WRIT40:	CALL	BDWRIT
5160:	1F31  217F00  		LD	HL,127
5161:	1F34  19      		ADD	HL,DE
5162:	1F35  0606    		LD	B,6
5163:	1F37  CD6828  	WRIT50:	CALL	BKSP
5164:	1F3A  10FB    		DJNZ	WRIT50
5165:	1F3C  CD6426  		CALL	OUTADR
5166:	1F3F  23      		INC	HL
5167:	1F40  EB      		EX	DE,HL
5168:	1F41  2A102F  		LD	HL,(ENDW)
5169:	1F44  ED52    		SBC	HL,DE
5170:	1F46  30E6    		JR	NC,WRIT40
5171:	1F48  C35223  		JP	CLOSEF
5172:			
5173:			
5174:			
5175:			;******************************************************************************
5176:			;*
5177:			;*	find:	locate string in memory
5178:			;*
5179:			;*		call iarg - get	starting address of seach
5180:			;*
5181:			;*		call in00 - get	match data concatenating multiple arguments
5182:			;*			    into a single string
5183:			;*
5184:			;*		addresses at which matches found displayed 8 per line.
5185:			;*		search continues until end of memory reached
5186:			;*		user may cancel	search at any time by hitting any key.
5187:			;*
5188:			;*		exit: to z8e for next command
5189:			;*
5190:			;******************************************************************************
5191:			
5192:	1F4B  CDB227  	FIND:	CALL	IEDTBC
5193:	1F4E  F8      		RET	M		;m - no	input
5194:	1F4F  CDD426  		CALL	IARG		;extract starting address of search
5195:	1F52  C2A70D  		JP	NZ,EXXX		;error
5196:	1F55  EB      		EX	DE,HL		;save starting address of search in de
5197:	1F56  CDC226  	FIND00:	CALL	IN00		;extract search	string concatenating multiple
5198:							;arguments
5199:	1F59  C2A70D  		JP	NZ,EXXX		;error - output	command	prompt
5200:	1F5C  AF      		XOR	A
5201:	1F5D  32102F  		LD	(LINES),A	;clear crlf flag
5202:	1F60  EB      		EX	DE,HL		;starting address of search - hl
5203:	1F61  11BF2F  		LD	DE,ARGBF	;argument stored here
5204:			
5205:	1F64  ED4B302F		LD	BC,(FNDSYM)
5206:	1F68  79      		LD	A,C
5207:	1F69  B0      		OR	B		;symbol found?
5208:	1F6A  CA751F  		JP	Z,FIND40	;no
5209:			
5210:	1F6D  EB      		EX	DE,HL		;hl - argument buffer
5211:	1F6E  46      		LD	B,(HL)		;reverse order of the two bytes for symbols
5212:	1F6F  23      		INC	HL
5213:	1F70  7E      		LD	A,(HL)
5214:	1F71  70      		LD	(HL),B
5215:	1F72  2B      		DEC	HL
5216:	1F73  77      		LD	(HL),A
5217:	1F74  EB      		EX	DE,HL
5218:			
5219:	1F75  ED4BBB2F	FIND40:	LD	BC,(ARGBC)	;number	of bytes to look for
5220:	1F79  CD3B26  		CALL	CRLF
5221:	1F7C  CD9D1F  	FIND50:	CALL	SRCH		;do the	search
5222:	1F7F  2015    		JR	NZ,FIND60	;not found
5223:	1F81  CD6426  		CALL	OUTADR		;display address where match found
5224:	1F84  3A102F  		LD	A,(LINES)
5225:	1F87  3D      		DEC	A		;carriage return after 8 addresses displayed
5226:	1F88  32102F  		LD	(LINES),A
5227:	1F8B  E607    		AND	7
5228:	1F8D  CC3B26  		CALL	Z,CRLF
5229:	1F90  CD9D25  		CALL	TTYQ		;user requesting abort?
5230:	1F93  FE0D    		CP	CR
5231:	1F95  C8      		RET	Z		;abort - return	to z8e
5232:	1F96  23      	FIND60:	INC	HL		;point to next address at which	to start search
5233:	1F97  09      		ADD	HL,BC		;ensure	we won't hit end of memory by adding
5234:							;in string size
5235:	1F98  D8      		RET	C		;impending end of memory
5236:	1F99  ED42    		SBC	HL,BC		;restore pointer
5237:	1F9B  18DF    		JR	FIND50
5238:			
5239:	1F9D  C5      	SRCH:	PUSH	BC
5240:	1F9E  D5      		PUSH	DE
5241:	1F9F  E5      		PUSH	HL
5242:	1FA0  1A      	SRCH00:	LD	A,(DE)
5243:	1FA1  EDA1    		CPI
5244:	1FA3  C2AA1F  		JP	NZ,SRCH10	;no match
5245:	1FA6  13      		INC	DE
5246:	1FA7  EAA01F  		JP	PE,SRCH00	;tally not expired - check next
5247:	1FAA  E1      	SRCH10:	POP	HL
5248:	1FAB  D1      		POP	DE
5249:	1FAC  C1      		POP	BC
5250:	1FAD  C9      		RET
5252:			;******************************************************************************
5253:			;*
5254:			;*	verify:	verify two blocks of data are identical
5255:			;*
5256:			;*		enter: de - starting address of	block 1
5257:			;*
5258:			;*		call bcde to get address of block 2 and	byte count
5259:			;*
5260:			;*		mismatch:   block 1 address and	byte are displayed
5261:			;*			    block 2 address and	byte are displayed
5262:			;*			    console intrrogated	- any input terminates verify
5263:			;*
5264:			;*		exit:	to z8e for next	command
5265:			;*
5266:			;******************************************************************************
5267:			
5268:	1FAE  CD8425  	VERIFY:	CALL	BCDE		;get block 2 address and byte count
5269:	1FB1  C2A70D  		JP	NZ,EXXX
5270:	1FB4  EB      		EX	DE,HL
5271:	1FB5  1A      	VERF00:	LD	A,(DE)		;byte from block 1
5272:	1FB6  AE      		XOR	(HL)		;versus	byte from block	two
5273:	1FB7  2817    		JR	Z,VERF10	;match - no display
5274:	1FB9  CD5B26  		CALL	NEWLIN
5275:	1FBC  1A      		LD	A,(DE)
5276:	1FBD  CD4A26  		CALL	OTHXSP		;display block 1 data
5277:	1FC0  CD4D26  		CALL	RSPACE
5278:	1FC3  CD6426  		CALL	OUTADR		;display block two address
5279:	1FC6  7E      		LD	A,(HL)
5280:	1FC7  CD6E26  		CALL	OUTHEX		;display results of xor
5281:	1FCA  CD9D25  		CALL	TTYQ		;check input status
5282:	1FCD  FE0D    		CP	CR
5283:	1FCF  C8      		RET	Z
5284:	1FD0  23      	VERF10:	INC	HL		;bump block 1 pointer
5285:	1FD1  13      		INC	DE		;bump block 2 pointer
5286:	1FD2  0B      		DEC	BC		;dec byte count
5287:	1FD3  78      		LD	A,B
5288:	1FD4  B1      		OR	C
5289:	1FD5  20DE    		JR	NZ,VERF00
5290:	1FD7  C9      		RET
5292:			;******************************************************************************
5293:			;*
5294:			;*	xreg:	display	machine	state
5295:			;*
5296:			;*		regptr:	table contains offsets to names	in operand name	table.
5297:			;*			sign bit set indicates prime register.
5298:			;*
5299:			;*		regmap:	table contains offsets to reg contents table (regcon)
5300:			;*			sign bit ignored (used by rgst command).
5301:			;*
5302:			;*		regcon:	table of register contents.
5303:			;*
5304:			;*		exit:	make current pc	current	disassembly location counter.
5305:			;*			set bit	6 of disassembly flag byte (zasmfb)
5306:			;*			jump to	zasm30 to disassemble current instruction.
5307:			;*
5308:			;******************************************************************************
5309:			
5310:	1FD8  CD4526  	XREG:	CALL	CRET
5311:	1FDB  010000  		LD	BC,0		;init reg index
5312:	1FDE  CD0120  	XREG00:	CALL	XREG05		;display reg name and contents
5313:	1FE1  0C      		INC	C
5314:	1FE2  79      		LD	A,C
5315:	1FE3  FE08    		CP	8
5316:	1FE5  CC3B26  		CALL	Z,CRLF
5317:	1FE8  79      		LD	A,C
5318:	1FE9  FE0C    		CP	0CH
5319:	1FEB  0600    		LD	B,0
5320:	1FED  20EF    		JR	NZ,XREG00
5321:	1FEF  3AE729  		LD	A,(LCMD)
5322:	1FF2  FE4A    		CP	'J'		;animated command in effect?
5323:	1FF4  C8      		RET	Z		;z - no disassembly required
5324:	1FF5  2AAF2F  		LD	HL,(PCREG)
5325:	1FF8  220C2F  		LD	(ZASMPC),HL
5326:			;	jp	zasm30		;- eg 3.3.5b
5327:	1FFB  CDC320  		CALL	ZASM30		;+
5328:	1FFE  C3F71B  		JP	PSWDSP		;+
5329:			
5330:	2001  21F52E  	XREG05:	LD	HL,REGPTR	;map of	reg name pointers
5331:	2004  50      		LD	D,B
5332:	2005  09      		ADD	HL,BC
5333:	2006  7E      		LD	A,(HL)		;extract pointer
5334:	2007  E67F    		AND	7FH		;strip sign for	name indexing
5335:	2009  5F      		LD	E,A
5336:	200A  46      		LD	B,(HL)		;save copy of offset - need sign later
5337:	200B  213529  		LD	HL,ZOPNM	;register name table
5338:	200E  19      		ADD	HL,DE
5339:	200F  19      		ADD	HL,DE		;two bytes per entry
5340:	2010  7E      		LD	A,(HL)
5341:	2011  CDDD25  		CALL	TTYO		;display character one
5342:	2014  23      		INC	HL
5343:	2015  7E      		LD	A,(HL)
5344:	2016  FE20    		CP	' '		;is second character a space?
5345:	2018  2002    		JR	NZ,XREG10
5346:	201A  3E43    		LD	A,'C'		;replace space - this is pc
5347:	201C  CDDD25  	XREG10:	CALL	TTYO		;display second	character
5348:	201F  AF      		XOR	A
5349:	2020  B0      		OR	B		;now test sign
5350:	2021  F22920  		JP	P,XREG20	;sign not set -	not prime reg
5351:	2024  3E27    		LD	A,27H		;display quote
5352:	2026  CDDD25  		CALL	TTYO
5353:	2029  3E3A    	XREG20:	LD	A,':'
5354:	202B  CDDD25  		CALL	TTYO
5355:	202E  21E42E  		LD	HL,REGMAP	;map of	pointers to reg	contents
5356:	2031  19      		ADD	HL,DE
5357:	2032  7E      		LD	A,(HL)
5358:	2033  F23820  		JP	P,XREG30	;p - not prime reg
5359:	2036  C608    		ADD	A,8		;prime contents	8 bytes	past non-prime
5360:	2038  E67F    	XREG30:	AND	7FH		;ignore	sign
5361:	203A  5F      		LD	E,A
5362:	203B  219F2F  		LD	HL,REGCON	;start of register contents storage
5363:	203E  19      		ADD	HL,DE
5364:	203F  56      		LD	D,(HL)		;hi order contents
5365:	2040  2B      		DEC	HL
5366:	2041  5E      		LD	E,(HL)
5367:	2042  EB      		EX	DE,HL
5368:	2043  CD6426  		CALL	OUTADR		;display contents
5369:	2046  C9      		RET
5370:			
5372:			;******************************************************************************
5373:			;*
5374:			;*	zasm
5375:			;*
5376:			;*	the disassembler is divided into two routines:
5377:			;*
5378:			;*	zasm - computes	the instruction	key value and finds the	opcode nmemonic
5379:			;*	opn  - uses the	key value to determine the number of operands and
5380:			;*	       displays	the operands.
5381:			;*
5382:			;*	entered: de - starting address to disassemble
5383:			;*
5384:			;*		zasm maps the 695 z80 instrucions into 256 key values.
5385:			;*              the instruction key value becomes the index into the
5386:			;*              opcode name pointer table (zopcnm), the first operand table
5387:			;*		(zopnd1), and the second operand table (zopnd2).
5388:			;*
5389:			;*		disassembly is done in user specified block sizes if the
5390:			;*		disassembly count evaluates to a number	between	1 and 255. if
5391:			;*		the count is greater than 255 the block	is disassembled	and the
5392:			;*		the command terminates.
5393:			;*
5394:			;*
5395:			;*		zasm15 - start of the disassembly loop
5396:			;*		zasmpc - address of the	instruction being disassembled
5397:			;*		zasmfb - disassembly flag byte
5398:			;*		zmflag - flag indicating directive processing (defb and	defw)
5399:			;*
5400:			;*			    bit	6 - xreg calling
5401:			;*			    bit	5 - asmblr calling
5402:			;*			    bit	0 - write to disk flag
5403:			;*
5404:			;*
5405:			;*
5406:			;******************************************************************************
5407:			
5408:			
5409:	2047          	ZASM:
5410:	2047  CDB227  		CALL	IEDTBC
5411:			
5412:			;	ret	m		;- eg 3.3.2
5413:	204A  F25A20  		JP	P,ZASM0		;+ Skip if arguments supplied, otherwise ...
5414:	204D  0600    		LD	B,0		;+ Signal no file write
5415:	204F  211000  		LD	HL,16		;+ Assume 16 lines of code
5416:	2052  22142F  		LD	(ZASMWT),HL	;+
5417:	2055  22122F  		LD	(ZASMCT),HL	;+
5418:	2058  1824    		JR	ZASM06		;+
5419:	205A          	ZASM0:				;+
5420:	205A  CDD426  		CALL	IARG
5421:	205D  C2A70D  		JP	NZ,EXXX
5422:	2060  EB      		EX	DE,HL
5423:	2061  CDD426  		CALL	IARG		;read in block size
5424:	2064  47      		LD	B,A		;save delimeter
5425:	2065  2803    		JR	Z,ZASM00
5426:	2067  210100  		LD	HL,1		;change	zero count to one
5427:	206A  AF      	ZASM00:	XOR	A
5428:	206B  B4      		OR	H
5429:	206C  2806    		JR	Z,ZASM05
5430:	206E  ED52    		SBC	HL,DE
5431:	2070  DAA70D  		JP	C,EXXX		;error - start address greater than end
5432:	2073  19      		ADD	HL,DE
5433:	2074  22122F  	ZASM05:	LD	(ZASMCT),HL	;save as permanent block count
5434:	2077  22142F  		LD	(ZASMWT),HL	;save as working tally
5435:	207A  EB      		EX	DE,HL		;hl - current instruction pointer
5436:	207B  220C2F  		LD	(ZASMPC),HL
5437:	207E          	ZASM06:				;+ eg 3.3.2
5438:	207E  CD3B26  		CALL	CRLF
5439:	2081  78      		LD	A,B		;check command line delimeter
5440:	2082  32252F  		LD	(DWRITE),A	;save as write to disk flag:
5441:							;z - no write   nz - write
5442:	2085  A7      		AND	A
5443:	2086  C48D23  		CALL	NZ,BLDF		;not end of line - build fcb
5444:	2089  C2DC1E  		JP	NZ,ESNTX
5445:			
5446:	208C  112130  	ZASM08:	LD	DE,ZASMBF	;start of disassembly buffer
5447:			
5448:	208F  ED537529	ZASM10:	LD	(ZASMIO),DE	;init pointer
5449:			
5450:	2093  ED5B0C2F	ZASM15:	LD	DE,(ZASMPC)	;fetch address to disassemble
5451:	2097  CDF31A  		CALL	ZLEN00		;calculate length
5452:	209A  EB      		EX	DE,HL
5453:			
5454:							;loop back here for interactive disassembly -
5455:							;user requests format change. c reg:
5456:							;     6 and 7 off: disassemble as code
5457:							;     6       on:  hex defb
5458:							;     7       on:  hex defw or ascii defb
5459:			
5460:	209B  CD6426  	ZASM18:	CALL	OUTADR		;display instruction address
5461:	209E  111D2F  		LD	DE,ZMFLAG
5462:	20A1  79      		LD	A,C		;save instruction length and format bits
5463:	20A2  12      		LD	(DE),A
5464:	20A3  E63F    		AND	3FH
5465:	20A5  47      		LD	B,A		;b  - length
5466:	20A6  4F      		LD	C,A		;c  - ditto
5467:	20A7  7E      	ZASM20:	LD	A,(HL)
5468:	20A8  CD4A26  		CALL	OTHXSP		;display object	code
5469:	20AB  23      		INC	HL
5470:	20AC  10F9    		DJNZ	ZASM20
5471:	20AE  79      		LD	A,C		;number	of object bytes
5472:	20AF  3D      		DEC	A
5473:	20B0  EE03    		XOR	3
5474:	20B2  47      		LD	B,A		;calculate space padding
5475:	20B3  87      		ADD	A,A
5476:	20B4  80      		ADD	A,B
5477:	20B5  C602    		ADD	A,2
5478:	20B7  47      		LD	B,A
5479:	20B8  CD4D26  	ZASM25:	CALL	RSPACE
5480:	20BB  10FB    		DJNZ	ZASM25
5481:	20BD  22102F  		LD	(ZASMNX),HL	;store address of next instruction
5482:	20C0  A7      		AND	A		;clear carry
5483:	20C1  ED42    		SBC	HL,BC		;point to first	byte in	instruction
5484:	20C3  EB      	ZASM30:	EX	DE,HL		;de - current instruction pointer
5485:	20C4  2A7529  		LD	HL,(ZASMIO)	;buffer	address	storage
5486:	20C7  3A342F  		LD	A,(MAXLIN)
5487:	20CA  47      		LD	B,A		;line length based on max symbol size
5488:	20CB  3620    	ZASM35:	LD	(HL),' '	;space out buffer
5489:	20CD  23      		INC	HL
5490:	20CE  10FB    		DJNZ	ZASM35
5491:	20D0  78      		LD	A,B
5492:	20D1  32162F  		LD	(OPNFLG),A
5493:	20D4  360D    		LD	(HL),CR		;append	crlf
5494:	20D6  23      		INC	HL
5495:	20D7  360A    		LD	(HL),LF
5496:	20D9  CD4B25  		CALL	FADR		;find address match
5497:	20DC  2A7529  		LD	HL,(ZASMIO)
5498:	20DF  2009    		JR	NZ,ZASM40	;nz - no table or not found
5499:	20E1  CD7525  		CALL	XSYM
5500:	20E4  363A    		LD	(HL),':'
5501:	20E6  ED5B0C2F		LD	DE,(ZASMPC)
5502:	20EA  211D2F  	ZASM40:	LD	HL,ZMFLAG	;check interactive disassembly flag
5503:	20ED  7E      		LD	A,(HL)		;sign bit tells all
5504:	20EE  A7      		AND	A
5505:	20EF  F2FC20  		JP	P,ZASM42	;bit off - not interactive
5506:	20F2  066D    		LD	B,6DH		;test for defb
5507:	20F4  D682    		SUB	82H
5508:	20F6  287F    		JR	Z,ZASM90
5509:	20F8  AF      		XOR	A		;must be defw
5510:	20F9  05      		DEC	B
5511:	20FA  187B    		JR	ZASM90
5512:	20FC  1A      	ZASM42:	LD	A,(DE)		;first byte of op code
5513:	20FD  21D02E  		LD	HL,OP1000	;table of z80 specific opcodes
5514:	2100  0E04    		LD	C,4
5515:	2102  EDB1    	ZASM45:	CPIR			;check for fd dd ed or cb
5516:	2104  2818    		JR	Z,ZASM55	;z - found
5517:	2106  FE40    	ZASM50:	CP	40H
5518:	2108  386D    		JR	C,ZASM90	;opcode	range 0	- 3f
5519:	210A  06E0    		LD	B,0E0H		;
5520:	210C  FEC0    		CP	0C0H		;
5521:	210E  3067    		JR	NC,ZASM90	;opcode	range c0 - ff
5522:	2110  FE80    		CP	80H
5523:	2112  305E    		JR	NC,ZASM85	;opcode	range 80 - bf
5524:	2114  06F8    		LD	B,0F8H		;
5525:	2116  FE76    		CP	76H		;test for halt instruction
5526:	2118  2058    		JR	NZ,ZASM85	;opcode	range 40 - 7f
5527:	211A  3EFF    		LD	A,0FFH		;set halt instruction key value	to 0f7h
5528:	211C  1859    		JR	ZASM90
5529:	211E  13      	ZASM55:	INC	DE
5530:	211F  1A      		LD	A,(DE)		;byte two of multi-byte	instruction
5531:	2120  0D      		DEC	C		;test for ed instruction
5532:	2121  2016    		JR	NZ,ZASM65	;nz - not an ed
5533:	2123  FE80    		CP	80H
5534:	2125  3008    		JR	NC,ZASM60	;opcode	range ed 40 - ed 7f
5535:	2127  FE40    		CP	40H
5536:	2129  304C    		JR	NC,ZASM90	;legal
5537:	212B  3E9F    		LD	A,09FH
5538:	212D  1848    		JR	ZASM90		;map to	question marks
5539:	212F  06E0    	ZASM60:	LD	B,0E0H		;set bias
5540:	2131  FEC0    		CP	0C0H		;test for illegal ed
5541:	2133  3842    		JR	C,ZASM90	;legal
5542:	2135  3EBF    		LD	A,0BFH		;map to	question marks
5543:	2137  183E    		JR	ZASM90		;opcode	range ed a0 - ed bb
5544:			
5545:			
5546:	2139  0C      	ZASM65:	INC	C
5547:	213A  2828    		JR	Z,ZASM80	;z - cb	instruction
5548:	213C  FECB    		CP	0CBH		;fd or dd - check for cb in byte two
5549:	213E  200F    		JR	NZ,ZASM70
5550:	2140  13      		INC	DE		;fetch last byte of fdcb or ddcb
5551:	2141  13      		INC	DE
5552:	2142  1A      		LD	A,(DE)
5553:	2143  0F      		RRCA
5554:	2144  381A    		JR	C,ZASM75
5555:	2146  E603    		AND	3
5556:	2148  FE03    		CP	3
5557:	214A  2014    		JR	NZ,ZASM75	;error
5558:	214C  1A      		LD	A,(DE)
5559:	214D  1815    		JR	ZASM80
5560:	214F  3A1D2F  	ZASM70:	LD	A,(ZMFLAG)
5561:	2152  D603    		SUB	3
5562:	2154  1A      		LD	A,(DE)
5563:	2155  20AF    		JR	NZ,ZASM50
5564:	2157  21962A  		LD	HL,Z80F3
5565:	215A  0E18    		LD	C,Z80F3L
5566:	215C  EDB1    		CPIR
5567:	215E  28A6    		JR	Z,ZASM50
5568:	2160  3E9F    	ZASM75:	LD	A,09FH
5569:	2162  1813    		JR	ZASM90
5570:	2164  FE40    	ZASM80:	CP	40H		;test type of cb instruction
5571:	2166  06E8    		LD	B,0E8H
5572:	2168  3808    		JR	C,ZASM85	;opcode	range cb 00 - cb 3f (shift)
5573:	216A  07      		RLCA
5574:	216B  07      		RLCA
5575:	216C  E603    		AND	03		;hi order bits become index
5576:	216E  06F0    		LD	B,0F0H
5577:	2170  1805    		JR	ZASM90		;opcode	range cb 40 - cb ff
5578:	2172  0F      	ZASM85:	RRCA
5579:	2173  0F      		RRCA
5580:	2174  0F      		RRCA			;bits 3-5 of cb	shift yield key
5581:	2175  E607    		AND	07H
5582:	2177  80      	ZASM90:	ADD	A,B		;add in	bias from b reg
5583:	2178  4F      		LD	C,A		;c - instruction key value
5584:	2179  AF      		XOR	A
5585:	217A  47      		LD	B,A
5586:	217B  21B02A  		LD	HL,ZOPCPT	;opcode	name pointer table
5587:	217E  09      		ADD	HL,BC		;index into table
5588:	217F  6E      		LD	L,(HL)		;fetch opname index
5589:	2180  67      		LD	H,A
5590:	2181  29      		ADD	HL,HL
5591:	2182  29      		ADD	HL,HL		;index times four
5592:	2183  11B02D  		LD	DE,ZOPCNM	;op code name table
5593:	2186  19      		ADD	HL,DE
5594:	2187  EB      		EX	DE,HL		;de - pointer to opcode	name
5595:	2188  2A7529  		LD	HL,(ZASMIO)	;buffer	pointer	storage
5596:	218B  79      		LD	A,C
5597:	218C  32262F  		LD	(ZASMKV),A	;opcode key value
5598:	218F  3A322F  		LD	A,(MAXLEN)
5599:	2192  4F      		LD	C,A
5600:	2193  0C      		INC	C		;set label length based on max size
5601:			
5602:	2194  3AE729  		LD	A,(LCMD)	;if xreg use compressed output format
5603:	2197  FE58    		CP	'X'
5604:	2199  2802    		JR	Z,ZASM92
5605:	219B  FE53    		CP	'S'		;step needs compressed format
5606:	219D  09      	ZASM92:	ADD	HL,BC
5607:	219E  0E04    		LD	C,4
5608:	21A0  EB      		EX	DE,HL		;de - buffer   hl - opcode name	pointer
5609:	21A1  EDB0    		LDIR
5610:	21A3  03      		INC	BC		;one space after opcode	for compressed format
5611:	21A4  2802    		JR	Z,ZASM95
5612:	21A6  0E04    		LD	C,4		;four spaces for true disassembly
5613:	21A8  EB      	ZASM95:	EX	DE,HL		;hl - buffer pointer
5614:	21A9  09      		ADD	HL,BC		;start of operand field	in buffer
5615:	21AA  3A262F  		LD	A,(ZASMKV)	;save the instruction key value
5616:	21AD  FE9F    		CP	09FH
5617:	21AF  2018    		JR	NZ,ZASM99
5618:	21B1  ED5B0C2F		LD	DE,(ZASMPC)
5619:	21B5  3A1D2F  		LD	A,(ZMFLAG)
5620:	21B8  47      		LD	B,A
5621:	21B9  1A      	ZASM97:	LD	A,(DE)
5622:	21BA  4A      		LD	C,D
5623:	21BB  CDFD24  		CALL	ZHEX
5624:	21BE  05      		DEC	B
5625:	21BF  CAFE21  		JP	Z,OPN020
5626:	21C2  362C    		LD	(HL),','
5627:	21C4  23      		INC	HL
5628:	21C5  51      		LD	D,C
5629:	21C6  13      		INC	DE
5630:	21C7  18F0    		JR	ZASM97
5631:	21C9  11B02B  	ZASM99:	LD	DE,ZOPND1	;table of first	operands
5632:	21CC  83      		ADD	A,E
5633:	21CD  5F      		LD	E,A		;instant offset
5634:	21CE  7A      		LD	A,D
5635:	21CF  88      		ADC	A,B
5636:	21D0  57      		LD	D,A
5637:	21D1  1A      		LD	A,(DE)
5638:	21D2  3C      		INC	A
5639:	21D3  284F    		JR	Z,OPN040	;no operands
5640:			
5642:			;******************************************************************************
5643:			;*
5644:			;*                          - operand processing -
5645:			;*
5646:			;*	enter:	b - zero (process first	operand)
5647:			;*		c - instruction	key value
5648:			;*
5649:			;*   instruction key value is used to fetch operand key value:
5650:			;*
5651:			;*	operand	key value is in	the range 0 - 1fh
5652:			;*	operand key value interpretted as follows:
5653:			;*
5654:			;*      0 - 17h  use as index to fetch literal from operand
5655:			;*		 name table (sign bit set - parens required)
5656:			;*
5657:			;*     18 - 1fh  operand requires processing - use as index
5658:			;*	         into oprerand jump table which is located
5659:			;*	         immediately after name table
5660:			;*
5661:			;*	   0ffh  no operand
5662:			;*
5663:			;*   operand key value jump table routines: (buffer address in de)
5664:			;*
5665:			;*
5666:			;*   entry point   key         action
5667:			;*
5668:			;*     opn100	   18h	 relative jump
5669:			;*     opn200	   19h	 convert 8 bit operand to hex
5670:			;*     opn300	   1ah	 convert 16 bit	operand	to hex
5671:			;*     opn400	   1ch	 register specified in instruction
5672:			;*     opn600	   1dh	 hl/ix/iy instruction
5673:			;*     opn700	   1eh	 mask rst operand from bit 3-5 of rst instruction
5674:			;*     opn800	   1fh	 bit number is specified in bits 3-5 of	op code
5675:			;*
5676:			;*    exit: to zasm15 to continue block disassembly
5677:			;*
5678:			;******************************************************************************
5679:			
5680:	21D5  3D      	OPN:	DEC	A		;save operand key value
5681:	21D6  F2DC21  		JP	P,OPN010
5682:	21D9  3628    		LD	(HL),'('
5683:	21DB  23      		INC	HL
5684:	21DC  EB      	OPN010:	EX	DE,HL		;de - buffer address
5685:	21DD  47      		LD	B,A
5686:	21DE  87      		ADD	A,A		;operand key value times two
5687:	21DF  213529  	OPN012:	LD	HL,ZOPNM	;base of operand name/jump table
5688:	21E2  85      		ADD	A,L		;index into table
5689:	21E3  6F      		LD	L,A
5690:	21E4  3001    		JR	NC,OPN014
5691:	21E6  24      		INC	H		;account for carry
5692:	21E7  3E1F    	OPN014:	LD	A,1FH
5693:	21E9  A0      		AND	B
5694:	21EA  FE18    		CP	ZOPNML		;test if processing required
5695:	21EC  3805    		JR	C,OPN015	;c - operand is	a fixed	literal
5696:	21EE  7E      		LD	A,(HL)		;fetch processing routine address
5697:	21EF  23      		INC	HL
5698:	21F0  66      		LD	H,(HL)		;
5699:	21F1  6F      		LD	L,A		;hl - operand processing routine
5700:	21F2  E9      		JP	(HL)		;geronimoooooooo
5701:	21F3  EDA0    	OPN015:	LDI			;first byte of operand literal
5702:	21F5  03      		INC	BC		;compensate for	ldi
5703:	21F6  EB      		EX	DE,HL		;hl - buffer
5704:	21F7  1A      		LD	A,(DE)
5705:	21F8  FE20    		CP	' '		;test for space	as byte	two of literal
5706:	21FA  2802    		JR	Z,OPN020	;ignore	spaces appearing in byte two
5707:	21FC  77      		LD	(HL),A
5708:	21FD  23      		INC	HL		;bump buffer pointer
5709:	21FE  78      	OPN020:	LD	A,B		;operand key value
5710:	21FF  FE80    		CP	80H		;test for closed paren required
5711:	2201  3803    		JR	C,OPN030	;c - none required
5712:	2203  3629    		LD	(HL),')'
5713:	2205  23      		INC	HL
5714:	2206  3A162F  	OPN030:	LD	A,(OPNFLG)	;get flag byte
5715:	2209  EEFF    		XOR	0FFH		;toggle operand number
5716:	220B  32162F  		LD	(OPNFLG),A	;
5717:	220E  2814    		JR	Z,OPN040	;z - just finished number two
5718:	2210  3A262F  		LD	A,(ZASMKV)	;get op code key value
5719:	2213  11B02C  		LD	DE,ZOPND2	;index into operand2 table
5720:	2216  83      		ADD	A,E
5721:	2217  5F      		LD	E,A
5722:	2218  3001    		JR	NC,OPN035
5723:	221A  14      		INC	D
5724:	221B  1A      	OPN035:	LD	A,(DE)		;get operand2 key value
5725:	221C  3C      		INC	A
5726:	221D  2805    		JR	Z,OPN040	;z - no	second operand
5727:	221F  362C    		LD	(HL),','	;separate operands with comma in buffer
5728:	2221  23      		INC	HL
5729:	2222  18B1    		JR	OPN
5730:	2224  2A7529  	OPN040:	LD	HL,(ZASMIO)	;rewind	buffer pointer
5731:	2227  3A342F  		LD	A,(MAXLIN)
5732:	222A  4F      		LD	C,A
5733:	222B          	OPN041:
5734:	222B  3A382F  		LD	A,(CASE)
5735:	222E  A7      		AND	A
5736:	222F  280C    		JR	Z,OPN043	;Upper case requested - no need to convert
5737:							;reg names [ras 19 Sep 85]
5738:	2231  7E      	OPN042:	LD	A,(HL)
5739:	2232  A7      		AND	A		;if sign bit on then no case conversion
5740:	2233  F42926  		CALL	P,ILCS
5741:	2236  E67F    		AND	7FH		;in case we fell thru
5742:	2238  77      		LD	(HL),A
5743:	2239  23      		INC	HL
5744:	223A  0D      		DEC	C
5745:	223B  20F4    		JR	NZ,OPN042
5746:	223D          	OPN043:				;correct jmp from opn041 4-9-85
5747:	223D  3A342F  		LD	A,(MAXLIN)
5748:	2240  FE1E    		CP	30
5749:	2242  2802    		JR	Z,OPN044
5750:	2244  3E2C    		LD	A,44		;allow 16 comment chars
5751:	2246          	OPN044:
5752:	2246  4F      		LD	C,A		;number of chars to print (omit crlf)
5753:	2247  2A7529  		LD	HL,(ZASMIO)
5754:	224A  3AE729  		LD	A,(LCMD)
5755:	224D  FE4A    		CP	'J'		;j command
5756:	224F  C8      		RET	Z		;end of the line for full screen animation
5757:	2250  CDA728  		CALL	PRINTB		;print buffer
5758:	2253  23      		INC	HL		;point past crlf to next 32 byte group
5759:	2254  23      		INC	HL
5760:	2255  EB      		EX	DE,HL
5761:	2256  3AE729  		LD	A,(LCMD)	;jettison all commands except z
5762:	2259  FE58    		CP	'X'
5763:	225B  CA3B26  		JP	Z,CRLF
5764:	225E  FE41    		CP	'A'
5765:	2260  CA3B26  		JP	Z,CRLF
5766:	2263  FE53    		CP	'S'
5767:	2265  CA3B26  		JP	Z,CRLF
5768:	2268  AF      		XOR	A
5769:	2269  321E2F  		LD	(ZASMF),A
5770:	226C  2A122F  		LD	HL,(ZASMCT)	;check disassembly count
5771:	226F  2B      		DEC	HL
5772:	2270  7C      		LD	A,H
5773:	2271  B5      		OR	L		;test for count expired
5774:	2272  C2F022  		JP	NZ,OPN060	;nz - this is not a count of one so this is not
5775:							;interactive disassebly
5776:			
5777:	2275  CDBD25  		CALL	TTYI		;check input command letter for interactive
5778:	2278  CD3226  		CALL	IXLT		;force upper case
5779:	227B  321E2F  		LD	(ZASMF),A
5780:	227E  FE43    		CP	'C'		;code?
5781:	2280  CC4526  		CALL	Z,CRET		;if user wants code return cursor to start of
5782:							;line and disassemble again
5783:	2283  CA9320  		JP	Z,ZASM15
5784:	2286  0E82    		LD	C,82H		;assume defw
5785:	2288  FE44    		CP	'D'
5786:	228A  280B    		JR	Z,OPN045	;defw -	082h
5787:	228C  0D      		DEC	C		;assume ascii defb
5788:	228D  FE41    		CP	'A'
5789:	228F  2806    		JR	Z,OPN045	;ascii defb - 081h
5790:	2291  FE42    		CP	'B'
5791:	2293  200B    		JR	NZ,OPN046	;none of the above
5792:	2295  0EC1    		LD	C,0C1H		;hex defb - 0c1h
5793:	2297  CD4526  	OPN045:	CALL	CRET
5794:	229A  2A0C2F  		LD	HL,(ZASMPC)
5795:	229D  C39B20  		JP	ZASM18
5796:			
5797:							;zasmf - 0 means this is block disassembly
5798:							;      - nz means char entered during
5799:			          			;        interactive mode was not c d a or b.
5800:			
5801:	22A0  FE3B    	OPN046:	CP	';'		;check if user wants to insert comments
5802:	22A2  204C    		JR	NZ,OPN060	;nz - user does not want to add comment
5803:			
5804:	22A4  CDDD25  		CALL	TTYO		;echo semicolon
5805:	22A7  1B      		DEC	DE
5806:	22A8  1B      		DEC	DE		;point to carriage return
5807:	22A9  3E20    		LD	A,' '
5808:	22AB  12      		LD	(DE),A		;clear crlf from buffer
5809:	22AC  13      		INC	DE
5810:	22AD  12      		LD	(DE),A
5811:	22AE  13      		INC	DE
5812:	22AF  CD5A23  		CALL	WRITE		;end of buffer - write if required
5813:	22B2  061D    		LD	B,29
5814:	22B4  3A342F  		LD	A,(MAXLIN)
5815:	22B7  D61E    		SUB	30
5816:	22B9  CAC022  		JP	Z,OPN048
5817:	22BC  1B      		DEC	DE
5818:	22BD  0610    		LD	B,16
5819:	22BF  AF      		XOR	A
5820:	22C0  4F      	OPN048:	LD	C,A
5821:	22C1  C5      		PUSH	BC
5822:	22C2  D5      		PUSH	DE		;save disassembly buffer pointer
5823:	22C3  57      		LD	D,A
5824:	22C4  CDCD27  		CALL	IEDT03
5825:	22C7  D1      		POP	DE
5826:	22C8  C1      		POP	BC
5827:	22C9  78      		LD	A,B		;recover max size of comment
5828:	22CA  2B      		DEC	HL
5829:	22CB  46      		LD	B,(HL)		;number actually entered
5830:	22CC  90      		SUB	B
5831:	22CD  4F      		LD	C,A		;trailing spaces
5832:	22CE  23      		INC	HL
5833:	22CF  EB      		EX	DE,HL		;de - input buffer   hl - disassembly buffer
5834:	22D0  363B    		LD	(HL),';'
5835:	22D2  23      		INC	HL
5836:	22D3  05      	OPN049:	DEC	B		;pre-test count
5837:	22D4  FADD22  		JP	M,OPN050
5838:	22D7  1A      		LD	A,(DE)		;first char of input
5839:	22D8  13      		INC	DE
5840:	22D9  77      		LD	(HL),A		;into disassembly buffer
5841:	22DA  23      		INC	HL
5842:	22DB  18F6    		JR	OPN049
5843:	22DD  0D      	OPN050:	DEC	C
5844:	22DE  FAE622  		JP	M,OPN055
5845:	22E1  3620    		LD	(HL),' '
5846:	22E3  23      		INC	HL
5847:	22E4  18F7    		JR	OPN050
5848:	22E6  360D    	OPN055:	LD	(HL),CR
5849:	22E8  23      		INC	HL
5850:	22E9  360A    		LD	(HL),LF
5851:	22EB  23      		INC	HL
5852:	22EC  EB      		EX	DE,HL
5853:	22ED  C30023  		JP	OPN065
5854:			
5855:	22F0          	OPN060:
5856:	22F0  3A342F  		LD	A,(MAXLIN)
5857:	22F3  FE1E    		CP	30		;test for 6 chars in label
5858:	22F5  CA0023  		JP	Z,OPN065	;z - buffer point ok
5859:	22F8  3E12    		LD	A,64-46		;bump buffer pointer to next 64 byte chunk
5860:	22FA  83      		ADD	A,E
5861:	22FB  5F      		LD	E,A
5862:	22FC  D20023  		JP	NC,OPN065
5863:	22FF  14      		INC	D
5864:			
5865:	2300  CD5A23  	OPN065:	CALL	WRITE		;check if write to disk flag in effect
5866:			
5867:	2303  CD3B26  		CALL	CRLF
5868:	2306  ED537529		LD	(ZASMIO),DE	;save new buffer pointer
5869:	230A  2A142F  		LD	HL,(ZASMWT)	;check disassembly count
5870:	230D  AF      		XOR	A
5871:	230E  B4      		OR	H		;less than 256?
5872:	230F  280B    		JR	Z,OPN080	;less -	this is	tally
5873:	2311  ED4B102F		LD	BC,(ZASMNX)	;fetch next disassembly	address
5874:	2315  ED42    		SBC	HL,BC		;versus	requested end address
5875:	2317  382B    		JR	C,OPN095	;c - end
5876:	2319  09      		ADD	HL,BC		;restore next disassembly address
5877:	231A  1815    		JR	OPN085		;more
5878:	231C  2B      	OPN080:	DEC	HL
5879:	231D  7C      		LD	A,H
5880:	231E  B5      		OR	L
5881:	231F  2010    		JR	NZ,OPN085	;nz - more
5882:	2321  2A122F  		LD	HL,(ZASMCT)	;fetch permanent block size
5883:	2324  3A1E2F  		LD	A,(ZASMF)
5884:	2327  A7      		AND	A
5885:	2328  CCBD25  		CALL	Z,TTYI		;query user - more?
5886:	232B  FE0D    		CP	CR		;return	means end
5887:	232D  2815    		JR	Z,OPN095
5888:	232F  1807    		JR	OPN090
5889:	2331          	OPN085:
5890:	2331  CD9D25  		CALL	TTYQ
5891:	2334  FE0D    		CP	CR
5892:	2336  280C    		JR	Z,OPN095	;nz - terminate	disassembly
5893:	2338          	OPN090:
5894:	2338  22142F  		LD	(ZASMWT),HL	;restore count
5895:	233B  2A102F  		LD	HL,(ZASMNX)	;next instruction pointer
5896:	233E  220C2F  		LD	(ZASMPC),HL	;make current
5897:	2341  C39320  		JP	ZASM15		;disassemble next instruction
5898:			
5899:	2344  3A252F  	OPN095:	LD	A,(DWRITE)	;writing to disk?
5900:	2347  A7      		AND	A
5901:	2348  C8      		RET	Z
5902:	2349  3E1A    		LD	A,EOF		;
5903:	234B  12      		LD	(DE),A		;set eof
5904:	234C  112130  		LD	DE,ZASMBF
5905:	234F  CD5A23  		CALL	WRITE
5906:			
5907:			
5908:			
5909:	2352  11D92F  	CLOSEF:	LD	DE,FCB		;close file
5910:	2355  0E10    		LD	C,16
5911:	2357  C30500  		JP	BDOS
5912:			
5913:			
5914:			
5915:	235A  C5      	WRITE:	PUSH	BC
5916:	235B  E5      		PUSH	HL
5917:	235C  21A130  		LD	HL,NZASM	;address of end of disassembly buffer
5918:	235F  A7      		AND	A
5919:	2360  ED52    		SBC	HL,DE
5920:	2362  200A    		JR	NZ,WRT10	;not end of buffer
5921:	2364  112130  		LD	DE,ZASMBF	;need to rewind buffer pointer
5922:	2367  3A252F  		LD	A,(DWRITE)	;test write to disk flag
5923:	236A  A7      		AND	A
5924:	236B  C47123  		CALL	NZ,BDWRIT	;nz - writing to disk
5925:	236E  E1      	WRT10:	POP	HL
5926:	236F  C1      		POP	BC
5927:	2370  C9      		RET
5928:			
5929:			
5930:			
5931:	2371  C5      	BDWRIT:	PUSH	BC		;bdos write routine
5932:	2372  D5      		PUSH	DE
5933:	2373  E5      		PUSH	HL
5934:	2374  0E1A    		LD	C,26		;set dma address
5935:	2376  CD0500  		CALL	BDOS
5936:	2379  11D92F  		LD	DE,FCB
5937:	237C  0E15    		LD	C,21
5938:	237E  CD0500  		CALL	BDOS		;write buffer
5939:							;+ eg 3.3.7b
5940:	2381  0E1A    		LD	C,26		;+ "Set DMA" function
5941:	2383  118000  		LD	DE,80H		;+ Restore default DMA for user program
5942:	2386  CD0500  		CALL	BDOS		;+
5943:	2389  E1      		POP	HL
5944:	238A  D1      		POP	DE
5945:	238B  C1      		POP	BC
5946:	238C  C9      		RET
5947:			
5948:			
5949:			
5950:	238D  CD501E  	BLDF:	CALL	LFCB		;initialize fcb
5951:	2390  C0      		RET	NZ		;error - invalid file name
5952:	2391  CDB71E  		CALL	LOPN
5953:	2394  2808    		JR	Z,BLDF00	;no file - create one
5954:	2396  11D92F  		LD	DE,FCB
5955:	2399  0E13    		LD	C,19		;file exists - delete it
5956:	239B  CD0500  		CALL	BDOS
5957:	239E  11D92F  	BLDF00:	LD	DE,FCB		;create	new file
5958:	23A1  0E16    		LD	C,22
5959:	23A3  CD0500  		CALL	BDOS		;if no file create one
5960:	23A6  AF      		XOR	A
5961:	23A7  C9      		RET
5962:			
5964:			
5965:	23A8  2A0C2F  	OPN100:	LD	HL,(ZASMPC)
5966:	23AB  23      		INC	HL
5967:	23AC  7E      		LD	A,(HL)		;fetch relative	displacement
5968:	23AD  4F      		LD	C,A
5969:	23AE  0C      		INC	C
5970:	23AF  87      		ADD	A,A		;test sign for displacement direction
5971:	23B0  0600    		LD	B,0
5972:	23B2  3001    		JR	NC,OPN105
5973:	23B4  05      		DEC	B		;produce zero for forward - ff for back
5974:	23B5  09      	OPN105:	ADD	HL,BC		;adjust	pc
5975:	23B6  EB      		EX	DE,HL		;de - instruction ptr	hl - buffer
5976:	23B7  CD4B25  		CALL	FADR
5977:	23BA  CC7525  		CALL	Z,XSYM
5978:	23BD  CA2422  		JP	Z,OPN040	;symbol	found
5979:			;	ld	(hl),'$'	;- eg 3.3.4a
5980:			;	inc	hl		;-
5981:			;	ld	a,c		;-
5982:			;	inc	a		;-
5983:	23C0  0600    		LD	B,0
5984:			;	cp	82h		;-
5985:			;	jp	opn610		;- convert displacement to ascii
5986:	23C2  C32424  		JP	OPN316		;+
5987:			
5988:	23C5  CD2525  	OPN200:	CALL	ZMQF		;check for interactive disassembly
5989:	23C8  300C    		JR	NC,OPN205	;sign off - not interactive
5990:	23CA  87      		ADD	A,A		;shift out bit 6
5991:	23CB  7E      		LD	A,(HL)
5992:	23CC  3826    		JR	C,OPN215	;on - must be hex defb
5993:	23CE  CD3025  		CALL	ZASCII		;user wants ascii - check validity
5994:	23D1  2021    		JR	NZ,OPN215	;nz - untable to convert to ascii
5995:	23D3  C3FE21  		JP	OPN020
5996:	23D6  CDE424  	OPN205:	CALL	ZNDX		;check for ix or iy instruction
5997:	23D9  EB      		EX	DE,HL		;buffer back to de
5998:	23DA  2002    		JR	NZ,OPN210	;nz - not ix or	iy
5999:	23DC  23      		INC	HL
6000:	23DD  23      		INC	HL		;must be  ld (ix+ind),nn
6001:	23DE  23      	OPN210:	INC	HL		;
6002:	23DF  7E      		LD	A,(HL)		;fetch object byte
6003:	23E0  2812    		JR	Z,OPN215	;no conversion of ix and iy displacements
6004:							;to ascii
6005:	23E2  3A262F  		LD	A,(ZASMKV)	;check for in or out instruction
6006:	23E5  FEB3    		CP	0B3H
6007:	23E7  280B    		JR	Z,OPN215	;no conversion of port addresses to ascii
6008:	23E9  FEBB    		CP	0BBH
6009:	23EB  2807    		JR	Z,OPN215
6010:	23ED  7E      		LD	A,(HL)
6011:	23EE  CD3025  		CALL	ZASCII
6012:	23F1  CAFE21  		JP	Z,OPN020
6013:	23F4  EB      	OPN215:	EX	DE,HL
6014:	23F5  1A      		LD	A,(DE)
6015:	23F6  FE0A    		CP	10		;decimal number?
6016:	23F8  3006    		JR	NC,OPN220	;no - convert to hex
6017:	23FA  CD1A25  		CALL	ZHEX20		;86 the	leading	zero and trailing h
6018:	23FD  C3FE21  		JP	OPN020
6019:	2400  CDFD24  	OPN220:	CALL	ZHEX		;do hex	to asii	conversion
6020:	2403  3648    		LD	(HL),'H'	;following 8 bit hex byte
6021:	2405  23      		INC	HL
6022:	2406  C3FE21  		JP	OPN020
6023:			
6024:	2409  CD2525  	OPN300:	CALL	ZMQF
6025:	240C  3808    		JR	C,OPN315	;c - this is defw
6026:	240E  CDE424  		CALL	ZNDX
6027:	2411  EB      		EX	DE,HL		;de - buffer   hl - instruction	pointer
6028:	2412  2001    		JR	NZ,OPN310	;nz - not ix or	iy
6029:	2414  23      		INC	HL
6030:	2415  23      	OPN310:	INC	HL
6031:	2416  7E      	OPN315:	LD	A,(HL)		;fetch lo order	16 bit operand
6032:	2417  23      		INC	HL
6033:	2418  66      		LD	H,(HL)		;hi order
6034:	2419  6F      		LD	L,A
6035:	241A  EB      		EX	DE,HL		;de - 16 bit operand   hl - buffer
6036:	241B  CD4B25  		CALL	FADR
6037:	241E  CC7525  		CALL	Z,XSYM
6038:	2421  CAFE21  		JP	Z,OPN020	;symbol	found
6039:	2424          	OPN316:				;+ eg 3.3.4b
6040:	2424  7A      		LD	A,D		;convert hi order to hex
6041:	2425  4F      		LD	C,A		;save spare copy
6042:	2426  CDFD24  		CALL	ZHEX
6043:	2429  7B      		LD	A,E
6044:	242A  57      		LD	D,A
6045:	242B  CD0B25  		CALL	ZHEX10
6046:	242E  AF      		XOR	A
6047:	242F  B1      		OR	C
6048:	2430  2006    		JR	NZ,OPN320
6049:	2432  7A      		LD	A,D
6050:	2433  FE0A    		CP	10
6051:	2435  DAFE21  		JP	C,OPN020
6052:	2438  3668    	OPN320:	LD	(HL),'h'
6053:	243A  23      		INC	HL
6054:	243B  C3FE21  		JP	OPN020
6055:			
6056:	243E          	OPN400:
6057:	243E  CDE424  		CALL	ZNDX
6058:	2441  2008    		JR	NZ,OPN410	;nz - not ix or	iy instruction
6059:	2443  13      		INC	DE
6060:	2444  1A      		LD	A,(DE)
6061:	2445  FECB    		CP	0CBH		;check for indexed bit instruction
6062:	2447  2002    		JR	NZ,OPN410
6063:	2449  13      		INC	DE		;byte of interest is number four
6064:	244A  13      		INC	DE
6065:	244B  3E01    	OPN410:	LD	A,01		;check low bit of operand key value
6066:	244D  A0      		AND	B
6067:	244E  1A      		LD	A,(DE)		;fetch op code
6068:	244F  2003    		JR	NZ,OPN500	;nz - index 01bh
6069:	2451  1F      		RRA			;register specified in bits 0-5
6070:	2452  1F      		RRA
6071:	2453  1F      		RRA
6072:	2454  E607    	OPN500:	AND	007		;register specified in bits 0-2
6073:	2456  EE06    		XOR	006		;from the movie	of the same name
6074:	2458  C2DC21  		JP	NZ,OPN010	;nz - not hl or	ix or iy
6075:	245B  3A0C2F  		LD	A,(ZASMPC)
6076:	245E  AB      		XOR	E		;test if pc was	incremented
6077:	245F  3628    		LD	(HL),'('	;set leading paren
6078:	2461  23      		INC	HL
6079:	2462  0680    		LD	B,080H		;set sign bit -	closed paren required
6080:	2464  EB      		EX	DE,HL		;de - buffer
6081:	2465  CADF21  		JP	Z,OPN012
6082:			
6083:			
6084:			
6085:	2468          	OPN600:
6086:	2468  CDE424  		CALL	ZNDX		;determine if ix or iy
6087:	246B  2806    		JR	Z,OPN605	;z - must be ix	of iy
6088:	246D  3E80    		LD	A,80H
6089:	246F  A0      		AND	B
6090:	2470  C3DC21  		JP	OPN010
6091:	2473          	OPN605:
6092:							;+Fix display of IX/IY when upper case is set
6093:	2473  F5      		PUSH	AF		;+Adapted from patch by George Havach (3.5.7)
6094:	2474  0EDF    		LD	C,0DFH		;+Upper case mask
6095:	2476  3A382F  		LD	A,(CASE)	;+See if upper or lower case
6096:	2479  B7      		OR	A		;+
6097:	247A  2802    		JR	Z,OPN606	;+Skip if upper case, otherwise
6098:	247C  0EFF    		LD	C,0FFH		;+ adjust mask
6099:	247E          	OPN606:				;+
6100:	247E  3E69    		LD	A,'i'		;+First character
6101:	2480  A1      		AND	C		;+Select case
6102:			;	ld	(hl),'i'	;-Set first character
6103:	2481  77      		LD	(HL),A		;+Set first character
6104:	2482  23      		INC	HL
6105:	2483  F1      		POP	AF		;+Second character
6106:	2484  CE78    		ADC	A,'x'		;Carry determines x or y (from zndx)
6107:	2486  A1      		AND	C		;+Select case
6108:	2487  77      		LD	(HL),A
6109:	2488  23      		INC	HL
6110:	2489  3E80    		LD	A,80H		;Test for parens
6111:	248B  A0      		AND	B
6112:	248C  CA0622  		JP	Z,OPN030	;z - not indexed instruction
6113:	248F  13      		INC	DE
6114:	2490  1A      		LD	A,(DE)		;fetch second byte of instruction
6115:	2491  FEE9    		CP	0E9H		;test for jp (ix) or jp	(iy)
6116:	2493  CAFE21  		JP	Z,OPN020	;output	closed paren
6117:	2496  13      		INC	DE
6118:	2497  1A      		LD	A,(DE)		;fetch displacement byte
6119:	2498  FE80    		CP	80H		;test sign
6120:	249A  362B    	OPN610:	LD	(HL),'+'	;assume	forward
6121:	249C  3804    		JR	C,OPN620	;c - forward
6122:	249E  ED44    		NEG			;force positive
6123:	24A0  362D    		LD	(HL),'-'
6124:	24A2  23      	OPN620:	INC	HL		;bump buffer pointer
6125:	24A3  E67F    		AND	7FH		;strip sign
6126:	24A5  CDFD24  		CALL	ZHEX		;convert to hex
6127:	24A8  3E09    		LD	A,9
6128:	24AA  BA      		CP	D
6129:	24AB  D2FE21  		JP	NC,OPN020
6130:	24AE  3668    		LD	(HL),'h'
6131:	24B0  23      		INC	HL
6132:	24B1  C3FE21  		JP	OPN020		;output	closed paren
6133:			
6134:			
6135:			
6136:			
6137:	24B4  2A0C2F  	OPN700:	LD	HL,(ZASMPC)
6138:	24B7  7E      		LD	A,(HL)		;fetch restart instruction
6139:	24B8  EB      		EX	DE,HL		;de - buffer   hl instruction pointer
6140:	24B9  E638    		AND	38H
6141:	24BB  CDFD24  		CALL	ZHEX		;convert restart number	to ascii
6142:	24BE  3648    		LD	(HL),'H'
6143:	24C0  C3FE21  		JP	OPN020
6144:			
6145:			
6146:			
6147:	24C3  CDE424  	OPN800:	CALL	ZNDX
6148:	24C6  2006    		JR	NZ,OPN810	;nz - not ddcb or fdcb instruction
6149:	24C8  13      		INC	DE
6150:	24C9  13      		INC	DE
6151:	24CA  13      		INC	DE		;
6152:	24CB  1A      		LD	A,(DE)		;byte 4	of ix or iy bit	instruction
6153:	24CC  180B    		JR	OPN820
6154:	24CE  FE10    	OPN810:	CP	10H		;weed out interrupt mode instructions
6155:	24D0  1A      		LD	A,(DE)		;second	byte of	instruction regardless
6156:	24D1  2006    		JR	NZ,OPN820	;nz - cb bit instruction
6157:	24D3  EE46    		XOR	046H		;
6158:	24D5  2807    		JR	Z,OPN830	;z - interrupt mode zero
6159:	24D7  D608    		SUB	8
6160:	24D9  1F      	OPN820:	RRA
6161:	24DA  1F      		RRA
6162:	24DB  1F      		RRA
6163:	24DC  E607    		AND	07		;leave only bit	number
6164:	24DE  CD1A25  	OPN830:	CALL	ZHEX20		;convert to ascii
6165:	24E1  C30622  		JP	OPN030
6167:			;******************************************************************************
6168:			;*
6169:			;*		     disassembler utility subroutines
6170:			;*
6171:			;*	zndx:	  determines if	fd dd ed or cb instruction
6172:			;*		  caller uses returned values on an individual basis
6173:			;*
6174:			;*		   z  -	dd fd
6175:			;*		  nz  -	neither	of the above
6176:			;*		  current instruction pointer bumped if	cb or ed instruction
6177:			;*
6178:			;*	zhex:	  convert to byte in the accumulator to ascii with leading zero
6179:			;*		  store	in buffer
6180:			;*		  d - reg destroyed
6181:			;*
6182:			;*	zhex10:	  no leading zero permitted
6183:			;*	zhex20:	  convert lo order nibble only
6184:			;*
6185:			;******************************************************************************
6186:			
6187:	24E4  2A0C2F  	ZNDX:	LD	HL,(ZASMPC)	;fetch current instruction pointer
6188:	24E7  EB      		EX	DE,HL		;de - instruction pointer   hl - buffer
6189:	24E8  1A      		LD	A,(DE)
6190:			;	ADD	A,-0FDH		;iy check
6191:	24E9  C603    		ADD	A,$03		;iy check
6192:	24EB  C8      		RET	Z
6193:	24EC  D6E0    		SUB	0DDH-0FDH	;ix check
6194:	24EE  C8      		RET	Z
6195:	24EF  FE10    		CP	10H		;ed check
6196:	24F1  2805    		JR	Z,ZNDX00
6197:	24F3  FEEE    		CP	0EEH		;cb check
6198:	24F5  3E00    		LD	A,0		;clear
6199:	24F7  C0      		RET	NZ
6200:	24F8  13      	ZNDX00:	INC	DE		;cb or ed - bump instruction pointer
6201:	24F9  2F      		CPL
6202:	24FA  A7      		AND	A		;ensure	nz set
6203:	24FB  2F      		CPL
6204:	24FC  C9      		RET
6205:			
6206:			
6207:			
6208:	24FD  57      	ZHEX:	LD	D,A
6209:	24FE  FEA0    		CP	0A0H		;test byte to convert
6210:	2500  3805    		JR	C,ZHEX00	;starts	with decimal digit - 86	the lead zero
6211:	2502  3630    		LD	(HL),'0'
6212:	2504  23      		INC	HL
6213:	2505  1804    		JR	ZHEX10
6214:	2507  FE0A    	ZHEX00:	CP	10
6215:	2509  380F    		JR	C,ZHEX20
6216:	250B  0F      	ZHEX10:	RRCA
6217:	250C  0F      		RRCA
6218:	250D  0F      		RRCA
6219:	250E  0F      		RRCA
6220:	250F  E60F    		AND	0FH
6221:	2511  C690    		ADD	A,90H
6222:	2513  27      		DAA
6223:	2514  CE40    		ADC	A,40H
6224:	2516  27      		DAA			;a - ascii digit
6225:	2517  77      		LD	(HL),A
6226:	2518  23      		INC	HL
6227:	2519  7A      		LD	A,D		;lo nibble conversion
6228:	251A  E60F    	ZHEX20:	AND	0FH
6229:	251C  C690    		ADD	A,90H
6230:	251E  27      		DAA
6231:	251F  CE40    		ADC	A,40H
6232:	2521  27      		DAA
6233:	2522  77      		LD	(HL),A
6234:	2523  23      		INC	HL
6235:	2524  C9      		RET
6236:			
6237:			
6238:			
6239:	2525  211D2F  	ZMQF:	LD	HL,ZMFLAG	;check interactive disassembly flag
6240:	2528  7E      		LD	A,(HL)
6241:	2529  3600    		LD	(HL),0		;clear regardless
6242:	252B  2A0C2F  		LD	HL,(ZASMPC)	;fetch current disassembly address
6243:	252E  87      		ADD	A,A		;check sign - on means interactive
6244:	252F  C9      		RET
6245:			
6246:			
6247:	2530  FE20    	ZASCII:	CP	' '
6248:	2532  D8      		RET	C
6249:	2533  A7      		AND	A
6250:	2534  F8      		RET	M
6251:	2535  FE7F    		CP	7FH		;rubout?
6252:	2537  2804    		JR	Z,ZASC10
6253:	2539  FE27    		CP	QUOTE
6254:	253B  2002    		JR	NZ,ZASC20
6255:	253D  A7      	ZASC10:	AND	A		;set nz - conversion not done
6256:	253E  C9      		RET
6257:	253F  EB      	ZASC20:	EX	DE,HL
6258:	2540  3627    		LD	(HL),QUOTE	;defb -	quoted character
6259:	2542  23      		INC	HL
6260:	2543  F680    		OR	80H		;hi bit on - no case conversion for this guy
6261:	2545  77      		LD	(HL),A
6262:	2546  23      		INC	HL
6263:	2547  3627    		LD	(HL),QUOTE
6264:	2549  BF      		CP	A
6265:	254A  C9      		RET
6266:			
6267:			
6268:			
6269:	254B  C5      	FADR:	PUSH	BC
6270:	254C  E5      		PUSH	HL
6271:	254D  2A0600  		LD	HL,(06)		;fetch top of tpa - start of symbol table
6272:	2550  ED4B322F		LD	BC,(MAXLEN)
6273:	2554  09      		ADD	HL,BC		;point to start of symbol name
6274:	2555  23      		INC	HL
6275:	2556  7E      	FADR00:	LD	A,(HL)		;first byte of symbol name
6276:	2557  3D      		DEC	A		;check validity
6277:	2558  FA7225  		JP	M,FADR30	;end of	table
6278:	255B  09      		ADD	HL,BC
6279:	255C  7E      		LD	A,(HL)		;fetch hi order	address	from table
6280:	255D  BA      		CP	D
6281:	255E  C26825  		JP	NZ,FADR10
6282:	2561  2B      		DEC	HL
6283:	2562  7E      		LD	A,(HL)
6284:	2563  23      		INC	HL
6285:	2564  BB      		CP	E
6286:	2565  CA6C25  		JP	Z,FADR20
6287:	2568  23      	FADR10:	INC	HL
6288:	2569  C35625  		JP	FADR00
6289:	256C  EB      	FADR20:	EX	DE,HL		;return pointer in de
6290:	256D  79      		LD	A,C
6291:	256E  2F      		CPL
6292:	256F  A3      		AND	E
6293:	2570  5F      		LD	E,A
6294:	2571  AF      		XOR	A
6295:	2572  E1      	FADR30:	POP	HL
6296:	2573  C1      		POP	BC
6297:	2574  C9      		RET
6298:			
6299:	2575          	XSYM:
6300:	2575  3A322F  		LD	A,(MAXLEN)
6301:	2578  3D      		DEC	A
6302:	2579  4F      		LD	C,A
6303:	257A  1A      	XSYM00:	LD	A,(DE)
6304:	257B  A7      		AND	A
6305:	257C  C8      		RET	Z
6306:	257D  77      		LD	(HL),A
6307:	257E  23      		INC	HL
6308:	257F  13      		INC	DE
6309:	2580  0D      		DEC	C
6310:	2581  20F7    		JR	NZ,XSYM00
6311:	2583  C9      		RET
6313:			;******************************************************************************
6314:			;*
6315:			;*	bcde:  query user for 3	arguments: source address
6316:			;*					   destination address
6317:			;*					   byte	count
6318:			;*
6319:			;*	       used by move, verify, and yfil routines
6320:			;*
6321:			;*	       return: bc - byte count
6322:			;*		       de - destination
6323:			;*		       hl - source pointer
6324:			;*			z - no errors
6325:			;*
6326:			;*		       nz - no input entered
6327:			;*			  - untable to evaluate argument
6328:			;*			  - destination	address	< source
6329:			;*
6330:			;******************************************************************************
6331:			
6332:	2584  CDB227  	BCDE:	CALL	IEDTBC
6333:	2587  F8      		RET	M		;no input is treated as	error
6334:	2588  CDD426  		CALL	IARG		;read in starting block	address
6335:	258B  C0      		RET	NZ
6336:	258C  EB      		EX	DE,HL
6337:	258D  CDD426  		CALL	IARG
6338:	2590  C0      		RET	NZ
6339:	2591  ED52    		SBC	HL,DE		;end - start = byte count - 1
6340:	2593  D8      		RET	C
6341:	2594  44      		LD	B,H
6342:	2595  4D      		LD	C,L
6343:	2596  03      		INC	BC
6344:	2597  CDC226  		CALL	IN00		;read in destination block address
6345:	259A  C0      		RET	NZ
6346:	259B  EB      		EX	DE,HL		;set regs right
6347:	259C  C9      		RET
6348:			
6350:			;******************************************************************************
6351:			;*
6352:			;*			   console i/o routines
6353:			;*
6354:			;*   "physical"	i/o routines: ttyi - keyboard input
6355:			;*			      ttyo - console output
6356:			;*			      ttyq - console status
6357:			;*
6358:			;*   logical input routines:  inchar - input character processing
6359:			;*				       control characters echoed with ^
6360:			;*
6361:			;*   logical output routines: crlf   - output carriage return/line feed
6362:			;*			      cret   - output carriage return only
6363:			;*			     space   - output space
6364:			;*			    spaces   - output number of	spaces in passed in c
6365:			;*			    outhex   - output hex byte in a
6366:			;*			    othxsp   - output hex byte in a followed by	space
6367:			;*			    outadr   - output 16 bit hex value in hl followed
6368:			;*				       by space	- hl preserved
6369:			;*			     print   - output string - address in de
6370:			;*				       string terminated by null
6371:			;*			    printb   - output string - address in hl
6372:			;*						       byte count in c
6373:			;*						       end at first null
6374:			;*
6375:			;******************************************************************************
6376:	0000          	IF STLONE
6381:			ELSE
6382:	0000          	    IF	ASMB
6384:			    ELSE
6385:	259D          	TTYQ:
6386:			    ENDIF
6387:	259D  C5      		PUSH	BC
6388:	259E  D5      		PUSH	DE
6389:	259F  E5      		PUSH	HL
6390:	25A0  0E0B    		LD	C,11
6391:	25A2  CD0500  		CALL	BDOS
6392:	25A5  A7      		AND	A
6393:	25A6  0E06    		LD	C,6
6394:	25A8  1EFF    		LD	E,0FFH
6395:	25AA  C40500  		CALL	NZ,BDOS
6396:	25AD  E1      		POP	HL
6397:	25AE  D1      		POP	DE
6398:	25AF  C1      		POP	BC
6399:	25B0  E67F    		AND	7FH
6400:	25B2  C9      		RET
6401:			ENDIF
6402:			
6403:	FFFF          	    IF NOT COMPACT
6404:	25BD          		ORG	TTYQ+32
6405:			    ENDIF
6406:			
6407:	0000          	IF STLONE
6417:			ELSE
6418:	0000          	    IF	ASMB
6420:			    ELSE
6421:	25BD          	TTYI:
6422:			    ENDIF
6423:	25BD  C5      		PUSH	BC
6424:	25BE  D5      		PUSH	DE
6425:	25BF  E5      		PUSH	HL
6426:	0000          	    IF	ASMB
6428:			    ELSE
6429:	25C0          	TTYI00:
6430:			    ENDIF
6431:	25C0  0E06    		LD	C,6
6432:	25C2  1EFF    		LD	E,0FFH
6433:	25C4  CD0500  		CALL	BDOS
6434:	25C7  E67F    		AND	7FH
6435:	25C9  28F5    		JR	Z,TTYI00
6436:	25CB  E1      		POP	HL
6437:	25CC  D1      		POP	DE
6438:	25CD  C1      		POP	BC
6439:	25CE  C9      		RET
6440:			ENDIF
6441:			
6442:	FFFF          	    IF NOT COMPACT
6443:	25DD          		ORG	TTYI+32
6444:			    ENDIF
6445:			
6446:	0000          	IF STLONE
6453:			ELSE
6454:	0000          	    IF	ASMB
6456:			    ELSE
6457:	25DD          	TTYO:
6458:			    ENDIF
6459:	25DD  F5      		PUSH	AF
6460:	25DE  C5      		PUSH	BC
6461:	25DF  D5      		PUSH	DE
6462:	25E0  E5      		PUSH	HL
6463:	25E1          	TTYO00:
6464:	25E1  E67F    		AND	7FH		;+ eg 3.3.1 (but this instruction will be
6465:							;	     patched during initialisation
6466:							;	     according to value stored at
6467:							;	     coMask: [3.4])
6468:	25E3  5F      		LD	E,A
6469:	0000          		IF	JTERM		;My terminal uses tab as cursor position
6471:				ELSE			;the tab to a string of spaces.
6472:	25E4  0E02    		LD	C,2
6473:				ENDIF
6474:	25E6  CD0500  		CALL	BDOS
6475:	25E9  E1      		POP	HL
6476:	25EA  D1      		POP	DE
6477:	25EB  C1      		POP	BC
6478:	25EC  F1      		POP	AF
6479:	25ED  C9      		RET
6480:			ENDIF
6481:			
6482:	FFFF          	    IF NOT COMPACT
6483:	25FD          		ORG	TTYO+32
6484:			    ENDIF
6485:			
6486:	25FD  CDBD25  	INCHAR:	CALL	TTYI
6487:	2600  FE03    		CP	CTLC
6488:	2602  2822    		JR	Z,EXICPM
6489:	2604  FE0D    		CP	CR
6490:	2606  C8      		RET	Z
6491:	2607  FE09    		CP	TAB
6492:	2609  C8      		RET	Z
6493:	260A  FE0A    		CP	LF
6494:	260C  C8      		RET	Z
6495:	260D  FE08    		CP	BS
6496:	260F  C8      		RET	Z
6497:	2610  FE18    		CP	CTLX
6498:	2612  C8      		RET	Z
6499:	2613  FE20    		CP	' '
6500:	2615  30C6    		JR	NC,TTYO
6501:	2617  F5      		PUSH	AF
6502:	2618  3E5E    		LD	A,'^'
6503:	261A  CDDD25  		CALL	TTYO
6504:	261D  F1      		POP	AF
6505:	261E  EE40    		XOR	40H
6506:	2620  CDDD25  		CALL	TTYO
6507:	2623  EE40    		XOR	40H
6508:	2625  C9      		RET
6509:			
6510:	2626          	EXICPM:
6511:			; 	EI			; renable interrupts
6512:			; 	CALL	GENAIN		; unlock monitor to enable ints
6513:	2626  C30000  		JP	$0000
6514:			
6515:	2629  FE41    	ILCS:	CP	'A'
6516:	262B  D8      		RET	C
6517:	262C  FE5B    		CP	'Z'+1
6518:	262E  D0      		RET	NC
6519:	262F  F620    		OR	20H
6520:	2631  C9      		RET
6521:			
6522:			
6523:			
6524:	2632  FE61    	IXLT:	CP	'a'
6525:	2634  D8      		RET	C
6526:	2635  FE7B    		CP	'z'+1
6527:	2637  D0      		RET	NC
6528:	2638  D620    		SUB	20H
6529:	263A  C9      		RET
6530:			
6532:	263B  3E0D    	CRLF:	LD	A,CR
6533:	263D  CDDD25  		CALL	TTYO
6534:	2640  3E0A    		LD	A,LF
6535:	2642  C3DD25  		JP	TTYO
6536:			
6537:	2645  3E0D    	CRET:	LD	A,CR
6538:	2647  C3DD25  		JP	TTYO
6539:			
6540:	264A  CD6E26  	OTHXSP:	CALL	OUTHEX
6541:			
6542:	264D  3E20    	RSPACE:	LD	A,' '
6543:	264F  C3DD25  		JP	TTYO
6544:			
6545:	2652  0E05    	SPACE5:	LD	C,5
6546:			
6547:	2654  CD4D26  	SPACES:	CALL	RSPACE
6548:	2657  0D      		DEC	C
6549:	2658  20FA    		JR	NZ,SPACES
6550:	265A  C9      		RET
6551:			
6552:			
6553:			
6554:	265B  CD3B26  	NEWLIN:	CALL	CRLF
6555:	265E  EB      		EX	DE,HL
6556:	265F  CD6426  		CALL	OUTADR
6557:	2662  EB      		EX	DE,HL
6558:	2663  C9      		RET
6559:			
6560:			
6561:	2664  7C      	OUTADR:	LD	A,H
6562:	2665  CD6E26  		CALL	OUTHEX
6563:	2668  7D      		LD	A,L
6564:	2669  CD4A26  		CALL	OTHXSP
6565:	266C  18DF    		JR	RSPACE
6566:			
6567:			
6568:			
6569:	266E  F5      	OUTHEX:	PUSH	AF
6570:	266F  CD7C26  		CALL	BINX
6571:	2672  CDDD25  		CALL	TTYO
6572:	2675  F1      		POP	AF
6573:	2676  CD8026  		CALL	BINX00
6574:	2679  C3DD25  		JP	TTYO
6575:			
6576:			
6577:			
6578:	267C  0F      	BINX:	RRCA
6579:	267D  0F      		RRCA
6580:	267E  0F      		RRCA
6581:	267F  0F      		RRCA
6582:	2680  E60F    	BINX00:	AND	0FH
6583:	2682  C690    		ADD	A,90H
6584:	2684  27      		DAA
6585:	2685  CE40    		ADC	A,40H
6586:	2687  27      		DAA
6587:	2688  C9      		RET
6589:	2689  C5      	ILIN:	PUSH	BC
6590:	268A  D5      		PUSH	DE
6591:	268B  0652    		LD	B,INBFSZ
6592:	268D  0E00    		LD	C,0
6593:	268F  CDBE26  		CALL	RTIN
6594:	2692  D1      		POP	DE
6595:	2693  C1      		POP	BC
6596:	2694  C9      		RET
6597:			
6598:			
6599:	2695  C5      	ISTR:	PUSH	BC
6600:	2696  D5      		PUSH	DE
6601:	2697  0601    		LD	B,1
6602:	2699  0E20    		LD	C,' '
6603:	269B  CDB927  		CALL	IEDT
6604:	269E  D1      		POP	DE
6605:	269F  C1      		POP	BC
6606:	26A0  C9      		RET
6607:			
6608:			
6609:							;resume input after reading in one char
6610:			
6611:	26A1  C5      	IRSM:	PUSH	BC
6612:	26A2  D5      		PUSH	DE
6613:	26A3  0651    		LD	B,INBFSZ-1	;max input size less one char already read in
6614:	26A5  0E20    		LD	C,' '		;this is terminator char
6615:	26A7  1601    		LD	D,1		;preset byte count
6616:	26A9  7A      		LD	A,D
6617:	26AA  32282F  		LD	(STRNGF),A	;set nz - this is string function
6618:	26AD  210430  		LD	HL,INBF+1	;init buffer pointer
6619:	26B0  CDD327  		CALL	IEDT05
6620:	26B3  AF      		XOR	A
6621:	26B4  32282F  		LD	(STRNGF),A	;this is no longer string function
6622:	26B7  B2      		OR	D
6623:	26B8  F4C226  		CALL	P,IN00
6624:	26BB  D1      		POP	DE
6625:	26BC  C1      		POP	BC
6626:	26BD  C9      		RET
6627:			
6628:			
6629:			
6630:	26BE  CDB927  	RTIN:	CALL	IEDT
6631:	26C1  F8      		RET	M
6632:	26C2  AF      	IN00:	XOR	A
6633:	26C3  32BB2F  		LD	(ARGBC),A
6634:	26C6  21BF2F  		LD	HL,ARGBF
6635:	26C9  22BD2F  		LD	(ARGBPT),HL
6636:	26CC  CDD426  	IN10:	CALL	IARG
6637:	26CF  C0      		RET	NZ
6638:	26D0  A7      		AND	A
6639:	26D1  20F9    		JR	NZ,IN10
6640:	26D3  C9      		RET
6641:			
6642:			
6643:			
6644:	26D4  C5      	IARG:	PUSH	BC
6645:	26D5  D5      		PUSH	DE
6646:	26D6  CDDF26  		CALL	PARG
6647:	26D9  3A202F  		LD	A,(DELIM)
6648:	26DC  D1      		POP	DE
6649:	26DD  C1      		POP	BC
6650:	26DE  C9      		RET
6652:	26DF  CD561A  	PARG:	CALL	PRSR		;extract next argument
6653:	26E2  C0      		RET	NZ		;parse error
6654:	26E3  3A172F  		LD	A,(QUOFLG)	;test for ascii	literal
6655:	26E6  A7      		AND	A
6656:	26E7  2834    		JR	Z,PARG10	;quote character not found
6657:	26E9  AF      		XOR	A
6658:	26EA  B0      		OR	B		;test for balanced quotes
6659:	26EB  F8      		RET	M		;error - unbalanced quotes
6660:	26EC  1A      		LD	A,(DE)		;first character of parse buffer
6661:	26ED  D627    		SUB	QUOTE
6662:	26EF  2035    		JR	NZ,PARG50	;invalid literal string but may be expression
6663:							;involving a literal
6664:	26F1  68      		LD	L,B		;l - character count of	parse buffer
6665:	26F2  67      		LD	H,A		;clear
6666:	26F3  19      		ADD	HL,DE		;
6667:	26F4  2B      		DEC	HL		;hl - pointer to last char in parse buffer
6668:	26F5  7E      		LD	A,(HL)		;
6669:	26F6  D627    		SUB	QUOTE		;ensure	literal	string ends with quote
6670:	26F8  202C    		JR		NZ,PARG50
6671:	26FA  77      		LD	(HL),A		;clear trailing quote
6672:	26FB  48      		LD	C,B		;c - character count of	parse buffer
6673:	26FC  47      		LD	B,A		;clear
6674:	26FD  0D      		DEC	C		;subtract the quote characters from the	count
6675:	26FE  0D      		DEC	C
6676:	26FF  0D      		DEC	C		;extra dec set error flag nz for '' string
6677:	2700  F8      		RET	M		;inform	caller of null string
6678:	2701  0C      		INC	C		;c - actual string length
6679:	2702  79      		LD	A,C		;spare copy
6680:	2703  13      		INC	DE		;point to second character of parse buffer
6681:	2704  2ABD2F  		LD	HL,(ARGBPT)	;caller	wants evaluated	arg stored here
6682:	2707  EB      		EX	DE,HL
6683:	2708  EDB0    		LDIR
6684:	270A  EB      		EX	DE,HL
6685:	270B  2B      		DEC	HL
6686:	270C  5E      		LD	E,(HL)
6687:	270D  2B      		DEC	HL
6688:	270E  56      		LD	D,(HL)
6689:	270F  23      		INC	HL
6690:	2710  23      		INC	HL		;point to where to store next arg
6691:	2711  3D      		DEC	A		;argument length 1?
6692:	2712  2001    		JR	NZ,PARG00
6693:	2714  57      		LD	D,A
6694:	2715  4F      	PARG00:	LD	C,A
6695:	2716  0C      		INC	C		;account for increment
6696:	2717  3ABB2F  		LD	A,(ARGBC)	;fetch current argument byte counter
6697:	271A  81      		ADD	A,C
6698:	271B  183C    		JR	PARG90
6699:	271D  CD4E12  	PARG10:	CALL	MREG		;check for register specified
6700:	2720  2004    		JR	NZ,PARG50	;nz - invalid register name
6701:	2722  79      		LD	A,C
6702:	2723  87      		ADD	A,A
6703:	2724  380D    		JR	C,PARG60	;sign bit reset	- 16 bit register pair
6704:	2726  210000  	PARG50:	LD	HL,00
6705:	2729  45      		LD	B,L
6706:	272A  115530  		LD	DE,PRSBF	;reinit	starting address of parse buffer
6707:	272D  CDEF18  		CALL	XVAL
6708:	2730  2816    		JR	Z,PARG70
6709:	2732  C9      		RET
6710:	2733  7E      	PARG60:	LD	A,(HL)
6711:	2734  2B      		DEC	HL
6712:	2735  6E      		LD	L,(HL)
6713:	2736  67      		LD	H,A
6714:	2737  3A5530  		LD	A,(PRSBF)	;check paren flag for indirection
6715:	273A  A7      		AND	A
6716:	273B  2005    		JR	NZ,PARG65	;nz - parens not removed
6717:	273D  13      		INC	DE		;bump past trailing null
6718:	273E  7E      		LD	A,(HL)
6719:	273F  23      		INC	HL
6720:	2740  66      		LD	H,(HL)
6721:	2741  6F      		LD	L,A
6722:	2742  0680    	PARG65:	LD	B,80H
6723:	2744  CDEF18  		CALL	XVAL
6724:	2747  C0      		RET	NZ
6725:	2748  EB      	PARG70:	EX	DE,HL
6726:	2749  2ABD2F  		LD	HL,(ARGBPT)
6727:	274C  3ABB2F  		LD	A,(ARGBC)
6728:	274F  14      		INC	D
6729:	2750  15      		DEC	D
6730:	2751  2803    		JR	Z,PARG80
6731:	2753  72      		LD	(HL),D
6732:	2754  23      		INC	HL
6733:	2755  3C      		INC	A
6734:	2756  73      	PARG80:	LD	(HL),E
6735:	2757  23      		INC	HL
6736:	2758  3C      		INC	A
6737:	2759  32BB2F  	PARG90:	LD	(ARGBC),A
6738:	275C  22BD2F  		LD	(ARGBPT),HL
6739:	275F  EB      		EX	DE,HL
6740:	2760  AF      		XOR	A
6741:	2761  C9      		RET
6743:	2762  47      	OUTBYT:	LD	B,A		;save spare copy
6744:	2763  CD4A26  		CALL	OTHXSP		;hex - display
6745:	2766  CD4D26  		CALL	RSPACE
6746:	2769  78      		LD	A,B		;display byte in ascii
6747:	276A  CD7328  		CALL	ASCI		;display ascii equivalent
6748:	276D  0E03    		LD	C,3
6749:	276F  C35426  		JP	SPACES		;solicit input three spaces right
6750:			
6751:	2772  CD9526  	RBYTE:	CALL	ISTR
6752:	2775  3A0230  		LD	A,(INBFNC)	;number	of chars in input buffer
6753:	2778  3D      		DEC	A		;test for input	buffer count of	zero
6754:	2779  13      		INC	DE		;assume	zero - examine next
6755:	277A  F8      		RET	M		;no input means examine next
6756:	277B  1B      		DEC	DE		;incorrect assumption
6757:	277C  3A0330  		LD	A,(INBF)	;check first char of input buffer
6758:	277F  FE2E    		CP	'.'
6759:	2781  C8      		RET	Z		;period	ends command
6760:	2782  FE3D    		CP	'='		;new address?
6761:	2784  2014    		JR	NZ,BYTE10
6762:	2786  AF      		XOR	A		;clear equal sign so prsr ignores it
6763:	2787  320330  		LD	(INBF),A
6764:	278A  CDA126  		CALL	IRSM		;fetch new address to examine
6765:	278D  201D    		JR	NZ,BYTE30	;error
6766:	278F  3A0230  		LD	A,(INBFNC)
6767:	2792  D602    		SUB	2
6768:	2794  3816    		JR	C,BYTE30	;c - error - equal sign was only char of input
6769:	2796  EB      		EX	DE,HL		;return new address in de
6770:	2797  37      		SCF			;ensure nz set for caller - no replacement data
6771:							;was entered
6772:	2798  9F      		SBC	A,A
6773:	2799  C9      		RET
6774:	279A  FE5E    	BYTE10:	CP	'^'		;
6775:	279C  2004    		JR	NZ,BYTE15	;nz - not up arrow means need more input
6776:	279E  1B      		DEC	DE		;dec current memory pointer
6777:	279F  37      		SCF	 		;set nz - no replacement data entered
6778:	27A0  9F      		SBC	A,A
6779:	27A1  C9      		RET
6780:	27A2  CDA126  	BYTE15:	CALL	IRSM		;resume	input from console
6781:	27A5  C8      		RET	Z		;no errors on input
6782:	27A6  3A0230  		LD	A,(INBFNC)	;check number of chars input
6783:	27A9  A7      		AND	A
6784:	27AA  28C6    		JR	Z,RBYTE		;none - user hit control x or backspaced to
6785:							;beginning of buffer
6786:	27AC  CDA70D  	BYTE30:	CALL	EXXX
6787:	27AF  37      		SCF
6788:	27B0  9F      		SBC	A,A		;set nz - no replacement
6789:	27B1  C9      		RET
6791:			;******************************************************************************
6792:			;*
6793:			;*	bdos function 10 replacement to	make romming this program easier since
6794:			;*	only two console i/o routines (ttyi and	ttyo) are required. this
6795:			;*	routine	supports backspace, line delete, and tab expansion.
6796:			;*
6797:			;*	all input stored in input buffer inbf.
6798:			;*
6799:			;*
6800:			;*	iedtbc:	solicit	console	for new	input and initialize b and c registers
6801:			;*		for max	size and input and no special line terminator.
6802:			;*
6803:			;*
6804:			;*	iedt:	solicit	console	for new	input using non-default	byte count for
6805:			;*		buffer or non-standard terminator.
6806:			;*
6807:			;*		called:	 b - max number	of characters to receive
6808:			;*			 c - special terminator	other than carriage return
6809:			;*
6810:			;*
6811:			;*	iedt00:	resume input - used by routines	which call iedt	with a buffer
6812:			;*		count of 1 to check for	special	character as the first char
6813:			;*		received (such as exam looking for period).
6814:			;*
6815:			;*		called:	 b - max number	of characters to receive
6816:			;*			 c - special terminator	other than carriage return
6817:			;*
6818:			;******************************************************************************
6819:			
6820:			
6821:	27B2  0652    	IEDTBC:	LD	B,INBFSZ
6822:	27B4  AF      		XOR	A
6823:	27B5  4F      		LD	C,A
6824:	27B6  32282F  		LD	(STRNGF),A
6825:	27B9  AF      	IEDT:	XOR	A
6826:	27BA  1652    		LD	D,INBFSZ
6827:	27BC  210330  		LD	HL,INBF
6828:	27BF  77      	IEDT00:	LD	(HL),A
6829:	27C0  23      		INC	HL
6830:	27C1  15      		DEC	D
6831:	27C2  20FB    		JR	NZ,IEDT00
6832:	27C4  32BB2F  		LD	(ARGBC),A	;init number of	arguments tally
6833:	27C7  21BF2F  		LD	HL,ARGBF
6834:	27CA  22BD2F  		LD	(ARGBPT),HL	;init pointer to start of buffer
6835:	27CD  210330  	IEDT03:	LD	HL,INBF		;start of input	buffer
6836:	27D0  32172F  		LD	(QUOFLG),A
6837:	27D3  CDFD25  	IEDT05:	CALL	INCHAR		;read char from	console
6838:	27D6  322B2F  		LD	(TRMNTR),A	;assume line terminator until proven otherwise
6839:	27D9  FE0D    		CP	CR		;end of	line?
6840:	27DB  CA6128  		JP	Z,IEDT90	;z - end (jr changed to jp:  eg 3.3.8a)
6841:	27DE  5F      		LD	E,A
6842:	27DF  FE27    		CP	QUOTE
6843:	27E1  3A172F  		LD	A,(QUOFLG)
6844:	27E4  2009    		JR	NZ,IEDT10
6845:	27E6  EE27    		XOR	QUOTE
6846:	27E8  32172F  		LD	(QUOFLG),A
6847:	27EB  3E27    		LD	A,QUOTE
6848:	27ED  1868    		JR	IEDT60
6849:	27EF  A7      	IEDT10:	AND	A		;quote flag on?
6850:	27F0  7B      		LD	A,E		;recover input character
6851:	27F1  280B    		JR	Z,IEDT15	;off - check terminator
6852:	27F3  3AE729  		LD	A,(LCMD)
6853:	27F6  CD3226  		CALL	IXLT
6854:	27F9  FE52    		CP	'R'
6855:	27FB  7B      		LD	A,E
6856:	27FC  2003    		JR	NZ,IEDT20
6857:	27FE  B9      	IEDT15:	CP	C		;compare with auxiliary terminator
6858:	27FF  2860    		JR	Z,IEDT90	;z - end
6859:	2801  FE09    	IEDT20:	CP	TAB
6860:	2803  200F    		JR	NZ,IEDT35	;nz - not tab check backspace
6861:	2805  CD4D26  	IEDT25:	CALL	RSPACE		;space out until char position mod 8 = zero
6862:	2808  77      		LD	(HL),A		;store space in buffer as we expand tab
6863:	2809  23      		INC	HL
6864:	280A  14      		INC	D
6865:	280B  3E07    		LD	A,7
6866:	280D  A2      		AND	D
6867:	280E  20F5    		JR	NZ,IEDT25
6868:	2810  3600    		LD	(HL),0		;set end of line null
6869:	2812  1848    		JR	IEDT70
6870:	2814  1E01    	IEDT35:	LD	E,1		;assume	one backspace required
6871:	2816  FE08    		CP	BS
6872:	2818  280C    		JR	Z,IEDT40	;z - correct assumption
6873:	281A  FE18    		CP	CTLX		;erase line?
6874:	281C  2039    		JR	NZ,IEDT60	;nz - process normal input character
6875:			
6876:	281E  AF      		XOR	A		;+ eg 3.3.8b
6877:	281F  B2      		OR	D		;+ See if ^X with empty buffer
6878:	2820  CA100C  		JP	Z,Z8E		;+ Abandon current command if so
6879:			
6880:	2823  5A      		LD	E,D		;backspace count is number of chars in buffer
6881:			
6882:	2824  1804    		JR	IEDT50		;+
6883:			
6884:	2826  AF      	IEDT40:	XOR	A		;test if already at beginning of buffer
6885:	2827  B2      		OR	D
6886:	2828  28A9    		JR	Z,IEDT05	;z - at	beginning so leave cursor as is
6887:	282A  CD6828  	IEDT50:	CALL	BKSP		;transmit bs - space - bs string
6888:	282D  15      		DEC	D		;sub one from input buffer count
6889:	282E  2B      		DEC	HL		;rewind	buffer pointer on notch
6890:	282F  7E      		LD	A,(HL)		;check for control characters
6891:	2830  3600    		LD	(HL),0
6892:	2832  FE27    		CP	QUOTE		;check for backspacing over a quote
6893:	2834  200A    		JR	NZ,IEDT55
6894:	2836  3A172F  		LD	A,(QUOFLG)	;toggle quote flag so we keep track of balance
6895:							;factor
6896:	2839  EE27    		XOR	QUOTE
6897:	283B  32172F  		LD	(QUOFLG),A
6898:	283E  1805    		JR	IEDT58
6899:	2840  FE20    	IEDT55:	CP	' '
6900:	2842  DC6828  		CALL	C,BKSP		;c - control char requires extra bs for caret
6901:	2845  1D      	IEDT58:	DEC	E		;dec backspace count
6902:	2846  20E2    		JR	NZ,IEDT50	;more backspacing
6903:	2848  3A282F  		LD	A,(STRNGF)	;string	function flag on?
6904:	284B  A7      		AND	A
6905:	284C  2885    		JR	Z,IEDT05	;off - get next	input char
6906:	284E  AF      		XOR	A		;did we	backspace to start of buffer?
6907:	284F  B2      		OR	D		;test via character count
6908:	2850  2081    		JR	NZ,IEDT05	;not rewound all the way
6909:	2852  320230  		LD	(INBFNC),A	;set a zero byte count so caller knows
6910:	2855  15      		DEC	D		;something is fishy
6911:	2856  C9      		RET
6912:	2857  77      	IEDT60:	LD	(HL),A		;store char in inbf
6913:	2858  23      		INC	HL		;bump inbf pointer
6914:	2859  3600    		LD	(HL),0		;end of line
6915:	285B  14      		INC	D		;bump number of	chars in buffer
6916:	285C  7A      	IEDT70:	LD	A,D		;current size
6917:	285D  90      		SUB	B		;versus	max size requested by caller
6918:	285E  DAD327  		JP	C,IEDT05	;more room in buffer
6919:	2861  210230  	IEDT90:	LD	HL,INBFNC	;store number of characters received ala
6920:							;bdos function 10
6921:	2864  72      		LD	(HL),D
6922:	2865  23      		INC	HL		;point to first	char in	buffer
6923:	2866  15      		DEC	D		;set m flag if length is zero
6924:	2867  C9      		RET			;sayonara
6925:			
6926:			
6927:			
6928:			
6929:	2868  CD6E28  	BKSP:	CALL	BKSP00
6930:	286B  CD4D26  		CALL	RSPACE
6931:	286E  3E08    	BKSP00:	LD	A,BS
6932:	2870  C3DD25  		JP	TTYO
6933:			
6934:			
6935:	2873  E67F    	ASCI:	AND	7FH		;Convert contents of accumulator to ascii
6936:	0000          		IF	HAZELTINE	;Hazeltine terminal?
6939:				ELSE			;Non-hazeltine terminal
6940:	2875  FE7F    		CP	DEL		;	check for del
6941:	2877  2805    		JR	Z,ASCI00	;	yes - translate to '.'
6942:				ENDIF			;Any terminal - other characters
6943:	2879  FE20    		CP	20H		;	check for control character
6944:	287B  D2DD25  		JP	NC,TTYO		;	no - output as is
6945:	287E          	ASCI00:				;	yes - translate to '.'
6946:			;	if	hazeltine
6947:	287E  3E2E    		LD	A,'.'		;Non-printables replaced with dot
6948:			;	else
6949:			;	ld	a,tilde		;Non-printables replaced with squiggle
6950:			;	endif
6951:	2880  C3DD25  	       	JP	TTYO
6952:			
6953:			
6954:			
6955:	2883  CD8728  	BCDX:	CALL	BCDX00
6956:	2886  C0      		RET	NZ
6957:	2887  ED6F    	BCDX00:	RLD
6958:	2889  EB      		EX	DE,HL
6959:	288A  29      		ADD	HL,HL
6960:	288B  44      		LD	B,H
6961:	288C  4D      		LD	C,L
6962:	288D  29      		ADD	HL,HL
6963:	288E  29      		ADD	HL,HL
6964:	288F  09      		ADD	HL,BC
6965:	2890  4F      		LD	C,A
6966:	2891  3E09    		LD	A,9
6967:	2893  B9      		CP	C
6968:	2894  D8      		RET	C
6969:	2895  AF      		XOR	A
6970:	2896  47      		LD	B,A
6971:	2897  09      		ADD	HL,BC
6972:	2898  EB      		EX	DE,HL
6973:	2899  8F      		ADC	A,A
6974:	289A  C9      		RET
6975:			
6976:			
6977:			
6978:	289B  CD3B26  	NPRINT:	CALL	CRLF
6979:	289E  1A      	PRINT:	LD	A,(DE)
6980:	289F  A7      		AND	A
6981:	28A0  C8      		RET	Z
6982:	28A1  CDDD25  		CALL	TTYO
6983:	28A4  13      		INC	DE
6984:	28A5  18F7    		JR	PRINT
6985:			
6986:			
6987:	28A7  7E      	PRINTB:	LD	A,(HL)
6988:	28A8  A7      		AND	A
6989:	28A9  C8      		RET	Z
6990:	28AA  CDDD25  		CALL	TTYO
6991:	28AD  23      		INC	HL
6992:	28AE  0D      		DEC	C
6993:	28AF  20F6    		JR	NZ,PRINTB
6994:	28B1  C9      		RET
6995:			
6996:			
6997:			
6998:	28B2  010000  	HOME:	LD	BC,00
6999:			
7000:			
7001:			;----------------------------------------------------------------------------
7002:			;
7003:			;	xycp:	Cursor-positioning routine.
7004:			;
7005:			;	Two versions are supplied and either can be selected during
7006:			;	assembly according to the setting of ATERM.
7007:			;
7008:			;	aterm	equ	TRUE		Selects ANSI screen driver
7009:			;	aterm	equ	FALSE		Selects default screen driver
7010:			;
7011:			;	In either  case, this routine is invoked with the row in B and
7012:			;	the column in C.
7013:			;
7014:			;----------------------------------------------------------------------------
7015:			
7016:	0000          	    IF	ASMB
7018:			    ELSE
7019:	28B5          	XYCP:
7020:			    ENDIF
7021:			
7022:	0000          	    IF ATERM
7076:			    ELSE
7077:			
7078:			;	Default screen driver - ras
7079:			
7080:	28B5  C5      		PUSH	BC		;Enter with row in b and column in c
7081:	28B6  D5      		PUSH	DE
7082:	28B7  E5      		PUSH	HL
7083:	28B8  213D2F  		LD	HL,MXYCP
7084:	28BB  3A412F  		LD	A,(ROW)		;Add in row offset
7085:	28BE  80      		ADD	A,B
7086:	28BF  47      		LD	B,A		;Save row character
7087:	28C0  3A422F  		LD	A,(COLUMN)	;Add column bias
7088:	28C3  81      		ADD	A,C
7089:	28C4  4F      		LD	C,A
7090:	28C5  5E      		LD	E,(HL)		;Number of chars in cursor addressing string
7091:	28C6          	XYCP00:
7092:	28C6  23      		INC	HL
7093:	28C7  7E      		LD	A,(HL)
7094:	28C8  CDDD25  		CALL	TTYO
7095:	28CB  1D      		DEC	E
7096:	28CC  20F8    		JR	NZ,XYCP00
7097:	28CE  3A3C2F  		LD	A,(ROWB4X)
7098:	28D1  A7      		AND	A
7099:	28D2  2003    		JR	NZ,XYCP10
7100:	28D4  78      		LD	A,B
7101:	28D5  41      		LD	B,C
7102:	28D6  4F      		LD	C,A
7103:	28D7          	XYCP10:
7104:	28D7  78      		LD	A,B
7105:	28D8  CDDD25  		CALL	TTYO
7106:	28DB  79      		LD	A,C
7107:	28DC  CDDD25  		CALL	TTYO
7108:	28DF  E1      		POP	HL
7109:	28E0  D1      		POP	DE
7110:	28E1  C1      		POP	BC
7111:	28E2  C9      		RET
7112:			
7113:			    ENDIF
7114:			
7115:	FFFF          	    IF	NOT COMPACT			;..then leave room for patching
7116:	2935          		ORG	XYCP+128		;  the object code
7117:			    ENDIF
7118:			
7119:	2935          	NREL:					;end of	relocatable code
7121:			
7122:	2935          	ZOPNM:
7123:	2935  484C    		DEFB	'HL'
7124:	2937  4120    		DEFB	'A '
7125:	2939  4820    		DEFB	'H '
7126:	293B  4C20    		DEFB	'L '
7127:	293D  4420    		DEFB	'D '
7128:	293F  4520    		DEFB	'E '
7129:	2941  4220    		DEFB	'B '
7130:	2943  4320    		DEFB	'C '
7131:	2945  4958    	SIX:	DEFB	'IX'
7132:	2947  5350    		DEFB	'SP'
7133:	2949  5020    		DEFB	'P '
7134:	294B  5220    		DEFB	'R '
7135:	294D  4920    		DEFB	'I '
7136:	294F  4146    		DEFB	'AF'
7137:	2951  4243    		DEFB	'BC'
7138:	2953  4445    		DEFB	'DE'
7139:	2955  4959    	SIY:	DEFB	'IY'
7140:	2957  5A20    		DEFB	'Z '
7141:	2959  4E43    		DEFB	'NC'
7142:	295B  4E5A    		DEFB	'NZ'
7143:	295D  5045    		DEFB	'PE'
7144:	295F  504F    		DEFB	'PO'
7145:	2961  4D20    		DEFB	'M '
7146:	2963  5043    		DEFB	'PC'
7147:			
7148:	0008          	RIX	EQU	(SIX-ZOPNM)/2		;relative position - ix
7149:	0010          	RIY	EQU	(SIY-ZOPNM)/2		;		     iy
7150:			
7151:	0018          	ZOPNML	EQU	($-ZOPNM)/2
7152:			
7153:	0030          	ZOPJTB	EQU	 $-NREL			;nrel to jump table bias for loader
7154:			
7155:	2965          	ZOPRJT:
7156:	2965  6824    		DEFW	OPN600			;18 - hl/ix/iy test
7157:	2967  3E24    		DEFW	OPN400			;19 - register specified in bits 0-2
7158:	2969  3E24    		DEFW	OPN400			;1a - register specified in bits 3-5
7159:	296B  A823    		DEFW	OPN100			;1b - relative jump
7160:	296D  C523    		DEFW	OPN200			;1c - nn
7161:	296F  0924    		DEFW	OPN300			;1d - nnnn
7162:	2971  B424    		DEFW	OPN700			;1e - restart
7163:	2973  C324    		DEFW	OPN800			;1f - bit number
7164:			
7165:	2975  2130    	ZASMIO:	DEFW	ZASMBF
7166:			
7167:	0009          	ZOPJTL	EQU	($-ZOPRJT)/2		;length	of operand jump	table
7168:			
7169:	2977          	JTCMD:
7170:	2977  F81C    		DEFW	IFCB			; i
7171:	2979  CF15    		DEFW	ASMBLR			; a
7172:	297B  7F10    		DEFW	USYM			; u
7173:	297D  8412    		DEFW	NPRT			; n
7174:	297F  B00D    		DEFW	JDBG			; j
7175:	2981  4720    		DEFW	ZASM			; z
7176:	2983  E10F    		DEFW	EXAM			; e
7177:	2985  B911    		DEFW	RGST			; r
7178:	2987  5214    		DEFW	GO			; g
7179:	2989  8B1C    		DEFW	YFIL			; y
7180:	298B  661C    		DEFW	MOVB			; m
7181:	298D  AE1F    		DEFW	VERIFY			; v
7182:	298F  F71B    		DEFW	PSWDSP			; p
7183:	2991  1213    		DEFW	BREAK			; b
7184:	2993  7513    		DEFW	CBREAK			; c
7185:	2995  4B1F    		DEFW	FIND			; f
7186:	2997  1910    		DEFW	HSYM			; h
7187:	2999  6B15    		DEFW	STEP			; s
7188:	299B  D713    		DEFW	OBREAK			; o
7189:	299D  5B1D    		DEFW	LLDR			; l
7190:	299F  1711    		DEFW	DUMP			; d
7191:	29A1  8412    		DEFW	QPRT			; q
7192:	29A3  D81F    		DEFW	XREG			; x
7193:	29A5  2014    		DEFW	KDMP			; k
7194:	29A7  F21E    		DEFW	WRIT			; w
7195:	29A9  A51C    		DEFW	CUSER			; >
7196:	29AB  C61C    		DEFW	QEVAL			; ?
7197:			;	defw	gadr			; #
7198:	29AD          	CMD:
7199:			;	defb	'#?>WKXQDLOSHFCB'
7200:	29AD  3F3E574B		DEFB	'?>WKXQDLOSHFCB'
	      5851444C
	      4F534846
	      4342
7201:	29BB  50564D59		DEFB	'PVMYGREZJNUAI'
	      4752455A
	      4A4E5541
	      49
7202:	001B          	NCMD	EQU	$-CMD		;number	of commands
7203:			
7204:	29C8          	BPEMSG:
7205:	29C8  2A455252		DEFB	'*ERROR*'
	      4F522A
7206:	29CF          	BPMSG:
7207:	29CF  2A42502A		DEFB	'*BP* @ '
	      204020
7208:	29D6  00      		DEFB	0
7209:	29D7          	PROMPT:
7210:	29D7  2A200800		DEFB	'*',' ',bs,0
7211:			
7212:	29DB  3D3E    	MRROW:	DEFB	'=','>'		;backspaces taken out
7213:	29DD  00      		DEFB	00
7214:			
7215:	29DE  3F3F    	MXXXX:	DEFB	'??'
7216:	29E0  203F3F20	MXX:	DEFB	' ??  '
	      20
7217:			
7218:			
7219:	29E5  20      	ASMFLG:	DEFB	' '
7220:	29E6  00      		DEFB	0
7221:			
7222:	29E7  20      	LCMD:	DEFB	' '
7223:	29E8  203F3F  	EMXXX:	DEFB	' ??'
7224:	29EB  00      		DEFB	0
7225:			
7226:	29EC          	MLDG:
7227:	29EC  4C6F6164		DEFB	'Loading: '
	      696E673A
	      20
7228:	29F5  00      		DEFB	0
7229:			
7230:	29F6          	MFILNF:
7231:	29F6  46696C65		DEFB	'File Not Found'
	      204E6F74
	      20466F75
	      6E64
7232:	2A04  0D0A00  		DEFB	CR,LF,00
7233:			
7234:			
7235:	2A07          	MLODM:
7236:	2A07  4C6F6164		DEFB	'Loaded:  '
	      65643A20
	      20
7237:	2A10  00      		DEFB	0
7238:	2A11          	MLODPG:
7239:			
7240:	2A11  50616765		DEFB	'Pages:   '
	      733A2020
	      20
7241:	2A1A  00      		DEFB	0
7242:			
7243:	2A1B          	MSNTX:
7244:	2A1B  53796E74		DEFB	'Syntax Error'
	      61782045
	      72726F72
7245:	2A27  0D0A00  		DEFB	CR,LF,0
7246:			
7247:	2A2A  4F757420	MMEMXX:	DEFB	'Out Of Memory'
	      4F66204D
	      656D6F72
	      79
7248:	2A37  00      		DEFB	0
7249:			
7250:	2A38  202D2043	MCNTU:	DEFB	' - Continue? '
	      6F6E7469
	      6E75653F
	      20
7251:	2A45  00      		DEFB	0
7252:			
7253:	2A46          	MIREG:
7254:	2A46  49523A20		DEFB	'IR: '
7255:	2A4A  00      		DEFB	0
7257:			
7258:	2A4B  09192B  	Z80FD:	DEFB	009H,019H,02BH
7259:	2A4E  232939E1		DEFB	023H,029H,039H,0E1H
7260:	2A52  E3E5E9F9		DEFB	0E3H,0E5H,0E9H,0F9H
7261:	000B          	Z80FDL	EQU	$-Z80FD
7262:			
7263:	2A56  21222A36	Z80F4:	DEFB	021H,022H,02AH,036H,0CBH
	      CB
7264:	0005          	Z80F4L	EQU	$-Z80F4
7265:			
7266:			
7267:	2A5B  C0E9C9D8	Z801:	DEFB	0C0H,0E9H,0C9H,0D8H
7268:	2A5F  D0C8E8E0		DEFB	0D0H,0C8H,0E8H,0E0H
7269:	2A63  F8F0    		DEFB	0F8H,0F0H
7270:	000A          	Z801L	EQU	$-Z801
7271:			
7272:			
7273:	2A65  36C6CED3	Z802:	DEFB	036H,0C6H,0CEH,0D3H
7274:	2A69  D6DBDEE6		DEFB	0D6H,0DBH,0DEH,0E6H
7275:	2A6D  EEF6FE  		DEFB	0EEH,0F6H,0FEH
7276:	2A70  183830  	Z802C:	DEFB	018H,038H,030H
7277:	2A73  282010  		DEFB	028H,020H,010H
7278:	0011          	Z802L	EQU	$-Z802
7279:	0006          	Z802CL	EQU	$-Z802C
7280:			
7281:			
7282:	2A76          	Z80R:
7283:	2A76  01112122	Z803:	DEFB	001H,011H,021H,022H
7284:	2A7A  2A31323A		DEFB	02AH,031H,032H,03AH
7285:			
7286:	2A7E  CD      	Z803S:	DEFB	0CDH
7287:	2A7F  DCD4CCC4		DEFB	0DCH,0D4H,0CCH,0C4H
7288:	2A83  ECE4FCF4		DEFB	0ECH,0E4H,0FCH,0F4H
7289:			
7290:	0009          	Z803SL	EQU	$-Z803S			;number	of call	instructions
7291:			
7292:	2A87  C3      	Z803C:	DEFB	0C3H
7293:	2A88  DAD2CAC2		DEFB	0DAH,0D2H,0CAH,0C2H
7294:	2A8C  EAE2FAF2		DEFB	0EAH,0E2H,0FAH,0F2H
7295:			
7296:	001A          	Z803L	EQU	$-Z803			;number	of 3 byte instructions
7297:	0012          	Z803CL	EQU	$-Z803S			;number	of 3 byte pc mod instructions
7298:			
7299:	2A90  434B53  	Z80ED:	DEFB	043H,04BH,053H
7300:	2A93  5B737B  		DEFB	05BH,073H,07BH
7301:			
7302:	0006          	Z80EDL	EQU	$-Z80ED
7303:			
7304:	0020          	Z80RL	EQU	$-Z80R			;number	relocatable z80	instructions
7305:			
7306:	2A96          	Z80F3:
7307:	2A96  3435464E		DEFB	034H,035H,046H,04EH
7308:	2A9A  565E666E		DEFB	056H,05EH,066H,06EH
7309:	2A9E  70717273		DEFB	070H,071H,072H,073H
7310:	2AA2  7475777E		DEFB	074H,075H,077H,07EH
7311:	2AA6  868E969E		DEFB	086H,08EH,096H,09EH
7312:	2AAA  A6AEB6BE		DEFB	0A6H,0AEH,0B6H,0BEH
7313:	0018          	Z80F3L	EQU	$-Z80F3
7315:			;***********************************************************************
7316:			;*
7317:			;*
7318:			;*
7319:			;*
7320:			;*
7321:			;***********************************************************************
7322:			
7323:	2AB0          		ORG	($+3) AND 0FFFCH
7324:	2AB0          	ZOPCPT:
7325:	2AB0  221C1C15		DEFB	022H,01CH,01CH,015H	;nop	ld	ld	inc	00 - 03
7326:	2AB4  150C1C31		DEFB	015H,00CH,01CH,031H	;inc	dec	ld	rlca	04 - 07
7327:	2AB8  10001C0C		DEFB	010H,000H,01CH,00CH	;ex	add	ld	dec	08 - 0b
7328:	2ABC  150C1C36		DEFB	015H,00CH,01CH,036H	;inc	dec	ld	rrca	0c - 0f
7329:	2AC0  0E1C1C15		DEFB	00EH,01CH,01CH,015H	;djnz	ld	ld	inc	10 - 13
7330:	2AC4  150C1C2F		DEFB	015H,00CH,01CH,02FH	;inc	dec	ld	rla	14 - 17
7331:	2AC8  1B001C0C		DEFB	01BH,000H,01CH,00CH	;jr	add	ld	dec	18 - 1b
7332:	2ACC  150C1C34		DEFB	015H,00CH,01CH,034H	;inc	dec	ld	rra	1c - 1f
7333:	2AD0  1B1C1C15		DEFB	01BH,01CH,01CH,015H	;jr	ld	ld	inc	20 - 23
7334:	2AD4  150C1C0B		DEFB	015H,00CH,01CH,00BH	;inc	dec	ld	daa	24 - 27
7335:	2AD8  1B001C0C		DEFB	01BH,000H,01CH,00CH	;jr	add	ld	dec	28 - 2b
7336:	2ADC  150C1C0A		DEFB	015H,00CH,01CH,00AH	;inc	dec	ld	cpl	2c - 2f
7337:	2AE0  1B1C1C15		DEFB	01BH,01CH,01CH,015H	;jr	ld	ld	inc	30 - 33
7338:	2AE4  150C1C3A		DEFB	015H,00CH,01CH,03AH	;inc	dec	ld	scf	34 - 37
7339:	2AE8  1B001C0C		DEFB	01BH,000H,01CH,00CH	;jr	add	ld	dec	38 - 3b
7340:	2AEC  150C1C04		DEFB	015H,00CH,01CH,004H	;inc	dec	ld	ccf	3c - 3f
7341:			
7342:			
7343:	2AF0  1426391C		DEFB	014H,026H,039H,01CH	;in	out	sbc	ld	ed 40
7344:	2AF4  212D131C		DEFB	021H,02DH,013H,01CH	;neg	retn	im	ld
7345:	2AF8  1426011C		DEFB	014H,026H,001H,01CH	;in	out	adc	ld
7346:	2AFC  222C221C		DEFB	022H,02CH,022H,01CH	;....	reti	...	ld
7347:	2B00  1426391C		DEFB	014H,026H,039H,01CH	;in	out	sbc	ld
7348:	2B04  2222131C		DEFB	022H,022H,013H,01CH	;...	...	im	ld
7349:	2B08  1426011C		DEFB	014H,026H,001H,01CH	;in	out	adc	ld
7350:	2B0C  2222131C		DEFB	022H,022H,013H,01CH	;...	...	im	ld
7351:	2B10  14263922		DEFB	014H,026H,039H,022H	;in	out	sbc	...
7352:	2B14  22220237		DEFB	022H,022H,002H,037H	;...	...	...	rrd
7353:	2B18  14260122		DEFB	014H,026H,001H,022H	;in	out	adc	...
7354:	2B1C  44454632		DEFB	044H,045H,046H,032H	;defb*	defw*	ddb*	rld
7355:	2B20  4347391C		DEFB	043H,047H,039H,01CH	;org*	equ*	sbc	ld	ed 70
7356:	2B24  22222222		DEFB	022H,022H,022H,022H	;...	...	...	...
7357:	2B28  1426011C		DEFB	014H,026H,001H,01CH	;in	out	adc	ld
7358:	2B2C  22222222		DEFB	022H,022H,022H,022H	;...	...	...	...	ed 7f
7359:			
7360:			
7361:	2B30  1F081828		DEFB	01FH,008H,018H,028H	;ldi	cpi	ini	outi
7362:	2B34  22222222		DEFB	022H,022H,022H,022H	;...	...	...	...
7363:	2B38  1D061627		DEFB	01DH,006H,016H,027H	;ldd	cpd	ind	outd
7364:	2B3C  22222222		DEFB	022H,022H,022H,022H	;...	...	...	...
7365:	2B40  20091925		DEFB	020H,009H,019H,025H	;ldir	cpir	inir	otir
7366:	2B44  22222222		DEFB	022H,022H,022H,022H	;...	...	...	...
7367:	2B48  1E071724		DEFB	01EH,007H,017H,024H	;lddr	cpdr	indr	otdr
7368:	2B4C  22222244		DEFB	022H,022H,022H,044H	;...	....	....	defb*
7369:			
7370:			
7371:	2B50  2B291A1A		DEFB	02BH,029H,01AH,01AH	;ret	pop	jp	jp	c0 - c3
7372:	2B54  032A0038		DEFB	003H,02AH,000H,038H	;call	push	add	rst	c4 - c7
7373:	2B58  2B2B1A22		DEFB	02BH,02BH,01AH,022H	;ret	ret	jp	...	c8 - cb
7374:	2B5C  03030138		DEFB	003H,003H,001H,038H	;call	call	adc	rst	cc - cf
7375:	2B60  2B291A26		DEFB	02BH,029H,01AH,026H	;ret	pop	jp	out	d0 - d3
7376:	2B64  032A3E38		DEFB	003H,02AH,03EH,038H	;call	push	sub	rst	d4 - d7
7377:	2B68  2B111A14		DEFB	02BH,011H,01AH,014H	;ret	exx	jp	in	d8 - db
7378:	2B6C  03223938		DEFB	003H,022H,039H,038H	;call	...	sbc	rst	dc - df
7379:	2B70  2B291A10		DEFB	02BH,029H,01AH,010H	;ret	pop	jp	ex	e0 - e3
7380:	2B74  032A0238		DEFB	003H,02AH,002H,038H	;call	push	and	rst	e4 - e7
7381:	2B78  2B1A1A10		DEFB	02BH,01AH,01AH,010H	;ret	jp	jp	ex	e8 - eb
7382:	2B7C  03223F38		DEFB	003H,022H,03FH,038H	;call	...	xor	rst	ec - ef
7383:	2B80  2B291A0D		DEFB	02BH,029H,01AH,00DH	;ret	pop	jp	di	f0 - f3
7384:	2B84  032A2338		DEFB	003H,02AH,023H,038H	;call	push	or	rst	f4 - f7
7385:	2B88  2B1C1A0F		DEFB	02BH,01CH,01AH,00FH	;ret	ld	jp	ei	f8 - fb
7386:	2B8C  03220538		DEFB	003H,022H,005H,038H	;call	...	cp	rst	fc - ff
7387:			
7388:	2B90  00013E39		DEFB	000H,001H,03EH,039H	;add	adc	sub	sbc
7389:	2B94  023F2305		DEFB	002H,03FH,023H,005H	;and	xor	or	cp
7390:			
7391:			
7392:	2B98  30352E33		DEFB	030H,035H,02EH,033H	;rlc	rrc	rl	rr
7393:	2B9C  3B3C223D		DEFB	03BH,03CH,022H,03DH	;sla	sra	...	srl
7394:	2BA0  22404142		DEFB	022H,040H,041H,042H	;...	bit	res	set
7395:			
7396:			
7397:	2BA4  22222212		DEFB	022H,022H,022H,012H	;...	...	...	halt
7398:			
7399:			
7400:	2BA8  1C1C1C1C		DEFB	01CH,01CH,01CH,01CH	;ld	ld	ld	ld
7401:	2BAC  1C1C1C1C		DEFB	01CH,01CH,01CH,01CH	;ld	ld	ld	ld
7402:			
7404:			;****************************************************************************
7405:			;*
7406:			;*			table of first operands
7407:			;*
7408:			;****************************************************************************
7409:			
7410:	2BB0          	ZOPND1:
7411:	2BB0  FF0E8E0E		DEFB	0FFH,00EH,08EH,00EH	;00 - 03
7412:	2BB4  060606FF		DEFB	006H,006H,006H,0FFH	;04 - 07
7413:	2BB8  0D18010E		DEFB	00DH,018H,001H,00EH	;08 - 0b
7414:	2BBC  070707FF		DEFB	007H,007H,007H,0FFH	;0c - 0f
7415:	2BC0  1B0F8F0F		DEFB	01BH,00FH,08FH,00FH	;10 - 13
7416:	2BC4  040404FF		DEFB	004H,004H,004H,0FFH	;14 - 17
7417:	2BC8  1B18010F		DEFB	01BH,018H,001H,00FH	;18 - 1b
7418:	2BCC  050505FF		DEFB	005H,005H,005H,0FFH	;1c - 1f
7419:	2BD0  13189D18		DEFB	013H,018H,09DH,018H	;20 - 23
7420:	2BD4  020202FF		DEFB	002H,002H,002H,0FFH	;24 - 27
7421:	2BD8  11181818		DEFB	011H,018H,018H,018H	;28 - 2b
7422:	2BDC  030303FF		DEFB	003H,003H,003H,0FFH	;2c - 2f
7423:	2BE0  12099D09		DEFB	012H,009H,09DH,009H	;30 - 33
7424:	2BE4  989898FF		DEFB	098H,098H,098H,0FFH	;34 - 37
7425:	2BE8  07180109		DEFB	007H,018H,001H,009H	;38 - 3b
7426:	2BEC  010101FF		DEFB	001H,001H,001H,0FFH	;3c - 3f
7427:			
7428:	2BF0  0687009D		DEFB	006H,087H,000H,09DH	;40 - 43
7429:	2BF4  FFFF1F0C		DEFB	0FFH,0FFH,01FH,00CH	;44 - 47
7430:	2BF8  0787000E		DEFB	007H,087H,000H,00EH	;48 - 4b
7431:	2BFC  FFFFFF0B		DEFB	0FFH,0FFH,0FFH,00BH	;4c - 4f
7432:	2C00  0487009D		DEFB	004H,087H,000H,09DH	;50 - 53
7433:	2C04  FFFF1F01		DEFB	0FFH,0FFH,01FH,001H	;54 - 57
7434:	2C08  0587000F		DEFB	005H,087H,000H,00FH	;58 - 5b
7435:	2C0C  FFFF1F01		DEFB	0FFH,0FFH,01FH,001H	;5c - 5f
7436:	2C10  028700FF		DEFB	002H,087H,000H,0FFH	;60 - 63
7437:	2C14  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;64 - 67
7438:	2C18  038700FF		DEFB	003H,087H,000H,0FFH	;68 - 6b
7439:	2C1C  1C1D1DFF		DEFB	01CH,01DH,01DH,0FFH	;6c - 6f	defb  defw  ddb
7440:	2C20  1D1D009D		DEFB	01DH,01DH,000H,09DH	;70 - 73	org   equ
7441:	2C24  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;74 - 77
7442:	2C28  01870009		DEFB	001H,087H,000H,009H	;78 - 7b
7443:	2C2C  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;7c - 7f
7444:			
7445:	2C30  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;a0 - bf
7446:	2C34  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;a4 - a7
7447:	2C38  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;a8 - ab
7448:	2C3C  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;ac - af
7449:	2C40  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;b0 - b3
7450:	2C44  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;b4 - b7
7451:	2C48  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;b8 - bb
7452:	2C4C  FFFF0FFF		DEFB	0FFH,0FFH,00FH,0FFH	;bc - bf
7453:			
7454:	2C50  130E131D		DEFB	013H,00EH,013H,01DH	;c0 - c3
7455:	2C54  130E011E		DEFB	013H,00EH,001H,01EH	;c4 - c7
7456:	2C58  11FF11FF		DEFB	011H,0FFH,011H,0FFH	;c8 - cb
7457:	2C5C  111D011E		DEFB	011H,01DH,001H,01EH	;cc - cf
7458:	2C60  120F129C		DEFB	012H,00FH,012H,09CH	;d0 - d3
7459:	2C64  120F1C1E		DEFB	012H,00FH,01CH,01EH	;d4 - d7
7460:	2C68  07FF0701		DEFB	007H,0FFH,007H,001H	;d8 - db
7461:	2C6C  07FF011E		DEFB	007H,0FFH,001H,01EH	;dc - df
7462:	2C70  15181589		DEFB	015H,018H,015H,089H	;e0 - e3
7463:	2C74  15181C1E		DEFB	015H,018H,01CH,01EH	;e4 - e7
7464:	2C78  1498140F		DEFB	014H,098H,014H,00FH	;e8 - eb
7465:	2C7C  14FF1C1E		DEFB	014H,0FFH,01CH,01EH	;ec - ef
7466:	2C80  0A0D0AFF		DEFB	00AH,00DH,00AH,0FFH	;f0 - f3
7467:	2C84  0A0D1C1E		DEFB	00AH,00DH,01CH,01EH	;f4 - f7
7468:	2C88  160916FF		DEFB	016H,009H,016H,0FFH	;f8 - fb
7469:	2C8C  16FF1C1E		DEFB	016H,0FFH,01CH,01EH	;fc - ff
7470:			
7471:			
7472:	2C90  01011901		DEFB	001H,001H,019H,001H	;8 bit logic and arithmetic
7473:	2C94  19191919		DEFB	019H,019H,019H,019H	;
7474:			
7475:			
7476:	2C98  19191919		DEFB	019H,019H,019H,019H	;shift and rotate
7477:	2C9C  19191919		DEFB	019H,019H,019H,019H	;
7478:	2CA0  FF1F1F1F		DEFB	0FFH,01FH,01FH,01FH	;bit - res - set
7479:			
7480:	2CA4  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;filler
7481:			
7482:	2CA8  1A1A1A1A		DEFB	01AH,01AH,01AH,01AH	;8 bit load
7483:	2CAC  1A1A1A1A		DEFB	01AH,01AH,01AH,01AH	;
7484:			
7486:			;***********************************************************************
7487:			;*
7488:			;*			table of second	operands
7489:			;*
7490:			;***********************************************************************
7491:			
7492:			
7493:	2CB0          	ZOPND2:
7494:	2CB0  FF1D01FF		DEFB	0FFH,01DH,001H,0FFH	;00 - 03
7495:	2CB4  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;04 - 07
7496:	2CB8  0D0E8EFF		DEFB	00DH,00EH,08EH,0FFH	;08 - 0b
7497:	2CBC  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;0c - 0f
7498:	2CC0  FF1D01FF		DEFB	0FFH,01DH,001H,0FFH	;10 - 13
7499:	2CC4  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;14 - 17
7500:	2CC8  FF0F8FFF		DEFB	0FFH,00FH,08FH,0FFH	;18 - 1b
7501:	2CCC  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;1c - 1f
7502:	2CD0  1B1D18FF		DEFB	01BH,01DH,018H,0FFH	;20 - 23
7503:	2CD4  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;24 - 27
7504:	2CD8  1B189DFF		DEFB	01BH,018H,09DH,0FFH	;28 - 2b
7505:	2CDC  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;2c - 2f
7506:	2CE0  1B1D01FF		DEFB	01BH,01DH,001H,0FFH	;30 - 33
7507:	2CE4  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;34 - 37
7508:	2CE8  1B099DFF		DEFB	01BH,009H,09DH,0FFH	;38 - 3b
7509:	2CEC  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;3c - 3f
7510:			
7511:			
7512:	2CF0  87060E0E		DEFB	087H,006H,00EH,00EH	;40 - 43
7513:	2CF4  FFFFFF01		DEFB	0FFH,0FFH,0FFH,001H	;44 - 47
7514:	2CF8  87070E9D		DEFB	087H,007H,00EH,09DH	;48 - 4b
7515:	2CFC  FFFFFF01		DEFB	0FFH,0FFH,0FFH,001H	;4c - 4f
7516:	2D00  87040F0F		DEFB	087H,004H,00FH,00FH	;50 - 53
7517:	2D04  FFFFFF0C		DEFB	0FFH,0FFH,0FFH,00CH	;54 - 57
7518:	2D08  87050F9D		DEFB	087H,005H,00FH,09DH	;58 - 5b
7519:	2D0C  FFFFFF0B		DEFB	0FFH,0FFH,0FFH,00BH	;5c - 5f
7520:	2D10  870200FF		DEFB	087H,002H,000H,0FFH	;60 - 63
7521:	2D14  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;64 - 67
7522:	2D18  870300FF		DEFB	087H,003H,000H,0FFH	;68 - 6b
7523:	2D1C  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;6c - 6f
7524:	2D20  FFFF0909		DEFB	0FFH,0FFH,009H,009H	;70 - 73
7525:	2D24  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;74 - 77
7526:	2D28  8701099D		DEFB	087H,001H,009H,09DH	;78 - 7b
7527:	2D2C  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH
7528:			
7529:	2D30  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;a0 - bf
7530:	2D34  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;a4 - a7
7531:	2D38  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;a8 - ab
7532:	2D3C  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;ac - af
7533:	2D40  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;b0 - b3
7534:	2D44  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;b4 - b7
7535:	2D48  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;b8 - bb
7536:	2D4C  FFFF0FFF		DEFB	0FFH,0FFH,00FH,0FFH	;bc - bf
7537:			
7538:	2D50  FFFF1DFF		DEFB	0FFH,0FFH,01DH,0FFH	;c0 - c3
7539:	2D54  1DFF1CFF		DEFB	01DH,0FFH,01CH,0FFH	;c4 - c7
7540:	2D58  FFFF1DFF		DEFB	0FFH,0FFH,01DH,0FFH	;c8 - cb
7541:	2D5C  1DFF1CFF		DEFB	01DH,0FFH,01CH,0FFH	;cc - cf
7542:	2D60  FFFF1D01		DEFB	0FFH,0FFH,01DH,001H	;d0 - d3
7543:	2D64  1DFFFFFF		DEFB	01DH,0FFH,0FFH,0FFH	;d4 - d7
7544:	2D68  FFFF1D9C		DEFB	0FFH,0FFH,01DH,09CH	;d8 - db
7545:	2D6C  1DFF1CFF		DEFB	01DH,0FFH,01CH,0FFH	;dc - df
7546:	2D70  FFFF1D18		DEFB	0FFH,0FFH,01DH,018H	;e0 - e3
7547:	2D74  1DFFFFFF		DEFB	01DH,0FFH,0FFH,0FFH	;e4 - e7
7548:	2D78  FFFF1D00		DEFB	0FFH,0FFH,01DH,000H	;e8 - eb
7549:	2D7C  1DFFFFFF		DEFB	01DH,0FFH,0FFH,0FFH	;ec - ef
7550:	2D80  FFFF1DFF		DEFB	0FFH,0FFH,01DH,0FFH	;f0 - f3
7551:	2D84  1DFFFFFF		DEFB	01DH,0FFH,0FFH,0FFH	;f4 - f7
7552:	2D88  FF181DFF		DEFB	0FFH,018H,01DH,0FFH	;f8 - fb
7553:	2D8C  1DFFFFFF		DEFB	01DH,0FFH,0FFH,0FFH	;fc - ff
7554:			
7555:	2D90  1919FF19		DEFB	019H,019H,0FFH,019H	;8 bit logic and arithmetic
7556:	2D94  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;
7557:			
7558:	2D98  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;shift and rotate
7559:	2D9C  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;
7560:	2DA0  FF191919		DEFB	0FFH,019H,019H,019H	;bit - res - set
7561:			
7562:	2DA4  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH
7563:			
7564:	2DA8  19191919		DEFB	019H,019H,019H,019H	;8 bit load
7565:	2DAC  19191919		DEFB	019H,019H,019H,019H
7567:			
7568:			;***********************************************************************
7569:			;*
7570:			;*			table of op code names
7571:			;*
7572:			;***********************************************************************
7573:			
7574:			
7575:	2DB0          	ZOPCNM:
7576:	2DB0  41444420		DEFB	'ADD ADC AND CALL'
	      41444320
	      414E4420
	      43414C4C
7577:	2DC0  43434620		DEFB	'CCF CP  CPD CPDR'
	      43502020
	      43504420
	      43504452
7578:	2DD0  43504920		DEFB	'CPI CPIRCPL DAA '
	      43504952
	      43504C20
	      44414120
7579:	2DE0  44454320		DEFB	'DEC DI  DJNZEI  '
	      44492020
	      444A4E5A
	      45492020
7580:	2DF0  45582020		DEFB	'EX  EXX HALTIM  '
	      45585820
	      48414C54
	      494D2020
7581:	2E00  494E2020		DEFB	'IN  INC IND INDR'
	      494E4320
	      494E4420
	      494E4452
7582:	2E10  494E4920		DEFB	'INI INIRJP  JR  '
	      494E4952
	      4A502020
	      4A522020
7583:	2E20  4C442020		DEFB	'LD  LDD LDDRLDI '
	      4C444420
	      4C444452
	      4C444920
7584:	2E30  4C444952		DEFB	'LDIRNEG NOP OR  '
	      4E454720
	      4E4F5020
	      4F522020
7585:	2E40  4F544452		DEFB	'OTDROTIROUT OUTD'
	      4F544952
	      4F555420
	      4F555444
7586:	2E50  4F555449		DEFB	'OUTIPOP PUSHRET '
	      504F5020
	      50555348
	      52455420
7587:	2E60  52455449		DEFB	'RETIRETNRL  RLA '
	      5245544E
	      524C2020
	      524C4120
7588:	2E70  524C4320		DEFB	'RLC RLCARLD RR  '
	      524C4341
	      524C4420
	      52522020
7589:	2E80  52524120		DEFB	'RRA RRC RRCARRD '
	      52524320
	      52524341
	      52524420
7590:	2E90  52535420		DEFB	'RST SBC SCF SLA '
	      53424320
	      53434620
	      534C4120
7591:	2EA0  53524120		DEFB	'SRA SRL SUB XOR '
	      53524C20
	      53554220
	      584F5220
7592:	2EB0  42495420		DEFB	'BIT RES SET ORG '
	      52455320
	      53455420
	      4F524720
7593:	2EC0  44454642		DEFB	'DEFBDEFWDDB EQU '
	      44454657
	      44444220
	      45515520
7594:			
7595:			
7596:			
7597:			
7598:	2ED0          	OP1000:
7599:	2ED0  FDDDEDCB		DEFB	 0FDH,0DDH,0EDH,0CBH
7600:			
7601:			
7602:			
7603:	2ED4  88      	PSWBIT:	DEFB	10001000B		;minus
7604:	2ED5  80      		DEFB	10000000B		;positive
7605:	2ED6  0C      		DEFB	00001100B		;even parity
7606:	2ED7  04      		DEFB	00000100B		;odd parity
7607:	2ED8  48      		DEFB	01001000B		;zero
7608:	2ED9  40      		DEFB	01000000B		;not zero
7609:	2EDA  09      		DEFB	00001001B		;carry
7610:	2EDB  01      		DEFB	00000001B		;no carry
7611:			
7612:	2EDC  12071311	PSWMAP:	DEFB	18,07,19,17,21,20,10,22
	      15140A16
7613:	0008          	PSWCNT	EQU	$-PSWMAP
7614:			
7615:			
7616:	2EE4          	REGMAP:
7617:	2EE4  87010706		DEFB	87H,01H,07H,06H,05H,04H
	      0504
7618:	2EEA  03029593		DEFB	03H,02H,95H,93H,91H,18H
	      9118
7619:	2EF0  19818385		DEFB	19H,81H,83H,85H,97H
	      97
7620:			
7621:	2EF5          	REGPTR:
7622:	2EF5  0D0E0F00		DEFB	0DH,0EH,0FH,00H
7623:	2EF9  8D8E8F80		DEFB	8DH,8EH,8FH,80H
7624:	2EFD  0A090810		DEFB	0AH,09H,08H,10H
7625:			
7626:	2F01  F5F7    	SIOTBL:	DEFB	0F5H,0F7H
7627:			
7628:	2F03  FF      	SYMFLG:	DEFB	0FFH		;symbol	table flag   00	- table	present
7629:							;		     ff	- no table
7630:			
7631:	2F04          	BSIZ:				;dump block size storage
7632:	2F04  00      	BSIZLO:	DEFB	0		;     lo order
7633:	2F05  01      	BSIZHI:	DEFB	1		;     hi order
7634:	2F06  0001    	BLKPTR:	DEFW	100H		;dump block address
7635:			
7636:	2F08  0001    	LOADB:	DEFW    100H		;z8e load bias for lldr command
7637:	2F0A  0000    	LOADN:	DEFW	00		;end of load address
7638:			
7639:	2F0C          	ASMBPC:				;next pc location for assembly
7640:	2F0C  0001    	ZASMPC:	DEFW	100H		;next pc location for disassemble
7641:							;default at load time: start of	tpa
7642:	2F0E  0000    	ZASMFL:	DEFW	00		;first disassembled address on jdbg screen
7643:			
7644:			
7645:	2F10          	FROM:
7646:	2F10          	OPRN01:
7647:	2F10          	RLBIAS:
7648:	2F10          	LINES:
7649:	2F10          	EXAMPT:
7650:	2F10          	ENDW:
7651:	2F10  00      	ZASMNX:	DEFB	0		;address of next instruction to	disassemble
7652:	2F11  00      	OPRX01:	DEFB	0
7653:	2F12          	BIAS:
7654:	2F12          	BIASLO:
7655:	2F12  00      	ZASMCT:	DEFB	0		;disassembly count
7656:	2F13          	BIASHI:
7657:	2F13  00      	OPRN02:	DEFB	0
7658:	2F14          	OPRX02:
7659:	2F14  0000    	ZASMWT:	DEFW	0		;disassembly count - working tally
7660:	2F16  00      	OPNFLG:	DEFB	0		;00 - operand 1   ff - operand 2   zasm
7661:							;and input character storage for interactive
7662:							;disassembly
7663:	2F17  00      	QUOFLG:	DEFB	0
7664:	2F18  FF      	WFLAG:	DEFB	0FFH		;trace subroutine flag:	nz - trace subs
7665:							;			 z - no	trace
7666:			
7667:	2F19          	NSTEP:
7668:	2F19  00      	NSTEPL:	DEFB	0
7669:	2F1A  00      	NSTEPH:	DEFB	0
7670:			
7671:	2F1B  00      	SBPS:	DEFB	0		;number	of step	breakpoints
7672:	2F1C  00      	BPS:	DEFB	0		;number	of normal breakpoints
7673:			
7674:	2F1D  00      	ZMFLAG:	DEFB	0
7675:	2F1E  00      	ZASMF:	DEFB	0
7676:	2F1F          	EXECBF:				;execute buffer	for relocated code
7677:	2F1F          	JLINES:
7678:	2F1F          	PARENF:
7679:	2F1F  00      	NUMENT:	DEFB	0		;number	of digits entered
7680:	2F20  00      	DELIM:	DEFB	0		;argument delimeter character
7681:	2F21  00      		DEFB	0
7682:	2F22  00      	BASE10:	DEFB	0
7683:	2F23  00      	JMP2JP:	DEFB	0
7684:	2F24  00      	JMP2:	DEFB	0
7685:	2F25          	DWRITE:
7686:	2F25  00      	CFLAG:	DEFB	0
7687:			
7688:	2F26          	IKEY:
7689:	2F26          	ZASMKV:
7690:	2F26  00      	SJMP:	DEFB	0
7691:	2F27          	MEXP:
7692:	2F27  00      	JMPLO:	DEFB	0
7693:	2F28          	STRNGF:
7694:	2F28  00      	JMPHI:	DEFB	0
7695:	2F29          	TIMER:
7696:	2F29  00      	FIRST:	DEFB	0
7697:	2F2A  00      	REGTRM:	DEFB	0
7698:	2F2B  00      	TRMNTR: DEFB	0
7699:	2F2C  0000    	ISYMPT:	DEFW	0
7700:			
7701:	2F2E          	JROPND:
7702:	2F2E  0000    	PASS2:	DEFW	0
7703:			
7704:	2F30  0000    	FNDSYM:	DEFW	0
7705:			
7706:	0000          	    IF	ASMB
7708:			    ELSE
7709:	2F32          	MAXLEN:
7710:			    ENDIF
7711:	2F32  0E00    		DEFW	14
7712:			
7713:	2F34  3E00    	MAXLIN:	DEFW	62
7714:			
7715:	2F36  00      	FWNDOW:	DEFB	00
7716:			
7717:	2F37  00      	NLMASK:	DEFB	00
7718:			
7719:	0000          	    IF	ASMB
7721:			    ELSE
7722:	2F38          	CASE:
7723:			    ENDIF
7724:	2F38  00      		DEFB	000H		;flag to indicate case of output
7725:	2F39  FF      		DEFB	0FFH		;flag to indicate case of output
7726:							;nz - lower   z - upper
7727:			
7728:	2F3A  FF      	JSTEPF:	DEFB	0FFH		;00 -   screen is intact, if user wants j
7729:							;       single step no need to repaint screen,
7730:							;       just move arrow.
7731:							;01   - user wants single-step j command
7732:							;else - j screen corrupted by non-j command
7733:			
7734:	2F3B  03      	LASTRO:	DEFB	03
7735:			
7736:	0000          	    IF	ASMB
7738:			    ELSE
7739:	2F3C          	ROWB4X:
7740:			    ENDIF
7741:			;     IF JTERM			;my terminal uses xy addressing
7742:	2F3C  00      		DEFB	0
7743:			;     ELSE			;most others use yx
7744:			; 	DEFB	1
7745:			;     ENDIF
7746:			
7747:	0000          	    IF	ASMB
7749:			    ELSE
7750:	2F3D          	MXYCP:
7751:			    ENDIF
7752:			;     IF JTERM
7753:			; 	DEFB	1,9		;jrs special (Datapoint 8227)
7754:			;     ELSE
7755:			;     IF Z80DS
7756:	2F3D  011B    	    	DEFB	1,ESC
7757:			;     ELSE
7758:			; 	DEFB	2,1BH,'='	;ADM 3a in "standard" version
7759:			; 	DEFB	0,0,0,0,0,0,0,0
7760:			;     ENDIF
7761:			;     ENDIF
7762:			
7763:	2F3F  00      	XYROW:	DEFB	0
7764:	2F40  00      	XYCOL:	DEFB	0
7765:			
7766:	0000          	    IF	ASMB
7768:			    ELSE
7769:	2F41          	ROW:
7770:			    ENDIF
7771:	0000          	    IF JTERM				;my terminal uses no bias for
7773:			    ELSE
7774:	2F41  20      		DEFB	' '			;bias for most other terminals
7775:			    ENDIF
7776:	0000          	    IF	ASMB
7778:			    ELSE
7779:	2F42          	COLUMN:
7780:			    ENDIF
7781:	0000          	    IF JTERM				;see above
7783:			    ELSE
7784:	2F42  20      		DEFB	' '
7785:			    ENDIF
7786:			
7787:	2F43  0000    	WNWTAB:	DEFW	0
7788:	2F45  0000    	WNWSIZ:	DEFW	0
7789:			
7790:	2F47  0000    	PORT:	DEFW	0
7791:			
7792:	2F49 .. 2F7E 00	BRKTBL:	DEFS	(MAXBP+2)*3
7793:	2F7F .. 2F9E 00	PSCTBL:	DEFS	MAXBP*2
7794:			
7795:			
7796:	2F9F          	REGCON:
7797:	2F9F          	AFREG:
7798:	2F9F  00      	FREG:	DEFB	00
7799:	2FA0  00      		DEFB	00
7800:	2FA1  0000    	BCREG:	DEFW	00
7801:	2FA3  0000    	DEREG:	DEFW	00
7802:	2FA5  0000    	HLREG:	DEFW	00
7803:	2FA7  0000    	AFPREG:	DEFW	00
7804:	2FA9  0000    	BCPREG:	DEFW	00
7805:	2FAB  0000    	DEPREG:	DEFW	00
7806:	2FAD  0000    	HLPREG:	DEFW	00
7807:	2FAF          	PCREG:
7808:	2FAF  00      	PCREGL:	DEFB	00
7809:	2FB0  01      	PCREGH:	DEFB	01
7810:	2FB1  0000    	SPREG:	DEFW	00
7811:	2FB3  0000    	IXREG:	DEFW	00
7812:	2FB5  0000    	IYREG:	DEFW	00
7813:			
7814:	0018          	REGSIZ	EQU	$-REGCON
7815:			
7816:	2FB7  00      	RREG:	DEFB	00
7817:	2FB8  00      	IREG:	DEFB	00
7818:			
7819:			
7820:	2FB9  0000    	FSTART:	DEFW	0
7821:	2FBB  0000    	ARGBC:	DEFW	0
7822:	2FBD  BF2F    	ARGBPT:	DEFW	ARGBF
7823:			
7824:	2FBF          	REGSAV	EQU	$		;storage for register contents in between bps
7825:							;while jdbg is in control
7826:			
7827:	2FD7          	WINDOW	EQU	REGSAV+REGSIZ	;memory window save area
7828:			
7829:	003E          	ARGBSZ	EQU	62
7830:			
7831:	2FBF .. 2FFC 00	ARGBF:	DEFS	ARGBSZ
7832:			
7833:	2FD9          	FCB	EQU     ARGBF+ARGBSZ-36 ;cp/m file control block
7834:	2FDA          	FCBNAM	EQU	FCB+1		;start of file name in fcb
7835:	2FE2          	FCBTYP	EQU	FCBNAM+8	;start of file type in fcb
7836:	2FE5          	FCBEXT	EQU	FCBTYP+3	;current extent	number
7837:	2FFD          	NFCB	EQU	$		;last byte of fcb plus one
7838:			
7839:	00A4          	GPBSIZ	EQU	164		;size of general purpose buffer
7840:			
7841:	2FFD          	SYMBUF:
7842:	2FFD          	OBJBUF:				;object	code buffer
7843:	2FFD .. 30A0 00		DEFS	GPBSIZ
7844:			;	REPT	GPBSIZ
7845:			;	DEFB	0
7846:			;	ENDM
7847:	0052          	INBFSZ	EQU	GPBSIZ/2
7848:	3001          	INBFMX	EQU	OBJBUF+4	;input buffer -	max byte count storage
7849:	3002          	INBFNC	EQU	INBFMX+1	;	      -	number chars read in
7850:	3003          	INBF	EQU	INBFNC+1	;	      -	starting address
7851:	0051          	INBFL	EQU	INBFSZ-1	;	      -	last relative position
7852:	3054          	NINBF	EQU	INBF+INBFL	;	      -	address	of last	char
7853:			
7854:	0052          	PRSBFZ	EQU	GPBSIZ/2
7855:	3055          	PRSBF	EQU	INBF+INBFSZ	;parse buffer -	starting address
7856:	30A6          	LPRSBF	EQU	PRSBF+PRSBFZ-1	;	      -	last char of parse buf
7857:	30A7          	NPRSBF	EQU	LPRSBF+1	;	      -	end address plus one
7858:			
7859:	30A1          	NZASM	EQU	$		;end of disassembly buffer
7860:	3021          	ZASMBF	EQU	NZASM-128	;start of disassembly buffer
7861:			
7862:	30A1 .. 30C8 00		DEFS	40
7863:	30C9          	STACK:
7864:	2500          	NMEM	EQU	((($+255) AND 0FF00H)-Z8EORG) AND 0FF00H
7865:			;	was	(256*(($+255)/256)-z8eorg) and 0ff00h
7866:			
7867:	0000          		IF	M80
7869:				ENDIF
7870:	30C9          		END



Statistics:

     9	passes
     0	jr promotions
   948	symbols
     0	bytes



Symbol Table:

afpreg          2fa7     intren         =fdfe+    rfsym20          3d4     
afreg           2f9f     iobuf          =  80+    rfsym21          3f0     
argbc           2fbb     ireg            2fb8     rfsym22          40d     
argbf           2fbf     irsm            26a1     rfsym23          41a     
argbpt          2fbd     irt            =  c9+    rfsym25          431     
argbsz         =  3e+    istr            2695     rfsym30          446     
asci            2873     isym            1a32     rfsym35          46c     
asci00          287e     isym00          1a3d     rfsym40          476     
asm000          15d5     isympt          2f2c     rfsym45          47e     
asm005          15de     ixlt            2632     rfsym50          492     
asm010          15e1     ixreg           2fb3     rgdisp           fa1     
asm015          15f1     iyreg           2fb5     rgst            11b9     
asm030          1622     jdbg             db0     rgst00          11dd     
asm040          1637     jdbg00           db6     rgst10          11f8     
asm050          1641     jdbg01           dd5     rgst15          1201     
asm060          1653     jdbg02           dd9     rgst20          121c     
asm070          1659     jdbg03           df4     rgst22          1224     
asm085          169a     jdbg05           df7     rgst25          1239     
asm090          169c     jdbg08           e08     rgst30          123e     
asm095          16bb     jdbg10           e18     rgst40          1245     
asmb           =   0+    jdbg15           e1d     rix            =   8+    
asmblr          15cf     jdbg20           e37     riy            =  10+    
asmbpc          2f0c     jdbg25           e42     rlbias          2f10+    
asmflg          29e5     jdbg28           e5e     rldrom         =fe79+    
asmxxl          1aa5     jdbg2a           de5     rlstsz         =  11+    
asmxxo          1aa9     jdbg30           e63     rlstxx           8d3     
asmxxp          1aad+    jdbg35           e6f     rm80sz         =   8+    
asmxxs          1ab1     jdbg40           e79     rm80xx           904     
asmxxt          1ab5     jdbg42           e8f     row             2f41     
asmxxu          16be     jdbg45           ea0     rowb4x          2f3c     
asmxxv          1ab9     jdbg50           ec6     rpr325           4f0     
asmxxx          1abb     jdbg55           ed5     rpr330           507     
aterm          =   0+    jdbg60           ede     rpr335           513     
base10          2f22     jdbg65           ee7     rpr340           525+    
bbcalret       =fd5a+    jdbg70           f10     rpr342           532     
bbconin        =fd94+    jdbg75           f17     rpr345           53a     
bbconout       =fd9f+    jdbg78           f4c     rpr350           551     
bbconst        =fdaa+    jdbg80           f50     rpr351           55e     
bbcpboot       =fcc3+    jdbg90           f53     rpr352           571     
bbcrtcini      =fc03+    jdbg95           f61     rpr355           575     
bbcrtfill      =fc09+    jlines          2f1f     rpr357           57a     
bbcurset       =fc21+    jmp2            2f24     rpr370           591     
bbdiv16        =fcdb+    jmp2jp          2f23     rpr4             598     
bbdmaset       =fcb7+    jmphi           2f28     rpr410           5af     
bbdprmset      =fd17+    jmplo           2f27     rpr420           5ba     
bbdriveid      =fcf3+    jropnd          2f2e     rpr421           5da     
bbdsksel       =fcbd+    jstepf          2f3a     rpr425           5ee     
bbeidck        =fd23+    jtcmd           2977     rpr430           5fb     
bbepmngr       =fd1d+    jterm          =   0+    rpr435           616     
bbexec         =fd29+    kdmp            1420     rpr438           621     
bbfdrvsel      =fcd5+    kdmp00          1443     rpr440           62e     
bbfhome        =fc81+    kdmp20          144a     rpr450           640     
bbflopio       =fc93+    lastro          2f3b     rprn             49b     
bbfread        =fc87+    lbin            1dad     rprn00           4db     
bbfwrite       =fc8d+    lbin00          1db0     rprnaa           4b0     
bbhdboot       =fd0b+    lbin20          1dd0     rprnbb           4b9     
bbhdgeo        =fd05+    lbin22          1dd5     rprncc           4d2+    
bbhdinit       =fced+    lbin25          1dff     rprnsz         =   a+    
bbhdrd         =fcff+    lbin30          1e04     rprnxx           8e5     
bbhdwr         =fcf9+    lbin35          1e07     rreg            2fb7     
bbinictc       =fc57+    lbin40          1e16     rslr             647     
bbjtobnk       =fc00+    lcmd            29e7     rslrsz         =  13+    
bbldpart       =fd11+    lf             =   a+    rslrxx           8f0     
bbmul16        =fce1+    lfcb            1e50     rslv            17c8     
bboffcal       =fce7+    lfcb00          1e68     rslv00          17cf     
bbprcvblk      =fc6f+    lfcb10          1e81     rslv10          17db     
bbprnchr       =fc99+    lfcb20          1e86     rslv20          17df     
bbpsndblk      =fc63+    lfcb30          1e8f+    rslv25          17fc     
bbrdtime       =fca5+    lfcb90          1e9a     rslv30          1802     
bbrdvdsk       =fc75+    lfcb95          1eaf     rslv35          1811     
bbresctc       =fc5d+    lfcb96          1eb1     rslv40          1819     
bbsecset       =fcb1+    lines           2f10     rslv50          1824     
bbsidset       =fccf+    lldr            1d5b     rslv60          1834     
bbstack        =feb4+    lldr00          1d71     rslv70          184e     
bbstbase       =fe90+    lldr05          1d9c     rspace          264d     
bbsttim        =fc9f+    lldr10          1da4     rst38          =  cf+    
bbtrkset       =fcab+    load             6cc     rstvec           103     
bbu0ini        =fc39+    load00           6dd     rtin            26be     
bbu1ini        =fc51+    load20           77a     sbps            2f1b     
bbu1rx         =fc45+    load30           782     sconin         =fc2d+    
bbu1st         =fc4b+    load40           787     sconout        =fc27+    
bbu1tx         =fc3f+    load50           7c5     sconst         =fc33+    
bbuplchr       =fc69+    load60           7cf     sintvec        =fff0+    
bbvcpmbt       =fcc9+    loadb           2f08     siotbl          2f01+    
bbvoid         =fd6a+    loadn           2f0a     six             2945     
bbwrvdsk       =fc7b+    lopn            1eb7     siy             2955     
bcde            2584     lopn00          1ebe+    sjmp            2f26     
bcdx            2883     lopn10          1ec6     slr            =ffff+    
bcdx00          2887     lprsbf         =30a6+    space5          2652     
bcpreg          2fa9     m80            =   0+    spaces          2654     
bcreg           2fa1     maxbp          =  10+    spreg           2fb1     
bdos           =   5+    maxlen          2f32     srch            1f9d     
bdwrit          2371     maxlin          2f34     srch00          1fa0     
bias            2f12     mbannr           105     srch10          1faa     
biashi          2f13     mcntu           2a38     stack           30c9     
biaslo          2f12     mexp            2f27     star             915     
bidprn           914+    mfilnf          29f6     step            156b     
binx            267c     mhex             918     step20          1593     
binx00          2680     minvof           965     step40          15a3     
bksp            2868     mireg           2a46+    step50          15b6     
bksp00          286e     mldg            29ec     stlone         =   0+    
bldf            238d     mlodm           2a07     strngf          2f28     
bldf00          239e     mlodpg          2a11     symbuf          2ffd     
blkptr          2f06     mmemxx          2a2a     symflg          2f03     
bpemsg          29c8     mmgetp         =fd78+    syscmlo        =feb4+    
bphn             ca0     mmpmap         =fd6b+    syscom         =fc00+    
bphn10           ced     mnvmem           9ab     sytimr         =fe19+    
bphn20           d01     movb            1c66     tab            =   9+    
bphn30           d22     movb00          1c84     tilde          =  7e+    
bphn35           d2f     mreg            124e     timer           2f29     
bphn50           d49     mreg00          1265     totsym           85c     
bphn60           d5f     mreg05          126d     trmntr          2f2b     
bphn90           d7e     mreg10          1276     true           =ffff+    
bpmsg           29cf     mreg50          1282     tsym             90d     
bps             2f1c     mrrow           29db     tsymbb           938     
bpxxx            d98     msntx           2a1b     tsymhi           90d     
break           1312     msymbb           91d     tsymlo           90e     
brk10           1318     msymld           983     ttyi            25bd     
brk30           1328     msymnf           94c     ttyi00          25c0     
brk40           132f     mxx             29e0+    ttyo            25dd     
brk50           1341     mxxxx           29de     ttyo00          25e1     
brk60           1345     mxycp           2f3d     ttyq            259d     
brk70           134d     mz8eld           997     u0isr          =fe25+    
brk80           1356     nchr             7d6     u1isr          =fe59+    
brktbl          2f49     ncmd           =  1b+    u1nul          =fe70+    
bs             =   8+    newlin          265b     uastav         =fe84+    
bsiz            2f04     nfcb           =2ffd+    uastkb         =fe86+    
bsizhi          2f05     ninbf          =3054+    uisre          =fe4e+    
bsizlo          2f04     nint             190     uisri          =fe32+    
byte10          279a     nint00           1d5     usym            107f     
byte15          27a2     nint03           1ee     usym10          1099     
byte30          27ac     nint05           200     usym20          10bc     
bytes            9c3     nint10           20f     usym25          10d0     
case            2f38     nint15           223     usym40          10dd     
cbreak          1375     nint20           22d     usymbl           90f     
cbrk10          139a     nint22           23a     vconin         =fc15+    
cbrk20          13a1     nint25           242     vconout        =fc0f+    
cbrk30          13aa     nint30           259     vconst         =fc1b+    
cflag           2f25     nint35           265     verf00          1fb5     
clok             fd4     nint40           26a     verf10          1fd0     
clok10           fda     nint45           278     verify          1fae     
closef          2352     nint50           27f     voidisr        =fe22+    
cmd             29ad     nint55           285     wflag           2f18     
column          2f42     nint60           28a     window         =2fd7+    
comask           104     nint70           2a8     wnwsiz          2f45     
compact        =   0+    nint71           2b5     wnwtab          2f43     
cr             =   d+    nint75           2b0     writ            1ef2     
crdureg        =fc27+    nint80           2c5     writ10          1f0a     
cret            2645     nint85           2ec     writ20          1f16+    
crlf            263b     nint90           2ee     writ30          1f1c     
ctlc           =   3+    nint95           309     writ40          1f2e     
ctlx           =  18+    nlmask          2f37     writ50          1f37     
curs             fad     nmem           =2500+    write           235a     
curs00           fb5+    nprint          289b     wrt10           236e     
curs20           fba+    nprsbf         =30a7+    xreg            1fd8     
curs30           fc4+    nprt            1284     xreg00          1fde     
curs40           fc6     nrel            2935     xreg05          2001     
cuser           1ca5     nstep           2f19     xreg10          201c     
cusok           1cc0     nsteph          2f1a+    xreg20          2029     
del            =  7f+    nstepl          2f19+    xreg30          2038     
delay          =fd85+    nsym             916     xsym            2575     
delim           2f20     nsymhi           916     xsym00          257a     
depreg          2fab     nsymlo           917     xval            18ef     
dereg           2fa3     ntpa             9c1     xval00          18f4     
disisr          1d4b     nument          2f1f+    xval05          1903     
dly1           =fd89+    nzasm          =30a1+    xval10          1922     
dly2           =fd87+    objbuf          2ffd     xval15          1928     
dump            1117     obreak          13d7     xval20          1931     
dump00          1126     obrk00          13dd     xval25          1940     
dump15          1137     obrk10          1404     xval30          1952     
dump20          1140     obrk20          1413     xval35          195d     
dump25          1145     op1000          2ed0     xval40          1986     
dump30          1149     opn             21d5     xval50          198b     
dump40          115c     opn010          21dc     xval55          199a     
dump50          116e     opn012          21df     xval60          199e     
dump55          117b     opn014          21e7     xval61          19b5     
dump60          1189     opn015          21f3     xval62          19c2     
dump70          118c     opn020          21fe     xval65          19cb     
dump80          1193     opn030          2206     xval90          19d7     
dwrite          2f25     opn035          221b     xval95          19e7     
efilnf          1ee9     opn040          2224     xycol           2f40+    
ememxx          1ee1     opn041          222b+    xycp            28b5     
emxxx           29e8     opn042          2231     xycp00          28c6     
enaisr          1d53     opn043          223d     xycp10          28d7     
endw            2f10     opn044          2246     xyrow           2f3f+    
eof            =  1a+    opn045          2297     yfil            1c8b     
eprint          1eec     opn046          22a0     yfil00          1c92     
esc            =  1b+    opn048          22c0     yfil10          1c98     
esntx           1edc     opn049          22d3     yfil20          1ca0     
exam             fe1     opn050          22dd     z801            2a5b     
exam00           fe8     opn055          22e6     z801l          =   a+    
exam10           ffd     opn060          22f0     z802            2a65     
exampt          2f10     opn065          2300     z802c           2a70     
execbf          2f1f     opn080          231c     z802cl         =   6+    
exicpm          2626     opn085          2331     z802l          =  11+    
exxx             da7     opn090          2338     z803            2a76     
fadr            254b     opn095          2344     z803c           2a87     
fadr00          2556     opn100          23a8     z803cl         =  12+    
fadr10          2568     opn105          23b5     z803l          =  1a+    
fadr20          256c     opn200          23c5     z803s           2a7e     
fadr30          2572     opn205          23d6     z803sl         =   9+    
false          =   0+    opn210          23de     z80ds          =ffff+    
fcb            =2fd9+    opn215          23f4     z80ed           2a90     
fcb5c          =  5c+    opn220          2400     z80edl         =   6+    
fcbext         =2fe5+    opn300          2409     z80f3           2a96     
fcbnam         =2fda+    opn310          2415     z80f3l         =  18+    
fcbtyp         =2fe2+    opn315          2416     z80f4           2a56     
feof             65f     opn316          2424     z80f4l         =   5+    
feof10           691     opn320          2438     z80fd           2a4b     
feof20           699     opn400          243e     z80fdl         =   b+    
feof50           6c5     opn410          244b     z80r            2a76     
fin            =fdc4+    opn500          2454     z80rl          =  20+    
find            1f4b     opn600          2468     z8e              c10     
find00          1f56+    opn605          2473     z8e00            c50     
find40          1f75     opn606          247e     z8e10            c5d     
find50          1f7c     opn610          249a+    z8e16            c79     
find60          1f96     opn620          24a2     z8e20            c86     
first           2f29+    opn700          24b4     z8eb             9bf     
fndsym          2f30     opn800          24c3     z8ebh            9c0     
formf          =   c+    opn810          24ce     z8ecmd           c14     
fout           =fde1+    opn820          24d9     z8ej            1e45     
freg            2f9f     opn830          24de     z8eorg           c00     
from            2f10+    opnflg          2f16     z8esp            c12     
fstart          2fb9+    opnm            178a     zasc10          253d     
fstat          =fdb5+    opnm00          17a2     zasc20          253f     
fstr00           8b8     opnm10          17ad+    zascii          2530     
fstr10           8bf     opnm20          17b2     zasm            2047     
fstr20           8d0     opnm30          17b8     zasm0           205a     
fstrng           8b6     opnm40          17c1     zasm00          206a     
fsym            19f3     opnv            1ae3     zasm05          2074     
fsym00          19f6     opnv00          1aed     zasm06          207e     
fsym10          1a11     oprn            1855     zasm08          208c     
fsym20          1a1f     oprn00          1858     zasm10          208f     
fsym30          1a2a     oprn01          2f10     zasm15          2093     
fwndow          2f36     oprn02          2f13     zasm18          209b     
g001            145d     oprn20          1867     zasm20          20a7     
g002            1463     oprn25          1871     zasm25          20b8     
g100            1469     oprn30          1882     zasm30          20c3     
g300            1481     oprn35          189e     zasm35          20cb     
g400            1496     oprn40          18af     zasm40          20ea     
g500            1499     oprn50          18d1     zasm42          20fc     
g505            14b3     oprn70          18d6     zasm45          2102+    
g518            14c3     oprn80          18de     zasm50          2106     
g520            14c6     oprn85          18e1     zasm55          211e     
g550            1506     oprtor          1adb     zasm60          212f     
g555            1527     oprx01          2f11+    zasm65          2139     
g600            1530     oprx02          2f14+    zasm70          214f     
go              1452     othxsp          264a     zasm75          2160     
gpbsiz         =  a4+    outadr          2664     zasm80          2164     
hazeltine      =   0+    outbyt          2762     zasm85          2172     
hex              80e     outhex          266e     zasm90          2177     
hex00            811     parenf          2f1f     zasm92          219d     
hex10            818     parg            26df     zasm95          21a8     
hex30            845     parg00          2715     zasm97          21b9     
hexc             7fb     parg10          271d     zasm99          21c9     
hexc00           805     parg50          2726     zasmbf         =3021+    
hlpreg          2fad     parg60          2733     zasmct          2f12     
hlreg           2fa5     parg65          2742     zasmf           2f1e     
home            28b2     parg70          2748     zasmfl          2f0e     
hsym            1019     parg80          2756     zasmio          2975     
hsym10          1030     parg90          2759     zasmkv          2f26     
iarg            26d4     pass2           2f2e     zasmnx          2f10     
ibl00           1d45     pbin            10fb     zasmpc          2f0c     
iblank          1d43     pbin00          10ff     zasmwt          2f14     
ibld            16c3     pcreg           2faf     zbuf             9c4     
ibld00          16ce     pcregh          2fb0     zbufnm           9c5     
ibld10          16e1     pcregl          2faf     zdlm            1ad0     
ibld20          16e9     pcrlf           10f2     zdlm00          1ad3     
ibld30          16f5     port            2f47     zdread           7de     
ibld40          1705     print           289e     zfnf             88b     
ibld50          1711     printb          28a7     zhex            24fd     
ibld55          1716     prompt          29d7     zhex00          2507     
ibld60          173b     prsbf          =3055+    zhex10          250b     
ibld65          1768     prsbfz         =  52+    zhex20          251a     
ibld70          1771     prsr            1a56     zlen00          1af3     
ibld75          1775     prsr10          1a60     zlen10          1b14     
ibld80          177b     prsr20          1a6d     zlen15          1b19     
ibld90          1784+    prsr30          1a7f     zlen20          1b21     
iedt            27b9     prsr50          1a8e     zlen30          1b34     
iedt00          27bf     prsr60          1a9e     zlen40          1b4a     
iedt03          27cd     psctbl          2f7f     zlen50          1b5a     
iedt05          27d3     pstrng           911     zlen55          1b86     
iedt10          27ef     psw00           1bfc     zlen58          1b92     
iedt15          27fe     psw10           1c15     zlen60          1b99     
iedt20          2801     psw50           1c33+    zlen65          1bb5     
iedt25          2805     psw55           1c37     zlen70          1bbe     
iedt35          2814     psw60           1c60     zlen80          1bd1     
iedt40          2826     pswbit          2ed4     zlen85          1bdc     
iedt50          282a     pswcnt         =   8+    zmem             894     
iedt55          2840     pswdsp          1bf7     zmflag          2f1d     
iedt58          2845     pswmap          2edc     zmqf            2525     
iedt60          2857     putc            110a     zndx            24e4     
iedt70          285c     putc00          110e+    zndx00          24f8     
iedt90          2861     qev01           1cf5     znmbuf           9d4     
iedtbc          27b2     qeval           1cc6     zoff             8aa     
ifcb            1cf8     qprt            1284     zopcnm          2db0     
ifcb00          1d02     qprt00          12a7     zopcpt          2ab0     
ifcb02          1d18     qprt10          12b5     zopjtb         =  30+    
ifcb12          1d33     qprt20          12d3     zopjtl         =   9+    
ijp            =  c3+    qprt30          12da     zopnd1          2bb0     
ikey            2f26     qprt50          12f4     zopnd2          2cb0     
ilcs            2629     qprt60          130b     zopnm           2935     
ilin            2689     quoflg          2f17     zopnml         =  18+    
imem            1ed2     quote          =  27+    zoprjt          2965     
in00            26c2     rbyte           2772     zstx             86c     
in10            26cc     regcon          2f9f     zsym             311     
inbf           =3003+    regmap          2ee4     zsym00           364     
inbfl          =  51+    regptr          2ef5     zsym05           371     
inbfmx         =3001+    regsav         =2fbf+    zsym10           383     
inbfnc         =3002+    regsiz         =  18+    zwnw             f6f     
inbfsz         =  52+    regtrm          2f2a     zwnw05           f71+    
inchar          25fd     relchr           913     zwnw10           f77     
init             a1c     rfsym            3a4     zwnw20           f8a     
inop           =   0+    rfsym00          3b4     
intrdi         =fe0f+    rfsym10          3c5     
