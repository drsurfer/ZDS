CP/M RMAC ASSEM 1.1

CP/M RMAC ASSEM 1.1	#001	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	title	'CP/M BDOS Interface, BDOS, Version 3.0 Dec, 1982'
                ;*****************************************************************
                ;*****************************************************************
                ;**                                                             **
                ;**   B a s i c    D i s k   O p e r a t i n g   S y s t e m    **
                ;**								**
                ;**            I n t e r f a c e   M o d u l e                  **
                ;**                                                             **
                ;*****************************************************************
                ;*****************************************************************
                ;
                ;	Copyright (c) 1978, 1979, 1980, 1981, 1982
                ;	Digital Research
                ;	Box 579, Pacific Grove
                ;	California
                ;
                ;       December 1982
                ;
 FFFF =         on	equ	0ffffh
 0000 =         off	equ	00000h
 0000 =         MPM	equ	off
 FFFF =         BANKED	equ	on
                
                ;
                ;	equates for non graphic characters
                ;
                
 0001 =         ctla	equ	01h	; control a
 0002 =         ctlb	equ	02h	; control b
 0003 =         ctlc	equ	03h	; control c
 0005 =         ctle	equ	05h	; physical eol
 0006 =         ctlf	equ	06h	; control f
 0007 =         ctlg	equ	07h	; control g
 0008 =         ctlh	equ	08h	; backspace
 000B =         ctlk	equ	0bh	; control k
 0010 =         ctlp	equ	10h	; prnt toggle
 0011 =         ctlq	equ	11h	; start screen
 0012 =         ctlr	equ	12h	; repeat line
 0013 =         ctls	equ	13h	; stop screen
 0015 =         ctlu	equ	15h	; line delete
 0017 =         ctlw	equ	17h	; control w
 0018 =         ctlx	equ	18h	; =ctl-u
 001A =         ctlz	equ	1ah	; end of file
 007F =         rubout	equ	7fh	; char delete
 0009 =         tab	equ	09h	; tab char
 000D =         cr	equ	0dh	; carriage return
 000A =         lf	equ	0ah	; line feed
 005E =         ctl	equ	5eh	; up arrow
                
 0000           		org	0000h
 0000 =         base		equ	$
                
                ; Base page definitions
                
 FC00 =         bnkbdos$pg	equ	base+0fc00h
 FD00 =         resbdos$pg	equ	base+0fd00h
CP/M RMAC ASSEM 1.1	#002	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 FB00 =         scb$pg		equ	base+0fb00h
 FF00 =         bios$pg		equ	base+0ff00h
                
                ; Bios equates
                
 FF00 =         bios		equ	bios$pg
 FF00 =         bootf		equ	bios$pg 	; 00. cold boot function
                
                if BANKED
                
 FB68 =         wbootf		equ	scb$pg+68h	; 01. warm boot function
 FB6E =         constf		equ	scb$pg+6eh  	; 02. console status function
 FB74 =         coninf		equ	scb$pg+74h	; 03. console input function
 FB7A =         conoutf		equ	scb$pg+7ah	; 04. console output function
 FB80 =         listf		equ	scb$pg+80h	; 05. list output function
                
                else
                
                wbootf		equ	bios$pg+3	; 01. warm boot function
                constf		equ	bios$pg+6	; 02. console status function
                coninf		equ	bios$pg+9	; 03. console input function
                conoutf		equ	bios$pg+12	; 04. console output function
                listf		equ	bios$pg+15	; 05. list output function
                
                endif
                
 FF12 =         punchf		equ	bios$pg+18	; 06. punch output function
 FF15 =         readerf		equ	bios$pg+21	; 07. reader input function
 FF18 =         homef		equ	bios$pg+24	; 08. disk home function
 FF1B =         seldskf		equ	bios$pg+27	; 09. select disk function
 FF1E =         settrkf		equ	bios$pg+30	; 10. set track function
 FF21 =         setsecf		equ	bios$pg+33	; 11. set sector function
 FF24 =         setdmaf		equ	bios$pg+36	; 12. set dma function
 FF27 =         readf		equ	bios$pg+39	; 13. read disk function
 FF2A =         writef		equ	bios$pg+42	; 14. write disk function
 FF2D =         liststf		equ	bios$pg+45	; 15. list status function
 FF30 =         sectran		equ	bios$pg+48	; 16. sector translate
 FF33 =         conoutstf	equ	bios$pg+51	; 17. console output status function
 FF36 =         auxinstf	equ	bios$pg+54	; 18. aux input status function
 FF39 =         auxoutstf	equ	bios$pg+57	; 19. aux output status function
 FF3C =         devtblf		equ	bios$pg+60	; 20. retunr device table address fx
 FF3F =         devinitf	equ	bios$pg+63	; 21. initialize device function
 FF42 =         drvtblf		equ	bios$pg+66	; 22. return drive table address
 FF45 =         multiof		equ	bios$pg+69	; 23. multiple i/o function
 FF48 =         flushf		equ	bios$pg+72	; 24. flush function
 FF4B =         movef		equ	bios$pg+75	; 25. memory move function
 FF4E =         timef		equ	bios$pg+78	; 26. system get/set time function
 FF51 =         selmemf		equ	bios$pg+81	; 27. select memory function
 FF54 =         setbnkf		equ	bios$pg+84	; 28. set dma bank function
 FF57 =         xmovef		equ	bios$pg+87	; 29. extended move function
                
                if BANKED
                
                ; System Control Block equates
                
 FB90 =         olog		equ	scb$pg+090h
CP/M RMAC ASSEM 1.1	#003	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 FB92 =         rlog		equ	scb$pg+092h
                
 FB9C =         SCB		equ	scb$pg+09ch
                
                ; Expansion Area - 6 bytes
                
 FB9C =         hashl		equ	scb$pg+09ch
 FB9D =         hash		equ	scb$pg+09dh
 FBA1 =         version		equ	scb$pg+0a1h
                
                ; Utilities Section - 8 bytes
                
 FBA2 =         util$flgs	equ	scb$pg+0a2h
 FBA6 =         dspl$flgs	equ	scb$pg+0a6h
                
                ; CLP Section - 4 bytes
                
 FBAA =         clp$flgs	equ	scb$pg+0aah
 FBAC =         clp$errcde	equ	scb$pg+0ach
                
                ; CCP Section - 8 bytes
                
 FBAE =         ccp$comlen	equ	scb$pg+0aeh
 FBAF =         ccp$curdrv	equ	scb$pg+0afh
 FBB0 =         ccp$curusr	equ	scb$pg+0b0h
 FBB1 =         ccp$conbuff	equ	scb$pg+0b1h
 FBB3 =         ccp$flgs	equ	scb$pg+0b3h
                
                ; Device I/O Section - 32 bytes
                
 FBB6 =         conwidth	equ	scb$pg+0b6h
 FBB7 =         column		equ	scb$pg+0b7h
 FBB8 =         conpage		equ	scb$pg+0b8h
 FBB9 =         conline		equ	scb$pg+0b9h
 FBBA =         conbuffadd	equ	scb$pg+0bah
 FBBC =         conbufflen	equ	scb$pg+0bch
 FBBE =         conin$rflg	equ	scb$pg+0beh
 FBC0 =         conout$rflg	equ	scb$pg+0c0h
 FBC2 =         auxin$rflg	equ	scb$pg+0c2h
 FBC4 =         auxout$rflg	equ	scb$pg+0c4h
 FBC6 =         lstout$rflg	equ	scb$pg+0c6h
 FBC8 =         page$mode	equ	scb$pg+0c8h
 FBC9 =         pm$default	equ	scb$pg+0c9h
 FBCA =         ctlh$act	equ	scb$pg+0cah
 FBCB =         rubout$act	equ	scb$pg+0cbh
 FBCC =         type$ahead	equ	scb$pg+0cch
 FBCD =         contran		equ	scb$pg+0cdh
 FBCF =         conmode		equ	scb$pg+0cfh
 FBD3 =         outdelim	equ	scb$pg+0d3h
 FBD4 =         listcp		equ	scb$pg+0d4h
 FBD5 =         qflag		equ	scb$pg+0d5h
                
                ; BDOS Section - 42 bytes
                
 FBD6 =         scbadd		equ	scb$pg+0d6h
 FBD8 =         dmaad		equ	scb$pg+0d8h
CP/M RMAC ASSEM 1.1	#004	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 FBDA =         olddsk		equ	scb$pg+0dah
 FBDB =         info		equ	scb$pg+0dbh
 FBDD =         resel		equ	scb$pg+0ddh
 FBDE =         relog 		equ	scb$pg+0deh
 FBDF =         fx		equ	scb$pg+0dfh
 FBE0 =         usrcode		equ	scb$pg+0e0h
 FBE1 =         dcnt		equ	scb$pg+0e1h
                ;searcha	equ	scb$pg+0e3h
 FBE5 =         searchl		equ	scb$pg+0e5h
 FBE6 =         multcnt		equ	scb$pg+0e6h
 FBE7 =         errormode	equ	scb$pg+0e7h
 FBE8 =         searchchain	equ	scb$pg+0e8h
 FBEC =         temp$drive	equ	scb$pg+0ech
 FBED =         errdrv      	equ	scb$pg+0edh
 FBF0 =         media$flag	equ	scb$pg+0f0h
 FBF3 =         bdos$flags	equ	scb$pg+0f3h
 FBF4 =         stamp		equ	scb$pg+0f4h
 FBF9 =         commonbase	equ	scb$pg+0f9h
 FBFB =         error		equ	scb$pg+0fbh	;jmp error$sub
 FBFE =         bdosadd		equ	scb$pg+0feh
                
                ; Resbdos equates
                
 FD00 =         resbdos		equ	resbdos$pg
 FD09 =         move$out	equ	resbdos$pg+9	; a=bank #, hl=dest, de=srce
 FD0C =         move$tpa	equ	resbdos$pg+0ch	; a=bank #, hl=dest, de=srce
 FD0F =         srch$hash	equ	resbdos$pg+0fh	; a=bank #, hl=hash table addr
 FD12 =         hashmx		equ	resbdos$pg+12h	; max hash search dcnt
 FD14 =         rd$dir$flag	equ	resbdos$pg+14h	; directory read flag
 FD15 =         make$xfcb	equ	resbdos$pg+15h	; make function flag
 FD16 =         find$xfcb	equ	resbdos$pg+16h	; search function flag
 FD17 =         xdcnt		equ	resbdos$pg+17h	; dcnt save for empty fcb,
                					; user 0 fcb, or xfcb
 FD19 =         xdmaad		equ	resbdos$pg+19h	; resbdos dma copy area addr
 FD1B =         curdma		equ	resbdos$pg+1bh	; current dma
 FD1D =         copy$cr$only	equ	resbdos$pg+1dh	; dont restore fcb flag
 FD1E =         user$info	equ	resbdos$pg+1eh	; user fcb address
 FD20 =         kbchar		equ	resbdos$pg+20h  ; conbdos look ahead char
 FD21 =         qconinx		equ	resbdos$pg+21h	; qconin mov a,m routine
                
                ELSE
                
                move$out	equ	movef
                move$tpa	equ	movef
                
                ENDIF
                
                ;
 0000 3635343332serial: db	'654321'
                ;
                ;	Enter here from the user's program with function number in c,
                ;	and information address in d,e
                ;
                
                bdose:	; Arrive here from user programs
 0006 EB22DBFBEB	xchg! shld info! xchg ; info=de, de=info
CP/M RMAC ASSEM 1.1	#005	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
 000B 7932DFFBFE	mov a,c! sta fx! cpi 14! jc bdose2
 0014 2100002298	lxi h,0! shld dircnt ; dircnt,multnum = 0
 001A 3ADAFB32A4	lda olddsk! sta seldsk ; Set seldsk
                
                if BANKED
 0020 3D32BC28  	dcr a! sta copy$cr$init
                ENDIF
                
                	; If mult$cnt ~= 1 then read or write commands
                	; are handled by the shell
 0024 3AE6FB3DCA	lda mult$cnt! dcr a! jz bdose2
 002B 219500    	lxi h,mult$fxs
                bdose1:
 002E 7EB7CA3B00	mov a,m! ora a! jz bdose2
 0033 B9CA3403  	cmp c! jz shell
 0037 23C32E00  	inx h! jmp bdose1
                bdose2:
 003B 7B329E28  	mov a,e! sta linfo ; linfo = low(info) - don't equ
 003F 210000229F	lxi h,0! shld aret ; Return value defaults to 0000
 0045 22DDFB    	shld resel ; resel,relog = 0
                	; Save user's stack pointer, set to local stack
 0048 39223203  	dad sp! shld entsp ; entsp = stackptr
                
                if not BANKED
                	lxi sp,lstack ; local stack setup
                ENDIF
                
 004C 213B28    	lxi h,goback ; Return here after all functions
 004F E5        	push h ; jmp goback equivalent to ret
 0050 79FE33D25D	mov a,c! cpi nfuncs! jnc high$fxs ; Skip if invalid #
 0056 4B        	mov c,e ; possible output character to c
 0057 21C600C36F	lxi h,functab! jmp bdos$jmp
                	; look for functions 98 ->
                high$fxs:
 005D FE80D25C01	cpi 128! jnc test$152
 0062 D662DAC015	sui 98! jc lret$eq$ff ; Skip if function < 98
 0067 FE0FD2C015	cpi nfuncs2! jnc lret$eq$ff
 006C 212C01    	lxi h,functab2
                bdos$jmp:
 006F 5F1600    	mov e,a! mvi d,0 ; de=func, hl=.ciotab
 0072 19195E2356	dad d! dad d! mov e,m! inx h! mov d,m ; de=functab(func)
 0077 2ADBFB    	lhld info ; info in de for later xchg
 007A EBE9      	xchg! pchl ; dispatched
                
                ;	   CAUTION: In banked systems only,
                ;          error$sub is referenced indirectly by the SCB ERROR
                ; 	   field in RESBDOS as (0fc7ch).  This value is converted
                ; 	   to the actual address of error$sub by GENSYS.  If the offset
                ; 	   of error$sub is changed, the SCB ERROR value must also
                ; 	   be changed.
                
                ;
                ;	error subroutine
                ;
                
CP/M RMAC ASSEM 1.1	#006	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                error$sub:
 007C 0600C50D  	mvi b,0! push b! dcr c
 0080 214A010909	lxi h,errtbl! dad b! dad b
 0085 5E2356EB  	mov e,m! inx h! mov d,m! xchg
 0089 CD8002    	call errflg
 008C C13AE7FBB7	pop b! lda error$mode! ora a! rnz
 0092 C32303    	jmp reboote
                
 0095 1415212228mult$fxs:	db	20,21,33,34,40,0
                
                	maclib	makedate
                if BANKED
                	@LCOPY
 009B+434F505952	DB	'COPYRIGHT 1998, '
 00AB+43414C4445	DB	'CALDERA, INC.   '
     +          	ENDM
                	@BDATE
 00BB+3130313139	DB	'101198'
     +          	ENDM
 00C1           	ds	5
                else
                	@SCOPY
                	@BDATE
                
                	;	31 level stack
                
                	dw	0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
                	dw	0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
                	dw	0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
                	dw	0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
                lstack:
                
                endif
                
                ;	dispatch table for functions
                
                functab:
 00C6 2F03C20328	dw	rebootx1, func1, func2, func3
 00CE 12FF80FB07	dw	punchf, listf, func6, func7
 00D6 310A370AC8	dw	func8, func9, func10, func11
 000C =         diskf	equ	($-functab)/2	; disk funcs
 00DE 7D21832196	dw	func12,func13,func14,func15
 00E6 87229B22EC	dw	func16,func17,func18,func19
 00EE FB2204230D	dw	func20,func21,func22,func23
 00F6 F523FB2301	dw	func24,func25,func26,func27
 00FE D311112417	dw	func28,func29,func30,func31
 0106 2D2441244A	dw	func32,func33,func34,func35
 010E 401E592475	dw	func36,func37,func38,func39
 0116 4A24C01575	dw	func40,lret$eq$ff,func42,func43
 011E 7D248B2490	dw	func44,func45,func46,func47
 0126 DF242A2550	dw	func48,func49,func50
 0033 =         nfuncs	equ	($-functab)/2
                
                functab2:
 012C E824C825  	dw	func98,func99
 0130 A6261F2728	dw	func100,func101,func102,func103
CP/M RMAC ASSEM 1.1	#007	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 0138 F127FE2713	dw	func104,func105,func106,func107
 0140 27287B0A89	dw	func108,func109,func110,func111
 0148 950A      	dw	func112
                
 000F =         nfuncs2	equ	($-functab2)/2
                
                errtbl:
 014A 410D      	dw	permsg
 014C 670D      	dw	rodmsg
 014E 580D      	dw	rofmsg
 0150 4A0D      	dw	selmsg
 0152 0000      	dw	0
 0154 0000      	dw	0
 0156 760D      	dw	passmsg
 0158 850D      	dw	fxstsmsg
 015A 910D      	dw	wildmsg
                
                test$152:
 015C FE98C0    	cpi 152! rnz
                
                ;
                ;	PARSE version 3.0b  Oct 08 1982 - Doug Huskey
                ;
                ;
                      	; DE->.(.filename,.fcb)
                	;
                	; filename = [d:]file[.type][;password]
                	;
                	; fcb assignments
                	;
                	;   0     => drive, 0 = default, 1 = A, 2 = B, ...
                	;   1-8   => file, converted to upper case,
                	;            padded with blanks (left justified)
                	;   9-11  => type, converted to upper case,
                	;	     padded with blanks (left justified)
                	;   12-15 => set to zero
                	;   16-23 => password, converted to upper case,
                	;	     padded with blanks
                	;   24-25 => 0000h
                	;   26    => length of password (0 - 8)
                	;
                	; Upon return, HL is set to FFFFH if DE locates
                	;            an invalid file name;
                	; otherwise, HL is set to 0000H if the delimiter
                	;            following the file name is a 00H (NULL)
                	; 	     or a 0DH (CR);
                	; otherwise, HL is set to the address of the delimiter
                	;            following the file name.
                	;
 015F 212924    	lxi 	h,sthl$ret
 0162 E5        	push	h
 0163 2ADBFB    	lhld 	info
 0166 5E        	mov	e,m		;get first parameter
 0167 23        	inx	h
 0168 56        	mov	d,m
 0169 D5        	push	d		;save .filename
CP/M RMAC ASSEM 1.1	#008	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 016A 23        	inx	h
 016B 5E        	mov	e,m		;get second parameter
 016C 23        	inx	h
 016D 56        	mov	d,m
 016E E1        	pop	h		;DE=.fcb  HL=.filename
 016F EB        	xchg
                parse0:
 0170 E5        	push	h		;save .fcb
 0171 AF        	xra	a
 0172 77        	mov	m,a		;clear drive byte
 0173 23        	inx	h
 0174 010B20    	lxi	b,20h*256+11
 0177 CD6C02    	call	pad		;pad name and type w/ blanks
 017A 010400    	lxi	b,4
 017D CD6C02    	call	pad		;EXT, S1, S2, RC = 0
 0180 010820    	lxi	b,20h*256+8
 0183 CD6C02    	call	pad		;pad password field w/ blanks
 0186 010C00    	lxi	b,12
 0189 CD6C02    	call	pad		;zero 2nd 1/2 of map, cr, r0 - r2
                ;
                ;	skip spaces
                ;
 018C CD7302    	call	skps
                ;
                ;	check for drive
                ;
 018F 1A        	ldax	d
 0190 FE3A      	cpi	':'		;is this a drive?
 0192 1B        	dcx	d
 0193 E1        	pop	h
 0194 E5        	push	h		;HL = .fcb
 0195 C2AC01    	jnz	parse$name
                ;
                ;	Parse the drive-spec
                ;
                parsedrv:
 0198 CD4D02    	call 	delim
 019B CAE001    	jz	parse$ok
 019E D641      	sui	'A'
 01A0 DAF601    	jc	perror1
 01A3 FE10      	cpi	16
 01A5 D2F601    	jnc	perror1
 01A8 13        	inx	d
 01A9 13        	inx	d		;past the ':'
 01AA 3C        	inr	a		;set drive relative to 1
 01AB 77        	mov	m,a		;store the drive in FCB(0)
                ;
                ;	Parse the file-name
                ;
                parse$name:
 01AC 23        	inx	h		;HL = .fcb(1)
 01AD CD4D02    	call	delim
 01B0 CAE001    	jz	parse$ok
 01B3 010007    	lxi	b,7*256
                
 01B6 1A        parse6:	ldax	d		;get a character
CP/M RMAC ASSEM 1.1	#009	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 01B7 FE2E      	cpi	'.'		;file-type next?
 01B9 CACA01    	jz	parse$type	;branch to file-type processing
 01BC FE3B      	cpi	';'
 01BE CAFB01    	jz	parse$pw
 01C1 CD1902    	call	gfc		;process one character
 01C4 C2B601    	jnz	parse6		;loop if not end of name
 01C7 C3E001    	jmp	parse$ok
                ;
                ;	Parse the file-type
                ;
                parse$type:
 01CA 13        	inx	d		;advance past dot
 01CB E1        	pop	h
 01CC E5        	push	h		;HL =.fcb
 01CD 010900    	lxi	b,9
 01D0 09        	dad	b		;HL =.fcb(9)
 01D1 010002    	lxi	b,2*256
                
 01D4 1A        parse8:	ldax	d
 01D5 FE3B      	cpi	';'
 01D7 CAFB01    	jz	parsepw
 01DA CD1902    	call	gfc		;process one character
 01DD C2D401    	jnz	parse8		;loop if not end of type
                ;
                parse$ok:
 01E0 C1        	pop	b
 01E1 D5        	push	d
 01E2 CD7302    	call	skps		;skip trailing blanks and tabs
 01E5 1B        	dcx	d
 01E6 CD4D02    	call	delim		;is next nonblank char a delim?
 01E9 E1        	pop	h
 01EA C0        	rnz			;no
 01EB 210000    	lxi	h,0
 01EE B7        	ora	a
 01EF C8        	rz			;return zero if delim = 0
 01F0 FE0D      	cpi	cr
 01F2 C8        	rz			;return zero if delim = cr
 01F3 EB        	xchg
 01F4 C9        	ret
                ;
                ;	handle parser error
                ;
                perror:
 01F5 C1        	pop	b			;throw away return addr
                perror1:
 01F6 C1        	pop	b
 01F7 21FFFF    	lxi	h,0ffffh
 01FA C9        	ret
                ;
                ;	Parse the password
                ;
                parsepw:
 01FB 13        	inx	d
 01FC E1        	pop	h
 01FD E5        	push	h
 01FE 011000    	lxi	b,16
CP/M RMAC ASSEM 1.1	#010	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 0201 09        	dad	b
 0202 010107    	lxi	b,7*256+1
                parsepw1:
 0205 CD1902    	call	gfc
 0208 C20502    	jnz	parsepw1
 020B 3E07      	mvi	a,7
 020D 90        	sub	b
 020E E1        	pop	h
 020F E5        	push	h
 0210 011A00    	lxi	b,26
 0213 09        	dad	b
 0214 77        	mov	m,a
 0215 1A        	ldax	d			;delimiter in A
 0216 C3E001    	jmp	parse$ok
                ;
                ;	get next character of name, type or password
                ;
 0219 CD4D02    gfc:	call	delim		;check for end of filename
 021C C8        	rz			;return if so
 021D FE20      	cpi	' '		;check for control characters
 021F 13        	inx	d
 0220 DAF501    	jc	perror		;error if control characters encountered
 0223 04        	inr	b		;error if too big for field
 0224 05        	dcr	b
 0225 FAF501    	jm	perror
 0228 0C        	inr	c
 0229 0D        	dcr	c
 022A C23202    	jnz	gfc1
 022D FE2A      	cpi	'*'		;trap "match rest of field" character
 022F CA3702    	jz	setmatch
 0232 77        gfc1:	mov	m,a		;put character in fcb
 0233 23        	inx	h
 0234 05        	dcr	b		;decrement field size counter
 0235 B7        	ora	a		;clear zero flag
 0236 C9        	ret
                ;;
                setmatch:
 0237 363F      	mvi	m,'?'		;set match one character
 0239 23        	inx	h
 023A 05        	dcr	b
 023B F23702    	jp	setmatch
 023E C9        	ret
                ;
                ;	check for delimiter
                ;
                ;	entry:	A = character
                ;	exit:	z = set if char is a delimiter
                ;
 023F 0D09202E2Cdelimiters:	db	cr,tab,' .,:;[]=<>|',0
                
 024D 1A        delim:	ldax	d		;get character
 024E E5        	push	h
 024F 213F02    	lxi	h,delimiters
 0252 BE        delim1:	cmp	m		;is char in table
 0253 CA5D02    	jz	delim2
 0256 34        	inr	m
CP/M RMAC ASSEM 1.1	#011	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 0257 35        	dcr	m		;end of table? (0)
 0258 23        	inx	h
 0259 C25202    	jnz	delim1
 025C B7        	ora	a		;reset zero flag
 025D E1        delim2:	pop	h
 025E C8        	rz
                	;
                	;	not a delimiter, convert to upper case
                	;
 025F FE61      	cpi	'a'
 0261 D8        	rc
 0262 FE7B      	cpi	'z'+1
 0264 D26902    	jnc	delim3
 0267 E65F      	ani 	05fh
 0269 E67F      delim3:	ani	07fh
 026B C9        	ret			;return with zero set if so
                ;
                ;	pad with blanks or zeros
                ;
 026C 70        pad:	mov	m,b
 026D 23        	inx	h
 026E 0D        	dcr	c
 026F C26C02    	jnz	pad
 0272 C9        	ret
                ;
                ;	skip blanks and tabs
                ;
 0273 1A        skps:	ldax	d
 0274 13        	inx	d
 0275 FE20      	cpi	' '		;skip spaces & tabs
 0277 CA7302    	jz 	skps
 027A FE09      	cpi	tab
 027C CA7302    	jz	skps
 027F C9        	ret
                ;
                ;	end of PARSE
                ;
                
                errflg:
                	; report error to console, message address in hl
 0280 E5CD8205  	push h! call crlf ; stack mssg address, new line
 0284 3AAA28C641	lda adrive! adi 'A'! sta dskerr ; current disk name
 028C 012F0D    	lxi b,dskmsg
                
                if BANKED
 028F CDEE02    	call zprint ; the error message
                else
                	call print
                endif
                
 0292 C1        	pop b
                
                if BANKED
 0293 3AF3FB17D2	lda bdos$flags! ral! jnc zprint
 029A CDEE02    	call zprint ; error message tail
 029D 3ADFFB0630	lda fx! mvi b,30h
CP/M RMAC ASSEM 1.1	#012	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 02A2 210B03    	lxi h,pr$fx1
 02A5 FE64DAAF02	cpi 100! jc errflg1
 02AA 363123D664	mvi m,31h! inx h! sui 100
                errflg1:
 02AF D60ADAB802	sui 10! jc errflg2
 02B4 04C3AF02  	inr b! jmp errflg1
                errflg2:
 02B8 7023C63A77	mov m,b! inx h! adi 3ah! mov m,a
 02BD 233620    	inx h! mvi m,20h
 02C0 210E033600	lxi h,pr$fcb! mvi m,0
 02C5 3ADDFBB7CA	lda resel! ora a! jz errflg3
 02CC 3620D5    	mvi m,20h! push d
 02CF 2ADBFB23EB	lhld info! inx h! xchg! lxi h,pr$fcb1
 02D7 0E08CD290E	mvi c,8! call move! mvi m,'.'! inx h
 02DF 0E03CD290E	mvi c,3! call move! pop d
                errflg3:
 02E5 CD8205    	call crlf
 02E8 01FB02C3EE	lxi b,pr$fx! jmp zprint
                
                zprint:
 02EE 0AB7C8    	ldax b! ora a! rz
 02F1 C54F      	push b! mov c,a
 02F3 CD2805    	call tabout
 02F6 C103C3EE02	pop b! inx b! jmp zprint
                
 02FB 42444F5320pr$fx:	db	'BDOS Function = '
 030B 202020    pr$fx1:	db	'   '
 030E 2046696C65pr$fcb:	db	' File = '
 0316           pr$fcb1:ds	12
 0322 00        	db	0
                
                else
                	jmp	print
                endif
                
                reboote:
 0323 21FDFFC32C	lxi h,0fffdh! jmp rebootx0 ; BDOS error
                rebootx:
                ;;;	lxi h,0fffeh ; CTL-C error
 0329 CD242D    	call patch$1e25	;[JCE] DRI Patch 13
                rebootx0:
 032C 22ACFB    	shld clp$errcde
                rebootx1:
 032F C368FB    	jmp wbootf
                
 0332           entsp:	ds	2	; entry stack pointer
                
                shell:
 0334 2100003922	lxi h,0! dad sp! shld shell$sp
                
                if not BANKED
                	lxi sp,shell$stk
                endif
                
 033B 21A203E5  	lxi h,shell$rtn! push h
 033F CD090ECD89	call save$rr! call save$dma
CP/M RMAC ASSEM 1.1	#013	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 0345 3AE6FB    	lda mult$cnt
                mult$io:
 0348 F5329928CD	push a! sta mult$num! call cbdos
 034F B7C29903  	ora a! jnz shell$err
 0353 3ADFFBFE21	lda fx! cpi 33! cnc incr$rr
 035B CD7F03    	call adv$dma
 035E F13DC24803	pop a! dcr a! jnz mult$io
 0363 676FC9    	mov h,a! mov l,a! ret
                
 0366 0000      shell$sp:	dw	0
                
 0368 C7C7C7C7C7		dw	0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
                
                shell$stk:		; shell has 5 level stack
 0372 0000      hold$dma:	dw	0
                
                cbdos:
 0374 3ADFFB4F  	lda fx! mov c,a
                cbdos1:
 0378 2ADBFBEBC3	lhld info! xchg! jmp bdose2
                
                adv$dma:
 037F 2AD8FB1180	lhld dmaad! lxi d,80h! dad d! jmp reset$dma1
                
                save$dma:
 0389 2AD8FB2272	lhld dmaad! shld hold$dma! ret
                
                reset$dma:
 0390 2A7203    	lhld hold$dma
                reset$dma1:
 0393 22D8FBC3BF	shld dmaad! jmp setdma
                
                shell$err:
 0399 C13CC8    	pop b! inr a! rz
 039C 3AE6FB9067	lda mult$cnt! sub b! mov h,a! ret
                
                shell$rtn:
 03A2 E53ADFFBFE	push h! lda fx! cpi 33! cnc reset$rr
 03AB CD9003    	call reset$dma
 03AE D12A6603F9	pop d! lhld shell$sp! sphl! xchg
 03B4 7D44C9    	mov a,l! mov b,h! ret
                
                	page
CP/M RMAC ASSEM 1.1	#014	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                
                
                	title	'CP/M Bdos Interface, Bdos, Version 3.0 Nov, 1982'
                ;*****************************************************************
                ;*****************************************************************
                ;**                                                             **
                ;**   B a s i c    D i s k   O p e r a t i n g   S y s t e m    **
                ;**								**
                ;**               C o n s o l e   P o r t i o n                 **
                ;**                                                             **
                ;*****************************************************************
                ;*****************************************************************
                ;
                ;       November 1982
                ;
                ;
                ;	Console handlers
                ;
                conin:
                	;read console character to A
 03B7 2120FD7E36	lxi h,kbchar! mov a,m! mvi m,0! ora a! rnz
                	;no previous keyboard character ready
 03BF C374FB    	jmp coninf ;get character externally
                	;ret
                ;
                conech:
 03C2 21720AE5  	LXI H,STA$RET! PUSH H
                CONECH0:
                	;read character with echo
 03C6 CDB703CDF0	call conin! call echoc! JC CONECH1 ;echo character?
                        ;character must be echoed before return
 03CF F54FCD2805	push psw! mov c,a! call tabout! pop psw
 03D5 C9        	RET
                CONECH1:
 03D6 CD1304C0  	CALL TEST$CTLS$MODE! RNZ
 03DA FE13C2E503	CPI CTLS! JNZ CONECH2
 03DF CD5E04C3C6	CALL CONBRK2! JMP CONECH0
                CONECH2:
 03E5 FE11CAC603	CPI CTLQ! JZ CONECH0
 03EA FE10CAC603	CPI CTLP! JZ CONECH0
 03EF C9        	RET
                ;
                echoc:
                	;echo character if graphic
                	;cr, lf, tab, or backspace
 03F0 FE0DC8    	cpi cr! rz ;carriage return?
 03F3 FE0AC8    	cpi lf! rz ;line feed?
 03F6 FE09C8    	cpi tab! rz ;tab?
 03F9 FE08C8    	cpi ctlh! rz ;backspace?
 03FC FE20C9    	cpi ' '! ret ;carry set if not graphic
                ;
                CONSTX:
 03FF 3A20FDB7C2	LDA KBCHAR! ORA A! JNZ CONB1
 0406 CD6EFBE601	CALL CONSTF! ANI 1! RET
                ;
CP/M RMAC ASSEM 1.1	#015	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                if BANKED
                
                SET$CTLS$MODE:
                	;SET CTLS STATUS OR INPUT FLAG FOR QUEUE MANAGER
 040C 21D5FB3640	LXI H,QFLAG! MVI M,40H! XTHL! PCHL
                
                endif
                ;
                TEST$CTLS$MODE:
                	;RETURN WITH Z FLAG RESET IF CTL-S CTL-Q CHECKING DISABLED
 0413 473ACFFBE6	MOV B,A! LDA CONMODE! ANI 2! MOV A,B! RET
                ;
                conbrk:	;check for character ready
 041B CD1304C2FF	CALL TEST$CTLS$MODE! JNZ CONSTX
 0421 3A20FDB7C2	lda kbchar! ora a! jnz CONBRK1 ;skip if active kbchar
                		;no active kbchar, check external break
                		;DOES BIOS HAVE TYPE AHEAD?
                if BANKED
 0428 3ACCFB3CCA		LDA TYPE$AHEAD! INR A! JZ CONSTX ;YES
                endif
                		;CONBRKX CALLED BY CONOUT
                
                	CONBRKX:
                		;HAS CTL-S INTERCEPT BEEN DISABLED?
 042F CD1304C0  		CALL TEST$CTLS$MODE! RNZ ;YES
                		;DOES KBCHAR CONTAIN CTL-S?
 0433 3A20FDFE13		LDA KBCHAR! CPI CTLS! JZ CONBRK1 ;YES
                if BANKED
 043B CD0C04    		CALL SET$CTLS$MODE
                endif
                		;IS A CHARACTER READY FOR INPUT?
 043E CD6EFB    		call constf
                if BANKED
 0441 E13600    		POP H! MVI M,0
                endif
 0444 E601C8    		ani 1! rz ;NO
                		;character ready, read it
                if BANKED
 0447 CD0C04    		CALL SET$CTLS$MODE
                endif
 044A CD74FB    		call coninf
                if BANKED
 044D E13600    		POP H! MVI M,0
                endif
                	CONBRK1:
 0450 FE13C27F04		cpi ctls! jnz conb0 ;check stop screen function
                		;DOES KBCHAR CONTAIN A CTL-S?
 0455 2120FDBEC2		LXI H,KBCHAR! CMP M! JNZ CONBRK2 ;NO
 045C 3600      		MVI M,0 ; KBCHAR = 0
                		;found ctls, read next character
                	CONBRK2:
                
                if BANKED
 045E CD0C04    		CALL SET$CTLS$MODE
                endif
 0461 CD74FB    		call coninf ;to A
CP/M RMAC ASSEM 1.1	#016	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                if BANKED
 0464 E13600    		POP H! MVI M,0
                endif
 0467 FE03C27504		cpi ctlc! JNZ CONBRK3
 046C 3ACFFBE608		LDA CONMODE! ANI 08H! JZ REBOOTX
 0474 AF        		XRA A
                	CONBRK3:
 0475 D611C8    		SUI CTLQ! RZ ; RETURN WITH A = ZERO IF CTLQ
 0478 3CCDA004C3		INR A! CALL CONB3! JMP CONBRK2
                	conb0:
 047F 2120FD    		LXI H,KBCHAR
                
 0482 47        		MOV B,A
                		;IS CONMODE(1) TRUE?
 0483 3ACFFB1FD2		LDA CONMODE! RAR! JNC $+7 ;NO
                		;DOES KBCHAR = CTLC?
 048A 3E03BEC8  		MVI A,CTLC! CMP M! RZ ;YES - RETURN
 048E 78        		MOV A,B
                
 048F FE11CA9D04		CPI CTLQ! JZ CONB2
 0494 FE10CA9D04		CPI CTLP! JZ CONB2
                		;character in accum, save it
 0499 77        		MOV M,A
                	conb1:
                		;return with true set in accumulator
 049A 3E01C9    		mvi a,1! ret
                	CONB2:
 049D AF77C9    		XRA A! MOV M,A! RET
                	CONB3:
 04A0 CCA904    		CZ TOGGLE$LISTCP
 04A3 0E07C47AFB		MVI C,7! CNZ CONOUTF
 04A8 C9        		RET
                ;
                TOGGLE$LISTCP:
                	; IS PRINTER ECHO DISABLED?
 04A9 3ACFFBE614	LDA CONMODE! ANI 14H! JNZ TOGGLE$L1 ;YES
 04B1 21D4FB3E01	LXI H,LISTCP! MVI A,1! XRA M! ANI 1
 04B9 77C9      	MOV M,A! RET
                TOGGLE$L1:
 04BB AFC9      	XRA A! RET
                ;
                QCONOUTF:
                	;DOES FX = INPUT?
 04BD 3ADFFB3DCA	LDA FX! DCR A! JZ CONOUTF ;YES
                	;IS ESCAPE SEQUENCE DECODING IN EFFECT?
 04C4 78        	MOV A,B
                ;;;	ANI 8		;[JCE] DRI Patch 13
 04C5 E610      	ANI 10h
 04C7 C27AFB    	JNZ SCONOUTF ;YES
 04CA C37AFB    	JMP CONOUTF
                ;
                conout:
                	;compute character position/write console char from C
                	;compcol = true if computing column position
 04CD 3ABC0AB7C2	lda compcol! ora a! jnz compout
                		;write the character, then compute the column
CP/M RMAC ASSEM 1.1	#017	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                		;write console character from C
                		;B ~= 0 -> ESCAPE SEQUENCE DECODING
 04D4 3ACFFBE614		LDA CONMODE! ANI 14H! MOV B,A
 04DA C5        		push b
                		;CALL CONBRKX FOR OUTPUT FUNCTIONS ONLY
 04DB 3ADFFB3DC4		LDA FX! DCR A! CNZ CONBRKX
 04E2 C1C5      		pop b! push b ;recall/save character
 04E4 CDBD04    		call QCONOUTF ;externally, to console
 04E7 C1        		pop b
                		;SKIP ECHO WHEN CONMODE & 14H ~= 0
 04E8 78B7C2F604		MOV A,B! ORA A! JNZ COMPOUT
 04ED C5        		push b ;recall/save character
                		;may be copying to the list device
 04EE 3AD4FBB7C4		lda listcp! ora a! cnz listf ;to printer, if so
 04F5 C1        		pop b ;recall the character
                	compout:
 04F6 79        		mov a,c ;recall the character
                		;and compute column position
 04F7 21B7FB    		lxi h,column ;A = char, HL = .column
 04FA FE7FC8    		cpi rubout! rz ;no column change if nulls
 04FD 34        		inr m ;column = column + 1
 04FE FE20D0    		cpi ' '! rnc ;return if graphic
                		;not graphic, reset column position
 0501 35        		dcr m ;column = column - 1
 0502 7EB7C8    		mov a,m! ora a! rz ;return if at zero
                		;not at zero, may be backspace or end line
 0505 79        		mov a,c ;character back to A
 0506 FE08C20D05		cpi ctlh! jnz notbacksp
                			;backspace character
 050B 35        			dcr m ;column = column - 1
 050C C9        			ret
                		notbacksp:
                			;not a backspace character, eol?
 050D FE0DC0    			cpi cr! rnz ;return if not
                			;end of line, column = 0
 0510 3600      			mvi m,0 ;column = 0
 0512 C9        		ret
                ;
                ctlout:
                	;send C character with possible preceding up-arrow
 0513 79CDF003  	mov a,c! call echoc ;cy if not graphic (or special case)
 0517 D22805    	jnc tabout ;skip if graphic, tab, cr, lf, or ctlh
                		;send preceding up arrow
 051A F50E5ECDCD		push psw! mvi c,ctl! call conout ;up arrow
 0520 F1F640    		pop psw! ori 40h ;becomes graphic letter
 0523 4F        		mov c,a ;ready to print
                if BANKED
 0524 CDC005C8  		call chk$column! rz
                endif
                		;(drop through to tabout)
                ;
                tabout:
                	;IS FX AN INPUT FUNCTION?
 0528 3ADFFB3DCA	LDA FX! DCR A! JZ TABOUT1 ;YES - ALWAYS EXPAND TABS FOR ECHO
                	;HAS TAB EXPANSION BEEN DISABLED OR
                	;ESCAPE SEQUENCE DECODING BEEN ENABLED?
CP/M RMAC ASSEM 1.1	#018	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 052F 3ACFFBE614	LDA CONMODE! ANI 14H! JNZ CONOUT ;YES
                TABOUT1:
                	;expand tabs to console
 0537 79FE09C2CD	mov a,c! cpi tab! jnz conout ;direct to conout if not
                		;tab encountered, move to next tab position
                	tab0:
                
                if BANKED
 053D 3ADFFBFE01		lda fx! cpi 1! jnz tab1
 0545 CDC005C8  		call chk$column! rz
                	tab1:
                endif
                
 0549 0E20CDCD04		mvi c,' '! call conout ;another blank
 054E 3AB7FBE607		lda column! ani 111b ;column mod 8 = 0 ?
 0553 C23D05    		jnz tab0 ;back for another if not
 0556 C9        	ret
                ;
                ;
                backup:
                	;back-up one screen position
 0557 CD6505    	call pctlh
                
                if BANKED
 055A 3ABF0AFE01	lda comchr! cpi ctla! rz
                endif
                
 0560 0E20CD7AFB	mvi c,' '! call conoutf
                ;	(drop through to pctlh)				;
                pctlh:
                	;send ctlh to console without affecting column count
 0565 0E08C37AFB	mvi c,ctlh! jmp conoutf
                	;ret
                ;
                crlfp:
                	;print #, cr, lf for ctlx, ctlu, ctlr functions
                	;then move to strtcol (starting column)
 056A 0E23CDCD04	mvi c,'#'! call conout
 056F CD8205    	call crlf
                	;column = 0, move to position strtcol
                	crlfp0:
 0572 3AB7FB21BD		lda column! lxi h,strtcol
 0578 BED0      		cmp m! rnc ;stop when column reaches strtcol
 057A 0E20CDCD04		mvi c,' '! call conout ;print blank
 057F C37205    		jmp crlfp0
                ;;
                ;
                crlf:
                	;carriage return line feed sequence
 0582 0E0DCDCD04	mvi c,cr! call conout! mvi c,lf! jmp conout
                	;ret
                ;
                print:
                	;print message until M(BC) = '$'
 058C 21D3FB    	LXI H,OUTDELIM
 058F 0ABEC8    	ldax b! CMP M! rz ;stop on $
CP/M RMAC ASSEM 1.1	#019	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                		;more to print
 0592 03C54F    		inx b! push b! mov c,a ;char to C
 0595 CD2805    		call tabout ;another character printed
 0598 C1C38C05  		pop b! jmp print
                ;
                QCONIN:
                
                if BANKED
 059C 2A280D7E32	lhld apos! mov a,m! sta ctla$sw
                endif
                	;IS BUFFER ADDRESS = 0?
 05A3 2ABAFB7DB4	LHLD CONBUFFADD! MOV A,L! ORA H! JZ CONIN ;YES
                	;IS CHARACTER IN BUFFER < 5?
                
                if BANKED
 05AB CD21FD    	call qconinx ; mov a,m with bank 1 switched in
                else
                	MOV A,M
                endif
                
 05AE 23        	INX H
 05AF B7C2B605  	ORA A! JNZ QCONIN1 ; NO
 05B3 210000    	LXI H,0
                QCONIN1:
 05B6 22BAFB22BC	SHLD CONBUFFADD! SHLD CONBUFFLEN! RNZ ; NO
 05BD C3B703    	JMP CONIN
                
                if BANKED
                	
                chk$column:
 05C0 3AB6FB5F3A	lda conwidth! mov e,a! lda column! cmp e! ret
                ;
                expand:
 05C9 EB2A280DEB	xchg! lhld apos! xchg
                expand1:
 05CE 1AB7C8    	ldax d! ora a! rz
 05D1 13237704C3	inx d! inx h! mov m,a! inr b! jmp expand1
                ;
                copy$xbuff:
 05D8 78B7C8    	mov a,b! ora a! rz
 05DB C548E5EB13	push b! mov c,b! push h! xchg! inx d
 05E0 21C20B    	lxi h,xbuff
 05E3 CD290E    	call move
 05E6 360022260D	mvi m,0! shld xpos
 05EB E1C1C9    	pop h! pop b! ret
                ;
                copy$cbuff:
 05EE 3AB4FB17D0	lda ccpflgs+1! ral! rnc
 05F3 21C20B11C1	lxi h,xbuff! lxi d,cbuff! inr c! jnz copy$cbuff1
 05FD EB78B7C8  	xchg! mov a,b! ora a! rz
 0601 32C00A    	sta cbuff$len
 0604 D5010F06C5	push d! lxi b,copy$cbuff2! push b
 0609 47        	mov b,a
                copy$cbuff1:
 060A 0448C3290E	inr b! mov c,b! jmp move
                copy$cbuff2:
CP/M RMAC ASSEM 1.1	#020	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 060F E12B3600C9	pop h! dcx h! mvi m,0! ret
                ;
                save$col:
 0614 3AB7FB322C	lda column! sta save$column! ret
                ;
                clear$right:
 061B 3AB7FB212D	lda column! lxi h,ctla$column! cmp m! rnc
 0623 0E20CDCD04	mvi c,20h! call conout! jmp clear$right
                ;
                reverse:
 062B 3A2C0D21B7	lda save$column! lxi h,column! cmp m! rnc
 0633 0E08CDCD04	mvi c,ctlh! call conout! jmp reverse
                ;
                chk$buffer$size:
 063B C5E5      	push b! push h
 063D 2A280D1E00	lhld apos! mvi e,0
                cbs1:
 0642 7EB7CA4C06	mov a,m! ora a! jz cbs2
 0647 1C23C34206	inr e! inx h! jmp cbs1
                cbs2:
 064C 7883B9    	mov a,b! add e! cmp c
 064F F50E07D47A	push a! mvi c,7! cnc conoutf
 0655 F1E1C1D8  	pop a! pop h! pop b! rc
 0659 D1D1C3FF06	pop d! pop d! jmp readnx
                ;
                refresh:
 065E 3A2A0DB7C8	lda ctla$sw! ora a! rz
 0663 3ABF0AFE01	lda comchr! cpi ctla! rz
 0669 FE06C8    	cpi ctlf! rz
 066C FE17C8    	cpi ctlw! rz
                refresh0:
 066F E5C5      	push h! push b
 0671 CD1406    	call save$col
 0674 2A280D    	lhld apos
                refresh1:
 0677 7EB7CA9306	mov a,m! ora a! jz refresh2
 067C 4FCDC005DA	mov c,a! call chk$column! jc refresh05
 0683 7B32B7FBC3	mov a,e! sta column! jmp refresh2
                refresh05:
 068A E5CD1305  	push h! call ctlout
 068E E123C37706	pop h! inx h! jmp refresh1
                refresh2:
 0693 3AB7FB322E	lda column! sta new$ctla$col
                refresh3:
 0699 CD1B06    	call clear$right
 069C CD2B06    	call reverse
 069F 3A2E0D322D	lda new$ctla$col! sta ctla$column
 06A5 C1E1C9    	pop b! pop h! ret
                ;
                init$apos:
 06A8 21250D2228	lxi h,aposi! shld apos
 06AE AF322A0D  	xra a! sta ctla$sw
 06B2 C9        	ret
                ;
                init$xpos:
 06B3 21C20B2226	lxi h,xbuff! shld xpos! ret
CP/M RMAC ASSEM 1.1	#021	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                ;
                set$ctla$column:
 06BA 212A0D7EB7	lxi h,ctla$sw! mov a,m! ora a! rnz
 06C0 343AB7FB32	inr m! lda column! sta ctla$column! ret
                ;
                readi:
 06C8 CDC005D482	call chk$column! cnc crlf
 06CE 3AC00A47  	lda cbuff$len! mov b,a
 06D2 0E00CDEE05	mvi c,0! call copy$cbuff
                else
                
                readi:
                	MOV A,D! ORA E! JNZ READ
                	LHLD DMAAD! SHLD INFO
                	INX H! INX H! SHLD CONBUFFADD
                endif
                
                read:	;read to info address (max length, current length, buffer)
                
                if BANKED
 06D7 CDB306    	call init$xpos
 06DA CDA806    	call init$apos
                readx:
 06DD CD5E06    	call refresh
 06E0 AF322B0D  	xra a! sta ctlw$sw
                readx1:
                
                endif
                
 06E4 3E0132DFFB	MVI A,1! STA FX
 06E9 3AB7FB32BD	lda column! sta strtcol ;save start for ctl-x, ctl-h
 06EF 2ADBFB4E23	lhld info! mov c,m! inx h! push h
 06F5 AF4732BE0A	XRA A! MOV B,A! STA SAVEPOS
 06FA B9C2FF06  	CMP C! JNZ $+4
 06FE 0C        	INR C
                	;B = current buffer length,
                	;C = maximum buffer length,
                	;HL= next to fill - 1
                	readnx:
                		;read next character, BC, HL active
 06FF C5E5      		push b! push h ;blen, cmax, HL saved
                		readn0:
                
                if BANKED
 0701 3A2B0DB7CC			lda ctlw$sw! ora a! cz qconin
                nxtline:
 0708 32BF0A    			sta comchr
                else
                			CALL QCONIN ;next char in A
                endif
                
                			;ani 7fh ;mask parity bit
 070B E1C1      			pop h! pop b ;reactivate counters
 070D FE0DCAE709			cpi cr! jz readen ;end of line?
 0712 FE0ACAE709			cpi lf! jz readen ;also end of line
                
CP/M RMAC ASSEM 1.1	#022	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                if BANKED
 0717 FE06C23507			cpi ctlf! jnz not$ctlf
                		do$ctlf:
 071C CDC0051DBB			call chk$column! dcr e! cmp e! jnc readnx
                		do$ctlf0:
 0724 EB2A280D7E			xchg! lhld apos! mov a,m! ora a! jz ctlw$l15
 072D 2322280DEB			inx h! shld apos! xchg! jmp notr
                		not$ctlf:
 0735 FE17C29A07			cpi ctlw! jnz not$ctlw
                		do$ctlw:
 073A EB2A280D7E			xchg! lhld apos! mov a,m! ora a! jz ctlw$l1
 0743 EBCDC0051D			xchg! call chk$column! dcr e! cmp e! xchg! jc ctlw$l0
 074D EBCD6F06EB			xchg! call refresh0! xchg! jmp ctlw$l13
                		ctlw$l0:
 0755 2A280D7E  			lhld apos! mov a,m
 0759 2322280DC3			inx h! shld apos! jmp ctlw$l3
                		ctlw$l1:
 0760 212A0D7E36			lxi h,ctla$sw! mov a,m! mvi m,0
 0766 B7CA7307  			ora a! jz ctlw$l2
                		ctlw$l13:
 076A 212B0D3600			lxi h,ctlw$sw! mvi m,0
                		ctlw$l15:
 076F EBC3FF06  			xchg! jmp readnx
                		ctlw$l2:
 0773 3A2B0DB7C2			lda ctlw$sw! ora a! jnz ctlw$l25
 077A 78B7C26F07			mov a,b! ora a! jnz ctlw$l15
 077F CDB306    			call init$xpos
                		ctlw$l25:
 0782 2A260D7EB7			lhld xpos! mov a,m! ora a
 0787 322B0DCA6F			sta ctlw$sw! jz ctlw$l15
 078D 2322260D  			inx h! shld xpos
                		ctlw$l3:
 0791 212B0D3617			lxi h,ctlw$sw! mvi m,ctlw
 0796 EBC34D09  			xchg! jmp notr
                		not$ctlw:
 079A FE01C2C507			cpi ctla! jnz not$ctla
                		do$ctla:
                			;do we have any characters to back over?
 079F 3ABD0A573A			lda strtcol! mov d,a! lda column! cmp d
 07A7 CAFF06    			jz readnx
 07AA 32BC0A    			sta compcol ;COL > 0
 07AD 78B7CA0B09			mov a,b! ora a! jz linelen
                			;characters remain in buffer, backup one
 07B2 05        			dcr b ;remove one character
                			;compcol > 0 marks repeat as length compute
                			;backup one position in xbuff
 07B3 E5        			push h
 07B4 CDBA06    			call set$ctla$column
 07B7 D1        			pop d
 07B8 2A280D2B  			lhld apos! dcx h
 07BC 22280D1A77			shld apos! ldax d! mov m,a! xchg! jmp linelen
                		not$ctla:
 07C5 FE02C20B08			cpi ctlb! jnz not$ctlb
                		do$ctlb:
 07CA 3ABE0AB8C2			lda save$pos! cmp b! jnz ctlb$l0
 07D1 3E17322A0D			mvi a,ctlw! sta ctla$sw
CP/M RMAC ASSEM 1.1	#023	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 07D6 32BF0AC33A			sta comchr! jmp do$ctlw
                		ctlb$l0:
 07DC EB2A280D04			xchg! lhld apos! inr b
                		ctlb$l1:
 07E1 053ABE0AB8			dcr b! lda save$pos! cmp b! jz ctlb$l2
 07E9 2B1A771BC3			dcx h! ldax d! mov m,a! dcx d! jmp ctlb$l1
                		ctlb$l2:
 07F0 22280D    			shld apos
 07F3 C5D5      			push b! push d
 07F5 CDBA06    			call set$ctla$column
                		ctlb$l3:
 07F8 3AB7FB47  			lda column! mov b,a
 07FC 3ABD0AB8CA			lda strtcol! cmp b! jz read$n0
 0803 0E08CDCD04 			mvi c,ctlh! call conout! jmp ctlb$l3
                		not$ctlb:
 080B FE0BC21E08			cpi ctlk! jnz not$ctlk
 0810 EB21250D22			xchg! lxi h,aposi! shld apos
 0817 EBCD5E06  			xchg! call refresh
 081B C3FF06    			jmp readnx
                		not$ctlk:
 081E FE07C22D08			cpi ctlg! jnz not$ctlg
 0823 3A2A0DB7CA			lda ctla$sw! ora a! jz readnx
 082A C32407    			jmp do$ctlf0
                		not$ctlg:
                endif
                
 082D FE08C25008			cpi ctlh! jnz noth ;backspace?
 0832 3ACAFB3CCA			LDA CTLH$ACT! INR A! JZ DO$RUBOUT
                		DO$CTLH:
                			;do we have any characters to back over?
 0839 3ABD0A573A			LDA STRTCOL! MOV D,A! LDA COLUMN! CMP D
 0841 CAFF06    			jz readnx
 0844 32BC0A    			STA COMPCOL ;COL > 0
 0847 78B7CA4D08			MOV A,B! ORA A! JZ $+4
                			;characters remain in buffer, backup one
 084C 05        			dcr b ;remove one character
                			;compcol > 0 marks repeat as length compute
 084D C30B09    			jmp linelen ;uses same code as repeat
                		noth:
                			;not a backspace
 0850 FE7FC27308			cpi rubout! jnz notrub ;rubout char?
 0855 3ACBFB3CCA			LDA RUBOUT$ACT! INR A! JZ DO$CTLH
                		DO$RUBOUT:
                if BANKED
 085C 3E7F32BF0A			mvi a,rubout! sta comchr
 0861 3A2A0DB7C2			lda ctla$sw! ora a! jnz do$ctlh
                endif
                			;rubout encountered, rubout if possible
 0868 78B7CAFF06			mov a,b! ora a! jz readnx ;skip if len=0
                			;buffer has characters, resend last char
 086D 7E052B    			mov a,m! dcr b! dcx h ;A = last char
                			;blen=blen-1, next to fill - 1 decremented
 0870 C37109    			jmp rdech1 ;act like this is an echo
                		notrub:
                			;not a rubout character, check end line
 0873 FE05C29208			cpi ctle! jnz note ;physical end line?
CP/M RMAC ASSEM 1.1	#024	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                			;yes, save active counters and force eol
 0878 C57832BE0A			push b! MOV A,B! STA SAVE$POS
 087D E5        			push h
                if BANKED
 087E 3A2A0DB7C4			lda ctla$sw! ora a! cnz clear$right
                endif
 0885 CD8205    			call crlf
                if BANKED
 0888 CD5E06    			call refresh
                endif
 088B AF32BD0A  			xra a! sta strtcol ;start position = 00
 088F C30107    			jmp readn0 ;for another character
                		note:
                			;not end of line, list toggle?
 0892 FE10C2A208			cpi ctlp! jnz notp ;skip if not ctlp
                			;list toggle - change parity
 0897 E5        			push h ;save next to fill - 1
 0898 C5        			PUSH B
 0899 AFCDA004  			XRA A! CALL CONB3
 089D C1        			POP B
 089E E1C3FF06  			pop h! jmp readnx ;for another char
                		notp:
                			;not a ctlp, line delete?
 08A2 FE18C2C408			cpi ctlx! jnz notx
 08A7 E1        			pop h ;discard start position
                			;loop while column > strtcol
                			backx:
 08A8 3ABD0A21B7				lda strtcol! lxi h,column
                if BANKED
 08AE BEDABD08  				cmp m! jc backx1
 08B2 2A280D7EB7				lhld apos! mov a,m! ora a! jnz readx
 08BA C3D706    				jmp read
                			    backx1:
                else
                				cmp m! jnc read ;start again
                endif
 08BD 35        				dcr m ;column = column - 1
 08BE CD5705    				call backup ;one position
 08C1 C3A808    				jmp backx
                		notx:
                			;not a control x, control u?
                			;not control-X, control-U?
 08C4 FE15C2D508			cpi ctlu! jnz notu ;skip if not
                if BANKED
 08C9 E3CDD805E3			xthl! call copy$xbuff! xthl
                endif
                			;delete line (ctlu)
                		do$ctlu:
 08CE CD6A05    			call crlfp ;physical eol
 08D1 E1        			pop h ;discard starting position
 08D2 C3D706    			jmp read ;to start all over
                		notu:
                			;not line delete, repeat line?
 08D5 FE12C24D09			cpi ctlr! jnz notr
 08DA AF32BE0A  			XRA A! STA SAVEPOS
                if BANKED
CP/M RMAC ASSEM 1.1	#025	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 08DE EBCDA806EB			xchg! call init$apos! xchg
 08E3 78B7CACE08			mov a,b! ora a! jz do$ctlu
 08E8 EB2A280D04			xchg! lhld apos! inr b
                		ctlr$l1:
 08ED 05CAF808  			dcr b! jz ctlr$l2
 08F1 2B1A771B  			dcx h! ldax d! mov m,a! dcx d
 08F5 C3ED08    			jmp ctlr$l1
                		ctlr$l2:
 08F8 22280DC5D5			shld apos! push b! push d
 08FD CD6A053E17			call crlfp! mvi a,ctlw! sta ctlw$sw
 0905 322A0DC301			sta ctla$sw! jmp readn0
                endif
                		linelen:
                			;repeat line, or compute line len (ctlh)
                			;if compcol > 0
 090B C5CD6A05  			push b! call crlfp ;save line length
 090F C1E1E5C5  			pop b! pop h! push h! push b
                			;bcur, cmax active, beginning buff at HL
                		rep0:
 0913 78B7CA2E09			mov a,b! ora a! jz rep1 ;count len to 00
 0918 234E      			inx h! mov c,m ;next to print
 091A 05        			DCR B
 091B D1D57A9057			POP D! PUSH D! MOV A,D! SUB B! MOV D,A
 0920 C5E5      			push b! push h ;count length down
 0922 3ABE0ABADC			LDA SAVEPOS! CMP D! CC CTLOUT
 0929 E1C1      			pop h! pop b ;recall remaining count
 092B C31309    			jmp rep0 ;for the next character
                		rep1:
                			;end of repeat, recall lengths
                			;original BC still remains pushed
 092E E5        			push h ;save next to fill
 092F 3ABC0AB7  			lda compcol! ora a ;>0 if computing length
 0933 CA0107    			jz readn0 ;for another char if so
                			;column position computed for ctlh
 0936 21B7FB96  			lxi h,column! sub m ;diff > 0
 093A 32BC0A    			sta compcol ;count down below
                			;move back compcol-column spaces
                		backsp:
                			;move back one more space
 093D CD5705    			call backup ;one space
 0940 21BC0A35  			lxi h,compcol! dcr m
 0944 C23D09    			jnz backsp
                if BANKED
 0947 CD5E06    			call refresh
                endif
 094A C30107    			jmp readn0 ;for next character
                		notr:
                			;not a ctlr, place into buffer
                			;IS BUFFER FULL?
 094D F5        			PUSH A
 094E 78B9DA5E09			MOV A,B! CMP C! JC RDECH0 ;NO
                			;DISCARD CHARACTER AND RING BELL
 0953 F1C5E5    			POP A! PUSH B! PUSH H
 0956 0E07CD7AFB			MVI C,7! CALL CONOUTF! JMP READN0
                		RDECH0:
                
CP/M RMAC ASSEM 1.1	#026	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                if BANKED
 095E 3ABF0AFE07			lda comchr! cpi ctlg! jz rdech05
 0966 3A2A0DB7C4			lda ctla$sw! ora a! cnz chk$buffer$size
                		rdech05:
                endif
                
 096D F1        			POP A
 096E 2377      			inx h! mov m,a ;character filled to mem
 0970 04        			inr b ;blen = blen + 1
                		rdech1:
                			;look for a random control character
 0971 C5E5      			push b! push h ;active values saved
 0973 4F        			mov c,a ;ready to print
                if BANKED
 0974 CD1406    			call save$col
                endif
 0977 CD1305    			call ctlout ;may be up-arrow C
 097A E1C1      			pop h! pop b
                if BANKED
 097C 3ABF0AFE07			lda comchr! cpi ctlg! jz do$ctlh
 0984 FE7FCA8C09			cpi rubout! jz rdech2
 0989 CD5E06    			call refresh
                		rdech2:
                endif
 098C 3ACFFBE608			LDA CONMODE! ANI 08H
                ;;;			JNZ NOTC	;[JCE] DRI Patch 13
 0991 C29709    			jnz patch$064b
                
 0994 7E        			mov a,m ;recall char
 0995 FE03      			cpi ctlc ;set flags for reboot test
 0997 78        patch$064b:		mov a,b ;move length to A
 0998 C2A009    			jnz notc ;skip if not a control c
 099B FE01      			cpi 1 ;control C, must be length 1
 099D CA2903    			jz REBOOTX ;reboot if blen = 1
                			;length not one, so skip reboot
                		notc:
                			;not reboot, are we at end of buffer?
                if BANKED
 09A0 B9D2E009  			cmp c! jnc buffer$full
                else
                			jmp readnx ;go for another if not
                endif
                
                if BANKED
 09A4 C5E5      			push b! push h
 09A6 CDC005DA01			call chk$column! jc readn0
 09AC 3A2A0DB7CA			lda ctla$sw! ora a! jz do$new$line
 09B3 3ABF0AFE17			lda comchr! cpi ctlw! jz back$one
 09BB FE06CAC509			cpi ctlf! jz back$one
                				
                		do$newline:
 09C0 3E05C30807			mvi a,ctle! jmp nxtline
                
                		back$one:
                			;back up to previous character
 09C5 E1C1      			pop h! pop b
CP/M RMAC ASSEM 1.1	#027	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 09C7 05EB      			dcr b! xchg
 09C9 2A280D2B22			lhld apos! dcx h! shld apos
 09D0 1A77EB2B  			ldax d! mov m,a! xchg! dcx h
 09D4 C5E5CD2B06			push b! push h! call reverse
                			;disable ctlb or ctlw
 09D9 AF322B0DC3			xra a! sta ctlw$sw! jmp readn0
                		
                		buffer$full:
 09E0 AF322B0DC3			xra a! sta ctlw$sw! jmp readnx
                endif
                		readen:
                			;end of read operation, store blen
                if BANKED
 09E7 CDC905    			call expand
                endif
 09EA E170      			pop h! mov m,b ;M(current len) = B
                if BANKED
 09EC C5        			push b
 09ED CDD805    			call copy$xbuff
 09F0 C1        			pop b
 09F1 0EFFCDEE05			mvi c,0ffh! call copy$cbuff
                endif
 09F6 21000022BA			LXI H,0! SHLD CONBUFFADD
 09FC 0E0DC3CD04			mvi c,cr! jmp conout ;return carriage
                			;ret
                ;
 03C2 =         func1	equ	CONECH
                	;return console character with echo
                ;
 0528 =         func2:	equ	tabout
                	;write console character with tab expansion
                ;
                func3:
                	;return reader character
 0A01 CD15FF    	call readerf
 0A04 C3720A    	jmp sta$ret
                ;
                ;func4:	equated to punchf
                	;write punch character
                ;
                ;func5:	equated to listf
                	;write list character
                	;write to list device
                ;
                func6:
                	;direct console i/o - read if 0ffh
 0A07 793CCA200A	mov a,c! inr a! jz dirinp ;0ffh => 00h, means input mode
 0A0C 3CCA170A  		inr a! JZ DIRSTAT ;0feh => direct STATUS function
 0A10 3CCA250A  		INR A! JZ DIRINP1 ;0fdh => direct input, no status
 0A14 C37AFB    		JMP CONOUTF
                	DIRSTAT:
                		;0feH in C for status
 0A17 CDFF03C2C0		CALL CONSTX! JNZ LRET$EQ$FF! JMP STA$RET
                	dirinp:
 0A20 CDFF03    		CALL CONSTX ;status check
 0A23 B7C8      		ora a! RZ ;skip, return 00 if not ready
CP/M RMAC ASSEM 1.1	#028	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                		;character is ready, get it
                	dirinp1:
 0A25 CDB703    		call CONIN ;to A
 0A28 C3720A    		jmp sta$ret
                ;
                func7:
 0A2B CD36FF    	call auxinstf
 0A2E C3720A    	jmp sta$ret
                ;
                func8:
 0A31 CD39FF    	call auxoutstf
 0A34 C3720A    	jmp sta$ret
                ;
                func9:
                	;write line until $ encountered
 0A37 EB        	xchg	;was lhld info	
 0A38 4D44      	mov c,l! mov b,h ;BC=string address
 0A3A C38C05    	jmp print ;out to console	
                
 06C8 =         func10	equ	readi
                	;read a buffered console line
                
                func11:
                	;IS CONMODE(1) TRUE?
 0A3D 3ACFFB1FD2	LDA CONMODE! RAR! JNC NORMAL$STATUS ;NO
                	;CTL-C ONLY STATUS CHECK
                if BANKED
 0A44 21D5FB3680	LXI H,QFLAG! MVI M,80H! PUSH H
                endif
 0A4A 21680AE5  	LXI H,CTLC$STAT$RET! PUSH H
                	;DOES KBCHAR = CTL-C?
 0A4E 3A20FDFE03	LDA KBCHAR! CPI CTLC! JZ CONB1 ;YES
                	;IS THERE A READY CHARACTER?
 0A56 CD6EFBB7C8	CALL CONSTF! ORA A! RZ ;NO
                	;IS THE READY CHARACTER A CTL-C?
 0A5B CD74FBFE03	CALL CONINF! CPI CTLC! JZ CONB0 ;YES
 0A63 3220FDAFC9	STA KBCHAR! XRA A! RET
                
                CTLC$STAT$RET:
                
                if BANKED
 0A68 CD720A    	CALL STA$RET
 0A6B E13600C9  	POP H! MVI M,0! RET
                else
                	JMP STA$RET
                endif
                
                NORMAL$STATUS:
                	;check console status
 0A6F CD1B04    	call conbrk
                	;(drop through to sta$ret)
                sta$ret:
                	;store the A register to aret
 0A72 329F0D    	sta aret
                func$ret:						;
 0A75 C9        	ret ;jmp goback (pop stack for non cp/m functions)
CP/M RMAC ASSEM 1.1	#029	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                ;
                setlret1:
                	;set lret = 1
 0A76 3E01C3720A	mvi a,1! jmp sta$ret				;
                ;
                FUNC109:			;GET/SET CONSOLE MODE
                	;DOES DE = 0FFFFH?
 0A7B 7AA33C    	MOV A,D! ANA E! INR A
 0A7E 2ACFFBCA29	LHLD CONMODE! JZ STHL$RET ;YES - RETURN CONSOLE MODE
 0A84 EB22CFFBC9	XCHG! SHLD CONMODE! RET ;NO - SET CONSOLE MODE
                ;
                FUNC110:			;GET/SET FUNCTION 9 DELIMITER
 0A89 21D3FB    	LXI H,OUT$DELIM
                	;DOES DE = 0FFFFH?
 0A8C 7AA33C    	MOV A,D! ANA E! INR A
 0A8F 7ECA720A  	MOV A,M! JZ STA$RET ;YES - RETURN DELIMITER
 0A93 73C9      	MOV M,E! RET ;NO - SET DELIMITER
                ;
                FUNC111:			;PRINT BLOCK TO CONSOLE
                FUNC112:			;LIST BLOCK
 0A95 EB5E235623	XCHG! MOV E,M! INX H! MOV D,M! INX H
 0A9A 4E2346EB  	MOV C,M! INX H! MOV B,M! XCHG
                	;HL = ADDR OF STRING
                	;BC = LENGTH OF STRING
                BLK$OUT:
 0A9E 78B1C8    	MOV A,B! ORA C! RZ
 0AA1 C5E54E    	PUSH B! PUSH H! MOV C,M
 0AA4 3ADFFBFE6F	LDA FX! CPI 111! JZ BLK$OUT1
 0AAC CD80FBC3B5	CALL LISTF! JMP BLK$OUT2
                BLK$OUT1:
 0AB2 CD2805    	CALL TABOUT
                BLK$OUT2:
 0AB5 E123C10B  	POP H! INX H! POP B! DCX B
 0AB9 C39E0A    	JMP BLK$OUT
                
 FB7A =         SCONOUTF	EQU	CONOUTF
                
                ;
                ;	data areas
                ;
 0ABC 00        compcol:db	0	;true if computing column position
 0ABD 00        strtcol:db	0	;starting column position after read
                
                if not BANKED
                
                kbchar:	db	0	;initial key char = 00
                
                endif
                
 0ABE 00        SAVEPOS:DB	0	;POSITION IN BUFFER CORRESPONDING TO
                			;BEGINNING OF LINE
                if BANKED
                
 0ABF 00        comchr:		db	0
 0AC0 00        cbuff$len:	db	0
 0AC1           cbuff:		ds	256
CP/M RMAC ASSEM 1.1	#030	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 0BC1 00        		db	0
 0BC2 00        xbuff:		db	0
 0BC3           		ds	354
 0D25 00        aposi:		db	0
 0D26 0000      xpos:		dw	0
 0D28 0000      apos:		dw	0
 0D2A 00        ctla$sw:	db	0
 0D2B 00        ctlw$sw:	db	0
 0D2C 00        save$column:	db	0
 0D2D 00        ctla$column:	db	0
 0D2E 00        new$ctla$col:	db	0
                
                endif
                
                ;	end of BDOS Console module
                ;
                ;**********************************************************************
                ;*****************************************************************
                ;
                ;	Error Messages
                
                if BANKED
                
 0000 =         md	equ	0
                
                else
                
                md	equ	24h
                
                endif
                
 0D2F 43502F4D20dskmsg: db	'CP/M Error On '
 0D3D 203A2000  dskerr: db	' : ',md
 0D41 4469736B20permsg: db	'Disk I/O',md
 0D4A 496E76616Cselmsg: db	'Invalid Drive',md
 0D58 526561642Frofmsg: db	'Read/Only File',md
 0D67 526561642Frodmsg: db	'Read/Only Disk',md
                
                if not MPM
                
                passmsg:
                
                if BANKED
 0D76 5061737377	db	'Password Error',md
                endif
                
                fxstsmsg:
 0D85 46696C6520	db	'File Exists',md
                
                wildmsg:
 0D91 3F20696E20	db	'? in Filename',md
                
                endif
                if MPM
                
                setlret1:
CP/M RMAC ASSEM 1.1	#031	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	mvi a,1
                sta$ret:
                	sta	aret
                func$ret:
                	ret
                entsp:	ds	2
                
                endif
                
                ;*****************************************************************
                ;*****************************************************************
                ;
                ;	common values shared between bdosi and bdos
                
                if MPM
                
                usrcode:db	0	; current user number
                
                endif
                
 0D9F           aret:	ds	2	; address value to return
 0D9F =         lret	equ	aret	; low(aret)
                
                ;*****************************************************************
                ;*****************************************************************
                ;**								**
                ;**   b a s i c    d i s k   o p e r a t i n g	 s y s t e m	**
                ;**								**
                ;*****************************************************************
                ;*****************************************************************
                
                ;	literal constants
                
 00FF =         true	equ	0ffh	; constant true
 0000 =         false	equ	000h	; constant false
 FFFF =         enddir	equ	0ffffh	; end of directory
 0001 =         byte	equ	1	; number of bytes for "byte" type
 0002 =         word	equ	2	; number of bytes for "word" type
                
                ;	fixed addresses in low memory
                
 005C =         tfcb	equ	005ch	; default fcb location
 0080 =         tbuff	equ	0080h	; default buffer location
                
                ;	error message handlers
                
                rod$error:
                	; report read/only disk error
 0DA1 0E02C3B20D	mvi c,2! jmp goerr
                
                rof$error:
                	; report read/only file error
 0DA6 0E03C3B20D	mvi c,3! jmp goerr
                
                sel$error:
                	; report select error
CP/M RMAC ASSEM 1.1	#032	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 0DAB 0E04      	mvi c,4
                	; Invalidate curdsk to force select call
                	; at next curselect call
 0DAD 3EFF32A928	mvi a,0ffh! sta curdsk
                
                goerr:
                	; hl = .errorhandler, call subroutine
 0DB2 612EFF229F	mov h,c! mvi l,0ffh! shld aret
                
                if MPM
                	call test$error$mode! jnz rtn$phy$errs
                	mov a,c! lxi h,pererr-2! jmp bdos$jmp
                else
                
                goerr1:
 0DB8 3AAA2832ED	lda adrive! sta errdrv
 0DBE 3AE7FB3CC4	lda error$mode! inr a! cnz error
                endif
                
                rtn$phy$errs:
                
                if MPM
                	lda lock$shell! ora a! jnz lock$perr
                endif
                
                	; Return 0ffffh if fx = 27 or 31
                
 0DC5 3ADFFB    	lda fx
 0DC8 FE1BCA3528	cpi 27! jz goback0
 0DCD FE1FCA3528	cpi 31! jz goback0
 0DD2 C33B28    	jmp goback
                
                if MPM
                
                test$error$mode:
                	lxi d,pname+4
                test$error$mode1:
                	call rlr! dad d
                	mov a,m! ani 80h! ret
                endif
                
                if BANKED
                
                set$copy$cr$only:
 0DD5 3ABC28321D	lda copy$cr$init! sta copy$cr$only! ret
                
                reset$copy$cr$only:
 0DDC AF32BC2832	xra a! sta copy$cr$init! sta copy$cr$only! ret
                
                endif
                
                bde$e$bde$m$hl:
 0DE4 7B955F    	mov a,e! sub l! mov e,a
 0DE7 7A9C57    	mov a,d! sbb h! mov d,a
 0DEA D005C9    	rnc! dcr b! ret
                
CP/M RMAC ASSEM 1.1	#033	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                bde$e$bde$p$hl:
 0DED 7B855F    	mov a,e! add l! mov e,a
 0DF0 7A8C57    	mov a,d! adc h! mov d,a
 0DF3 D004C9    	rnc! inr b! ret
                
                shl3bv:
 0DF6 0C        	inr c
                shl3bv1:
 0DF7 0DC8      	dcr c! rz
 0DF9 298FC3F70D	dad h! adc a! jmp shl3bv1
                
                incr$rr:
 0DFE CD3710    	call get$rra
 0E01 34C0      	inr m! rnz
 0E03 2334C0    	inx h! inr m! rnz
 0E06 2334C9    	inx h! inr m! ret
                
                save$rr:
 0E09 CD120EEB  	call save$rr2! xchg
                save$rr1:
 0E0D 0E03C3290E	mvi c,3! jmp move ; ret
                save$rr2:
 0E12 CD371011AE	call get$rra! lxi d,save$ranr! ret
                
                reset$rr:
 0E19 CD120EC30D	call save$rr2! jmp save$rr1 ; ret
                
                compare:
 0E1F 1ABEC0    	ldax d! cmp m! rnz
 0E22 23130DC8  	inx h! inx d! dcr c! rz
 0E26 C31F0E    	jmp compare
                
                ;
                ;	local subroutines for bios interface
                ;
                
                move:
                	; Move data length of length c from source de to
                	; destination given by hl
 0E29 0C        	inr c ; in case it is zero
                	move0:
 0E2A 0DC8      		dcr c! rz ; more to move
 0E2C 1A77      		ldax d! mov m,a ; one byte moved
 0E2E 1323      		inx d! inx h ; to next byte
 0E30 C32A0E    		jmp move0
                
                selectdisk:
                	; Select the disk drive given by register D, and fill
                	; the base addresses curtrka - alloca, then fill
                	; the values of the disk parameter block
 0E33 4A        	mov c,d ; current disk# to c
                	; lsb of e = 0 if not yet logged - in
 0E34 CD1BFF    	call seldskf ; hl filled by call
                	; hl = 0000 if error, otherwise disk headers
 0E37 7CB5C8    	mov a,h! ora l! rz ; Return with C flag reset if select error
                		; Disk header block address in hl
CP/M RMAC ASSEM 1.1	#034	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 0E3A 5E235623  		mov e,m! inx h! mov d,m! inx h ; de=.tran
 0E3E 2269282323		shld cdrmaxa! inx h! inx h ; .cdrmax
 0E43 226B282323		shld curtrka! inx h! inx h ; hl=.currec
 0E48 226D282323		shld curreca! inx h! inx h ; hl=.buffa
 0E4D 23226F2823		inx h! shld drvlbla! inx h
 0E52 2271282323		shld lsn$add! inx h! inx h
                		; de still contains .tran
 0E57 EB229A28  		xchg! shld tranv ; .tran vector
 0E5B 217328    		lxi h,dpbaddr ; de= source for move, hl=dest
 0E5E 0E0DCD290E		mvi c,addlist! call move ; addlist filled
                		; Now fill the disk parameter block
 0E63 2A7328EB  		lhld dpbaddr! xchg ; de is source
 0E67 218028    		lxi h,sectpt ; hl is destination
 0E6A 0E11CD290E		mvi c,dpblist! call move ; data filled
                		; Now set single/double map mode
 0E6F 2A8528    		lhld maxall ; largest allocation number
 0E72 7C        		mov a,h ; 00 indicates < 255
 0E73 21A32836FF		lxi h,single! mvi m,true ; Assume a=00
 0E78 B7CA7E0E  		ora a! jz retselect
                		; high order of maxall not zero, use double dm
 0E7C 3600      		mvi m,false
                	retselect:
                		; C flag set indicates successful select
 0E7E 37C9      		stc! ret
                
                home:
                	; Move to home position, then offset to start of dir
 0E80 CD18FF    	call homef
 0E83 AF        	xra a ; constant zero to accumulator
 0E84 2A6B287723	lhld curtrka! mov m,a! inx h! mov m,a ; curtrk=0000
 0E8A 2A6D287723	lhld curreca! mov m,a! inx h! mov m,a ; currec=0000
 0E90 2377      	inx h! mov m,a ; currec high byte=00
                
                if MPM
                	lxi h,0! shld dblk ; dblk = 0000
                endif
                
 0E92 C9        	ret
                
                rdbuff:
                	; Read buffer and check condition
 0E93 3E0132B428	mvi a,1! sta readf$sw
 0E98 CD27FF    	call readf ; current drive, track, sector, dma
 0E9B C3A50E    	jmp diocomp ; Check for i/o errors
                
                wrbuff:
                	; Write buffer and check condition
                	; write type (wrtype) is in register c
 0E9E AF32B428  	xra a! sta readf$sw
 0EA2 CD2AFF    	call writef ; current drive, track, sector, dma
                diocomp: ; Check for disk errors
 0EA5 B7C8      	ora a! rz
 0EA7 4F        	mov c,a
 0EA8 CDB60E    	call chk$media$flag
 0EAB 79        	mov a,c
 0EAC FE03DAB20D	cpi 3! jc goerr
CP/M RMAC ASSEM 1.1	#035	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 0EB1 0E01C3B20D	mvi c,1! jmp goerr
                
                chk$media$flag:
                	; A = 0ffh -> media changed
 0EB6 3CC0      	inr a! rnz
                
                if BANKED
                	; Handle media changes as I/O errors for
                	; permanent drives
 0EB8 CDEB0EC8  	call chksiz$eq$8000h! rz
                endif
                
                	; BIOS says media change occurred
                	; Is disk logged-in?
 0EBC 2A6528CD1D	lhld dlog! call test$vector! mvi c,1! rz ; no - return error
 0EC5 CDB211    	call media$change
 0EC8 E1        	pop h ; Discard return address
                	; Was this a flush operation (fx = 48)?
 0EC9 3ADFFBFE30	lda fx! cpi 48! rz ; yes
                	; Is this a flush to another drive?
 0ECF 21AA283AA4	lxi h,adrive! lda seldsk! cmp m! jnz reset$relog
                	; Bail out if fx = read, write, close, or search next
 0ED9 CD1312    	call chk$exit$fxs
                	; Is this a directory read operation?
 0EDC 3AB428B7C0	lda readf$sw! ora a! rnz ; yes
                	; Error - directory write operation
 0EE1 0E02C3B20D	mvi c,2! jmp goerr ; Return disk read/only error
                
                reset$relog:
                	; Reset relog if flushing to another drive
 0EE6 AF32DEFBC9	xra a! sta relog! ret
                
                if BANKED
                
                chksiz$eq$8000h:
                	; Return with Z flag set if drive permanent
                	; with no checksum vector
 0EEB 2A8B283E80	lhld chksiz! mvi a,80h! cmp h! rnz
 0EF2 AFBDC9    	xra a! cmp l! ret
                
                endif
                
                seekdir:
                	; Seek the record containing the current dir entry
                
                if MPM
                	lxi d,0ffffh ; mask = ffff
                	lhld dblk! mov a,h! ora l! jz seekdir1
                	lda blkmsk! mov e,a! xra a! mov d,a ; mask = blkmsk
                	lda blkshf! mov c,a! xra a
                	call shl3bv ; ahl = shl(dblk,blkshf)
                seekdir1:
                	push h! push a ; Save ahl
                endif
                
 0EF5 2AE1FB    	lhld dcnt ; directory counter to hl
CP/M RMAC ASSEM 1.1	#036	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 0EF8 0E02CDAB10	mvi c,dskshf! call hlrotr ; value to hl
 0EFD 229128    	shld drec
                
                if MPM
                
                ;	arecord = shl(dblk,blkshf) + shr(dcnt,dskshf) & mask
                
                	mov a,l! ana e! mov l,a ; dcnt = dcnt & mask
                	mov a,h! ana d! mov h,a
                	pop b! pop d! call bde$e$bde$p$hl
                
                else
 0F00 0600EB    	mvi b,0! xchg
                endif
                
                set$arecord:
 0F03 21AB28    	lxi h,arecord
 0F06 7323722370	mov m,e! inx h! mov m,d! inx h! mov m,b
 0F0B C9        	ret
                
                seek:
                	; Seek the track given by arecord (actual record)
                
 0F0C 2A6B284E23	lhld curtrka! mov c,m! inx h! mov b,m ; bc = curtrk
 0F12 C5        	push b ; s0 = curtrk
 0F13 2A6D285E23	lhld curreca! mov e,m! inx h! mov d,m
 0F19 2346      	inx h! mov b,m ; bde = currec
 0F1B 2AAB283AAD	lhld arecord! lda arecord+2! mov c,a ; chl = arecord
                seek0:
 0F22 7D937C9A79	mov a,l! sub e! mov a,h! sbb d! mov a,c! sbb b
 0F28 E5        	push h ; Save low(arecord)
 0F29 D2390F    	jnc seek1 ; if arecord >= currec then go to seek1
 0F2C 2A8028CDE4	lhld sectpt! call bde$e$bde$m$hl ; currec = currec - sectpt
 0F32 E1E32BE3  	pop h! xthl! dcx h! xthl ; curtrk = curtrk - 1
 0F36 C3220F    	jmp seek0
                seek1:
 0F39 2A8028CDED	lhld sectpt! call bde$e$bde$p$hl ; currec = currec + sectpt
 0F3F E1        	pop h ; Restore low(arecord)
 0F40 7D937C9A79	mov a,l! sub e! mov a,h! sbb d! mov a,c! sbb b
 0F46 DA500F    	jc seek2 ; if arecord < currec then go to seek2
 0F49 E323E3    	xthl! inx h! xthl ; curtrk = curtrk + 1
 0F4C E5        	push h ; save low (arecord)
 0F4D C3390F    	jmp seek1
                seek2:
 0F50 E3E5      	xthl! push h ; hl,s0 = curtrk, s1 = low(arecord)
 0F52 2A8028CDE4	lhld sectpt! call bde$e$bde$m$hl ; currec = currec - sectpt
 0F58 E1D5C5E5  	pop h! push d! push b! push h ; hl,s0 = curtrk,
                	; s1 = high(arecord,currec), s2 = low(currec),
                	; s3 = low(arecord)
 0F5C EB2A8D2819	xchg! lhld offset! dad d
 0F61 444D22FB28	mov b,h! mov c,l! shld track
 0F66 CD1EFF    	call settrkf ; call bios settrk routine
                	; Store curtrk
 0F69 D12A6B2873	pop d! lhld curtrka! mov m,e! inx h! mov m,d
                	; Store currec
 0F70 C1D1      	pop b! pop d!
CP/M RMAC ASSEM 1.1	#037	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 0F72 2A6D287323	lhld curreca! mov m,e! inx h! mov m,d
 0F78 2370      	inx h! mov m,b ; currec = bde
 0F7A C1        	pop b ; bc = low(arecord), de = low(currec)
 0F7B 79936F    	mov a,c! sub e! mov l,a ; hl = bc - de
 0F7E 78        	mov a,b
 0F7F 9A        	sbb d
 0F80 67        	mov h,a
 0F81 CD9D0F    	call shr$physhf
 0F84 444D      	mov b,h! mov c,l
                
 0F86 2A9A28EB  	lhld tranv! xchg ; bc=sector#, de=.tran
 0F8A CD30FF    	call sectran ; hl = tran(sector)
 0F8D 4D44      	mov c,l! mov b,h ; bc = tran(sector)
 0F8F 22FD28    	shld sector
 0F92 CD21FF    	call setsecf ; sector selected
 0F95 2A1BFD4D44	lhld curdma! mov c,l! mov b,h! jmp setdmaf
                	; ret
                shr$physhf:
 0F9D 3A8F284FC3	lda physhf! mov c,a! jmp hlrotr
                
                ;	file control block (fcb) constants
                
 00E5 =         empty	equ	0e5h	; empty directory entry
 007F =         lstrec	equ	127	; last record# on extent
 0080 =         recsiz	equ	128	; record size
 0020 =         fcblen	equ	32	; file control block size
 0004 =         dirrec	equ	recsiz/fcblen	; directory fcbs / record
 0002 =         dskshf	equ	2	; log2(dirrec)
 0003 =         dskmsk	equ	dirrec-1
 0005 =         fcbshf	equ	5	; log2(fcblen)
                
 000C =         extnum	equ	12	; extent number field
 001F =         maxext	equ	31	; largest extent number
 000D =         ubytes	equ	13	; unfilled bytes field
 000E =         modnum	equ	14	; data module number
                
 0040 =         maxmod	equ	64	; largest module number
                
 0080 =         fwfmsk	equ	80h	; file write flag is high order modnum
 000F =         namlen	equ	15	; name length
 000F =         reccnt	equ	15	; record count field
 0010 =         dskmap	equ	16	; disk map field
 001F =         lstfcb	equ	fcblen-1
 0020 =         nxtrec	equ	fcblen
 0021 =         ranrec	equ	nxtrec+1; random record field (2 bytes)
                
                ;	reserved file indicators
                
 0009 =         rofile	equ	9	; high order of first type char
 000A =         invis	equ	10	; invisible file in dir command
                
                ;	utility functions for file access
                
                dm$position:
                	; Compute disk map position for vrecord to hl
 0FA4 2182284E  	lxi h,blkshf! mov c,m ; shift count to c
CP/M RMAC ASSEM 1.1	#038	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 0FA8 3AA828    	lda vrecord ; current virtual record to a
                	dmpos0:
 0FAB B71F0DC2AB		ora a! rar! dcr c! jnz dmpos0
                	; a = shr(vrecord,blkshf) = vrecord/2**(sect/block)
 0FB1 47        	mov b,a ; Save it for later addition
 0FB2 3E0896    	mvi a,8! sub m ; 8-blkshf to accumulator
 0FB5 4F        	mov c,a ; extent shift count in register c
 0FB6 3AA628    	lda extval ; extent value ani extmsk
                	dmpos1:
                		; blkshf = 3,4,5,6,7, c=5,4,3,2,1
                		; shift is 4,3,2,1,0
 0FB9 0DCAC20F  		dcr c! jz dmpos2
 0FBD B717C3B90F		ora a! ral! jmp dmpos1
                	dmpos2:
                	; Arrive here with a = shl(ext and extmsk,7-blkshf)
 0FC2 80        	add b ; Add the previous shr(vrecord,blkshf) value
                	; a is one of the following values, depending upon alloc
                	; bks blkshf
                	; 1k   3     v/8 + extval * 16
                	; 2k   4     v/16+ extval * 8
                	; 4k   5     v/32+ extval * 4
                	; 8k   6     v/64+ extval * 2
                	; 16k  7     v/128+extval * 1
 0FC3 C9        	ret ; with dm$position in a
                
                getdma:
 0FC4 2ADBFB1110	lhld info! lxi d,dskmap! dad d! ret
                
                getdm:
                	; Return disk map value from position given by bc
 0FCC CDC40F    	call getdma
 0FCF 09        	dad b ; Index by a single byte value
 0FD0 3AA328    	lda single ; single byte/map entry?
 0FD3 B7CADA0F  	ora a! jz getdmd ; Get disk map single byte
 0FD7 6E60C9    		mov l,m! mov h,b! ret ; with hl=00bb
                	getdmd:
 0FDA 09        		dad b ; hl=.fcb(dm+i*2)
                		; double precision value returned
 0FDB 7E23666FC9		mov a,m! inx h! mov h,m! mov l,a! ret
                
                index:
                	; Compute disk block number from current fcb
 0FE0 CDA40F    	call dm$position ; 0...15 in register a
 0FE3 329F28    	sta dminx
 0FE6 4F0600CDCC	mov c,a! mvi b,0! call getdm ; value to hl
 0FEC 22AB287DB4	shld arecord! mov a,l! ora h! ret
                
                atran:
                	; Compute actual record address, assuming index called
                
                ;	arecord = shl(arecord,blkshf)
                
 0FF2 3A82284F  	lda blkshf! mov c,a
 0FF6 2AAB28AFCD	lhld arecord! xra a! call shl3bv
 0FFD 22AB2832AD	shld arecord! sta arecord+2
                
CP/M RMAC ASSEM 1.1	#039	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 1003 22B128    	shld arecord1 ; Save low(arecord)
                
                ;	arecord = arecord or (vrecord and blkmsk)
                
 1006 3A83284F3A	lda blkmsk! mov c,a! lda vrecord! ana c
 100E 47        	mov b,a ; Save vrecord & blkmsk in reg b & blk$off
 100F 329328    	sta blk$off
 1012 21AB28B677	lxi h,arecord! ora m! mov m,a! ret
                
                get$atts:
                	; Get volatile attributes starting at f'5
                	; info locates fcb
 1018 2ADBFB    	lhld info
 101B 11080019  	lxi d,8! dad d ; hl = .fcb(f'8)
 101F 0E04      	mvi c,4
                get$atts$loop:
 1021 7E87F5    	mov a,m! add a! push a
 1024 7A1F57    	mov a,d! rar! mov d,a
 1027 F10F77    	pop a! rrc! mov m,a
 102A 2B0DC22110	dcx h! dcr c! jnz get$atts$loop
 102F 7AC9      	mov a,d! ret
                
                get$s1:
                	; Get current s1 field to a
 1031 CD3F10237E	call getexta! inx h! mov a,m! ret
                
                get$rra:
                	; Get current ran rec field address to hl
 1037 2ADBFB1121	lhld info! lxi d,ranrec! dad d ; hl=.fcb(ranrec)
 103E C9        	ret
                
                getexta:
                	; Get current extent field address to hl
 103F 2ADBFB110C	lhld info! lxi d,extnum! dad d ; hl=.fcb(extnum)
 1046 C9        	ret
                
                getrcnta:
                	; Get reccnt address to hl
 1047 2ADBFB110F	lhld info! lxi d,reccnt! dad d! ret
                
                getfcba:
                	; Compute reccnt and nxtrec addresses for get/setfcb
 104F CD4710EB  	call getrcnta! xchg ; de=.fcb(reccnt)
 1053 21110019  	lxi h,(nxtrec-reccnt)! dad d ; hl=.fcb(nxtrec)
 1057 C9        	ret
                
                getfcb:
                	; Set variables from currently addressed fcb
 1058 CD4F10    	call getfcba ; addresses in de, hl
 105B 7E32A828  	mov a,m! sta vrecord ; vrecord=fcb(nxtrec)
 105F EB7EB7C26D	xchg! mov a,m! ora a! jnz getfcb0
 1065 CD97144FCD	call get$dir$ext! mov c,a! call set$rc! mov a,m
                getfcb0:
 106D FE81DA7410	cpi 81h! jc getfcb1
 1072 3E80      	mvi a,80h
                getfcb1:
CP/M RMAC ASSEM 1.1	#040	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 1074 32A528    	sta rcount ; rcount=fcb(reccnt) or 80h
 1077 CD3F10    	call getexta ; hl=.fcb(extnum)
 107A 3A8428    	lda extmsk ; extent mask to a
 107D A6        	ana m ; fcb(extnum) and extmsk
 107E 32A628    	sta extval
 1081 C9        	ret
                
                setfcb:
                	; Place values back into current fcb
 1082 CD4F10    	call getfcba ; addresses to de, hl
                	; fcb(cr) = vrecord
 1085 3AA82877  	lda vrecord! mov m,a
                	; Is fx < 22? (sequential read or write)
 1089 3ADFFBFE16	lda fx! cpi 22! jnc $+4 ; no
                	; fcb(cr) = fcb(cr) + 1
 1091 34        	inr m
 1092 EB7EFE80D0	xchg! mov a,m! cpi 80h! rnc ; dont reset fcb(rc) if > 7fh
 1097 3AA52877  	lda rcount! mov m,a ; fcb(reccnt)=rcount
 109B C9        	ret
                
                zero$ext$mod:
 109C CD3F107223	call getexta! mov m,d! inx h! inx h! mov m,d
 10A3 C9        	ret
                
                zero:
 10A4 70230DC8  	mov m,b! inx h! dcr c! rz
 10A8 C3A410    	jmp zero
                
                hlrotr:
                	; hl rotate right by amount c
 10AB 0C        	inr c ; in case zero
 10AC 0DC8      	hlrotr0: dcr c! rz ; return when zero
 10AE 7CB71F67  		mov a,h! ora a! rar! mov h,a ; high byte
 10B2 7D1F6F    		mov a,l! rar! mov l,a ; low byte
 10B5 C3AC10    		jmp hlrotr0
                
                compute$cs:
                	; Compute checksum for current directory buffer
 10B8 2A6728    	lhld buffa ; current directory buffer
 10BB 010400    	lxi b,4 ; b = 0, c = 4
                compute$cs0:
 10BE 1620      	mvi d,32 ; size of fcb
 10C0 AF        	xra a ; clear checksum value
                compute$cs1:
 10C1 862315    		add m! inx h! dcr d
 10C4 C2C110    		jnz compute$cs1
 10C7 A8470D    		xra b! mov b,a! dcr c
 10CA C2BE10    		jnz compute$cs0
 10CD C9        	ret ; with checksum in a
                
                if MPM
                
                compute$cs:
                	; Compute checksum for current directory buffer
                	mvi c,recsiz ; size of directory buffer
                	lhld buffa ; current directory buffer
CP/M RMAC ASSEM 1.1	#041	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	xra a ; Clear checksum value
                	computecs0:
                		add m! inx h! dcr c ; cs = cs+buff(recsiz-c)
                		jnz computecs0
                	ret ; with checksum in a
                
                chksum$fcb: ; Compute checksum for fcb
                	; Add 1st 12 bytes of fcb + curdsk +
                	;     high$ext + xfcb$read$only + bbh
                	lxi h,pdcnt! mov a,m
                	inx h! add m ; Add high$ext
                	inx h! add m ; Add xfcb$read$only
                	inx h! add m ; Add curdsk
                	adi 0bbh ; Add 0bbh to bias checksum
                	lhld info! mvi c,12! call computecs0
                	; Skip extnum
                	inx h
                	; Add fcb(s1)
                	add m! inx h
                	; Skip modnum
                	inx h
                	; Skip fcb(reccnt)
                	; Add disk map
                	inx h! mvi c,16! call computecs0
                	ora a! ret ; Z flag set if checksum valid
                
                set$chksum$fcb:
                	call chksum$fcb! rz
                	mov b,a! call gets1
                	cma! add b! cma
                	mov m,a! ret
                
                reset$chksum$fcb:
                	xra a! sta comp$fcb$cks
                	call chksum$fcb! rnz
                	call get$s1! inr m! ret
                
                endif
                
                check$fcb:
                
                if MPM
                	xra a! sta check$fcb4
                check$fcb1:
                	call chek$fcb! rz
                check$fcb2:
                
                	ani 0fh! jnz check$fcb3
                	lda pdcnt! ora a! jz check$fcb3
                	call set$sdcnt! sta dont$close
                	call close1
                	lxi h,lret! inr m! jz check$fcb3
                	mvi m,0! call pack$sdcnt! mvi b,5
                	call search$olist! rz
                check$fcb3:
                
CP/M RMAC ASSEM 1.1	#042	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	pop h ; Discard return address
                check$fcb4:
                	nop
                	mvi a,10! jmp sta$ret
                
                set$fcb$cks$flag:
                	mvi a,0ffh! sta comp$fcb$cks! ret
                
                else
 10CE CD31102A71	call gets1! lhld lsn$add
 10D4 BEC4E310  	cmp m! cnz chk$media$fcb
                endif
                
                chek$fcb:
 10D8 3AB528    	lda high$ext
                
                if MPM
                
                	; if ext & 0110$0000b = 0110$0000b then
                	; set fcb(0) to 0 (user 0)
                
                	cpi 0110$0000b! jnz chek$fcb1
                else
 10DB B7C8      	ora a! rz
                endif
                
 10DD 2ADBFBAF77	lhld info! xra a! mov m,a ; fcb(0) = 0
                chek$fcb1:
                
                if MPM
                	jmp chksum$fcb ; ret
                else
 10E2 C9        	ret
                
                chk$media$fcb:
                	; fcb(s1) ~= DPH login sequence # field
                	; Is fcb addr < bdosadd?
                
                if banked
 10E3 2A1EFD    	lhld user$info
                else
                	lhld info
                endif
                
 10E6 EB2AFEFBCD	xchg! lhld bdosadd! call subdh! jnc chk$media1 ; no
                	; Is rlog(drive) true?
 10F0 2A92FBCD1D	lhld rlog! call testvector! rz ; no
                chk$media1:
                	; Return invalid fcb error code
 10F7 E1E1      	pop h! pop h
                chk$media2:
 10F9 3E0AC3720A	mvi a,10! jmp sta$ret
                endif
                
                hlrotl:
                	; Rotate the mask in hl by amount in c
CP/M RMAC ASSEM 1.1	#043	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 10FE 0C        	inr c ; may be zero
 10FF 0DC8      	hlrotl0: dcr c! rz ; return if zero
 1101 29C3FF10  		dad h! jmp hlrotl0
                
                set$dlog:
 1105 116528    	lxi d,dlog
                set$cdisk:
                	; Set a "1" value in curdsk position of bc
 1108 3AA928    	lda curdsk
                set$cdisk1:
 110B 4F        	mov c,a ; Ready parameter for shift
 110C 210100    	lxi h,1 ; number to shift
 110F CDFE10    	call hlrotl ; hl = mask to integrate
 1112 1AB51213  	ldax d! ora l! stax d! inx d
 1116 1AB412C9  	ldax d! ora h! stax d! ret
                
                nowrite:
                	; Return true if dir checksum difference occurred
 111A 2A6328    	lhld rodsk
                
                test$vector:
 111D 3AA928    	lda curdsk
                test$vector1:
 1120 4FCDAB10  	mov c,a! call hlrotr
 1124 7DE601C9  	mov a,l! ani 1b! ret ; non zero if curdsk bit on
                
                check$rodir:
                	; Check current directory element for read/only status
 1128 CD4011    	call getdptra ; address of element
                
                check$rofile:
                	; Check current buff(dptr) or fcb(0) for r/o status
 112B CD3211    	call ro$test
 112E D0        	rnc ; Return if not set
 112F C3A60D    	jmp rof$error ; Exit to read only disk message
                
                ro$test:
 1132 11090019  	lxi d,rofile! dad d
 1136 7E17C9    	mov a,m! ral! ret ; carry set if r/o
                
                check$write:
                	; Check for write protected disk
 1139 CD1A11C8  	call nowrite! rz ; ok to write if not rodsk
 113D C3A10D    	jmp rod$error ; read only disk error
                
                getdptra:
                	; Compute the address of a directory element at
                	; positon dptr in the buffer
                
 1140 2A67283AB7	lhld buffa! lda dptr
                addh:
                	; hl = hl + a
 1146 856FD0    	add l! mov l,a! rnc
                	; overflow to h
 1149 24C9      	inr h! ret
                
CP/M RMAC ASSEM 1.1	#044	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                getmodnum:
                	; Compute the address of the module number
                	; bring module number to accumulator
                	; (high order bit is fwf (file write flag)
 114B 2ADBFB110E	lhld info! lxi d,modnum! dad d ; hl=.fcb(modnum)
 1152 7EC9      	mov a,m! ret ; a=fcb(modnum)
                
                clrmodnum:
                	; Clear the module number field for user open/make
 1154 CD4B113600	call getmodnum! mvi m,0 ; fcb(modnum)=0
 1159 C9        	ret
                
                clr$ext:
                	; fcb ext = fcb ext & 1fh
 115A CD3F107EE6	call getexta! mov a,m! ani 0001$1111b! mov m,a!
 1161 C9        	ret
                
                setfwf:
 1162 CD4B11    	call getmodnum ; hl=.fcb(modnum), a=fcb(modnum)
                	; Set fwf (file write flag) to "1"
 1165 F68077    	ori fwfmsk! mov m,a ; fcb(modnum)=fcb(modnum) or 80h
                	; also returns non zero in accumulator
 1168 C9        	ret
                
                compcdr:
                	; Return cy if cdrmax > dcnt
 1169 2AE1FBEB  	lhld dcnt! xchg ; de = directory counter
 116D 2A6928    	lhld cdrmaxa ; hl=.cdrmax
 1170 7B96      	mov a,e! sub m ; low(dcnt) - low(cdrmax)
 1172 23        	inx h ; hl = .cdrmax+1
 1173 7A9E      	mov a,d! sbb m ; hig(dcnt) - hig(cdrmax)
                	; condition dcnt - cdrmax  produces cy if cdrmax>dcnt
 1175 C9        	ret
                
                setcdr:
                	; if not (cdrmax > dcnt) then cdrmax = dcnt+1
 1176 CD6911    	call compcdr
 1179 D8        	rc ; Return if cdrmax > dcnt
                	; otherwise, hl = .cdrmax+1, de = dcnt
 117A 13722B73  	inx d! mov m,d! dcx h! mov m,e
 117E C9        	ret
                
                subdh:
                	; Compute hl = de - hl
 117F 7B956F7A9C	mov a,e! sub l! mov l,a! mov a,d! sbb h! mov h,a
 1185 C9        	ret
                
                newchecksum:
 1186 0EFE      	mvi c,0feh ; Drop through to compute new checksum
                checksum:
                	; Compute current checksum record and update the
                	; directory element if c=true, or check for = if not
                	; drec < chksiz?
 1188 2A9128EB2A	lhld drec! xchg! lhld chksiz
 118F 7CE67F67  	mov a,h! ani 7fh! mov h,a ; Mask off permanent drive bit
 1193 CD7F11    	call subdh ; de-hl
CP/M RMAC ASSEM 1.1	#045	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 1196 D0        	rnc ; Skip checksum if past checksum vector size
                		; drec < chksiz, so continue
 1197 C5        		push b ; Save init flag
 1198 CDB810    		call compute$cs ; Check sum value to a
 119B 2A7528    		lhld checka ; address of check sum vector
 119E EB        		xchg
 119F 2A9128    		lhld drec
 11A2 19        		dad d ; hl = .check(drec)
 11A3 C1        		pop b ; Recall true=0ffh or false=00 to c
 11A4 0C        		inr c ; 0ffh produces zero flag
 11A5 CAC611    		jz initial$cs
 11A8 0C        		inr c ; 0feh produces zero flag
 11A9 CAD111    		jz update$cs
                
                if MPM
                		inr c! jz test$dir$cs
                endif
                
                			; not initializing, compare
 11AC BE        			cmp m ; compute$cs=check(drec)?
 11AD C8        			rz ; no message if ok
                			; checksum error, are we beyond
                			; the end of the disk?
 11AE CD1A11    			call nowrite
                ;;;			rnz	;[JCE] DRI Patch 13
 11B1 00        			nop
                
                media$change:
 11B2 CD5212    			call discard$data
                
                if MPM
                			call flush$file0
                else
 11B5 3EFF32DEFB			mvi a,0ffh! sta relog! sta hashl
 11BD CDE811    			call set$rlog
                endif
                
                			; Reset the drive
                
 11C0 CD0511C35A			call set$dlog! jmp reset37x
                
                if MPM
                		test$dir$cs:
                			cmp m! jnz flush$files
                			ret
                endif
                
                		initial$cs:
                			; initializing the checksum
 11C6 BE77C8    			cmp m! mov m,a! rz
                			; or 1 into login seq # if media change
 11C9 2A71283E01			lhld lsn$add! mvi a,1! ora m! mov m,a! ret
                
                		update$cs:
                			; updating the checksum
 11D1 77C9      			mov m,a! ret
CP/M RMAC ASSEM 1.1	#046	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                set$ro:
                	; Set current disk to read/only
 11D3 3AA4281163	lda seldsk! lxi d,rodsk! call set$cdisk1 ; sets bit to 1
                	; high water mark in directory goes to max
 11DC 2A872823EB	lhld dirmax! inx h! xchg ; de = directory max
 11E1 2A6928    	lhld cdrmaxa ; hl = .cdrmax
 11E4 732372    	mov m,e! inx h! mov m,d ; cdrmax = dirmax
 11E7 C9        	ret
                
                set$rlog:
                	; rlog(seldsk) = true
 11E8 2A90FBCD1D	lhld olog! call test$vector! rz
 11EF 1192FBC308	lxi d,rlog! jmp set$cdisk
                
                tst$log$fxs:
 11F5 3A8C28E680	lda chksiz+1! ani 80h! rnz
 11FB 21C028    	lxi h,log$fxs
                tst$log0:
 11FE 3ADFFB47  	lda fx! mov b,a
                tst$log1:
 1202 7EB8C8    	mov a,m! cmp b! rz
 1205 23B7C20212	inx h! ora a! jnz tst$log1
 120A 3CC9      	inr a! ret
                
                test$media$flag:
 120C 2A7128237E	lhld lsn$add! inx h! mov a,m! ora a! ret
                
                chk$exit$fxs:
 1213 213B28E5  	lxi h,goback! push h
                	; does fx = read or write function?
                	; and is drive removable?
 1217 21CD28CDFE	lxi h,rw$fxs! call tst$log0! jz chk$media2 ; yes
                	; is fx = close or searchn function?
                	; and is drive removable?
 1220 21D428CDFE	lxi h,sc$fxs! call tst$log0! jz lret$eq$ff ; yes
 1229 E1C9      	pop h! ret
                
                tst$relog:
 122B 21DEFB7EB7	lxi h,relog! mov a,m! ora a! rz
 1231 3600      	mvi m,0
                drv$relog:
 1233 CD6B1E    	call curselect
 1236 21000022E1	lxi h,0! shld dcnt! xra a! sta dptr
 1240 C9        	ret
                
                set$lsn:
 1241 2A71284E  	lhld lsn$add! mov c,m
 1245 CD311071C9	call gets1! mov m,c! ret
                
                discard$data$bcb:
 124A 2A7B280E04	lhld dtabcba! mvi c,4! jmp discard0
                
                discard$data:
 1252 2A7B28C35B	lhld dtabcba! jmp discard
                
CP/M RMAC ASSEM 1.1	#047	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                discard$dir:
 1258 2A7928    	lhld dirbcba
                
                discard:
 125B 0E01      	mvi c,1
                discard0:
 125D 7DA43CC8  	mov a,l! ana h! inr a! rz
                
                if BANKED
 1261 5E2356EB  	mov e,m! inx h! mov d,m! xchg
                discard1:
 1265 E5C5      	push h! push b
 1267 11AA28CD1F	lxi d,adrive! call compare
 126D C1E1C27412	pop b! pop h! jnz discard2
                
 1272 36FF      	mvi m,0ffh
                discard2:
 1274 110D0019  	lxi d,13! dad d
 1278 5E2356    	mov e,m! inx h! mov d,m
 127B EB7DB4C8  	xchg! mov a,l! ora h! rz
 127F C36512    	jmp discard1
                else
                	push h
                	lxi d,adrive! call compare
                	pop h! rnz
                	mvi m,0ffh! ret
                endif
                
                get$buffa:
 1282 D5110A0019	push d! lxi d,10! dad d
 1287 5E2356    	mov e,m! inx h! mov d,m
                
                if BANKED
 128A 237E32FA28	inx h! mov a,m! sta buffer$bank
                endif
                
 128F EBD1C9    	xchg! pop d! ret
                
                rddir:
                	; Read a directory entry into the directory buffer
 1292 CDF50E    	call seek$dir
 1295 3E03C3A212	mvi a,3! jmp wrdir0
                
                seek$copy:
                wrdir:
                	; Write the current directory entry, set checksum
 129A CD3911    	call check$write
 129D CD8611    	call newchecksum ; Initialize entry
 12A0 3E05      	mvi a,5
                wrdir0:
 12A2 2100002296	lxi h,0! shld last$block
 12A8 2A7928    	lhld dirbcba
                
                if BANKED
 12AB FE05C2B312	cpi 5! jnz $+6
 12B0 2AF028    	lhld curbcba
CP/M RMAC ASSEM 1.1	#048	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                endif
                
 12B3 CD5829    	call deblock
                
                setdata:
                	; Set data dma address
 12B6 2AD8FBC3BF	lhld dmaad! jmp setdma ; to complete the call
                
                setdir1:
 12BC CD8212    	call get$buffa
                
                setdma:
                	; hl=.dma address to set (i.e., buffa or dmaad)
 12BF 221BFDC9  	shld curdma! ret
                
                dir$to$user:
                
                if not MPM
                	; Copy the directory entry to the user buffer
                	; after call to search or searchn by user code
 12C3 2A6728EB  	lhld buffa! xchg ; source is directory buffer
 12C7 2A19FD    	lhld xdmaad ; destination is user dma address
 12CA 018000    	lxi b,recsiz ; copy entire record
 12CD CD4BFF    	call movef
                endif
                	; Set lret to dcnt & 3 if search successful
 12D0 219F0D7E3C	lxi h,lret! mov a,m! inr a! rz
 12D6 3AE1FBE603	lda dcnt! ani dskmsk! mov m,a! ret
                
                make$fcb$inv: ; Flag fcb as invalid
                	; Reset fcb write flag
 12DD CD6211    	call setfwf
                	; Set 1st two bytes of diskmap to ffh
 12E0 23233EFF77	inx h! inx h! mvi a,0ffh! mov m,a! inx h! mov m,a
 12E7 C9        	ret
                
                chk$inv$fcb: ; Check for invalid fcb
 12E8 CDC40FC3FB	call getdma! jmp test$ffff
                
                tst$inv$fcb: ; Test for invalid fcb
 12EE CDE812C0  	call chk$inv$fcb! rnz
 12F2 E13E09C372	pop h! mvi a,9! jmp sta$ret! ; lret = 9
                
                end$of$dir:
                	; Return zero flag if at end of directory, non zero
                	; if not at end (end of dir if dcnt = 0ffffh)
 12F8 21E1FB    	lxi h,dcnt
                test$ffff:
 12FB 7E        	mov a,m ; may be 0ffh
 12FC 23BE      	inx h! cmp m ; low(dcnt) = high(dcnt)?
 12FE C0        	rnz ; non zero returned if different
                	; high and low the same, = 0ffh?
 12FF 3C        	inr a ; 0ffh becomes 00 if so
 1300 C9        	ret
                
                set$end$dir:
CP/M RMAC ASSEM 1.1	#049	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	; Set dcnt to the end of the directory
 1301 21FFFF22E1	lxi h,enddir! shld dcnt! ret
                
                read$dir:
 1308 CD0E13C340	call r$dir! jmp r$dir1
                
                r$dir:
                	; Read next directory entry, with c=true if initializing
                
 130E 2A8728EB  	lhld dirmax! xchg ; in preparation for subtract
 1312 2AE1FB2322	lhld dcnt! inx h! shld dcnt ; dcnt=dcnt+1
                	; Continue while dirmax >= dcnt (dirmax-dcnt no cy)
 1319 CD7F11    	call subdh ; de-hl
                
 131C DA0113    	jc set$end$dir
                
                	read$dir0:
                		; not at end of directory, seek next element
                		; initialization flag is in c
 131F 3AE1FBE603		lda dcnt! ani dskmsk ; low(dcnt) and dskmsk
 1324 0605      		mvi b,fcbshf ; to multiply by fcb size
                		read$dir1:
 1326 8705C22613			add a! dcr b! jnz read$dir1
                		; a = (low(dcnt) and dskmsk) shl fcbshf
 132B 32B728    		sta dptr ; ready for next dir operation
 132E B7C0      		ora a! rnz ; Return if not a new record
                	read$dir2:
 1330 C5        		push b ; Save initialization flag c
 1331 CD9212    		call rd$dir ; Read the directory record
 1334 C1        		pop b ; Recall initialization flag
 1335 3ADEFBB7C0		lda relog! ora a! rnz
 133A C38811    		jmp checksum ; Checksum the directory elt
                
                r$dir2:
 133D CD3013    	call read$dir2
                r$dir1:
 1340 3ADEFBB7C8	lda relog! ora a! rz
 1345 CD1312    	call chk$exit$fxs
 1348 CD2B12C392	call tst$relog! jmp rd$dir
                
                getallocbit:
                	; Given allocation vector position bc, return with byte
                	; containing bc shifted so that the least significant
                	; bit is in the low order accumulator position.  hl is
                	; the address of the byte for possible replacement in
                	; memory upon return, and d contains the number of shifts
                	; required to place the returned value back into position
 134E 79E6073C5F	mov a,c! ani 111b! inr a! mov e,a! mov d,a
                	; d and e both contain the number of bit positions to shift
                
 1354 60690E03  	mov h,b! mov l,c! mvi c,3 ; bc = bc shr 3
 1358 CDAB10    	call hlrotr ; hlrotr does not touch d and e
 135B 444D      	mov b,h! mov c,l
                
 135D 2A7728    	lhld alloca ; base address of allocation vector
 1360 097E      	dad b! mov a,m ; byte to a, hl = .alloc(bc shr 3)
CP/M RMAC ASSEM 1.1	#050	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	; Now move the bit to the low order position of a
 1362 071DC26213	rotl: rlc! dcr e! jnz rotl! ret
                
                setallocbit:
                	; bc is the bit position of alloc to set or reset.  the
                	; value of the bit is in register e.
 1368 D5CD4E13  	push d! call getallocbit ; shifted val a, count in d
 136C E6FE      	ani 1111$1110b ; mask low bit to zero (may be set)
 136E C1B1      	pop b! ora c ; low bit of c is masked into a
                	; jmp rotr ; to rotate back into proper position
                	; ret
                
                rotr:
                	; byte value from alloc is in register a, with shift count
                	; in register c (to place bit back into position), and
                	; target alloc position in registers hl, rotate and replace
 1370 0F15C27013	rrc! dcr d! jnz rotr ; back into position
 1375 77        	mov m,a ; back to alloc
 1376 C9        	ret
                
                copy$alv:
                	; If Z flag set, copy 1st ALV to 2nd
                	; Otherwise, copy 2nd ALV to 1st
                
                if not BANKED
                	lda bdos$flags! rlc! rlc! rc
                endif
                
 1377 F5        	push a
 1378 CDDE13444D	call get$nalbs! mov b,h! mov c,l
 137D 2A7728545D	lhld alloca! mov d,h! mov e,l! dad b
 1383 F1CA4BFF  	pop a! jz movef
 1387 EBC34BFF  	xchg! jmp movef
                
                scandm$ab:
                	; Set/Reset 1st and 2nd ALV
 138B C5CDA613  	push b! call scandm$a
 138F C1        	pop b! ;jmp scandm$b
                
                scandm$b:
                	; Set/Reset 2nd ALV
                
                if not BANKED
                	lda bdos$flags! ani 40h! rnz
                endif
                
 1390 C5CDDE13  	push b! call get$nalbs
 1394 EB2A7728  	xchg! lhld alloca
 1398 C1E5192277	pop b! push h! dad d! shld alloca
 139E CDA613    	call scandm$a
 13A1 E1227728C9	pop h! shld alloca! ret
                
                scandm$a:
                	; Set/Reset 1st ALV
                	; Scan the disk map addressed by dptr for non-zero
                	; entries, the allocation vector entry corresponding
CP/M RMAC ASSEM 1.1	#051	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	; to a non-zero entry is set to the value of c (0,1)
 13A6 CD4011    	call getdptra ; hl = buffa + dptr
                	; hl addresses the beginning of the directory entry
 13A9 11100019  	lxi d,dskmap! dad d ; hl now addresses the disk map
 13AD C5        	push b ; Save the 0/1 bit to set
 13AE 0E11      	mvi c,fcblen-dskmap+1 ; size of single byte disk map + 1
                	scandm0:
                		; Loop once for each disk map entry
 13B0 D1        		pop d ; Recall bit parity
 13B1 0DC8      		dcr c! rz ; all done scanning?
                		; no, get next entry for scan
 13B3 D5        		push d ; Replace bit parity
 13B4 3AA328B7CA		lda single! ora a! jz scandm1
                			; single byte scan operation
 13BB C5        			push b ; Save counter
 13BC E5        			push h ; Save map address
 13BD 4E0600    			mov c,m! mvi b,0 ; bc=block#
 13C0 C3C913    			jmp scandm2
                		scandm1:
                			; double byte scan operation
 13C3 0D        			dcr c ; count for double byte
 13C4 C5        			push b ; Save counter
 13C5 4E2346    			mov c,m! inx h! mov b,m ; bc=block#
 13C8 E5        			push h ; Save map address
                		scandm2:
                			; Arrive here with bc=block#, e=0/1
 13C9 79B0      			mov a,c! ora b ; Skip if = 0000
 13CB CAD813    			jz scandm3
 13CE 2A8528    			lhld maxall ; Check invalid index
 13D1 7D917C98  			mov a,l! sub c! mov a,h! sbb b ; maxall - block#
 13D5 D46813    			cnc set$alloc$bit
                			; bit set to 0/1
                		scandm3:
 13D8 E123      			pop h! inx h ; to next bit position
 13DA C1        			pop b ; Recall counter
 13DB C3B013    			jmp scandm0 ; for another item
                
                get$nalbs: ; Get # of allocation vector bytes
 13DE 2A85280E03	lhld maxall! mvi c,3
                	; number of bytes in allocation vector is (maxall/8)+1
 13E3 CDAB1023C9	call hlrotr! inx h! ret
                
                if MPM
                
                test$dir:
                	call home
                	call set$end$dir
                test$dir1:
                	mvi c,0feh! call read$dir
                	lda flushed! ora a! rnz
                	call end$of$dir! rz
                	jmp test$dir1
                endif
                
                initialize:
                	; Initialize the current disk
CP/M RMAC ASSEM 1.1	#052	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	; lret = false ; set to true if $ file exists
                	; Compute the length of the allocation vector - 2
                
                if MPM
                	lhld tlog! call test$vector! jz initialize1
                	lhld tlog! call remove$drive! shld tlog
                	xra a! sta flushed
                	call test$dir! rz
                initialize1:
                else
                
 13E8 CD0C123600	call test$media$flag ! mvi m,0
                ;;;	call discard$data ;[JCE] DRI Patch 13 
                ;;;	call discard$dir
                
                endif
                ;[JCE] DRI Patch 13
                
                if BANKED
                ;;;	; Is drive permanent with no chksum vector?
                ;;;	call chksiz$eq$8000h
                ;;;	jnz initialize2 ; no
                ;;;	; Is this an initial login operation?
                ;;;	; register A = 0
                ;;;	lhld lsn$add
                ;;;	cmp m
                ;;;	mvi m,2
                ;;;	call test$media$flag
                ;;;	mvi m,0 ; Reset media change flag
 13ED CDEB0E    	call chksiz$eq$8000h
 13F0 C2FF13    	jnz patch$13ff
 13F3 2A7128    	lhld lsn$add
 13F6 BE        	cmp m
 13F7 00        	nop
 13F8 00        	nop
 13F9 CAFF13    	jz patch$13ff
 13FC C3402D    	jmp patch$2d40
                
                patch$13ff:
                
 13FF CD5212    	call discard$data
 1402 CD5812    	call discard$dir
                
                initialize2:
                else	;BANKED
                	call discard$data ;[JCE] DRI Patch 13 
                	call discard$dir
                
                endif
                
 1405 CDDE13    	call get$nalbs ; Get # of allocation vector bytes
 1408 444D      	mov b,h! mov c,l ; Count down bc til zero
 140A 2A7728    	lhld alloca ; base of allocation vector
                	; Fill the allocation vector with zeros
                	initial0:
 140D 360023    		mvi m,0! inx h ; alloc(i)=0
CP/M RMAC ASSEM 1.1	#053	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 1410 0B        		dcx b ; Count length down
 1411 78B1C20D14		mov a,b! ora c! jnz initial0
                
 1416 2A6F2877  	lhld drvlbla! mov m,a ; Zero out drive desc byte
                
                	; Set the reserved space for the directory
                
 141A 2A8928EB  	lhld dirblk! xchg
 141E 2A7728    	lhld alloca ; hl=.alloc()
 1421 732372    	mov m,e! inx h! mov m,d ; sets reserved directory blks
                	; allocation vector initialized, home disk
 1424 CD800E    	call home
                	; cdrmax = 3 (scans at least one directory record)
 1427 2A69283604	lhld cdrmaxa! mvi m,4! inx h! mvi m,0
                
 142F CD0113    	call set$end$dir ; dcnt = enddir
 1432 2A7D2822B1	lhld hashtbla! shld arecord1
                
                	; Read directory entries and check for allocated storage
                
                	initial2:
 1438 0EFFCD0813		mvi c,true! call read$dir
 143D CDF812    		call end$of$dir
                if BANKED
 1440 CA6A2D    		jz patch$2d6a	;[JCE] DRI Patch 13
                else
                		jz copy$alv
                endif
                		; not end of directory, valid entry?
 1443 CD4011    		call getdptra ; hl = buffa + dptr
 1446 EB2AB1287C		xchg! lhld arecord1! mov a,h! ana l! inr a! xchg
                		; is hashtbla ~= 0ffffh
 144E C48F2B    		cnz init$hash ; yes - call init$hash
 1451 3E21BE    		mvi a,21h! cmp m
 1454 CA3814    		jz initial2 ; Skip date & time records
                
 1457 3EE5BE    		mvi a,empty! cmp m
 145A CA3814    		jz initial2 ; go get another item
                
 145D 3E20BECA74		mvi a,20h! cmp m! jz drv$lbl
 1463 3E10A6C26E		mvi a,10h! ana m! jnz initial3
                
                		; Now scan the disk map for allocated blocks
                
 1469 0E01      		mvi c,1 ; set to allocated
 146B CDA613    		call scandm$a
                	initial3:
 146E CD7611    		call setcdr ; set cdrmax to dcnt
 1471 C33814    		jmp initial2 ; for another entry
                
                drv$lbl:
 1474 110C00197E		lxi d,extnum! dad d! mov a,m
 1479 2A6F2877C3		lhld drvlbla! mov m,a! jmp initial3
                
                copy$dirloc:
                	; Copy directory location to lret following
CP/M RMAC ASSEM 1.1	#054	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	; delete, rename, ... ops
                
 1480 3A9D28C372	lda dirloc! jmp sta$ret
                	; ret
                
                compext:
                	; Compare extent# in a with that in c, return nonzero
                	; if they do not match
 1486 C5        	push b ; Save c's original value
 1487 F53A84282F	push psw! lda extmsk! cma! mov b,a
                	; b has negated form of extent mask
 148D 79A04F    	mov a,c! ana b! mov c,a ; low bits removed from c
 1490 F1A0      	pop psw! ana b ; low bits removed from a
 1492 91E61F    	sub c! ani maxext ; Set flags
 1495 C1        	pop b ; Restore original values
 1496 C9        	ret
                
                get$dir$ext:
                	; Compute directory extent from fcb
                	; Scan fcb disk map backwards
 1497 CD4F10    	call getfcba ; hl = .fcb(vrecord)
 149A 0E10410CC5	mvi c,16! mov b,c! inr c! push b
                	; b=dskmap pos (rel to 0)
                get$de0:
 149F C1        	pop b
 14A0 0D        	dcr c
 14A1 AF        	xra a ; Compare to zero
                get$de1:
 14A2 2B05      	dcx h! dcr b; Decr dskmap position
 14A4 BEC2AC14  	cmp m! jnz get$de2 ; fcb(dskmap(b)) ~= 0
 14A8 0DC2A214  	dcr c! jnz get$de1
                	; c = 0 -> all blocks = 0 in fcb disk map
                get$de2:
 14AC 79329F28  	mov a,c! sta dminx
 14B0 3AA328B778	lda single! ora a! mov a,b
 14B5 C2B914    	jnz get$de3
 14B8 1F        	rar ; not single, divide blk idx by 2
                get$de3:
 14B9 C5E5      	push b! push h ; Save dskmap position & count
 14BB 6F2600    	mov l,a! mvi h,0 ; hl = non-zero blk idx
                	; Compute ext offset from last non-zero
                	; block index by shifting blk idx right
                	; 7 - blkshf
 14BE 3A8228573E	lda blkshf! mov d,a! mvi a,7! sub d
 14C5 4FCDAB1045	mov c,a! call hlrotr! mov b,l
                	; b = ext offset
 14CA 3A8428B8E1	lda extmsk! cmp b! pop h! jc get$de0
                	; Verify computed extent offset <= extmsk
 14D2 CD3F104E  	call getexta! mov c,m
 14D6 2FE61FA1B0	cma! ani maxext! ana c! ora b
                	; dir ext = (fcb ext & (~ extmsk) & maxext) | ext offset
 14DB C1        	pop b ; Restore stack
 14DC C9        	ret ; a = directory extent
                
                searchi:
                	; search initialization
CP/M RMAC ASSEM 1.1	#055	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 14DD 2ADBFB22A0	lhld info! shld searcha ; searcha = info
                searchi1:
 14E3 7932E5FB  	mov a,c! sta searchl ; searchl = c
 14E7 CDA62B    	call set$hash
 14EA 3EFF329D28	mvi a,0ffh! sta dirloc ; changed if actually found
 14EF C9        	ret
                
                search$namlen:
 14F0 0E0FC3F714	mvi c,namlen! jmp search
                search$extnum:
 14F5 0E0C      	mvi c,extnum
                search:
                	; Search for directory element of length c at info
 14F7 CDDD14    	call searchi
                search1: ; entry point used by rename
 14FA CD0113    	call set$end$dir ; dcnt = enddir
 14FD CDF511CC80	call tst$log$fxs! cz home
                	; (drop through to searchn)
                
                searchn:
                	; Search for the next directory element, assuming
                	; a previous call on search which sets searcha and
                	; searchl
                
                if MPM
                	lxi h,user0$pass! xra a! cmp m! mov m,a! cnz swap
                else
 1503 AF32BE28  	xra a! sta user0$pass
                endif
                
 1507 CD6B2CC2BA	call search$hash! jnz search$fin
 150D 0E00CD0813	mvi c,false! call read$dir ; Read next dir element
 1512 CDF812CABA	call end$of$dir! jz search$fin
                		; not end of directory, scan for match
 1518 2AA028EB  		lhld searcha! xchg ; de=beginning of user fcb
 151C 1A        		ldax d ; first character
 151D FEE5      		cpi empty ; Keep scanning if empty
 151F CA2A15    		jz searchnext
                		; not empty, may be end of logical directory
 1522 D5        		push d ; Save search address
 1523 CD6911    		call compcdr ; past logical end?
 1526 D1        		pop d ; Recall address
 1527 D2BA15    		jnc search$fin ; artificial stop
                searchnext:
 152A CD4011    		call getdptra ; hl = buffa+dptr
 152D 3AE5FB4F  		lda searchl! mov c,a ; length of search to c
 1531 0600      		mvi b,0 ; b counts up, c counts down
                
 1533 7EFEE5CCED		mov a,m! cpi empty! cz save$dcnt$pos1
                
                if BANKED
 1539 AF32A228  		xra a! sta save$xfcb
 153D 7EE6EFBECA		mov a,m! ani 1110$1111b! cmp m! jz search$loop
 1544 EBBEEBC257		xchg! cmp m! xchg! jnz search$loop
 154A 3A16FDB7CA		lda find$xfcb! ora a! jz search$n
 1551 32A228C394		sta save$xfcb! jmp searchok
CP/M RMAC ASSEM 1.1	#056	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                endif
                
                		searchloop:
 1557 79B7CA9B15			mov a,c! ora a! jz endsearch
 155C 1AFE3FCA94			ldax d! cpi '?'! jz searchok ; ? in user fcb
                			; Scan next character if not ubytes
 1562 78FE0DCA94			mov a,b! cpi ubytes! jz searchok
                			; not the ubytes field, extent field?
 1568 FE0C      			cpi extnum ; may be extent field
 156A CA7C15    			jz searchext ; Skip to search extent
 156D FE0E1ACCB7			cpi modnum! ldax d! cz searchmod
 1573 96E67F    			sub m! ani 7fh ; Mask-out flags/extent modulus
 1576 C2C715    			jnz searchnm ; Skip if not matched
 1579 C39415    			jmp searchok ; matched character
                		searchext:
 157C 1A        			ldax d
                			; Attempt an extent # match
 157D C5        			push b ; Save counters
                
                if MPM
                			push h
                			lhld sdcnt
                			inr h! jnz dont$save
                			lhld dcnt! shld sdcnt
                			lhld dblk! shld sdblk
                		dont$save:
                			pop h
                endif
                
 157E 4E        			mov c,m ; directory character to c
 157F CD8614    			call compext ; Compare user/dir char
                
 1582 47        			mov b,a
 1583 3ABE283CCA			lda user0pass! inr a! jz save$dcnt$pos2
                			; Disable search of user 0 if any fcb
                			; is found under the current user #
 158A AF32BD28  			xra a! sta search$user0
 158E 78        			mov a,b
                
 158F C1        			pop b ; Recall counters
 1590 B7        			ora a ; Set flag
 1591 C20315    			jnz searchn ; Skip if no match
                		searchok:
                			; current character matches
 1594 1323040D  			inx d! inx h! inr b! dcr c
 1598 C35715    			jmp searchloop
                		endsearch:
                			; entire name matches, return dir position
                
                if BANKED
 159B 3AA2283CC2			lda save$xfcb! inr a! jnz endsearch1
 15A2 3A18FDFEFE			lda xdcnt+1! cpi 0feh! cz save$dcnt$pos0
 15AA C30315    			jmp searchn
                		endsearch1:
                endif
                
CP/M RMAC ASSEM 1.1	#057	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 15AD AF329D28  			xra a! sta dirloc ; dirloc = 0
 15B1 329F0D    			sta lret ; lret = 0
                			; successful search -
                			; return with zero flag reset
 15B4 4704C9    			mov b,a! inr b! ret
                		searchmod:
 15B7 E63FC9    			ani 3fh! ret ; Mask off high 2 bits
                		search$fin:
                			; end of directory, or empty name
                
 15BA CDED15    			call save$dcnt$pos1
                
                			; Set dcnt = 0ffffh
 15BD CD0113    			call set$end$dir ; may be artifical end
                		lret$eq$ff:
                			; unsuccessful search -
                			; return with zero flag set
                			; lret,low(aret) = 0ffh
 15C0 3EFF4704C3			mvi a,255! mov b,a! inr b! jmp sta$ret
                
                		searchnm: ; search no match routine
 15C7 78B7C20315			mov a,b! ora a! jnz searchn ; fcb(0)?
 15CC 7EB7C20315			mov a,m! ora a! jnz searchn ; dir fcb(0)=0?
 15D1 3ABD28B7CA			lda search$user0! ora a! jz searchn
 15D8 32BE28    			sta user0$pass
                
                if MPM
                			call swap
                endif
                
 15DB C39415    			jmp searchok
                
                if MPM
                
                swap: ; Swap dcnt,sdblk with sdcnt0,sdblk0
                	push h! push d! push b
                	lxi d,sdcnt! lxi h,sdcnt0
                	mvi b,4
                swap1:
                	ldax d! mov c,a! mov a,m
                	stax d! mov m,c
                	inx h! inx d! dcr b! jnz swap1
                	pop b! pop d! pop h!
                	ret
                endif
                
                save$dcnt$pos2:
                	; Save directory position of matching fcb
                	; under user 0 with matching extent # & modnum = 0
                	; a = 0 on entry
 15DE B0C1010315	ora b! pop b! lxi b,searchn! push b! rnz
 15E5 23237EB7C0	inx h! inx h! mov a,m! ora a! rnz
                	; Call if user0pass = 0ffh &
                	;	  dir fcb(extnum) = fcb(extnum)
                	;	  dir fcb(modnum) = 0
                save$dcnt$pos0:
CP/M RMAC ASSEM 1.1	#058	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 15EA CDF515    	call save$dcnt$pos ; Return to searchn
                save$dcnt$pos1:
                	; Save directory position of first empty fcb
                	; or the end of the directory
                
 15ED E5        	push h
 15EE 2A17FD    	lhld xdcnt
 15F1 24C2FB15  	inr h! jnz save$dcnt$pos$ret ; Return if h ~= 0ffh
                
                
                save$dcnt$pos:
 15F5 2AE1FB2217	lhld dcnt! shld xdcnt
                
                if MPM
                	lhld dblk! shld xdblk
                endif
                
                save$dcnt$pos$ret:
 15FB E1C9      	pop h! ret
                
                if BANKED
                
                init$xfcb$search:
 15FD 3EFF      	mvi a,0ffh
                init$xfcb$search1:
 15FF 3216FD3EFE	sta find$xfcb! mvi a,0feh! sta xdcnt+1! ret
                
                does$xfcb$exist:
 1608 3A18FDFEFE	lda xdcnt+1! cpi 0feh! rz
 160E CD0A19    	call set$dcnt$dblk
 1611 AFCDFF15  	xra a! call init$xfcb$search1
 1615 2AA0287EF6	lhld searcha! mov a,m! ori 10h! mov m,a
 161C 0E0CCDE314	mvi c,extnum! call searchi1! jmp searchn
                
                xdcnt$eq$dcnt:
 1624 2AE1FB2217	lhld dcnt! shld xdcnt! ret
                
                restore$dir$fcb:
 162B CD0A19    	call set$dcnt$dblk
 162E 0E0FCDDD14	mvi c,namlen! call searchi! jmp searchn
                endif
                
                delete:
                	; Delete the currently addressed file
 1636 CD1810    	call get$atts
                
                if BANKED
 1639 32B328    	sta attributes
                	; Make search return matching fcbs and xfcbs
                deletex:
 163C 3EFECDFF15	mvi a,0feh! call init$xfcb$search1
                else
                	; Return with aret = 0 for XFCB only delete
                	; in non-banked systems
                	ral! rc
                endif
CP/M RMAC ASSEM 1.1	#059	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                ; Delete pass 1 - check r/o attributes and xfcb passwords
                
 1641 CDF514C8  	call search$extnum! rz
                
                    delete00:
 1645 CA8416    	    jz delete1
                
                if BANKED
                	    ; Is addressed dir fcb an xfcb?
 1648 CD40117EE6	    call getdptra! mov a,m! ani 10h! jnz delete01 ; yes
                
                if MPM
                	    call tst$olist ; Verify fcb not open by someone else
                endif
                
                	    ; Check r/o attribute if this is not an
                	    ; xfcb only delete operation.
 1651 3AB32817D4	    lda attributes! ral! cnc check$rodir
                else
                	    call check$rodir
                endif
                
                if BANKED
                	    ; Are xfcb passwords enabled?
 1658 CD731F17DA	    call get$dir$mode! ral! jc delete02 ; no
                endif
                
                	    ; Is this a wild card delete operation?
 165F 2ADBFBCD39	    lhld info! call chk$wild! jz delete02 ; yes
                	    ; Not wild & passwords inactive
                	    ; Skip to pass 2
 1668 C38A16    	    jmp delete11
                
                if BANKED
                
                    delete01:
                	    ; Check xfcb password if passwords enabled
 166B CD731F17D2	    call get$dir$mode! ral! jnc delete02
 1672 CDD420CA7E	    call chk$xfcb$password! jz delete02
 1678 CD851FC33C	    call chk$pw$error! jmp deletex
                endif
                
                    delete02:
 167E CD0315C345	    call searchn! jmp delete00
                
                ; Delete pass 2 - delete all matching fcbs and/or xfcbs.
                
                delete1:
 1684 CDF514    	call search$extnum
                
                    delete10:
 1687 CA8014    	    jz copy$dir$loc
                    delete11:
 168A CD4011    	    call getdptra
                
CP/M RMAC ASSEM 1.1	#060	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                if BANKED
                	    ; Is addressed dir fcb an xfcb?
 168D 7EE610C29B	    mov a,m! ani 10h! jnz delete12 ; yes
                if MPM
                	    push h
                	    call chk$olist ; Delete olist item if present
                	    pop h
                endif
                	    ; Is this delete operation xfcb only?
 1693 3AB328E680	    lda attributes! ani 80h! jnz delete13 ; yes
                endif
                
                    delete12:
                	    ; Delete dir fcb or xfcb
                	    ; if fcb free all alocated blocks.
                
 169B 36E5      	    mvi m,empty
                
                if BANKED
                
                    delete13:
 169D F5        	    push a ; Z flag set => free FCB blocks
                	    ; Zero password mode byte in sfcb if sfcb exists
                	    ; Does sfcb exist?
 169E CD1021B7C2	    call get$dtba$8! ora a! jnz $+4 ; no
                	    ; Zero mode byte
 16A5 77        	    mov m,a
                endif
                
 16A6 CD9A120E00	    call wrdir! mvi c,0
                
                if BANKED
 16AB F1CC8B13  	    pop a! cz scandm$ab
                else
                	    call scandm$ab
                endif
                
 16AF CDC82C    	    call fix$hash
 16B2 CD0315C387	    call searchn! jmp delete10
                
                get$block:
                	; Given allocation vector position bc, find the zero bit
                	; closest to this position by searching left and right.
                	; if found, set the bit to one and return the bit position
                	; in hl.  if not found (i.e., we pass 0 on the left, or
                	; maxall on the right), return 0000 in hl
 16B8 5059      	mov d,b! mov e,c ; copy of starting position to de
                	righttst:
 16BA 2A8528    		lhld maxall ; value of maximum allocation#
 16BD 7B957A9C  		mov a,e! sub l! mov a,d! sbb h ; right=maxall?
 16C1 D2EE16    		jnc retblock0 ; return block 0000 if so
 16C4 13C5D5    		inx d! push b! push d ; left, right pushed
 16C7 424B      		mov b,d! mov c,e ; ready right for call
 16C9 CD4E13    		call getallocbit
 16CC 1FD2E616  		rar! jnc retblock ; Return block number if zero
 16D0 D1C1      		pop d! pop b ; Restore left and right pointers
CP/M RMAC ASSEM 1.1	#061	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	lefttst:
 16D2 79B0CABA16		mov a,c! ora b! jz righttst ; Skip if left=0000
                		; left not at position zero, bit zero?
 16D7 0BD5C5    		dcx b! push d! push b ; left,right pushed
 16DA CD4E13    		call getallocbit
 16DD 1FD2E616  		rar! jnc retblock ; return block number if zero
                		; bit is one, so try the right
 16E1 C1D1      		pop b! pop d ; left, right restored
 16E3 C3BA16    		jmp righttst
                	retblock:
 16E6 173C      		ral! inr a ; bit back into position and set to 1
                		; d contains the number of shifts required to reposition
 16E8 CD7013    		call rotr ; move bit back to position and store
 16EB E1D1      		pop h! pop d ; hl returned value, de discarded
 16ED C9        		ret
                	retblock0:
                		; cannot find an available bit, return 0000
 16EE 79        		mov a,c
 16EF B0C2D216  		ora b! jnz lefttst ; also at beginning
 16F3 210000C9  		lxi h,0000h! ret
                
                copy$dir:
                	; Copy fcb information starting at c for e bytes
                	; into the currently addressed directory entry
 16F7 1680      	mvi d,80h
                copy$dir0:
 16F9 CD1017    	call copy$dir2
 16FC 0C        	inr c
                copy$dir1:
 16FD 0DCA9A12  	dcr c! jz seek$copy
 1701 7EA0C5    	mov a,m! ana b! push b
 1704 471AE67FB0	mov b,a! ldax d! ani 7fh! ora b! mov m,a
 170A C12313C3FD	pop b! inx h! inx d! jmp copy$dir1
                copy$dir2:
 1710 D5        	push d ; Save length for later
 1711 0600      	mvi b,0 ; double index to bc
 1713 2ADBFB    	lhld info ; hl = source for data
 1716 09        	dad b
 1717 237ED624CC	inx h! mov a,m! sui '$'! cz set$submit$flag
 171E 2BEB      	dcx h! xchg ; de=.fcb(c), source for copy
 1720 CD4011    	call getdptra ; hl=.buff(dptr), destination
 1723 C1        	pop b ; de=source, hl=dest, c=length
 1724 C9        	ret
                
                set$submit$flag:
 1725 11B3FB1AF6	lxi d,ccp$flgs! ldax d! ori 1! stax d! ret
                
                check$wild:
                	; Check for ? in file name or type
 172D 2ADBFB    	lhld info
                check$wild0:	; entry point used by rename
 1730 CD3917C0  	call chk$wild! rnz
 1734 3E09C3E523	mvi a,9! jmp set$aret
                
                chk$wild:
 1739 0E0B      	mvi c,11
CP/M RMAC ASSEM 1.1	#062	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                chk$wild1:
 173B 233E3F96E6	inx h! mvi a,3fh! sub m! ani 7fh! rz
 1742 0DC23B17B7	dcr c! jnz chk$wild1! ora a! ret
                
                copy$user$no:
 1748 2ADBFB7E01	lhld info! mov a,m! lxi b,dskmap
 174F 0977C9    	dad b! mov m,a! ret
                
                rename:
                	; Rename the file described by the first half of
                	; the currently addressed file control block. The
                	; new name is contained in the last half of the
                	; currently addressed file control block.  The file
                	; name and type are changed, but the reel number
                	; is ignored.  The user number is identical.
                
                	; Verify that the new file name does not exist.
                	; Also verify that no wild chars exist in
                	; either filename.
                
                if MPM
                	call getatts! sta attributes
                endif
                
                	; Verify that no wild chars exist in 1st filename.
 1752 CD2D17    	call check$wild
                
                if BANKED
                	; Check password of file to be renamed.
 1755 CD781FC485	call chk$password! cnz chk$pw$error
                	; Setup search to scan for xfcbs.
 175B CDFD15    	call init$xfcb$search
                endif
                
                	; Copy user number to 2nd filename
 175E CD4817    	call copy$user$no
 1761 22A028    	shld searcha
                
                	; Verify no wild chars exist in 2nd filename
 1764 CD3017    	call check$wild0
                
                	; Verify new filename does not already exist
 1767 0E0C2AA028	mvi c,extnum! lhld searcha! call searchi1! call search1
 1772 C2E323    	jnz file$exists ; New filename exists
                
                if BANKED
                	; If an xfcb exists for the new filename, delete it.
 1775 CD0816C48A	call does$xfcb$exist! cnz delete11
                endif
                
 177B CD4817    	call copy$user$no
                
                if BANKED
 177E CDFD15    	call init$xfcb$search
                endif
                
CP/M RMAC ASSEM 1.1	#063	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	; Search up to the extent field
 1781 CDF514    	call search$extnum
 1784 C8        	rz
 1785 CD2811    	call check$rodir ; may be r/o file
                
                if MPM
                	call chk$olist
                endif
                
                	; Copy position 0
                	rename0:
                		; not end of directory, rename next element
 1788 0E101E0CCD		mvi c,dskmap! mvi e,extnum! call copy$dir
                		; element renamed, move to next
                
 178F CDC82C    		call fix$hash
 1792 CD0315    		call searchn
 1795 C28817    		jnz rename0
                	rename1:
                
                if BANKED
 1798 CD0816CA80		call does$xfcb$exist! jz copy$dir$loc
 179E CD4817C388		call copy$user$no! jmp rename0
                else
                		jmp copy$dir$loc
                endif
                
                indicators:
                	; Set file indicators for current fcb
 17A4 CD1810    	call get$atts ; Clear f5' through f8'
 17A7 32B328    	sta attributes
                
                if BANKED
 17AA CD781FC485	call chk$password! cnz chk$pw$error
                endif
                
 17B0 CDF514    	call search$extnum ; through file type
 17B3 C8        	rz
                
                if MPM
                	call chk$olist
                endif
                
                	indic0:
                		; not end of directory, continue to change
 17B4 0E001E0C  		mvi c,0! mvi e,extnum ; Copy name
 17B8 CD1017CD29		call copy$dir2! call move
 17BE 3AB328E640		lda attributes! ani 40h! jz indic1
                
                		; If interface att f6' set, dir fcb(s1) = fcb(cr)
                
 17C6 E5CD4F107E		push h! call getfcba! mov a,m
 17CB E12377    		pop h! inx h! mov m,a
                	indic1:
 17CE CD9A12    		call seek$copy
 17D1 CD0315    		call searchn
CP/M RMAC ASSEM 1.1	#064	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 17D4 CA8014    		jz copy$dir$loc
 17D7 C3B417    		jmp indic0
                
                open:
                	; Search for the directory entry, copy to fcb
                ;;;	call search$namlen	;[JCE] DRI Patch 13
 17DA CD832D    	call patch$1e3e
                open1:
 17DD C8        	rz ; Return with lret=255 if end
                	; not end of directory, copy fcb information
                open$copy:
 17DE CD62115FE5	call setfwf! mov e,a! push h! dcx h! dcx h
 17E5 56D5      	mov d,m! push d ; Save extent# & module# with fcb write flag set
 17E7 CD4011EB  	call getdptra! xchg ; hl = .buff(dptr)
 17EB 2ADBFB    	lhld info ; hl=.fcb(0)
 17EE 0E20      	mvi c,nxtrec ; length of move operation
 17F0 CD290E    	call move ; from .buff(dptr) to .fcb(0)
                	; Note that entire fcb is copied, including indicators
 17F3 CD97144F  	call get$dir$ext! mov c,a
                	; Restore module # and extent #
 17F7 D1E1732B2B	pop d! pop h! mov m,e! dcx h! dcx h! mov m,d
                	; hl = .user extent#, c = dir extent#
                	; above move set fcb(reccnt) to dir(reccnt)
                	; if fcb ext < dir ext then fcb(reccnt) = fcb(reccnt) | 128
                	; if fcb ext = dir ext then fcb(reccnt) = fcb(reccnt)
                	; if fcb ext > dir ext then fcb(reccnt) = 0
                
                set$rc: ; hl=.fcb(ext), c=dirext
 17FD 0600      		mvi b,0
 17FF EB21030019		xchg! lxi h,(reccnt-extnum)! dad d
                		; Is fcb ext = dirext?
 1804 1A91CA1218		ldax d! sub c! jz set$rc2 ; yes
                		; Is fcb ext > dirext?
 1809 78D21018  		mov a,b! jnc set$rc1 ; yes - fcb(rc) = 0
                		; fcb ext  < dirext
                		; fcb(rc) = 128 | fcb(rc)
 180D 3E80B6    		mvi a,128! ora m
                	set$rc1:
 1810 77C9      		mov m,a! ret
                	set$rc2:
                		; fcb ext = dirext
 1812 7EB7C0    		mov a,m! ora a! rnz ; ret if fcb(rc) ~= 0
                	set$rc3:
 1815 3600      		mvi m,0 ; required by function 99
 1817 3A9F28B7C8		lda dminx! ora a! rz ; ret if no blks in fcb
 181C 3680C9    		mvi m,128! ret ; fcb(rc) = 128
                
                mergezero:
                	; hl = .fcb1(i), de = .fcb2(i),
                	; if fcb1(i) = 0 then fcb1(i) := fcb2(i)
 181F 7E23B62BC0	mov a,m! inx h! ora m! dcx h! rnz ; return if = 0000
 1824 1A771323  	ldax d! mov m,a! inx d! inx h ; low byte copied
 1828 1A771B2B  	ldax d! mov m,a! dcx d! dcx h ; back to input form
 182C C9        	ret
                
                restore$rc:
CP/M RMAC ASSEM 1.1	#065	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	; hl = .fcb(extnum)
                	; if fcb(rc) > 80h then fcb(rc) = fcb(rc) & 7fh
 182D E5        	push h
 182E 11030019  	lxi d,(reccnt-extnum)! dad d
 1832 7EFE81DA3B	mov a,m! cpi 81h! jc restore$rc1
 1838 E67F77    	ani 7fh! mov m,a
                restore$rc1:
 183B E1C9      	pop h! ret
                
                close:
                	; Locate the directory element and re-write it
 183D AF329F0D  	xra a! sta lret
                
                if MPM
                	sta dont$close
                endif
                
 1841 CD1A11C0  	call nowrite! rnz ; Skip close if r/o disk
                	; Check file write flag - 0 indicates written
 1845 CD4B11    	call getmodnum ; fcb(modnum) in a
 1848 E680C0    	ani fwfmsk! rnz ; Return if bit remains set
                close1:
 184B CDE812CAF2	call chk$inv$fcb! jz mergerr
                
                if MPM
                	call set$fcb$cks$flag
                endif
                
                ;;;	call get$dir$ext
 1851 CDFC2C    	call patch$1dfd		;[JCE] DRI patch 7
                
 1854 4F        	mov c,a
 1855 46        	mov b,m
 1856 C5        	push b
                	; b = original extent, c = directory extent
                	; Set fcb(ex) to directory extent
 1857 71        	mov m,c
                	; Recompute fcb(rc)
 1858 CD2D18    	call restore$rc
                	; Call set$rc if fcb ext > dir ext
 185B 79B8DCFD17	mov a,c! cmp b! cc set$rc
 1860 CD6C18    	call close$fcb
                	; Restore original extent & reset fcb(rc)
 1863 CD3F10C1  	call get$exta! pop b
 1867 4E70C3FD17	mov c,m! mov m,b! jmp set$rc ; Reset fcb(rc)
                
                close$fcb:
                	; Locate file
 186C CDF014    	call search$namlen
 186F C8        	rz ; Return if not found
                	; Merge the disk map at info with that at buff(dptr)
 1870 011000CD67	lxi b,dskmap! call get$fcb$adds
 1876 0E10      	mvi c,(fcblen-dskmap) ; length of single byte dm
                	merge0:
 1878 3AA328B7CA		lda single! ora a! jz merged ; Skip to double
                		; This is a single byte map
CP/M RMAC ASSEM 1.1	#066	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                		; if fcb(i) = 0 then fcb(i) = buff(i)
                		; if buff(i) = 0 then buff(i) = fcb(i)
                		; if fcb(i) <> buff(i) then error
 187F 7EB71AC286		mov a,m! ora a! ldax d! jnz fcbnzero
                			; fcb(i) = 0
 1885 77        			mov m,a ; fcb(i) = buff(i)
                		fcbnzero:
 1886 B7C28C18  		ora a! jnz buffnzero
                			; buff(i) = 0
 188A 7E12      			mov a,m! stax d ; buff(i)=fcb(i)
                		buffnzero:
 188C BEC2F218  		cmp m! jnz mergerr ; fcb(i) = buff(i)?
 1890 C3A818    		jmp dmset ; if merge ok
                	merged:
                		; This is a double byte merge operation
 1893 CD1F18    		call mergezero ; buff = fcb if buff 0000
 1896 EBCD1F18EB		xchg! call mergezero! xchg ; fcb = buff if fcb 0000
                		; They should be identical at this point
 189B 1ABEC2F218		ldax d! cmp m! jnz mergerr ; low same?
 18A0 1323      		inx d! inx h ; to high byte
 18A2 1ABEC2F218		ldax d! cmp m! jnz mergerr ; high same?
                		; merge operation ok for this pair
 18A7 0D        		dcr c ; extra count for double byte
                	dmset:
 18A8 1323      		inx d! inx h ; to next byte position
 18AA 0DC27818  		dcr c! jnz merge0 ; for more
                		; end of disk map merge, check record count
                		; de = .buff(dptr)+32, hl = .fcb(32)
                
 18AE EB01ECFF09		xchg! lxi b,-(fcblen-extnum)! dad b! push h
 18B4 CD9714D1  		call get$dir$ext! pop d
                
                		; hl = .fcb(extnum), de = .buff(dptr+extnum)
                
 18B8 CDF818    		call compare$extents
                
                		; b=1 -> fcb(ext) ~= dir ext = buff(ext)
                		; b=2 -> fcb(ext) = dir ext ~= buff(ext)
                		; b=3 -> fcb(ext) = dir ext = buff(ext)
                
                		; fcb(ext), buff(ext) = dir ext
 18BB 7712C5    		mov m,a! stax d! push b
                
 18BE 01030009EB		lxi b,(reccnt-extnum)! dad b! xchg! dad b
 18C4 C1        		pop b
                
                		; hl = .buff(rc) , de = .fcb(rc)
                
 18C5 05CAD918  		dcr b! jz mrg$rc1 ; fcb(rc) = buff(rc)
                
 18C9 05CADA18  		dcr b! jz mrg$rc2 ; buff(rc) = fcb(rc)
                
 18CD 1ABEDAD918		ldax d! cmp m! jc mrg$rc1 ; Take larger rc
 18D2 B7C2DA18  		ora a! jnz mrg$rc2
 18D6 CD1518    		call set$rc3
                
CP/M RMAC ASSEM 1.1	#067	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 18D9 EB               mrg$rc1: xchg
                
 18DA 1A77             mrg$rc2: ldax d! mov m,a
                
                if MPM
                		lda dont$close! ora a! rnz
                endif
                
                		; Set t3' off indicating file update
 18DC CD4011110B		call getdptra! lxi d,11! dad d
 18E3 7EE67F77  		mov a,m! ani 7fh! mov m,a
 18E7 CD6211    		call setfwf
 18EA 0E01CD9013		mvi c,1! call scandm$b ; Set 2nd ALV vector
 18EF C39A12    		jmp seek$copy ; OK to "wrdir" here - 1.4 compat
                		; ret
                	mergerr:
                		; elements did not merge correctly
 18F2 CDDD12    		call make$fcb$inv
 18F5 C3C015    		jmp lret$eq$ff
                
                compare$extents:
 18F8 0601BEC0  	mvi b,1! cmp m! rnz
 18FC 04EBBEEBC0	inr b! xchg! cmp m! xchg! rnz
 1901 04C9      	inr b! ret
                
                set$xdcnt:
 1903 21FFFF2217	lxi h,0ffffh! shld xdcnt! ret
                
                set$dcnt$dblk:
 190A 2A17FD    	lhld xdcnt
                set$dcnt$dblk1:
 190D 3EFCA5    	mvi a,1111$1100b! ana l
 1910 6F2B22E1FB	mov l,a! dcx h! shld dcnt
                
                if MPM
                	lhld xdblk! shld dblk
                endif
                
 1915 C9        	ret
                
                if MPM
                
                sdcnt$eq$xdcnt:
                	lxi h,sdcnt! lxi d,xdcnt! mvi c,4
                	jmp move
                endif
                
                make:
                	; Create a new file by creating a directory entry
                	; then opening the file
                
                ;;;	lxi h,xdcnt	;[JCE] DRI Patch 13
 1916 CD762D    	call patch$1e31
                
 1919 CDFB12C40A	call test$ffff! cnz set$dcnt$dblk
                
CP/M RMAC ASSEM 1.1	#068	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 191F 2ADBFBE5  	lhld info! push h ; Save fcb address, Look for E5
 1923 21622822DB	lxi h,efcb! shld info ; info = .empty
 1929 0E01      	mvi c,1
                
 192B CDDD14CD03	call searchi! call searchn
                
                	; zero flag set if no space
 1931 E1        	pop h ; Recall info address
 1932 22DBFB    	shld info ; in case we return here
 1935 C8        	rz ; Return with error condition 255 if not found
                
                if BANKED
                	; Return early if making an xfcb
 1936 3A15FDB7C0	lda make$xfcb! ora a! rnz
                endif
                
                	; Clear the remainder of the fcb
                	; Clear s1 byte
 193B 110D001972	lxi d,13! dad d! mov m,d! inx h
                	; Clear and save file write flag of modnum
 1941 7EF5E5E63F	mov a,m! push a! push h! ani 3fh! mov m,a! inx h
 1948 3E01      	mvi a,1
 194A 0E11      	mvi c,fcblen-namlen ; number of bytes to fill
                	make0:
 194C 72230DC24C		mov m,d! inx h! dcr c! jnz make0
 1952 3D4ACC1221		dcr a! mov c,d! cz get$dtba
 1957 B70E0ACA4C		ora a! mvi c,10! jz make0
 195D CD7611    	call setcdr ; may have extended the directory
                	; Now copy entry to the directory
 1960 0E00112000	mvi c,0! lxi d,fcblen! call copy$dir0
                	; and restore the file write flag
 1968 E1F177    	pop h! pop a! mov m,a
                	; and set the fcb write flag to "1"
 196B CDC82C    	call fix$hash
 196E C36211    	jmp setfwf
                
                open$reel:
                	; Close the current extent, and open the next one
                	; if possible.	rmf is true if in read mode
                
                if BANKED
 1971 CDDC0D    	call reset$copy$cr$only
                endif
                
 1974 CD3F10    	call getexta
 1977 7E4F      	mov a,m! mov c,a
 1979 0CCD8614  	inr c! call compext
 197D CADA19    	jz open$reel3
 1980 E5C5      	push h! push b
 1982 CD3D18    	call close
 1985 C1E1      	pop b! pop h
 1987 3A9F0D3CC8	lda lret! inr a! rz
 198C 3E1FA177  	mvi a,maxext! ana c! mov m,a ; Incr extent field
                	; Advance to module & save
 1990 23237E32A7	inx h! inx h! mov a,m! sta save$mod
 1996 C2A019    	jnz open$reel0 ; Jump if in same module
CP/M RMAC ASSEM 1.1	#069	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                	open$mod:
                		; Extent number overflow, go to next module
 1999 34        		inr m ; fcb(modnum)=++1
                		; Module number incremented, check for overflow
                
 199A 7EE63F    		mov a,m! ani 3fh ; Mask high order bits
                
 199D CAC919    		jz open$r$err ; cannot overflow to zero
                
                		; otherwise, ok to continue with new module
                	open$reel0:
 19A0 CD0319    		call set$xdcnt ; Reset xdcnt for make
                
                if MPM
                		call set$sdcnt
                endif
                
                ;;;		call search$namlen	;[JCE] DRI Patch 13 
 19A3 CD832D    		call patch$1e3e		;Next extent found?
                
 19A6 C2B919    		jnz open$reel1
                			; end of file encountered
 19A9 3A9C283C  			lda rmf! inr a ; 0ffh becomes 00 if read
 19AD CAC919    			jz open$r$err ; sets lret = 1
                			; Try to extend the current file
 19B0 CD1619    			call make
                			; cannot be end of directory
 19B3 CAC919    			jz open$r$err ; with lret = 1
                
                if MPM
                			call fix$olist$item
                			call set$fcb$cks$flag
                endif
                
 19B6 C3BC19    			jmp open$reel2
                		open$reel1:
                			; not end of file, open
 19B9 CDDE17    			call open$copy
                
                if MPM
                			call set$fcb$cks$flag
                endif
                
                		open$reel2:
                
                if not MPM
 19BC CD4112    			call set$lsn
                endif
                
 19BF CD5810    			call getfcb ; Set parameters
 19C2 AF32A828C3			xra a! sta vrecord! jmp sta$ret ; lret = 0
                			; ret ; with lret = 0
                	open$r$err:
                		; Restore module and extent
 19C9 CD4B113AA7		call getmodnum! lda save$mod! mov m,a
CP/M RMAC ASSEM 1.1	#070	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 19D0 2B2B7E3DE6		dcx h! dcx h! mov a,m! dcr a! ani 1fh
 19D6 77C3760A  		mov m,a! jmp setlret1 ; lret = 1
                
                	open$reel3:
 19DA 34        		inr m ; fcb(ex) = fcb(ex) + 1
 19DB CD97144F  		call get$dir$ext! mov c,a
                		; Is new extent beyond dir$ext?
 19DF BED2EC19  		cmp m! jnc open$reel4 ; no
 19E3 35        		dcr m ; fcb(ex) = fcb(ex) - 1
                		; Is this a read fx?
 19E4 3A9C283CCA		lda rmf! inr a! jz set$lret1 ; yes - Don't advance ext
 19EB 34        		inr m ; fcb(ex) = fcb(ex) + 1
                	open$reel4:
 19EC CD2D18    		call restore$rc
 19EF CDFD17C3BC		call set$rc! jmp open$reel2
                
                seqdiskread:
                diskread:	; (may enter from seqdiskread)
 19F5 CDEE12    	call tst$inv$fcb ; Check for valid fcb
 19F8 3EFF329C28	mvi a,true! sta rmf ; read mode flag = true (open$reel)
                
                if MPM
                	sta dont$close
                endif
                
                	; Read the next record from the current fcb
 19FD CD5810    	call getfcb ; sets parameters for the read
                diskread0:
 1A00 3AA82821A5	lda vrecord! lxi h,rcount! cmp m ; vrecord-rcount
                	; Skip if rcount > vrecord
 1A07 DA191A    	jc recordok
                
                if MPM
                		call test$disk$fcb! jnz diskread0
                		lda vrecord
                endif
                
                		; not enough records in the extent
                		; record count must be 128 to continue
 1A0A FE80      		cpi 128 ; vrecord = 128?
 1A0C C2760A    		jnz setlret1 ; Skip if vrecord<>128
 1A0F CD7119    		call open$reel ; Go to next extent if so
                		; Check for open ok
 1A12 3A9F0DB7C2		lda lret! ora a! jnz setlret1 ; Stop at eof
                	recordok:
                		; Arrive with fcb addressing a record to read
                
                if BANKED
 1A19 CDD50D    		call set$copy$cr$only
                endif
                
 1A1C CDE00F    		call index ; Z flag set if arecord = 0
                
                if MPM
                		jnz recordok1
                		call test$disk$fcb! jnz diskread0
CP/M RMAC ASSEM 1.1	#071	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                endif
                
 1A1F CA760A    		jz setlret1 ; Reading unwritten data
                	recordok1:
                		; Record has been allocated, read it
 1A22 CDF20F    		call atran ; arecord now a disk address
 1A25 CD4D1A    		call check$nprs
 1A28 DA8210    		jc setfcb
 1A2B C23F1A    		jnz read$deblock
                
 1A2E CDB612    		call setdata
 1A31 CD0C0F    		call seek ; to proper track,sector
                
                if BANKED
 1A34 3E01CD54FF		mvi a,1! call setbnkf
                endif
                
 1A39 CD930E    		call rdbuff ; to dma address
 1A3C C38210    		jmp setfcb ; Replace parameter
                
                read$deblock:
 1A3F 2100002296	lxi h,0! shld last$block
 1A45 3E01CDFF28	mvi a,1! call deblock$dta
 1A4A C38210    	jmp setfcb
                
                check$nprs:
                	;
                	; on exit,  c flg	   -> no i/o operation
                	;	    z flg & ~c flg -> direct(physical) i/o operation
                	;	   ~z flg & ~c flg -> indirect(deblock) i/o operation
                	;
                	;	   Dir$cnt contains the number of 128 byte records
                	;	   to transfer directly.  This routine sets dir$cnt
                	;	   when initiating a sequence of direct physical
                	;	   i/o operations.  Dir$cnt is decremented each
                	;	   time check$nprs is called during such a sequence.
                	;
                	; Is direct transfer operation in progress?
 1A4D 3A932847  	lda blk$off! mov b,a
 1A51 3A90284FA0	lda phy$msk! mov c,a! ana b! push a
 1A57 3A9828FE02	lda dir$cnt! cpi 2! jc check$npr1 ; no
                	; yes - Decrement direct record count
 1A5F 3D329828  	dcr a! sta dir$cnt
                	; Are we at a new physical record?
 1A63 F137C0    	pop a! stc! rnz ; no - ret with c flg set
                	; Perform physical i/o operation
 1A66 AFC9      	xra a! ret ; Return with z flag set and c flag reset
                check$npr1:
                	; Are we in mid-physical record?
 1A68 F1CA721A  	pop a! jz check$npr11 ; no
                check$npr1a:
                	; Is phymsk = 0?
 1A6C 79B7C8    	mov a,c! ora a! rz ; yes - Don't deblock
                check$npr1b:
                	; Deblocking required
 1A6F F601C9    	ori 1! ret ; ret with z flg reset and c flg reset
CP/M RMAC ASSEM 1.1	#072	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                check$npr11:
 1A72 792F57    	mov a,c! cma! mov d,a ; d = ~phy$msk
 1A75 21A828    	lxi h,vrecord
                	; Is mult$num < 2?
 1A78 3A9928FE02	lda mult$num! cpi 2! jc check$npr1a ; yes
 1A80 86FE80DA88	add m! cpi 80h! jc check$npr2
 1A86 3E80      	mvi a,80h
                check$npr2: ; a = min(vrecord + mult$num),80h) = x
 1A88 C5        	push b ; Save low(arecord) & blkmsk, phymsk
 1A89 46367F    	mov b,m! mvi m,7fh ; vrecord = 7f
 1A8C C5        	push b ; Save vrecord
 1A8D E5        	push h ; Save .vrecord
 1A8E F5        	push a ; Save x
 1A8F 3A83285F1C	lda blkmsk! mov e,a! inr e! cma! ana b! mov b,a
                	; b = vrecord & ~blkmsk
                	; e = blkmsk + 1
 1A97 E1        	pop h ; h = x
                	; Is this a read function?
 1A98 3A9C28B7CA	lda rmf! ora a! jz check$npr21 ; no
                	; Is rcount & ~phymsk < x?
 1A9F 3AA528A2BC	lda rcount! ana d! cmp h! jc check$npr23 ; yes
                check$npr21:
 1AA7 7C        	mov a,h ; a = x
                check$npr23:
 1AA8 90        	sub b ; a = a - vrecord & ~blkmsk
 1AA9 4F        	mov c,a ; c = max # of records from beginning of curr blk
                	; Is c < blkmsk+1?
 1AAA BBDA1C1B  	cmp e! jc check$npr8 ; yes
                
                if BANKED
 1AAE C5        	push b ; c = max # of records
                	; Compute maximum disk map position
 1AAF CDA40F    	call dm$position
 1AB2 47        	mov b,a ; b = index of last block in extent
                	; Does the last block # = the current block #?
 1AB3 3A9F28B85F	lda dminx! cmp b! mov e,a! jz check$npr5 ; yes
                	; Compute # of blocks in sequence
 1ABB 4FC50600  	mov c,a! push b! mvi b,0
 1ABF CDCC0F    	call get$dm ; hl = current block #
                check$npr4:
                	; Get next block #
 1AC2 E503CDCC0F	push h! inx b! call get$dm
 1AC7 D113      	pop d! inx d
                	; Does next block # = previous block # + 1?
 1AC9 7A9457    	mov a,d! sub h! mov d,a
 1ACC 7B95B2CAC2	mov a,e! sub l! ora d! jz check$npr4 ; yes
                	; Is next block # = 0?
 1AD2 7CB5C2F51A	mov a,h! ora l! jnz check$npr45 ; no
                	; Is this a read function?
 1AD7 3A9C28B7C2	lda rmf! ora a! jnz check$npr45 ; no
                	; Is next block # > maxall?
 1ADE 2A85287D93	lhld maxall! mov a,l! sub e
 1AE3 7C9ADAF51A	mov a,h! sbb d! jc check$npr45 ; yes
                	; Is next block # allocated?
 1AE8 C5D5424B  	push b! push d! mov b,d! mov c,e
 1AEC CD4E13E1C1	call getallocbit! pop h! pop b
CP/M RMAC ASSEM 1.1	#073	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 1AF1 1FD2C21A  	rar! jnc check$npr4 ; no - it will be later
                check$npr45:
 1AF5 0DD1      	dcr c! pop d
                	; Is max dm position less than c?
 1AF7 7AB9DAFD1A	mov a,d! cmp c! jc check$npr5 ; yes
 1AFC 79        	mov a,c ; no
                check$npr5: ; a = index of last block
 1AFD 934704    	sub e! mov b,a! inr b ; b = # of consecutive blks
 1B00 3A83283C4F	lda blkmsk! inr a! mov c,a
                check$npr6:
 1B05 05CA0D1B  	dcr b! jz check$npr7
 1B09 81C3051B  	add c! jmp check$npr6
                check$npr7:
 1B0D C1        	pop b
 1B0E 41        	mov b,c ; b = max # of records
 1B0F 4F        	mov c,a ; c = (# of consecutive blks)*(blkmsk+1)
 1B10 3A9C28B7CA	lda rmf! ora a! jz check$npr8
 1B17 78B9DA1D1B	mov a,b! cmp c! jc check$npr9
                else
                	mov c,e ; multis-sector max = 1 block in non-banked systems
                endif
                
                check$npr8:
 1B1C 79        	mov a,c
                check$npr9:
                	; Restore vrecord
 1B1D E1C170    	pop h! pop b! mov m,b
 1B20 C1        	pop b
                	; a = max # of consecutive records including current blk
                	; b = low(arecord) & blkmsk
                	; c = phymsk
                	; Is mult$num > a - b
 1B21 21992856  	lxi h,mult$num! mov d,m
 1B25 90BAD22B1B	sub b! cmp d! jnc check$npr10
 1B2A 57        	mov d,a ; yes - use smaller value to compute dir$cnt
                check$npr10:
                	; Does this operation involve at least 1 physical record?
 1B2B 792FA23298	mov a,c! cma! ana d! sta dir$cnt! jz check$npr1b ; Deblocking required
                	; Flush any pending buffers before doing multiple reads
 1B34 F53A9C28B7	push a! lda rmf! ora a! jz check$npr10a
 1B3C CD2025CDB6	call flushx! call setdata
                check$npr10a:
 1B42 F167      	pop a! mov h,a ; Save # of 128 byte records
                	; Does this operation involve more than 1 physical record?
                	; Register h contains number of 128 byte records
 1B44 CD9D0F7C  	call shr$physhf! mov a,h
 1B48 FE014FC445	cpi 1! mov c,a! cnz mult$iof ; yes - Make bios call
 1B4E AFC9      	xra a! ret ; Return with z flg set
                
                if MPM
                
                test$unlocked:
                	lda high$ext! ani 80h! ret
                
                test$disk$fcb:
                	call test$unlocked! rz
CP/M RMAC ASSEM 1.1	#074	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	lda dont$close! ora a! rz
                	call close1
                test$disk$fcb1:
                	pop d
                	lxi h,lret! inr m! mvi a,11! jz sta$ret
                	mvi m,0
                	push d
                	call getrcnta! mov a,m! sta rcount ; Reset rcount
                	xra a! sta dont$close
                	inr a! ret
                endif
                
                reset$fwf:
 1B50 CD4B11    	call getmodnum ; hl=.fcb(modnum), a=fcb(modnum)
                	; Reset the file write flag to mark as written fcb
 1B53 E67F      	ani (not fwfmsk) and 0ffh ; bit reset
 1B55 77        	mov m,a ; fcb(modnum) = fcb(modnum) and 7fh
 1B56 C9        	ret
                
                set$filewf:
 1B57 CD4B11E640	call getmodnum! ani 0100$0000b! push a
 1B5D 7EF64077F1	mov a,m! ori 0100$0000b! mov m,a! pop a! ret
                
                seqdiskwrite:
                diskwrite:	; (may enter here from seqdiskwrite above)
 1B63 3E00329C28	mvi a,false! sta rmf ; read mode flag
                	; Write record to currently selected file
                
 1B68 CD3911    	call check$write ; in case write protected
                
                if BANKED
 1B6B 3AB628B7  	lda xfcb$read$only! ora a
 1B6F 3E03C2E523	mvi a,3! jnz set$aret
                endif
                
 1B74 3AB528    	lda high$ext
                
                if MPM
                	ani 0100$0000b
                else
 1B77 B7        	ora a
                endif
                
                	; Z flag reset if r/o mode
 1B78 3E03C2E523	mvi a,3! jnz set$aret
                
 1B7D 2ADBFB    	lhld info ; hl = .fcb(0)
 1B80 CD2B11    	call check$rofile ; may be a read-only file
                
 1B83 CDEE12    	call tst$inv$fcb ; Test for invalid fcb
                
 1B86 CD5321    	call update$stamp
                
 1B89 CD5810    	call getfcb ; to set local parameters
 1B8C 3AA828FE80	lda vrecord! cpi lstrec+1 ; vrecord-128
 1B91 DA9C1B    	jc diskwrite0
CP/M RMAC ASSEM 1.1	#075	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 1B94 CD7119    	call open$reel ; vrecord = 128, try to open next extent
 1B97 3A9F0DB7C0	lda lret! ora a! rnz ; no available fcb
                disk$write0:
                
                if MPM
                	mvi a,0ffh! sta dont$close
                disk$write1:
                
                endif
                
                	; Can write the next record, so continue
 1B9C CDE00F    	call index ; Z flag set if arecord = 0
 1B9F CABA1B    	jz diskwrite2
                	; Was the last write operation for the same block & drive?
 1BA2 21AA281195	lxi h,adrive! lxi d,last$drive! mvi c,3
 1BAA CD1F0ECAB5	call compare! jz diskwrite15 ; yes
                	; no - force preread in blocking/deblocking
 1BB0 3EFF329428	mvi a,0ffh! sta last$off
                diskwrite15:
                
                if MPM
                	; If file is unlocked, verify record is not locked
                	; Record has to be allocated to be locked
                	call test$unlocked! jz not$unlocked
                	call atran! mov c,a
                	lda mult$cnt! mov b,a! push b
                	call test$lock! pop b
                	xra a! mov c,a! push b
                	jmp diskwr10
                not$unlocked:
                	inr a
                endif
                
 1BB5 0E00      	mvi c,0 ; Marked as normal write operation for wrbuff
 1BB7 C3111C    	jmp diskwr1
                diskwrite2:
                
                if MPM
                		call test$disk$fcb! jnz diskwrite1
                endif
                
                if BANKED
 1BBA CDDC0D    		call reset$copy$cr$only
                endif
                
                		; not allocated
                		; The argument to getblock is the starting
                		; position for the disk search, and should be
                		; the last allocated block for this file, or
                		; the value 0 if no space has been allocated
 1BBD CDA40F    		call dm$position
 1BC0 329F28    		sta dminx ; Save for later
 1BC3 010000    		lxi b,0000h ; May use block zero
 1BC6 B7CAD11B  		ora a! jz nopblock ; Skip if no previous block
                			; Previous block exists at a
 1BCA 4F0B      			mov c,a! dcx b ; Previous block # in bc
CP/M RMAC ASSEM 1.1	#076	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 1BCC CDCC0F    			call getdm ; Previous block # to hl
 1BCF 444D      			mov b,h! mov c,l ; bc=prev block#
                		nopblock:
                			; bc = 0000, or previous block #
 1BD1 CDB816    			call get$block ; block # to hl
                		; Arrive here with block# or zero
 1BD4 7DB4C2DE1B		mov a,l! ora h! jnz blockok
                			; Cannot find a block to allocate
 1BD9 3E02C3720A			mvi a,2! jmp sta$ret ; lret=2
                		blockok:
                
                if MPM
                		call set$fcb$cks$flag
                endif
                
                		; allocated block number is in hl
 1BDE 22AB282296		shld arecord! shld last$block! xra a! sta last$off
 1BE8 3AAA283295		lda adrive! sta lastdrive
 1BEE EB        		xchg ; block number to de
 1BEF 2ADBFB0110		lhld info! lxi b,dskmap! dad b ; hl=.fcb(dskmap)
 1BF6 3AA328B7  		lda single! ora a ; Set flags for single byte dm
 1BFA 3A9F28    		lda dminx ; Recall dm index
 1BFD CA071C    		jz allocwd ; Skip if allocating word
                			; Allocating a byte value
 1C00 CD461173  			call addh! mov m,e ; single byte alloc
 1C04 C30F1C    			jmp diskwru ; to continue
                		allocwd:
                		; Allocate a word value
 1C07 4F0600    			mov c,a! mvi b,0 ; double(dminx)
 1C0A 0909      			dad b! dad b ; hl=.fcb(dminx*2)
 1C0C 732372    			mov m,e! inx h! mov m,d ; double wd
                		diskwru:
                		; disk write to previously unallocated block
 1C0F 0E02      		mvi c,2 ; marked as unallocated write
                	diskwr1:
                	; Continue the write operation of no allocation error
                	; c = 0 if normal write, 2 if to prev unalloc block
 1C11 C5        	push b ; Save write flag
 1C12 CDF20F    	call atran ; arecord set
                diskwr10:
 1C15 3ADFFBFE28		lda fx! cpi 40! jnz diskwr11 ; fx ~= wrt rndm zero fill
 1C1D 793D3DC284		mov a,c! dcr a! dcr a! jnz diskwr11 ; old allocation
                
                		; write random zero fill + new block
                
 1C23 C1F5      		pop b! push a ; zero write flag
 1C25 2AAB28E5  		lhld arecord! push h
 1C29 2190285E1C		lxi h,phymsk! mov e,m! inr e! mov d,a! push d
 1C30 2A7928    		lhld dirbcba
                
                if BANKED
 1C33 5E2356EB  		mov e,m! inx h! mov d,m! xchg
                fill00:
 1C37 E5CD782BD1		push h! call get$next$bcba! pop d! jnz fill00
 1C3F EB        		xchg
                endif
CP/M RMAC ASSEM 1.1	#077	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                		; Force prereads in blocking/deblocking
                		; Discard BCB
 1C40 3D32942877		dcr a! sta last$off! mov m,a
 1C45 CDBC12    		call setdir1 ; Set dma to BCB buffer
                		; Zero out BCB buffer
 1C48 D1D5AF    		pop d! push d! xra a
                	fill0:
 1C4B 772314F24B		mov m,a! inx h! inr d! jp fill0
 1C51 571DC24B1C		mov d,a! dcr e! jnz fill0
                		; Write 1st physical record of block
 1C56 2AB1280E02		lhld arecord1! mvi c,2
                	fill1:
 1C5B 22AB28C5CD		shld arecord! push b! call discard$data$bcb
 1C62 CD0C0F    		call seek
                
                if BANKED
 1C65 AFCD54FF  		xra a! call setbnkf
                endif
                
 1C69 C1CD9E0E  		pop b! call wrbuff
 1C6D 2AAB28D1D5		lhld arecord! pop d! push d
                		; Continue writing until blkmsk & arecord = 0
 1C72 193A8328A5		dad d! lda blkmsk! ana l! mvi c,0! jnz fill1
                		; Restore arecord
 1C7C E1E122AB28		pop h! pop h! shld arecord
                
 1C81 CDB612    		call setdata ; Restore dma
                	diskwr11:
                
 1C84 D13AA82857	pop d! lda vrecord! mov d,a ; Load and save vrecord
 1C89 D5CD4D1A  	push d! call check$nprs
                
 1C8D DABA1C    	jc dont$write
 1C90 CA9B1C    	jz write
                
 1C93 3E02      	mvi a,2 ; deblock write code
 1C95 CDFF28    	call deblock$dta
 1C98 C3BA1C    	jmp dont$write
                write:
 1C9B CDB612    	call setdata
 1C9E CD0C0F    	call seek
                
                if BANKED
 1CA1 3E01CD54FF	mvi a,1! call setbnkf
                endif
                
                	; Discard matching BCB if write is direct
 1CA6 CD4A12    	call discard$data$bcb
                
                	; Set write flag to zero if arecord & blkmsk ~= 0
                
 1CA9 C1C53AAB28	pop b! push b! lda arecord
 1CAE 218328A6CA	lxi h,blkmsk! ana m! jz write0
 1CB5 0E00      	mvi c,0
                write0:
CP/M RMAC ASSEM 1.1	#078	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 1CB7 CD9E0E    	call wrbuff
                
                dont$write:
 1CBA C1        	pop b ; c = 2 if a new block was allocated, 0 if not
                	; Increment record count if rcount<=vrecord
 1CBB 7821A528BE	mov a,b! lxi h,rcount! cmp m ; vrecord-rcount
 1CC0 DAC71C    	jc diskwr2
                		; rcount <= vrecord
 1CC3 7734      		mov m,a! inr m ; rcount = vrecord+1
                
                if MPM
                		call test$unlocked! jz write1
                
                		; for unlocked files
                		;   rcount = rcount & (~ blkmsk) + blkmsk + 1
                
                		lda blkmsk! mov b,a! inr b! cma! mov c,a
                		mov a,m! dcr a! ana c! add b! mov m,a
                	write1:
                endif
                
 1CC5 0E02      		mvi c,2 ; Mark as record count incremented
                	diskwr2:
                	; a has vrecord, c=2 if new block or new record#
 1CC7 0D0DC2CF1C	dcr c! dcr c! jnz noupdate
 1CCC CD501B    		call reset$fwf
                
                if MPM
                		call test$unlocked! jz noupdate
                		lda rcount! call getrcnta! mov m,a
                		call close
                		call test$disk$fcb1
                endif
                
                noupdate:
                	; Set file write flag if reset
 1CCF CD571B    	call set$filewf
                
                if BANKED
 1CD2 C2DE1C    	jnz disk$write3
                	; Reset fcb file write flag to ensure t3' gets
                	; reset by the close function
 1CD5 CD501B    	call reset$fwf
 1CD8 CDDC0D    	call reset$copy$cr$only
 1CDB C38210    	jmp setfcb
                disk$write3:
 1CDE CDD50D    	call set$copy$cr$only
                else
                	cz reset$fwf
                endif
 1CE1 C38210    	jmp setfcb ; Replace parameters
                	; ret
                
                rseek:
                	; Random access seek operation, c=0ffh if read mode
                	; fcb is assumed to address an active file control block
CP/M RMAC ASSEM 1.1	#079	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	; (1st block of FCB = 0ffffh if previous bad seek)
 1CE4 C5        	push b ; Save r/w flag
 1CE5 2ADBFBEB  	lhld info! xchg ; de will hold base of fcb
 1CE9 21210019  		lxi h,ranrec! dad d ; hl=.fcb(ranrec)
 1CED 7EE67FF5  		mov a,m! ani 7fh! push psw ; record number
 1CF1 7E17      		mov a,m! ral ; cy=lsb of extent#
 1CF3 237E17E61F		inx h! mov a,m! ral! ani 11111b ; a=ext#
 1CF8 4F        		mov c,a ; c holds extent number, record stacked
                
 1CF9 7EE6F023B6		mov a,m! ani 1111$0000b! inx h! ora m
 1CFE 0F0F0F0F47		rrc! rrc! rrc! rrc! mov b,a
                		; b holds module #
                
                		; Check high byte of ran rec <= 3
 1D03 7E        		mov a,m
 1D04 E6FCE12E06		ani 1111$1100b! pop h! mvi l,6! mov a,h
                
                		; Produce error 6, seek past physical eod
 1D0A C2B01D    		jnz seekerr
                
                		; otherwise, high byte = 0, a = sought record
 1D0D 21200019  		lxi h,nxtrec! dad d ; hl = .fcb(nxtrec)
 1D11 77        		mov m,a ; sought rec# stored away
                
                	; Arrive here with b=mod#, c=ext#, de=.fcb, rec stored
                	; the r/w flag is still stacked.  compare fcb values
                
 1D12 3ADFFBFE63		lda fx! cpi 99! jz rseek3
                		; Check module # first
 1D1A D5CDE812D1		push d! call chk$inv$fcb! pop d! jz ranclose
 1D22 210E001978		lxi h,modnum! dad d! mov a,b ; b=seek mod#
 1D27 96E63FC25B		sub m! ani 3fh! jnz ranclose ; same?
                		; Module matches, check extent
 1D2D 210C0019  		lxi h,extnum! dad d
 1D31 7EB9CAA41D		mov a,m! cmp c! jz seekok2 ; extents equal
 1D36 CD8614C25B		call compext! jnz ranclose
                		; Extent is in same directory fcb
 1D3C C5CD9714C1		push b! call get$dir$ext! pop b
 1D41 B9D2501D  		cmp c! jnc rseek2 ; jmp if dir$ext > ext
 1D45 D1D51CC250		pop d! push d! inr e! jnz rseek2 ; jmp if write fx
 1D4B 1CD1C3760A		inr e! pop d! jmp set$lret1 ; error - reading unwritten data
                	rseek2:
 1D50 71        		mov m,c ; fcb(ext) = c
 1D51 4F        		mov c,a ; c = dir$ext
                		; hl=.fcb(ext),c=dir ext
 1D52 CD2D18    		call restore$rc
 1D55 CDFD17    		call set$rc
 1D58 C3A11D    		jmp seekok1
                	ranclose:
 1D5B C5D5      		push b! push d ; Save seek mod#,ext#, .fcb
 1D5D CD3D18    		call close ; Current extent closed
 1D60 D1C1      		pop d! pop b ; Recall parameters and fill
 1D62 2E03      		mvi l,3 ; Cannot close error #3
 1D64 3A9F0D3CCA		lda lret! inr a! jz seekerr
                	rseek3:
 1D6B CD0319    		call set$xdcnt ; Reset xdcnt for make
CP/M RMAC ASSEM 1.1	#080	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                if MPM
                		call set$sdcnt
                endif
                
 1D6E 210C0019E5		lxi h,extnum! dad d! push h
 1D73 5671      		mov d,m! mov m,c ; fcb(extnum)=ext#
 1D75 23237E5FD5		inx h! inx h! mov a,m! mov e,a! push d
 1D7A E640B077  		ani 040h! ora b! mov m,a
                		; fcb(modnum)=mod#
 1D7E CDDA17    		call open ; Is the file present?
 1D81 3A9F0D3CC2		lda lret! inr a! jnz seekok ; Open successful?
                		; Cannot open the file, read mode?
 1D88 D1E1C1    		pop d! pop h! pop b ; r/w flag to c (=0ffh if read)
 1D8B C5E5D5    		push b! push h! push d ; Restore stack
 1D8E 2E04      		mvi l,4 ; Seek to unwritten extent #4
 1D90 0C        		inr c ; becomes 00 if read operation
 1D91 CAA91D    		jz badseek ; Skip to error if read operation
                		; Write operation, make new extent
 1D94 CD1619    		call make
 1D97 2E05      		mvi l,5 ; cannot create new extent #5
 1D99 CAA91D    		jz badseek ; no dir space
                
                if MPM
                		call fix$olist$item
                endif
                
                		; file make operation successful
                	seekok:
 1D9C C1C1      		pop b! pop b ; Discard top 2 stacked items
                
                if MPM
                		call set$fcb$cks$flag
                else
 1D9E CD4112    		call set$lsn
                endif
                
                	seekok1:
                
                if BANKED
 1DA1 CDDC0D    		call reset$copy$cr$only
                endif
                
                	seekok2:
 1DA4 C1        		pop b ; Discard r/w flag or .fcb(ext)
 1DA5 AFC3720A  		xra a! jmp sta$ret ; with zero set
                	badseek:
                		; Restore fcb(ext) & fcb(mod)
 1DA9 D1E3      		pop d! xthl ; Save error flag
 1DAB 72232373  		mov m,d! inx h! inx h! mov m,e
 1DAF E1        		pop h ; Restore error flag
                	seekerr:
                
                if BANKED
 1DB0 CDDC0D    		call reset$copy$cr$only ; Z flag set
 1DB3 3C        		inr a ; Reset Z flag
CP/M RMAC ASSEM 1.1	#081	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                endif
                
 1DB4 C1        		pop b ; Discard r/w flag
 1DB5 7DC3720A  		mov a,l! jmp sta$ret ; lret=#, nonzero
                
                randiskread:
                	; Random disk read operation
 1DB9 0EFF      	mvi c,true ; marked as read operation
 1DBB CDE41C    	call rseek
 1DBE CCF519    	cz diskread ; if seek successful
 1DC1 C9        	ret
                
                randiskwrite:
                	; Random disk write operation
 1DC2 0E00      	mvi c,false ; marked as write operation
 1DC4 CDE41C    	call rseek
 1DC7 CC631B    	cz diskwrite ; if seek successful
 1DCA C9        	ret
                
                compute$rr:
                	; Compute random record position for getfilesize/setrandom
 1DCB EB19      	xchg! dad d
                	; de=.buf(dptr) or .fcb(0), hl = .f(nxtrec/reccnt)
 1DCD 4E0600    	mov c,m! mvi b,0 ; bc = 0000 0000 ?rrr rrrr
 1DD0 210C00197E	lxi h,extnum! dad d! mov a,m! rrc! ani 80h ; a=e000 0000
 1DD8 814F3E0088	add c! mov c,a! mvi a,0! adc b! mov b,a
                	; bc = 0000 000? errrr rrrr
 1DDE 7E0FE60F80	mov a,m! rrc! ani 0fh! add b! mov b,a
                	; bc = 000? eeee errrr rrrr
 1DE4 210E00197E	lxi h,modnum! dad d! mov a,m ; a=xxmm mmmm
 1DE9 87878787  	add a! add a! add a! add a ; cy=m a=mmmm 0000
                
 1DED B78047F5  	ora a! add b! mov b,a! push psw ; Save carry
 1DF1 7E1F1F1F1F	mov a,m! rar! rar! rar! rar! ani 0000$0011b ; a=0000 00mm
 1DF8 6FF13E008D	mov l,a! pop psw! mvi a,0! adc l ; Add carry
 1DFD C9        	ret
                
                compare$rr:
 1DFE 5F        	mov e,a ; Save cy
 1DFF 79965723  	mov a,c! sub m! mov d,a! inx h ; lst byte
 1E03 789E23    	mov a,b! sbb m! inx h ; middle byte
 1E06 F5B257F1  	push a! ora d! mov d,a! pop a
 1E0A 7B9E      	mov a,e! sbb m ; carry if .fcb(ranrec) > directory
 1E0C C9        	ret
                
                set$rr:
 1E0D 732B702B71	mov m,e! dcx h! mov m,b! dcx h! mov m,c! ret
                
                getfilesize:
                	; Compute logical file size for current fcb
                	; Zero the receiving ranrec field
 1E13 CD3710E5  	call get$rra! push h ; Save position
 1E17 7223722372	mov m,d! inx h! mov m,d! inx h! mov m,d ; =00 00 00
 1E1C CDF514    	call search$extnum
                	getsize:
 1E1F CA3E1E    		jz setsize
CP/M RMAC ASSEM 1.1	#082	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                		; current fcb addressed by dptr
 1E22 CD4011110F		call getdptra! lxi d,reccnt ; ready for compute size
 1E28 CDCB1D    		call compute$rr
                		; a=0000 00mm bc = mmmm eeee errr rrrr
                		; Compare with memory, larger?
 1E2B E1E5      		pop h! push h ; Recall, replace .fcb(ranrec)
 1E2D CDFE1DD40D		call compare$rr! cnc set$rr
 1E33 CD0315    		call searchn
 1E36 3E00329F0D		mvi a,0! sta aret
 1E3B C31F1E    		jmp getsize
                	setsize:
                
 1E3E E1        	pop h ; Discard .fcb(ranrec)
 1E3F C9        	ret
                
                setrandom:
                	; Set random record from the current file control block
 1E40 EB112000  	xchg! lxi d,nxtrec ; Ready params for computesize
 1E44 CDCB1D    	call compute$rr ; de=info, a=0000 00mm, bc=mmmm eeee errr rrrr
 1E47 21210019  	lxi h,ranrec! dad d ; hl = .fcb(ranrec)
 1E4B 7123702377	mov m,c! inx h! mov m,b! inx h! mov m,a ; to ranrec
 1E50 C9        	ret
                
                disk$select:
                	; Select disk info for subsequent input or output ops
 1E51 32AA28    	sta adrive
                disk$select1: ; called by deblock
 1E54 77        	mov m,a ; curdsk = seldsk or adrive
 1E55 57        	mov d,a ; Save seldsk in register D for selectdisk call
 1E56 2A6528CD1D	lhld dlog! call test$vector ; test$vector does not modify DE
 1E5C 5FD5      	mov e,a! push d ; Send to seldsk, save for test below
 1E5E CD330EE1  	call selectdisk! pop h ; Recall dlog vector
 1E62 D2AB0D    	jnc sel$error ; returns with C flag set if select ok
                	; Is the disk logged in?
 1E65 2D        	dcr l ; reg l = 1 if so
 1E66 C9        	ret
                
                tmpselect:
 1E67 21A42873  	lxi h,seldsk! mov m,e
                
                curselect:
 1E6B 3AA42821A9	lda seldsk! lxi h,curdsk! cmp m! jnz select
 1E75 FEFFC0    	cpi 0ffh! rnz ; return if seldsk ~= ffh
                
                select:
 1E78 CD511E    	call disk$select
                
                if MPM
                	jnz select1 ; no
                	; yes - drive previously logged in
                	lhld rlog! call test$vector
                	sta rem$drv! ret ; Set rem$drv & return
                select1:
                
                else
 1E7B C8        	rz ; yes - drive previously logged in
CP/M RMAC ASSEM 1.1	#083	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                endif
                
 1E7C CDE813    	call initialize ; Log in the directory
                
                	; Increment login sequence # if odd
 1E7F 2A71287EE6	lhld lsn$add! mov a,m! ani 1! push a! add m! mov m,a
 1E88 F1C4E811  	pop a! cnz set$rlog
                
 1E8C CD0511    	call set$dlog
                
                if MPM
                	lxi h,chksiz+1! mov a,m! ral! mvi a,0! jc select2
                	lxi d,rlog! call set$cdisk ; rlog=set$cdisk(rlog)
                	mvi a,1
                select2:
                	sta rem$drv
                endif
                
 1E8F C9        	ret
                
                reselectx:
 1E90 AF32B528  	xra a! sta high$ext
                
                if BANKED
 1E94 32B628    	sta xfcb$read$only
                endif
                
 1E97 C3B91E    	jmp reselect1
                
                reselect:
                	; Check current fcb to see if reselection necessary
 1E9A 017F80    	lxi b,807fh
 1E9D 2ADBFB1107	lhld info! lxi d,7! xchg! dad d
                
                if BANKED
                	; xfcb$read$only = 80h & fcb(7)
 1EA5 7EA032B628	mov a,m! ana b! sta xfcb$read$only
                	; fcb(7) = fcb(7) & 7fh
 1EAA 7EA177    	mov a,m! ana c! mov m,a
                endif
                
                if MPM
                	; if fcb(8) & 80h
                	;    then fcb(8) = fcb(8) & 7fh, high$ext = 60h
                	;    else high$ext = fcb(ext) & 0e0h
                	inx h! lxi d,4
                	mov a,m! ana c! cmp m! mov m,a! mvi a,60h! jnz reselect0
                	dad d! mvi a,0e0h! ana m
                reselect0:
                	sta high$ext
                else
                	; high$ext = 80h & fcb(8)
 1EAD 237EA032B5	inx h! mov a,m! ana b! sta high$ext
                	; fcb(8) = fcb(8) & 7fh
 1EB3 7EA177    	mov a,m! ana c! mov m,a
                endif
CP/M RMAC ASSEM 1.1	#084	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                	; fcb(ext) = fcb(ext) & 1fh
 1EB6 CD5A11    	call clr$ext
                reselect1:
                
 1EB9 210000    	lxi h,0
                
                if BANKED
 1EBC 2215FD    	shld make$xfcb ; make$xfcb,find$xfcb = 0
                endif
 1EBF 2217FD    	shld xdcnt ; required by directory hashing
                
 1EC2 AF32BD28  	xra a! sta search$user0
 1EC6 3D32DDFB  	dcr a! sta resel ; Mark possible reselect
 1ECA 2ADBFB7E  	lhld info! mov a,m ; drive select code
 1ECE 32BF28    	sta fcbdsk ; save drive code
 1ED1 E61F      	ani 1$1111b ; non zero is auto drive select
 1ED3 3D        	dcr a ; Drive code normalized to 0..30, or 255
 1ED4 329E28    	sta linfo ; Save drive code
 1ED7 FEFFCADF1E	cpi 0ffh! jz noselect
                		; auto select function, seldsk saved above
 1EDC 32A428    		sta seldsk
                	noselect:
 1EDF CD6B1E    		call curselect
                		; Set user code
 1EE2 3AE0FB    		lda usrcode ; 0...15
 1EE5 2ADBFB77  		lhld info! mov m,a
                	noselect0:
                		; Discard directory BCB's if drive is removable
                		; and fx = 15,17,19,22,23,30 etc.
 1EE9 CDF511CC58		call tst$log$fxs! cz discard$dir
                		; Check for media change on currently slected disk
 1EEF CDF51E    		call check$media
                		; Check for media change on any other disks
 1EF2 C32F1F    		jmp check$all$media
                
                check$media:
                	; Check media if DPH media flag set.
                	; Is DPH media flag set?
 1EF5 CD0C12C8  	call test$media$flag! rz ; no
                	; Test for media change by reading directory
                	; to current high water mark or until media change
                	; is detected.
                	; First reset DPH media flag & discard directory BCB's
 1EF9 3600      	mvi m,0
 1EFB CD5812    	call discard$dir
 1EFE 2AE1FBE5  	lhld dcnt! push h
 1F02 CD800ECD01	call home! call set$end$dir
                check$media1:
 1F08 0E00CD0E13	mvi c,false! call r$dir
 1F0D 21DEFB7EB7	lxi h,relog! mov a,m! ora a! jz check$media2
 1F15 3600E13ADF	mvi m,0! pop h! lda fx! cpi 48! rz
 1F1E CD3312C313	call drv$relog! jmp chk$exit$fxs
                check$media2:
 1F24 CD6911DA08	call comp$cdr! jc check$media1
 1F2A E122E1FBC9	pop h! shld dcnt! ret
CP/M RMAC ASSEM 1.1	#085	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                check$all$media:
                	; This routine checks all logged-in drives for
                	; a set DPH media flag and pending buffers.  It reads
                	; the directory for these drives to verify that media
                	; has not changed.  If media has changed, the drives
                	; get reset (but not relogged-in).
                	; Is SCB media flag set?
 1F2F 21F0FB7EB7	lxi h,media$flag! mov a,m! ora a! rz ; no
                	; Reset SCB media flag
 1F35 3600      	mvi m,0
                	; Test logged-in drives only
 1F37 2A65283E10	lhld dlog! mvi a,16
                chk$am1:
 1F3C 3D29D2511F	dcr a! dad h! jnc chk$am2
                	; A = drive #
                	; Select drive
 1F41 F5E521A928	push a! push h! lxi h,curdsk! call disk$select
                	; Does drive have pending data buffers?
 1F49 CD581FC4F5	call test$pending! cnz check$media ; yes
 1F4F E1F1      	pop h! pop a
                chk$am2:
 1F51 B7C23C1F  	ora a! jnz chk$am1
 1F55 C36B1E    	jmp curselect
                
                test$pending:
                	; On return, Z flag reset if buffer pending
                
                	; Does dta$bcba = 0ffffh
 1F58 2A7B287DA4	lhld dta$bcba! mov a,l! ana h! inr a! rz ; yes
                
                if BANKED
                
                test$p1:
                	; Does bcb addr = 0?
 1F5F 5E2356    	mov e,m! inx h! mov d,m
 1F62 7BB2C8    	mov a,e! ora d! rz ; yes - no pending buffers
 1F65 210400    	lxi h,4
                else
                	lxi d,4
                endif
                
                	; Is buffer pending?
 1F68 197EB7    	dad d! mov a,m! ora a ; A ~= 0 if so
                
                if BANKED
 1F6B C0        	rnz ; yes
                	; no - advance to next bcb
 1F6C 210D0019C3	lxi h,13! dad d! jmp test$p1
                else
                	ret
                endif
                
                get$dir$mode:
 1F73 2A6F287E  	lhld drvlbla! mov a,m
                
CP/M RMAC ASSEM 1.1	#086	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                if not BANKED
                	ani 7fh ; Mask off password bit
                endif
                
 1F77 C9        	ret
                
                if BANKED
                
                chk$password:
 1F78 CD731FE680	call get$dir$mode! ani 80h! rz
                
                chk$pw:		; Check password
 1F7E CD8320C8  	call get$xfcb! rz ; a = xfcb options
 1F82 C30220    	jmp cmp$pw
                
                chk$pw$error:
                	; Disable special searches
 1F85 AF3218FD  	xra a! sta xdcnt+1
                	; pw$fcb = dir$xfcb
 1F89 CD4011EB  	call getdptra! xchg
 1F8D 0E0C21D728	mvi c,12! lxi h,pw$fcb! push h
 1F93 CD290E1A23	call move! ldax d! inx h! mov m,a! pop d
 1F9A 2ADBFB7E12	lhld info! mov a,m! stax d
                	; push original info and xfcb password mode
                	; info = .pw$fcb
 1F9F E5EB22DBFB	push h! xchg! shld info
                	; Does fcb(ext = 0, mod = 0) exist?
 1FA4 CDF014CAE4	call search$namlen! jz chk$pwe2 ; no
                	; Does sfcb exist for fcb ?
 1FAA CD1021B7C2	call get$dtba$8! ora a! jnz chk$pwe1 ; no
 1FB1 EB21E428  	xchg! lxi h,pw$mode
                	; Is sfcb password mode nonzero?
 1FB5 461A77B7CA	mov b,m! ldax d! mov m,a! ora a! jz chk$pwe2 ; no
                	; Do password modes match?
 1FBC A8E6E0CAD2	xra b! ani 0e0h! jz chk$pwe1 ; yes
                	; no - update xfcb to match sfcb
 1FC2 CD8320CAD2	call get$xfcb! jz chk$pwe1 ; no xfcb (error)
 1FC8 3AE42877CD	lda pw$mode! mov m,a! call nowrite! cz seek$copy
                chk$pwe1:
 1FD2 E122DBFB  	pop h! shld info
 1FD6 3ADFFBFE0F	lda fx! cpi 15! rz! cpi 22! rz
                
                pw$error:	; password error
 1FDF 3E07C3E523	mvi a,7! jmp set$aret
                
                chk$pwe2:
 1FE4 AF32E428  	xra a! sta pw$mode
 1FE8 CD1A11C2FD	call nowrite! jnz chk$pwe3
                	; Delete xfcb
 1FEE CD8320F5  	call get$xfcb! push a
 1FF2 2ADBFB7EF6	lhld info! mov a,m! ori 10h! mov m,a
 1FF9 F1C48716  	pop a! cnz delete$10
                chk$pwe3:
                	; Restore info
 1FFD E122DBFBC9	pop h! shld info! ret
                
CP/M RMAC ASSEM 1.1	#087	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                cmp$pw:		; Compare passwords
 2002 2346      	inx h! mov b,m
 2004 78B7C21D20	mov a,b! ora a! jnz cmp$pw2
 2009 545D2323  	mov d,h! mov e,l! inx h! inx h
 200D 0E09      	mvi c,9
                cmp$pw1:
 200F 237E0DC8  	inx h! mov a,m! dcr c! rz
 2013 B7CA0F20  	ora a! jz cmp$pw1
 2017 FE20CA0F20	cpi 20h! jz cmp$pw1
 201C EB        	xchg
                cmp$pw2:
 201D 110A0019EB	lxi d,(23-ubytes)! dad d! xchg
 2022 2A19FD0E08	lhld xdmaad! mvi c,8
                cmp$pw3:
 2027 1AA8BEC234	ldax d! xra b! cmp m! jnz cmp$pw4
 202D 1B230DC227	dcx d! inx h! dcr c! jnz cmp$pw3
 2033 C9        	ret
                cmp$pw4:
 2034 1B0DC23420	dcx d! dcr c! jnz cmp$pw4
 2039 13        	inx d
                
                if MPM
                	call get$df$pwa! inr a! jnz cmp$pw5
                	inr a! ret
                cmp$pw5:
                
                else
 203A 21E728    	lxi h,df$password
                endif
                
 203D 0E08C31F0E	mvi c,8! jmp compare
                
                if MPM
                
                get$df$pwa:	; a = ff => no df pwa
                	call rlr! lxi b,console! dad b
                	mov a,m! cpi 16! mvi a,0ffh! rnc
                	mov a,m! add a! add a! add a
                	mvi h,0! mov l,a! lxi b,dfpassword! dad b
                	ret
                endif
                
                set$pw:		; Set password in xfcb
 2042 E5        	push h ; Save .xfcb(ex)
 2043 010800    	lxi b,8 ; b = 0, c = 8
 2046 110B0019  	lxi d,(23-extnum)! dad d
 204A EB2A19FD  	xchg! lhld xdmaad
                set$pw0:
 204E AFF5      	xra a! push a
                set$pw1:
 2050 7E12B7CA5E	mov a,m! stax d! ora a! jz set$pw2
 2056 FE20CA5E20	cpi 20h! jz set$pw2
 205B 3333F5    	inx sp! inx sp! push a
                set$pw2:
 205E 8047      	add b! mov b,a
 2060 1B230DC250	dcx d! inx h! dcr c! jnz set$pw1
CP/M RMAC ASSEM 1.1	#088	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 2066 F1B0E1C276	pop a! ora b! pop h! jnz set$pw3
                	; is fx = 100 (directory label)?
 206C 3ADFFBFE64	lda fx! cpi 100! jz set$pw3 ; yes
 2074 3600      	mvi m,0 ; zero xfcb(ex) - no password
                set$pw3:
 2076 130E08    	inx d! mvi c,8
                set$pw4:
 2079 1AA812130D	ldax d! xra b! stax d! inx d! dcr c! jnz set$pw4
 2081 23C9      	inx h! ret
                
                get$xfcb:
 2083 2ADBFB7EF5	lhld info! mov a,m! push a
 2088 F61077    	ori 010h! mov m,a
 208B CDF5143E00	call search$extnum! mvi a,0! sta lret
 2093 2ADBFBC170	lhld info! pop b! mov m,b! rz
                get$xfcb1:
 2099 CD4011EB  	call getdptra! xchg
 209D 210C00197E	lxi h,extnum! dad d! mov a,m! ani 0e0h! ori 1
 20A6 C9        	ret
                
                adjust$dmaad:
 20A7 E52A19FD19	push h! lhld xdmaad! dad d
 20AC 2219FDE1C9	shld xdmaad! pop h! ret
                
                init$xfcb:
 20B1 CD7611    	call setcdr ; may have extended the directory
 20B4 011410    	lxi b,1014h ; b=10h, c=20
                init$xfcb0:
                	; b = fcb(0) logical or mask
                	; c = zero count
 20B7 C5        	push b
 20B8 CD4011EB2A	call getdptra! xchg! lhld info! xchg
                	; Zero extnum and modnum
 20C0 1AB0771323	ldax d! ora b! mov m,a! inx d! inx h
 20C5 0E0BCD290E	mvi c,11! call move! pop b! inr c
                init$xfcb1:
 20CC 0DC8      	dcr c! rz
 20CE 360023C3CC	mvi m,0! inx h! jmp init$xfcb1
                
                chk$xfcb$password:
 20D4 CD9920    	call get$xfcb1
                chk$xfcb$password1:
 20D7 E5CD0220E1	push h! call cmp$pw! pop h! ret
                
                endif
                
                stamp1:
 20DD 0E00C3E420	mvi c,0! jmp stamp3
                stamp2:
 20E2 0E04      	mvi c,4
                stamp3:
 20E4 CD1221B7C0	call get$dtba! ora a! rnz
 20E9 119A12D5  	lxi d,seek$copy! push d
                stamp4:
                
                if MPM
CP/M RMAC ASSEM 1.1	#089	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	push h
                	call get$stamp$add! xchg
                	pop h
                else
 20ED 11F4FB    	lxi d,stamp
                endif
                
 20F0 E5D5      	push h! push d
 20F2 0E00CD4EFF	mvi c,0! call timef ; does not modify hl,de
 20F7 0E04CD1F0E	mvi c,4! call compare
 20FC 0E04D1E1C2	mvi c,4! pop d! pop h! jnz move
 2103 E1C9      	pop h! ret
                
                stamp5:
 2105 CD40110911	call getdptra! dad b! lxi d,func$ret! push d
 210D C3ED20    	jmp stamp4
                
                if BANKED
                
                get$dtba$8:
 2110 0E08      	mvi c,8
                endif
                
                get$dtba:
                	; c = offset of sfcb subfield (0,4,8)
                	; Return with a = 0 if sfcb exists
                
                	; Does fcb occupy 4th item of sector?
 2112 3AE1FBE603	lda dcnt! ani 3! cpi 3! rz ; yes
 211A 47        	mov b,a
 211B 2A67281160	lhld buffa! lxi d,96! dad d
                	; Does sfcb reside in 4th directory item?
 2122 7ED621C0  	mov a,m! sui 21h! rnz ; no
                	; hl = hl + 10*lret + 1 + c
 2126 78875F8787	mov a,b! add a! mov e,a! add a! add a! add e
 212C 3C815F19AF	inr a! add c! mov e,a! dad d! xra a
 2131 C9        	ret
                
                qstamp:
                	; Is fcb 1st logical fcb for file?
 2132 CD4021C0  	call qdirfcb1! rnz ; no
                qstamp1:
                	; Does directory label specify requested stamp?
 2136 2A6F2879A6	lhld drvlbla! mov a,c! ana m! jnz nowrite ; yes - verify drive r/w
 213E 3CC9      	inr a! ret ; no - return with Z flag reset
                
                qdirfcb1:
                	; Routine to determine if fcb is 1st directory fcb
                	; for file
                	; Is fcb(ext) & ~extmsk & 00011111b = 0?
 2140 3A8428F6E0	lda extmsk! ori 1110$0000b! cma! mov b,a
 2147 CD3F107EA0	call getexta! mov a,m! ana b! rnz ; no
                	; is fcb(mod) & 0011$1111B = 0?
 214D 23237EE63F	inx h! inx h! mov a,m! ani 3fh! ret ; Z flag set if zero
                
                update$stamp:
CP/M RMAC ASSEM 1.1	#090	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	; Is update stamping requested on drive?
 2153 0E20CD3621	mvi c,0010$0000b! call qstamp1! rnz ; no
                	; Has file been written to since it was opened?
 2159 CD4B11E640	call getmodnum! ani 40h! rnz ; yes - update stamp performed
                	; Search for 1st dir fcb
 215F CD3F104636	call getexta! mov b,m! mvi m,0! push h
 2166 23234E3600	inx h! inx h! mov c,m! mvi m,0! push b
                	; Search from beginning of directory
 216C CDF014    	call search$namlen
                	; Perform update stamp if dir fcb 1 found
 216F C4E220    	cnz stamp2
 2172 AF329F0D  	xra a! sta lret
                	; Restore fcb extent and module fields
 2176 C1E1702323	pop b! pop h! mov m,b! inx h! inx h! mov m,c! ret
                
                if MPM
                
                pack$sdcnt:
                
                ;packed$dcnt = dblk(low 15 bits) || dcnt(low 9 bits)
                
                ;	if sdblk = 0 then dblk = shr(sdcnt,blkshf+2)
                ;		     else dblk = sdblk
                ;	dcnt = sdcnt & (blkmsk || '11'b)
                ;
                ;	packed$dcnt format (24 bits)
                ;
                ;	12345678 12345678 12345678
                ;	23456789 .......1 ........ sdcnt (low 9 bits)
                ;	........ 9abcdef. 12345678 sdblk (low 15 bits)
                ;
                	lhld sdblk! mov a,h! ora l! jnz pack$sdcnt1
                	lda blkshf! adi 2! mov c,a! lhld sdcnt
                	call hlrotr
                pack$sdcnt1:
                	dad h! xchg! lxi h,sdcnt! mvi b,1
                	lda blkmsk! ral! ora b! ral! ora b
                	ana m! sta packed$dcnt
                	lda blkshf! cpi 7! jnz pack$sdcnt2
                	inx h! mov a,m! ana b! jz pack$sdcnt2
                	mov a,e! ora b! mov e,a
                pack$sdcnt2:
                	xchg! shld packed$dcnt+1
                	ret
                
                ; olist element = link(2) || atts(1) || dcnt(3) ||
                ;		 pdaddr(2) || opncnt(2)
                ;
                ;	link = 0 -> end of list
                ;
                ;	atts - 80 - open in locked mode
                ;	       40 - open in unlocked mode
                ;	       20 - open in read/only mode
                ;	       10 - deleted item
                ;	       0n - drive code (0-f)
                ;
CP/M RMAC ASSEM 1.1	#091	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                ;	dcnt = packed sdcnt+sdblk
                ;	pdaddr = process descriptor addr
                ;	opncnt = # of open calls - # of close calls
                ;		 olist item freed by close when opncnt = 0
                ;
                ; llist element = link(2) || drive(1) || arecord(3) ||
                ;		 pdaddr(2) || .olist$item(2)
                ;
                ;	link = 0 -> end of list
                ;
                ;	drive - 0n - drive code (0-f)
                ;
                ;	arecord = record number of locked record
                ;	pdaddr = process descriptor addr
                ;	.olist$item = address of file's olist item
                
                search$olist:
                	lxi h,open$root! jmp srch$list0
                search$llist:
                	lxi h,lock$root! jmp srch$list0
                searchn$list:
                	lhld cur$pos
                srch$list0:
                	shld prv$pos
                
                ; search$olist, search$llist, searchn$list conventions
                ;
                ;	b = 0 -> return next item
                ;	b = 1 -> search for matching drive
                ;	b = 3 -> search for matching dcnt
                ;	b = 5 -> search for matching dcnt + pdaddr
                ;	if found then z flag is set
                ;		      prv$pos -> previous list element
                ;		      cur$pos -> found list element
                ;		      hl -> found list element
                ;	else prv$pos -> list element to insert after
                ;
                ;	olist and llist are maintained in drive order
                
                srch$list1:
                	mov e,m! inx h! mov d,m! xchg
                	mov a,l! ora h! jz srch$list3
                	xra a! cmp b! jz srch$list6
                	inx h! inx h!
                	lxi d,curdsk! mov a,m! ani 0fh! mov c,a
                	ldax d! sub c! jnz srch$list4
                	mov a,b! dcr a! jz srch$list5
                	mov c,b! push h
                	inx d! inx h! call compare
                	pop h! jz srch$list5
                srch$list2:
                	dcx h! dcx h
                	shld prv$pos! jmp srch$list1
                srch$list3:
                	inr a! ret
                srch$list4:
CP/M RMAC ASSEM 1.1	#092	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	jnc srch$list2
                srch$list5:
                	dcx h! dcx h
                srch$list6:
                	shld cur$pos! ret
                
                delete$item: ; hl -> item to be deleted
                	di
                	push d! push h
                	mov e,m! inx h! mov d,m
                	lhld prv$pos! shld cur$pos
                	; prv$pos.link = delete$item.link
                	mov m,e! inx h! mov m,d
                
                	lhld free$root! xchg
                	; free$root = .delete$item
                	pop h! shld free$root
                	; delete$item.link = previous free$root
                	mov m,e! inx h! mov m,d
                	pop d! ei! ret
                
                create$item: ; hl -> new item if successful
                	     ; z flag set if no free items
                	lhld free$root! mov a,l! ora h! rz
                	push d! push h! shld cur$pos
                	mov e,m! inx h! mov d,m
                	; free$root = free$root.link
                	xchg! shld free$root
                
                	lhld prv$pos
                	mov e,m! inx h! mov d,m
                	pop h
                	; create$item.link = prv$pos.link
                	mov m,e! inx h! mov m,d! dcx h
                	xchg! lhld prv$pos
                	; prv$pos.link = .create$item
                	mov m,e! inx h! mov m,d! xchg
                	pop d! ret
                
                set$olist$item:
                	; a = attributes
                	; hl = olist entry address
                	inx h! inx h
                	mov b,a! lxi d,curdsk! ldax d! ora b
                	mov m,a! inx h! inx d
                	mvi c,5! call move
                	xra a! mov m,a! inx h! mov m,a! ret
                
                set$sdcnt:
                	mvi a,0ffh! sta sdcnt+1! ret
                
                tst$olist:
                	mvi a,0c9h! sta chk$olist05! jmp chk$olist0
                chk$olist:
                	xra a! sta chk$olist05
                chk$olist0:
CP/M RMAC ASSEM 1.1	#093	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	lxi d,dcnt! lxi h,sdcnt! mvi c,4! call move
                	call pack$sdcnt! mvi b,3! call search$olist! rnz
                	pop d ; pop return address
                	inx h! inx h
                	mov a,m! ani 80h! jz openx06
                	dcx h! dcx h
                	push d! push h
                	call compare$pds! pop h! pop d! jnz openx06
                	push d ; Restore return address
                chk$olist05:
                	nop ; tst$olist changes this instr to ret
                	call delete$item! lda pdcnt
                chk$olist1:
                	adi 16! jz chk$olist1
                	sta pdcnt
                
                	push a! call rlr
                	lxi b,pdcnt$off! dad b! pop a
                	mov m,a! ret
                
                remove$files:	; bc = pdaddr
                	lhld cur$pos! push h
                	lhld prv$pos! push h
                	mov d,b! mov e,c! lxi h,open$root! shld cur$pos
                remove$file1:
                	mvi b,0! push d! call searchn$list! pop d! jnz remove$file2
                	lxi b,6! call tst$tbl$lmt! jnz remove$file1
                	inx h! inx h! mov a,m! ori 10h! mov m,a
                	sta deleted$files
                	jmp remove$file1
                remove$file2:
                	pop h! shld prv$pos
                	pop h! shld cur$pos
                	ret
                
                delete$files:
                	lxi h,open$root! shld cur$pos
                delete$file1:
                	mvi b,0! call search$nlist! rnz
                	inx h! inx h! mov a,m! ani 10h! jz delete$file1
                	dcx h! dcx h! call remove$locks! call delete$item
                	jmp delete$file1
                
                flush$files:
                	lxi h,flushed! mov a,m! ora a! rnz
                	inr m
                flush$file0:
                	lxi h,open$root! shld cur$pos
                flush$file1:
                	mvi b,1! call searchn$list! rnz
                	push h! call remove$locks! call delete$item! pop h
                	lxi d,6! dad d! mov e,m! inx h! mov d,m
                	lxi h,pdcnt$off! dad d! mov a,m! ani 1! jnz flush$file1
                	mov a,m! ori 1! mov m,a
                	lhld pdaddr! mvi c,2! call compare! jnz flush$file1
                	lda pdcnt! adi 10h! sta pdcnt! jmp flush$file1
CP/M RMAC ASSEM 1.1	#094	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                free$files:
                	; free$mode = 1 - remove curdsk files for process
                	;	      0 - remove all files for process
                	lhld pdaddr! xchg! lxi h,open$root! shld curpos
                free$files1:
                	lda free$mode! mov b,a
                	push d! call searchn$list! pop d! rnz
                	lxi b,6! call tst$tbl$lmt! jnz free$files1
                	push h! inx h! inx h! inx h
                	call test$ffff! jnz free$files2
                	call test$ffff! jz free$files3
                free$files2:
                	mvi a,0ffh! sta incr$pdcnt
                free$files3:
                	pop h! call remove$locks! call delete$item
                	jmp free$files1
                
                remove$locks:
                	shld file$id
                	inx h! inx h! mov a,m! ani 40h! jz remove$lock3
                	push d! lhld prv$pos! push h
                	lhld file$id! xchg! lxi h,lock$root! shld cur$pos
                remove$lock1:
                	mvi b,0! push d! call searchn$list! pop d
                	jnz remove$lock2
                	lxi b,8! call tst$tbl$lmt! jnz remove$lock1
                	call delete$item
                	jmp remove$lock1
                remove$lock2:
                	pop h! shld prv$pos! pop d
                remove$lock3:
                	lhld file$id! ret
                
                tst$tbl$lmt:
                	push h! dad b
                	mov a,m! inx h! mov h,m
                	sub e! jnz tst$tbl$lmt1
                	mov a,h! sub d
                tst$tbl$lmt1:
                	pop h! ret
                
                create$olist$item:
                	mvi b,1! call search$olist
                	di
                	call create$item! lda attributes! call set$olist$item
                	ei
                	ret
                
                count$opens:
                	xra a! sta open$cnt
                	lhld pdaddr! xchg! lxi h,open$root! shld curpos
                count$open1:
                	mvi b,0! push d! call searchn$list! pop d! jnz count$open2
                	lxi b,6! call tst$tbl$lmt! jnz count$open1
                	lda open$cnt! inr a! sta open$cnt
CP/M RMAC ASSEM 1.1	#095	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	jmp count$open1
                count$open2:
                	lxi h,open$max! lda open$cnt! ret
                
                count$locks:
                	xra a! sta lock$cnt
                	xchg! lxi h,lock$root! shld cur$pos
                count$lock1:
                	mvi b,0! push d! call searchn$list! pop d! rnz
                	lxi b,8! call tst$tbl$lmt! jnz count$lock1
                	lda lock$cnt! inr a! sta lock$cnt
                	jmp count$lock1
                
                check$free:
                	lda mult$cnt! mov e,a
                	mvi d,0! lxi h,free$root! shld cur$pos
                check$free1:
                	mvi b,0! push d! call searchn$list! pop d! jnz check$free2
                	inr d! mov a,d! sub e! jc check$free1
                	ret
                check$free2:
                	pop h! mvi a,14! jmp sta$ret
                
                lock:				; record lock and unlock
                	call reselect! call check$fcb
                	call test$unlocked
                	rz ; file not opened in unlocked mode
                	lhld xdmaad! mov e,m! inx h! mov d,m
                	xchg! inx h! inx h
                	mov a,m! mov b,a! lda curdsk! sub b
                	ani 0fh! jnz lock8 ; invalid file id
                	mov a,b! ani 40h! jz lock8 ; invalid file id
                	dcx h! dcx h! shld file$id
                	lda lock$unlock! inr a! jnz lock1 ; jmp if unlock
                	call count$locks
                	lda lock$cnt! mov b,a
                	lda mult$cnt! add b! mov b,a
                	lda lock$max! cmp b
                	mvi a,12! jc sta$ret ; too many locks by this process
                	call check$free
                lock1:
                	call save$rr! lxi h,lock9! push h! lda mult$cnt
                lock2:
                	push a! call get$lock$add
                	lda lock$unlock! inr a! jnz lock3
                	call test$lock
                lock3:
                	pop a! dcr a! jz lock4
                	call incr$rr! jmp lock2
                lock4:
                	call reset$rr! lda mult$cnt
                lock5:
                	push a! call get$lock$add
                	lda lock$unlock! inr a! jnz lock6
                	call set$lock! jmp lock7
                lock6:
CP/M RMAC ASSEM 1.1	#096	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	call free$lock
                lock7:
                	pop a! dcr a! rz
                	call incr$rr! jmp lock5
                lock8:
                	mvi a,13! jmp sta$ret ; invalid file id
                lock9:
                	call reset$rr! ret
                
                get$lock$add:
                	lxi h,0! dad sp! shld lock$sp
                	mvi a,0ffh! sta lock$shell
                	call rseek
                	xra a! sta lock$shell
                	call getfcb
                	lhld aret! mov a,l! ora a! jnz lock$err
                	call index! lxi h,1! jz lock$err
                	call atran! ret
                
                lock$perr:
                	xra a! sta lock$shell
                	xchg! lhld lock$sp! sphl! xchg
                lock$err:
                	pop d ; Discard return address
                	pop b ; b = mult$cnt-# recs processed
                	lda mult$cnt! sub b
                	add a! add a! add a! add a
                	ora h! mov h,a! mov b,a
                	shld aret! ret
                
                test$lock:
                	call move$arecord
                	mvi b,3! call search$llist! rnz
                	call compare$pds! rz
                	lxi h,8! jmp lock$err
                
                set$lock:
                	call move$arecord
                	mvi b,1! call search$llist
                	di
                	call create$item
                	xra a! call set$olist$item
                	xchg! lhld file$id! xchg
                	mov m,d! dcx h! mov m,e
                	ei! ret
                
                free$lock:
                	call move$arecord
                	mvi b,5! call search$llist! rnz
                free$lock0:
                	call delete$item
                	mvi b,5! call searchn$list! rnz
                	jmp free$lock0
                
                compare$pds:
                	lxi d,6! dad d! xchg
CP/M RMAC ASSEM 1.1	#097	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	lxi h,pdaddr! mvi c,2! jmp compare
                
                
                move$arecord:
                	lxi d,arecord! lxi h,packed$dcnt
                
                
                fix$olist$item:
                	lxi d,xdcnt! lxi h,sdcnt
                	; Is xdblk,xdcnt < sdblk,sdcnt
                	mvi c,4! ora a!
                fix$ol1:
                	ldax d! sbb m! inx h! inx d! dcr c! jnz fix$ol1
                	rnc
                	; yes - update olist entry
                	call swap! call sdcnt$eq$xdcnt
                	lxi h,open$root! shld cur$pos
                	; Find file's olist entry
                fix$ol2:
                	call swap! call pack$sdcnt! call swap
                	mvi b,3! call searchn$list! rnz
                	; Update olist entry with new dcnt value
                	push h! call pack$sdcnt! pop h
                	inx h! inx h! inx h! lxi d,packed$dcnt
                	mvi c,3! call move! jmp fix$ol2
                
                hl$eq$hl$and$de:
                	mov a,l! ana e! mov l,a
                	mov a,h! ana d! mov h,a
                	ret
                
                remove$drive:
                	xchg! lda curdsk! mov c,a! lxi h,1
                	call hlrotl
                	mov a,l! cma! ana e! mov e,a
                	mov a,h! cma! ana d! mov d,a
                	xchg! ret
                
                diskreset:
                	lxi h,0! shld ntlog
                	xra a! sta set$ro$flag
                	lhld info
                intrnldiskreset:
                	xchg! lhld open$root! mov a,h! ora l! rz
                	xchg! lda curdsk! push a! mvi b,0
                dskrst1:
                	mov a,l! rar! jc dskrst3
                dskrst2:
                	mvi c,1! call hlrotr! inr b
                	mov a,h! ora l! jnz dskrst1
                	pop a! sta curdsk
                	lhld ntlog! xchg! lhld tlog
                	mov a,l! ora e! mov l,a
                	mov a,h! ora d! mov h,a! shld tlog
                	inr a! ret
                dskrst3:
CP/M RMAC ASSEM 1.1	#098	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	push b! push h! mov a,b! sta curdsk
                	lhld rlog! call test$vector1! push a
                	lhld rodsk! lda curdsk! call test$vector1! mov b,a
                	pop h! lda set$ro$flag! ora b! ora h! sta check$disk
                	lxi h,open$root! shld cur$pos
                dskrst4:
                	mvi b,1! call searchn$list! jnz dskrst6
                	lda check$disk! ora a! jz dskrst5
                	push h! call compare$pds! jz dskrst45
                	pop h! xra a! xchg! jmp dskrst6
                dskrst45:
                	lxi d,ntlog! call set$cdisk
                	pop h! jmp dskrst4
                dskrst5:
                	lhld info! call remove$drive! shld info
                	ori 1
                dskrst6:
                	pop h! pop b! jnz dskrst2
                
                	; error - olist item exists for another process
                	; for removable drive to be reset
                	pop a! sta curdsk! mov a,b! adi 41h ; a = ascii drive
                	lxi h,6! dad d! mov c,m! inx h! mov b,m ; bc = pdaddr
                	push psw! call test$error$mode! pop d! jnz dskrst7
                	mov a,d
                
                	push b! push psw
                	call rlr! lxi d,console! dad d! mov d,m ; d = console #
                	lxi b,deniedmsg! call xprint
                	pop psw! mov c,a! call conoutx
                	mvi c,':'! call conoutx
                	lxi b,cnsmsg! call xprint
                	pop h! push h! lxi b,console! dad b
                	mov a,m! adi '0'! mov c,a! call conoutx
                	lxi b,progmsg! call xprint
                	pop h! call dsplynm
                
                dskrst7:
                	pop h ; Remove return addr from diskreset
                	lxi h,0ffffh! shld aret ; Flag the error
                	ret
                
                deniedmsg:
                	db cr,lf,'disk reset denied, drive ',0
                cnsmsg:
                	db ' console ',0
                progmsg:
                	db ' program ',0
                endif
                
                ;
                ;	individual function handlers
                ;
                
                func12:
                	; Return version number
CP/M RMAC ASSEM 1.1	#099	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                if MPM
                	lxi h,0100h+dvers! jmp sthl$ret
                else
 217D 3AA1FBC372	lda version! jmp sta$ret ; lret = dvers (high = 00)
                endif
                
                func13:
                
                if MPM
                	lhld dlog! shld info
                	call diskreset! jz reset$all
                	call reset$37
                	jmp func13$cont
                reset$all:
                
                	; Reset disk system - initialize to disk 0
                	lxi h,0! shld rodsk! shld dlog
                
                	shld rlog! shld tlog
                func13$cont:
                	mvi a,0ffh! sta curdsk
                else
 2183 21FFFFCD5A	lxi h,0ffffh! call reset$37x
                endif
 2189 AF32DAFB  	xra a! sta olddsk ; Note that usrcode remains unchanged
                
                if MPM
                	xra a! call getmemseg ; a = mem seg tbl index
                	ora a! rz
                	inr a! rz
                	call rlradr! lxi b,msegtbl-rlros! dad b
                	add a! add a! mov e,a! mvi d,0! dad d
                	mov h,m! mvi l,80h
                	jmp intrnlsetdma
                else
 218D 21800022D8	lxi h,tbuff! shld dmaad ; dmaad = tbuff
 2193 C3B612    	jmp setdata ; to data dma address
                endif
                
                func14:
                
                if MPM
                	call tmpselect ; seldsk = reg e
                	call rlr! lxi b,diskselect! dad b
                	mov a,m! ani 0fh! rrc! rrc! rrc! rrc
                	mov b,a! lda seldsk! ora b! rrc! rrc! rrc! rrc
                	mov m,a! ret
                else
 2196 CD671E    	call tmpselect ; seldsk = reg e
 2199 3AA42832DA	lda seldsk! sta olddsk! ret
                endif
                
                func15:
                	; Open file
 21A0 CD5411    	call clrmodnum ; Clear the module number
CP/M RMAC ASSEM 1.1	#100	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                if MPM
                	call reselect
                	xra a! sta make$flag
                	call set$sdcnt
                	lxi h,open$file! push h
                	mvi a,0c9h! sta check$fcb4
                	call check$fcb1
                	pop h! lda high$ext! cpi 060h! jnz open$file
                	call home! call set$end$dir
                	jmp open$user$zero
                open$file:
                	call set$sdcnt
                	call reset$chksum$fcb ; Set invalid check sum
                else
 21A3 CD901E    	call reselectx
                endif
                
 21A6 CD2D17    	call check$wild ; Check for wild chars in fcb
                
                if MPM
                
                	call get$atts! ani 1100$0000b ; a = attributes
                	cpi 1100$0000b! jnz att$ok
                	ani 0100$0000b ; Mask off unlock mode
                att$ok:
                	sta high$ext
                	mov b,a! ora a! rar! jnz att$set
                	mvi a,80h
                att$set:
                	sta attributes! mov a,b
                	ani 80h! jnz call$open
                endif
                
 21A9 3AE0FBB7CA	lda usrcode! ora a! jz call$open
 21B0 3EFE3218FD	mvi a,0feh! sta xdcnt+1! inr a! sta search$user0
                
                if MPM
                	sta sdcnt0+1
                endif
                
                call$open:
 21B9 CDDA17CDE7	call open! call openx ; returns if unsuccessful, a = 0
 21BF 21BD28BEC8	lxi h,search$user0! cmp m! rz
 21C4 773A18FDFE	mov m,a! lda xdcnt+1! cpi 0feh! rz
                ;
                ;	file exists under user 0
                ;
                
                if MPM
                	call swap
                endif
                
 21CB CD0A19    	call set$dcnt$dblk
                
                if MPM
CP/M RMAC ASSEM 1.1	#101	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	mvi a,0110$0000b
                else
 21CE 3E80      	mvi a,80h
                endif
                
 21D0 32B528    	sta high$ext
                open$user$zero:
                	; Set fcb user # to zero
 21D3 2ADBFB3600	lhld info! mvi m,0
 21D8 0E0FCDDD14	mvi c,namlen! call searchi! call searchn
 21E0 CDDD17    	call open1 ; Attempt reopen under user zero
 21E3 CDE721    	call openx ; openx returns only if unsuccessful
 21E6 C9        	ret
                openx:
 21E7 CDF812C8  	call end$of$dir! rz
 21EB CD4F107E3C	call getfcba! mov a,m! inr a! jnz openxa
 21F3 1B1B1A77  	dcx d! dcx d! ldax d! mov m,a
                openxa:
                	; open successful
 21F7 E1        	pop h ; Discard return address
                	; Was file opened under user 0 after unsuccessful
                	; attempt to open under user n?
                
                if MPM
                	lda high$ext! cpi 060h! jz openx00 ; yes
                	; Was file opened in locked mode?
                	ora a! jnz openx0 ; no
                	; does user = zero?
                	lhld info! ora m! jnz openx0 ; no
                	; Does file have read/only attribute set?
                	call rotest! jnc openx0 ; no
                	; Does file have system attribute set?
                	inx h! mov a,m! ral! jnc openx0 ; no
                
                	; Force open mode to read/only mode and set user 0 flag
                	; if file opened in locked mode, user = 0, and
                	; file has read/only and system attributes set
                
                openx00:
                
                else
 21F8 3AB52817D2	lda high$ext! ral! jnc openx0
                endif
                
                	; Is file under user 0 a system file ?
                
                if MPM
                	mvi a,20h! sta attributes
                endif
                
 21FF 2ADBFB110A	lhld info! lxi d,10! dad d
 2206 7EE680C212	mov a,m! ani 80h! jnz openx0 ; yes - open successful
                	; open fails
 220C 32B528C3C0	sta high$ext! jmp lret$eq$ff
                openx0:
                
CP/M RMAC ASSEM 1.1	#102	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                if MPM
                	call reset$chksum$fcb
                else
 2212 CD4112    	call set$lsn
                endif
                
                if BANKED
                
                	; Are passwords enabled on drive?
 2215 CD731FE680	call get$dir$mode! ani 80h! jz openx1a ; no
                	; Is this 1st dir fcb?
 221D CD4021C24E	call qdirfcb1! jnz openx0a ; no
                	; Does sfcb exist?
 2223 CD1021B7C2	call get$dtba$8! ora a! jnz openx0a ; no
                	; Is sfcb password mode read or write?
 222A 7EE6C0CA76	mov a,m! ani 0c0h! jz openx1a ; no
                	; Does xfcb exist?
 2230 CD2416    	call xdcnt$eq$dcnt
 2233 CD8320C257	call get$xfcb! jnz openx0b ; yes
                	; no - set sfcb password mode to zero
 2239 CD2B16C8  	call restore$dir$fcb! rz ; (error)
                	; Does sfcb still exist?
 223D CD1021B7C2	call get$dtba$8! ora a! jnz openx1a ; no (error)
                	; sfcb password mode = 0
 2244 77        	mov m,a
                	; update sfcb
 2245 CD1A11CC9A	call nowrite! cz seek$copy
 224B C37622    	jmp openx1a
                openx0a:
 224E CD2416    	call xdcnt$eq$dcnt
                	; Does xfcb exist?
 2251 CD8320CA72	call get$xfcb! jz openx1 ; no
                openx0b:
                	; yes - check password
 2257 CD0220CA72	call cmp$pw! jz openx1
 225D CD851F    	call chk$pw$error
 2260 3AE428E6C0	lda pw$mode! ani 0c0h! jz openx1
 2268 E680C2DF1F	ani 80h! jnz pw$error
 226D 3E8032B628	mvi a,080h! sta xfcb$read$only
                openx1:
 2272 CD2B16C8  	call restore$dir$fcb! rz ; (error)
                openx1a:
 2276 CD4112    	call set$lsn
                
                if MPM
                	call pack$sdcnt
                	; Is this file currently open?
                	mvi b,3! call search$olist! jz openx04
                openx01:
                	; no - is olist full?
                	lhld free$root! mov a,l! ora h! jnz openx03
                	; yes - error
                openx02:
                	mvi a,11! jmp set$aret
                openx03:
                	; Has process exceeded open file maximum?
CP/M RMAC ASSEM 1.1	#103	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	call count$opens! sub m! jc openx035
                	; yes - error
                openx034:
                	mvi a,10! jmp set$aret
                openx035:
                	; Create new olist element
                	call create$olist$item
                	jmp openx08
                openx04:
                	; Do file attributes match?
                	inx h! inx h
                	lda attributes! ora m! cmp m! jnz openx06
                	; yes - is open mode locked?
                	ani 80h! jnz openx07
                	; no - has this file been opened by this process?
                	lhld prv$pos! shld cur$pos
                	mvi b,5! call searchn$list! jnz openx01
                openx05:
                	; yes - increment open file count
                	lxi d,8! dad d! inr m! jnz openx08
                	; count overflow
                	inx h! inr m! jmp openx08
                openx06:
                	; error - file opened by another process in imcompatible mode
                	mvi a,5! jmp set$aret
                openx07:
                	; Does this olist item belong to this process?
                	dcx h! dcx h! push h
                	call compare$pds
                	pop h! jnz openx06 ; no - error
                	jmp openx05 ; yes
                openx08:; Wopen ok
                	; Was file opened in unlocked mode?
                	lda attributes! ani 40h! jz openx09 ; no
                	; yes - return .olist$item in ranrec field of fcb
                	call get$rra
                	lxi d,cur$pos! mvi c,2! call move
                openx09:
                	call set$fcb$cks$flag
                	lda make$flag! ora a! rnz
                endif
                endif
                
 2279 0E40      	mvi c,0100$0000b
                openx2:
 227B CD3221CCDD	call qstamp! cz stamp1
 2281 1190FBC308	lxi d,olog! jmp set$cdisk
                
                func16:
                	; Close file
 2287 CD9A1E    	call reselect
                
                if MPM
                	call get$atts! sta attributes
                	lxi h,close00! push h
                	mvi a,0c9h! sta check$fcb4
CP/M RMAC ASSEM 1.1	#104	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	call check$fcb1! pop h
                	call set$sdcnt
                	call getmodnum! ani 80h! jnz close01
                	call close! jmp close02
                close00:
                	mvi a,6! jmp set$aret
                close01:
                	mvi a,0ffh! sta dont$close! call close1
                close02:
                else
 228A CD4112    	call set$lsn
 228D CDD810CD3D	call chek$fcb! call close
                endif
                
 2293 3A9F0D3CC8	lda lret! inr a! rz
                
 2298 C31A25    	jmp flush ; Flush buffers
                
                if MPM
                	lda attributes! ral! rc
                	call pack$sdcnt
                	; Find olist item for this process & file
                	mvi b,5! call search$olist! jnz close03
                	; Decrement open count
                	push h! lxi d,8! dad d
                	mov a,m! sui 1! mov m,a! inx h
                	mov a,m! sbi 0! mov m,a! dcx h
                	; Is open count = 0ffffh
                	call test$ffff! pop h! jnz close03
                	; yes - remove file's olist entry
                	shld file$id! call delete$item
                	call reset$chksum$fcb
                	; if unlocked file, remove file's locktbl entries
                	call test$unlocked! jz close03
                	lhld file$id! call remove$locks
                close03:
                	ret
                
                endif
                
                func17:
                	; Search for first occurrence of a file
 229B EBAF      	xchg! xra a
                csearch:
 229D F5        	push a
 229E 7EFE3FC2AF	mov a,m! cpi '?'! jnz csearch1 ; no reselect if ?
 22A4 CD6B1ECDE9	call curselect! call noselect0! mvi c,0! jmp csearch3
                csearch1:
 22AF CD3F107EFE	call getexta! mov a,m! cpi '?'! jz csearch2
 22B8 CD5A11CD54	call clr$ext! call clrmodnum
                csearch2:
 22BE CD901E    	call reselectx
 22C1 0E0F      	mvi c,namlen
                csearch3:
 22C3 F1F5CADA22	pop a! push a! jz csearch4
                	; dcnt = dcnt & 0fch
CP/M RMAC ASSEM 1.1	#105	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 22C8 2AE1FBE53E	lhld dcnt! push h! mvi a,0fch
 22CE A56F22E1FB	ana l! mov l,a! shld dcnt
 22D3 CD9212    	call rd$dir
 22D6 E122E1FB  	pop h! shld dcnt
                csearch4:
 22DA F1        	pop a
 22DB 21C312    	lxi h,dir$to$user
 22DE E5        	push h
 22DF CAF714    	jz search
 22E2 3AE5FB4FCD	lda searchl! mov c,a! call searchi! jmp searchn
                
                func18:
                	; Search for next occurrence of a file name
                
                if BANKED
 22EC EB22A028  	xchg! shld searcha
                else
                	lhld searcha! shld info
                endif
                
 22F0 F601C39D22	ori 1! jmp csearch
                
                func19:
                	; Delete a file
                ;;;	call reselectx	;[JCE] DRI Patch 13
 22F5 CD7D2D    	call patch$1e38
 22F8 C33616    	jmp delete
                
                func20:
                	; Read a file
 22FB CD9A1E    	call reselect
 22FE CDCE10    	call check$fcb
 2301 C3F519    	jmp seqdiskread
                
                func21:
                	; Write a file
 2304 CD9A1E    	call reselect
 2307 CDCE10    	call check$fcb
 230A C3631B    	jmp seqdiskwrite
                
                func22:
                	; Make a file
                
                if BANKED
 230D CD181032B3	call get$atts! sta attributes
                endif
                
 2313 CD5A11    	call clr$ext
 2316 CD5411    	call clrmodnum ; fcb mod = 0
 2319 CD901E    	call reselectx
                
                if MPM
                	call reset$chksum$fcb
                endif
                
 231C CD2D17    	call check$wild
CP/M RMAC ASSEM 1.1	#106	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 231F CD0319    	call set$xdcnt ; Reset xdcnt for make
                
                if MPM
                	call set$sdcnt
                endif
                
 2322 CDDA17    	call open ; Verify file does not already exist
                
                if MPM
                	call reset$chksum$fcb
                endif
                
                	; Does dir fcb for fcb exist?
                	; ora a required to reset carry
 2325 CDF812B7CA	call end$of$dir! ora a! jz makea0 ; no
                	; Is dir$ext < fcb(ext)?
 232C CD9714BED2	call get$dir$ext! cmp m! jnc file$exists ; no
                makea0:
 2333 F5        	push a ; carry set if dir fcb already exists
                
                if MPM
                	lda attributes! ani 80h! rrc! jnz makex00
                	mvi a,80h
                makex00:
                	sta make$flag
                	lda sdcnt+1! inr a! jz makex01
                	call pack$sdcnt
                	mvi b,3! call search$olist! jz make$x02
                makex01:
                	lhld free$root! mov a,l! ora h! jz openx02
                	jmp makex03
                makex02:
                	inx h! inx h
                	lda makeflag! ana m! jz openx06
                	dcx h! dcx h! call compare$pds! jz makex03
                	lda makeflag! ral! jc openx06
                makex03:
                
                endif
                
                if BANKED
                	; Is fcb 1st fcb for file?
 2334 CD4021CA59	call qdirfcb1! jz makex04 ; yes
                	; no - does dir lbl require passwords?
 233A CD731FE680	call get$dir$mode! ani 80h! jz makex04
                	; no - does xfcb exist with mode 1 or 2 password?
 2342 CD8320CA59	call get$xfcb! jz makex04
                	; yes - check password
 2348 CDD720CA59	call chk$xfcb$password1! jz makex04
                	; Verify password error
 234E CD851F    	call chk$pw$error
 2351 3AE428E6C0	lda pw$mode! ani 0c0h! jnz pw$error
                makex04:
                
                endif
                
CP/M RMAC ASSEM 1.1	#107	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	; carry on stack indicates a make not required because
                	; of extent folding
 2359 F1D41619  	pop a! cnc make
                
                if MPM
                	call reset$chksum$fcb
                endif
                
                	; end$of$dir call either applies to above make or open call
 235D CDF812C8  	call end$of$dir! rz ; Return if make unsuccessful
                
                if not MPM
 2361 CD4112    	call set$lsn
                endif
                
                if BANKED
                
                	; Are passwords activated by dir lbl?
 2364 CD731FE680	call get$dir$mode! ani 80h! jz make3a
                	; Did user set password attribute?
 236C 3AB328E640	lda attributes! ani 40h! jz make3a
                	; Is fcb file's 1st logical fcb?
 2374 CD4021C2D2	call qdirfcb1! jnz make3a
                	; yes - does xfcb already exist for file
 237A CD2416    	call xdcnt$eq$dcnt
 237D CD8320C297	call get$xfcb! jnz make00 ; yes
                	; Attempt to make xfcb
 2383 3EFF3215FD	mvi a,0ffh! sta make$xfcb! call make! jnz make00
                	; xfcb make failed - delete fcb that was created above
 238E CDF014    	call search$namlen
 2391 CD8716C3C0	call delete10! jmp lret$eq$ff ; Return with a = 0ffh
                
                make00:
 2397 CDB120    	call init$xfcb ; Initialize xfcb
                	; Get password mode from dma + 8
 239A EB2A19FD01	xchg! lhld xdmaad! lxi b,8! dad b! xchg
 23A3 1AE6E0C2AB	ldax d! ani 0e0h! jnz make2
 23A9 3E80      	mvi a,080h ; default password mode is read protect
                make2:
 23AB 32E428    	sta pw$mode
                	; Set xfcb password mode field
 23AE F5CD9920F1	push a! call getxfcb1! pop a! mov m,a
                	; Set xfcb password and password checksum
                	; Fix hash table and write xfcb
 23B4 CD422070CD	call set$pw! mov m,b! call sdl3
                	; Return to fcb
 23BB CD2B16C8  	call restore$dir$fcb! rz
                	; Does sfcb exist?
 23BF 0E08CD1221	mvi c,8! call getdtba! ora a! jnz make3a ; no
                	; Place password mode in sfcb if sfcb exists
 23C8 3AE42877CD	lda pw$mode! mov m,a! call seek$copy
 23CF CD4112    	call set$lsn
                endif
                
                make3a:
 23D2 0E50      	mvi c,0101$0000b
CP/M RMAC ASSEM 1.1	#108	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                if MPM
                	call openx2
                	lda make$flag! sta attributes
                	ani 40h! ral! sta high$ext
                	lda sdcnt+1! inr a! jnz makexx02
                	call sdcnt$eq$xdcnt! call pack$sdcnt
                	jmp openx03
                makexx02:
                	call fix$olist$item! jmp openx1
                	jmp set$fcb$cks$flag
                else
 23D4 CD7B22    	call openx2
 23D7 0E20CD3221	mvi c,0010$0000b! call qstamp! rnz
 23DD CDE220C357	call stamp2! jmp set$filewf
                endif
                
                file$exists:
 23E3 3E08      	mvi a,8
                set$aret:
 23E5 4F32A00DCD	mov c,a! sta aret+1! call lret$eq$ff
                
                if MPM
                	call test$error$mode! jnz goback
                else
 23EC C3B80D    	jmp goerr1
                endif
                
                if MPM
                	mov a,c! sui 3
                	mov l,a! mvi h,0! dad h
                	lxi d,xerr$list! dad d
                	mov e,m! inx h! mov d,m
                	xchg! jmp report$err
                endif
                
                func23:
                	; Rename a file
                ;;;	call reselectx	;[JCE] DRI Patch 13
 23EF CD7D2D    	call patch$1e38
 23F2 C35217    	jmp rename
                
                func24:
                	; Return the login vector
 23F5 2A6528C329	lhld dlog! jmp sthl$ret
                
                func25:
                	; Return selected disk number
 23FB 3AA428C372	lda seldsk! jmp sta$ret
                
                func26:
                
                if MPM
                	; Save dma address in process descriptor
                	lhld info
                intrnlsetdma:
CP/M RMAC ASSEM 1.1	#109	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	xchg
                	call rlr! lxi b,disksetdma! dad b
                	mov m,e! inx h! mov m,d
                endif
                
                	; Set the subsequent dma address to info
 2401 EB22D8FB  	xchg! shld dmaad ; dmaad = info
 2405 C3B612    	jmp setdata ; to data dma address
                
                func27:
                	; Return the login vector address
 2408 CD6B1E    	call curselect
 240B 2A7728C329	lhld alloca! jmp sthl$ret
                
                if MPM
                
                func28:
                	; Write protect current disk
                	; first check for open files on disk
                	mvi a,0ffh! sta set$ro$flag
                	lda seldsk! mov c,a! lxi h,0001h
                	call hlrotl! call intrnldiskreset
                	jmp set$ro
                else
                
 11D3 =         func28: equ	set$ro ; Write protect current disk
                
                endif
                
                func29:
                	; Return r/o bit vector
 2411 2A6328C329	lhld rodsk! jmp sthl$ret
                
                func30:
                	; Set file indicators
 2417 CD2D17    	call check$wild
                ;;;	call reselectx	;[JCE] DRI Patch 13
 241A CD7D2D    	call patch$1e38
 241D CDA417    	call indicators
 2420 C38014    	jmp copy$dirloc ; lret=dirloc
                
                func31:
                	; Return address of disk parameter block
 2423 CD6B1E    	call curselect
 2426 2A7328    	lhld dpbaddr
                sthl$ret:
 2429 229F0DC9  	shld aret! ret
                
                func32:
                	; Set user code
 242D 3A9E28FEFF	lda linfo! cpi 0ffh! jnz setusrcode
                		; Interrogate user code instead
 2435 3AE0FBC372		lda usrcode! jmp sta$ret ; lret=usrcode
                	setusrcode:
 243B E60F32E0FB		ani 0fh! sta usrcode
                
CP/M RMAC ASSEM 1.1	#110	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                if MPM
                		push a
                		call rlr! lxi b,diskselect! dad b
                		pop b
                		mov a,m! ani 0f0h! ora b! mov m,a
                endif
                
 2440 C9        		ret
                
                func33:
                	; Random disk read operation
 2441 CD9A1E    	call reselect
 2444 CDCE10    	call check$fcb
 2447 C3B91D    	jmp randiskread ; to perform the disk read
                
                func34:
                	; Random disk write operation
 244A CD9A1E    	call reselect
 244D CDCE10    	call check$fcb
 2450 C3C21D    	jmp randiskwrite ; to perform the disk write
                
                func35:
                	; Return file size (0-262,144)
 2453 CD9A1E    	call reselect
 2456 C3131E    	jmp getfilesize
                
 1E40 =         func36	equ setrandom ; Set random record
                
                func37:
                	; Drive reset
                
                if MPM
                	call diskreset
                reset$37:
                	lhld info
                else
 2459 EB        	xchg
                endif
                
                reset$37x:
 245A 7D2F5F7C2F	mov a,l! cma! mov e,a! mov a,h! cma
 245F 2A6528A457	lhld dlog! ana h! mov d,a! mov a,l! ana e
 2466 5F2A6328EB	mov e,a! lhld rodsk! xchg! shld dlog
                
                if MPM
                	push h! call hl$eq$hl$and$de
                else
 246E 7DA36F    	mov a,l! ana e! mov l,a
 2471 7CA267    	mov a,h! ana d! mov h,a
                endif
                
 2474 226328    	shld rodsk
                
                if MPM
                	pop h! xchg! lhld rlog! call hl$eq$hl$and$de! shld rlog
                endif
CP/M RMAC ASSEM 1.1	#111	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                	; Force select call in next curselect
 2477 3EFF32A928	mvi a,0ffh! sta curdsk! ret
                
                if MPM
                
                func38:
                	; Access drive
                
                	lxi h,packed$dcnt! mvi a,0ffh
                	mov m,a! inx h! mov m,a! inx h! mov m,a
                	xra a! xchg! lxi b,16
                acc$drv0:
                	dad h! adc b! dcr c! jnz acc$drv0
                	ora a! rz
                	sta mult$cnt! dcr a! push a
                	call acc$drv02
                	pop a! jmp openx02 ; insufficient free lock list items
                acc$drv02:
                	call check$free! pop h ; Discard return addr, free space exists
                	call count$opens! pop b! add b! jc openx034
                	sub m! jnc openx034 ; openmax exceeded
                	lhld info! lda curdsk! push a! mvi a,16
                acc$drv1:
                	dcr a! dad h! jc acc$drv2
                acc$drv15:
                	ora a! jnz acc$drv1
                	pop a! sta curdsk! ret
                acc$drv2:
                	push a! push h! sta curdsk
                	call create$olist$item
                	pop h! pop a! jmp acc$drv15
                
                func39:
                	; Free drive
                	lhld open$root! mov a,h! ora l! rz
                	xra a! sta incr$pdcnt! inr a! sta free$mode
                	lhld info! mov a,h! cmp l! jnz free$drv1
                	inr a! jnz free$drv1
                	sta free$mode! call free$files! jmp free$drv3
                free$drv1:
                	lda curdsk! push a! mvi a,16
                free$drv2:
                	dcr a! dad h! jc free$drv4
                free$drv25:
                	ora a! jnz free$drv2
                	pop a! sta curdsk
                free$drv3:
                	lda incr$pdcnt! ora a! rz
                	lda pdcnt! jmp chk$olist1
                free$drv4:
                	push a! push h! sta curdsk
                	call free$files
                	pop h! pop a! jmp free$drv25
                else
                
CP/M RMAC ASSEM 1.1	#112	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 0A75 =         func38	equ	func$ret
 0A75 =         func39	equ	func$ret
                
                endif
                
 244A =         func40	equ	func34		; Write random with zero fill
                
                if MPM
                
                func41	equ	func$ret	; Test & write
                func42:				; Record lock
                	mvi a,0ffh! sta lock$unlock! jmp lock
                func43:				; Record unlock
                	xra a! sta lock$unlock! jmp lock
                
                else
                
 0A75 =         func42	equ	func$ret	; Record lock
 0A75 =         func43	equ	func$ret	; Record unlock
                
                endif
                
                func44:				; Set multi-sector count
 247D 7BB7CAC015	mov a,e! ora a! jz lret$eq$ff
 2482 FE81D2C015	cpi 129! jnc lret$eq$ff
 2487 32E6FB    	sta mult$cnt
                
                if MPM
                	mov d,a
                	call rlr! lxi b,mult$cnt$off! dad b
                	mov m,d
                endif
                
 248A C9        	ret
                
                func45:				; Set bdos error mode
                
                if MPM
                	call rlr! lxi b,pname+4! dad b
                	call set$pflag
                	mov m,a! inx h
                	call set$pflag
                	mov m,a! ret
                
                set$pflag:
                	mov a,m! ani 7fh! inr e! rnz
                	ori 80h! ret
                else
 248B 7B32E7FB  	mov a,e! sta error$mode
                endif
                
 248F C9        	ret
                
                func46:
                	; Get free space
                	; Perform temporary select of specified drive
CP/M RMAC ASSEM 1.1	#113	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 2490 CD671E    	call tmpselect
 2493 2A7728EB  	lhld alloca! xchg ; de = alloc vector addr
 2497 CDDE13    	call get$nalbs ; Get # alloc blocks
                	; hl = # of allocation vector bytes
                	; Count # of true bits in allocation vector
 249A 010000    	lxi b,0 ; bc = true bit accumulator
 249D 1A        gsp1:	ldax d
 249E B7CAAA24  gsp2:	ora a! jz gsp4
 24A2 1FD2A224  gsp3:	rar! jnc gsp3
 24A6 03C39E24  	inx b! jmp gsp2
 24AA 132B      gsp4:	inx d! dcx h
 24AC 7DB4C29D24	mov a,l! ora h! jnz gsp1
                	; hl = 0 when allocation vector processed
                	; Compute maxall + 1 - bc
 24B1 2A852823  	lhld maxall! inx h
 24B5 7D916F    	mov a,l! sub c! mov l,a
 24B8 7C9867    	mov a,h! sbb b! mov h,a
                	; hl = # of available blocks on drive
 24BB 3A82284FAF	lda blkshf! mov c,a! xra a
 24C0 CDF60D    	call shl3bv
                	; ahl = # of available sectors on drive
                	; Store ahl in beginning of current dma
 24C3 EB2A19FD73	xchg! lhld xdmaad! mov m,e! inx h
 24C9 722377C9  	mov m,d! inx h! mov m,a! ret
                
                if MPM
                
                func47	equ	func$ret
                
                else
                
                func47:				; Chain to program
 24CD 21B3FB7EF6	lxi h,ccp$flgs! mov a,m! ori 80h! mov m,a
 24D4 1CC22F03  	inr e! jnz rebootx1
 24D8 7EF64077  	mov a,m! ori 40h! mov m,a
 24DC C32F03    	jmp rebootx1
                endif
                
                func48:				; Flush buffers
 24DF CD2F1F    	call check$all$media
 24E2 CD48FF    	call flushf
 24E5 CDA50E    	call diocomp
                flush0:				; Function 98 entry point
 24E8 2A65283E10	lhld dlog! mvi a,16
                flush1:
 24ED 3D29D21525	dcr a! dad h! jnc flush5
 24F2 F5E55FCD67	push a! push h! mov e,a! call tmpselect ; seldsk = e
 24F8 3ADFFBFE30	lda fx! cpi 48! jz flush3
                	; Function 98 - reset allocation
                	; Copy 2nd ALV over 1st ALV
 2500 CD7713    	call copy$alv
                if BANKED
 2503 C33A2D    	jmp patch$2d3a	;[JCE] DRI Patch 13
                else
                	jmp flush35
                endif
CP/M RMAC ASSEM 1.1	#114	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                flush3:
 2506 CD2025    	call flushx
                	; if e = 0ffh then discard buffers after possible flush
 2509 3A9E283CC2	lda linfo! inr a! jnz flush4
                flush35:
 2510 CD5212    	call discard$data
                flush4:
 2513 E1F1      	pop h! pop a
                flush5:
 2515 B7C2ED24  	ora a! jnz flush1
 2519 C9        	ret
                
                flush:
 251A CD48FF    	call flushf
 251D CDA50E    	call diocomp
                flushx:
 2520 3A9028B7C8	lda phymsk! ora a! rz
 2525 3E04C3FF28	mvi a,4! jmp deblock$dta
                
                if MPM
                
                func49	equ	func$ret
                
                else
                
                func49: ; Get/Set system control block
                
 252A EB7EFE63D0	xchg! mov a,m! cpi 99! rnc
 252F EB219CFB85	xchg! lxi h,scb! add l! mov l,a
 2535 EB237EFEFE	xchg! inx h! mov a,m! cpi 0feh! jnc func49$set
 253D EB5E2356EB	xchg! mov e,m! inx h! mov d,m! xchg
 2542 C32924    	jmp sthl$ret
                func49$set:
 2545 47237E1204	mov b,a! inx h! mov a,m! stax d! inr b! rz
 254B 23137E12C9	inx h! inx d! mov a,m! stax d! ret
                endif
                
                if MPM
                
                func50	equ	func$ret
                
                else
                
                func50:				; Direct bios call
                	; de -> function (1 byte)
                	;	a  value (1 byte)
                	;	bc value (2 bytes)
                	;	de value (2 bytes)
                	;	hl value (2 bytes)
                
 2550 21B025E5  	lxi h,func50$ret! push h
 2554 EB        	xchg
                
                if BANKED
 2555 7EFE1BC8  	mov a,m! cpi 27! rz
CP/M RMAC ASSEM 1.1	#115	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 2559 FE0CC26225	cpi 12! jnz dir$bios1
 255E 118B25D5  	lxi d,dir$bios3! push d
                dir$bios1:
 2562 FE09C26B25	cpi 9! jnz dir$bios2
 2567 119025D5  	lxi d,dirbios4! push d
                dir$bios2:
                
                endif
                
 256B E52323    	push h! inx h! inx h
 256E 4E234623  	mov c,m! inx h! mov b,m! inx h
 2572 5E235623  	mov e,m! inx h! mov d,m! inx h
 2576 7E23666F  	mov a,m! inx h! mov h,m! mov l,a
 257A E37EE56F87	xthl! mov a,m! push h! mov l,a! add a! add l
                
 2580 2100FF    	lxi h,bios
                
 2583 856FE3    	add l! mov l,a! xthl
 2586 237EE1E3C9	inx h! mov a,m! pop h! xthl! ret
                
                if BANKED
                
                dir$bios3:
 258B 3E01C354FF	mvi a,1! jmp setbnkf
                
                dir$bios4:
 2590 7DB4C8    	mov a,l! ora h! rz
 2593 EB210A0019	xchg! lxi h,10! dad d! mvi m,0 ; Zero login sequence #
 259A 2AF9FBCD7F	lhld common$base! call subdh! xchg! rnc
                	; Copy DPH to common memory
 25A2 EB2ADBFB23	xchg! lhld info! inx h! push h! lxi b,25
 25AB CD4BFFE1C9	call movef! pop h! ret
                endif
                
                func50$ret:
                
                if BANKED
 25B0 229F0D47  	shld aret! mov b,a
 25B4 2ADBFB7E  	lhld info! mov a,m
 25B8 FE09C8    	cpi 9! rz
 25BB FE10C8    	cpi 16! rz
 25BE FE14C8    	cpi 20! rz
 25C1 FE16C8    	cpi 22! rz
 25C4 78C3720A  	mov a,b! jmp sta$ret
                else
                	xchg! lhld entsp! sphl! xchg! ret
                endif
                endif
                
 24E8 =         func98	equ	flush0			; Reset Allocation
                
                func99:					; Truncate file
 25C8 CD901E    	call reselectx
 25CB CD2D17    	call check$wild
                
                if BANKED
CP/M RMAC ASSEM 1.1	#116	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 25CE CD781FC485	call chk$password! cnz chk$pw$error
                endif
                
 25D4 0EFFCDE41C	mvi c,true! call rseek! jnz lret$eq$ff
                	; compute dir$fcb size
 25DC CD4011110F	call getdptra! lxi d,reccnt
 25E2 CDCB1D    	call compute$rr ; cba = fcb size
                	; Is random rec # >= dir$fcb size
 25E5 CD3710CDFE	call get$rra! call compare$rr
 25EB DAC015    	jc lret$eq$ff ; yes ( > )
 25EE B2CAC015  	ora d! jz lret$eq$ff  ; yes ( = )
                	; Perform truncate
 25F2 CD2811    	call check$rodir ; may be r/o file
 25F5 CD9A12    	call wrdir ; verify BIOS can write to disk
 25F8 CD5321    	call update$stamp ; Set update stamp
 25FB CDF514    	call search$extnum
                trunc1:
 25FE CA8014    	jz copy$dirloc
                	; is dirfcb < fcb?
 2601 CD7126DA1C	call compare$mod$ext! jc trunc2 ; yes
                	; remove dirfcb blocks from allocation vector
 2607 F50E00CD8B	push a! mvi c,0! call scandm$ab! pop a
                	; is dirfcb = fcb?
 260E CA2226    	jz trunc3 ; yes
                	; delete dirfcb
 2611 CD401136E5	call getdptra! mvi m,empty! call fix$hash
                trunc15:
 2619 CD9A12    	call wrdir
                trunc2:
 261C CD0315    	call searchn
 261F C3FE25    	jmp trunc1
                trunc3:
 2622 CD5810CDA4	call getfcb! call dm$position
 2628 CD8B26    	call zero$dm
                	; fcb(extnum) = dir$ext after blocks removed
 262B CD9714BE77	call get$dir$ext! cmp m! mov m,a! push a
                	; fcb(rc) = fcb(cr) + 1
 2631 CD4F107E3C	call getfcba! mov a,m! inr a! stax d
                	; rc = 0 or 128 if dir$ext < fcb(extnum)
 2637 F1EBC41518	pop a! xchg! cnz set$rc3
                	; rc = 0 if no blocks remain in fcb
 263C 3A9F28B7CC	lda dminx! ora a! cz set$rc3
 2643 010B00CD67	lxi b,11! call get$fcb$adds! xchg
                	; reset archive (t3') attribute bit
 264A 7EE67F7723	mov a,m! ani 7fh! mov m,a! inx h! inx d
                	; dirfcb(extnum) = fcb(extnum)
 2650 1A77      	ldax d! mov m,a
                	; advance to .fcb(reccnt) & .dirfcb(reccnt)
 2652 2336002323	inx h! mvi m,0! inx h! inx h
 2657 131313    	inx d! inx d! inx d
                	; dirfcb_rc+dskmap = fcb_rc+dskmap
 265A 0E11CD290E	mvi c,17! call move
                	; restore non-erased blkidxs in allocation vector
 265F 0E01CD8B13	mvi c,1! call scandm$ab
 2664 C31926    	jmp trunc15
                
CP/M RMAC ASSEM 1.1	#117	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                get$fcb$adds:
 2667 CD401109EB	call getdptra! dad b! xchg
 266C 2ADBFB09C9	lhld info! dad b! ret
                
                compare$mod$ext:
 2671 010E00CD67	lxi b,modnum! call get$fcb$adds
 2677 7EE63F47  	mov a,m! ani 3fh! mov b,a
                	; compare dirfcb(modnum) to fcb(modnum)
 267B 1AB8C0    	ldax d! cmp b! rnz ; dirfcb(modnum) ~= fcb(modnum)
 267E 2B2B1B1B  	dcx h! dcx h! dcx d! dcx d
                	; compare dirfcb(extnum) to fcb(extnum)
 2682 1A4ECD8614	ldax d! mov c,m! call compext! rz ; dirfcb(extnum) = fcb(extnum)
 2688 1ABEC9    	ldax d! cmp m! ret
                
                zero$dm:
 268B 3C21A32834	inr a! lxi h,single! inr m! jz zero$dm1
 2693 87        	add a
                zero$dm1:
 2694 35        	dcr m
 2695 CDC40F4F06	call getdma! mov c,a! mvi b,0! dad b
 269C 3E10      	mvi a,16
                zero$dm2:
 269E B9C8      	cmp c! rz
 26A0 70230CC39E	mov m,b! inx h! inr c! jmp zero$dm2
                
                if BANKED
                
                func100:			; Set directory label
                	; de -> .fcb
                	;	drive location
                	;	name & type fields user's discretion
                	;	extent field definition
                	;	bit 1 (80h): enable passwords on drive
                	;	bit 2 (40h): enable file access
                	;	bit 3 (20h): enable file update stamping
                	;	bit 4 (10h): enable file create stamping
                	;	bit 8 (01h): assign new password to dir lbl
 26A6 CD901E    	call reselectx
 26A9 2ADBFB3621	lhld info! mvi m,21h! mvi c,1
 26B0 CDF714C2BF	call search! jnz sdl0
 26B6 CD3F107EE6	call getexta! mov a,m! ani 0111$0000b! jnz lret$eq$ff
                sdl0:
                	; Does dir lbl exist on drive?
 26BF 2ADBFB3620	lhld info! mvi m,20h! mvi c,1
 26C6 CD0319CDF7	call set$xdcnt! call search! jnz sdl1
                	; no - make one
 26CF 3EFF3215FD	mvi a,0ffh! sta make$xfcb
 26D4 CD1619C8  	call make! rz ; no dir space
 26D8 CDB120    	call init$xfcb
 26DB 011800CD05	lxi b,24! call stamp5! call stamp1
                sdl1:
                	; Update date & time stamp
 26E4 011C00CD05	lxi b,28! call stamp5! call stamp2
                	; Verify password - new dir lbl falls through
 26ED CDD420C2DF	call chk$xfcb$password! jnz pw$error
 26F3 010000CDB7	lxi b,0! call init$xfcb0
CP/M RMAC ASSEM 1.1	#118	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	; Set dir lbl dta in extent field
 26F9 1AF60177  	ldax d! ori 1h! mov m,a
                	; Low bit of dir lbl data set to indicate dir lbl exists
                	; Update drive's dir lbl vector element
 26FD E52A6F2877	push h! lhld drvlbla! mov m,a! pop h
                sdl2:
                	; Assign new password to dir lbl or xfcb?
 2703 1AE601CA19	ldax d! ani 1! jz sdl3
                	; yes - new password field is in 2nd 8 bytes of dma
 2709 110800CDA7	lxi d,8! call adjust$dmaad
 270F CD422070  	call set$pw! mov m,b
 2713 11F8FFCDA7	lxi d,-8! call adjust$dmaad
                sdl3:
 2719 CDC82C    	call fix$hash
 271C C39A12    	jmp seek$copy
                else
                
                func100 equ	lret$eq$ff
                func103 equ	lret$eq$ff
                
                endif
                
                func101:
                	; Return directory label data
                	; Perform temporary select of specified drive
 271F CD671E    	call tmpselect
 2722 CD731FC372	call get$dir$mode! jmp sta$ret
                
                func102:
                	; Read file xfcb
 2728 CD901E    	call reselectx
 272B CD2D17    	call check$wild
 272E CD9C10    	call zero$ext$mod
 2731 CDF014C8  	call search$namlen! rz
 2735 CDC40F0108	call getdma! lxi b,8! call zero
 273E E50E00CD12	push h! mvi c,0! call get$dtba! ora a! jnz rxfcb2
 2748 D1EB0E08  	pop d! xchg! mvi c,8
                
                if BANKED
 274C CD290E1AC3	call move! ldax d! jmp rxfcb3
                else
                	jmp move
                endif
                
                rxfcb2:
 2753 E1010800  	pop h! lxi b,8
                
                if BANKED
 2757 CDA410CD83	call zero! call get$xfcb! rz
 275E 7E        	mov a,m
                rxfcb3:
 275F CD3F1077C9	call getexta! mov m,a! ret
                else
                	jmp zero
                endif
                
CP/M RMAC ASSEM 1.1	#119	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                if BANKED
                
                func103:
                	; Write or update file xfcb
 2764 CD901E    	call reselectx
                	; Are passwords enabled in directory label?
 2767 CD731F17D2	call get$dir$mode! ral! jnc lret$eq$ff ; no
 276E CD2D17    	call check$wild
                	; Save .fcb(ext) & ext
 2771 CD3F1046E5	call getexta! mov b,m! push h! push b
                	; Set extent & mod to zero
 2777 CD9C10    	call zero$ext$mod
                	; Does file's 1st fcb exist in directory?
 277A CDF014    	call search$namlen
                	; Restore extent
 277D C1E170C8  	pop b! pop h! mov m,b! rz ; no
 2781 CD0319    	call set$xdcnt
                	; Does sfcb exist?
 2784 CD1021B7CA	call get$dtba$8! ora a! jz wxfcb5 ; yes
                	; No - Does xfcb exist?
 278B CD8320C2A1	call get$xfcb! jnz wxfcb1 ; yes
                wxfcb0:
                	; no - does file exist in directory?
 2791 3EFF3215FD	mvi a,0ffh! sta make$xfcb
 2796 CDF514C8  	call search$extnum! rz
                	; yes - attempt to make xfcb for file
 279A CD1619C8  	call make! rz ; no dir space
                	; Initialize xfcb
 279E CDB120    	call init$xfcb
                wxfcb1:
                	; Verify password - new xfcb falls through
 27A1 CDD420C2DF	call chk$xfcb$password! jnz pw$error
                	; Set xfcb options data
 27A7 E5CD3F10D1	push h! call getexta! pop d! xchg
 27AD 7EB7C2BE27	mov a,m! ora a! jnz wxfcb2
 27B2 1AE601C2BE	ldax d! ani 1! jnz wxfcb2
 27B8 CD1927C3CA	call sdl3! jmp wxfcb4
                wxfcb2:
 27BE 1AE6E0C2C6	ldax d! ani 0e0h! jnz wxfcb3
 27C4 3E80      	mvi a,80h
                wxfcb3:
 27C6 77CD0327  	mov m,a! call sdl2
                wxfcb4:
 27CA CD99203D32	call get$xfcb1! dcr a! sta pw$mode
 27D1 CD9C10    	call zero$ext$mod
 27D4 CDF014C8  	call search$namlen! rz
 27D8 CD1021B7C0	call get$dtba$8! ora a! rnz
 27DD 3AE42877C3	lda pw$mode! mov m,a! jmp seek$copy
                wxfcb5:
                	; Take sfcb's password mode over xfcb's mode
 27E4 7EF5      	mov a,m! push a
 27E6 CD8320    	call get$xfcb
                	; does xfcb exist?
 27E9 C1CA9127  	pop b! jz wxfcb0 ; no
                	; Set xfcb's password mode to sfcb's mode
 27ED 70C3A127  	mov m,b! jmp wxfcb1
CP/M RMAC ASSEM 1.1	#120	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                endif
                
                func104:			; Set current date and time
                
                if MPM
                	call get$stamp$add
                else
 27F1 21F4FB    	lxi h,stamp
                endif
 27F4 CD0E28    	call copy$stamp
 27F7 36000EFFC3	mvi m,0! mvi c,0ffh! jmp timef
                
                func105:			; Get current date and time
                
                
                
                if MPM
                	call get$stamp$add
                else
 27FE 0E00CD4EFF	mvi c,0! call timef
 2803 21F4FB    	lxi h,stamp
                endif
                
 2806 EB        	xchg
 2807 CD0E28    	call copy$stamp
 280A 1AC3720A  	ldax d! jmp sta$ret
                
                copy$stamp:
 280E 0E04C3290E	mvi c,4! jmp move ; ret
                
                if MPM
                
                get$stamp$add:
                	call rlradr! lxi b,-5! dad b
                	ret
                endif
                
                if BANKED
                
                func106:			; Set default password
                
                if MPM
                	call get$df$pwa! inr a! rz
                	lxi b,7! dad b
                else
 2813 21EE28    	lxi h,df$password+7
                endif
 2816 EB010800E5	xchg! lxi b,8! push h
 281B C34E20    	jmp set$pw0
                else
                
                func106 equ	func$ret
                
                endif
                
CP/M RMAC ASSEM 1.1	#121	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                func107:			; Return serial number
                
                if MPM
                	lhld sysdat! mvi l,181
                else
 281E 210000    	lxi h,serial
                endif
                
 2821 EB0E06C329	xchg! mvi c,6! jmp move
                
                func108:			; Get/Set program return code
                
                	; Is de = 0ffffh?
 2827 7AA33C    	mov a,d! ana e! inr a
 282A 2AACFBCA29	lhld clp$errcde! jz sthl$ret ; yes - return return code
 2830 EB22ACFBC9	xchg! shld clp$errcde! ret ; no - set return code
                
                goback0:
 2835 21FFFF229F	lxi h,0ffffh! shld aret
                goback:
                	; Arrive here at end of processing to return to user
 283B 3ADDFBB7CA	lda resel! ora a! jz retmon
                
                if MPM
                		lda comp$fcb$cks! ora a! cnz set$chksum$fcb
                endif
                
 2842 2ADBFB3ABF		lhld info! lda fcbdsk! mov m,a ; fcb(0)=fcbdsk
                if BANKED
                
                		; fcb(7) = fcb(7) | xfcb$read$only
 2849 110700193A		lxi d,7! dad d! lda xfcb$read$only! ora m! mov m,a
                
                endif
                if MPM
                		; if high$ext = 60h then fcb(8) = fcb(8) | 80h
                		;		    else fcb(ext) = fcb(ext) | high$ext
                
                		call getexta! lda high$ext! cpi 60h! jnz goback2
                		lxi d,-4! dad d! mvi a,80h
                	goback2:
                		ora m! mov m,a
                else
                		; fcb(8) = fcb(8) | high$ext
                if BANKED
 2852 23        		inx h
                else
                		lxi d,8! dad d
                endif
 2853 3AB528B677		lda high$ext! ora m! mov m,a
                endif
                
                ;	return from the disk monitor
                
                retmon:
 2858 2A3203F9  	lhld entsp! sphl
CP/M RMAC ASSEM 1.1	#122	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 285C 2A9F0D7D44	lhld aret! mov a,l! mov b,h! ret
                ;
                ;	data areas
                ;
 2862 E5        efcb:	db	empty	; 0e5=available dir entry
 2863 0000      rodsk:	dw	0	; read only disk vector
 2865 0000      dlog:	dw	0	; logged-in disks
                
                if MPM
                
                rlog:	dw	0	; removeable logged-in disks
                tlog:	dw	0	; removeable disk test login vector
                ntlog:	dw	0	; new tlog vector
                rem$drv: ds	byte	; curdsk removable drive switch
                			; 0 = permanent drive, 1 = removable drive
                endif
                
                if not BANKED
                
                xdmaad	equ	$
                curdma	ds	word	; current dma address
                
                endif
                
                if not MPM
                
 2867           buffa:	ds	word	; pointer to directory dma address
                
                endif
                
                ;
                ;	curtrka - alloca are set upon disk select
                ;	(data must be adjacent, do not insert variables)
                ;	(address of translate vector, not used)
 2869           cdrmaxa:ds	word	; pointer to cur dir max value (2 bytes)
 286B           curtrka:ds	word	; current track address (2)
 286D           curreca:ds	word	; current record address (3)
 286F           drvlbla:ds	word	; current drive label byte address (1)
 2871           lsn$add:ds	word	; login sequence # address (1)
                			; +1 -> bios media change flag (1)
 2873           dpbaddr:ds	word	; current disk parameter block address
 2875           checka: ds	word	; current checksum vector address
 2877           alloca: ds	word	; current allocation vector address
 2879           dirbcba:ds	word	; dir bcb list head
 287B           dtabcba:ds	word	; data bcb list head
                hash$tbla:
 287D           	ds	word	; directory hash table address
 287F           	ds	byte	; directory hash table bank
                
 000D =         addlist equ	$-dpbaddr	; address list size
                
                ;
                ;	       buffer control block format
                ;
                ; bcb format : drv(1) || rec(3) || pend(1) || sequence(1) ||
                ;	       0	 1	   4	      5
CP/M RMAC ASSEM 1.1	#123	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                ;
                ;	       track(2) || sector(2) || buffer$add(2) ||
                ;	       6	   8		10
                ;
                ;	       bank(1) || link(2)
                ;	       12	  13
                ;
                
                ;	sectpt - offset obtained from disk parm block at dpbaddr
                ;	(data must be adjacent, do not insert variables)
 2880           sectpt: ds	word	; sectors per track
 2882           blkshf: ds	byte	; block shift factor
 2883           blkmsk: ds	byte	; block mask
 2884           extmsk: ds	byte	; extent mask
 2885           maxall: ds	word	; maximum allocation number
 2887           dirmax: ds	word	; largest directory number
 2889           dirblk: ds	word	; reserved allocation bits for directory
 288B           chksiz: ds	word	; size of checksum vector
 288D           offset: ds	word	; offset tracks at beginning
 288F           physhf: ds	byte	; physical record shift
 2890           phymsk: ds	byte	; physical record mask
 0011 =         dpblist equ	$-sectpt	; size of area
                ;
                ;	local variables
                ;
 2891           drec		ds	word	; directory record number
 2893           blk$off:	ds	byte	; record offset within block
 2894           last$off:	ds	byte	; last offset within new block
 2895           last$drive:	ds	byte	; drive of last new block
 2896           last$block:	ds	word	; last new block
                
                ; The following two variables are initialized as a pair on entry
                
 2898           dir$cnt:	ds	byte	; direct i/o count
 2899           mult$num:	ds	byte	; multi-sector number
                
 289A           tranv:	ds	word	; address of translate vector
                lock$unlock:
                make$flag:
 289C           rmf:	ds	byte	; read mode flag for open$reel
                incr$pdcnt:
 289D           dirloc: ds	byte	; directory flag in rename, etc.
                free$mode:
 289E           linfo:	ds	byte	; low(info)
 289F           dminx:	ds	byte	; local for diskwrite
                
                if MPM
                
                searchl:ds	byte	; search length
                
                endif
                if BANKED
                
 28A0           searcha:ds	word	; search address
                
                endif
CP/M RMAC ASSEM 1.1	#124	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                if BANKED
                
                save$xfcb:
 28A2           	ds	byte	; search xfcb save flag
                
                endif
                
 28A3           single: ds	byte	; set true if single byte allocation map
                
                if MPM
                
                seldsk: ds	byte	; currently selected disk
                
                endif
                
 28A4           seldsk: ds	byte	; disk on entry to bdos
 28A5           rcount: ds	byte	; record count in current fcb
 28A6           extval: ds	byte	; extent number and extmsk
                save$mod:
 28A7           	ds	byte	; open$reel module save field
                
 28A8           vrecord:ds	byte	; current virtual record
                
                if not MPM
                
 28A9 FF        curdsk: db	0ffh	; current disk
                
                endif
                
 28AA FF        adrive: db	0ffh	; current blocking/deblocking disk
 28AB           arecord:ds	word	; current actual record
 28AD           	ds	byte
                
 28AE           save$ranr:	ds	3	; random record save area
 28B1           arecord1:	ds	word	; current actual block# * blkmsk
 28B3           attributes:	ds	byte	; make attribute hold area
 28B4           readf$sw:	ds	byte	; BIOS read/write switch
                
                ;******** following variable order critical *****************
                
                if MPM
                
                mult$cnt:	ds	byte	; multi-sector count
                pdcnt:		ds	byte	; process descriptor count
                
                endif
                
 28B5           high$ext:	ds	byte	; fcb high ext bits
                
                if BANKED
                
 28B6           xfcb$read$only: ds	byte	; xfcb read only flag
                
                endif
                if MPM
CP/M RMAC ASSEM 1.1	#125	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                curdsk:		db	0ffh			;current disk
                packed$dcnt:	ds	3			;
                pdaddr:		ds	word			;
                ;************************************************************
                cur$pos:	ds	word			;
                prv$pos:	ds	word			;
                sdcnt:		ds	word			;
                sdblk:		ds	word			;
                sdcnt0:		ds	word			;
                sdblk0:		ds	word			;
                dont$close:	ds	byte			;
                open$cnt:			; mp/m temp variable for open
                lock$cnt:	ds	word	; mp/m temp variable for lock
                file$id:	ds	word	; mp/m temp variable for lock
                deleted$files:	ds	byte
                lock$shell:	ds	byte
                lock$sp:	ds	word
                set$ro$flag:	ds	byte
                check$disk:	ds	byte
                flushed:	ds	byte
                fcb$cks$valid:	ds	byte
                ;				mp/m variables	*
                
                endif
                
                ;	local variables for directory access
 28B7           dptr:	ds	byte	; directory pointer 0,1,2,3
                
 28B8           save$hash:	ds	4	; hash code save area
                
                if BANKED
                
 28BC           copy$cr$init:	ds	byte	; copy$cr$only initialization value
                
                else
                
                hashmx: ds	word	; cdrmax or dirmax
                xdcnt:	ds	word	; empty directory dcnt
                
                endif
                
                if MPM
                
                xdcnt:	ds	word	; empty directory dcnt
                xdblk:	ds	word	; empty directory block
                dcnt:	ds	word	; directory counter 0,1,...,dirmax
                dblk:	ds	word	; directory block index
                
                endif
                
 28BD           search$user0:	ds	byte	; search user 0 for file (open)
                
 28BE           user0$pass:	ds	byte	; search user 0 pass flag
                
 28BF           fcbdsk:		ds	byte	; disk named in fcb
CP/M RMAC ASSEM 1.1	#126	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                if MPM
                
                make$xfcb:	ds	1
                find$xfcb:	ds	1
                
                endif
                
 28C0 0F10111316log$fxs:db	15,16,17,19,22,23,30,35,99,100,102,103,0
 28CD 1415212228rw$fxs: db	20,21,33,34,40,41,0
 28D4 101200    sc$fxs: db	16,18,0
                
                if MPM
                
                comp$fcb$cks:	ds	byte	; compute fcb checksum flag
                
                endif
                if BANKED
                
 28D7           pw$fcb:		ds	12	;1 |
 28E3 00        		db	0	;2 |
 28E4 00        pw$mode:	db	0	;3 |- Order critical
 28E5 00        		db	0	;4 |
 28E6 00        		db	0	;5 |
                
 28E7           df$password:	ds	8
                
                if MPM
                		ds	120
                endif
                endif
                
 28EF           phy$off:	ds	byte
 28F0           curbcba:	ds	word
                
                if BANKED
                
 28F2           lastbcba:	ds	word
 28F4           rootbcba:	ds	word
 28F6           emptybcba:	ds	word
 28F8           seqbcba:	ds	word
 28FA           buffer$bank:	ds	byte
                
                endif
                
 28FB           track:		ds	word
 28FD           sector:		ds	word
                
                ;	**************************
                ;	Blocking/Deblocking Module
                ;	**************************
                
                deblock$dta:
 28FF 2A7B28    	lhld dtabcba
                
                if BANKED
CP/M RMAC ASSEM 1.1	#127	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 2902 FE04C25829	cpi 4! jnz deblock
                deblock$flush:
                	; de = addr of 1st bcb
 2907 5E2356    	mov e,m! inx h! mov d,m
                	; Search for dirty bcb with lowest track #
 290A 21FFFF22FB	lxi h,0ffffh! shld track! xchg
                deblock$flush1:
                	; Does current drive own bcb?
 2911 3AAA28BEC2	lda adrive! cmp m! jnz deblock$flush2 ;no
                	; Is bcb's buffer pending?
 2918 EB21040019	xchg! lxi h,4! dad d! mov a,m
 291E EB3CC23C29	xchg! inr a! jnz deblock$flush2 ; no
                	; Is bcb(6) < track?
 2923 E51313EB  	push h! inx d! inx d! xchg
 2927 5E2356    	mov e,m! inx h! mov d,m
                	; Subdh computes hl = de - hl
 292A 2AFB28CD7F	lhld track! call subdh! pop h! jnc deblock$flush2 ; no
                	; yes - track = bcb(6) , sector = addr(bcb)
 2934 EB22FB28EB	xchg! shld track! xchg! shld sector
                deblock$flush2:
                	; Is this the last bcb?
 293C CD782BC211	call get$next$bcba! jnz deblock$flush1 ; no - hl = addr of next bcb
                	; Does track = ffff?
 2942 21FB28CDFB	lxi h,track! call test$ffff! rz ; yes - no bcb to flush
                	; Flush bcb located by sector
 2949 2AFD28AF3E	lhld sector! xra a! mvi a,4! call deblock
 2952 2A7B28C307	lhld dtabcba! jmp deblock$flush ; Repeat until no bcb's to flush
                endif
                
                deblock:
                
                	; BDOS Blocking/Deblocking routine
                	; a = 1 -> read command
                	; a = 2 -> write command
                	; a = 3 -> locate command
                	; a = 4 -> flush command
                	; a = 5 -> directory update
                
 2958 F5        	push a ; Save z flag and deblock fx
                
                	; phy$off = low(arecord) & phymsk
                	; low(arecord) = low(arecord) & ~phymsk
 2959 CD512A    	call deblock8
 295C 3AAB285FA0	lda arecord! mov e,a! ana b! sta phy$off
 2964 7BA132AB28	mov a,e! ana c! sta arecord
                
                if BANKED
 2969 F1F5C4922A	pop a! push a! cnz get$bcba
                endif
                
 296E 22F028CD82	shld curbcba! call getbuffa! shld curdma
                	; hl = curbcba, de = .adrive, c = 4
 2977 CD582A    	call deblock9
                	; Is BCB discarded?
 297A 7E3CCAC229	mov a,m! inr a! jz deblock2 ; yes
                	; Is command flush?
CP/M RMAC ASSEM 1.1	#128	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 297F F1F5FE04D2	pop a! push a! cpi 4! jnc deblock1 ; yes
                	; Is referenced physical record already in buffer?
                
                ;;;	call compare	;[JCE] DRI patch 7
 2986 CD0B2D    	call patch$1e0c
                
 2989 CAF229    	jz deblock45 ; yes
 298C AF        	xra a
                deblock1:
                	; Does buffer contain an updated record?
 298D CD612A    	call deblock10
 2990 FE05CA9A29	cpi 5! jz deblock15
 2995 7EB7CAC229	mov a,m! ora a! jz deblock2 ; no
                deblock15:
                	; Reset record pending flag
 299A 3600      	mvi m,0
                	; Save arecord
 299C 2AAB28E53A	lhld arecord! push h! lda arecord+2! push a
                	; Flush physical record buffer
 29A4 CD582A    	call deblock9
 29A7 EBCD290E  	xchg! call move
                	; Select drive to be flushed
 29AB 21A9283AAA	lxi h,curdsk! lda adrive! cmp m! cnz disk$select1
                	; Write record if drive logged-in
 29B5 3E01CC712A	mvi a,1! cz deblock$io
                	; Restore arecord
 29BA C1D1CD030F	pop b! pop d! call set$arecord
                	; Restore selected drive
 29BF CD6B1E    	call curselect
                deblock2:
                	; Is deblock command flush | dir write?
 29C2 F1FE04D0  	pop a! cpi 4! rnc ; yes - return
                	; Is deblock command write?
 29C6 F5FE02C2D6	push a! cpi 2! jnz deblock25 ; no
                	; Is blk$off < last$off
 29CC 219428    	lxi h,last$off
 29CF 3A9328    	lda blk$off
 29D2 BE        	cmp m
 29D3 D2E029    	jnc deblock3 ; no
                deblock25:
                	; Discard BCB on read operations in case
                	; I/O error occurs
                ;;;	lhld curbcba		;[JCE] DRI Patch 7
 29D6 CD1B2D    	call patch$1e1c
 29D9 36FF      	mvi m,0ffh
                	; Read physical record buffer
 29DB 3E02C3E329	mvi a,2! jmp deblock35
                deblock3:
                	; last$off = blk$off + 1
 29E0 3C77      	inr a! mov m,a
                	; Place track & sector in bcb
 29E2 AF        	xra a
                deblock35:
 29E3 CD712A    	call deblock$io
                deblock4:
 29E6 CD582A    	call deblock9 ; phypfx = adrive || arecord
CP/M RMAC ASSEM 1.1	#129	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 29E9 CD290E3600	call move! mvi m,0 ; zero pending flag
                
                if BANKED
                	; Zero logical record sequence
 29EE 23CD832B  	inx h! call set$bcb$seq
                endif
                
                deblock45:
                	; recadd = phybuffa + phy$off*80h
 29F2 3AEF283C11	lda phy$off! inr a! lxi d,80h! lxi h,0ff80h
                deblock5:
 29FC 193DC2FC29	dad d! dcr a! jnz deblock5
 2A01 EB2A1BFD19	xchg! lhld curdma! dad d
                	; If deblock command = locate then buffa = recadd; return
 2A06 F1FE03C210	pop a! cpi 3! jnz deblock6
 2A0C 226728C9  	shld buffa! ret
                deblock6:
 2A10 EB2AD8FB01	xchg! lhld dmaad! lxi b,80h
                	; If deblock command = read
 2A17 FE01      	cpi 1
                
                if BANKED
 2A19 C2332A    	jnz deblock7
                	; then move to tpa
 2A1C 3AFAFB3DBA	lda common$base+1! dcr a! cmp d! jc move$tpa
 2A24 3AFA284F06	lda buffer$bank! mov c,a! mvi b,1! call deblock12
 2A2D 018000C30C	lxi b,80h! jmp move$tpa
                deblock7:
                
                else
                	jz move$tpa ; then move to dma
                endif
                
                	; else move from dma
 2A33 EB        	xchg
                
                if BANKED
 2A34 3AFAFB3DBC	lda common$base+1! dcr a! cmp h! jc deblock75
 2A3C 3AFA28470E	lda buffer$bank! mov b,a! mvi c,1! call deblock12
 2A45 018000    	lxi b,80h
                deblock75:
                
                endif
                
 2A48 CD0CFD    	call move$tpa
                	; Set physical record pending flag for write command
 2A4B CD612A36FF	call deblock10! mvi m,0ffh
 2A50 C9        	ret
                
                deblock8:
 2A51 3A9028472F	lda phymsk! mov b,a! cma! mov c,a! ret
                
                deblock9:
 2A58 2AF02811AA	lhld curbcba! lxi d,adrive! mvi c,4! ret
                
                deblock10:
CP/M RMAC ASSEM 1.1	#130	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 2A61 110400    	lxi d,4
                deblock11:
 2A64 2AF02819C9	lhld curbcba! dad d! ret
                
                if BANKED
                
                deblock12:
 2A69 E5D5CD57FF	push h! push d! call xmovef
 2A6E D1E1C9    	pop d! pop h! ret
                endif
                
                deblock$io:
                	; a = 0 -> seek only
                	; a = 1 -> write
                	; a = 2 -> read
 2A71 F5CD0C0F  	push a! call seek
                
                if BANKED
 2A75 3AFA28CD54	lda buffer$bank! call setbnkf
                endif
                
 2A7B 0E01      	mvi c,1
 2A7D F13D      	pop a! dcr a
 2A7F CA9E0E    	jz wrbuff
 2A82 F4930E    	cp rdbuff
                	; Move track & sector to bcb
 2A85 CD612A2323	call deblock10! inx h! inx h
 2A8A 11FB280E04	lxi d,track! mvi c,4! jmp move
                
                if BANKED
                
                get$bcba:
                ;;;	shld rootbcba	;[JCE] DRI Patch 13
 2A92 CD302D    	call patch$2d30
 2A95 11F3FF1922	lxi d,-13! dad d! shld lastbcba
 2A9C CD782BE5  	call get$next$bcba! push h
                	; Is there only 1 bcb in list?
 2AA0 CD782BE1C8	call get$next$bcba! pop h! rz ; yes - return
 2AA5 EB21000022	xchg! lxi h,0! shld emptybcba! shld seqbcba
 2AAF EB        	xchg
                get$bcb1:
                	; Does bcb contain requested record?
 2AB0 22F028CD58	shld curbcba! call deblock9! call compare! jz get$bcb4 ; yes
                	; Is bcb discarded?
 2ABC 2AF0287E3C	lhld curbcba! mov a,m! inr a! jnz get$bcb11 ; no
 2AC4 EB2AF22822	xchg! lhld lastbcba! shld emptybcba! jmp get$bcb14
                get$bcb11:
                	; Does bcb contain record from current disk?
 2ACE 3AAA28BEC2	lda adrive! cmp m! jnz get$bcb15 ; no
 2AD5 EB21050019	xchg! lxi h,5! dad d! lda phy$msk
                	; Is phy$msk = 0?
 2ADD B7CAF32A  	ora a! jz get$bcb14 ; yes
                	; Does bcb(5) [bcb sequence] = phymsk?
 2AE1 BEC2F32A  	cmp m! jnz get$bcb14 ; no
                ;;;	lhld seqbcba	;[JCE] DRI Patch 13
                ;;;	mov a,l
CP/M RMAC ASSEM 1.1	#131	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                ;;;	ora h
 2AE5 3A392D    	lda patch$2d39
 2AE8 B7        	ora a
 2AE9 00        	nop
 2AEA C2F32A    	jnz get$bcb14
 2AED 2AF22822F8	lhld lastbcba! shld seqbcba
                get$bcb14:
 2AF3 EB        	xchg
                get$bcb15:
                	; Advance to next bcb - list exhausted?
 2AF4 E5CD782BD1	push h! call get$next$bcba! pop d! jz get$bcb2 ; yes
 2AFC EB22F228EB	xchg! shld lastbcba! xchg! jmp get$bcb1
                get$bcb2:
                	; Matching bcb not found
                	; Was a sequentially accessed bcb encountered?
                ;;;	lhld seqbcba	;[JCE] DRI Patch 13
 2B04 2AF628    	lhld emptybcba
                
 2B07 7DB4C2142B	mov a,l! ora h! jnz get$bcb25 ; yes
                	; Was a discarded bcb encountered?
                ;;;	lhld emptybcba	;[JCE] DRI Patch 13
 2B0C 2AF828    	lhld seqbcba
                
 2B0F 7DB4CA172B	mov a,l! ora h! jz get$bcb3 ; no
                get$bcb25:
 2B14 22F228    	shld lastbcba
                get$bcb3:
                	; Insert selected bcb at head of list
 2B17 2AF228CD78	lhld lastbcba! call get$next$bcba
 2B1D 22F028CD78	shld curbcba! call get$next$bcba
 2B23 EBCD6D2B  	xchg! call last$bcb$links$de
 2B27 2AF4285E23	lhld rootbcba! mov e,m! inx h! mov d,m
 2B2D 2AF028010D	lhld curbcba! lxi b,13! dad b
 2B34 732372    	mov m,e! inx h! mov m,d
 2B37 2AF028EB2A	lhld curbcba! xchg! lhld rootbcba
 2B3E 732372EBC9	mov m,e! inx h! mov m,d! xchg! ret
                get$bcb4:
                	; BCB matched arecord
 2B43 2AF0281105	lhld curbcba! lxi d,5! dad d
                	; Does bcb(5) = phy$off?
 2B4A 3AEF28BECA	lda phy$off! cmp m! jz get$bcb5 ; yes
                	; Does bcb(5) + 1 = phy$off?
 2B51 34BECA592B	inr m! cmp m! jz get$bcb5 ; yes
 2B56 CD832B    	call set$bcb$seq
                get$bcb5:
                	; Is bcb at head of list?
 2B59 2AF028EB2A	lhld curbcba! xchg! lhld rootbcba
 2B60 7E236E67  	mov a,m! inx h! mov l,m! mov h,a
 2B64 CD7F11B5EB	call subdh! ora l! xchg! rz ; yes
 2B6A C3172B    	jmp get$bcb3 ; no - insert bcb at head of list
                
                last$bcb$links$de:
 2B6D 2AF228010D	lhld lastbcba! lxi b,13! dad b
 2B74 732372C9  	mov m,e! inx h! mov m,d! ret
                
                get$next$bcba:
CP/M RMAC ASSEM 1.1	#132	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

 2B78 010D00095E	lxi b,13! dad b! mov e,m! inx h! mov d,m
 2B7F EB7CB5C9  	xchg! mov a,h! ora l! ret
                
                set$bcb$seq:
 2B83 3AEF2877B7	lda phy$off! mov m,a! ora a! rz
 2B89 3A90283C77	lda phy$msk! inr a! mov m,a! ret
                
                endif
                
                if not MPM
                if not BANKED
                
                patch$1dfd:			;[JCE] DRI Patch 7
                	lda	chksiz+1
                	ral
                	jc	get$dir$ext
                	mvi	a,0ffh
                	sta	patch$1e24
                	jmp	get$dir$ext
                
                patch$1e0c:
                	cpi	3
                	jnz	compare
                	lda	patch$1e24
                	inr	a
                	jnz	compare
                	pop	h
                	jmp	deblock25
                
                patch$1e1c:
                	xra	a
                	sta	patch$1e24
                	lhld	curbcba
                	ret
                
                patch$1e24:
                	db	0
                
                patch$1e25:
                	lxi	h,0
                	shld	conbuffadd
                	shld	ccp$conbuff
                	dcx	h
                	dcx	h
                	ret
                
                patch$1e31:			;Patch 13
                	call	check$write
                	lxi	h,xdcnt
                	ret
                
                patch$1e38:
                	call	reselectx
                	jmp	check$write
                
                patch$1e3e:
CP/M RMAC ASSEM 1.1	#133	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	call	setfwf
                	jmp	search$namlen
                
                	ds	41	;[JCE] Was 112 before patching
                last:
                		org	base + (((last-base)+255) and 0ff00h) - 112
                
                olog:		dw	0
                rlog:		dw	0
                
                patch$flgs:	db	0,0,0,6 ;Patchlevel
                		dw	base+6
                		xra a! ret
                
                ; System Control Block
                
                SCB:
                
                ; Expansion Area - 6 bytes
                
                hashl:		db	0
                hash:		dw	0,0
                version:	db	31h
                
                ; Utilities Section - 8 bytes
                
                util$flgs:	dw	0,0
                dspl$flgs:	dw	0
                		dw	0
                
                ; CLP Section - 4 bytes
                
                clp$flgs:	dw	0
                clp$errcde:	dw	0
                
                ; CCP Section - 8 bytes
                
                ccp$comlen:	db	0
                ccp$curdrv:	db	0
                ccp$curusr:	db	0
                ccp$conbuff:	dw	0
                ccp$flgs:	dw	0
                		db	0
                
                ; Device I/O Section - 32 bytes
                
                conwidth:	db	0
                column:		db	0
                conpage:	db	0
                conline:	db	0
                conbuffadd:	dw	0
                conbufflen:	dw	0
                conin$rflg:	dw	0
                conout$rflg:	dw	0
                auxin$rflg:	dw	0
                auxout$rflg:	dw	0
CP/M RMAC ASSEM 1.1	#134	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                lstout$rflg:	dw	0
                page$mode:	db	0
                pm$default:	db	0
                ctlh$act:	db	0
                rubout$act:	db	0
                type$ahead:	db	0
                contran:	dw	0
                conmode:	dw	0
                		db	0
                		db	0
                outdelim:	db	'$'
                listcp		db	0
                qflag:		db	0
                
                ; BDOS Section - 42 bytes
                
                scbadd:		dw	scb
                dmaad:		dw	0080h
                olddsk:		db	0
                info:		dw	0
                resel:		db	0
                relog:		db	0
                fx:		db	0
                usrcode:	db	0
                dcnt:		dw	0
                searcha:	dw	0
                searchl:	db	0
                multcnt:	db	1
                errormode:	db	0
                searchchain:	db	0,0ffh,0ffh,0ffh
                temp$drive:	db	0
                errdrv:		db	0
                		dw	0
                media$flag:	db	0
                		dw	0
                bdos$flags:	db	0
                stamp:		db	0ffh,0ffh,0ffh,0ffh,0ffh
                commonbase:	dw	0
                error:		jmp	error$sub
                bdosadd:	dw	base+6
                
                endif
                endif
                
                ;	************************
                ;	Directory Hashing Module
                ;	************************
                
                ; Hash format
                ; xxsuuuuu xxxxxxxx xxxxxxxx ssssssss
                ; x = hash code of fcb name field
                ; u = low 5 bits of fcb user field
                ;     1st bit is on for XFCB's
                ; s = shiftr(mod || ext,extshf)
                
                if not BANKED
CP/M RMAC ASSEM 1.1	#135	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                hashorg:
                	org	base+(((hashorg-base)+255) and 0ff00h)
                endif
                
                init$hash:
                	; de = .hash table entry
                	; hl = .dir fcb
 2B8F E5D5CDE02B	push h! push d! call get$hash
                	; Move computed hash to hash table entry
 2B94 E1119DFB01	pop h! lxi d,hash! lxi b,4
                
                if BANKED
 2B9B 3A7F28CD09	lda hash$tbla+2! call move$out
                else
                	call movef
                endif
                
                	; Save next hash table entry address
 2BA1 22B128    	shld arecord1
                	; Restore dir fcb address
 2BA4 E1C9      	pop h! ret
                
                set$hash:
                	; Return if searchl = 0
 2BA6 B7C8      	ora a! rz
                	; Is searchl < 12 ?
 2BA8 FE0CDADC2B	cpi 12! jc set$hash2 ; yes - hashl = 0
                	; Is searchl = 12 ?
 2BAD 3E02CAB42B	mvi a,2! jz set$hash1 ; yes - hashl = 2
 2BB2 3E03      	mvi a,3 ; hashl = 3
                set$hash1:
 2BB4 329CFB    	sta hashl
 2BB7 EB        	xchg
                	; Is dir hashing invoked for drive?
 2BB8 CD642CC8  	call test$hash! rz ; no
 2BBC EB        	xchg
 2BBD 3ADFFB    	lda fx
 2BC0 FE10CAE02B	cpi 16! jz get$hash ; bdos fx = 16
 2BC5 FE23CACF2B	cpi 35! jz set$hash15
 2BCA FE14D2E02B	cpi 20! jnc get$hash ; bdos fx = 20 or above
                set$hash15:
 2BCF 3E02329CFB	mvi a,2! sta hashl ; bdos fx = 15,17,18,19, or 35
                	; if fcb wild then hashl = 0, hash = fcb(0)
                	;	      else hashl = 2, hash = get$hash
 2BD4 E5CD3917E1	push h! call chk$wild! pop h! jnz get$hash
                set$hash2:
 2BDC AF329CFB  	xra a! sta hashl
                	; jmp get$hash
                
                get$hash:
                	; hash(0) = fcb(0)
 2BE0 7E329DFB23	mov a,m! sta hash! inx h! xchg
                	; Don't compute hash for dir lbl & sfcb's
 2BE6 210000E620	lxi h,0! ani 20h! jnz get$hash6
                	; b = 11, c = 8, ahl = 0
CP/M RMAC ASSEM 1.1	#136	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                	; Compute fcb name hash (000000xx xxxxxxxxx xxxxxxxx) (ahl)
 2BEE 01080B    	lxi b,0b08h
                get$hash1:
                	; Don't shift if fcb(8)
 2BF1 0DC5CA062C	dcr c! push b! jz get$hash3
                	; Don't shift if fcb(6)
 2BF6 0D0DCA062C	dcr c! dcr c! jz get$hash3
                	; ahl = ahl * 2
 2BFB 298FF578  	dad h! adc a! push a! mov a,b
                	; is b odd?
 2BFF 1FDA072C  	rar! jc get$hash4 ; yes
                	; ahl = ahl * 2 for even fcb(i)
 2C03 F1298F    	pop a! dad h! adc a
                get$hash3:
 2C06 F5        	push a
                get$hash4:
                	; a = fcb(i) & 7fh - 20h divided by 2 if even
 2C07 1AE67FD620	ldax d! ani 7fh! sui 20h! rar! jnc get$hash5
 2C10 17        	ral
                get$hash5:
                	; ahl = ahl + a
 2C11 4F0600    	mov c,a! mvi b,0
 2C14 F109CE00C1	pop a! dad b! aci 0! pop b
                	; advance to next fcb char
 2C19 1305C2F12B	inx d! dcr b! jnz get$hash1
                get$hash6:
                	; ahl = 000000xx xxxxxxxx xxxxxxxx
                	; Store low 2 bytes of hash
 2C1E 229EFB219D	shld hash+1! lxi h,hash
                	; hash(0) = hash(0) (000uuuuu) | xx000000
 2C24 E6030F0FB6	ani 3! rrc! rrc! ora m! mov m,a
                	; Does fcb(0) = e5h, 20h, or 21h?
 2C2A E620C25B2C	ani 20h! jnz get$hash9 ; yes
                	; bc = 00000mmm mmmeeeee, m = module #, e = extent
 2C2F 1AE61F4F13	ldax d! ani 1fh! mov c,a! inx d! inx d
 2C35 1AE63F0F0F	ldax d! ani 3fh! rrc! rrc! rrc! mov d,a
 2C3C E607477AE6	ani 7! mov b,a! mov a,d! ani 0e0h! ora c! mov c,a
                	; shift bc right by # of bits in extmsk
 2C44 3A8428    	lda extmsk
                get$hash7:
 2C47 1FD2562C  	rar! jnc get$hash8
 2C4B F5        	push a
 2C4C 781F47    	mov a,b! rar! mov b,a
 2C4F 791F4F    	mov a,c! rar! mov c,a
 2C52 F1C3472C  	pop a! jmp get$hash7
                get$hash8:
                	; hash(0) = hash(0) (xx0uuuuu) | 00s00000
 2C56 78E6010F0F	mov a,b! ani 1! rrc! rrc
                get$hash9:
 2C5B 0FB677    	rrc! ora m! mov m,a
                	; hash(3) = ssssssss
 2C5E 1103001971	lxi d,3! dad d! mov m,c! ret
                
                test$hash:
 2C64 2A7D287DB4	lhld hash$tbla! mov a,l! ora h! inr a! ret
                
CP/M RMAC ASSEM 1.1	#137	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                search$hash:
                	; Does hash table exist for drive?
 2C6B CD642CC8  	call test$hash! rz ; no
                	; Has dir hash search been disabled?
 2C6F 3A9CFB3CC8	lda hashl! inr a! rz ; yes
                	; Is searchl = 0?
 2C74 3AE5FBB7C8	lda searchl! ora a! rz ; yes
                	; hashmx = cdrmaxa if searchl ~= 1
                	;	   dir$max if searchl = 1
 2C79 2A69285E23	lhld cdrmaxa! mov e,m! inx h! mov d,m
 2C7F EB3DC2872C	xchg! dcr a! jnz search$h0
 2C84 2A8728    	lhld dir$max
                search$h0:
 2C87 2212FD    	shld hashmx
                
                if BANKED
                	; call search$hash in resbdos, a = bank, hl = hash tbl addr
 2C8A 3A7F282A7D	lda hash$tbla+2! lhld hash$tbla! call srch$hash
                	; Was search successful?
 2C93 C2AE2C    	jnz search$h1 ; no
                	; Is directory read required?
 2C96 3A14FDB70E	lda rd$dir$flag! ora a! mvi c,0
 2C9C C43D13    	cnz r$dir2 ; yes if Z flag reset
                	; Is function = 18?
 2C9F 3ADFFBD612	lda fx! sui 18! rz ; Never reset dcnt for fx 18
                	; Was media change detected by above read?
 2CA5 3A9CFB3CCC	lda hashl! inr a! cz setenddir ; yes
 2CAC AFC9      	xra a! ret ; search$hash successful
                search$h1:
                	; Was search initiated from beginning of directory?
 2CAE CDF812C0  	call end$of$dir! rnz ; no
                	; Is bdos fx = 15,17,19,22,23,30?
 2CB2 CDF511C0  	call tst$log$fxs! rnz ; no
                	; Disable hash & return successful
 2CB6 3EFF329CFB	mvi a,0ffh! sta hashl
 2CBB 2A69285E23	lhld cdrmaxa! mov e,m! inx h! mov d,m! xchg
 2CC2 2BCD0D19AF	dcx h! call set$dcnt$dblk1! xra a! ret
                else
                	lhld hash$tbla! mov b,h! mov c,l
                	lhld hashmx! xchg
                	; Return with Z flag set if dcnt = hashmx
                	lhld dcnt! push h! call subdh! pop d! ora l! rz
                	; Push hashmx - dcnt (# of hashtbl entries to search)
                	; Push dcnt + 1
                	push h! inx d! xchg! push h
                	; Compute .hash$tbl(dcnt)
                	dcx h! dad h! dad h! dad b
                search$h1:
                	; Advance hl to address of next hash$tbl entry
                	lxi d,4! dad d! lxi d,hash
                	; Do hash u fields match?
                	ldax d! xra m! ani 1fh! jnz search$h3 ; no
                	; Do hash's match?
                	call search$h6! jz search$h4 ; yes
                search$h2:
                	xchg! pop h
CP/M RMAC ASSEM 1.1	#138	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                search$h25:
                	; de = .hash$tbl(dcnt), hl = dcnt
                	; dcnt = dcnt + 1
                	inx h! xthl
                	; hl = # of hash$tbl entries to search
                	; decrement & test for zero
                	; Restore stack & hl to .hashtbl(dcnt)
                	dcx h! mov a,l! ora h! xthl! push h
                	; Are we done?
                	xchg! jnz search$h1 ; no - keep searching
                	; Search unsuccessful
                	pop h! pop h
                	; Was search initiated from beginning of directory?
                	call end$of$dir! rnz ; no
                	; Is fx = 15,17,19,22,23,30 & drive removeable?
                	call tst$log$fxs! rnz ; no
                	; Disable hash & return successful
                	mvi a,0ffh! sta hashl
                	lhld cdrmaxa! mov e,m! inx h! mov d,m! xchg
                	dcx h! call set$dcnt$dblk1! xra a! ret
                
                search$h3:
                	; Does xdcnt+1 = 0ffh?
                	lda xdcnt+1! inr a! jz search$h5 ; yes
                	; Does xdcnt+1 = 0feh?
                	inr a! jnz search$h2 ; no - continue searching
                	; Do hash's match?
                	call search$h6! jnz search$h2 ; no
                	; xdcnt+1 = 0feh
                	; Open user 0 search
                	; Does hash u field = 0?
                	mov a,m! ani 1fh! jnz search$h2 ; no
                	; Search successful
                search$h4:
                	; Successful search
                	; Set dcnt to search$hash dcnt-1
                	; dcnt gets incremented by read$dir
                	; Also discard search$hash loop count
                	lhld dcnt! xchg
                	pop h! dcx h! shld dcnt! pop b
                	; Does dcnt&3 = 3?
                	mov a,l! ani 03h! cpi 03h! rz ; yes
                	; Does old dcnt & new dcnt reside in same sector?
                	mov a,e! ani 0fch! mov e,a
                	mov a,l! ani 0fch! mov l,a
                	call subdh! ora l! rz ; yes
                	; Read directory record
                	call read$dir2
                	; Has media change been detected?
                	lda hashl! inr a! cz setenddir ; dcnt = -1 if hashl = 0ffh
                	xra a! ret
                search$h5:
                	; xdcnt+1 = 0ffh
                	; Make search to save dcnt of empty fcb
                	; Is hash$tbl entry empty?
                	mov a,m! cpi 0f5h! jnz search$h2 ; no
CP/M RMAC ASSEM 1.1	#139	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                search$h55:
                	; xdcnt = dcnt
                	xchg! pop h! shld xdcnt! jmp search$h25
                search$h6:
                	; hash compare routine
                	; Is hashl = 0?
                	lda hashl! ora a! rz ; yes - hash compare successful
                	; b = 0f0h if hashl = 3
                	;     0d0h if hashl = 2
                	mov c,a! rrc! rrc! rrc! ori 1001$0000b! mov b,a
                	; hash s field must be screened out of hash(0)
                	; if hashl = 2
                	; Do hash(0) fields match?
                	ldax d! xra m! ana b! rnz ; no
                	; Compare remainder of hash fields for hashl bytes
                	push h! inx h! inx d! call compare
                	pop h! ret
                endif
                
                fix$hash:
 2CC8 CD642CC8  	call test$hash! rz
 2CCC 21B828119D	lxi h,save$hash! lxi d,hash! lxi b,4
 2CD5 E5D5C5CD4B	push h! push d! push b! call movef
 2CDB 2A7D28E5  	lhld hash$tbla! push h
 2CDF CD4011CDE0	call get$dptra! call get$hash
 2CE5 2AE1FB2929	lhld dcnt! dad h! dad h
 2CEA D119      	pop d! dad d
 2CEC C1D1D5C5  	pop b! pop d! push d! push b
                
                if BANKED
 2CF0 3A7F28CD09	lda hash$tbla+2! call move$out
                else
                	call movef
                endif
                
 2CF6 C1E1D1C34B	pop b! pop h! pop d! jmp movef
                
                if not MPM
                if BANKED
                
                patch$1dfd:			;[JCE] DRI Patch 7
 2CFC 3A8C28    	lda	chksiz+1
 2CFF 17        	ral
 2D00 DA9714    	jc	get$dir$ext
 2D03 3EFF      	mvi	a,0ffh
 2D05 32232D    	sta	patch$1e24
 2D08 C39714    	jmp	get$dir$ext
                
                patch$1e0c:
 2D0B FE03      	cpi	3
 2D0D C21F0E    	jnz	compare
 2D10 3A232D    	lda	patch$1e24
 2D13 3C        	inr	a
 2D14 C21F0E    	jnz	compare
 2D17 E1        	pop	h
 2D18 C3D629    	jmp	deblock25
CP/M RMAC ASSEM 1.1	#140	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                patch$1e1c:
 2D1B AF        	xra	a
 2D1C 32232D    	sta	patch$1e24
 2D1F 2AF028    	lhld	curbcba
 2D22 C9        	ret
                
                patch$1e24:
 2D23 00        	db	0
                
                patch$1e25:
 2D24 210000    	lxi	h,0
 2D27 22BAFB    	shld	conbuffadd
 2D2A 22B1FB    	shld	ccp$conbuff
 2D2D 2B        	dcx	h
 2D2E 2B        	dcx	h
 2D2F C9        	ret
                
                patch$2d30:
 2D30 22F428    	shld rootbcba
 2D33 D603      	sui 3
 2D35 32392D    	sta patch$2d39
 2D38 C9        	ret
                
                patch$2d39:
 2D39 00        	db	0
                
                patch$2d3a:
 2D3A CD432D    	call	patch$2d43
 2D3D C31325    	jmp	flush4
                
                patch$2d40:
 2D40 CD7713    	call	copy$alv
                patch$2d43:
 2D43 2A7B28    	lhld	dtabcba
 2D46 7D        	mov	a,l
 2D47 A4        	ana	h
 2D48 3C        	inr	a
 2D49 C8        	rz
                patch$2d4a:
 2D4A 5E        	mov	e,m
 2D4B 23        	inx	h
 2D4C 56        	mov	d,m
 2D4D 7A        	mov	a,d
 2D4E B3        	ora	e
 2D4F C8        	rz
 2D50 21AA28    	lxi	h,adrive
 2D53 1A        	ldax	d
 2D54 BE        	cmp	m
 2D55 C2632D    	jnz	patch$2d63
 2D58 210400    	lxi	h,4
 2D5B 19        	dad	d
 2D5C 3EFF      	mvi	a,0ffh
 2D5E BE        	cmp	m
 2D5F C2632D    	jnz	patch$2d63
 2D62 12        	stax	d
CP/M RMAC ASSEM 1.1	#141	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                patch$2d63:
 2D63 210D00    	lxi	h,0dh
 2D66 19        	dad	d
 2D67 C34A2D    	jmp	patch$2d4a
                
                patch$2d6a:
 2D6A CD7713    	call	copy$alv
 2D6D 2A7128    	lhld	lsn$add
 2D70 7E        	mov	a,m
 2D71 B7        	ora	a
 2D72 C0        	rnz	
 2D73 3602      	mvi	m,2
 2D75 C9        	ret
                
                patch$1e31:
 2D76 CD3911    	call	check$write
 2D79 2117FD    	lxi	h,xdcnt
 2D7C C9        	ret
                
                patch$1e38:
 2D7D CD901E    	call	reselectx
 2D80 C33911    	jmp	check$write
                
                patch$1e3e:
 2D83 CD6211    	call	setfwf
 2D86 C3F014    	jmp	search$namlen
                
                last:
                
 2DFF           	org	(((last-base)+255) and 0ff00h) - 1
 2DFF 00        	db	0
                
                endif	;BANKED
                
                else	;not MPM
                
                	ds	192
                last:
                	org	(((last-base)+255) and 0ff00h) - 192
                
                	;	bnkbdos patch area
                
                	dw	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                	dw	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                	dw	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                	dw	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                	dw	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                	dw	0,0,0,0,0,0,0,0,0,0,0,0
                
                free$root:	dw	$-$
                open$root:	dw	0
                lock$root:	dw	0
                lock$max:	db	0
                open$max:	db	0
                
                ;	BIOS access table
CP/M RMAC ASSEM 1.1	#142	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

                
                bios	equ	$		; base of the bios jump table
                bootf	equ	bios		; cold boot function
                wbootf	equ	bootf+3		; warm boot function
                constf	equ	wbootf+3	; console status function
                coninf	equ	constf+3	; console input function
                conoutf equ	coninf+3	; console output function
                listf	equ	conoutf+3	; list output function
                punchf	equ	listf+3		; punch output function
                readerf equ	punchf+3	; reader input function
                homef	equ	readerf+3	; disk home function
                seldskf equ	homef+3		; select disk function
                settrkf equ	seldskf+3	; set track function
                setsecf equ	settrkf+3	; set sector function
                setdmaf equ	setsecf+3	; set dma function
                readf	equ	setdmaf+3	; read disk function
                writef	equ	readf+3		; write disk function
                liststf equ	writef+3	; list status function
                sectran equ	liststf+3	; sector translate
                
                endif
                
 2E00           		end
2E00
CP/M RMAC ASSEM 1.1	#143	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

1146 ADDH	000D ADDLIST	20A7 ADJUSTDMAAD		28AA ADRIVE
037F ADVDMA	2877 ALLOCA	1C07 ALLOCWD	0D28 APOS	0D25 APOSI
28AB ARECORD	28B1 ARECORD1	0D9F ARET	0FF2 ATRAN	28B3 ATTRIBUTES
FBC2 AUXINRFLG	FF36 AUXINSTF	FBC4 AUXOUTRFLG	FF39 AUXOUTSTF	09C5 BACKONE
093D BACKSP	0557 BACKUP	08A8 BACKX	08BD BACKX1	1DA9 BADSEEK
FFFF BANKED	0000 BASE	0DE4 BDEEBDEMHL	0DED BDEEBDEPHL	FBFE BDOSADD
0006 BDOSE	002E BDOSE1	003B BDOSE2	FBF3 BDOSFLAGS	006F BDOSJMP
FF00 BIOS	FF00 BIOSPG	2883 BLKMSK	2893 BLKOFF	0A9E BLKOUT
0AB2 BLKOUT1	0AB5 BLKOUT2	2882 BLKSHF	1BDE BLOCKOK	FC00 BNKBDOSPG
FF00 BOOTF	2867 BUFFA	28FA BUFFERBANK	09E0 BUFFERFULL	188C BUFFNZERO
0001 BYTE	21B9 CALLOPEN	0374 CBDOS	0378 CBDOS1	0642 CBS1
064C CBS2	0AC1 CBUFF	0AC0 CBUFFLEN	FBAE CCPCOMLEN	FBB1 CCPCONBUFF
FBAF CCPCURDRV	FBB0 CCPCURUSR	FBB3 CCPFLGS	2869 CDRMAXA	2875 CHECKA
1F2F CHECKALLMEDIA		10CE CHECKFCB	1EF5 CHECKMEDIA
1F08 CHECKMEDIA1		1F24 CHECKMEDIA2		1A68 CHECKNPR1
1B2B CHECKNPR10	1B42 CHECKNPR10A		1A72 CHECKNPR11	1A6C CHECKNPR1A
1A6F CHECKNPR1B	1A88 CHECKNPR2	1AA7 CHECKNPR21	1AA8 CHECKNPR23	1AC2 CHECKNPR4
1AF5 CHECKNPR45	1AFD CHECKNPR5	1B05 CHECKNPR6	1B0D CHECKNPR7	1B1C CHECKNPR8
1B1D CHECKNPR9	1A4D CHECKNPRS	1128 CHECKRODIR	112B CHECKROFILE
1188 CHECKSUM	172D CHECKWILD	1730 CHECKWILD0	1139 CHECKWRITE	10D8 CHEKFCB
10E2 CHEKFCB1	1F3C CHKAM1	1F51 CHKAM2	063B CHKBUFFERSIZE
05C0 CHKCOLUMN	1213 CHKEXITFXS	12E8 CHKINVFCB	10F7 CHKMEDIA1	10F9 CHKMEDIA2
10E3 CHKMEDIAFCB		0EB6 CHKMEDIAFLAG
1F78 CHKPASSWORD		1F7E CHKPW	1FD2 CHKPWE1	1FE4 CHKPWE2
1FFD CHKPWE3	1F85 CHKPWERROR	288B CHKSIZ	0EEB CHKSIZEQ8000H
1739 CHKWILD	173B CHKWILD1	20D4 CHKXFCBPASSWORD
20D7 CHKXFCBPASSWORD1		061B CLEARRIGHT	183D CLOSE	184B CLOSE1
186C CLOSEFCB	FBAC CLPERRCDE	FBAA CLPFLGS	115A CLREXT	1154 CLRMODNUM
2002 CMPPW	200F CMPPW1	201D CMPPW2	2027 CMPPW3	2034 CMPPW4
FBB7 COLUMN	0ABF COMCHR	FBF9 COMMONBASE	0E1F COMPARE
18F8 COMPAREEXTENTS		2671 COMPAREMODEXT		1DFE COMPARERR
1169 COMPCDR	0ABC COMPCOL	1486 COMPEXT	04F6 COMPOUT	10B8 COMPUTECS
10BE COMPUTECS0	10C1 COMPUTECS1	1DCB COMPUTERR	047F CONB0	049A CONB1
049D CONB2	04A0 CONB3	041B CONBRK	0450 CONBRK1	045E CONBRK2
0475 CONBRK3	042F CONBRKX	FBBA CONBUFFADD	FBBC CONBUFFLEN	03C2 CONECH
03C6 CONECH0	03D6 CONECH1	03E5 CONECH2	03B7 CONIN	FB74 CONINF
FBBE CONINRFLG	FBB9 CONLINE	FBCF CONMODE	04CD CONOUT	FB7A CONOUTF
FBC0 CONOUTRFLG	FF33 CONOUTSTF	FBB8 CONPAGE	FB6E CONSTF	03FF CONSTX
FBCD CONTRAN	FBB6 CONWIDTH	1377 COPYALV	05EE COPYCBUFF	060A COPYCBUFF1
060F COPYCBUFF2	28BC COPYCRINIT	FD1D COPYCRONLY	16F7 COPYDIR	16F9 COPYDIR0
16FD COPYDIR1	1710 COPYDIR2	1480 COPYDIRLOC	280E COPYSTAMP	1748 COPYUSERNO
05D8 COPYXBUFF	000D CR		0582 CRLF	056A CRLFP	0572 CRLFP0
229D CSEARCH	22AF CSEARCH1	22BE CSEARCH2	22C3 CSEARCH3	22DA CSEARCH4
005E CTL	0001 CTLA	0D2D CTLACOLUMN	0D2A CTLASW	0002 CTLB
07DC CTLBL0	07E1 CTLBL1	07F0 CTLBL2	07F8 CTLBL3	0003 CTLC
0A68 CTLCSTATRET		0005 CTLE	0006 CTLF	0007 CTLG
0008 CTLH	FBCA CTLHACT	000B CTLK	0513 CTLOUT	0010 CTLP
0011 CTLQ	0012 CTLR	08ED CTLRL1	08F8 CTLRL2	0013 CTLS
0015 CTLU	0017 CTLW	0755 CTLWL0	0760 CTLWL1	076A CTLWL13
076F CTLWL15	0773 CTLWL2	0782 CTLWL25	0791 CTLWL3	0D2B CTLWSW
0018 CTLX	001A CTLZ	28F0 CURBCBA	FD1B CURDMA	28A9 CURDSK
286D CURRECA	1E6B CURSELECT	286B CURTRKA	FBE1 DCNT	2958 DEBLOCK
298D DEBLOCK1	2A61 DEBLOCK10	2A64 DEBLOCK11	2A69 DEBLOCK12	299A DEBLOCK15
29C2 DEBLOCK2	29D6 DEBLOCK25	29E0 DEBLOCK3	29E3 DEBLOCK35	29E6 DEBLOCK4
29F2 DEBLOCK45	29FC DEBLOCK5	2A10 DEBLOCK6	2A33 DEBLOCK7	2A48 DEBLOCK75
2A51 DEBLOCK8	2A58 DEBLOCK9	28FF DEBLOCKDTA	2907 DEBLOCKFLUSH
CP/M RMAC ASSEM 1.1	#144	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

2911 DEBLOCKFLUSH1		293C DEBLOCKFLUSH2		2A71 DEBLOCKIO
1636 DELETE	1645 DELETE00	166B DELETE01	167E DELETE02	1684 DELETE1
1687 DELETE10	168A DELETE11	169B DELETE12	169D DELETE13	163C DELETEX
024D DELIM	0252 DELIM1	025D DELIM2	0269 DELIM3	023F DELIMITERS
FF3F DEVINITF	FF3C DEVTBLF	28E7 DFPASSWORD	0EA5 DIOCOMP	2879 DIRBCBA
2562 DIRBIOS1	256B DIRBIOS2	258B DIRBIOS3	2590 DIRBIOS4	2889 DIRBLK
2898 DIRCNT	0A20 DIRINP	0A25 DIRINP1	289D DIRLOC	2887 DIRMAX
0004 DIRREC	0A17 DIRSTAT	12C3 DIRTOUSER	125B DISCARD	125D DISCARD0
1265 DISCARD1	1274 DISCARD2	1252 DISCARDDATA
124A DISCARDDATABCB		1258 DISCARDDIR	000C DISKF	19F5 DISKREAD
1A00 DISKREAD0	1E51 DISKSELECT	1E54 DISKSELECT1		1C11 DISKWR1
1C15 DISKWR10	1C84 DISKWR11	1CC7 DISKWR2	1B63 DISKWRITE	1B9C DISKWRITE0
1BB5 DISKWRITE15		1BBA DISKWRITE2	1CDE DISKWRITE3	1C0F DISKWRU
2865 DLOG	FBD8 DMAAD	289F DMINX	0FAB DMPOS0	0FB9 DMPOS1
0FC2 DMPOS2	0FA4 DMPOSITION	18A8 DMSET	079F DOCTLA	07CA DOCTLB
071C DOCTLF	0724 DOCTLF0	0839 DOCTLH	08CE DOCTLU	073A DOCTLW
1608 DOESXFCBEXIST		09C0 DONEWLINE	1CBA DONTWRITE	085C DORUBOUT
2873 DPBADDR	0011 DPBLIST	28B7 DPTR	2891 DREC	1474 DRVLBL
286F DRVLBLA	1233 DRVRELOG	FF42 DRVTBLF	0D3D DSKERR	0010 DSKMAP
0D2F DSKMSG	0003 DSKMSK	0002 DSKSHF	FBA6 DSPLFLGS	287B DTABCBA
03F0 ECHOC	2862 EFCB	00E5 EMPTY	28F6 EMPTYBCBA	FFFF ENDDIR
12F8 ENDOFDIR	159B ENDSEARCH	15AD ENDSEARCH1	0332 ENTSP	FBED ERRDRV
0280 ERRFLG	02AF ERRFLG1	02B8 ERRFLG2	02E5 ERRFLG3	FBFB ERROR
FBE7 ERRORMODE	007C ERRORSUB	014A ERRTBL	05C9 EXPAND	05CE EXPAND1
2884 EXTMSK	000C EXTNUM	28A6 EXTVAL	0000 FALSE	28BF FCBDSK
0020 FCBLEN	1886 FCBNZERO	0005 FCBSHF	23E3 FILEEXISTS	1C4B FILL0
1C37 FILL00	1C5B FILL1	FD16 FINDXFCB	2CC8 FIXHASH	251A FLUSH
24E8 FLUSH0	24ED FLUSH1	2506 FLUSH3	2510 FLUSH35	2513 FLUSH4
2515 FLUSH5	FF48 FLUSHF	2520 FLUSHX	289E FREEMODE	03C2 FUNC1
06C8 FUNC10	26A6 FUNC100	271F FUNC101	2728 FUNC102	2764 FUNC103
27F1 FUNC104	27FE FUNC105	2813 FUNC106	281E FUNC107	2827 FUNC108
0A7B FUNC109	0A3D FUNC11	0A89 FUNC110	0A95 FUNC111	0A95 FUNC112
217D FUNC12	2183 FUNC13	2196 FUNC14	21A0 FUNC15	2287 FUNC16
229B FUNC17	22EC FUNC18	22F5 FUNC19	0528 FUNC2	22FB FUNC20
2304 FUNC21	230D FUNC22	23EF FUNC23	23F5 FUNC24	23FB FUNC25
2401 FUNC26	2408 FUNC27	11D3 FUNC28	2411 FUNC29	0A01 FUNC3
2417 FUNC30	2423 FUNC31	242D FUNC32	2441 FUNC33	244A FUNC34
2453 FUNC35	1E40 FUNC36	2459 FUNC37	0A75 FUNC38	0A75 FUNC39
244A FUNC40	0A75 FUNC42	0A75 FUNC43	247D FUNC44	248B FUNC45
2490 FUNC46	24CD FUNC47	24DF FUNC48	252A FUNC49	2545 FUNC49SET
2550 FUNC50	25B0 FUNC50RET	0A07 FUNC6	0A2B FUNC7	0A31 FUNC8
0A37 FUNC9	24E8 FUNC98	25C8 FUNC99	0A75 FUNCRET	00C6 FUNCTAB
012C FUNCTAB2	0080 FWFMSK	FBDF FX		0D85 FXSTSMSG
134E GETALLOCBIT		1018 GETATTS	1021 GETATTSLOOP
2AB0 GETBCB1	2ACE GETBCB11	2AF3 GETBCB14	2AF4 GETBCB15	2B04 GETBCB2
2B14 GETBCB25	2B17 GETBCB3	2B43 GETBCB4	2B59 GETBCB5	2A92 GETBCBA
16B8 GETBLOCK	1282 GETBUFFA	149F GETDE0	14A2 GETDE1	14AC GETDE2
14B9 GETDE3	1497 GETDIREXT	1F73 GETDIRMODE	0FCC GETDM	0FC4 GETDMA
0FDA GETDMD	1140 GETDPTRA	2112 GETDTBA	2110 GETDTBA8	103F GETEXTA
1058 GETFCB	106D GETFCB0	1074 GETFCB1	104F GETFCBA	2667 GETFCBADDS
1E13 GETFILESIZE		2BE0 GETHASH	2BF1 GETHASH1	2C06 GETHASH3
2C07 GETHASH4	2C11 GETHASH5	2C1E GETHASH6	2C47 GETHASH7	2C56 GETHASH8
2C5B GETHASH9	114B GETMODNUM	13DE GETNALBS	2B78 GETNEXTBCBA
1047 GETRCNTA	1037 GETRRA	1031 GETS1	1E1F GETSIZE	2083 GETXFCB
2099 GETXFCB1	0219 GFC	0232 GFC1	283B GOBACK	2835 GOBACK0
0DB2 GOERR	0DB8 GOERR1	249D GSP1	249E GSP2	24A2 GSP3
CP/M RMAC ASSEM 1.1	#145	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

24AA GSP4	FB9D HASH	FB9C HASHL	FD12 HASHMX	287D HASHTBLA
28B5 HIGHEXT	005D HIGHFXS	10FE HLROTL	10FF HLROTL0	10AB HLROTR
10AC HLROTR0	0372 HOLDDMA	0E80 HOME	FF18 HOMEF	289D INCRPDCNT
0DFE INCRRR	0FE0 INDEX	17B4 INDIC0	17CE INDIC1	17A4 INDICATORS
FBDB INFO	06A8 INITAPOS	2B8F INITHASH	140D INITIAL0	1438 INITIAL2
146E INITIAL3	11C6 INITIALCS	13E8 INITIALIZE	1405 INITIALIZE2
20B1 INITXFCB	20B7 INITXFCB0	20CC INITXFCB1	15FD INITXFCBSEARCH
15FF INITXFCBSEARCH1		06B3 INITXPOS	000A INVIS	FD20 KBCHAR
2D89 LAST	28F2 LASTBCBA	2B6D LASTBCBLINKSDE		2896 LASTBLOCK
2895 LASTDRIVE	2894 LASTOFF	16D2 LEFTTST	000A LF		090B LINELEN
289E LINFO	FBD4 LISTCP	FB80 LISTF	FF2D LISTSTF	289C LOCKUNLOCK
28C0 LOGFXS	0D9F LRET	15C0 LRETEQFF	2871 LSNADD	001F LSTFCB
FBC6 LSTOUTRFLG	007F LSTREC	1916 MAKE	194C MAKE0	2397 MAKE00
23AB MAKE2	23D2 MAKE3A	2333 MAKEA0	12DD MAKEFCBINV	289C MAKEFLAG
2359 MAKEX04	FD15 MAKEXFCB	2885 MAXALL	001F MAXEXT	0040 MAXMOD
0000 MD		11B2 MEDIACHANGE		FBF0 MEDIAFLAG	1878 MERGE0
1893 MERGED	18F2 MERGERR	181F MERGEZERO	000E MODNUM	0E29 MOVE
0E2A MOVE0	FF4B MOVEF	FD09 MOVEOUT	FD0C MOVETPA	0000 MPM
18D9 MRGRC1	18DA MRGRC2	FBE6 MULTCNT	0095 MULTFXS	0348 MULTIO
FF45 MULTIOF	2899 MULTNUM	000F NAMLEN	1186 NEWCHECKSUM
0D2E NEWCTLACOL	0033 NFUNCS	000F NFUNCS2	1BD1 NOPBLOCK
0A6F NORMALSTATUS		1EDF NOSELECT	1EE9 NOSELECT0	050D NOTBACKSP
09A0 NOTC	07C5 NOTCTLA	080B NOTCTLB	0735 NOTCTLF	082D NOTCTLG
081E NOTCTLK	079A NOTCTLW	0892 NOTE	0850 NOTH	08A2 NOTP
094D NOTR	0873 NOTRUB	08D5 NOTU	08C4 NOTX	1CCF NOUPDATE
111A NOWRITE	0708 NXTLINE	0020 NXTREC	0000 OFF	288D OFFSET
FBDA OLDDSK	FB90 OLOG	FFFF ON		17DA OPEN	17DD OPEN1
17DE OPENCOPY	1999 OPENMOD	1971 OPENREEL	19A0 OPENREEL0	19B9 OPENREEL1
19BC OPENREEL2	19DA OPENREEL3	19EC OPENREEL4	19C9 OPENRERR
21D3 OPENUSERZERO		21E7 OPENX	2212 OPENX0	224E OPENX0A
2257 OPENX0B	2272 OPENX1	2276 OPENX1A	227B OPENX2	21F7 OPENXA
FBD3 OUTDELIM	026C PAD	FBC8 PAGEMODE	0170 PARSE0	01B6 PARSE6
01D4 PARSE8	0198 PARSEDRV	01AC PARSENAME	01E0 PARSEOK	01FB PARSEPW
0205 PARSEPW1	01CA PARSETYPE	0D76 PASSMSG	0997 PATCH064B	13FF PATCH13FF
2CFC PATCH1DFD	2D0B PATCH1E0C	2D1B PATCH1E1C	2D23 PATCH1E24	2D24 PATCH1E25
2D76 PATCH1E31	2D7D PATCH1E38	2D83 PATCH1E3E	2D30 PATCH2D30	2D39 PATCH2D39
2D3A PATCH2D3A	2D40 PATCH2D40	2D43 PATCH2D43	2D4A PATCH2D4A	2D63 PATCH2D63
2D6A PATCH2D6A	0565 PCTLH	0D41 PERMSG	01F5 PERROR	01F6 PERROR1
2890 PHYMSK	28EF PHYOFF	288F PHYSHF	FBC9 PMDEFAULT	030E PRFCB
0316 PRFCB1	02FB PRFX	030B PRFX1	058C PRINT	FF12 PUNCHF
1FDF PWERROR	28D7 PWFCB	28E4 PWMODE	059C QCONIN	05B6 QCONIN1
FD21 QCONINX	04BD QCONOUTF	2140 QDIRFCB1	FBD5 QFLAG	2132 QSTAMP
2136 QSTAMP1	1D5B RANCLOSE	1DB9 RANDISKREAD
1DC2 RANDISKWRITE		0021 RANREC	28A5 RCOUNT	0E93 RDBUFF
1292 RDDIR	FD14 RDDIRFLAG	095E RDECH0	096D RDECH05	0971 RDECH1
098C RDECH2	130E RDIR	1340 RDIR1	133D RDIR2	06D7 READ
1A3F READDEBLOCK		1308 READDIR	131F READDIR0	1326 READDIR1
1330 READDIR2	09E7 READEN	FF15 READERF	FF27 READF	28B4 READFSW
06C8 READI	0701 READN0	06FF READNX	06DD READX	06E4 READX1
0323 REBOOTE	0329 REBOOTX	032C REBOOTX0	032F REBOOTX1	000F RECCNT
1A19 RECORDOK	1A22 RECORDOK1	0080 RECSIZ	065E REFRESH	066F REFRESH0
068A REFRESH05	0677 REFRESH1	0693 REFRESH2	0699 REFRESH3	FBDE RELOG
1752 RENAME	1788 RENAME0	1798 RENAME1	0913 REP0	092E REP1
FD00 RESBDOS	FD00 RESBDOSPG	FBDD RESEL	1E9A RESELECT	1EB9 RESELECT1
1E90 RESELECTX	245A RESET37X	0DDC RESETCOPYCRONLY		0390 RESETDMA
0393 RESETDMA1	1B50 RESETFWF	0EE6 RESETRELOG	0E19 RESETRR
CP/M RMAC ASSEM 1.1	#146	CP/M BDOS INTERFACE, BDOS, VERSION 3.0 DEC, 1982

162B RESTOREDIRFCB		182D RESTORERC	183B RESTORERC1	16E6 RETBLOCK
16EE RETBLOCK0	2858 RETMON	0E7E RETSELECT	062B REVERSE	16BA RIGHTTST
FB92 RLOG	289C RMF	0DA1 RODERROR	0D67 RODMSG	2863 RODSK
0DA6 ROFERROR	0009 ROFILE	0D58 ROFMSG	28F4 ROOTBCBA	1132 ROTEST
1362 ROTL	1370 ROTR	1CE4 RSEEK	1D50 RSEEK2	1D6B RSEEK3
0DC5 RTNPHYERRS	007F RUBOUT	FBCB RUBOUTACT	28CD RWFXS	2753 RXFCB2
275F RXFCB3	0614 SAVECOL	0D2C SAVECOLUMN	15F5 SAVEDCNTPOS
15EA SAVEDCNTPOS0		15ED SAVEDCNTPOS1
15DE SAVEDCNTPOS2		15FB SAVEDCNTPOSRET		0389 SAVEDMA
28B8 SAVEHASH	28A7 SAVEMOD	0ABE SAVEPOS	28AE SAVERANR	0E09 SAVERR
0E0D SAVERR1	0E12 SAVERR2	28A2 SAVEXFCB	13B0 SCANDM0	13C3 SCANDM1
13C9 SCANDM2	13D8 SCANDM3	13A6 SCANDMA	138B SCANDMAB	1390 SCANDMB
FB9C SCB	FBD6 SCBADD	FB00 SCBPG	28D4 SCFXS	FB7A SCONOUTF
26BF SDL0	26E4 SDL1	2703 SDL2	2719 SDL3	14F7 SEARCH
14FA SEARCH1	28A0 SEARCHA	FBE8 SEARCHCHAIN		157C SEARCHEXT
14F5 SEARCHEXTNUM		15BA SEARCHFIN	2C87 SEARCHH0	2CAE SEARCHH1
2C6B SEARCHHASH	14DD SEARCHI	14E3 SEARCHI1	FBE5 SEARCHL	1557 SEARCHLOOP
15B7 SEARCHMOD	1503 SEARCHN	14F0 SEARCHNAMLEN		152A SEARCHNEXT
15C7 SEARCHNM	1594 SEARCHOK	28BD SEARCHUSER0		28FD SECTOR
2880 SECTPT	FF30 SECTRAN	0F0C SEEK	0F22 SEEK0	0F39 SEEK1
0F50 SEEK2	129A SEEKCOPY	0EF5 SEEKDIR	1DB0 SEEKERR	1D9C SEEKOK
1DA1 SEEKOK1	1DA4 SEEKOK2	28A4 SELDSK	FF1B SELDSKF	1E78 SELECT
0E33 SELECTDISK	0DAB SELERROR	FF51 SELMEMF	0D4A SELMSG	28F8 SEQBCBA
19F5 SEQDISKREAD		1B63 SEQDISKWRITE		0000 SERIAL
1368 SETALLOCBIT		0F03 SETARECORD	23E5 SETARET	2B83 SETBCBSEQ
FF54 SETBNKF	1108 SETCDISK	110B SETCDISK1	1176 SETCDR
0DD5 SETCOPYCRONLY		06BA SETCTLACOLUMN
040C SETCTLSMODE		12B6 SETDATA	190A SETDCNTDBLK
190D SETDCNTDBLK1		12BC SETDIR1	1105 SETDLOG	12BF SETDMA
FF24 SETDMAF	1301 SETENDDIR	1082 SETFCB	1B57 SETFILEWF	1162 SETFWF
2BA6 SETHASH	2BB4 SETHASH1	2BCF SETHASH15	2BDC SETHASH2	0A76 SETLRET1
1241 SETLSN	0237 SETMATCH	2042 SETPW	204E SETPW0	2050 SETPW1
205E SETPW2	2076 SETPW3	2079 SETPW4	1E40 SETRANDOM	17FD SETRC
1810 SETRC1	1812 SETRC2	1815 SETRC3	11E8 SETRLOG	11D3 SETRO
1E0D SETRR	FF21 SETSECF	1E3E SETSIZE	1725 SETSUBMITFLAG
FF1E SETTRKF	243B SETUSRCODE	1903 SETXDCNT	0334 SHELL	0399 SHELLERR
03A2 SHELLRTN	0366 SHELLSP	0372 SHELLSTK	0DF6 SHL3BV	0DF7 SHL3BV1
0F9D SHRPHYSHF	28A3 SINGLE	0273 SKPS	FD0F SRCHHASH	FBF4 STAMP
20DD STAMP1	20E2 STAMP2	20E4 STAMP3	20ED STAMP4	2105 STAMP5
0A72 STARET	2429 STHLRET	0ABD STRTCOL	117F SUBDH	0009 TAB
053D TAB0	0549 TAB1	0528 TABOUT	0537 TABOUT1	0080 TBUFF
FBEC TEMPDRIVE	015C TEST152	0413 TESTCTLSMODE		12FB TESTFFFF
2C64 TESTHASH	120C TESTMEDIAFLAG		1F5F TESTP1
1F58 TESTPENDING		111D TESTVECTOR	1120 TESTVECTOR1
005C TFCB	FF4E TIMEF	1E67 TMPSELECT	04BB TOGGLEL1
04A9 TOGGLELISTCP		28FB TRACK	289A TRANV	00FF TRUE
25FE TRUNC1	2619 TRUNC15	261C TRUNC2	2622 TRUNC3	12EE TSTINVFCB
11FE TSTLOG0	1202 TSTLOG1	11F5 TSTLOGFXS	122B TSTRELOG	FBCC TYPEAHEAD
000D UBYTES	11D1 UPDATECS	2153 UPDATESTAMP		28BE USER0PASS
FD1E USERINFO	FBE0 USRCODE	FBA2 UTILFLGS	FBA1 VERSION	28A8 VRECORD
FB68 WBOOTF	0D91 WILDMSG	0002 WORD	0E9E WRBUFF	129A WRDIR
12A2 WRDIR0	1C9B WRITE	1CB7 WRITE0	FF2A WRITEF	2791 WXFCB0
27A1 WXFCB1	27BE WXFCB2	27C6 WXFCB3	27CA WXFCB4	27E4 WXFCB5
0BC2 XBUFF	FD17 XDCNT	1624 XDCNTEQDCNT		FD19 XDMAAD
28B6 XFCBREADONLY		FF57 XMOVEF	0D26 XPOS	10A4 ZERO
268B ZERODM	2694 ZERODM1	269E ZERODM2	109C ZEROEXTMOD	02EE ZPRINT
048H USE FACTOR
END OF ASSEMBLY

