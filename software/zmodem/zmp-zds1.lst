   1:			;-----------------------------------------------------------------------------
   2:			;
   3:			;	Sample Overlay for ZMP (Z-Modem Program)
   4:			;
   5:			;	Name	ZMÃ©-ZDS1.Z80
   6:			;
   7:			;	Dated Sep 14, 1988
   8:			;	      Nov 27, 2017
   9:			;
  10:			;	Written by -
  11:			;	  Ron Murray, c/o Z-Node 62, 061-9-450-0200, Perth, Western Australia.
  12:			;
  13:			;	Modified to ZMP v1.2 standard rjm 15/9/88
  14:			;	Modified to ZMP v1.3 standard rjm 11/10/88
  15:			;	Modified to ZMP v1.4 standard rjm 20/11/88
  16:			;	Modified to ZMP v1.5 standard rjm 25/3/89
  17:			;
  18:			;
  19:			;-----------------------------------------------------------------------------
  20:			;
  21:			;
  22:			;	System-dependent code overlay for ZMODEM
  23:			;
  24:			;
  25:			;
  26:			;    Insert your own code as necessary in this file. Code contained herein
  27:			; has been written in Z80 code for use with M80 or SLR. Assemble as follows:
  28:			;
  29:			;	SLR ZMO-xx01/h
  30:			;	MLOAD ZMP.COM=ZMODEM.COM,ZMO-xx01.HEX
  31:			; or
  32:			;	M80 =ZMO-xx01.Z80
  33:			;	RELHEX ZMO-xx01
  34:			;	MLOAD ZMP.COM=ZMODEM.COM,ZMO-xx01.HEX
  35:			;
  36:			;
  37:			;       (Don't use L80 without changing the source for assembly as a
  38:			;         cseg file.)
  39:			;
  40:			;-----------------------------------------------------------------------------
  41:			;
  42:			;
  43:			; Notes on modifying this file:
  44:			;
  45:			;    C requires that functions do not change either index register (IX or IY).
  46:			; If your overlay requires either of these to be changed, ensure they are
  47:			; restored to the original values on return.
  48:			;    Since collecting parameters from C functions can be tricky, only change
  49:			; the parts marked 'Insert your own code here'. Do NOT modify the jump
  50:			; table at the start. Do NOT modify the entry/exit sections of each
  51:			; function. Do NOT pass 'GO'. Do NOT collect $200.
  52:			;    Apart from defining modem functions, this file also defines terminal
  53:			; characteristics. Examples provided are for ADM-3A (with a few of my own
  54:			; additions). Modify to suit your own terminal. An inline print routine
  55:			; is provided for printing strings in the usual way: usage is
  56:			;
  57:			;	call	print
  58:			;	db	'required string',0
  59:			;
  60:			;-----------------------------------------------------------------------------
  61:			;
  62:			;
  63:			;    Don't forget to set your clock speed at the clkspd variable.
  64:			;
  65:			;
  66:			;    If you find your overlay exceeds the maximum size (currently 0400h),
  67:			; you will have to contact me for another version. If too many people need
  68:			; to do it, we haven't allowed enough room.
  69:			;
  70:			; Ron Murray 15/8/88
  71:			;
  72:			;
  73:			;
  74:			;---------------------------------------------------------------------------
  75:			
  76:			include common.equ
**** common.equ ****
   1:			;
   2:			;=======================================================================
   3:			;
   4:			; Modular Z80 DarkStar (NE Z80) SysBios
   5:			;
   6:			;=======================================================================
   7:			;
   8:			; Original code:
   9:			; Z80 Nuova Elettronica Monitor 390 su eprom 2532 (4k)
  10:			;
  11:			; Disassembled and reconstructed by
  12:			; Piergiorgio Betti <pbetti@lpconsul.net> on 2005 01 26
  13:			;
  14:			; Latest non modular BIOS is DARKSTAR-MONITOR-0.9.0.asm
  15:			; dated 20140531
  16:			; - Following addition of MultiF-Board doing complete rewrite of the
  17:			;   monitor/BIOS has been started.
  18:			;   Major goals:
  19:			;   o Modularization: Now monitor can grow up to 256kb instead of 4kb
  20:			;     :-)
  21:			;   o Specialized images fitted in memory page (4kb) or multiples
  22:			;   o Full support for new hardware
  23:			;   o I/O rewrite for MODE 2 interrupts
  24:			;   Minor goals:
  25:			;   o Full code clean-up & reoarganization
  26:			; ---------------------------------------------------------------------
  27:			; Revisions:
  28:			; 20140905 - Modified hexadecimal constants to 0xxH format to be widely
  29:			;            accepted by different assemblers
  30:			; 20150714 - Modified to implement serial XON/XOFF and RTS/CTS
  31:			; 20170331 - Fixed uart1 isr routine
  32:			; ---------------------------------------------------------------------
  33:			
  34:			; ---------------------------------------------------------------------
  35:			; SYSBIOS
  36:			;
  37:			; This is the BIOS non-resident portion of the new (banked)
  38:			; BIOS/Monitor for the NE Z80 (aka DarkStar)
  39:			;
  40:			; ---------------------------------------------------------------------
  41:			;
  42:			; Full BIOS memory scheme:
  43:			;
  44:			;	+-----------------+
  45:			;	+    SysCommon    +   <-- Resident portion. Common to all images
  46:			;	+   FC00 - FFFF   +
  47:			;	+-----------------+
  48:			;	+-----------------+   +-----------------+   +-----------------+
  49:			;	+     SysBios     +   +   BootMonitor   +   +     [Other]     +
  50:			;	+   F000 - FBFF   +   +   F000 - FBFF   +   +   F000 - FBFF   +
  51:			;	+-----------------+   +-----------------+   +-----------------+
  52:			;
  53:			;	         ^                     ^                     ^
  54:			;	         |                     |                     |
  55:			;	         ---------------------------------------------
  56:			;	                      Variable section
  57:			;
  58:			; The above are always assembled at ORG F000 and linked and allocated
  59:			; in the EEPROM in this way:
  60:			;
  61:			;	+-----------------+
  62:			;	+    SysCommon    +
  63:			;	+   FC00 - FFFF   +
  64:			;	+     SysBios     +     <-- EEPROM page 1 ($C1000)
  65:			;	+   F000 - FBFF   +
  66:			;	+-----------------+
  67:			;	+-----------------+
  68:			;	+    SysCommon    +
  69:			;	+   FC00 - FFFF   +
  70:			;	+   BootMonitor   +     <-- EEPROM page 0 ($C0000)
  71:			;	+   F000 - FBFF   +
  72:			;	+-----------------+
  73:			;
  74:			; ---------------------------------------------------------------------
  75:			;
  76:			; Define which assembler we are using
  77:			;
  78:			
  79:			; PASMO	equ	1
  80:	0001'         	mzmac	equ	1
  81:			; ZMAC	equ	1			; ZMAC Z80 assembler, not Linux/Unix version
  82:			
  83:			; ... only one at a time can be active (1) ...
  84:			
  85:			;
  86:			; Monitor version numbers (major.minor)
  87:			;
  88:	0033'         	monmaj		equ	'3'
  89:	0036'         	monmin		equ	'6'
  90:			
  91:			;
  92:			; Buffers addresses labels
  93:			;
  94:			
  95:			; -- Global --
  96:	0003'         	iobyte		equ	0003h		; byte: Intel IOBYTE (CP/M 2.2 only)
  97:	0004'         	cdisk		equ	0004h		; byte: Last logged drive
  98:	0006'         	btpasiz		equ	0006h		; word: size of tpa + 1
  99:			;
 100:			; -- Private --
 101:	000B'         	hmempag		equ	000bh		; byte: highest ram page
 102:	000C'         	bbcbank		equ	000ch		; byte: current bank
 103:	000D'         	bbcstck		equ	000dh		; word: current stack
 104:					;
 105:	004F'         	prvtop		equ	004fh		; top of private area storage
 106:	004F'         	colbuf		equ	prvtop		; byte:
 107:	004E'         	dselbf		equ	colbuf-1	; byte: floppy drive select status
 108:								; - bits: 0 = drive 0
 109:								; - bits: 1 = drive 1
 110:								; - bits: 2 = drive 2
 111:								; - bits: 3 = drive 3
 112:								; - bits: 4 = unused
 113:								; - bits: 5 = head select
 114:								; - bits: 6 = motor on (disabled by jumper)
 115:								; - bits: 7 = unused
 116:	004D'         	kbdbyte		equ	dselbf-1	; byte: store keyboard input
 117:	004C'         	miobyte		equ	kbdbyte-1	; byte:
 118:								; - bits: 0: 0 = floppy write		1 = floppy read
 119:								;         1: 0 = no ctrl on keypress	1 = ctrl on keypress
 120:								;         2: 0 = scroll			1 = no scroll
 121:								;         3: 0 = accept lowercase	1 = convert to uppercase
 122:								;         4: 0 = destr. bkspace		1 = non destr. bkspace
 123:								;         5: 0 = console out		1 = serial out
 124:								;         6: 0 = disp. all chars	1 = obscure non punct.
 125:								;         7: 0 = ctrl chr set 1		1 = ctrl chr set 2
 126:	004B'         	tmpbyte		equ	miobyte-1	; byte: transients flags
 127:								; - bits: 0: 0 = high in cursor addressing
 128:								;         1: 0 = ESC catched by ANSI driver
 129:								;         2: 0 = CSI catched by ANSI driver
 130:								;         3: 0 = Two byte code ESC seq. from serial
 131:								;         4: 0 = Plain serial i/o (disable ANSI driver)
 132:								;         5: 0 = store interrupt status (on/off)
 133:								;         6: 0 = floppy no home on err	1 = no home on err
 134:								;         7: 0 = unlock LBA free addressing (unpartitioned)
 135:	004A'         	cursshp		equ	tmpbyte-1	; cursor shape
 136:	0048'         	curpbuf		equ	cursshp-2	; word: cursor position
 137:	0046'         	ftrkbuf		equ	curpbuf-2	; word: track # for i/o (0 - 65535)
 138:	0045'         	fdrvbuf		equ	ftrkbuf-1	; byte: drive number for i/0 (0 - 15)
 139:	0043'         	fsecbuf		equ	fdrvbuf-2	; word: sector # for i/o (1 .. 65535)
 140:	0041'         	frdpbuf		equ	fsecbuf-2	; word: dma address for i/o
 141:	003F'         	fsekbuf		equ	frdpbuf-2	; word: current track number for drive A/B
 142:	003E'         	ram3buf		equ	fsekbuf-1	; byte:
 143:	003D'         	ram2buf		equ	ram3buf-1	; byte:
 144:	003C'         	ram1buf		equ	ram2buf-1	; byte:
 145:	003B'         	ram0buf		equ	ram1buf-1	; byte:
 146:	003A'         	rst7sp3		equ	003ah		; keep clear area of RST38 (RST7)
 147:	0039'         	rst7sp2		equ	0039h
 148:	0038'         	rst7sp1		equ	0038h
 149:	0036'         	vstabuf		equ	rst7sp1-2	; word: Display start addr
 150:	002F'         	rsrvbuf		equ	vstabuf-7	; free 7 byte buffer
 151:	002D'         	appbuf		equ	rsrvbuf-2	; word: generic buffer
 152:	002C'         	copsys		equ	appbuf-1	; Op system type for partition selection
 153:	002B'         	uart0br		equ	copsys-1	; UART 0 baudrate
 154:	002A'         	uart1br		equ	uart0br-1	; UART 1 baudrate
 155:	0029'         	ctc0tc		equ	uart1br-1	; CTC channel 0 time constant
 156:	0028'         	ctc1tc		equ	ctc0tc-1	; CTC channel 1 time constant
 157:	0027'         	timrcon		equ	ctc1tc-1	; timer buf
 158:	0026'         	cnfbyte		equ	timrcon-1	; config byte
 159:								; - bits: 0: 0 = UART1 intr disabled	1 = RST8 redir UART1
 160:								;         1: 1 = XON/XOFF enabled on UART0
 161:								;         2: 1 = RTS/CTS enabled on UART0
 162:								;         3: 0 = unused/reserved
 163:								;         4: 0 = unused/reserved
 164:								;         5: 0 = unused/reserved
 165:								;         6: 0 = unused/reserved
 166:								;         7: 0 = unused/reserved
 167:	000F'         	fifosto		equ	000fh		; fifo queues storage start
 168:	0008'         	fifsize		equ	8		; fifo queue lenght
 169:	000B'         	fifblok		equ	11		; fifo queue size
 170:	000F'         	fifou0		equ	fifosto		; uart 0 queue (alternate console)
 171:	001A'         	fifokb		equ	fifou0+fifblok	; keyboard queue
 172:	0025'         	fifoend		equ	fifokb+fifblok	; fifo blocks end
 173:			;
 174:	3000'         	bldoffs		equ	3000h		; place for disk bootloader
 175:			
 176:			;
 177:			; Some commodity equs
 178:			;
 179:	000D'         	cr		equ	0dh		; ascii CR & LF
 180:	000A'         	lf		equ	0ah
 181:	000C'         	ff		equ	0ch		; FORM FEED (clear screen)
 182:	001B'         	esc		equ	1bh		; ESCape
 183:	0011'         	xonc		equ	11h		; Xon
 184:	0013'         	xofc		equ	13h		; Xoff
 185:	FFFF'         	true		equ	-1
 186:	0000'         	false		equ	0
 187:	0100'         	tpa		equ	0100h		; TPA base address (for CP/M)
 188:			
 189:			;
 190:			; Modules equs
 191:			;
 192:				; delay
 193:	00F6'         	mscnt		equ	246
 194:				; mmu
 195:	000D'         	mmutstpage	equ	0dh		; logical page used for sizing
 196:	D000'         	mmutstaddr	equ	mmutstpage<<12	; logical page used for sizing
 197:			
 198:			; Conventionally all bios/monitor images start at $F000.
 199:			; Except for special cases all code is copied to ram @ $F000.
 200:			; In this case eeprom page 0 is directly mapped into logical space
 201:			; by hardware so we can initialize the system at cold boot.
 202:			;
 203:			; We assume to initialize MMU as follow:
 204:			;
 205:			; +--------+
 206:			; |  F000  |	-> $C0000  eeprom page 0
 207:			; +--------+
 208:			; +--------+
 209:			; |  EFFF  |
 210:			; +--------+
 211:			;     ...       -> $00000 to $0EFFF ram
 212:			; +--------+
 213:			; |  0000  |
 214:			; +--------+
 215:			;
 216:			
 217:			
 218:			; include	modules/hwequs.inc.asm
 219:			; Hardware equates
 220:			; ---------------------------------------------------------------------
 221:			
 222:			; ---------------------------------------------------------------------
 223:			; LX529 VIDEO BOARD:
 224:			; ---------------------------------------------------------------------
 225:	0080'         	crtbase		equ	80h
 226:				; RAM0 for ascii chars & semi6. Combined with RAM1 and RAM2 for graphics
 227:	0080'         	crtram0dat	equ	crtbase		; RAM0 access: PIO0 port A data register
 228:	0082'         	crtram0cnt	equ	crtbase+2	; RAM0 access: PIO0 port A control register
 229:				; Printer port
 230:	0081'         	crtprntdat	equ	crtbase+1	; PRINTER (output): PIO0 port B data register
 231:	0083'         	crtprntcnt	equ	crtbase+3	; PRINTER (output): PIO0 port B control register
 232:								; STROBE is generated by hardware
 233:				; RAM1 for graphics. (pixel index by RAM0+RAM1+RAM2)
 234:	0084'         	crtram1dat	equ	crtbase+4	; RAM1 access: PIO1 port A data register
 235:	0086'         	crtram1cnt	equ	crtbase+6	; RAM1 access: PIO1 port A control register
 236:				; Keyboard port (negated). Bit 7 is for strobe
 237:	0085'         	crtkeybdat	equ	crtbase+5	; KEYBOARD (input): PIO1 port B data register
 238:	0087'         	crtkeybcnt	equ	crtbase+7	; KEYBOARD (input): PIO1 port B control register
 239:	0007'         	keybstrbbit	equ	7		; Strobe bit
 240:				; RAM2 for graphics. (pixel index by RAM0+RAM1+RAM2)
 241:	0088'         	crtram2dat	equ	crtbase+8	; RAM2 access: PIO2 port A data register
 242:	008A'         	crtram2cnt	equ	crtbase+10	; RAM2 access: PIO2 port A control register
 243:				; Service/User port
 244:	0089'         	crtservdat	equ	crtbase+9	; Service (i/o): PIO2 port B data register
 245:	008B'         	crtservcnt	equ	crtbase+11	; Service (i/o): PIO2 port B control register
 246:	0000'         	prntbusybit	equ	0		; Printer BUSY bit		(in)	1
 247:	0001'         	crtwidthbit	equ	1		; Set 40/80 chars per line	(out)	0
 248:	0002'         	pio2bit2	equ	2		; user 1 (input)		(in)	1
 249:	0003'         	pio2bit3	equ	3		; user 2 (input)		(in)	1
 250:	0004'         	pio2bit4	equ	4		; user 3 (input)		(in)	1
 251:	0005'         	clksclk		equ	5		; DS1320 clock line		(out)	0
 252:	0006'         	clkio		equ	6		; DS1320 I/O line		(i/o)	1
 253:	0007'         	clkrst		equ	7		; DS1320 RST line		(out)	0
 254:				; normal set for PIO2 (msb) 01011101 (lsb) that is hex $5D
 255:								; Other bits available to user
 256:				; RAM3 control chars/graphics attributes
 257:	008E'         	crtram3port	equ	crtbase+14	; RAM3 port
 258:	0000'         	crtblinkbit	equ	0		; Blink
 259:	0001'         	crtrevrsbit	equ	1		; Reverse
 260:	0002'         	crtunderbit	equ	2		; Underline
 261:	0003'         	crthilitbit	equ	3		; Highlight
 262:	0004'         	crtmodebit	equ	4		; ASCII/GRAPHIC mode
 263:				; Beeper port
 264:	008F'         	crtbeepport	equ	crtbase+15	; Beeper port
 265:				; 6545 CRT controller ports
 266:	008C'         	crt6545adst	equ	crtbase+12	; Address & Status register
 267:	008D'         	crt6545data	equ	crtbase+13	; Data register
 268:				; Cursor modes
 269:	0040'         	blislowblok	equ	40h		; Blink, slow, block
 270:	004A'         	blislowline	equ	4ah		; Blink, slow, line
 271:	0060'         	blifastblok	equ	60h		; Blink, fast, block
 272:	006A'         	blifastline	equ	6ah		; Blink, fast, line
 273:	0020'         	cursoroff	equ	20h		; Off
 274:	0000'         	fixblock	equ	00h		; Fixed, block
 275:	000A'         	cursoron	equ	0ah		; On
 276:				; 6545 register index
 277:	0000'         	vr0.hrtot	equ	0		; Total horizontal chars
 278:	0001'         	vr1.hrdis	equ	1		; Total horizontal displayed ch.
 279:	0002'         	vr2.hrsyncpos	equ	2		; Horizontal sync position
 280:	0003'         	vr3.hrvrsyncw	equ	3		; Hsync and vsync width
 281:								; (bit 0-3 hsync, bit 4-7 vsync)
 282:	0004'         	vr4.vrchrow	equ	4		; Total ch. rows in a frame
 283:	0005'         	vr5.vradj	equ	5		; Vertical additional scan lines
 284:	0006'         	vr6.vrdisrows	equ	6		; Displayed char rows
 285:	0007'         	vr7.vrsyncpos	equ	7		; Vertical sync position
 286:	0008'         	vr8.crtmode	equ	8		; Operating mode
 287:								; 76543210
 288:								; ||||||++ Interlace
 289:								; |||||+-- Addressing bin/rowcol
 290:								; ||||+--- Memory shared/transp.
 291:								; |||+---- Display delay no/yes
 292:								; ||+----- Cursor delay no/yes
 293:								; |+------ Pin 34 addr/strobe
 294:								; |------- Access blank/interl.
 295:	0009'         	vr9.scanlines	equ	9		; Scan lines per char row
 296:	000A'         	vr10.crstart	equ	10		; Cursor start line bit 0-4
 297:								; bit 6-5
 298:								;     0 0 = No blink
 299:								;     0 1 = No cursor
 300:								;     1 0 = Blink 1/16 rate
 301:								;     1 1 = Blink 1/32 rate
 302:	000B'         	vr11.crend	equ	11		; Cursor end line bit 0-4
 303:	000C'         	vr12.dstarth	equ	12		; Display start address high
 304:	000D'         	vr13.dstartl	equ	13		; Display start address low
 305:	000E'         	vr14.curposh	equ	14		; Cursor position high
 306:	000F'         	vr15.curposl	equ	15		; Cursor position low
 307:	0010'         	vr16.lpenh	equ	16		; LPEN position high
 308:	0011'         	vr17.lpenl	equ	17		; LPEN position low
 309:	0012'         	vr18.updaddrh	equ	18		; Update (next char) address H
 310:	0013'         	vr19.updaddrl	equ	19		; Update (next char) address L
 311:	001F'         	vr31.dummy	equ	31		; Dummy register for transparent
 312:								; addressing update checkin
 313:	07CF'         	endvid		equ	07cfh		; end video cursor (25*80)
 314:			; ---------------------------------------------------------------------
 315:			; LX390 FDC CONTROLLER:
 316:			; ---------------------------------------------------------------------
 317:	00D0'         	fdcbase		equ	0d0h
 318:	00D0'         	fdccmdstatr	equ	fdcbase		; Command and status register
 319:	00D1'         	fdctrakreg	equ	fdcbase+1	; Track register
 320:	00D2'         	fdcsectreg	equ	fdcbase+2	; Sector register
 321:	00D7'         	fdcdatareg	equ	fdcbase+7	; Data register *** Verificare che sia $d7
 322:	00D6'         	fdcdrvrcnt	equ	fdcbase+6	; Driver select/control register
 323:			;
 324:	0007'         	fdcrestc	equ	00000111b	; 1771 restore (seek to trak 0) cmd
 325:	0016'         	fdcseekc	equ	00010110b	; seek cmd
 326:	0088'         	fdcreadc	equ	10001000b	; read cmd
 327:	00A8'         	fdcwritc	equ	10101000b	; write cmd
 328:	00D0'         	fdcreset	equ	11010000b	; fdc reset immediate cmd
 329:			;
 330:			; ---------------------------------------------------------------------
 331:			; LX389: PARALLEL INTERFACE
 332:			; ---------------------------------------------------------------------
 333:			; alternate printer port
 334:	0003'         	altprnprt	equ	03h
 335:			;
 336:			; parallel port PC link
 337:	0003'         	ppdatap		equ	03h		; Data port
 338:	0002'         	ppcntrp		equ	02h		; Control port
 339:	0000'         	ppstrob		equ	0		; Strobe bit
 340:	0001'         	ppakstb		equ	1		; Acknowledge/Stop bit
 341:			;
 342:	0000'         	ppdini		equ	00h		; 00000000 Dnl Init byte
 343:	0004'         	ppdrdy		equ	04h		; 00000100 Dnl Ready
 344:	0006'         	ppdstp		equ	06h		; 00000110 Dnl Stop
 345:	0002'         	ppdokg		equ	02h		; 00000010 Dnl Ok Go
 346:	0001'         	ppuini		equ	01h		; 00000001 Upl Init byte
 347:	0005'         	ppurdy		equ	05h		; 00000101 Upl Ready
 348:	0007'         	ppuack		equ	07h		; 00000111 Upl Acknowledge
 349:	0003'         	ppuokg		equ	03h		; 00000011 Upl Ok Go
 350:			;
 351:			; virtual disks (PC-linked over parallel port)
 352:	0000'         	vdrdsec		equ	0		; read sector command
 353:	0001'         	vdwrsec		equ	1		; write sector command
 354:	000A'         	vdbufsz		equ	10		; 10 bytes block
 355:			; ---------------------------------------------------------------------
 356:			; MULTF-BOARD: MMU, IDE, SERIAL, CTC
 357:			; ---------------------------------------------------------------------
 358:			; -- I/O --
 359:	0020'         	mmuport		equ	20h
 360:	0021'         	menaprt		equ	21h
 361:			; -- Map --
 362:	00C0'         	eepage0		equ	0c0h		; page 0 of eeprom
 363:	F000'         	eepsta		equ	0f000h		; eeprom location after MMU reset
 364:	00EF'         	mmtpapag	equ	(eepsta>>8)-1	; TPA top page (256 bytes pages)
 365:	00FF'         	imtpag		equ	0ffh		; eeprom page with image table
 366:	0400'         	imtsiz		equ	1024		; size
 367:	E000'         	ramtbl		equ	0e000h		; ram table location
 368:	0030'         	tblblk		equ	48		; block size
 369:	0014'         	maxblk		equ	20		; max images
 370:	03C0'         	rtbsiz		equ	tblblk * maxblk	; real table size
 371:								; A table block is:
 372:	0008'         	tnamelen	equ	8		;	name		: 8 bytes
 373:	0002'         	tpagelen	equ	2		;	page offset	: 2 bytes
 374:	0004'         	tiaddrlen	equ	4		;	image address	: 4 bytes
 375:	0004'         	tsizelen	equ	4		;	image size	: 4 bytes
 376:	0014'         	tdesclen	equ	20		;	description	: 20 bytes
 377:			; -- IDE --
 378:	00E0'         	ideporta	equ	0e0h		; lower 8 bits of IDE interface
 379:	00E1'         	ideportb	equ	0e1h		; upper 8 bits of IDE interface
 380:	00E2'         	ideportc	equ	0e2h		; control lines for IDE interface
 381:	00E3'         	ideportctrl	equ	0e3h		; 8255 configuration port
 382:			
 383:	0092'         	readcfg8255	equ	10010010b	; Set 8255 IDEportC to output, IDEportA/B input
 384:	0080'         	writecfg8255	equ	10000000b	; Set all three 8255 ports to output mode
 385:			;IDE control lines for use with IDEportC.
 386:	0001'         	idea0line	equ	01h		; direct from 8255 to IDE interface
 387:	0002'         	idea1line	equ	02h		; direct from 8255 to IDE interface
 388:	0004'         	idea2line	equ	04h		; direct from 8255 to IDE interface
 389:	0008'         	idecs0line	equ	08h		; inverter between 8255 and IDE interface
 390:	0010'         	idecs1line	equ	10h		; inverter between 8255 and IDE interface
 391:	0020'         	idewrline	equ	20h		; inverter between 8255 and IDE interface
 392:	0040'         	iderdline	equ	40h		; inverter between 8255 and IDE interface
 393:	0080'         	iderstline	equ	80h		; inverter between 8255 and IDE interface
 394:			;Symbolic constants for the IDE Drive registers
 395:	0008'         	regdata		equ	idecs0line
 396:	0009'         	regerr		equ	idecs0line + idea0line
 397:	000A'         	regseccnt	equ	idecs0line + idea1line
 398:	000B'         	regsector	equ	idecs0line + idea1line + idea0line
 399:	000C'         	regcyllsb	equ	idecs0line + idea2line
 400:	000D'         	regcylmsb	equ	idecs0line + idea2line + idea0line
 401:	000E'         	regshd		equ	idecs0line + idea2line + idea1line		;(0EH)
 402:	000F'         	regcommand	equ	idecs0line + idea2line + idea1line + idea0line	;(0FH)
 403:	000F'         	regstatus	equ	idecs0line + idea2line + idea1line + idea0line
 404:	0016'         	regcontrol	equ	idecs1line + idea2line + idea1line
 405:	0016'         	regastatus	equ	idecs1line + idea2line + idea1line
 406:			;IDE Command Constants.
 407:	0010'         	cmdrecal	equ	010h
 408:	0020'         	cmdread		equ	020h
 409:	0030'         	cmdwrite	equ	030h
 410:	0091'         	cmdinit		equ	091h
 411:	00EC'         	cmdid		equ	0ech
 412:	00E0'         	cmdspindown	equ	0e0h
 413:	00E1'         	cmdspinup	equ	0e1h
 414:			; -- 16C550 UARTS --
 415:	00C0'         	uart0base	equ	0c0h		; Port base address for 0
 416:	00C8'         	uart1base	equ	0c8h		; Port base address for 1
 417:	00C0'         	uart0		equ	uart0base	; Select UART 0
 418:	00C8'         	uart1		equ	uart1base	; Select UART 1
 419:	0000'         	r0rxtx		equ	0		; (r/w) RXD/TXD Transmit/Receive Buffer
 420:	0000'         	r0brdl		equ	0		; (r/w) DLL  if bit 7 of LCR is set: Baud Rate Divisor LSB
 421:	0001'         	r1ier		equ	1		; (r/w) IER - Interrupt Enable Register
 422:	0001'         	r1brdm		equ	1		; (r/w) DLM if bit 7 of LCR is set: Baud Rate Divisor MSB
 423:	0002'         	r2iir		equ	2		; (r)   IIR - Interrupt Identification Register
 424:	0002'         	r2fcr		equ	2		; (w)   FCR - FIFO Control Register
 425:	0003'         	r3lcr		equ	3		; (r/w) LCR - Line Control Register
 426:	0004'         	r4mcr		equ	4		; (r/w) MCR - Modem Control Register
 427:	0005'         	r5lsr		equ	5		; (r)   LSR - Line Status Register
 428:	0006'         	r6msr		equ	6		; (r)   MSR - Modem Status Register
 429:	0007'         	r7spr		equ	7		; (r/w) SPR - Scratch Pad Register
 430:				; fifo
 431:	0007'         	ufifo1		equ	00000111b	; 1 char
 432:	0047'         	ufifo4		equ	01000111b	; 4 char
 433:	0087'         	ufifo8		equ	10000111b	; 8 char
 434:	00C7'         	ufifo14		equ	11000111b	; 14 char
 435:				; speeds:
 436:	0060'         	uart1200	equ	96		; = 1,843,200 / ( 16 x 1200 )
 437:	0030'         	uart2400	equ	48		; = 1,843,200 / ( 16 x 2400 )
 438:	0018'         	uart4800	equ	24		; = 1,843,200 / ( 16 x 4800 )
 439:	000C'         	uart9600	equ	12		; = 1,843,200 / ( 16 x 9600 )
 440:	0006'         	uart19k2	equ	06		; = 1,843,200 / ( 16 x 19,200 )
 441:	0003'         	uart38k4	equ	03		; = 1,843,200 / ( 16 x 38,400 )
 442:	0002'         	uart57k6	equ	02		; = 1,843,200 / ( 16 x 57,600 )
 443:	0001'         	uart115k2	equ	01		; = 1,843,200 / ( 16 x 115,200 )
 444:			
 445:	0006'         	u0defspeed	equ	uart19k2	; UART 0 default speed
 446:	000C'         	u1defspeed	equ	uart9600	; UART 1 default speed
 447:			; -- Z80CTC --
 448:	00E8'         	ctcbase		equ	0e8h
 449:	00E8'         	ctcchan0	equ	ctcbase+0	; Channel 1 - Free
 450:	00E9'         	ctcchan1	equ	ctcbase+1	; Channel 2 - System Timer
 451:	00EA'         	ctcchan2	equ	ctcbase+2	; Channel 3 - UART 1 Interrupt
 452:	00EB'         	ctcchan3	equ	ctcbase+3	; Channel 4 - UART 0 Interrupt
 453:	0020'         	ctc0tchi	equ	32		; hi speed chan. 0 tc: 4Mhz / 256 / 32 = 488.28 Hz
 454:	0005'         	ctc1tc100hz	equ	5		; lo speed chan. 1 tc: 488.28 Hz / 5 = ~ 97.6 Hz
 455:	000A'         	ctc1tc50hz	equ	10		; lo speed chan. 1 tc: 488.28 Hz / 10 = ~ 48.8 Hz
 456:	0013'         	ctc1tc25hz	equ	19		; lo speed chan. 1 tc: 488.28 Hz / 19 = ~ 25 Hz
 457:	0030'         	ctc1tc10hz	equ	48		; lo speed chan. 1 tc: 488.28 Hz / 48 = ~ 10 Hz
 458:	00F4'         	ctc1tc2hz	equ	244		; lo speed chan. 1 tc: 488.28 Hz / 244 = ~ 2 Hz
 459:	0013'         	syshertz	equ	ctc1tc25hz	; System timer hertz
 460:			; -- EEPROM --
 461:	0001'         	eep29ee		equ	01h		; type 29EE020
 462:	0002'         	eep29xe		equ	02h		; type 29LE020 or 29VE020
 463:	0004'         	eep29c		equ	04h		; type 29C020
 464:	0008'         	eepunsupp	equ	08h		; unsupported
 465:	0010'         	eeproglock	equ	10h		; programming locked
 466:				;
 467:	0080'         	eerineprom	equ	80h		; tried to program eeprom running inside it
 468:			
 469:			;
 470:			; MMU organization
 471:			;
 472:			; MMU manage 16 4kb pages in Z80 address space (logical)
 473:			; It can assign any of 256 4k pages (physical) from its
 474:			; 1Mb address space.
 475:			;
 476:			; To load phisycal page XXh to logical page (in CPU address space) Y,
 477:			; you should consider that MMU is at a fixed address 20h and that
 478:			; logical 4K page Y is derived in the MMU by the usage of A12,A13,A14
 479:			; and A15 address lines during an I/O instruction.
 480:			;
 481:			; So to address phys. ram page 00h at the top of logical space page Fh
 482:			; you need to have Fh * on top address lines * because this address
 483:			; is the index to MMU page.
 484:			;
 485:			; So:
 486:			;
 487:			; 	LD	A,00h		<--- phis. page number	00xxxh (4k page)
 488:			; 	LD	B,F0h		<--- log. page number 	 Fxxxh (cpu page)
 489:			; 	LD	C,20h		<--- MMU I/O address
 490:			; 	OUT	(C),A
 491:			; 	RET
 492:			;
 493:			; The OUT instruction place:
 494:			; A on data lines D0-D7
 495:			; Fh (from B register) on A12-A15
 496:			; on port 20h (C register)
 497:			;
 498:			;
 499:			; Memory is organized as follow:
 500:			;
 501:			;	Slot 1	-> RAM	  -> 512k from 00000h to 7ffffh (mandatory)
 502:			;	Slot 2	-> RAM	  -> 128k from 80000h to 9ffffh (option 1)
 503:			;	Slot 2	-> RAM    -> 256k from 80000h to bffffh (option 2)
 504:			;	Slot 3	-> EEPROM -> 256k from c0000h to fffffh (mandatory)
 505:			;
 506:			
 507:			;*************************************
 508:			; Production / Testing
 509:	0000'         	bbdebug		equ	false
 510:			;*************************************
 511:			
 512:			;-------------------------------------
 513:			; Segments, pages locations
 514:			
 515:	0000'         	if	bbdebug
 521:			else
 522:			
 523:	00C0'         	bbimgp		equ	eepage0		; Image location
 524:	000E'         	bbappp		equ	0eh
 525:	000F'         	bbpag		equ	0fh		; Base page location
 526:			
 527:			endif
 528:			
 529:	000D'         	trnpag		equ	0dh		; Page used for transient MMU ops
 530:	F000'         	bbbase		equ	bbpag << 12	; non resident base address
 531:	FC00'         	bbcomn		equ	bbbase + 0c00h	; resident portion address
 532:			
 533:			; sysbase 	equ	bbbase		; use this to have 60K TPA
 534:			; SYSBASE 	equ	BBCOMN		; use this to have 63K TPA
 535:			
 536:			;-------------------------------------
**** zmp-zds1.z80 ****
  77:			include darkstar.equ
**** darkstar.equ ****
   1:			;****** Equ's file autogenerated by genequs ver: 1.0
   2:			;****** Input files:
   3:			;****** SysCommon.lst
   4:	FE76'         	TX0            	EQU	0FE76H
   5:	FDC4'         	FIN            	EQU	0FDC4H
   6:	FE78'         	TX01           	EQU	0FE78H
   7:	FD89'         	DLY1           	EQU	0FD89H
   8:	FD87'         	DLY2           	EQU	0FD87H
   9:	FDE1'         	FOUT           	EQU	0FDE1H
  10:	FE64'         	U1NUL          	EQU	0FE64H
  11:	FE25'         	U0ISR          	EQU	0FE25H
  12:	FE5B'         	U1ISR          	EQU	0FE5BH
  13:	FD85'         	DELAY          	EQU	0FD85H
  14:	FE50'         	UISRE          	EQU	0FE50H
  15:	FDB5'         	FSTAT          	EQU	0FDB5H
  16:	FE35'         	UISRI          	EQU	0FE35H
  17:	FE6E'         	DOSTX          	EQU	0FE6EH
  18:	FC4B'         	BBU1ST         	EQU	0FC4BH
  19:	FC45'         	BBU1RX         	EQU	0FC45H
  20:	FC3F'         	BBU1TX         	EQU	0FC3FH
  21:	FD29'         	BBEXEC         	EQU	0FD29H
  22:	FCFF'         	BBHDRD         	EQU	0FCFFH
  23:	FD6A'         	BBVOID         	EQU	0FD6AH
  24:	FE91'         	UASTKB         	EQU	0FE91H
  25:	FD6B'         	MMPMAP         	EQU	0FD6BH
  26:	FE0F'         	INTRDI         	EQU	0FE0FH
  27:	FC2D'         	SCONIN         	EQU	0FC2DH
  28:	FC15'         	VCONIN         	EQU	0FC15H
  29:	FCDB'         	BBDIV16        	EQU	0FCDBH
  30:	FCF9'         	BBHDWR         	EQU	0FCF9H
  31:	FD78'         	MMGETP         	EQU	0FD78H
  32:	FDFE'         	INTREN         	EQU	0FDFEH
  33:	FE84'         	RLDROM         	EQU	0FE84H
  34:	FCE1'         	BBMUL16        	EQU	0FCE1H
  35:	FC00'         	SYSCOM         	EQU	0FC00H
  36:	FE8F'         	UASTAV         	EQU	0FE8FH
  37:	FE19'         	SYTIMR         	EQU	0FE19H
  38:	FC33'         	SCONST         	EQU	0FC33H
  39:	FC1B'         	VCONST         	EQU	0FC1BH
  40:	FE6C'         	SRXRSM         	EQU	0FE6CH
  41:	FE68'         	SRXSTP         	EQU	0FE68H
  42:	FC39'         	BBU0INI        	EQU	0FC39H
  43:	FC51'         	BBU1INI        	EQU	0FC51H
  44:	FC87'         	BBFREAD        	EQU	0FC87H
  45:	FD23'         	BBEIDCK        	EQU	0FD23H
  46:	FD05'         	BBHDGEO        	EQU	0FD05H
  47:	FEBF'         	BBSTACK        	EQU	0FEBFH
  48:	FC81'         	BBFHOME        	EQU	0FC81H
  49:	FD94'         	BBCONIN        	EQU	0FD94H
  50:	FC27'         	CRDUREG        	EQU	0FC27H
  51:	FFF0'         	SINTVEC        	EQU	0FFF0H
  52:	FEBF'         	SYSCMLO        	EQU	0FEBFH
  53:	FE22'         	VOIDISR        	EQU	0FE22H
  54:	FC9F'         	BBSTTIM        	EQU	0FC9FH
  55:	FDAA'         	BBCONST        	EQU	0FDAAH
  56:	FC27'         	SCONOUT        	EQU	0FC27H
  57:	FC0F'         	VCONOUT        	EQU	0FC0FH
  58:	FCE7'         	BBOFFCAL       	EQU	0FCE7H
  59:	FC57'         	BBINICTC       	EQU	0FC57H
  60:	FE9B'         	BBSTBASE       	EQU	0FE9BH
  61:	FC5D'         	BBRESCTC       	EQU	0FC5DH
  62:	FCA5'         	BBRDTIME       	EQU	0FCA5H
  63:	FD5A'         	BBCALRET       	EQU	0FD5AH
  64:	FCB7'         	BBDMASET       	EQU	0FCB7H
  65:	FC00'         	BBJTOBNK       	EQU	0FC00H
  66:	FCBD'         	BBDSKSEL       	EQU	0FCBDH
  67:	FCED'         	BBHDINIT       	EQU	0FCEDH
  68:	FCB1'         	BBSECSET       	EQU	0FCB1H
  69:	FD0B'         	BBHDBOOT       	EQU	0FD0BH
  70:	FC69'         	BBUPLCHR       	EQU	0FC69H
  71:	FC99'         	BBPRNCHR       	EQU	0FC99H
  72:	FCC9'         	BBVCPMBT       	EQU	0FCC9H
  73:	FC93'         	BBFLOPIO       	EQU	0FC93H
  74:	FD1D'         	BBEPMNGR       	EQU	0FD1DH
  75:	FCCF'         	BBSIDSET       	EQU	0FCCFH
  76:	FD11'         	BBLDPART       	EQU	0FD11H
  77:	FC75'         	BBRDVDSK       	EQU	0FC75H
  78:	FC8D'         	BBFWRITE       	EQU	0FC8DH
  79:	FCC3'         	BBCPBOOT       	EQU	0FCC3H
  80:	FC21'         	BBCURSET       	EQU	0FC21H
  81:	FCAB'         	BBTRKSET       	EQU	0FCABH
  82:	FC7B'         	BBWRVDSK       	EQU	0FC7BH
  83:	FD9F'         	BBCONOUT       	EQU	0FD9FH
  84:	FCF3'         	BBDRIVEID      	EQU	0FCF3H
  85:	FC63'         	BBPSNDBLK      	EQU	0FC63H
  86:	FC03'         	BBCRTCINI      	EQU	0FC03H
  87:	FC6F'         	BBPRCVBLK      	EQU	0FC6FH
  88:	FC09'         	BBCRTFILL      	EQU	0FC09H
  89:	FCD5'         	BBFDRVSEL      	EQU	0FCD5H
  90:	FD17'         	BBDPRMSET      	EQU	0FD17H
  91:			;****** EOF ***
  92:			
**** zmp-zds1.z80 ****
  78:			
  79:	0000'         	false	equ	0
  80:	FFFF'         	true	equ	not false
  81:			
  82:			;------------------------------------------------------------------------------
  83:			
  84:			; User-set variables:
  85:			
  86:	0004'         	clkspd	equ	4		; Processor clock speed in MHz
  87:	0000'         	debug	equ	false		; to allow debugging of overlay with Z8E etc.
  88:			
  89:			;Set the following two equates to the drive and user area which will contain
  90:			;   ZMP's .OVR files, .CFG file, .FON file and .HLP file. Set both to zero
  91:			;   (null) to locate them on the drive from which ZMP was invoked.
  92:			
  93:	0000'         	overdrive	equ	0	; Drive to find overlay files on ('A'-'P')
  94:	0000'         	overuser	equ	0	; User area to find files
  95:			
  96:			;------------------------------------------------------------------------------
  97:			
  98:			
  99:			; NOT user-set variables
 100:			
 101:							; origin of this overlay
 102:	013D'         	userdef	equ	013Dh
 103:			
 104:							; subsequent revisions.
 105:	003C'         	mspeed	equ	03ch		; location of current baud rate.
 106:	0400'         	ovsize	equ	0400h		; max size of this overlay
 107:			
 108:				.z80			; use z80 code
 109:				aseg			; absolute
 110:			
 111:	0000          		 if	debug
 113:				 else
 114:	013D          		org	userdef
 115:				 endif
 116:			
 117:			
 118:	001B          	esc	equ	1bh
 119:	0011          	ctrlq	equ	11h
 120:	000D          	cr	equ	0dh
 121:	000A          	lf	equ	0ah
 122:	0005          	bdos	equ	5
 123:			
 124:			
 125:	013D          	codebgn	equ	$
 126:			
 127:			;Jump table for the overlay: do NOT change this
 128:	013D          	jump_tab:
 129:	013D  C3A301  		jp	scrnpr		; screen print
 130:	0140  C3B702  		jp	mrd		; modem read with timeout
 131:	0143  C3CE01  		jp	mchin		; get a character from modem
 132:	0146  C3D801  		jp	mchout		; send a character to the modem
 133:	0149  C3E401  		jp	mordy		; test for tx buffer empty
 134:	014C  C3E801  		jp	mirdy		; test for character received
 135:	014F  C3F401  		jp	sndbrk		; send break
 136:	0152  C35502  		jp	cursadd		; cursor addressing
 137:	0155  C3AD02  		jp	cls		; clear screen
 138:	0158  C3AE02  		jp	invon		; inverse video on
 139:	015B  C3AF02  		jp	invoff		; inverse video off
 140:	015E  C3B002  		jp	hide		; hide cursor
 141:	0161  C3B102  		jp	show		; show cursor
 142:	0164  C3B202  		jp	savecu		; save cursor position
 143:	0167  C3B302  		jp	rescu		; restore cursor position
 144:	016A  C3B402  		jp	mint		; service modem interrupt
 145:	016D  C3B502  		jp	invec		; initialise interrupt vectors
 146:	0170  C3B602  		jp	dinvec		; de-initialise interrupt vectors
 147:	0173  C3FB01  		jp	mdmerr		; test uart flags for error
 148:	0176  C30102  		jp	dtron		; turn DTR on
 149:	0179  C30202  		jp	dtroff		; turn DTR OFF
 150:	017C  C30302  		jp	init		; initialise uart
 151:	017F  C3EB02  		jp	wait		; wait seconds
 152:	0182  C32A03  		jp	mswait		; wait milliseconds
 153:	0185  C3C101  		jp	userin		; user-defined entry routine
 154:	0188  C3CA01  		jp	userout		; user-defined exit routine
 155:	018B  C34903  		jp	getvars		; get system variables
 156:	018E  C34702  		jp	setport		; set port (0 or 1)
 157:			
 158:			; Spare jumps for compatibility with future versions
 159:	0191  C3C001  		jp	spare		; spare for later use
 160:	0194  C3C001  		jp	spare		; spare for later use
 161:	0197  C3C001  		jp	spare		; spare for later use
 162:	019A  C3C001  		jp	spare		; spare for later use
 163:	019D  C3C001  		jp	spare		; spare for later use
 164:	01A0  C3C001  		jp	spare		; spare for later use
 165:			
 166:			;
 167:			; Main code starts here
 168:			;
 169:			;Screen print function
 170:	01A3          	scrnpr:
 171:							; <== Insert your own code here
 172:	01A3  CDD102  		call	print
 173:	01A6  46756E63		db	'Function not supported.',cr,lf,0
	      74696F6E
	      206E6F74
	      20737570
	      706F7274
	      65642E0D
	      0A00
 174:							; <== End of your own code
 175:	01C0          	spare:
 176:	01C0  C9      		ret
 177:			
 178:			; User-defined entry routine: leave empty if not needed
 179:	01C1          	userin:
 180:	01C1  CD5103  		call	attach_1_legacy		; init
 181:	01C4  3E87    		ld	a,ufifo8
 182:	01C6  CD8B03  		call	set_fifo1
 183:	01C9  C9      		ret
 184:			
 185:			; User-defined exit routine: leave empty if not needed
 186:	01CA          	userout:
 187:	01CA  CD7203  		call	detach_1_legacy		; deinit
 188:	01CD  C9      		ret
 189:			
 190:			
 191:			;Get a character from the modem: return in HL
 192:	01CE          	mchin:
 193:	01CE  C5      		push	bc
 194:							; <== Insert your own code here
 195:			
 196:	01CF  CDAC03  		call	srlin1
 197:							; <== End of your own code
 198:			
 199:	01D2  6F      		ld	l,a		; put in HL
 200:	01D3  2600    		ld	h,0
 201:	01D5  B7      		or	a		; set/clear Z
 202:	01D6  C1      		pop	bc
 203:	01D7  C9      		ret
 204:			
 205:			;Send a character to the modem
 206:	01D8          	mchout:
 207:	01D8  210200  		ld	hl,2		; get the character
 208:	01DB  39      		add	hl,sp
 209:	01DC  7E      		ld	a,(hl)
 210:							; <== Insert your own code here
 211:	01DD  C5      		push	bc
 212:	01DE  79      		ld	a,c
 213:	01DF  CDEB03  		call	srlout1
 214:	01E2  C1      		pop	bc
 215:							; <== End of your own code
 216:	01E3  C9      		ret			; done
 217:			
 218:			;Test for output ready: return TRUE (1) in HL if ok
 219:	01E4          	mordy:
 220:							; <== Insert your own code here
 221:	01E4  AF      		xor	a
 222:							; <== End of your own code
 223:			
 224:	01E5  7D      		ld	a,l		; set/clear Z
 225:	01E6  B7      		or	a
 226:	01E7  C9      		ret
 227:			
 228:			;Test for character at modem: return TRUE (1) in HL if so
 229:	01E8          	mirdy:
 230:							; <== Insert your own code here
 231:	01E8  210000  		ld	hl,0
 232:	01EB  CDBD03  		call	srchk1
 233:	01EE  2801    		jr	z,mirdy01
 234:	01F0  2C      		inc 	l
 235:	01F1          	mirdy01:
 236:							; <== End of your own code
 237:	01F1  7D      		ld	a,l		; set/clear Z
 238:	01F2  B7      		or	a
 239:	01F3  C9      		ret
 240:			
 241:			;Send a break to the modem: leave empty if your system can't do it
 242:	01F4          	sndbrk:
 243:							; <== Insert your own code here
 244:			
 245:	01F4  212C01  		ld	hl,300		; wait 300 mS
 246:	01F7  CD3203  		call	waithlms
 247:			
 248:							; <== End of your own code
 249:	01FA  C9      		ret
 250:			;
 251:			;Test UART flags for error: return TRUE (1) in HL if error.
 252:	01FB          	mdmerr:
 253:							; <== Insert your own code here
 254:	01FB  210000  		ld	hl,0
 255:							; <== End of your own code
 256:	01FE  7D      		ld	a,l		; set/clear Z
 257:	01FF  B7      		or	a
 258:	0200  C9      		ret
 259:			
 260:			
 261:			
 262:			;Turn DTR ON
 263:	0201          	dtron:
 264:							; <== Insert your own code here
 265:			
 266:							; <== End of your own code
 267:	0201  C9      		ret
 268:			
 269:			
 270:			
 271:			;Turn DTR OFF
 272:	0202          	dtroff:
 273:							; <== Insert your own code here
 274:			
 275:			
 276:							; <== End of your own code
 277:	0202  C9      		ret
 278:			
 279:			
 280:			
 281:			;Initialise the uart
 282:			
 283:	0203          	init:
 284:			
 285:	0203  210200  		ld	hl,2		; get parameters
 286:	0206  39      		add	hl,sp
 287:	0207  EB      		ex	de,hl
 288:	0208  CD4203  		call	getparm		; in HL
 289:	020B  223802  		ld	(brate),hl	; baud rate
 290:	020E  CD4203  		call	getparm
 291:	0211  223402  		ld	(parity),hl	; parity
 292:	0214  CD4203  		call	getparm
 293:	0217  223602  		ld	(data),hl	; data bits (BINARY 7 or 8)
 294:	021A  CD4203  		call	getparm
 295:	021D  223202  		ld	(stop),hl	; stop bits (BINARY 1 or 2)
 296:			
 297:			
 298:							; <== Insert your own code here
 299:			
 300:	0220  3E0C    		ld	a,u1defspeed	; by default
 301:							; using values below
 302:	0222  323C00  		ld	(mspeed),a	; don't forget to load mspeed with the
 303:							; current brate value if the new rate is
 304:							; valid. See table of values below.
 305:	0225  3A3802  		ld	a,(brate)
 306:	0228  213A02  		ld	hl,zds_rates
 307:	022B  85      		add	a,l
 308:	022C  6F      		ld	l,a
 309:	022D  7E      		ld	a,(hl)
 310:	022E  CDA503  		call	set_speed1
 311:							; <== End of your own code
 312:	0231  C9      		ret
 313:			;--------------------------------------------------------------------------
 314:			
 315:	0232  0100    	stop:	dw	1		; stop bits
 316:	0234  4E00    	parity:	dw	'N'		; parity
 317:	0236  0800    	data:	dw	8		; data bits
 318:	0238  0700    	brate:	dw	7		; baud rate:
 319:			
 320:			;--------------------------------------------------------------------------
 321:			;Values of brate for each baud rate
 322:			;
 323:			; baud rate    brate
 324:			;
 325:			;   110		 0
 326:			;   300		 1
 327:			;   450		 2
 328:			;   600		 3
 329:			;   710		 4
 330:			;  1200		 5
 331:			;  2400		 6
 332:			;  4800		 7
 333:			;  9600		 8
 334:			; 19200		 9
 335:			; 38400		10
 336:			; 57600         11
 337:			; 76800         12
 338:			
 339:	023A          	zds_rates:
 340:	023A  00      		db	0		; 110
 341:	023B  00      		db	0		; 300
 342:	023C  00      		db	0		; 450
 343:	023D  00      		db	0		; 600
 344:	023E  00      		db	0		; 710
 345:	023F  60      		db	uart1200	; 1200
 346:	0240  30      		db	uart2400	; 2400
 347:	0241  18      		db	uart4800	; 4800
 348:	0242  0C      		db	uart9600	; 9600
 349:	0243  06      		db	uart19k2	; 19200
 350:	0244  03      		db	uart38k4	; 38400
 351:	0245  02      		db	uart57k6	; 57600
 352:	0246  01      		db	uart115k2	; 76800 -> 115200
 353:			;
 354:			; Set the port. ZMP supplies either 0 or 1 as a parameter. You're on your
 355:			; own here -- your system is bound to be different from any other! You may
 356:			; implement a software switch on all the modem-dependent routines, or perhaps
 357:			; you can have one or two centralised routines for accessing the UARTs and
 358:			; modify the code from this routine to select one or the other. (Who said
 359:			; there was anything wrong with self-modifying code?). If you have only one
 360:			; UART port, or if you don't want to go through all the hassles, just have
 361:			; this routine returning with no changes made. Note that ZMP calls this
 362:			; routine with both values for the port on initialisation.
 363:			;
 364:	0247          	setport:
 365:	0247  210200  		ld	hl,2		; get port number
 366:	024A  39      		add	hl,sp
 367:	024B  EB      		ex	de,hl
 368:	024C  CD4203  		call	getparm		; in HL (values are 0 and 1)
 369:			
 370:							; <== Insert your own code here
 371:	024F  7D      		ld	a,l
 372:	0250  325402  		ld	(port),a
 373:							; <== End of your own code
 374:	0253  C9      		ret
 375:			
 376:	0254          	port:	ds	1
 377:			
 378:			
 379:			;****************************************************************************
 380:			;Video terminal sequences: these are for ADM-3A: Modify as you wish
 381:			;Cursor addressing:
 382:	0255          	cursadd:
 383:			; 	ld	hl,2		; get parameters
 384:			; 	add	hl,sp
 385:			; 	ex	de,hl
 386:			; 	call	getparm		; in HL
 387:			; 	ld	(row),hl	; row
 388:			; 	call	getparm
 389:			; 	ld	(col),hl	; column
 390:			; 				; <== Insert your own code here
 391:			; 				; using values in row and col
 392:			; 	ld	a,esc
 393:			; ; 	call	cout
 394:			; 	ld	a,(col)
 395:			; 	inc	a
 396:			; 	add	a,' '
 397:			; ; 	call	cout
 398:			; 	ld	a,(row)
 399:			; 	inc	a
 400:			; 	add	a,' '
 401:			; ; 	call	cout
 402:	0255  CDD102  		call	print
 403:	0258  51554949		db	'QUIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII',0
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494949
	      49494900
 404:							; <== end of your own code
 405:	02A8  C9      		ret
 406:			
 407:	02A9          	row:	ds	2		; row
 408:	02AB          	col:	ds	2		; column
 409:			
 410:			
 411:			;Clear screen:
 412:	02AD          	cls:
 413:			; 	ld	a,0ch
 414:			; 	call	cout
 415:	02AD  C9      		ret
 416:			
 417:			;Inverse video on:
 418:	02AE          	invon:
 419:			; 	call	print
 420:			; 	db	esc,1bh,0dh
 421:	02AE  C9      		ret
 422:			
 423:			;Inverse video off:
 424:	02AF          	invoff:
 425:			; 	call	print
 426:			; 	db	esc,1ch,0dh
 427:	02AF  C9      		ret
 428:			
 429:			;Turn off cursor:
 430:	02B0          	hide:
 431:			; 	ld	a,04h
 432:			; 	call	cout
 433:	02B0  C9      		ret
 434:			
 435:			;Turn on cursor:
 436:	02B1          	show:
 437:			; 	ld	a,05h
 438:			; 	call	cout
 439:	02B1  C9      		ret
 440:			
 441:			;Save cursor position:
 442:	02B2          	savecu:
 443:	02B2  C9      		ret
 444:			
 445:			;Restore cursor position:
 446:	02B3          	rescu:
 447:	02B3  C9      		ret
 448:			
 449:			;****************************************************************************
 450:			
 451:			;Service modem interrupt:
 452:	02B4          	mint:
 453:	02B4  C9      		ret			; my system doesn't need this
 454:			
 455:			;Initialise interrupt vectors:
 456:	02B5          	invec:
 457:	02B5  C9      		ret			; ditto
 458:			
 459:			;De-initialise interrupt vectors:
 460:	02B6          	dinvec:
 461:	02B6  C9      		ret			; ditto
 462:			
 463:			;****************** End of user-defined code ********************************
 464:			;		Do not change anything below here.
 465:			
 466:			;Modem character test for 100 ms
 467:	02B7          	mrd:
 468:	02B7  C5      		push	bc		; save bc
 469:	02B8  016400  		ld	bc,100		; set limit
 470:	02BB          	mrd1:
 471:	02BB  CDE801  		call	mirdy		; char at modem?
 472:	02BE  200F    		jr	nz,mrd2		; yes, exit
 473:	02C0  210100  		ld	hl,1		; else wait 1ms
 474:	02C3  CD3203  		call	waithlms
 475:	02C6  0B      		dec	bc		; loop till done
 476:	02C7  78      		ld	a,b
 477:	02C8  B1      		or	c
 478:	02C9  20F0    		jr	nz,mrd1
 479:	02CB  210000  		ld	hl,0		; none there, result=0
 480:	02CE  AF      		xor	a
 481:	02CF          	mrd2:
 482:	02CF  C1      		pop	bc
 483:	02D0  C9      		ret
 484:			
 485:			; Inline print routine: destroys A and HL
 486:			
 487:	02D1          	print:
 488:	02D1  E3      		ex	(sp),hl		; get address of string
 489:	02D2          	ploop:
 490:	02D2  7E      		ld	a,(hl)		; get next
 491:	02D3  23      		inc	hl		; bump pointer
 492:	02D4  B7      		or	a		; done if zero
 493:	02D5  2805    		jr	z,pdone
 494:	02D7  CDDE02  		call	cout		; else print
 495:	02DA  18F6    		jr	ploop		; and loop
 496:	02DC          	pdone:
 497:	02DC  E3      		ex	(sp),hl		; restore return address
 498:	02DD  C9      		ret			; and quit
 499:			
 500:			;
 501:			;Output a character in A to the console
 502:			;
 503:	02DE          	cout:
 504:	02DE  C5      		push	bc		; save regs
 505:	02DF  D5      		push	de
 506:	02E0  E5      		push	hl
 507:	02E1  5F      		ld	e,a		; character to E
 508:	02E2  0E02    		ld	c,2
 509:	02E4  CD0500  		call	bdos		; print it
 510:	02E7  E1      		pop	hl
 511:	02E8  D1      		pop	de
 512:	02E9  C1      		pop	bc
 513:	02EA  C9      		ret
 514:			
 515:			;Wait(seconds)
 516:	02EB          	wait:
 517:	02EB  210200  		ld	hl,2
 518:	02EE  39      		add	hl,sp
 519:	02EF  EB      		ex	de,hl		; get delay size
 520:	02F0  CD4203  		call	getparm
 521:							; fall thru to..
 522:			;Wait seconds in HL
 523:	02F3          	waithls:
 524:	02F3  C5      		push	bc		; save bc
 525:	02F4  D5      		push	de		; de
 526:	02F5  DDE5    		push	ix		; and ix
 527:	02F7  DD210000		ld	ix,0		; then point ix to 0
 528:							; so we don't upset memory-mapped i/o
 529:			
 530:			;Calculate values for loop constants. Need to have two loops to avoid
 531:			;   16-bit overflow with clock speeds above 9 MHz.
 532:			
 533:	0001          	outerval	equ	(clkspd / 10) + 1
 534:	682C          	innerval	equ	(6667 / outerval) * clkspd
 535:			
 536:	02FB          	wait10:
 537:	02FB  0601    		ld	b,outerval
 538:			
 539:	02FD          	wait11:
 540:	02FD  112C68  		ld	de,innerval
 541:			
 542:	0300          	wait12:
 543:	0300  DDCB0046		bit	0,(ix)		; time-wasters
 544:	0304  DDCB0046		bit	0,(ix)
 545:	0308  DDCB0046		bit	0,(ix)		; 20 T-states each
 546:	030C  DDCB0046		bit	0,(ix)
 547:	0310  DDCB0046		bit	0,(ix)
 548:	0314  DDCB0046		bit	0,(ix)
 549:	0318  1B      		dec	de
 550:	0319  7B      		ld	a,e
 551:	031A  7A      		ld	a,d
 552:	031B  B3      		or	e
 553:	031C  20E2    		jr	nz,wait12	; 150 T-states per inner loop
 554:	031E  10DD    		djnz	wait11		; decrement outer loop
 555:	0320  2B      		dec	hl		; ok, decrement count in hl
 556:	0321  7C      		ld	a,h
 557:	0322  B5      		or	l
 558:	0323  20D6    		jr	nz,wait10
 559:	0325  DDE1    		pop	ix		; done -- restore ix
 560:	0327  D1      		pop	de		; de
 561:	0328  C1      		pop	bc		; and bc
 562:	0329  C9      		ret
 563:			
 564:			;Wait milliseconds
 565:	032A          	mswait:
 566:	032A  210200  		ld	hl,2
 567:	032D  39      		add	hl,sp
 568:	032E  EB      		ex	de,hl		; get delay size
 569:	032F  CD4203  		call	getparm
 570:							; fall thru to..
 571:			;Wait milliseconds in HL
 572:	0332          	waithlms:
 573:	0332  D5      		push	de
 574:	0333          	w1ms0:
 575:	0333  119C00  		ld	de,39 * clkspd
 576:	0336          	w1ms1:
 577:	0336  1B      		dec	de
 578:	0337  7A      		ld	a,d
 579:	0338  B3      		or	e
 580:	0339  20FB    		jr	nz,w1ms1
 581:	033B  2B      		dec	hl
 582:	033C  7C      		ld	a,h
 583:	033D  B5      		or	l
 584:	033E  20F3    		jr	nz,w1ms0
 585:	0340  D1      		pop	de
 586:	0341  C9      		ret
 587:			
 588:			;Get next parameter from (de) into hl
 589:	0342          	getparm:
 590:	0342  EB      		ex	de,hl		; get address into hl
 591:	0343  5E      		ld	e,(hl)		; get lo
 592:	0344  23      		inc	hl
 593:	0345  56      		ld	d,(hl)		; then hi
 594:	0346  23      		inc	hl		; bump for next
 595:	0347  EB      		ex	de,hl		; result in hl, address still in de
 596:	0348  C9      		ret
 597:			
 598:			;Get address of user-defined variables
 599:			
 600:	0349          	getvars:
 601:	0349  214D03  		ld	hl,uservars
 602:	034C  C9      		ret
 603:			
 604:	034D          	uservars:
 605:	034D  0000    		dw	overdrive	; .OVR etc. drive/user
 606:	034F  0000    		dw	overuser
 607:			
 608:			;; ZDS specific serial interface routines
 609:			include zds_ser1.lib
**** zds_ser1.lib ****
   1:			;
   2:			;=======================================================================
   3:			;
   4:			; DarkStar (NE Z80) Serial support library - UART 1
   5:			;
   6:			;=======================================================================
   7:			;;---------------------------------------------------------------------
   8:			;; Version      : 1.0 - 20170311
   9:			;; Assemble     : SLR z80asm, myzmac
  10:			;; Revisions:
  11:			;; 20170311	- Initial revision
  12:			;;---------------------------------------------------------------------
  13:			
  14:				title	zds_serial1.lib - Serial i/o to host computer
  15:			;
  16:			; 	public	srlout1,srlin1,srchk1
  17:			; 	public	attach_1_legacy, detach_1_legacy
  18:			; 	public	set_speed1
  19:			
  20:			; 	extern	cnfbyte
  21:			
  22:			;;
  23:			;; Using this lib require inclusion of "darkstar.equ"
  24:			;;
  25:			;
  26:			;
  27:	0011          	xon		equ	11h
  28:	0013          	xoff		equ	13h
  29:	0008          	rst8op		equ	0008h
  30:	0009          	rst8adr		equ	0009h
  31:	00C9          	op_ret		equ	0c9h
  32:	00C3          	op_jp		equ	0c3h
  33:			;
  34:			; Receive lock work enable
  35:			;
  36:	0000          	lock_wround	equ	false
  37:			
  38:			;;
  39:			;; attach_1_legacy
  40:			;;
  41:			;; connect to uart1 via legacy RST8
  42:			;;
  43:			;;
  44:			
  45:	0351          	attach_1_legacy:
  46:	0351  F5      		push	af
  47:	0352  E5      		push	hl
  48:	0353  F3      		di				; hold interrupts
  49:	0354  3EC3    		ld	a,op_jp			; jp opcode
  50:	0356  320800  		ld	(rst8op),a		; in rst8 base
  51:	0359  210A04  		ld	hl,isr_s1		; and isr routine
  52:	035C  220900  		ld	(rst8adr),hl
  53:	035F  212600  		ld	hl,cnfbyte
  54:	0362  CBC6    		set	0,(hl)			; enable rst8 redirect
  55:	0364          	at_fls:
  56:	0364  DBCD    		in	a,(uart1+r5lsr)		; read status to flush the queue
  57:	0366  CB47    		bit	0,a			; data available in rx buffer?
  58:	0368  2804    		jr	z,at_clr			; no.
  59:	036A  DBC8    		in	a,(uart1+r0rxtx)	; read data
  60:	036C  18F6    		jr	at_fls
  61:	036E          	at_clr:
  62:	036E  FB      		ei				; re-enable interrupts
  63:	036F  E1      		pop	hl
  64:	0370  F1      		pop	af
  65:	0371  C9      		ret				; done
  66:			
  67:			;;
  68:			;; detach_1_legacy
  69:			;;
  70:			;; disconnect uart1 from RST8 redirect
  71:			;;
  72:			
  73:	0372          	detach_1_legacy:
  74:	0372  F5      		push	af
  75:	0373  E5      		push	hl
  76:	0374  F3      		di				; hold interrupts
  77:			
  78:	0375  3E0C    		ld	a,u1defspeed		; reset to defaults
  79:	0377  322A00  		ld	(uart1br),a
  80:	037A  CD51FC  		call	bbu1ini
  81:			
  82:	037D  3EC9    		ld	a,op_ret		; ret opcode
  83:	037F  320800  		ld	(rst8op),a		; in rst8 base
  84:	0382  212600  		ld	hl,cnfbyte
  85:	0385  CB86    		res	0,(hl)			; disable rst8 redirect
  86:			
  87:	0387  FB      		ei				; re-enable interrupts
  88:	0388  E1      		pop	hl
  89:	0389  F1      		pop	af
  90:	038A  C9      		ret				; done
  91:			
  92:			;;
  93:			;; set_fifo
  94:			;;
  95:			;; set fifo size, A is the define
  96:			;;
  97:			
  98:	038B          	set_fifo1:
  99:	038B  D5      		push	de
 100:	038C  5F      		ld	e,a			; save param
 101:	038D  3E07    		ld	a,ufifo1		; and validate it
 102:	038F  BB      		cp	e
 103:	0390  280F    		jr	z,set_fifo10
 104:	0392  3E47    		ld	a,ufifo4
 105:	0394  BB      		cp	e
 106:	0395  280A    		jr	z,set_fifo10
 107:	0397  3E87    		ld	a,ufifo8
 108:	0399  BB      		cp	e
 109:	039A  2805    		jr	z,set_fifo10
 110:	039C  3EC7    		ld	a,ufifo14
 111:	039E  BB      		cp	e
 112:	039F  2002    		jr	nz,set_fifo11		; wrong value entered
 113:	03A1          	set_fifo10:
 114:	03A1  D3CA    		out	(uart1+r2fcr),a		; transfer to uart
 115:	03A3          	set_fifo11:
 116:	03A3  D1      		pop	de
 117:	03A4  C9      		ret
 118:			
 119:			;;
 120:			;; set_speed1
 121:			;;
 122:			;; set baud rate, A is the define (no validation)
 123:			;;
 124:			
 125:	03A5          	set_speed1:
 126:	03A5  322A00  		ld	(uart1br),a		; store value
 127:	03A8  CD51FC  		call	bbu1ini
 128:	03AB  C9      		ret
 129:			
 130:			;;
 131:			;; set_mode1
 132:			;;
 133:			;; set baud rate, A is the define (no validation)
 134:			;;
 135:			;; TODO: Wrong, this should be done by sysbios.
 136:			;;       To be fixed in future release.
 137:			
 138:			;set_mode1:
 139:			
 140:			
 141:			;;
 142:			;; Check for input (and get it)
 143:			;;
 144:			;; A contain input byte
 145:			;;
 146:			
 147:	03AC          	srlin1:
 148:	03AC  DBCD    		in	a,(uart1+r5lsr)		; read status
 149:	03AE  CB7F    		bit	7,a			; fifo overrun?
 150:	03B0  C40A04  		call	nz,isr_s1		; try to flush the fifo
 151:			
 152:	0000          	if	lock_wround
 161:			endif
 162:			
 163:	03B3  3A6F04  		ld	a,(ilen)		; buffer length
 164:	03B6  B7      		or	a			; empty ?
 165:	03B7  C8      		ret	z			; yes -> forget it
 166:	03B8  CDC203  		call	getbyte
 167:	03BB  37      		scf				; success
 168:	03BC  C9      		ret
 169:			
 170:			;;
 171:			;; Check for input (and get it)
 172:			;;
 173:			
 174:	03BD          	srchk1:
 175:	03BD  3A6F04  		ld	a,(ilen)		; buffer length
 176:	03C0  B7      		or	a			; empty ?
 177:	03C1  C8      		ret	z			; return Z flag
 178:			
 179:			
 180:			
 181:			;;
 182:			;; getbyte - extract char from queue
 183:			;;
 184:			
 185:	03C2          	getbyte:
 186:	03C2  E5      		push	hl
 187:	03C3  D5      		push	de
 188:	03C4  2A7004  		ld	hl,(ibgp)
 189:	03C7  7E      		ld	a,(hl)			; get next char.
 190:	03C8  23      		inc	hl
 191:	03C9  117305  		ld	de,ibend
 192:	03CC  CD5D04  		call	cphlde			; buffer end ?
 193:	03CF  3803    		jr	c,noiwrap		; no ->
 194:	03D1  217404  		ld	hl,ibstrt		; yes, back to start
 195:	03D4          	noiwrap:
 196:	03D4  227004  		ld	(ibgp),hl
 197:	03D7  216F04  		ld	hl,ilen
 198:	03DA  35      		dec	(hl)
 199:	03DB  F5      		push	af
 200:	03DC  3A6F04  		ld	a,(ilen)
 201:			; 	cp	imax-20
 202:	03DF  FEDF    		cp	imax-32
 203:	03E1  CC0504  		call	z,pson
 204:	03E4  F1      		pop	af
 205:	03E5  D1      		pop	de
 206:	03E6  E1      		pop	hl
 207:	03E7  C9      		ret
 208:			
 209:			;;
 210:			;; Read 16c550 LSR register and return in A
 211:			;;
 212:	03E8          	getlsr1:
 213:	03E8  DBCD    	in	a,(uart1+r5lsr)		; read status
 214:	03EA  C9      		ret
 215:			
 216:			;;
 217:			;;  Output routine
 218:			;;  upon entry:	C contains the character to be output
 219:			;;
 220:			
 221:	03EB          	srlout1:
 222:	03EB          	srlout:
 223:	03EB  F5      		push	af
 224:	03EC  3A6E04  	sot0:	ld	a,(opflg)		; test xon/xoff
 225:	03EF  CB47    		bit	0,a
 226:	03F1  20F9    		jr	nz,sot0			; idle if xoff
 227:	03F3          	sot1:
 228:	03F3  DBCD    		in	a,(uart1+r5lsr)		; read status
 229:	03F5  CB6F    		bit	5,a			; ready to send?
 230:	03F7  CAF303  		jp	z,sot1			; no, retry.
 231:			
 232:	03FA  79      		ld	a,c			; fill in the char
 233:	03FB  D3C8    		out	(uart1+r0rxtx),a	; send it
 234:	03FD  F1      		pop	af
 235:	03FE  C9      		ret
 236:			;;
 237:			;;	Interrupt Service Routines
 238:			;;
 239:			
 240:			;;
 241:			;; psoff: send xoff to host
 242:			;;
 243:	03FF          	psoff:
 244:	03FF  0E13    		ld	c,xoff
 245:	0401  CDEB03  		call	srlout
 246:	0404  C9      		ret
 247:			;
 248:			;;
 249:			;; pson: send xon to host
 250:			;;
 251:	0405  0E11    	pson:	ld	c,xon
 252:	0407  C3EB03  		jp	srlout
 253:			
 254:			;;
 255:			;; isr_s1
 256:			;;
 257:			;; Called upon interrupt on uart1
 258:			;;
 259:			
 260:	040A          	isr_s1:
 261:	040A  ED737305		ld	(tstack),sp		; save status
 262:	040E  31F305  		ld	sp,stack
 263:	0411  CD6304  		call	pushem
 264:	0414  CDFF03  		call	psoff			; lock host
 265:			
 266:	0417  3A6F04  		ld	a,(ilen)		; buffer capacity ?
 267:	041A  216E04  		ld	hl,opflg
 268:	041D  FEEF    	 	cp	imax-16			; uart hw fifo is 16 bytes
 269:	041F  282E    		jr	z,iret			; wait for dequeue
 270:			;
 271:	0421          	isr_s10:
 272:	0421  DBCD    		in	a,(uart1+r5lsr)		; read status
 273:	0423  CB47    		bit	0,a			; data available in rx buffer?
 274:	0425  2825    		jr	z,iret0			; no.
 275:	0427  DBC8    		in	a,(uart1+r0rxtx)	; read data
 276:			
 277:	0429  FE13    		cp	xoff
 278:	042B  CC5704  		call	z,idle
 279:	042E  FE11    		cp	xon
 280:	0430  CC5A04  		call	z,nidle
 281:			
 282:	0433  2A7204  		ld	hl,(ibpp)
 283:	0436  77      		ld	(hl),a
 284:	0437  23      		inc	hl
 285:	0438  117305  		ld	de,ibend
 286:	043B  CD5D04  		call	cphlde
 287:	043E  3803    		jr	c,norw
 288:	0440  217404  		ld	hl,ibstrt
 289:	0443          	norw:
 290:	0443  227204  		ld	(ibpp),hl
 291:	0446  216F04  		ld	hl,ilen
 292:	0449  34      		inc	(hl)
 293:	044A  18D5    		jr	isr_s10			; repeat for more data in UART
 294:	044C          	iret0:
 295:	044C  CD0504  		call	pson
 296:	044F          	iret:
 297:	044F  CD6804  		call	popem
 298:	0452  ED7B7305		ld	sp,(tstack)
 299:	0456  C9      	dummy:	ret
 300:			
 301:	0457          	idle:
 302:	0457  CBC6    		set	0,(hl)
 303:	0459  C9      		ret
 304:			;
 305:	045A          	nidle:
 306:	045A  CB86    		res	0,(hl)
 307:	045C  C9      		ret
 308:			;
 309:	045D          	cphlde:
 310:	045D  E5      		push	hl		;compares hl & de
 311:	045E  B7      		or	a		;and sets flags.
 312:	045F  ED52    		sbc	hl,de
 313:	0461  E1      		pop	hl
 314:	0462  C9      		ret
 315:			;
 316:	0463          	pushem:
 317:	0463  E3      		ex	(sp),hl		;save main regs on stack.
 318:	0464  D5      		push	de		;the hl pair is mod'd.
 319:	0465  C5      		push	bc
 320:	0466  F5      		push	af
 321:	0467  E9      		jp	(hl)
 322:			;
 323:	0468          	popem:
 324:	0468  E1      		pop	hl		;restore all main regs
 325:	0469  F1      		pop	af		;from stack after a
 326:	046A  C1      		pop	bc		;call to pushem.
 327:	046B  D1      		pop	de
 328:	046C  E3      		ex	(sp),hl
 329:	046D  C9      		ret
 330:			;
 331:			
 332:	046E  00      	opflg	db	0
 333:			;
 334:	046F  00      	ilen	db	0		;input buffer length
 335:	0470  7404    	ibgp	dw	ibstrt		;input buffer get pointer
 336:	0472  7404    	ibpp	dw	ibstrt		;input buffer put pointer
 337:	0474          	ibstrt	equ	$		;input buffer start
 338:	0474          	ibuff	ds	0ffh		;input buffer
 339:	0573          	ibend	equ	$		;input buffer end
 340:	00FF          	imax	equ	0ffh		;input buffer max length
 341:			;
 342:	0573          	tstack	ds	80h
 343:	05F3          	stack	equ	$
 344:			;
 345:	05F3          		end



Statistics:

     4	passes
     0	jr promotions
   447	symbols
     0	bytes



Symbol Table:

altprnprt      =   3     
appbuf         =  2d     
at_clr           36e     
at_fls           364     
attach_1_legacy  351     
bbappp         =   e     
bbbase         =f000     
bbcalret       =fd5a     
bbcbank        =   c     
bbcomn         =fc00     
bbconin        =fd94     
bbconout       =fd9f     
bbconst        =fdaa     
bbcpboot       =fcc3     
bbcrtcini      =fc03     
bbcrtfill      =fc09     
bbcstck        =   d     
bbcurset       =fc21     
bbdebug        =   0     
bbdiv16        =fcdb     
bbdmaset       =fcb7     
bbdprmset      =fd17     
bbdriveid      =fcf3     
bbdsksel       =fcbd     
bbeidck        =fd23     
bbepmngr       =fd1d     
bbexec         =fd29     
bbfdrvsel      =fcd5     
bbfhome        =fc81     
bbflopio       =fc93     
bbfread        =fc87     
bbfwrite       =fc8d     
bbhdboot       =fd0b     
bbhdgeo        =fd05     
bbhdinit       =fced     
bbhdrd         =fcff     
bbhdwr         =fcf9     
bbimgp         =  c0     
bbinictc       =fc57     
bbjtobnk       =fc00     
bbldpart       =fd11     
bbmul16        =fce1     
bboffcal       =fce7     
bbpag          =   f     
bbprcvblk      =fc6f     
bbprnchr       =fc99     
bbpsndblk      =fc63     
bbrdtime       =fca5     
bbrdvdsk       =fc75     
bbresctc       =fc5d     
bbsecset       =fcb1     
bbsidset       =fccf     
bbstack        =febf     
bbstbase       =fe9b     
bbsttim        =fc9f     
bbtrkset       =fcab     
bbu0ini        =fc39     
bbu1ini        =fc51     
bbu1rx         =fc45     
bbu1st         =fc4b     
bbu1tx         =fc3f     
bbuplchr       =fc69     
bbvcpmbt       =fcc9     
bbvoid         =fd6a     
bbwrvdsk       =fc7b     
bdos           =   5     
bldoffs        =3000     
blifastblok    =  60     
blifastline    =  6a     
blislowblok    =  40     
blislowline    =  4a     
brate            238     
btpasiz        =   6     
cdisk          =   4     
clkio          =   6     
clkrst         =   7     
clksclk        =   5     
clkspd         =   4     
cls              2ad     
cmdid          =  ec     
cmdinit        =  91     
cmdread        =  20     
cmdrecal       =  10     
cmdspindown    =  e0     
cmdspinup      =  e1     
cmdwrite       =  30     
cnfbyte        =  26     
codebgn        = 13d     
col              2ab     
colbuf         =  4f     
copsys         =  2c     
cout             2de     
cphlde           45d     
cr             =   d     
crdureg        =fc27     
crt6545adst    =  8c     
crt6545data    =  8d     
crtbase        =  80     
crtbeepport    =  8f     
crtblinkbit    =   0     
crthilitbit    =   3     
crtkeybcnt     =  87     
crtkeybdat     =  85     
crtmodebit     =   4     
crtprntcnt     =  83     
crtprntdat     =  81     
crtram0cnt     =  82     
crtram0dat     =  80     
crtram1cnt     =  86     
crtram1dat     =  84     
crtram2cnt     =  8a     
crtram2dat     =  88     
crtram3port    =  8e     
crtrevrsbit    =   1     
crtservcnt     =  8b     
crtservdat     =  89     
crtunderbit    =   2     
crtwidthbit    =   1     
ctc0tc         =  29     
ctc0tchi       =  20     
ctc1tc         =  28     
ctc1tc100hz    =   5     
ctc1tc10hz     =  30     
ctc1tc25hz     =  13     
ctc1tc2hz      =  f4     
ctc1tc50hz     =   a     
ctcbase        =  e8     
ctcchan0       =  e8     
ctcchan1       =  e9     
ctcchan2       =  ea     
ctcchan3       =  eb     
ctrlq          =  11     
curpbuf        =  48     
cursadd          255     
cursoroff      =  20     
cursoron       =   a     
cursshp        =  4a     
data             236     
debug          =   0     
delay          =fd85     
detach_1_legacy  372     
dinvec           2b6     
dly1           =fd89     
dly2           =fd87     
dostx          =fe6e     
dselbf         =  4e     
dtroff           202     
dtron            201     
dummy            456     
eep29c         =   4     
eep29ee        =   1     
eep29xe        =   2     
eepage0        =  c0     
eeproglock     =  10     
eepsta         =f000     
eepunsupp      =   8     
eerineprom     =  80     
endvid         = 7cf     
esc            =  1b     
false          =   0     
fdcbase        =  d0     
fdccmdstatr    =  d0     
fdcdatareg     =  d7     
fdcdrvrcnt     =  d6     
fdcreadc       =  88     
fdcreset       =  d0     
fdcrestc       =   7     
fdcsectreg     =  d2     
fdcseekc       =  16     
fdctrakreg     =  d1     
fdcwritc       =  a8     
fdrvbuf        =  45     
ff             =   c     
fifblok        =   b     
fifoend        =  25     
fifokb         =  1a     
fifosto        =   f     
fifou0         =   f     
fifsize        =   8     
fin            =fdc4     
fixblock       =   0     
fout           =fde1     
frdpbuf        =  41     
fsecbuf        =  43     
fsekbuf        =  3f     
fstat          =fdb5     
ftrkbuf        =  46     
getbyte          3c2     
getlsr1          3e8     
getparm          342     
getvars          349     
hide             2b0     
hmempag        =   b     
ibend          = 573     
ibgp             470     
ibpp             472     
ibstrt         = 474     
ibuff            474     
idea0line      =   1     
idea1line      =   2     
idea2line      =   4     
idecs0line     =   8     
idecs1line     =  10     
ideporta       =  e0     
ideportb       =  e1     
ideportc       =  e2     
ideportctrl    =  e3     
iderdline      =  40     
iderstline     =  80     
idewrline      =  20     
idle             457     
ilen             46f     
imax           =  ff     
imtpag         =  ff     
imtsiz         = 400     
init             203     
innerval       =682c     
intrdi         =fe0f     
intren         =fdfe     
invec            2b5     
invoff           2af     
invon            2ae     
iobyte         =   3     
iret             44f     
iret0            44c     
isr_s1           40a     
isr_s10          421     
jump_tab         13d     
kbdbyte        =  4d     
keybstrbbit    =   7     
lf             =   a     
lock_wround    =   0     
maxblk         =  14     
mchin            1ce     
mchout           1d8     
mdmerr           1fb     
menaprt        =  21     
mint             2b4     
miobyte        =  4c     
mirdy            1e8     
mirdy01          1f1     
mmgetp         =fd78     
mmpmap         =fd6b     
mmtpapag       =  ef     
mmuport        =  20     
mmutstaddr     =d000     
mmutstpage     =   d     
monmaj         =  33     
monmin         =  36     
mordy            1e4     
mrd              2b7     
mrd1             2bb     
mrd2             2cf     
mscnt          =  f6     
mspeed         =  3c     
mswait           32a     
mzmac          =   1     
nidle            45a     
noiwrap          3d4     
norw             443     
op_jp          =  c3     
op_ret         =  c9     
opflg            46e     
outerval       =   1     
overdrive      =   0     
overuser       =   0     
ovsize         = 400     
parity           234     
pdone            2dc     
pio2bit2       =   2     
pio2bit3       =   3     
pio2bit4       =   4     
ploop            2d2     
popem            468     
port             254     
ppakstb        =   1     
ppcntrp        =   2     
ppdatap        =   3     
ppdini         =   0     
ppdokg         =   2     
ppdrdy         =   4     
ppdstp         =   6     
ppstrob        =   0     
ppuack         =   7     
ppuini         =   1     
ppuokg         =   3     
ppurdy         =   5     
print            2d1     
prntbusybit    =   0     
prvtop         =  4f     
psoff            3ff     
pson             405     
pushem           463     
r0brdl         =   0     
r0rxtx         =   0     
r1brdm         =   1     
r1ier          =   1     
r2fcr          =   2     
r2iir          =   2     
r3lcr          =   3     
r4mcr          =   4     
r5lsr          =   5     
r6msr          =   6     
r7spr          =   7     
ram0buf        =  3b     
ram1buf        =  3c     
ram2buf        =  3d     
ram3buf        =  3e     
ramtbl         =e000     
readcfg8255    =  92     
regastatus     =  16     
regcommand     =   f     
regcontrol     =  16     
regcyllsb      =   c     
regcylmsb      =   d     
regdata        =   8     
regerr         =   9     
regseccnt      =   a     
regsector      =   b     
regshd         =   e     
regstatus      =   f     
rescu            2b3     
rldrom         =fe84     
row              2a9     
rsrvbuf        =  2f     
rst7sp1        =  38     
rst7sp2        =  39     
rst7sp3        =  3a     
rst8adr        =   9     
rst8op         =   8     
rtbsiz         = 3c0     
savecu           2b2     
sconin         =fc2d     
sconout        =fc27     
sconst         =fc33     
scrnpr           1a3     
set_fifo1        38b     
set_fifo10       3a1     
set_fifo11       3a3     
set_speed1       3a5     
setport          247     
show             2b1     
sintvec        =fff0     
sndbrk           1f4     
sot0             3ec     
sot1             3f3     
spare            1c0     
srchk1           3bd     
srlin1           3ac     
srlout           3eb     
srlout1          3eb     
srxrsm         =fe6c     
srxstp         =fe68     
stack          = 5f3     
stop             232     
syscmlo        =febf     
syscom         =fc00     
syshertz       =  13     
sytimr         =fe19     
tblblk         =  30     
tdesclen       =  14     
tiaddrlen      =   4     
timrcon        =  27     
tmpbyte        =  4b     
tnamelen       =   8     
tpa            = 100     
tpagelen       =   2     
trnpag         =   d     
true           =ffffffff 
tsizelen       =   4     
tstack           573     
tx0            =fe76     
tx01           =fe78     
u0defspeed     =   6     
u0isr          =fe25     
u1defspeed     =   c     
u1isr          =fe5b     
u1nul          =fe64     
uart0          =  c0     
uart0base      =  c0     
uart0br        =  2b     
uart1          =  c8     
uart115k2      =   1     
uart1200       =  60     
uart19k2       =   6     
uart1base      =  c8     
uart1br        =  2a     
uart2400       =  30     
uart38k4       =   3     
uart4800       =  18     
uart57k6       =   2     
uart9600       =   c     
uastav         =fe8f     
uastkb         =fe91     
ufifo1         =   7     
ufifo14        =  c7     
ufifo4         =  47     
ufifo8         =  87     
uisre          =fe50     
uisri          =fe35     
userdef        = 13d     
userin           1c1     
userout          1ca     
uservars         34d     
vconin         =fc15     
vconout        =fc0f     
vconst         =fc1b     
vdbufsz        =   a     
vdrdsec        =   0     
vdwrsec        =   1     
voidisr        =fe22     
vr0.hrtot      =   0     
vr1.hrdis      =   1     
vr10.crstart   =   a     
vr11.crend     =   b     
vr12.dstarth   =   c     
vr13.dstartl   =   d     
vr14.curposh   =   e     
vr15.curposl   =   f     
vr16.lpenh     =  10     
vr17.lpenl     =  11     
vr18.updaddrh  =  12     
vr19.updaddrl  =  13     
vr2.hrsyncpos  =   2     
vr3.hrvrsyncw  =   3     
vr31.dummy     =  1f     
vr4.vrchrow    =   4     
vr5.vradj      =   5     
vr6.vrdisrows  =   6     
vr7.vrsyncpos  =   7     
vr8.crtmode    =   8     
vr9.scanlines  =   9     
vstabuf        =  36     
w1ms0            333     
w1ms1            336     
wait             2eb     
wait10           2fb     
wait11           2fd     
wait12           300     
waithlms         332     
waithls          2f3     
writecfg8255   =  80     
xofc           =  13     
xoff           =  13     
xon            =  11     
xonc           =  11     
zds_rates        23a     
