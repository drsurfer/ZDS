   1:			;**************************************************************
   2:			;*
   3:			;*             C P / M   version   2 . 2
   4:			;*
   5:			;*   Reconstructed from memory image on February 27, 1981
   6:			;*
   7:			;*                by Clark A. Calkins
   8:			;*
   9:			;**************************************************************
  10:			;
  11:			;   Set memory limit here. This is the amount of contigeous
  12:			; ram starting from 0000. CP/M will reside at the end of this space.
  13:			;
  14:			; MEM	EQU	62		;for a 62k system (TS802 TEST - WORKS OK).
  15:				include sysent.asm
sysent.asm
**** sysent.asm ****
   1:			;
   2:			;********************************************************
   3:			;*							*
   4:			;*	    UNIVERSAL BASIC I/O SYSTEM (BIOS)		*
   5:			;*							*
   6:			;*           memory size and SONE allocation		*
   7:			;*							*
   8:			;********************************************************
   9:			;
  10:			;	Programmers: Martino Stefano & Gallarani Paolo
  11:				; Disassembly/retype Pino Giaquinto & Piergiorgio Betti 2015/04/25
  12:			;
  13:			;********************************************************
  14:			;*		MEMORY SIZING				*
  15:			;********************************************************
  16:			;
  17:			; msize	equ	56			; CP/M memory size in kilobyte
  18:				include	msize.asm		; read in ram size
msize.asm
**** msize.asm ****
   1:	003E          	msize	equ	62
**** sysent.asm ****
  19:	0001          	mres	equ	1			; reserved mem in kilobyte
  20:			;
  21:			;********************************************************
  22:			;*		SYSTEM CONSTANTS			*
  23:			;********************************************************
  24:			;
  25:	003D          	cmsize	equ	msize-mres		; cp/m size in kbyte
  26:			;
  27:			;	bias is address offset from 3400h for memory system
  28:			;	than 16k (referred to as "b" throughout the next)
  29:			;
  30:	A400          	bias	equ	(cmsize-20)*1024;
  31:	D800          	ccp	equ	3400h+bias		; base of ccp
  32:	E000          	bdose	equ	ccp+800h		; start of bdos
  33:	E006          	bdos	equ	ccp+806h		; base of bdos
  34:	EE00          	bios	equ	ccp+1600h		; base of bios
  35:	1000          	ipl	equ	1000h			; ipl origin
  36:			;
  37:			; EOF
**** ccpbdos.asm ****
  16:	003D          	MEM	EQU	cmsize
  17:			;
  18:			;**************************************************************
  19:			;*
  20:			;*        B I O S   J U M P   T A B L E
  21:			;*
  22:			;**************************************************************
  23:			;
  24:	EE00          	BOOT	equ	bios
  25:	EE03          	WBOOT	equ	bios+3
  26:	EE06          	CONST	equ	bios+6
  27:	EE09          	CONIN	equ	bios+9
  28:	EE0C          	CONOUT	equ	bios+12
  29:	EE0F          	LISTD	equ	bios+15
  30:	EE12          	PUNCH	equ	bios+18
  31:	EE15          	READER	equ	bios+21
  32:	EE18          	HOME	equ	bios+24
  33:	EE1B          	SELDSK	equ	bios+27
  34:	EE1E          	SETTRK	equ	bios+30
  35:	EE21          	SETSEC	equ	bios+33
  36:	EE24          	SETDMA	equ	bios+36
  37:	EE27          	READ	equ	bios+39
  38:	EE2A          	WRITE	equ	bios+42
  39:	EE2D          	PRSTAT	equ	bios+45
  40:	EE30          	SECTRAN	equ	bios+48
  41:			;
  42:			
  43:			;
  44:	0003          	IOBYTE	EQU	3		;i/o definition byte.
  45:	0004          	TDRIVE	EQU	4		;current drive name and user number.
  46:	0005          	ENTRYP	EQU	5		;entry point for the cp/m bdos.
  47:	005C          	TFCB	EQU	5CH		;default file control block.
  48:	0080          	TBUFF	EQU	80H		;i/o buffer and command line storage.
  49:	0100          	TBASE	EQU	100H		;transiant program storage area.
  50:			;
  51:			;   Set control character equates.
  52:			;
  53:	0003          	CNTRLC	EQU	3		;control-c
  54:	0005          	CNTRLE	EQU	05H		;control-e
  55:	0008          	BS	EQU	08H		;backspace
  56:	0009          	TAB	EQU	09H		;tab
  57:	000A          	LF	EQU	0AH		;line feed
  58:	000C          	FF	EQU	0CH		;form feed
  59:	000D          	CR	EQU	0DH		;carriage return
  60:	0010          	CNTRLP	EQU	10H		;control-p
  61:	0012          	CNTRLR	EQU	12H		;control-r
  62:	0013          	CNTRLS	EQU	13H		;control-s
  63:	0015          	CNTRLU	EQU	15H		;control-u
  64:	0018          	CNTRLX	EQU	18H		;control-x
  65:	001A          	CNTRLZ	EQU	1AH		;control-z (end-of-file mark)
  66:	007F          	DEL	EQU	7FH		;rubout
  67:			;
  68:			;   Set origin for CP/M
  69:			;
  70:			; 	ORG	(MEM-7)*1024
  71:	D800          		.phase ccp
  72:			;
  73:	D800  C35CDB  	CBASE:	JP	COMMAND		;execute command processor (ccp).
  74:	D803  C358DB  		JP	CLEARBUF	;entry to empty input buffer before starting ccp.
  75:			
  76:			;
  77:			;   Standard cp/m ccp input buffer. Format is (max length),
  78:			; (actual length), (char #1), (char #2), (char #3), etc.
  79:			;
  80:	D806  7F      	INBUFF:	DEFB	127		;length of input buffer.
  81:	D807  00      		DEFB	0		;current length of contents.
  82:	D808  436F7079		DEFB	'Copyright'
	      72696768
	      74
  83:	D811  20313937		DEFB	' 1979 (c) by Digital Research      '
	      39202863
	      29206279
	      20446967
	      6974616C
	      20526573
	      65617263
	      68202020
	      202020
  84:	D834  00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	      00000000
	      00000000
	      00000000
	      00000000
	      000000
  85:	D84B  00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	      00000000
	      00000000
	      00000000
	      00000000
	      000000
  86:	D862  00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	      00000000
	      00000000
	      00000000
	      00000000
	      000000
  87:	D879  00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	      00000000
	      00000000
	      000000
  88:	D888  08D8    	INPOINT:DEFW	INBUFF+2	;input line pointer
  89:	D88A  0000    	NAMEPNT:DEFW	0		;input line pointer used for error message. Points to
  90:			;			;start of name in error.
  91:			;
  92:			;   Routine to print (A) on the console. All registers used.
  93:			;
  94:	D88C  5F      	PRINT:	LD	E,A		;setup bdos call.
  95:	D88D  0E02    		LD	C,2
  96:	D88F  C30500  		JP	ENTRYP
  97:			;
  98:			;   Routine to print (A) on the console and to save (BC).
  99:			;
 100:	D892  C5      	PRINTB:	PUSH	BC
 101:	D893  CD8CD8  		CALL	PRINT
 102:	D896  C1      		POP	BC
 103:	D897  C9      		RET
 104:			;
 105:			;   Routine to send a carriage return, line feed combination
 106:			; to the console.
 107:			;
 108:	D898  3E0D    	CRLF:	LD	A,CR
 109:	D89A  CD92D8  		CALL	PRINTB
 110:	D89D  3E0A    		LD	A,LF
 111:	D89F  C392D8  		JP	PRINTB
 112:			;
 113:			;   Routine to send one space to the console and save (BC).
 114:			;
 115:	D8A2  3E20    	PSPACE:	LD	A,' '
 116:	D8A4  C392D8  		JP	PRINTB
 117:			;
 118:			;   Routine to print character string pointed to be (BC) on the
 119:			; console. It must terminate with a null byte.
 120:			;
 121:	D8A7  C5      	PLINE:	PUSH	BC
 122:	D8A8  CD98D8  		CALL	CRLF
 123:	D8AB  E1      		POP	HL
 124:	D8AC  7E      	PLINE2:	LD	A,(HL)
 125:	D8AD  B7      		OR	A
 126:	D8AE  C8      		RET	Z
 127:	D8AF  23      		INC	HL
 128:	D8B0  E5      		PUSH	HL
 129:	D8B1  CD8CD8  		CALL	PRINT
 130:	D8B4  E1      		POP	HL
 131:	D8B5  C3ACD8  		JP	PLINE2
 132:			;
 133:			;   Routine to reset the disk system.
 134:			;
 135:	D8B8  0E0D    	RESDSK:	LD	C,13
 136:	D8BA  C30500  		JP	ENTRYP
 137:			;
 138:			;   Routine to select disk (A).
 139:			;
 140:	D8BD  5F      	DSKSEL:	LD	E,A
 141:	D8BE  0E0E    		LD	C,14
 142:	D8C0  C30500  		JP	ENTRYP
 143:			;
 144:			;   Routine to call bdos and save the return code. The zero
 145:			; flag is set on a return of 0ffh.
 146:			;
 147:	D8C3  CD0500  	ENTRY1:	CALL	ENTRYP
 148:	D8C6  32EEDF  		LD	(RTNCODE),A	;save return code.
 149:	D8C9  3C      		INC	A		;set zero if 0ffh returned.
 150:	D8CA  C9      		RET
 151:			;
 152:			;   Routine to open a file. (DE) must point to the FCB.
 153:			;
 154:	D8CB  0E0F    	OPEN:	LD	C,15
 155:	D8CD  C3C3D8  		JP	ENTRY1
 156:			;
 157:			;   Routine to open file at (FCB).
 158:			;
 159:	D8D0  AF      	OPENFCB:XOR	A		;clear the record number byte at fcb+32
 160:	D8D1  32EDDF  		LD	(FCB+32),A
 161:	D8D4  11CDDF  		LD	DE,FCB
 162:	D8D7  C3CBD8  		JP	OPEN
 163:			;
 164:			;   Routine to close a file. (DE) points to FCB.
 165:			;
 166:	D8DA  0E10    	CLOSE:	LD	C,16
 167:	D8DC  C3C3D8  		JP	ENTRY1
 168:			;
 169:			;   Routine to search for the first file with ambigueous name
 170:			; (DE).
 171:			;
 172:	D8DF  0E11    	SRCHFST:LD	C,17
 173:	D8E1  C3C3D8  		JP	ENTRY1
 174:			;
 175:			;   Search for the next ambigeous file name.
 176:			;
 177:	D8E4  0E12    	SRCHNXT:LD	C,18
 178:	D8E6  C3C3D8  		JP	ENTRY1
 179:			;
 180:			;   Search for file at (FCB).
 181:			;
 182:	D8E9  11CDDF  	SRCHFCB:LD	DE,FCB
 183:	D8EC  C3DFD8  		JP	SRCHFST
 184:			;
 185:			;   Routine to delete a file pointed to by (DE).
 186:			;
 187:	D8EF  0E13    	DELETE:	LD	C,19
 188:	D8F1  C30500  		JP	ENTRYP
 189:			;
 190:			;   Routine to call the bdos and set the zero flag if a zero
 191:			; status is returned.
 192:			;
 193:	D8F4  CD0500  	ENTRY2:	CALL	ENTRYP
 194:	D8F7  B7      		OR	A		;set zero flag if appropriate.
 195:	D8F8  C9      		RET
 196:			;
 197:			;   Routine to read the next record from a sequential file.
 198:			; (DE) points to the FCB.
 199:			;
 200:	D8F9  0E14    	RDREC:	LD	C,20
 201:	D8FB  C3F4D8  		JP	ENTRY2
 202:			;
 203:			;   Routine to read file at (FCB).
 204:			;
 205:	D8FE  11CDDF  	READFCB:LD	DE,FCB
 206:	D901  C3F9D8  		JP	RDREC
 207:			;
 208:			;   Routine to write the next record of a sequential file.
 209:			; (DE) points to the FCB.
 210:			;
 211:	D904  0E15    	WRTREC:	LD	C,21
 212:	D906  C3F4D8  		JP	ENTRY2
 213:			;
 214:			;   Routine to create the file pointed to by (DE).
 215:			;
 216:	D909  0E16    	CREATE:	LD	C,22
 217:	D90B  C3C3D8  		JP	ENTRY1
 218:			;
 219:			;   Routine to rename the file pointed to by (DE). Note that
 220:			; the new name starts at (DE+16).
 221:			;
 222:	D90E  0E17    	RENAM:	LD	C,23
 223:	D910  C30500  		JP	ENTRYP
 224:			;
 225:			;   Get the current user code.
 226:			;
 227:	D913  1EFF    	GETUSR:	LD	E,0FFH
 228:			;
 229:			;   Routne to get or set the current user code.
 230:			; If (E) is FF then this is a GET, else it is a SET.
 231:			;
 232:	D915  0E20    	GETSETUC: LD	C,32
 233:	D917  C30500  		JP	ENTRYP
 234:			;
 235:			;   Routine to set the current drive byte at (TDRIVE).
 236:			;
 237:	D91A  CD13D9  	SETCDRV:CALL	GETUSR		;get user number
 238:	D91D  87      		ADD	A,A		;and shift into the upper 4 bits.
 239:	D91E  87      		ADD	A,A
 240:	D91F  87      		ADD	A,A
 241:	D920  87      		ADD	A,A
 242:	D921  21EFDF  		LD	HL,CDRIVE	;now add in the current drive number.
 243:	D924  B6      		OR	(HL)
 244:	D925  320400  		LD	(TDRIVE),A	;and save.
 245:	D928  C9      		RET
 246:			;
 247:			;   Move currently active drive down to (TDRIVE).
 248:			;
 249:	D929  3AEFDF  	MOVECD:	LD	A,(CDRIVE)
 250:	D92C  320400  		LD	(TDRIVE),A
 251:	D92F  C9      		RET
 252:			;
 253:			;   Routine to convert (A) into upper case ascii. Only letters
 254:			; are affected.
 255:			;
 256:	D930  FE61    	UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
 257:	D932  D8      		RET	C
 258:	D933  FE7B    		CP	'{'
 259:	D935  D0      		RET	NC
 260:	D936  E65F    		AND	5FH		;convert it if found.
 261:	D938  C9      		RET
 262:			;
 263:			;   Routine to get a line of input. We must check to see if the
 264:			; user is in (BATCH) mode. If so, then read the input from file
 265:			; ($$$.SUB). At the end, reset to console input.
 266:			;
 267:	D939  3AABDF  	GETINP:	LD	A,(BATCH)	;if =0, then use console input.
 268:	D93C  B7      		OR	A
 269:	D93D  CA96D9  		JP	Z,GETINP1
 270:			;
 271:			;   Use the submit file ($$$.sub) which is prepared by a
 272:			; SUBMIT run. It must be on drive (A) and it will be deleted
 273:			; if and error occures (like eof).
 274:			;
 275:	D940  3AEFDF  		LD	A,(CDRIVE)	;select drive 0 if need be.
 276:	D943  B7      		OR	A
 277:	D944  3E00    		LD	A,0		;always use drive A for submit.
 278:	D946  C4BDD8  		CALL	NZ,DSKSEL	;select it if required.
 279:	D949  11ACDF  		LD	DE,BATCHFCB
 280:	D94C  CDCBD8  		CALL	OPEN		;look for it.
 281:	D94F  CA96D9  		JP	Z,GETINP1	;if not there, use normal input.
 282:	D952  3ABBDF  		LD	A,(BATCHFCB+15)	;get last record number+1.
 283:	D955  3D      		DEC	A
 284:	D956  32CCDF  		LD	(BATCHFCB+32),A
 285:	D959  11ACDF  		LD	DE,BATCHFCB
 286:	D95C  CDF9D8  		CALL	RDREC		;read last record.
 287:	D95F  C296D9  		JP	NZ,GETINP1	;quit on end of file.
 288:			;
 289:			;   Move this record into input buffer.
 290:			;
 291:	D962  1107D8  		LD	DE,INBUFF+1
 292:	D965  218000  		LD	HL,TBUFF	;data was read into buffer here.
 293:	D968  0680    		LD	B,128		;all 128 characters may be used.
 294:	D96A  CD42DC  		CALL	HL2DE		;(HL) to (DE), (B) bytes.
 295:	D96D  21BADF  		LD	HL,BATCHFCB+14
 296:	D970  3600    		LD	(HL),0		;zero out the 's2' byte.
 297:	D972  23      		INC	HL		;and decrement the record count.
 298:	D973  35      		DEC	(HL)
 299:	D974  11ACDF  		LD	DE,BATCHFCB	;close the batch file now.
 300:	D977  CDDAD8  		CALL	CLOSE
 301:	D97A  CA96D9  		JP	Z,GETINP1	;quit on an error.
 302:	D97D  3AEFDF  		LD	A,(CDRIVE)	;re-select previous drive if need be.
 303:	D980  B7      		OR	A
 304:	D981  C4BDD8  		CALL	NZ,DSKSEL	;don't do needless selects.
 305:			;
 306:			;   Print line just read on console.
 307:			;
 308:	D984  2108D8  		LD	HL,INBUFF+2
 309:	D987  CDACD8  		CALL	PLINE2
 310:	D98A  CDC2D9  		CALL	CHKCON		;check console, quit on a key.
 311:	D98D  CAA7D9  		JP	Z,GETINP2	;jump if no key is pressed.
 312:			;
 313:			;   Terminate the submit job on any keyboard input. Delete this
 314:			; file such that it is not re-started and jump to normal keyboard
 315:			; input section.
 316:			;
 317:	D990  CDDDD9  		CALL	DELBATCH	;delete the batch file.
 318:	D993  C382DB  		JP	CMMND1		;and restart command input.
 319:			;
 320:			;   Get here for normal keyboard input. Delete the submit file
 321:			; incase there was one.
 322:			;
 323:	D996  CDDDD9  	GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
 324:	D999  CD1AD9  		CALL	SETCDRV		;reset active disk.
 325:	D99C  0E0A    		LD	C,10		;get line from console device.
 326:	D99E  1106D8  		LD	DE,INBUFF
 327:	D9A1  CD0500  		CALL	ENTRYP
 328:	D9A4  CD29D9  		CALL	MOVECD		;reset current drive (again).
 329:			;
 330:			;   Convert input line to upper case.
 331:			;
 332:	D9A7  2107D8  	GETINP2:LD	HL,INBUFF+1
 333:	D9AA  46      		LD	B,(HL)		;(B)=character counter.
 334:	D9AB  23      	GETINP3:INC	HL
 335:	D9AC  78      		LD	A,B		;end of the line?
 336:	D9AD  B7      		OR	A
 337:	D9AE  CABAD9  		JP	Z,GETINP4
 338:	D9B1  7E      		LD	A,(HL)		;convert to upper case.
 339:	D9B2  CD30D9  		CALL	UPPER
 340:	D9B5  77      		LD	(HL),A
 341:	D9B6  05      		DEC	B		;adjust character count.
 342:	D9B7  C3ABD9  		JP	GETINP3
 343:	D9BA  77      	GETINP4:LD	(HL),A		;add trailing null.
 344:	D9BB  2108D8  		LD	HL,INBUFF+2
 345:	D9BE  2288D8  		LD	(INPOINT),HL	;reset input line pointer.
 346:	D9C1  C9      		RET
 347:			;
 348:			;   Routine to check the console for a key pressed. The zero
 349:			; flag is set is none, else the character is returned in (A).
 350:			;
 351:	D9C2  0E0B    	CHKCON:	LD	C,11		;check console.
 352:	D9C4  CD0500  		CALL	ENTRYP
 353:	D9C7  B7      		OR	A
 354:	D9C8  C8      		RET	Z		;return if nothing.
 355:	D9C9  0E01    		LD	C,1		;else get character.
 356:	D9CB  CD0500  		CALL	ENTRYP
 357:	D9CE  B7      		OR	A		;clear zero flag and return.
 358:	D9CF  C9      		RET
 359:			;
 360:			;   Routine to get the currently active drive number.
 361:			;
 362:	D9D0  0E19    	GETDSK:	LD	C,25
 363:	D9D2  C30500  		JP	ENTRYP
 364:			;
 365:			;   Set the stabdard dma address.
 366:			;
 367:	D9D5  118000  	STDDMA:	LD	DE,TBUFF
 368:			;
 369:			;   Routine to set the dma address to (DE).
 370:			;
 371:	D9D8  0E1A    	DMASET:	LD	C,26
 372:	D9DA  C30500  		JP	ENTRYP
 373:			;
 374:			;  Delete the batch file created by SUBMIT.
 375:			;
 376:	D9DD  21ABDF  	DELBATCH: LD	HL,BATCH	;is batch active?
 377:	D9E0  7E      		LD	A,(HL)
 378:	D9E1  B7      		OR	A
 379:	D9E2  C8      		RET	Z
 380:	D9E3  3600    		LD	(HL),0		;yes, de-activate it.
 381:	D9E5  AF      		XOR	A
 382:	D9E6  CDBDD8  		CALL	DSKSEL		;select drive 0 for sure.
 383:	D9E9  11ACDF  		LD	DE,BATCHFCB	;and delete this file.
 384:	D9EC  CDEFD8  		CALL	DELETE
 385:	D9EF  3AEFDF  		LD	A,(CDRIVE)	;reset current drive.
 386:	D9F2  C3BDD8  		JP	DSKSEL
 387:			;
 388:			;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
 389:			; the same or we halt....
 390:			;
 391:	D9F5  1128DB  	VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
 392:	D9F8  2100E0  		LD	HL,PATTRN2	;ditto, but how could they be different?
 393:	D9FB  0606    		LD	B,6		;6 bytes each.
 394:	D9FD  1A      	VERIFY1:LD	A,(DE)
 395:	D9FE  BE      		CP	(HL)
 396:	D9FF  C2CFDB  		JP	NZ,SYSHALT	;jump to halt routine.
 397:	DA02  13      		INC	DE
 398:	DA03  23      		INC	HL
 399:	DA04  05      		DEC	B
 400:	DA05  C2FDD9  		JP	NZ,VERIFY1
 401:	DA08  C9      		RET
 402:			;
 403:			;   Print back file name with a '?' to indicate a syntax error.
 404:			;
 405:	DA09  CD98D8  	SYNERR:	CALL	CRLF		;end current line.
 406:	DA0C  2A8AD8  		LD	HL,(NAMEPNT)	;this points to name in error.
 407:	DA0F  7E      	SYNERR1:LD	A,(HL)		;print it until a space or null is found.
 408:	DA10  FE20    		CP	' '
 409:	DA12  CA22DA  		JP	Z,SYNERR2
 410:	DA15  B7      		OR	A
 411:	DA16  CA22DA  		JP	Z,SYNERR2
 412:	DA19  E5      		PUSH	HL
 413:	DA1A  CD8CD8  		CALL	PRINT
 414:	DA1D  E1      		POP	HL
 415:	DA1E  23      		INC	HL
 416:	DA1F  C30FDA  		JP	SYNERR1
 417:	DA22  3E3F    	SYNERR2:LD	A,'?'		;add trailing '?'.
 418:	DA24  CD8CD8  		CALL	PRINT
 419:	DA27  CD98D8  		CALL	CRLF
 420:	DA2A  CDDDD9  		CALL	DELBATCH	;delete any batch file.
 421:	DA2D  C382DB  		JP	CMMND1		;and restart from console input.
 422:			;
 423:			;   Check character at (DE) for legal command input. Note that the
 424:			; zero flag is set if the character is a delimiter.
 425:			;
 426:	DA30  1A      	CHECK:	LD	A,(DE)
 427:	DA31  B7      		OR	A
 428:	DA32  C8      		RET	Z
 429:	DA33  FE20    		CP	' '		;control characters are not legal here.
 430:	DA35  DA09DA  		JP	C,SYNERR
 431:	DA38  C8      		RET	Z		;check for valid delimiter.
 432:	DA39  FE3D    		CP	'='
 433:	DA3B  C8      		RET	Z
 434:	DA3C  FE5F    		CP	'_'
 435:	DA3E  C8      		RET	Z
 436:	DA3F  FE2E    		CP	'.'
 437:	DA41  C8      		RET	Z
 438:	DA42  FE3A    		CP	':'
 439:	DA44  C8      		RET	Z
 440:	DA45  FE3B    		CP	';'
 441:	DA47  C8      		RET	Z
 442:	DA48  FE3C    		CP	'<'
 443:	DA4A  C8      		RET	Z
 444:	DA4B  FE3E    		CP	'>'
 445:	DA4D  C8      		RET	Z
 446:	DA4E  C9      		RET
 447:			;
 448:			;   Get the next non-blank character from (DE).
 449:			;
 450:	DA4F  1A      	NONBLANK: LD	A,(DE)
 451:	DA50  B7      		OR	A		;string ends with a null.
 452:	DA51  C8      		RET	Z
 453:	DA52  FE20    		CP	' '
 454:	DA54  C0      		RET	NZ
 455:	DA55  13      		INC	DE
 456:	DA56  C34FDA  		JP	NONBLANK
 457:			;
 458:			;   Add (HL)=(HL)+(A)
 459:			;
 460:	DA59  85      	ADDHL:	ADD	A,L
 461:	DA5A  6F      		LD	L,A
 462:	DA5B  D0      		RET	NC		;take care of any carry.
 463:	DA5C  24      		INC	H
 464:	DA5D  C9      		RET
 465:			;
 466:			;   Convert the first name in (FCB).
 467:			;
 468:	DA5E  3E00    	CONVFST:LD	A,0
 469:			;
 470:			;   Format a file name (convert * to '?', etc.). On return,
 471:			; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
 472:			; the position within the fcb for the name (either 0 or 16).
 473:			;
 474:	DA60  21CDDF  	CONVERT:LD	HL,FCB
 475:	DA63  CD59DA  		CALL	ADDHL
 476:	DA66  E5      		PUSH	HL
 477:	DA67  E5      		PUSH	HL
 478:	DA68  AF      		XOR	A
 479:	DA69  32F0DF  		LD	(CHGDRV),A	;initialize drive change flag.
 480:	DA6C  2A88D8  		LD	HL,(INPOINT)	;set (HL) as pointer into input line.
 481:	DA6F  EB      		EX	DE,HL
 482:	DA70  CD4FDA  		CALL	NONBLANK	;get next non-blank character.
 483:	DA73  EB      		EX	DE,HL
 484:	DA74  228AD8  		LD	(NAMEPNT),HL	;save pointer here for any error message.
 485:	DA77  EB      		EX	DE,HL
 486:	DA78  E1      		POP	HL
 487:	DA79  1A      		LD	A,(DE)		;get first character.
 488:	DA7A  B7      		OR	A
 489:	DA7B  CA89DA  		JP	Z,CONVRT1
 490:	DA7E  DE40    		SBC	A,'A'-1		;might be a drive name, convert to binary.
 491:	DA80  47      		LD	B,A		;and save.
 492:	DA81  13      		INC	DE		;check next character for a ':'.
 493:	DA82  1A      		LD	A,(DE)
 494:	DA83  FE3A    		CP	':'
 495:	DA85  CA90DA  		JP	Z,CONVRT2
 496:	DA88  1B      		DEC	DE		;nope, move pointer back to the start of the line.
 497:	DA89  3AEFDF  	CONVRT1:LD	A,(CDRIVE)
 498:	DA8C  77      		LD	(HL),A
 499:	DA8D  C396DA  		JP	CONVRT3
 500:	DA90  78      	CONVRT2:LD	A,B
 501:	DA91  32F0DF  		LD	(CHGDRV),A	;set change in drives flag.
 502:	DA94  70      		LD	(HL),B
 503:	DA95  13      		INC	DE
 504:			;
 505:			;   Convert the basic file name.
 506:			;
 507:	DA96  0608    	CONVRT3:LD	B,08H
 508:	DA98  CD30DA  	CONVRT4:CALL	CHECK
 509:	DA9B  CAB9DA  		JP	Z,CONVRT8
 510:	DA9E  23      		INC	HL
 511:	DA9F  FE2A    		CP	'*'		;note that an '*' will fill the remaining
 512:	DAA1  C2A9DA  		JP	NZ,CONVRT5	;field with '?'.
 513:	DAA4  363F    		LD	(HL),'?'
 514:	DAA6  C3ABDA  		JP	CONVRT6
 515:	DAA9  77      	CONVRT5:LD	(HL),A
 516:	DAAA  13      		INC	DE
 517:	DAAB  05      	CONVRT6:DEC	B
 518:	DAAC  C298DA  		JP	NZ,CONVRT4
 519:	DAAF  CD30DA  	CONVRT7:CALL	CHECK		;get next delimiter.
 520:	DAB2  CAC0DA  		JP	Z,GETEXT
 521:	DAB5  13      		INC	DE
 522:	DAB6  C3AFDA  		JP	CONVRT7
 523:	DAB9  23      	CONVRT8:INC	HL		;blank fill the file name.
 524:	DABA  3620    		LD	(HL),' '
 525:	DABC  05      		DEC	B
 526:	DABD  C2B9DA  		JP	NZ,CONVRT8
 527:			;
 528:			;   Get the extension and convert it.
 529:			;
 530:	DAC0  0603    	GETEXT:	LD	B,03H
 531:	DAC2  FE2E    		CP	'.'
 532:	DAC4  C2E9DA  		JP	NZ,GETEXT5
 533:	DAC7  13      		INC	DE
 534:	DAC8  CD30DA  	GETEXT1:CALL	CHECK
 535:	DACB  CAE9DA  		JP	Z,GETEXT5
 536:	DACE  23      		INC	HL
 537:	DACF  FE2A    		CP	'*'
 538:	DAD1  C2D9DA  		JP	NZ,GETEXT2
 539:	DAD4  363F    		LD	(HL),'?'
 540:	DAD6  C3DBDA  		JP	GETEXT3
 541:	DAD9  77      	GETEXT2:LD	(HL),A
 542:	DADA  13      		INC	DE
 543:	DADB  05      	GETEXT3:DEC	B
 544:	DADC  C2C8DA  		JP	NZ,GETEXT1
 545:	DADF  CD30DA  	GETEXT4:CALL	CHECK
 546:	DAE2  CAF0DA  		JP	Z,GETEXT6
 547:	DAE5  13      		INC	DE
 548:	DAE6  C3DFDA  		JP	GETEXT4
 549:	DAE9  23      	GETEXT5:INC	HL
 550:	DAEA  3620    		LD	(HL),' '
 551:	DAEC  05      		DEC	B
 552:	DAED  C2E9DA  		JP	NZ,GETEXT5
 553:	DAF0  0603    	GETEXT6:LD	B,3
 554:	DAF2  23      	GETEXT7:INC	HL
 555:	DAF3  3600    		LD	(HL),0
 556:	DAF5  05      		DEC	B
 557:	DAF6  C2F2DA  		JP	NZ,GETEXT7
 558:	DAF9  EB      		EX	DE,HL
 559:	DAFA  2288D8  		LD	(INPOINT),HL	;save input line pointer.
 560:	DAFD  E1      		POP	HL
 561:			;
 562:			;   Check to see if this is an ambigeous file name specification.
 563:			; Set the (A) register to non zero if it is.
 564:			;
 565:	DAFE  010B00  		LD	BC,11		;set name length.
 566:	DB01  23      	GETEXT8:INC	HL
 567:	DB02  7E      		LD	A,(HL)
 568:	DB03  FE3F    		CP	'?'		;any question marks?
 569:	DB05  C209DB  		JP	NZ,GETEXT9
 570:	DB08  04      		INC	B		;count them.
 571:	DB09  0D      	GETEXT9:DEC	C
 572:	DB0A  C201DB  		JP	NZ,GETEXT8
 573:	DB0D  78      		LD	A,B
 574:	DB0E  B7      		OR	A
 575:	DB0F  C9      		RET
 576:			;
 577:			;   CP/M command table. Note commands can be either 3 or 4 characters long.
 578:			;
 579:	0006          	NUMCMDS EQU	6		;number of commands
 580:	DB10  44495220	CMDTBL:	DEFB	'DIR '
 581:	DB14  45524120		DEFB	'ERA '
 582:	DB18  54595045		DEFB	'TYPE'
 583:	DB1C  53415645		DEFB	'SAVE'
 584:	DB20  52454E20		DEFB	'REN '
 585:	DB24  55534552		DEFB	'USER'
 586:			;
 587:			;   The following six bytes must agree with those at (PATTRN2)
 588:			; or cp/m will SYSHALT. Why?
 589:			;
 590:	DB28  00160000	PATTRN1:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
	      0000
 591:			;
 592:			;   Search the command table for a match with what has just
 593:			; been entered. If a match is found, then we jump to the
 594:			; proper section. Else jump to (UNKNOWN).
 595:			; On return, the (C) register is set to the command number
 596:			; that matched (or NUMCMDS+1 if no match).
 597:			;
 598:	DB2E  2110DB  	SEARCH:	LD	HL,CMDTBL
 599:	DB31  0E00    		LD	C,0
 600:	DB33  79      	SEARCH1:LD	A,C
 601:	DB34  FE06    		CP	NUMCMDS		;this commands exists.
 602:	DB36  D0      		RET	NC
 603:	DB37  11CEDF  		LD	DE,FCB+1	;check this one.
 604:	DB3A  0604    		LD	B,4		;max command length.
 605:	DB3C  1A      	SEARCH2:LD	A,(DE)
 606:	DB3D  BE      		CP	(HL)
 607:	DB3E  C24FDB  		JP	NZ,SEARCH3	;not a match.
 608:	DB41  13      		INC	DE
 609:	DB42  23      		INC	HL
 610:	DB43  05      		DEC	B
 611:	DB44  C23CDB  		JP	NZ,SEARCH2
 612:	DB47  1A      		LD	A,(DE)		;allow a 3 character command to match.
 613:	DB48  FE20    		CP	' '
 614:	DB4A  C254DB  		JP	NZ,SEARCH4
 615:	DB4D  79      		LD	A,C		;set return register for this command.
 616:	DB4E  C9      		RET
 617:	DB4F  23      	SEARCH3:INC	HL
 618:	DB50  05      		DEC	B
 619:	DB51  C24FDB  		JP	NZ,SEARCH3
 620:	DB54  0C      	SEARCH4:INC	C
 621:	DB55  C333DB  		JP	SEARCH1
 622:			;
 623:			;   Set the input buffer to empty and then start the command
 624:			; processor (ccp).
 625:			;
 626:	DB58  AF      	CLEARBUF: XOR	A
 627:	DB59  3207D8  		LD	(INBUFF+1),A	;second byte is actual length.
 628:			;
 629:			;**************************************************************
 630:			;*
 631:			;*
 632:			;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
 633:			;*
 634:			;**************************************************************
 635:			;*
 636:	DB5C  31ABDF  	COMMAND:LD	SP,CCPSTACK	;setup stack area.
 637:	DB5F  C5      		PUSH	BC		;note that (C) should be equal to:
 638:	DB60  79      		LD	A,C		;(uuuudddd) where 'uuuu' is the user number
 639:	DB61  1F      		RRA			;and 'dddd' is the drive number.
 640:	DB62  1F      		RRA
 641:	DB63  1F      		RRA
 642:	DB64  1F      		RRA
 643:	DB65  E60F    		AND	0FH		;isolate the user number.
 644:	DB67  5F      		LD	E,A
 645:	DB68  CD15D9  		CALL	GETSETUC	;and set it.
 646:	DB6B  CDB8D8  		CALL	RESDSK		;reset the disk system.
 647:	DB6E  32ABDF  		LD	(BATCH),A	;clear batch mode flag.
 648:	DB71  C1      		POP	BC
 649:	DB72  79      		LD	A,C
 650:	DB73  E60F    		AND	0FH		;isolate the drive number.
 651:	DB75  32EFDF  		LD	(CDRIVE),A	;and save.
 652:	DB78  CDBDD8  		CALL	DSKSEL		;...and select.
 653:	DB7B  3A07D8  		LD	A,(INBUFF+1)
 654:	DB7E  B7      		OR	A		;anything in input buffer already?
 655:	DB7F  C298DB  		JP	NZ,CMMND2	;yes, we just process it.
 656:			;
 657:			;   Entry point to get a command line from the console.
 658:			;
 659:	DB82  31ABDF  	CMMND1:	LD	SP,CCPSTACK	;set stack straight.
 660:	DB85  CD98D8  		CALL	CRLF		;start a new line on the screen.
 661:	DB88  CDD0D9  		CALL	GETDSK		;get current drive.
 662:	DB8B  C661    		ADD	A,'a'
 663:	DB8D  CD8CD8  		CALL	PRINT		;print current drive.
 664:	DB90  3E3E    		LD	A,'>'
 665:	DB92  CD8CD8  		CALL	PRINT		;and add prompt.
 666:	DB95  CD39D9  		CALL	GETINP		;get line from user.
 667:			;
 668:			;   Process command line here.
 669:			;
 670:	DB98  118000  	CMMND2:	LD	DE,TBUFF
 671:	DB9B  CDD8D9  		CALL	DMASET		;set standard dma address.
 672:	DB9E  CDD0D9  		CALL	GETDSK
 673:	DBA1  32EFDF  		LD	(CDRIVE),A	;set current drive.
 674:	DBA4  CD5EDA  		CALL	CONVFST		;convert name typed in.
 675:	DBA7  C409DA  		CALL	NZ,SYNERR	;wild cards are not allowed.
 676:	DBAA  3AF0DF  		LD	A,(CHGDRV)	;if a change in drives was indicated,
 677:	DBAD  B7      		OR	A		;then treat this as an unknown command
 678:	DBAE  C2A5DE  		JP	NZ,UNKNOWN	;which gets executed.
 679:	DBB1  CD2EDB  		CALL	SEARCH		;else search command table for a match.
 680:			;
 681:			;   Note that an unknown command returns
 682:			; with (A) pointing to the last address
 683:			; in our table which is (UNKNOWN).
 684:			;
 685:	DBB4  21C1DB  		LD	HL,CMDADR	;now, look thru our address table for command (A).
 686:	DBB7  5F      		LD	E,A		;set (DE) to command number.
 687:	DBB8  1600    		LD	D,0
 688:	DBBA  19      		ADD	HL,DE
 689:	DBBB  19      		ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
 690:	DBBC  7E      		LD	A,(HL)		;now pick out this address.
 691:	DBBD  23      		INC	HL
 692:	DBBE  66      		LD	H,(HL)
 693:	DBBF  6F      		LD	L,A
 694:	DBC0  E9      		JP	(HL)		;now execute it.
 695:			;
 696:			;   CP/M command address table.
 697:			;
 698:	DBC1  77DC1FDD	CMDADR:	DEFW	DIRECT,ERASE,TYPE,SAVE
	      5DDDADDD
 699:	DBC9  10DE8EDE		DEFW	RENAME,USER,UNKNOWN
	      A5DE
 700:			;
 701:			;   Halt the system. Reason for this is unknown at present.
 702:			;
 703:	DBCF          	SYSHALT:
 704:	DBCF  21F376  		LD	HL,76F3H	;'DI HLT' instructions.
 705:	DBD2  2200D8  		LD	(CBASE),HL
 706:	DBD5  2100D8  		LD	HL,CBASE
 707:	DBD8  E9      		JP	(HL)
 708:			;
 709:			;   Read error while TYPEing a file.
 710:			;
 711:	DBD9  01DFDB  	RDERROR:LD	BC,RDERR
 712:	DBDC  C3A7D8  		JP	PLINE
 713:	DBDF  52656164	RDERR:	DEFB	'Read error',0
	      20657272
	      6F7200
 714:			;
 715:			;   Required file was not located.
 716:			;
 717:	DBEA  01F0DB  	NONE:	LD	BC,NOFILE
 718:	DBED  C3A7D8  		JP	PLINE
 719:	DBF0  4E6F2066	NOFILE:	DEFB	'No file',0
	      696C6500
 720:			;
 721:			;   Decode a command of the form 'A>filename number{ filename}.
 722:			; Note that a drive specifier is not allowed on the first file
 723:			; name. On return, the number is in register (A). Any error
 724:			; causes 'filename?' to be printed and the command is aborted.
 725:			;
 726:	DBF8  CD5EDA  	DECODE:	CALL	CONVFST		;convert filename.
 727:	DBFB  3AF0DF  		LD	A,(CHGDRV)	;do not allow a drive to be specified.
 728:	DBFE  B7      		OR	A
 729:	DBFF  C209DA  		JP	NZ,SYNERR
 730:	DC02  21CEDF  		LD	HL,FCB+1	;convert number now.
 731:	DC05  010B00  		LD	BC,11		;(B)=sum register, (C)=max digit count.
 732:	DC08  7E      	DECODE1:LD	A,(HL)
 733:	DC09  FE20    		CP	' '		;a space terminates the numeral.
 734:	DC0B  CA33DC  		JP	Z,DECODE3
 735:	DC0E  23      		INC	HL
 736:	DC0F  D630    		SUB	'0'		;make binary from ascii.
 737:	DC11  FE0A    		CP	10		;legal digit?
 738:	DC13  D209DA  		JP	NC,SYNERR
 739:	DC16  57      		LD	D,A		;yes, save it in (D).
 740:	DC17  78      		LD	A,B		;compute (B)=(B)*10 and check for overflow.
 741:	DC18  E6E0    		AND	0E0H
 742:	DC1A  C209DA  		JP	NZ,SYNERR
 743:	DC1D  78      		LD	A,B
 744:	DC1E  07      		RLCA
 745:	DC1F  07      		RLCA
 746:	DC20  07      		RLCA			;(A)=(B)*8
 747:	DC21  80      		ADD	A,B		;.......*9
 748:	DC22  DA09DA  		JP	C,SYNERR
 749:	DC25  80      		ADD	A,B		;.......*10
 750:	DC26  DA09DA  		JP	C,SYNERR
 751:	DC29  82      		ADD	A,D		;add in new digit now.
 752:	DC2A  DA09DA  	DECODE2:JP	C,SYNERR
 753:	DC2D  47      		LD	B,A		;and save result.
 754:	DC2E  0D      		DEC	C		;only look at 11 digits.
 755:	DC2F  C208DC  		JP	NZ,DECODE1
 756:	DC32  C9      		RET
 757:	DC33  7E      	DECODE3:LD	A,(HL)		;spaces must follow (why?).
 758:	DC34  FE20    		CP	' '
 759:	DC36  C209DA  		JP	NZ,SYNERR
 760:	DC39  23      		INC	HL
 761:	DC3A  0D      	DECODE4:DEC	C
 762:	DC3B  C233DC  		JP	NZ,DECODE3
 763:	DC3E  78      		LD	A,B		;set (A)=the numeric value entered.
 764:	DC3F  C9      		RET
 765:			;
 766:			;   Move 3 bytes from (HL) to (DE). Note that there is only
 767:			; one reference to this at (A2D5h).
 768:			;
 769:	DC40  0603    	MOVE3:	LD	B,3
 770:			;
 771:			;   Move (B) bytes from (HL) to (DE).
 772:			;
 773:	DC42  7E      	HL2DE:	LD	A,(HL)
 774:	DC43  12      		LD	(DE),A
 775:	DC44  23      		INC	HL
 776:	DC45  13      		INC	DE
 777:	DC46  05      		DEC	B
 778:	DC47  C242DC  		JP	NZ,HL2DE
 779:	DC4A  C9      		RET
 780:			;
 781:			;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
 782:			;
 783:	DC4B  218000  	EXTRACT:LD	HL,TBUFF
 784:	DC4E  81      		ADD	A,C
 785:	DC4F  CD59DA  		CALL	ADDHL
 786:	DC52  7E      		LD	A,(HL)
 787:	DC53  C9      		RET
 788:			;
 789:			;  Check drive specified. If it means a change, then the new
 790:			; drive will be selected. In any case, the drive byte of the
 791:			; fcb will be set to null (means use current drive).
 792:			;
 793:	DC54  AF      	DSELECT:XOR	A		;null out first byte of fcb.
 794:	DC55  32CDDF  		LD	(FCB),A
 795:	DC58  3AF0DF  		LD	A,(CHGDRV)	;a drive change indicated?
 796:	DC5B  B7      		OR	A
 797:	DC5C  C8      		RET	Z
 798:	DC5D  3D      		DEC	A		;yes, is it the same as the current drive?
 799:	DC5E  21EFDF  		LD	HL,CDRIVE
 800:	DC61  BE      		CP	(HL)
 801:	DC62  C8      		RET	Z
 802:	DC63  C3BDD8  		JP	DSKSEL		;no. Select it then.
 803:			;
 804:			;   Check the drive selection and reset it to the previous
 805:			; drive if it was changed for the preceeding command.
 806:			;
 807:	DC66  3AF0DF  	RESETDR:LD	A,(CHGDRV)	;drive change indicated?
 808:	DC69  B7      		OR	A
 809:	DC6A  C8      		RET	Z
 810:	DC6B  3D      		DEC	A		;yes, was it a different drive?
 811:	DC6C  21EFDF  		LD	HL,CDRIVE
 812:	DC6F  BE      		CP	(HL)
 813:	DC70  C8      		RET	Z
 814:	DC71  3AEFDF  		LD	A,(CDRIVE)	;yes, re-select our old drive.
 815:	DC74  C3BDD8  		JP	DSKSEL
 816:			;
 817:			;**************************************************************
 818:			;*
 819:			;*           D I R E C T O R Y   C O M M A N D
 820:			;*
 821:			;**************************************************************
 822:			;
 823:	DC77  CD5EDA  	DIRECT:	CALL	CONVFST		;convert file name.
 824:	DC7A  CD54DC  		CALL	DSELECT		;select indicated drive.
 825:	DC7D  21CEDF  		LD	HL,FCB+1	;was any file indicated?
 826:	DC80  7E      		LD	A,(HL)
 827:	DC81  FE20    		CP	' '
 828:	DC83  C28FDC  		JP	NZ,DIRECT2
 829:	DC86  060B    		LD	B,11		;no. Fill field with '?' - same as *.*.
 830:	DC88  363F    	DIRECT1:LD	(HL),'?'
 831:	DC8A  23      		INC	HL
 832:	DC8B  05      		DEC	B
 833:	DC8C  C288DC  		JP	NZ,DIRECT1
 834:	DC8F  1E00    	DIRECT2:LD	E,0		;set initial cursor position.
 835:	DC91  D5      		PUSH	DE
 836:	DC92  CDE9D8  		CALL	SRCHFCB		;get first file name.
 837:	DC95  CCEADB  		CALL	Z,NONE		;none found at all?
 838:	DC98  CA1BDD  	DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
 839:	DC9B  3AEEDF  		LD	A,(RTNCODE)	;get file's position in segment (0-3).
 840:	DC9E  0F      		RRCA
 841:	DC9F  0F      		RRCA
 842:	DCA0  0F      		RRCA
 843:	DCA1  E660    		AND	60H		;(A)=position*32
 844:	DCA3  4F      		LD	C,A
 845:	DCA4  3E0A    		LD	A,10
 846:	DCA6  CD4BDC  		CALL	EXTRACT		;extract the tenth entry in fcb.
 847:	DCA9  17      		RLA			;check system file status bit.
 848:	DCAA  DA0FDD  		JP	C,DIRECT8	;we don't list them.
 849:	DCAD  D1      		POP	DE
 850:	DCAE  7B      		LD	A,E		;bump name count.
 851:	DCAF  1C      		INC	E
 852:	DCB0  D5      		PUSH	DE
 853:	DCB1  E603    		AND	03H		;at end of line?
 854:	DCB3  F5      		PUSH	AF
 855:	DCB4  C2CCDC  		JP	NZ,DIRECT4
 856:	DCB7  CD98D8  		CALL	CRLF		;yes, end this line and start another.
 857:	DCBA  C5      		PUSH	BC
 858:	DCBB  CDD0D9  		CALL	GETDSK		;start line with ('A:').
 859:	DCBE  C1      		POP	BC
 860:	DCBF  C641    		ADD	A,'A'
 861:	DCC1  CD92D8  		CALL	PRINTB
 862:	DCC4  3E3A    		LD	A,':'
 863:	DCC6  CD92D8  		CALL	PRINTB
 864:	DCC9  C3D4DC  		JP	DIRECT5
 865:	DCCC  CDA2D8  	DIRECT4:CALL	PSPACE		;add seperator between file names.
 866:	DCCF  3E3A    		LD	A,':'
 867:	DCD1  CD92D8  		CALL	PRINTB
 868:	DCD4  CDA2D8  	DIRECT5:CALL	PSPACE
 869:	DCD7  0601    		LD	B,1		;'extract' each file name character at a time.
 870:	DCD9  78      	DIRECT6:LD	A,B
 871:	DCDA  CD4BDC  		CALL	EXTRACT
 872:	DCDD  E67F    		AND	7FH		;strip bit 7 (status bit).
 873:	DCDF  FE20    		CP	' '		;are we at the end of the name?
 874:	DCE1  C2F9DC  		JP	NZ,DRECT65
 875:	DCE4  F1      		POP	AF		;yes, don't print spaces at the end of a line.
 876:	DCE5  F5      		PUSH	AF
 877:	DCE6  FE03    		CP	3
 878:	DCE8  C2F7DC  		JP	NZ,DRECT63
 879:	DCEB  3E09    		LD	A,9		;first check for no extension.
 880:	DCED  CD4BDC  		CALL	EXTRACT
 881:	DCF0  E67F    		AND	7FH
 882:	DCF2  FE20    		CP	' '
 883:	DCF4  CA0EDD  		JP	Z,DIRECT7	;don't print spaces.
 884:	DCF7  3E20    	DRECT63:LD	A,' '		;else print them.
 885:	DCF9  CD92D8  	DRECT65:CALL	PRINTB
 886:	DCFC  04      		INC	B		;bump to next character psoition.
 887:	DCFD  78      		LD	A,B
 888:	DCFE  FE0C    		CP	12		;end of the name?
 889:	DD00  D20EDD  		JP	NC,DIRECT7
 890:	DD03  FE09    		CP	9		;nope, starting extension?
 891:	DD05  C2D9DC  		JP	NZ,DIRECT6
 892:	DD08  CDA2D8  		CALL	PSPACE		;yes, add seperating space.
 893:	DD0B  C3D9DC  		JP	DIRECT6
 894:	DD0E  F1      	DIRECT7:POP	AF		;get the next file name.
 895:	DD0F  CDC2D9  	DIRECT8:CALL	CHKCON		;first check console, quit on anything.
 896:	DD12  C21BDD  		JP	NZ,DIRECT9
 897:	DD15  CDE4D8  		CALL	SRCHNXT		;get next name.
 898:	DD18  C398DC  		JP	DIRECT3		;and continue with our list.
 899:	DD1B  D1      	DIRECT9:POP	DE		;restore the stack and return to command level.
 900:	DD1C  C386DF  		JP	GETBACK
 901:			;
 902:			;**************************************************************
 903:			;*
 904:			;*                E R A S E   C O M M A N D
 905:			;*
 906:			;**************************************************************
 907:			;
 908:	DD1F  CD5EDA  	ERASE:	CALL	CONVFST		;convert file name.
 909:	DD22  FE0B    		CP	11		;was '*.*' entered?
 910:	DD24  C242DD  		JP	NZ,ERASE1
 911:	DD27  0152DD  		LD	BC,YESNO	;yes, ask for confirmation.
 912:	DD2A  CDA7D8  		CALL	PLINE
 913:	DD2D  CD39D9  		CALL	GETINP
 914:	DD30  2107D8  		LD	HL,INBUFF+1
 915:	DD33  35      		DEC	(HL)		;must be exactly 'y'.
 916:	DD34  C282DB  		JP	NZ,CMMND1
 917:	DD37  23      		INC	HL
 918:	DD38  7E      		LD	A,(HL)
 919:	DD39  FE59    		CP	'Y'
 920:	DD3B  C282DB  		JP	NZ,CMMND1
 921:	DD3E  23      		INC	HL
 922:	DD3F  2288D8  		LD	(INPOINT),HL	;save input line pointer.
 923:	DD42  CD54DC  	ERASE1:	CALL	DSELECT		;select desired disk.
 924:	DD45  11CDDF  		LD	DE,FCB
 925:	DD48  CDEFD8  		CALL	DELETE		;delete the file.
 926:	DD4B  3C      		INC	A
 927:	DD4C  CCEADB  		CALL	Z,NONE		;not there?
 928:	DD4F  C386DF  		JP	GETBACK		;return to command level now.
 929:	DD52  416C6C20	YESNO:	DEFB	'All (y/n)?',0
	      28792F6E
	      293F00
 930:			;
 931:			;**************************************************************
 932:			;*
 933:			;*            T Y P E   C O M M A N D
 934:			;*
 935:			;**************************************************************
 936:			;
 937:	DD5D  CD5EDA  	TYPE:	CALL	CONVFST		;convert file name.
 938:	DD60  C209DA  		JP	NZ,SYNERR	;wild cards not allowed.
 939:	DD63  CD54DC  		CALL	DSELECT		;select indicated drive.
 940:	DD66  CDD0D8  		CALL	OPENFCB		;open the file.
 941:	DD69  CAA7DD  		JP	Z,TYPE5		;not there?
 942:	DD6C  CD98D8  		CALL	CRLF		;ok, start a new line on the screen.
 943:	DD6F  21F1DF  		LD	HL,NBYTES	;initialize byte counter.
 944:	DD72  36FF    		LD	(HL),0FFH	;set to read first sector.
 945:	DD74  21F1DF  	TYPE1:	LD	HL,NBYTES
 946:	DD77  7E      	TYPE2:	LD	A,(HL)		;have we written the entire sector?
 947:	DD78  FE80    		CP	128
 948:	DD7A  DA87DD  		JP	C,TYPE3
 949:	DD7D  E5      		PUSH	HL		;yes, read in the next one.
 950:	DD7E  CDFED8  		CALL	READFCB
 951:	DD81  E1      		POP	HL
 952:	DD82  C2A0DD  		JP	NZ,TYPE4	;end or error?
 953:	DD85  AF      		XOR	A		;ok, clear byte counter.
 954:	DD86  77      		LD	(HL),A
 955:	DD87  34      	TYPE3:	INC	(HL)		;count this byte.
 956:	DD88  218000  		LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
 957:	DD8B  CD59DA  		CALL	ADDHL
 958:	DD8E  7E      		LD	A,(HL)
 959:	DD8F  FE1A    		CP	CNTRLZ		;end of file mark?
 960:	DD91  CA86DF  		JP	Z,GETBACK
 961:	DD94  CD8CD8  		CALL	PRINT		;no, print it.
 962:	DD97  CDC2D9  		CALL	CHKCON		;check console, quit if anything ready.
 963:	DD9A  C286DF  		JP	NZ,GETBACK
 964:	DD9D  C374DD  		JP	TYPE1
 965:			;
 966:			;   Get here on an end of file or read error.
 967:			;
 968:	DDA0  3D      	TYPE4:	DEC	A		;read error?
 969:	DDA1  CA86DF  		JP	Z,GETBACK
 970:	DDA4  CDD9DB  		CALL	RDERROR		;yes, print message.
 971:	DDA7  CD66DC  	TYPE5:	CALL	RESETDR		;and reset proper drive
 972:	DDAA  C309DA  		JP	SYNERR		;now print file name with problem.
 973:			;
 974:			;**************************************************************
 975:			;*
 976:			;*            S A V E   C O M M A N D
 977:			;*
 978:			;**************************************************************
 979:			;
 980:	DDAD  CDF8DB  	SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
 981:	DDB0  F5      		PUSH	AF		;save number of pages to write.
 982:	DDB1  CD5EDA  		CALL	CONVFST		;convert file name.
 983:	DDB4  C209DA  		JP	NZ,SYNERR	;wild cards not allowed.
 984:	DDB7  CD54DC  		CALL	DSELECT		;select specified drive.
 985:	DDBA  11CDDF  		LD	DE,FCB		;now delete this file.
 986:	DDBD  D5      		PUSH	DE
 987:	DDBE  CDEFD8  		CALL	DELETE
 988:	DDC1  D1      		POP	DE
 989:	DDC2  CD09D9  		CALL	CREATE		;and create it again.
 990:	DDC5  CAFBDD  		JP	Z,SAVE3		;can't create?
 991:	DDC8  AF      		XOR	A		;clear record number byte.
 992:	DDC9  32EDDF  		LD	(FCB+32),A
 993:	DDCC  F1      		POP	AF		;convert pages to sectors.
 994:	DDCD  6F      		LD	L,A
 995:	DDCE  2600    		LD	H,0
 996:	DDD0  29      		ADD	HL,HL		;(HL)=number of sectors to write.
 997:	DDD1  110001  		LD	DE,TBASE	;and we start from here.
 998:	DDD4  7C      	SAVE1:	LD	A,H		;done yet?
 999:	DDD5  B5      		OR	L
1000:	DDD6  CAF1DD  		JP	Z,SAVE2
1001:	DDD9  2B      		DEC	HL		;nope, count this and compute the start
1002:	DDDA  E5      		PUSH	HL		;of the next 128 byte sector.
1003:	DDDB  218000  		LD	HL,128
1004:	DDDE  19      		ADD	HL,DE
1005:	DDDF  E5      		PUSH	HL		;save it and set the transfer address.
1006:	DDE0  CDD8D9  		CALL	DMASET
1007:	DDE3  11CDDF  		LD	DE,FCB		;write out this sector now.
1008:	DDE6  CD04D9  		CALL	WRTREC
1009:	DDE9  D1      		POP	DE		;reset (DE) to the start of the last sector.
1010:	DDEA  E1      		POP	HL		;restore sector count.
1011:	DDEB  C2FBDD  		JP	NZ,SAVE3	;write error?
1012:	DDEE  C3D4DD  		JP	SAVE1
1013:			;
1014:			;   Get here after writing all of the file.
1015:			;
1016:	DDF1  11CDDF  	SAVE2:	LD	DE,FCB		;now close the file.
1017:	DDF4  CDDAD8  		CALL	CLOSE
1018:	DDF7  3C      		INC	A		;did it close ok?
1019:	DDF8  C201DE  		JP	NZ,SAVE4
1020:			;
1021:			;   Print out error message (no space).
1022:			;
1023:	DDFB  0107DE  	SAVE3:	LD	BC,NOSPACE
1024:	DDFE  CDA7D8  		CALL	PLINE
1025:	DE01  CDD5D9  	SAVE4:	CALL	STDDMA		;reset the standard dma address.
1026:	DE04  C386DF  		JP	GETBACK
1027:	DE07  4E6F2073	NOSPACE:DEFB	'No space',0
	      70616365
	      00
1028:			;
1029:			;**************************************************************
1030:			;*
1031:			;*           R E N A M E   C O M M A N D
1032:			;*
1033:			;**************************************************************
1034:			;
1035:	DE10  CD5EDA  	RENAME:	CALL	CONVFST		;convert first file name.
1036:	DE13  C209DA  		JP	NZ,SYNERR	;wild cards not allowed.
1037:	DE16  3AF0DF  		LD	A,(CHGDRV)	;remember any change in drives specified.
1038:	DE19  F5      		PUSH	AF
1039:	DE1A  CD54DC  		CALL	DSELECT		;and select this drive.
1040:	DE1D  CDE9D8  		CALL	SRCHFCB		;is this file present?
1041:	DE20  C279DE  		JP	NZ,RENAME6	;yes, print error message.
1042:	DE23  21CDDF  		LD	HL,FCB		;yes, move this name into second slot.
1043:	DE26  11DDDF  		LD	DE,FCB+16
1044:	DE29  0610    		LD	B,16
1045:	DE2B  CD42DC  		CALL	HL2DE
1046:	DE2E  2A88D8  		LD	HL,(INPOINT)	;get input pointer.
1047:	DE31  EB      		EX	DE,HL
1048:	DE32  CD4FDA  		CALL	NONBLANK	;get next non blank character.
1049:	DE35  FE3D    		CP	'='		;only allow an '=' or '_' seperator.
1050:	DE37  CA3FDE  		JP	Z,RENAME1
1051:	DE3A  FE5F    		CP	'_'
1052:	DE3C  C273DE  		JP	NZ,RENAME5
1053:	DE3F  EB      	RENAME1:EX	DE,HL
1054:	DE40  23      		INC	HL		;ok, skip seperator.
1055:	DE41  2288D8  		LD	(INPOINT),HL	;save input line pointer.
1056:	DE44  CD5EDA  		CALL	CONVFST		;convert this second file name now.
1057:	DE47  C273DE  		JP	NZ,RENAME5	;again, no wild cards.
1058:	DE4A  F1      		POP	AF		;if a drive was specified, then it
1059:	DE4B  47      		LD	B,A		;must be the same as before.
1060:	DE4C  21F0DF  		LD	HL,CHGDRV
1061:	DE4F  7E      		LD	A,(HL)
1062:	DE50  B7      		OR	A
1063:	DE51  CA59DE  		JP	Z,RENAME2
1064:	DE54  B8      		CP	B
1065:	DE55  70      		LD	(HL),B
1066:	DE56  C273DE  		JP	NZ,RENAME5	;they were different, error.
1067:	DE59  70      	RENAME2:LD	(HL),B		;	reset as per the first file specification.
1068:	DE5A  AF      		XOR	A
1069:	DE5B  32CDDF  		LD	(FCB),A		;clear the drive byte of the fcb.
1070:	DE5E  CDE9D8  	RENAME3:CALL	SRCHFCB		;and go look for second file.
1071:	DE61  CA6DDE  		JP	Z,RENAME4	;doesn't exist?
1072:	DE64  11CDDF  		LD	DE,FCB
1073:	DE67  CD0ED9  		CALL	RENAM		;ok, rename the file.
1074:	DE6A  C386DF  		JP	GETBACK
1075:			;
1076:			;   Process rename errors here.
1077:			;
1078:	DE6D  CDEADB  	RENAME4:CALL	NONE		;file not there.
1079:	DE70  C386DF  		JP	GETBACK
1080:	DE73  CD66DC  	RENAME5:CALL	RESETDR		;bad command format.
1081:	DE76  C309DA  		JP	SYNERR
1082:	DE79  0182DE  	RENAME6:LD	BC,EXISTS	;destination file already exists.
1083:	DE7C  CDA7D8  		CALL	PLINE
1084:	DE7F  C386DF  		JP	GETBACK
1085:	DE82  46696C65	EXISTS:	DEFB	'File exists',0
	      20657869
	      73747300
1086:			;
1087:			;**************************************************************
1088:			;*
1089:			;*             U S E R   C O M M A N D
1090:			;*
1091:			;**************************************************************
1092:			;
1093:	DE8E  CDF8DB  	USER:	CALL	DECODE		;get numeric value following command.
1094:	DE91  FE10    		CP	16		;legal user number?
1095:	DE93  D209DA  		JP	NC,SYNERR
1096:	DE96  5F      		LD	E,A		;yes but is there anything else?
1097:	DE97  3ACEDF  		LD	A,(FCB+1)
1098:	DE9A  FE20    		CP	' '
1099:	DE9C  CA09DA  		JP	Z,SYNERR	;yes, that is not allowed.
1100:	DE9F  CD15D9  		CALL	GETSETUC	;ok, set user code.
1101:	DEA2  C389DF  		JP	GETBACK1
1102:			;
1103:			;**************************************************************
1104:			;*
1105:			;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1106:			;*
1107:			;**************************************************************
1108:			;
1109:	DEA5  CDF5D9  	UNKNOWN:CALL	VERIFY		;check for valid system (why?).
1110:	DEA8  3ACEDF  		LD	A,(FCB+1)	;anything to execute?
1111:	DEAB  FE20    		CP	' '
1112:	DEAD  C2C4DE  		JP	NZ,UNKWN1
1113:	DEB0  3AF0DF  		LD	A,(CHGDRV)	;nope, only a drive change?
1114:	DEB3  B7      		OR	A
1115:	DEB4  CA89DF  		JP	Z,GETBACK1	;neither???
1116:	DEB7  3D      		DEC	A
1117:	DEB8  32EFDF  		LD	(CDRIVE),A	;ok, store new drive.
1118:	DEBB  CD29D9  		CALL	MOVECD		;set (TDRIVE) also.
1119:	DEBE  CDBDD8  		CALL	DSKSEL		;and select this drive.
1120:	DEC1  C389DF  		JP	GETBACK1	;then return.
1121:			;
1122:			;   Here a file name was typed. Prepare to execute it.
1123:			;
1124:	DEC4  11D6DF  	UNKWN1:	LD	DE,FCB+9	;an extension specified?
1125:	DEC7  1A      		LD	A,(DE)
1126:	DEC8  FE20    		CP	' '
1127:	DECA  C209DA  		JP	NZ,SYNERR	;yes, not allowed.
1128:	DECD  D5      	UNKWN2:	PUSH	DE
1129:	DECE  CD54DC  		CALL	DSELECT		;select specified drive.
1130:	DED1  D1      		POP	DE
1131:	DED2  2183DF  		LD	HL,COMFILE	;set the extension to 'COM'.
1132:	DED5  CD40DC  		CALL	MOVE3
1133:	DED8  CDD0D8  		CALL	OPENFCB		;and open this file.
1134:	DEDB  CA6BDF  		JP	Z,UNKWN9	;not present?
1135:			;
1136:			;   Load in the program.
1137:			;
1138:	DEDE  210001  		LD	HL,TBASE	;store the program starting here.
1139:	DEE1  E5      	UNKWN3:	PUSH	HL
1140:	DEE2  EB      		EX	DE,HL
1141:	DEE3  CDD8D9  		CALL	DMASET		;set transfer address.
1142:	DEE6  11CDDF  		LD	DE,FCB		;and read the next record.
1143:	DEE9  CDF9D8  		CALL	RDREC
1144:	DEEC  C201DF  		JP	NZ,UNKWN4	;end of file or read error?
1145:	DEEF  E1      		POP	HL		;nope, bump pointer for next sector.
1146:	DEF0  118000  		LD	DE,128
1147:	DEF3  19      		ADD	HL,DE
1148:	DEF4  1100D8  		LD	DE,CBASE	;enough room for the whole file?
1149:	DEF7  7D      		LD	A,L
1150:	DEF8  93      		SUB	E
1151:	DEF9  7C      		LD	A,H
1152:	DEFA  9A      		SBC	A,D
1153:	DEFB  D271DF  		JP	NC,UNKWN0	;no, it can't fit.
1154:	DEFE  C3E1DE  		JP	UNKWN3
1155:			;
1156:			;   Get here after finished reading.
1157:			;
1158:	DF01  E1      	UNKWN4:	POP	HL
1159:	DF02  3D      		DEC	A		;normal end of file?
1160:	DF03  C271DF  		JP	NZ,UNKWN0
1161:	DF06  CD66DC  		CALL	RESETDR		;yes, reset previous drive.
1162:	DF09  CD5EDA  		CALL	CONVFST		;convert the first file name that follows
1163:	DF0C  21F0DF  		LD	HL,CHGDRV	;command name.
1164:	DF0F  E5      		PUSH	HL
1165:	DF10  7E      		LD	A,(HL)		;set drive code in default fcb.
1166:	DF11  32CDDF  		LD	(FCB),A
1167:	DF14  3E10    		LD	A,16		;put second name 16 bytes later.
1168:	DF16  CD60DA  		CALL	CONVERT		;convert second file name.
1169:	DF19  E1      		POP	HL
1170:	DF1A  7E      		LD	A,(HL)		;and set the drive for this second file.
1171:	DF1B  32DDDF  		LD	(FCB+16),A
1172:	DF1E  AF      		XOR	A		;clear record byte in fcb.
1173:	DF1F  32EDDF  		LD	(FCB+32),A
1174:	DF22  115C00  		LD	DE,TFCB		;move it into place at(005Ch).
1175:	DF25  21CDDF  		LD	HL,FCB
1176:	DF28  0621    		LD	B,33
1177:	DF2A  CD42DC  		CALL	HL2DE
1178:	DF2D  2108D8  		LD	HL,INBUFF+2	;now move the remainder of the input
1179:	DF30  7E      	UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
1180:	DF31  B7      		OR	A		;or a null.
1181:	DF32  CA3EDF  		JP	Z,UNKWN6
1182:	DF35  FE20    		CP	' '
1183:	DF37  CA3EDF  		JP	Z,UNKWN6
1184:	DF3A  23      		INC	HL
1185:	DF3B  C330DF  		JP	UNKWN5
1186:			;
1187:			;   Do the line move now. It ends in a null byte.
1188:			;
1189:	DF3E  0600    	UNKWN6:	LD	B,0		;keep a character count.
1190:	DF40  118100  		LD	DE,TBUFF+1	;data gets put here.
1191:	DF43  7E      	UNKWN7:	LD	A,(HL)		;move it now.
1192:	DF44  12      		LD	(DE),A
1193:	DF45  B7      		OR	A
1194:	DF46  CA4FDF  		JP	Z,UNKWN8
1195:	DF49  04      		INC	B
1196:	DF4A  23      		INC	HL
1197:	DF4B  13      		INC	DE
1198:	DF4C  C343DF  		JP	UNKWN7
1199:	DF4F  78      	UNKWN8:	LD	A,B		;now store the character count.
1200:	DF50  328000  		LD	(TBUFF),A
1201:	DF53  CD98D8  		CALL	CRLF		;clean up the screen.
1202:	DF56  CDD5D9  		CALL	STDDMA		;set standard transfer address.
1203:	DF59  CD1AD9  		CALL	SETCDRV		;reset current drive.
1204:	DF5C  CD0001  		CALL	TBASE		;and execute the program.
1205:			;
1206:			;   Transiant programs return here (or reboot).
1207:			;
1208:	DF5F  31ABDF  		LD	SP,BATCH	;set stack first off.
1209:	DF62  CD29D9  		CALL	MOVECD		;move current drive into place (TDRIVE).
1210:	DF65  CDBDD8  		CALL	DSKSEL		;and reselect it.
1211:	DF68  C382DB  		JP	CMMND1		;back to comand mode.
1212:			;
1213:			;   Get here if some error occured.
1214:			;
1215:	DF6B  CD66DC  	UNKWN9:	CALL	RESETDR		;inproper format.
1216:	DF6E  C309DA  		JP	SYNERR
1217:	DF71  017ADF  	UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
1218:	DF74  CDA7D8  		CALL	PLINE
1219:	DF77  C386DF  		JP	GETBACK
1220:	DF7A  42616420	BADLOAD:DEFB	'Bad load',0
	      6C6F6164
	      00
1221:	DF83  434F4D  	COMFILE:DEFB	'COM'		;command file extension.
1222:			;
1223:			;   Get here to return to command level. We will reset the
1224:			; previous active drive and then either return to command
1225:			; level directly or print error message and then return.
1226:			;
1227:	DF86  CD66DC  	GETBACK:CALL	RESETDR		;reset previous drive.
1228:	DF89  CD5EDA  	GETBACK1: CALL	CONVFST		;convert first name in (FCB).
1229:	DF8C  3ACEDF  		LD	A,(FCB+1)	;if this was just a drive change request,
1230:	DF8F  D620    		SUB	' '		;make sure it was valid.
1231:	DF91  21F0DF  		LD	HL,CHGDRV
1232:	DF94  B6      		OR	(HL)
1233:	DF95  C209DA  		JP	NZ,SYNERR
1234:	DF98  C382DB  		JP	CMMND1		;ok, return to command level.
1235:			;
1236:			;   ccp stack area.
1237:			;
1238:	DF9B  00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	      00000000
	      00000000
	      00000000
1239:	DFAB          	CCPSTACK EQU	$	;end of ccp stack area.
1240:			;
1241:			;   Batch (or SUBMIT) processing information storage.
1242:			;
1243:	DFAB  00      	BATCH:	DEFB	0		;batch mode flag (0=not active).
1244:	DFAC  00242424	BATCHFCB: DEFB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	      20202020
	      20535542
	      00000000
	      00000000
	      00000000
	      00000000
	      00000000
	      00
1245:			;
1246:			;   File control block setup by the CCP.
1247:			;
1248:	DFCD  00202020	FCB:	DEFB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
	      20202020
	      20202020
	      00000000
	      00202020
	      20202020
	      20202020
	      00000000
	      00
1249:	DFEE  00      	RTNCODE:DEFB	0		;status returned from bdos call.
1250:	DFEF  00      	CDRIVE:	DEFB	0		;currently active drive.
1251:	DFF0  00      	CHGDRV:	DEFB	0		;change in drives flag (0=no change).
1252:	DFF1  0000    	NBYTES:	DEFW	0		;byte counter used by TYPE.
1253:			;
1254:			;   Room for expansion?
1255:			;
1256:	DFF3  00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0
	      00000000
	      00000000
	      00
1257:			;
1258:	0800          		.dephase
1259:			;
1260:			; BDOS CODE START HERE
1261:			;
1262:	E000          		.phase bdose
1263:			;   Note that the following six bytes must match those at
1264:			; (PATTRN1) or cp/m will HALT. Why?
1265:			;
1266:	E000  00160000	PATTRN2:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
	      0000
1267:			;
1268:			;**************************************************************
1269:			;*
1270:			;*                    B D O S   E N T R Y
1271:			;*
1272:			;**************************************************************
1273:			;
1274:	E006  C311E0  	FBASE:	JP	FBASE1
1275:			;
1276:			;   Bdos error table.
1277:			;
1278:	E009  99E0    	BADSCTR:DEFW	ERROR1		;bad sector on read or write.
1279:	E00B  A5E0    	BADSLCT:DEFW	ERROR2		;bad disk select.
1280:	E00D  ABE0    	RODISK:	DEFW	ERROR3		;disk is read only.
1281:	E00F  B1E0    	ROFILE:	DEFW	ERROR4		;file is read only.
1282:			;
1283:			;   Entry into bdos. (DE) or (E) are the parameters passed. The
1284:			; function number desired is in register (C).
1285:			;
1286:	E011  EB      	FBASE1:	EX	DE,HL		;save the (DE) parameters.
1287:	E012  2243E3  		LD	(PARAMS),HL
1288:	E015  EB      		EX	DE,HL
1289:	E016  7B      		LD	A,E		;and save register (E) in particular.
1290:	E017  32D6ED  		LD	(EPARAM),A
1291:	E01A  210000  		LD	HL,0
1292:	E01D  2245E3  		LD	(STATUS),HL	;clear return status.
1293:	E020  39      		ADD	HL,SP
1294:	E021  220FE3  		LD	(USRSTACK),HL	;save users stack pointer.
1295:	E024  3141E3  		LD	SP,STKAREA	;and set our own.
1296:	E027  AF      		XOR	A		;clear auto select storage space.
1297:	E028  32E0ED  		LD	(AUTOFLAG),A
1298:	E02B  32DEED  		LD	(AUTO),A
1299:	E02E  2174ED  		LD	HL,GOBACK	;set return address.
1300:	E031  E5      		PUSH	HL
1301:	E032  79      		LD	A,C		;get function number.
1302:	E033  FE29    		CP	NFUNCTS		;valid function number?
1303:	E035  D0      		RET	NC
1304:	E036  4B      		LD	C,E		;keep single register function here.
1305:	E037  2147E0  		LD	HL,FUNCTNS	;now look thru the function table.
1306:	E03A  5F      		LD	E,A
1307:	E03B  1600    		LD	D,0		;(DE)=function number.
1308:	E03D  19      		ADD	HL,DE
1309:	E03E  19      		ADD	HL,DE		;(HL)=(start of table)+2*(function number).
1310:	E03F  5E      		LD	E,(HL)
1311:	E040  23      		INC	HL
1312:	E041  56      		LD	D,(HL)		;now (DE)=address for this function.
1313:	E042  2A43E3  		LD	HL,(PARAMS)	;retrieve parameters.
1314:	E045  EB      		EX	DE,HL		;now (DE) has the original parameters.
1315:	E046  E9      		JP	(HL)		;execute desired function.
1316:			;
1317:			;   BDOS function jump table.
1318:			;
1319:	0029          	NFUNCTS EQU	41		;number of functions in followin table.
1320:			;
1321:	E047  03EEC8E2	FUNCTNS:DEFW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LISTD,DIRCIO,GETIOB
	      90E1CEE2
	      12EE0FEE
	      D4E2EDE2
1322:	E057  F3E2F8E2		DEFW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
	      E1E1FEE2
	      7EEC83EC
	      45EC9CEC
1323:	E067  A5ECABEC		DEFW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
	      C8ECD7EC
	      E0ECE6EC
	      ECEC
1324:	E075  F5ECFEEC		DEFW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
	      04ED0AED
	      11ED2CE5
	      17ED1DED
1325:	E085  26ED2DED		DEFW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
	      41ED47ED
	      4DED0EEC
	      53ED04E3
1326:	E095  04E39BED		DEFW	RTN,WTSPECL
1327:			;
1328:			;   Bdos error message section.
1329:			;
1330:	E099  21CAE0  	ERROR1:	LD	HL,BADSEC	;bad sector message.
1331:	E09C  CDE5E0  		CALL	PRTERR		;print it and get a 1 char responce.
1332:	E09F  FE03    		CP	CNTRLC		;re-boot request (control-c)?
1333:	E0A1  CA0000  		JP	Z,0		;yes.
1334:	E0A4  C9      		RET			;no, return to retry i/o function.
1335:			;
1336:	E0A5  21D5E0  	ERROR2:	LD	HL,BADSEL	;bad drive selected.
1337:	E0A8  C3B4E0  		JP	ERROR5
1338:			;
1339:	E0AB  21E1E0  	ERROR3:	LD	HL,DISKRO	;disk is read only.
1340:	E0AE  C3B4E0  		JP	ERROR5
1341:			;
1342:	E0B1  21DCE0  	ERROR4:	LD	HL,FILERO	;file is read only.
1343:			;
1344:	E0B4  CDE5E0  	ERROR5:	CALL	PRTERR
1345:	E0B7  C30000  		JP	0		;always reboot on these errors.
1346:			;
1347:	E0BA  42646F73	BDOSERR:DEFB	'Bdos Err On '
	      20457272
	      204F6E20
1348:	E0C6  203A2024	BDOSDRV:DEFB	' : $'
1349:	E0CA  42616420	BADSEC:	DEFB	'Bad Sector$'
	      53656374
	      6F7224
1350:	E0D5  53656C65	BADSEL:	DEFB	'Select$'
	      637424
1351:	E0DC  46696C65	FILERO:	DEFB	'File '
	      20
1352:	E0E1  522F4F24	DISKRO:	DEFB	'R/O$'
1353:			;
1354:			;   Print bdos error message.
1355:			;
1356:	E0E5  E5      	PRTERR:	PUSH	HL		;save second message pointer.
1357:	E0E6  CDC9E1  		CALL	OUTCRLF		;send (cr)(lf).
1358:	E0E9  3A42E3  		LD	A,(ACTIVE)	;get active drive.
1359:	E0EC  C641    		ADD	A,'A'		;make ascii.
1360:	E0EE  32C6E0  		LD	(BDOSDRV),A	;and put in message.
1361:	E0F1  01BAE0  		LD	BC,BDOSERR	;and print it.
1362:	E0F4  CDD3E1  		CALL	PRTMESG
1363:	E0F7  C1      		POP	BC		;print second message line now.
1364:	E0F8  CDD3E1  		CALL	PRTMESG
1365:			;
1366:			;   Get an input character. We will check our 1 character
1367:			; buffer first. This may be set by the console status routine.
1368:			;
1369:	E0FB  210EE3  	GETCHAR:LD	HL,CHARBUF	;check character buffer.
1370:	E0FE  7E      		LD	A,(HL)		;anything present already?
1371:	E0FF  3600    		LD	(HL),0		;...either case clear it.
1372:	E101  B7      		OR	A
1373:	E102  C0      		RET	NZ		;yes, use it.
1374:	E103  C309EE  		JP	CONIN		;nope, go get a character responce.
1375:			;
1376:			;   Input and echo a character.
1377:			;
1378:	E106  CDFBE0  	GETECHO:CALL	GETCHAR		;input a character.
1379:	E109  CD14E1  		CALL	CHKCHAR		;carriage control?
1380:	E10C  D8      		RET	C		;no, a regular control char so don't echo.
1381:	E10D  F5      		PUSH	AF		;ok, save character now.
1382:	E10E  4F      		LD	C,A
1383:	E10F  CD90E1  		CALL	OUTCON		;and echo it.
1384:	E112  F1      		POP	AF		;get character and return.
1385:	E113  C9      		RET
1386:			;
1387:			;   Check character in (A). Set the zero flag on a carriage
1388:			; control character and the carry flag on any other control
1389:			; character.
1390:			;
1391:	E114  FE0D    	CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
1392:	E116  C8      		RET	Z		;or a tab.
1393:	E117  FE0A    		CP	LF
1394:	E119  C8      		RET	Z
1395:	E11A  FE09    		CP	TAB
1396:	E11C  C8      		RET	Z
1397:	E11D  FE08    		CP	BS
1398:	E11F  C8      		RET	Z
1399:	E120  FE20    		CP	' '		;other control char? Set carry flag.
1400:	E122  C9      		RET
1401:			;
1402:			;   Check the console during output. Halt on a control-s, then
1403:			; reboot on a control-c. If anything else is ready, clear the
1404:			; zero flag and return (the calling routine may want to do
1405:			; something).
1406:			;
1407:	E123  3A0EE3  	CKCONSOL: LD	A,(CHARBUF)	;check buffer.
1408:	E126  B7      		OR	A		;if anything, just return without checking.
1409:	E127  C245E1  		JP	NZ,CKCON2
1410:	E12A  CD06EE  		CALL	CONST		;nothing in buffer. Check console.
1411:	E12D  E601    		AND	01H		;look at bit 0.
1412:	E12F  C8      		RET	Z		;return if nothing.
1413:	E130  CD09EE  		CALL	CONIN		;ok, get it.
1414:	E133  FE13    		CP	CNTRLS		;if not control-s, return with zero cleared.
1415:	E135  C242E1  		JP	NZ,CKCON1
1416:	E138  CD09EE  		CALL	CONIN		;halt processing until another char
1417:	E13B  FE03    		CP	CNTRLC		;is typed. Control-c?
1418:	E13D  CA0000  		JP	Z,0		;yes, reboot now.
1419:	E140  AF      		XOR	A		;no, just pretend nothing was ever ready.
1420:	E141  C9      		RET
1421:	E142  320EE3  	CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
1422:	E145  3E01    	CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
1423:	E147  C9      		RET
1424:			;
1425:			;   Output (C) to the screen. If the printer flip-flop flag
1426:			; is set, we will send character to printer also. The console
1427:			; will be checked in the process.
1428:			;
1429:	E148  3A0AE3  	OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
1430:	E14B  B7      		OR	A		;anything and we won't generate output.
1431:	E14C  C262E1  		JP	NZ,OUTCHR1
1432:	E14F  C5      		PUSH	BC
1433:	E150  CD23E1  		CALL	CKCONSOL	;check console (we don't care whats there).
1434:	E153  C1      		POP	BC
1435:	E154  C5      		PUSH	BC
1436:	E155  CD0CEE  		CALL	CONOUT		;output (C) to the screen.
1437:	E158  C1      		POP	BC
1438:	E159  C5      		PUSH	BC
1439:	E15A  3A0DE3  		LD	A,(PRTFLAG)	;check printer flip-flop flag.
1440:	E15D  B7      		OR	A
1441:	E15E  C40FEE  		CALL	NZ,LISTD	;print it also if non-zero.
1442:	E161  C1      		POP	BC
1443:	E162  79      	OUTCHR1:LD	A,C		;update cursors position.
1444:	E163  210CE3  		LD	HL,CURPOS
1445:	E166  FE7F    		CP	DEL		;rubouts don't do anything here.
1446:	E168  C8      		RET	Z
1447:	E169  34      		INC	(HL)		;bump line pointer.
1448:	E16A  FE20    		CP	' '		;and return if a normal character.
1449:	E16C  D0      		RET	NC
1450:	E16D  35      		DEC	(HL)		;restore and check for the start of the line.
1451:	E16E  7E      		LD	A,(HL)
1452:	E16F  B7      		OR	A
1453:	E170  C8      		RET	Z		;ingnore control characters at the start of the line.
1454:	E171  79      		LD	A,C
1455:	E172  FE08    		CP	BS		;is it a backspace?
1456:	E174  C279E1  		JP	NZ,OUTCHR2
1457:	E177  35      		DEC	(HL)		;yes, backup pointer.
1458:	E178  C9      		RET
1459:	E179  FE0A    	OUTCHR2:CP	LF		;is it a line feed?
1460:	E17B  C0      		RET	NZ		;ignore anything else.
1461:	E17C  3600    		LD	(HL),0		;reset pointer to start of line.
1462:	E17E  C9      		RET
1463:			;
1464:			;   Output (A) to the screen. If it is a control character
1465:			; (other than carriage control), use ^x format.
1466:			;
1467:	E17F  79      	SHOWIT:	LD	A,C
1468:	E180  CD14E1  		CALL	CHKCHAR		;check character.
1469:	E183  D290E1  		JP	NC,OUTCON	;not a control, use normal output.
1470:	E186  F5      		PUSH	AF
1471:	E187  0E5E    		LD	C,'^'		;for a control character, preceed it with '^'.
1472:	E189  CD48E1  		CALL	OUTCHAR
1473:	E18C  F1      		POP	AF
1474:	E18D  F640    		OR	'@'		;and then use the letter equivelant.
1475:	E18F  4F      		LD	C,A
1476:			;
1477:			;   Function to output (C) to the console device and expand tabs
1478:			; if necessary.
1479:			;
1480:	E190  79      	OUTCON:	LD	A,C
1481:	E191  FE09    		CP	TAB		;is it a tab?
1482:	E193  C248E1  		JP	NZ,OUTCHAR	;use regular output.
1483:	E196  0E20    	OUTCON1:LD	C,' '		;yes it is, use spaces instead.
1484:	E198  CD48E1  		CALL	OUTCHAR
1485:	E19B  3A0CE3  		LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
1486:			
1487:	E19E  E607    		AND	07H		;position.
1488:	E1A0  C296E1  		JP	NZ,OUTCON1
1489:	E1A3  C9      		RET
1490:			;
1491:			;   Echo a backspace character. Erase the prevoius character
1492:			; on the screen.
1493:			;
1494:	E1A4  CDACE1  	BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
1495:	E1A7  0E20    		LD	C,' '		;then blank that character.
1496:	E1A9  CD0CEE  		CALL	CONOUT
1497:	E1AC  0E08    	BACKUP1:LD	C,BS		;then back space once more.
1498:	E1AE  C30CEE  		JP	CONOUT
1499:			;
1500:			;   Signal a deleted line. Print a '#' at the end and start
1501:			; over.
1502:			;
1503:	E1B1  0E23    	NEWLINE:LD	C,'#'
1504:	E1B3  CD48E1  		CALL	OUTCHAR		;print this.
1505:	E1B6  CDC9E1  		CALL	OUTCRLF		;start new line.
1506:	E1B9  3A0CE3  	NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
1507:	E1BC  210BE3  		LD	HL,STARTING
1508:	E1BF  BE      		CP	(HL)
1509:	E1C0  D0      		RET	NC		;there yet?
1510:	E1C1  0E20    		LD	C,' '
1511:	E1C3  CD48E1  		CALL	OUTCHAR		;nope, keep going.
1512:	E1C6  C3B9E1  		JP	NEWLN1
1513:			;
1514:			;   Output a (cr) (lf) to the console device (screen).
1515:			;
1516:	E1C9  0E0D    	OUTCRLF:LD	C,CR
1517:	E1CB  CD48E1  		CALL	OUTCHAR
1518:	E1CE  0E0A    		LD	C,LF
1519:	E1D0  C348E1  		JP	OUTCHAR
1520:			;
1521:			;   Print message pointed to by (BC). It will end with a '$'.
1522:			;
1523:	E1D3  0A      	PRTMESG:LD	A,(BC)		;check for terminating character.
1524:	E1D4  FE24    		CP	'$'
1525:	E1D6  C8      		RET	Z
1526:	E1D7  03      		INC	BC
1527:	E1D8  C5      		PUSH	BC		;otherwise, bump pointer and print it.
1528:	E1D9  4F      		LD	C,A
1529:	E1DA  CD90E1  		CALL	OUTCON
1530:	E1DD  C1      		POP	BC
1531:	E1DE  C3D3E1  		JP	PRTMESG
1532:			;
1533:			;   Function to execute a buffered read.
1534:			;
1535:	E1E1  3A0CE3  	RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
1536:	E1E4  320BE3  		LD	(STARTING),A
1537:	E1E7  2A43E3  		LD	HL,(PARAMS)	;get the maximum buffer space.
1538:	E1EA  4E      		LD	C,(HL)
1539:	E1EB  23      		INC	HL		;point to first available space.
1540:	E1EC  E5      		PUSH	HL		;and save.
1541:	E1ED  0600    		LD	B,0		;keep a character count.
1542:	E1EF  C5      	RDBUF1:	PUSH	BC
1543:	E1F0  E5      		PUSH	HL
1544:	E1F1  CDFBE0  	RDBUF2:	CALL	GETCHAR		;get the next input character.
1545:	E1F4  E67F    		AND	7FH		;strip bit 7.
1546:	E1F6  E1      		POP	HL		;reset registers.
1547:	E1F7  C1      		POP	BC
1548:	E1F8  FE0D    		CP	CR		;en of the line?
1549:	E1FA  CAC1E2  		JP	Z,RDBUF17
1550:	E1FD  FE0A    		CP	LF
1551:	E1FF  CAC1E2  		JP	Z,RDBUF17
1552:	E202  FE08    		CP	BS		;how about a backspace?
1553:	E204  C216E2  		JP	NZ,RDBUF3
1554:	E207  78      		LD	A,B		;yes, but ignore at the beginning of the line.
1555:	E208  B7      		OR	A
1556:	E209  CAEFE1  		JP	Z,RDBUF1
1557:	E20C  05      		DEC	B		;ok, update counter.
1558:	E20D  3A0CE3  		LD	A,(CURPOS)	;if we backspace to the start of the line,
1559:	E210  320AE3  		LD	(OUTFLAG),A	;treat as a cancel (control-x).
1560:	E213  C370E2  		JP	RDBUF10
1561:	E216  FE7F    	RDBUF3:	CP	DEL		;user typed a rubout?
1562:	E218  C226E2  		JP	NZ,RDBUF4
1563:	E21B  78      		LD	A,B		;ignore at the start of the line.
1564:	E21C  B7      		OR	A
1565:	E21D  CAEFE1  		JP	Z,RDBUF1
1566:	E220  7E      		LD	A,(HL)		;ok, echo the prevoius character.
1567:	E221  05      		DEC	B		;and reset pointers (counters).
1568:	E222  2B      		DEC	HL
1569:	E223  C3A9E2  		JP	RDBUF15
1570:	E226  FE05    	RDBUF4:	CP	CNTRLE		;physical end of line?
1571:	E228  C237E2  		JP	NZ,RDBUF5
1572:	E22B  C5      		PUSH	BC		;yes, do it.
1573:	E22C  E5      		PUSH	HL
1574:	E22D  CDC9E1  		CALL	OUTCRLF
1575:	E230  AF      		XOR	A		;and update starting position.
1576:	E231  320BE3  		LD	(STARTING),A
1577:	E234  C3F1E1  		JP	RDBUF2
1578:	E237  FE10    	RDBUF5:	CP	CNTRLP		;control-p?
1579:	E239  C248E2  		JP	NZ,RDBUF6
1580:	E23C  E5      		PUSH	HL		;yes, flip the print flag filp-flop byte.
1581:	E23D  210DE3  		LD	HL,PRTFLAG
1582:	E240  3E01    		LD	A,1		;PRTFLAG=1-PRTFLAG
1583:	E242  96      		SUB	(HL)
1584:	E243  77      		LD	(HL),A
1585:	E244  E1      		POP	HL
1586:	E245  C3EFE1  		JP	RDBUF1
1587:	E248  FE18    	RDBUF6:	CP	CNTRLX		;control-x (cancel)?
1588:	E24A  C25FE2  		JP	NZ,RDBUF8
1589:	E24D  E1      		POP	HL
1590:	E24E  3A0BE3  	RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
1591:	E251  210CE3  		LD	HL,CURPOS
1592:	E254  BE      		CP	(HL)
1593:	E255  D2E1E1  		JP	NC,RDBUFF	;done yet?
1594:	E258  35      		DEC	(HL)		;no, decrement pointer and output back up one space.
1595:	E259  CDA4E1  		CALL	BACKUP
1596:	E25C  C34EE2  		JP	RDBUF7
1597:	E25F  FE15    	RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
1598:	E261  C26BE2  		JP	NZ,RDBUF9
1599:	E264  CDB1E1  		CALL	NEWLINE		;start a new line.
1600:	E267  E1      		POP	HL
1601:	E268  C3E1E1  		JP	RDBUFF
1602:	E26B  FE12    	RDBUF9:	CP	CNTRLR		;control-r?
1603:	E26D  C2A6E2  		JP	NZ,RDBUF14
1604:	E270  C5      	RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
1605:	E271  CDB1E1  		CALL	NEWLINE
1606:	E274  C1      		POP	BC
1607:	E275  E1      		POP	HL
1608:	E276  E5      		PUSH	HL
1609:	E277  C5      		PUSH	BC
1610:	E278  78      	RDBUF11:LD	A,B		;done whole line yet?
1611:	E279  B7      		OR	A
1612:	E27A  CA8AE2  		JP	Z,RDBUF12
1613:	E27D  23      		INC	HL		;nope, get next character.
1614:	E27E  4E      		LD	C,(HL)
1615:	E27F  05      		DEC	B		;count it.
1616:	E280  C5      		PUSH	BC
1617:	E281  E5      		PUSH	HL
1618:	E282  CD7FE1  		CALL	SHOWIT		;and display it.
1619:	E285  E1      		POP	HL
1620:	E286  C1      		POP	BC
1621:	E287  C378E2  		JP	RDBUF11
1622:	E28A  E5      	RDBUF12:PUSH	HL		;done with line. If we were displaying
1623:	E28B  3A0AE3  		LD	A,(OUTFLAG)	;then update cursor position.
1624:	E28E  B7      		OR	A
1625:	E28F  CAF1E1  		JP	Z,RDBUF2
1626:	E292  210CE3  		LD	HL,CURPOS	;because this line is shorter, we must
1627:	E295  96      		SUB	(HL)		;back up the cursor (not the screen however)
1628:	E296  320AE3  		LD	(OUTFLAG),A	;some number of positions.
1629:	E299  CDA4E1  	RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
1630:	E29C  210AE3  		LD	HL,OUTFLAG	;zero, the screen will not be changed.
1631:	E29F  35      		DEC	(HL)
1632:	E2A0  C299E2  		JP	NZ,RDBUF13
1633:	E2A3  C3F1E1  		JP	RDBUF2		;now just get the next character.
1634:			;
1635:			;   Just a normal character, put this in our buffer and echo.
1636:			;
1637:	E2A6  23      	RDBUF14:INC	HL
1638:	E2A7  77      		LD	(HL),A		;store character.
1639:	E2A8  04      		INC	B		;and count it.
1640:	E2A9  C5      	RDBUF15:PUSH	BC
1641:	E2AA  E5      		PUSH	HL
1642:	E2AB  4F      		LD	C,A		;echo it now.
1643:	E2AC  CD7FE1  		CALL	SHOWIT
1644:	E2AF  E1      		POP	HL
1645:	E2B0  C1      		POP	BC
1646:	E2B1  7E      		LD	A,(HL)		;was it an abort request?
1647:	E2B2  FE03    		CP	CNTRLC		;control-c abort?
1648:	E2B4  78      		LD	A,B
1649:	E2B5  C2BDE2  		JP	NZ,RDBUF16
1650:	E2B8  FE01    		CP	1		;only if at start of line.
1651:	E2BA  CA0000  		JP	Z,0
1652:	E2BD  B9      	RDBUF16:CP	C		;nope, have we filled the buffer?
1653:	E2BE  DAEFE1  		JP	C,RDBUF1
1654:	E2C1  E1      	RDBUF17:POP	HL		;yes end the line and return.
1655:	E2C2  70      		LD	(HL),B
1656:	E2C3  0E0D    		LD	C,CR
1657:	E2C5  C348E1  		JP	OUTCHAR		;output (cr) and return.
1658:			;
1659:			;   Function to get a character from the console device.
1660:			;
1661:	E2C8  CD06E1  	GETCON:	CALL	GETECHO		;get and echo.
1662:	E2CB  C301E3  		JP	SETSTAT		;save status and return.
1663:			;
1664:			;   Function to get a character from the tape reader device.
1665:			;
1666:	E2CE  CD15EE  	GETRDR:	CALL	READER		;get a character from reader, set status and return.
1667:	E2D1  C301E3  		JP	SETSTAT
1668:			;
1669:			;  Function to perform direct console i/o. If (C) contains (FF)
1670:			; then this is an input request. If (C) contains (FE) then
1671:			; this is a status request. Otherwise we are to output (C).
1672:			;
1673:	E2D4  79      	DIRCIO:	LD	A,C		;test for (FF).
1674:	E2D5  3C      		INC	A
1675:	E2D6  CAE0E2  		JP	Z,DIRC1
1676:	E2D9  3C      		INC	A		;test for (FE).
1677:	E2DA  CA06EE  		JP	Z,CONST
1678:	E2DD  C30CEE  		JP	CONOUT		;just output (C).
1679:	E2E0  CD06EE  	DIRC1:	CALL	CONST		;this is an input request.
1680:	E2E3  B7      		OR	A
1681:	E2E4  CA91ED  		JP	Z,GOBACK1	;not ready? Just return (directly).
1682:	E2E7  CD09EE  		CALL	CONIN		;yes, get character.
1683:	E2EA  C301E3  		JP	SETSTAT		;set status and return.
1684:			;
1685:			;   Function to return the i/o byte.
1686:			;
1687:	E2ED  3A0300  	GETIOB:	LD	A,(IOBYTE)
1688:	E2F0  C301E3  		JP	SETSTAT
1689:			;
1690:			;   Function to set the i/o byte.
1691:			;
1692:	E2F3  210300  	SETIOB:	LD	HL,IOBYTE
1693:	E2F6  71      		LD	(HL),C
1694:	E2F7  C9      		RET
1695:			;
1696:			;   Function to print the character string pointed to by (DE)
1697:			; on the console device. The string ends with a '$'.
1698:			;
1699:	E2F8  EB      	PRTSTR:	EX	DE,HL
1700:	E2F9  4D      		LD	C,L
1701:	E2FA  44      		LD	B,H		;now (BC) points to it.
1702:	E2FB  C3D3E1  		JP	PRTMESG
1703:			;
1704:			;   Function to interigate the console device.
1705:			;
1706:	E2FE  CD23E1  	GETCSTS:CALL	CKCONSOL
1707:			;
1708:			;   Get here to set the status and return to the cleanup
1709:			; section. Then back to the user.
1710:			;
1711:	E301  3245E3  	SETSTAT:LD	(STATUS),A
1712:	E304  C9      	RTN:	RET
1713:			;
1714:			;   Set the status to 1 (read or write error code).
1715:			;
1716:	E305  3E01    	IOERR1:	LD	A,1
1717:	E307  C301E3  		JP	SETSTAT
1718:			;
1719:	E30A  00      	OUTFLAG:DEFB	0		;output flag (non zero means no output).
1720:	E30B  02      	STARTING: DEFB	2		;starting position for cursor.
1721:	E30C  00      	CURPOS:	DEFB	0		;cursor position (0=start of line).
1722:	E30D  00      	PRTFLAG:DEFB	0		;printer flag (control-p toggle). List if non zero.
1723:	E30E  00      	CHARBUF:DEFB	0		;single input character buffer.
1724:			;
1725:			;   Stack area for BDOS calls.
1726:			;
1727:	E30F  0000    	USRSTACK: DEFW	0		;save users stack pointer here.
1728:			;
1729:	E311  00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	      00000000
	      00000000
	      00000000
	      00000000
	      00000000
1730:	E329  00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	      00000000
	      00000000
	      00000000
	      00000000
	      00000000
1731:	E341          	STKAREA EQU	$		;end of stack area.
1732:			;
1733:	E341  00      	USERNO:	DEFB	0		;current user number.
1734:	E342  00      	ACTIVE:	DEFB	0		;currently active drive.
1735:	E343  0000    	PARAMS:	DEFW	0		;save (DE) parameters here on entry.
1736:	E345  0000    	STATUS:	DEFW	0		;status returned from bdos function.
1737:			;
1738:			;   Select error occured, jump to error routine.
1739:			;
1740:	E347  210BE0  	SLCTERR:LD	HL,BADSLCT
1741:			;
1742:			;   Jump to (HL) indirectly.
1743:			;
1744:	E34A  5E      	JUMPHL:	LD	E,(HL)
1745:	E34B  23      		INC	HL
1746:	E34C  56      		LD	D,(HL)		;now (DE) contain the desired address.
1747:	E34D  EB      		EX	DE,HL
1748:	E34E  E9      		JP	(HL)
1749:			;
1750:			;   Block move. (DE) to (HL), (C) bytes total.
1751:			;
1752:	E34F  0C      	DE2HL:	INC	C		;is count down to zero?
1753:	E350  0D      	DE2HL1:	DEC	C
1754:	E351  C8      		RET	Z		;yes, we are done.
1755:	E352  1A      		LD	A,(DE)		;no, move one more byte.
1756:	E353  77      		LD	(HL),A
1757:	E354  13      		INC	DE
1758:	E355  23      		INC	HL
1759:	E356  C350E3  		JP	DE2HL1		;and repeat.
1760:			;
1761:			;   Select the desired drive.
1762:			;
1763:	E359  3A42E3  	SELECT:	LD	A,(ACTIVE)	;get active disk.
1764:	E35C  4F      		LD	C,A
1765:	E35D  CD1BEE  		CALL	SELDSK		;select it.
1766:	E360  7C      		LD	A,H		;valid drive?
1767:	E361  B5      		OR	L		;valid drive?
1768:	E362  C8      		RET	Z		;return if not.
1769:			;
1770:			;   Here, the BIOS returned the address of the parameter block
1771:			; in (HL). We will extract the necessary pointers and save them.
1772:			;
1773:	E363  5E      		LD	E,(HL)		;yes, get address of translation table into (DE).
1774:	E364  23      		INC	HL
1775:	E365  56      		LD	D,(HL)
1776:	E366  23      		INC	HL
1777:	E367  22B3ED  		LD	(SCRATCH1),HL	;save pointers to scratch areas.
1778:	E36A  23      		INC	HL
1779:	E36B  23      		INC	HL
1780:	E36C  22B5ED  		LD	(SCRATCH2),HL	;ditto.
1781:	E36F  23      		INC	HL
1782:	E370  23      		INC	HL
1783:	E371  22B7ED  		LD	(SCRATCH3),HL	;ditto.
1784:	E374  23      		INC	HL
1785:	E375  23      		INC	HL
1786:	E376  EB      		EX	DE,HL		;now save the translation table address.
1787:	E377  22D0ED  		LD	(XLATE),HL
1788:	E37A  21B9ED  		LD	HL,DIRBUF	;put the next 8 bytes here.
1789:	E37D  0E08    		LD	C,8		;they consist of the directory buffer
1790:	E37F  CD4FE3  		CALL	DE2HL		;pointer, parameter block pointer,
1791:	E382  2ABBED  		LD	HL,(DISKPB)	;check and allocation vectors.
1792:	E385  EB      		EX	DE,HL
1793:	E386  21C1ED  		LD	HL,SECTORS	;move parameter block into our ram.
1794:	E389  0E0F    		LD	C,15		;it is 15 bytes long.
1795:	E38B  CD4FE3  		CALL	DE2HL
1796:	E38E  2AC6ED  		LD	HL,(DSKSIZE)	;check disk size.
1797:	E391  7C      		LD	A,H		;more than 256 blocks on this?
1798:	E392  21DDED  		LD	HL,BIGDISK
1799:	E395  36FF    		LD	(HL),0FFH	;set to samll.
1800:	E397  B7      		OR	A
1801:	E398  CA9DE3  		JP	Z,SELECT1
1802:	E39B  3600    		LD	(HL),0		;wrong, set to large.
1803:	E39D  3EFF    	SELECT1:LD	A,0FFH		;clear the zero flag.
1804:	E39F  B7      		OR	A
1805:	E3A0  C9      		RET
1806:			;
1807:			;   Routine to home the disk track head and clear pointers.
1808:			;
1809:	E3A1  CD18EE  	HOMEDRV:CALL	HOME		;home the head.
1810:	E3A4  AF      		XOR	A
1811:	E3A5  2AB5ED  		LD	HL,(SCRATCH2)	;set our track pointer also.
1812:	E3A8  77      		LD	(HL),A
1813:	E3A9  23      		INC	HL
1814:	E3AA  77      		LD	(HL),A
1815:	E3AB  2AB7ED  		LD	HL,(SCRATCH3)	;and our sector pointer.
1816:	E3AE  77      		LD	(HL),A
1817:	E3AF  23      		INC	HL
1818:	E3B0  77      		LD	(HL),A
1819:	E3B1  C9      		RET
1820:			;
1821:			;   Do the actual disk read and check the error return status.
1822:			;
1823:	E3B2  CD27EE  	DOREAD:	CALL	READ
1824:	E3B5  C3BBE3  		JP	IORET
1825:			;
1826:			;   Do the actual disk write and handle any bios error.
1827:			;
1828:	E3B8  CD2AEE  	DOWRITE:CALL	WRITE
1829:	E3BB  B7      	IORET:	OR	A
1830:	E3BC  C8      		RET	Z		;return unless an error occured.
1831:	E3BD  2109E0  		LD	HL,BADSCTR	;bad read/write on this sector.
1832:	E3C0  C34AE3  		JP	JUMPHL
1833:			;
1834:			;   Routine to select the track and sector that the desired
1835:			; block number falls in.
1836:			;
1837:	E3C3  2AEAED  	TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
1838:	E3C6  0E02    		LD	C,2		;in directory and compute sector #.
1839:	E3C8  CDEAE4  		CALL	SHIFTR		;sector #=file-position/4.
1840:	E3CB  22E5ED  		LD	(BLKNMBR),HL	;save this as the block number of interest.
1841:	E3CE  22ECED  		LD	(CKSUMTBL),HL	;what's it doing here too?
1842:			;
1843:			;   if the sector number has already been set (BLKNMBR), enter
1844:			; at this point.
1845:			;
1846:	E3D1  21E5ED  	TRKSEC1:LD	HL,BLKNMBR
1847:	E3D4  4E      		LD	C,(HL)		;move sector number into (BC).
1848:	E3D5  23      		INC	HL
1849:	E3D6  46      		LD	B,(HL)
1850:	E3D7  2AB7ED  		LD	HL,(SCRATCH3)	;get current sector number and
1851:	E3DA  5E      		LD	E,(HL)		;move this into (DE).
1852:	E3DB  23      		INC	HL
1853:	E3DC  56      		LD	D,(HL)
1854:	E3DD  2AB5ED  		LD	HL,(SCRATCH2)	;get current track number.
1855:	E3E0  7E      		LD	A,(HL)		;and this into (HL).
1856:	E3E1  23      		INC	HL
1857:	E3E2  66      		LD	H,(HL)
1858:	E3E3  6F      		LD	L,A
1859:	E3E4  79      	TRKSEC2:LD	A,C		;is desired sector before current one?
1860:	E3E5  93      		SUB	E
1861:	E3E6  78      		LD	A,B
1862:	E3E7  9A      		SBC	A,D
1863:	E3E8  D2FAE3  		JP	NC,TRKSEC3
1864:	E3EB  E5      		PUSH	HL		;yes, decrement sectors by one track.
1865:	E3EC  2AC1ED  		LD	HL,(SECTORS)	;get sectors per track.
1866:	E3EF  7B      		LD	A,E
1867:	E3F0  95      		SUB	L
1868:	E3F1  5F      		LD	E,A
1869:	E3F2  7A      		LD	A,D
1870:	E3F3  9C      		SBC	A,H
1871:	E3F4  57      		LD	D,A		;now we have backed up one full track.
1872:	E3F5  E1      		POP	HL
1873:	E3F6  2B      		DEC	HL		;adjust track counter.
1874:	E3F7  C3E4E3  		JP	TRKSEC2
1875:	E3FA  E5      	TRKSEC3:PUSH	HL		;desired sector is after current one.
1876:	E3FB  2AC1ED  		LD	HL,(SECTORS)	;get sectors per track.
1877:	E3FE  19      		ADD	HL,DE		;bump sector pointer to next track.
1878:	E3FF  DA0FE4  		JP	C,TRKSEC4
1879:	E402  79      		LD	A,C		;is desired sector now before current one?
1880:	E403  95      		SUB	L
1881:	E404  78      		LD	A,B
1882:	E405  9C      		SBC	A,H
1883:	E406  DA0FE4  		JP	C,TRKSEC4
1884:	E409  EB      		EX	DE,HL		;not yes, increment track counter
1885:	E40A  E1      		POP	HL		;and continue until it is.
1886:	E40B  23      		INC	HL
1887:	E40C  C3FAE3  		JP	TRKSEC3
1888:			;
1889:			;   here we have determined the track number that contains the
1890:			; desired sector.
1891:			;
1892:	E40F  E1      	TRKSEC4:POP	HL		;get track number (HL).
1893:	E410  C5      		PUSH	BC
1894:	E411  D5      		PUSH	DE
1895:	E412  E5      		PUSH	HL
1896:	E413  EB      		EX	DE,HL
1897:	E414  2ACEED  		LD	HL,(OFFSET)	;adjust for first track offset.
1898:	E417  19      		ADD	HL,DE
1899:	E418  44      		LD	B,H
1900:	E419  4D      		LD	C,L
1901:	E41A  CD1EEE  		CALL	SETTRK		;select this track.
1902:	E41D  D1      		POP	DE		;reset current track pointer.
1903:	E41E  2AB5ED  		LD	HL,(SCRATCH2)
1904:	E421  73      		LD	(HL),E
1905:	E422  23      		INC	HL
1906:	E423  72      		LD	(HL),D
1907:	E424  D1      		POP	DE
1908:	E425  2AB7ED  		LD	HL,(SCRATCH3)	;reset the first sector on this track.
1909:	E428  73      		LD	(HL),E
1910:	E429  23      		INC	HL
1911:	E42A  72      		LD	(HL),D
1912:	E42B  C1      		POP	BC
1913:	E42C  79      		LD	A,C		;now subtract the desired one.
1914:	E42D  93      		SUB	E		;to make it relative (1-# sectors/track).
1915:	E42E  4F      		LD	C,A
1916:	E42F  78      		LD	A,B
1917:	E430  9A      		SBC	A,D
1918:	E431  47      		LD	B,A
1919:	E432  2AD0ED  		LD	HL,(XLATE)	;translate this sector according to this table.
1920:	E435  EB      		EX	DE,HL
1921:	E436  CD30EE  		CALL	SECTRAN		;let the bios translate it.
1922:	E439  4D      		LD	C,L
1923:	E43A  44      		LD	B,H
1924:	E43B  C321EE  		JP	SETSEC		;and select it.
1925:			;
1926:			;   Compute block number from record number (SAVNREC) and
1927:			; extent number (SAVEXT).
1928:			;
1929:	E43E  21C3ED  	GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
1930:	E441  4E      		LD	C,(HL)		;note that this is base 2 log of ratio.
1931:	E442  3AE3ED  		LD	A,(SAVNREC)	;get record number.
1932:	E445  B7      	GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
1933:	E446  1F      		RRA
1934:	E447  0D      		DEC	C
1935:	E448  C245E4  		JP	NZ,GETBLK1
1936:	E44B  47      		LD	B,A		;save result in (B).
1937:	E44C  3E08    		LD	A,8
1938:	E44E  96      		SUB	(HL)
1939:	E44F  4F      		LD	C,A		;compute (C)=8-BLKSHFT.
1940:	E450  3AE2ED  		LD	A,(SAVEXT)
1941:	E453  0D      	GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
1942:	E454  CA5CE4  		JP	Z,GETBLK3
1943:	E457  B7      		OR	A
1944:	E458  17      		RLA
1945:	E459  C353E4  		JP	GETBLK2
1946:	E45C  80      	GETBLK3:ADD	A,B
1947:	E45D  C9      		RET
1948:			;
1949:			;   Routine to extract the (BC) block byte from the fcb pointed
1950:			; to by (PARAMS). If this is a big-disk, then these are 16 bit
1951:			; block numbers, else they are 8 bit numbers.
1952:			; Number is returned in (HL).
1953:			;
1954:	E45E  2A43E3  	EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
1955:	E461  111000  		LD	DE,16		;block numbers start 16 bytes into fcb.
1956:	E464  19      		ADD	HL,DE
1957:	E465  09      		ADD	HL,BC
1958:	E466  3ADDED  		LD	A,(BIGDISK)	;are we using a big-disk?
1959:	E469  B7      		OR	A
1960:	E46A  CA71E4  		JP	Z,EXTBLK1
1961:	E46D  6E      		LD	L,(HL)		;no, extract an 8 bit number from the fcb.
1962:	E46E  2600    		LD	H,0
1963:	E470  C9      		RET
1964:	E471  09      	EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
1965:	E472  5E      		LD	E,(HL)
1966:	E473  23      		INC	HL
1967:	E474  56      		LD	D,(HL)
1968:	E475  EB      		EX	DE,HL		;return in (HL).
1969:	E476  C9      		RET
1970:			;
1971:			;   Compute block number.
1972:			;
1973:	E477  CD3EE4  	COMBLK:	CALL	GETBLOCK
1974:	E47A  4F      		LD	C,A
1975:	E47B  0600    		LD	B,0
1976:	E47D  CD5EE4  		CALL	EXTBLK
1977:	E480  22E5ED  		LD	(BLKNMBR),HL
1978:	E483  C9      		RET
1979:			;
1980:			;   Check for a zero block number (unused).
1981:			;
1982:	E484  2AE5ED  	CHKBLK:	LD	HL,(BLKNMBR)
1983:	E487  7D      		LD	A,L		;is it zero?
1984:	E488  B4      		OR	H
1985:	E489  C9      		RET
1986:			;
1987:			;   Adjust physical block (BLKNMBR) and convert to logical
1988:			; sector (LOGSECT). This is the starting sector of this block.
1989:			; The actual sector of interest is then added to this and the
1990:			; resulting sector number is stored back in (BLKNMBR). This
1991:			; will still have to be adjusted for the track number.
1992:			;
1993:	E48A  3AC3ED  	LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
1994:	E48D  2AE5ED  		LD	HL,(BLKNMBR)	;get physical sector desired.
1995:	E490  29      	LOGICL1:ADD	HL,HL		;compute logical sector number.
1996:	E491  3D      		DEC	A		;note logical sectors are 128 bytes long.
1997:	E492  C290E4  		JP	NZ,LOGICL1
1998:	E495  22E7ED  		LD	(LOGSECT),HL	;save logical sector.
1999:	E498  3AC4ED  		LD	A,(BLKMASK)	;get block mask.
2000:	E49B  4F      		LD	C,A
2001:	E49C  3AE3ED  		LD	A,(SAVNREC)	;get next sector to access.
2002:	E49F  A1      		AND	C		;extract the relative position within physical block.
2003:	E4A0  B5      		OR	L		;and add it too logical sector.
2004:	E4A1  6F      		LD	L,A
2005:	E4A2  22E5ED  		LD	(BLKNMBR),HL	;and store.
2006:	E4A5  C9      		RET
2007:			;
2008:			;   Set (HL) to point to extent byte in fcb.
2009:			;
2010:	E4A6  2A43E3  	SETEXT:	LD	HL,(PARAMS)
2011:	E4A9  110C00  		LD	DE,12		;it is the twelth byte.
2012:	E4AC  19      		ADD	HL,DE
2013:	E4AD  C9      		RET
2014:			;
2015:			;   Set (HL) to point to record count byte in fcb and (DE) to
2016:			; next record number byte.
2017:			;
2018:	E4AE  2A43E3  	SETHLDE:LD	HL,(PARAMS)
2019:	E4B1  110F00  		LD	DE,15		;record count byte (#15).
2020:	E4B4  19      		ADD	HL,DE
2021:	E4B5  EB      		EX	DE,HL
2022:	E4B6  211100  		LD	HL,17		;next record number (#32).
2023:	E4B9  19      		ADD	HL,DE
2024:	E4BA  C9      		RET
2025:			;
2026:			;   Save current file data from fcb.
2027:			;
2028:	E4BB  CDAEE4  	STRDATA:CALL	SETHLDE
2029:	E4BE  7E      		LD	A,(HL)		;get and store record count byte.
2030:	E4BF  32E3ED  		LD	(SAVNREC),A
2031:	E4C2  EB      		EX	DE,HL
2032:	E4C3  7E      		LD	A,(HL)		;get and store next record number byte.
2033:	E4C4  32E1ED  		LD	(SAVNXT),A
2034:	E4C7  CDA6E4  		CALL	SETEXT		;point to extent byte.
2035:	E4CA  3AC5ED  		LD	A,(EXTMASK)	;get extent mask.
2036:	E4CD  A6      		AND	(HL)
2037:	E4CE  32E2ED  		LD	(SAVEXT),A	;and save extent here.
2038:	E4D1  C9      		RET
2039:			;
2040:			;   Set the next record to access. If (MODE) is set to 2, then
2041:			; the last record byte (SAVNREC) has the correct number to access.
2042:			; For sequential access, (MODE) will be equal to 1.
2043:			;
2044:	E4D2  CDAEE4  	SETNREC:CALL	SETHLDE
2045:	E4D5  3AD5ED  		LD	A,(MODE)	;get sequential flag (=1).
2046:	E4D8  FE02    		CP	2		;a 2 indicates that no adder is needed.
2047:	E4DA  C2DEE4  		JP	NZ,STNREC1
2048:	E4DD  AF      		XOR	A		;clear adder (random access?).
2049:	E4DE  4F      	STNREC1:LD	C,A
2050:	E4DF  3AE3ED  		LD	A,(SAVNREC)	;get last record number.
2051:	E4E2  81      		ADD	A,C		;increment record count.
2052:	E4E3  77      		LD	(HL),A		;and set fcb's next record byte.
2053:	E4E4  EB      		EX	DE,HL
2054:	E4E5  3AE1ED  		LD	A,(SAVNXT)	;get next record byte from storage.
2055:	E4E8  77      		LD	(HL),A		;and put this into fcb as number of records used.
2056:	E4E9  C9      		RET
2057:			;
2058:			;   Shift (HL) right (C) bits.
2059:			;
2060:	E4EA  0C      	SHIFTR:	INC	C
2061:	E4EB  0D      	SHIFTR1:DEC	C
2062:	E4EC  C8      		RET	Z
2063:	E4ED  7C      		LD	A,H
2064:	E4EE  B7      		OR	A
2065:	E4EF  1F      		RRA
2066:	E4F0  67      		LD	H,A
2067:	E4F1  7D      		LD	A,L
2068:	E4F2  1F      		RRA
2069:	E4F3  6F      		LD	L,A
2070:	E4F4  C3EBE4  		JP	SHIFTR1
2071:			;
2072:			;   Compute the check-sum for the directory buffer. Return
2073:			; integer sum in (A).
2074:			;
2075:	E4F7  0E80    	CHECKSUM: LD	C,128		;length of buffer.
2076:	E4F9  2AB9ED  		LD	HL,(DIRBUF)	;get its location.
2077:	E4FC  AF      		XOR	A		;clear summation byte.
2078:	E4FD  86      	CHKSUM1:ADD	A,(HL)		;and compute sum ignoring carries.
2079:	E4FE  23      		INC	HL
2080:	E4FF  0D      		DEC	C
2081:	E500  C2FDE4  		JP	NZ,CHKSUM1
2082:	E503  C9      		RET
2083:			;
2084:			;   Shift (HL) left (C) bits.
2085:			;
2086:	E504  0C      	SHIFTL:	INC	C
2087:	E505  0D      	SHIFTL1:DEC	C
2088:	E506  C8      		RET	Z
2089:	E507  29      		ADD	HL,HL		;shift left 1 bit.
2090:	E508  C305E5  		JP	SHIFTL1
2091:			;
2092:			;   Routine to set a bit in a 16 bit value contained in (BC).
2093:			; The bit set depends on the current drive selection.
2094:			;
2095:	E50B  C5      	SETBIT:	PUSH	BC		;save 16 bit word.
2096:	E50C  3A42E3  		LD	A,(ACTIVE)	;get active drive.
2097:	E50F  4F      		LD	C,A
2098:	E510  210100  		LD	HL,1
2099:	E513  CD04E5  		CALL	SHIFTL		;shift bit 0 into place.
2100:	E516  C1      		POP	BC		;now 'or' this with the original word.
2101:	E517  79      		LD	A,C
2102:	E518  B5      		OR	L
2103:	E519  6F      		LD	L,A		;low byte done, do high byte.
2104:	E51A  78      		LD	A,B
2105:	E51B  B4      		OR	H
2106:	E51C  67      		LD	H,A
2107:	E51D  C9      		RET
2108:			;
2109:			;   Extract the write protect status bit for the current drive.
2110:			; The result is returned in (A), bit 0.
2111:			;
2112:	E51E  2AADED  	GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
2113:	E521  3A42E3  		LD	A,(ACTIVE)	;which drive is current?
2114:	E524  4F      		LD	C,A
2115:	E525  CDEAE4  		CALL	SHIFTR		;shift status such that bit 0 is the
2116:	E528  7D      		LD	A,L		;one of interest for this drive.
2117:	E529  E601    		AND	01H		;and isolate it.
2118:	E52B  C9      		RET
2119:			;
2120:			;   Function to write protect the current disk.
2121:			;
2122:	E52C  21ADED  	WRTPRTD:LD	HL,WRTPRT	;point to status word.
2123:	E52F  4E      		LD	C,(HL)		;set (BC) equal to the status.
2124:	E530  23      		INC	HL
2125:	E531  46      		LD	B,(HL)
2126:	E532  CD0BE5  		CALL	SETBIT		;and set this bit according to current drive.
2127:	E535  22ADED  		LD	(WRTPRT),HL	;then save.
2128:	E538  2AC8ED  		LD	HL,(DIRSIZE)	;now save directory size limit.
2129:	E53B  23      		INC	HL		;remember the last one.
2130:	E53C  EB      		EX	DE,HL
2131:	E53D  2AB3ED  		LD	HL,(SCRATCH1)	;and store it here.
2132:	E540  73      		LD	(HL),E		;put low byte.
2133:	E541  23      		INC	HL
2134:	E542  72      		LD	(HL),D		;then high byte.
2135:	E543  C9      		RET
2136:			;
2137:			;   Check for a read only file.
2138:			;
2139:	E544  CD5EE5  	CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
2140:	E547  110900  	CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
2141:	E54A  19      		ADD	HL,DE
2142:	E54B  7E      		LD	A,(HL)
2143:	E54C  17      		RLA
2144:	E54D  D0      		RET	NC		;return if ok.
2145:	E54E  210FE0  		LD	HL,ROFILE	;else, print error message and terminate.
2146:	E551  C34AE3  		JP	JUMPHL
2147:			;
2148:			;   Check the write protect status of the active disk.
2149:			;
2150:	E554  CD1EE5  	CHKWPRT:CALL	GETWPRT
2151:	E557  C8      		RET	Z		;return if ok.
2152:	E558  210DE0  		LD	HL,RODISK	;else print message and terminate.
2153:	E55B  C34AE3  		JP	JUMPHL
2154:			;
2155:			;   Routine to set (HL) pointing to the proper entry in the
2156:			; directory buffer.
2157:			;
2158:	E55E  2AB9ED  	FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
2159:	E561  3AE9ED  		LD	A,(FCBPOS)	;relative position of file.
2160:			;
2161:			;   Routine to add (A) to (HL).
2162:			;
2163:	E564  85      	ADDA2HL:ADD	A,L
2164:	E565  6F      		LD	L,A
2165:	E566  D0      		RET	NC
2166:	E567  24      		INC	H		;take care of any carry.
2167:	E568  C9      		RET
2168:			;
2169:			;   Routine to get the 's2' byte from the fcb supplied in
2170:			; the initial parameter specification.
2171:			;
2172:	E569  2A43E3  	GETS2:	LD	HL,(PARAMS)	;get address of fcb.
2173:	E56C  110E00  		LD	DE,14		;relative position of 's2'.
2174:	E56F  19      		ADD	HL,DE
2175:	E570  7E      		LD	A,(HL)		;extract this byte.
2176:	E571  C9      		RET
2177:			;
2178:			;   Clear the 's2' byte in the fcb.
2179:			;
2180:	E572  CD69E5  	CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
2181:	E575  3600    		LD	(HL),0		;now clear it.
2182:	E577  C9      		RET
2183:			;
2184:			;   Set bit 7 in the 's2' byte of the fcb.
2185:			;
2186:	E578  CD69E5  	SETS2B7:CALL	GETS2		;get the byte.
2187:	E57B  F680    		OR	80H		;and set bit 7.
2188:	E57D  77      		LD	(HL),A		;then store.
2189:	E57E  C9      		RET
2190:			;
2191:			;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
2192:			; the difference. This checks to see if there are more file
2193:			; names in the directory. We are at (FILEPOS) and there are
2194:			; (SCRATCH1) of them to check.
2195:			;
2196:	E57F  2AEAED  	MOREFLS:LD	HL,(FILEPOS)	;we are here.
2197:	E582  EB      		EX	DE,HL
2198:	E583  2AB3ED  		LD	HL,(SCRATCH1)	;and don't go past here.
2199:	E586  7B      		LD	A,E		;compute difference but don't keep.
2200:	E587  96      		SUB	(HL)
2201:	E588  23      		INC	HL
2202:	E589  7A      		LD	A,D
2203:	E58A  9E      		SBC	A,(HL)		;set carry if no more names.
2204:	E58B  C9      		RET
2205:			;
2206:			;   Call this routine to prevent (SCRATCH1) from being greater
2207:			; than (FILEPOS).
2208:			;
2209:	E58C  CD7FE5  	CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
2210:	E58F  D8      		RET	C
2211:	E590  13      		INC	DE		;yes, reset it to (FILEPOS).
2212:	E591  72      		LD	(HL),D
2213:	E592  2B      		DEC	HL
2214:	E593  73      		LD	(HL),E
2215:	E594  C9      		RET
2216:			;
2217:			;   Compute (HL)=(DE)-(HL)
2218:			;
2219:	E595  7B      	SUBHL:	LD	A,E		;compute difference.
2220:	E596  95      		SUB	L
2221:	E597  6F      		LD	L,A		;store low byte.
2222:	E598  7A      		LD	A,D
2223:	E599  9C      		SBC	A,H
2224:	E59A  67      		LD	H,A		;and then high byte.
2225:	E59B  C9      		RET
2226:			;
2227:			;   Set the directory checksum byte.
2228:			;
2229:	E59C  0EFF    	SETDIR:	LD	C,0FFH
2230:			;
2231:			;   Routine to set or compare the directory checksum byte. If
2232:			; (C)=0ffh, then this will set the checksum byte. Else the byte
2233:			; will be checked. If the check fails (the disk has been changed),
2234:			; then this disk will be write protected.
2235:			;
2236:	E59E  2AECED  	CHECKDIR: LD	HL,(CKSUMTBL)
2237:	E5A1  EB      		EX	DE,HL
2238:	E5A2  2ACCED  		LD	HL,(ALLOC1)
2239:	E5A5  CD95E5  		CALL	SUBHL
2240:	E5A8  D0      		RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
2241:	E5A9  C5      		PUSH	BC
2242:	E5AA  CDF7E4  		CALL	CHECKSUM	;else compute checksum.
2243:	E5AD  2ABDED  		LD	HL,(CHKVECT)	;get address of checksum table.
2244:	E5B0  EB      		EX	DE,HL
2245:	E5B1  2AECED  		LD	HL,(CKSUMTBL)
2246:	E5B4  19      		ADD	HL,DE		;set (HL) to point to byte for this drive.
2247:	E5B5  C1      		POP	BC
2248:	E5B6  0C      		INC	C		;set or check ?
2249:	E5B7  CAC4E5  		JP	Z,CHKDIR1
2250:	E5BA  BE      		CP	(HL)		;check them.
2251:	E5BB  C8      		RET	Z		;return if they are the same.
2252:	E5BC  CD7FE5  		CALL	MOREFLS		;not the same, do we care?
2253:	E5BF  D0      		RET	NC
2254:	E5C0  CD2CE5  		CALL	WRTPRTD		;yes, mark this as write protected.
2255:	E5C3  C9      		RET
2256:	E5C4  77      	CHKDIR1:LD	(HL),A		;just set the byte.
2257:	E5C5  C9      		RET
2258:			;
2259:			;   Do a write to the directory of the current disk.
2260:			;
2261:	E5C6  CD9CE5  	DIRWRITE: CALL	SETDIR		;set checksum byte.
2262:	E5C9  CDE0E5  		CALL	DIRDMA		;set directory dma address.
2263:	E5CC  0E01    		LD	C,1		;tell the bios to actually write.
2264:	E5CE  CDB8E3  		CALL	DOWRITE		;then do the write.
2265:	E5D1  C3DAE5  		JP	DEFDMA
2266:			;
2267:			;   Read from the directory.
2268:			;
2269:	E5D4  CDE0E5  	DIRREAD:CALL	DIRDMA		;set the directory dma address.
2270:	E5D7  CDB2E3  		CALL	DOREAD		;and read it.
2271:			;
2272:			;   Routine to set the dma address to the users choice.
2273:			;
2274:	E5DA  21B1ED  	DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
2275:	E5DD  C3E3E5  		JP	DIRDMA1
2276:			;
2277:			;   Routine to set the dma address for directory work.
2278:			;
2279:	E5E0  21B9ED  	DIRDMA:	LD	HL,DIRBUF
2280:			;
2281:			;   Set the dma address. On entry, (HL) points to
2282:			; word containing the desired dma address.
2283:			;
2284:	E5E3  4E      	DIRDMA1:LD	C,(HL)
2285:	E5E4  23      		INC	HL
2286:	E5E5  46      		LD	B,(HL)		;setup (BC) and go to the bios to set it.
2287:	E5E6  C324EE  		JP	SETDMA
2288:			;
2289:			;   Move the directory buffer into user's dma space.
2290:			;
2291:	E5E9  2AB9ED  	MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
2292:	E5EC  EB      		EX	DE,HL
2293:	E5ED  2AB1ED  		LD	HL,(USERDMA)	; put it here.
2294:	E5F0  0E80    		LD	C,128		;this is its length.
2295:	E5F2  C34FE3  		JP	DE2HL		;move it now and return.
2296:			;
2297:			;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2298:			;
2299:	E5F5  21EAED  	CKFILPOS: LD	HL,FILEPOS
2300:	E5F8  7E      		LD	A,(HL)
2301:	E5F9  23      		INC	HL
2302:	E5FA  BE      		CP	(HL)		;are both bytes the same?
2303:	E5FB  C0      		RET	NZ
2304:	E5FC  3C      		INC	A		;yes, but are they each 0ffh?
2305:	E5FD  C9      		RET
2306:			;
2307:			;   Set location (FILEPOS) to 0ffffh.
2308:			;
2309:	E5FE  21FFFF  	STFILPOS: LD	HL,0FFFFH
2310:	E601  22EAED  		LD	(FILEPOS),HL
2311:	E604  C9      		RET
2312:			;
2313:			;   Move on to the next file position within the current
2314:			; directory buffer. If no more exist, set pointer to 0ffffh
2315:			; and the calling routine will check for this. Enter with (C)
2316:			; equal to 0ffh to cause the checksum byte to be set, else we
2317:			; will check this disk and set write protect if checksums are
2318:			; not the same (applies only if another directory sector must
2319:			; be read).
2320:			;
2321:	E605  2AC8ED  	NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
2322:	E608  EB      		EX	DE,HL
2323:	E609  2AEAED  		LD	HL,(FILEPOS)	;get current count.
2324:	E60C  23      		INC	HL		;go on to the next one.
2325:	E60D  22EAED  		LD	(FILEPOS),HL
2326:	E610  CD95E5  		CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
2327:	E613  D219E6  		JP	NC,NXENT1	;is there more room left?
2328:	E616  C3FEE5  		JP	STFILPOS	;no. Set this flag and return.
2329:	E619  3AEAED  	NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
2330:	E61C  E603    		AND	03H		;only look within this sector (only 4 entries fit).
2331:	E61E  0605    		LD	B,5		;convert to relative position (32 bytes each).
2332:	E620  87      	NXENT2:	ADD	A,A		;note that this is not efficient code.
2333:	E621  05      		DEC	B		;5 'ADD A's would be better.
2334:	E622  C220E6  		JP	NZ,NXENT2
2335:	E625  32E9ED  		LD	(FCBPOS),A	;save it as position of fcb.
2336:	E628  B7      		OR	A
2337:	E629  C0      		RET	NZ		;return if we are within buffer.
2338:	E62A  C5      		PUSH	BC
2339:	E62B  CDC3E3  		CALL	TRKSEC		;we need the next directory sector.
2340:	E62E  CDD4E5  		CALL	DIRREAD
2341:	E631  C1      		POP	BC
2342:	E632  C39EE5  		JP	CHECKDIR
2343:			;
2344:			;   Routine to to get a bit from the disk space allocation
2345:			; map. It is returned in (A), bit position 0. On entry to here,
2346:			; set (BC) to the block number on the disk to check.
2347:			; On return, (D) will contain the original bit position for
2348:			; this block number and (HL) will point to the address for it.
2349:			;
2350:	E635  79      	CKBITMAP: LD	A,C		;determine bit number of interest.
2351:	E636  E607    		AND	07H		;compute (D)=(E)=(C and 7)+1.
2352:	E638  3C      		INC	A
2353:	E639  5F      		LD	E,A		;save particular bit number.
2354:	E63A  57      		LD	D,A
2355:			;
2356:			;   compute (BC)=(BC)/8.
2357:			;
2358:	E63B  79      		LD	A,C
2359:	E63C  0F      		RRCA			;now shift right 3 bits.
2360:	E63D  0F      		RRCA
2361:	E63E  0F      		RRCA
2362:	E63F  E61F    		AND	1FH		;and clear bits 7,6,5.
2363:	E641  4F      		LD	C,A
2364:	E642  78      		LD	A,B
2365:	E643  87      		ADD	A,A		;now shift (B) into bits 7,6,5.
2366:	E644  87      		ADD	A,A
2367:	E645  87      		ADD	A,A
2368:	E646  87      		ADD	A,A
2369:	E647  87      		ADD	A,A
2370:	E648  B1      		OR	C		;and add in (C).
2371:	E649  4F      		LD	C,A		;ok, (C) ha been completed.
2372:	E64A  78      		LD	A,B		;is there a better way of doing this?
2373:	E64B  0F      		RRCA
2374:	E64C  0F      		RRCA
2375:	E64D  0F      		RRCA
2376:	E64E  E61F    		AND	1FH
2377:	E650  47      		LD	B,A		;and now (B) is completed.
2378:			;
2379:			;   use this as an offset into the disk space allocation
2380:			; table.
2381:			;
2382:	E651  2ABFED  		LD	HL,(ALOCVECT)
2383:	E654  09      		ADD	HL,BC
2384:	E655  7E      		LD	A,(HL)		;now get correct byte.
2385:	E656  07      	CKBMAP1:RLCA			;get correct bit into position 0.
2386:	E657  1D      		DEC	E
2387:	E658  C256E6  		JP	NZ,CKBMAP1
2388:	E65B  C9      		RET
2389:			;
2390:			;   Set or clear the bit map such that block number (BC) will be marked
2391:			; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2392:			; 1 then it will be set (don't use anyother values).
2393:			;
2394:	E65C  D5      	STBITMAP: PUSH	DE
2395:	E65D  CD35E6  		CALL	CKBITMAP	;get the byte of interest.
2396:	E660  E6FE    		AND	0FEH		;clear the affected bit.
2397:	E662  C1      		POP	BC
2398:	E663  B1      		OR	C		;and now set it acording to (C).
2399:			;
2400:			;  entry to restore the original bit position and then store
2401:			; in table. (A) contains the value, (D) contains the bit
2402:			; position (1-8), and (HL) points to the address within the
2403:			; space allocation table for this byte.
2404:			;
2405:	E664  0F      	STBMAP1:RRCA			;restore original bit position.
2406:	E665  15      		DEC	D
2407:	E666  C264E6  		JP	NZ,STBMAP1
2408:	E669  77      		LD	(HL),A		;and stor byte in table.
2409:	E66A  C9      		RET
2410:			;
2411:			;   Set/clear space used bits in allocation map for this file.
2412:			; On entry, (C)=1 to set the map and (C)=0 to clear it.
2413:			;
2414:	E66B  CD5EE5  	SETFILE:CALL	FCB2HL		;get address of fcb
2415:	E66E  111000  		LD	DE,16
2416:	E671  19      		ADD	HL,DE		;get to block number bytes.
2417:	E672  C5      		PUSH	BC
2418:	E673  0E11    		LD	C,17		;check all 17 bytes (max) of table.
2419:	E675  D1      	SETFL1:	POP	DE
2420:	E676  0D      		DEC	C		;done all bytes yet?
2421:	E677  C8      		RET	Z
2422:	E678  D5      		PUSH	DE
2423:	E679  3ADDED  		LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
2424:	E67C  B7      		OR	A
2425:	E67D  CA88E6  		JP	Z,SETFL2
2426:	E680  C5      		PUSH	BC		;only 8 bit numbers. set (BC) to this one.
2427:	E681  E5      		PUSH	HL
2428:	E682  4E      		LD	C,(HL)		;get low byte from table, always
2429:	E683  0600    		LD	B,0		;set high byte to zero.
2430:	E685  C38EE6  		JP	SETFL3
2431:	E688  0D      	SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
2432:	E689  C5      		PUSH	BC
2433:	E68A  4E      		LD	C,(HL)		;now get both the low and high bytes.
2434:	E68B  23      		INC	HL
2435:	E68C  46      		LD	B,(HL)
2436:	E68D  E5      		PUSH	HL
2437:	E68E  79      	SETFL3:	LD	A,C		;block used?
2438:	E68F  B0      		OR	B
2439:	E690  CA9DE6  		JP	Z,SETFL4
2440:	E693  2AC6ED  		LD	HL,(DSKSIZE)	;is this block number within the
2441:	E696  7D      		LD	A,L		;space on the disk?
2442:	E697  91      		SUB	C
2443:	E698  7C      		LD	A,H
2444:	E699  98      		SBC	A,B
2445:	E69A  D45CE6  		CALL	NC,STBITMAP	;yes, set the proper bit.
2446:	E69D  E1      	SETFL4:	POP	HL		;point to next block number in fcb.
2447:	E69E  23      		INC	HL
2448:	E69F  C1      		POP	BC
2449:	E6A0  C375E6  		JP	SETFL1
2450:			;
2451:			;   Construct the space used allocation bit map for the active
2452:			; drive. If a file name starts with '$' and it is under the
2453:			; current user number, then (STATUS) is set to minus 1. Otherwise
2454:			; it is not set at all.
2455:			;
2456:	E6A3  2AC6ED  	BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
2457:	E6A6  0E03    		LD	C,3
2458:	E6A8  CDEAE4  		CALL	SHIFTR		;(HL)=(HL)/8.
2459:	E6AB  23      		INC	HL		;at lease 1 byte.
2460:	E6AC  44      		LD	B,H
2461:	E6AD  4D      		LD	C,L		;set (BC) to the allocation table length.
2462:			;
2463:			;   Initialize the bitmap for this drive. Right now, the first
2464:			; two bytes are specified by the disk parameter block. However
2465:			; a patch could be entered here if it were necessary to setup
2466:			; this table in a special mannor. For example, the bios could
2467:			; determine locations of 'bad blocks' and set them as already
2468:			; 'used' in the map.
2469:			;
2470:	E6AE  2ABFED  		LD	HL,(ALOCVECT)	;now zero out the table now.
2471:	E6B1  3600    	BITMAP1:LD	(HL),0
2472:	E6B3  23      		INC	HL
2473:	E6B4  0B      		DEC	BC
2474:	E6B5  78      		LD	A,B
2475:	E6B6  B1      		OR	C
2476:	E6B7  C2B1E6  		JP	NZ,BITMAP1
2477:	E6BA  2ACAED  		LD	HL,(ALLOC0)	;get initial space used by directory.
2478:	E6BD  EB      		EX	DE,HL
2479:	E6BE  2ABFED  		LD	HL,(ALOCVECT)	;and put this into map.
2480:	E6C1  73      		LD	(HL),E
2481:	E6C2  23      		INC	HL
2482:	E6C3  72      		LD	(HL),D
2483:			;
2484:			;   End of initialization portion.
2485:			;
2486:	E6C4  CDA1E3  		CALL	HOMEDRV		;now home the drive.
2487:	E6C7  2AB3ED  		LD	HL,(SCRATCH1)
2488:	E6CA  3603    		LD	(HL),3		;force next directory request to read
2489:	E6CC  23      		INC	HL		;in a sector.
2490:	E6CD  3600    		LD	(HL),0
2491:	E6CF  CDFEE5  		CALL	STFILPOS	;clear initial file position also.
2492:	E6D2  0EFF    	BITMAP2:LD	C,0FFH		;read next file name in directory
2493:	E6D4  CD05E6  		CALL	NXENTRY		;and set checksum byte.
2494:	E6D7  CDF5E5  		CALL	CKFILPOS	;is there another file?
2495:	E6DA  C8      		RET	Z
2496:	E6DB  CD5EE5  		CALL	FCB2HL		;yes, get its address.
2497:	E6DE  3EE5    		LD	A,0E5H
2498:	E6E0  BE      		CP	(HL)		;empty file entry?
2499:	E6E1  CAD2E6  		JP	Z,BITMAP2
2500:	E6E4  3A41E3  		LD	A,(USERNO)	;no, correct user number?
2501:	E6E7  BE      		CP	(HL)
2502:	E6E8  C2F6E6  		JP	NZ,BITMAP3
2503:	E6EB  23      		INC	HL
2504:	E6EC  7E      		LD	A,(HL)		;yes, does name start with a '$'?
2505:	E6ED  D624    		SUB	'$'
2506:	E6EF  C2F6E6  		JP	NZ,BITMAP3
2507:	E6F2  3D      		DEC	A		;yes, set atatus to minus one.
2508:	E6F3  3245E3  		LD	(STATUS),A
2509:	E6F6  0E01    	BITMAP3:LD	C,1		;now set this file's space as used in bit map.
2510:	E6F8  CD6BE6  		CALL	SETFILE
2511:	E6FB  CD8CE5  		CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
2512:	E6FE  C3D2E6  		JP	BITMAP2
2513:			;
2514:			;   Set the status (STATUS) and return.
2515:			;
2516:	E701  3AD4ED  	STSTATUS: LD	A,(FNDSTAT)
2517:	E704  C301E3  		JP	SETSTAT
2518:			;
2519:			;   Check extents in (A) and (C). Set the zero flag if they
2520:			; are the same. The number of 16k chunks of disk space that
2521:			; the directory extent covers is expressad is (EXTMASK+1).
2522:			; No registers are modified.
2523:			;
2524:	E707  C5      	SAMEXT:	PUSH	BC
2525:	E708  F5      		PUSH	AF
2526:	E709  3AC5ED  		LD	A,(EXTMASK)	;get extent mask and use it to
2527:	E70C  2F      		CPL			;to compare both extent numbers.
2528:	E70D  47      		LD	B,A		;save resulting mask here.
2529:	E70E  79      		LD	A,C		;mask first extent and save in (C).
2530:	E70F  A0      		AND	B
2531:	E710  4F      		LD	C,A
2532:	E711  F1      		POP	AF		;now mask second extent and compare
2533:	E712  A0      		AND	B		;with the first one.
2534:	E713  91      		SUB	C
2535:	E714  E61F    		AND	1FH		;(* only check buts 0-4 *)
2536:	E716  C1      		POP	BC		;the zero flag is set if they are the same.
2537:	E717  C9      		RET			;restore (BC) and return.
2538:			;
2539:			;   Search for the first occurence of a file name. On entry,
2540:			; register (C) should contain the number of bytes of the fcb
2541:			; that must match.
2542:			;
2543:	E718  3EFF    	FINDFST:LD	A,0FFH
2544:	E71A  32D4ED  		LD	(FNDSTAT),A
2545:	E71D  21D8ED  		LD	HL,COUNTER	;save character count.
2546:	E720  71      		LD	(HL),C
2547:	E721  2A43E3  		LD	HL,(PARAMS)	;get filename to match.
2548:	E724  22D9ED  		LD	(SAVEFCB),HL	;and save.
2549:	E727  CDFEE5  		CALL	STFILPOS	;clear initial file position (set to 0ffffh).
2550:	E72A  CDA1E3  		CALL	HOMEDRV		;home the drive.
2551:			;
2552:			;   Entry to locate the next occurence of a filename within the
2553:			; directory. The disk is not expected to have been changed. If
2554:			; it was, then it will be write protected.
2555:			;
2556:	E72D  0E00    	FINDNXT:LD	C,0		;write protect the disk if changed.
2557:	E72F  CD05E6  		CALL	NXENTRY		;get next filename entry in directory.
2558:	E732  CDF5E5  		CALL	CKFILPOS	;is file position = 0ffffh?
2559:	E735  CA94E7  		JP	Z,FNDNXT6	;yes, exit now then.
2560:	E738  2AD9ED  		LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
2561:	E73B  EB      		EX	DE,HL
2562:	E73C  1A      		LD	A,(DE)
2563:	E73D  FEE5    		CP	0E5H		;empty directory entry?
2564:	E73F  CA4AE7  		JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
2565:	E742  D5      		PUSH	DE
2566:	E743  CD7FE5  		CALL	MOREFLS		;more files in directory?
2567:	E746  D1      		POP	DE
2568:	E747  D294E7  		JP	NC,FNDNXT6	;no more. Exit now.
2569:	E74A  CD5EE5  	FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
2570:	E74D  3AD8ED  		LD	A,(COUNTER)	;get number of bytes (characters) to check.
2571:	E750  4F      		LD	C,A
2572:	E751  0600    		LD	B,0		;initialize byte position counter.
2573:	E753  79      	FNDNXT2:LD	A,C		;are we done with the compare?
2574:	E754  B7      		OR	A
2575:	E755  CA83E7  		JP	Z,FNDNXT5
2576:	E758  1A      		LD	A,(DE)		;no, check next byte.
2577:	E759  FE3F    		CP	'?'		;don't care about this character?
2578:	E75B  CA7CE7  		JP	Z,FNDNXT4
2579:	E75E  78      		LD	A,B		;get bytes position in fcb.
2580:	E75F  FE0D    		CP	13		;don't care about the thirteenth byte either.
2581:	E761  CA7CE7  		JP	Z,FNDNXT4
2582:	E764  FE0C    		CP	12		;extent byte?
2583:	E766  1A      		LD	A,(DE)
2584:	E767  CA73E7  		JP	Z,FNDNXT3
2585:	E76A  96      		SUB	(HL)		;otherwise compare characters.
2586:	E76B  E67F    		AND	7FH
2587:	E76D  C22DE7  		JP	NZ,FINDNXT	;not the same, check next entry.
2588:	E770  C37CE7  		JP	FNDNXT4		;so far so good, keep checking.
2589:	E773  C5      	FNDNXT3:PUSH	BC		;check the extent byte here.
2590:	E774  4E      		LD	C,(HL)
2591:	E775  CD07E7  		CALL	SAMEXT
2592:	E778  C1      		POP	BC
2593:	E779  C22DE7  		JP	NZ,FINDNXT	;not the same, look some more.
2594:			;
2595:			;   So far the names compare. Bump pointers to the next byte
2596:			; and continue until all (C) characters have been checked.
2597:			;
2598:	E77C  13      	FNDNXT4:INC	DE		;bump pointers.
2599:	E77D  23      		INC	HL
2600:	E77E  04      		INC	B
2601:	E77F  0D      		DEC	C		;adjust character counter.
2602:	E780  C353E7  		JP	FNDNXT2
2603:	E783  3AEAED  	FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
2604:	E786  E603    		AND	03H
2605:	E788  3245E3  		LD	(STATUS),A
2606:	E78B  21D4ED  		LD	HL,FNDSTAT
2607:	E78E  7E      		LD	A,(HL)
2608:	E78F  17      		RLA
2609:	E790  D0      		RET	NC
2610:	E791  AF      		XOR	A
2611:	E792  77      		LD	(HL),A
2612:	E793  C9      		RET
2613:			;
2614:			;   Filename was not found. Set appropriate status.
2615:			;
2616:	E794  CDFEE5  	FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
2617:	E797  3EFF    		LD	A,0FFH		;say not located.
2618:	E799  C301E3  		JP	SETSTAT
2619:			;
2620:			;   Erase files from the directory. Only the first byte of the
2621:			; fcb will be affected. It is set to (E5).
2622:			;
2623:	E79C  CD54E5  	ERAFILE:CALL	CHKWPRT		;is disk write protected?
2624:	E79F  0E0C    		LD	C,12		;only compare file names.
2625:	E7A1  CD18E7  		CALL	FINDFST		;get first file name.
2626:	E7A4  CDF5E5  	ERAFIL1:CALL	CKFILPOS	;any found?
2627:	E7A7  C8      		RET	Z		;nope, we must be done.
2628:	E7A8  CD44E5  		CALL	CHKROFL		;is file read only?
2629:	E7AB  CD5EE5  		CALL	FCB2HL		;nope, get address of fcb and
2630:	E7AE  36E5    		LD	(HL),0E5H	;set first byte to 'empty'.
2631:	E7B0  0E00    		LD	C,0		;clear the space from the bit map.
2632:	E7B2  CD6BE6  		CALL	SETFILE
2633:	E7B5  CDC6E5  		CALL	DIRWRITE	;now write the directory sector back out.
2634:	E7B8  CD2DE7  		CALL	FINDNXT		;find the next file name.
2635:	E7BB  C3A4E7  		JP	ERAFIL1		;and repeat process.
2636:			;
2637:			;   Look through the space allocation map (bit map) for the
2638:			; next available block. Start searching at block number (BC-1).
2639:			; The search procedure is to look for an empty block that is
2640:			; before the starting block. If not empty, look at a later
2641:			; block number. In this way, we return the closest empty block
2642:			; on either side of the 'target' block number. This will speed
2643:			; access on random devices. For serial devices, this should be
2644:			; changed to look in the forward direction first and then start
2645:			; at the front and search some more.
2646:			;
2647:			;   On return, (DE)= block number that is empty and (HL) =0
2648:			; if no empry block was found.
2649:			;
2650:	E7BE  50      	FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
2651:	E7BF  59      		LD	E,C
2652:			;
2653:			;   Look before target block. Registers (BC) are used as the lower
2654:			; pointer and (DE) as the upper pointer.
2655:			;
2656:	E7C0  79      	FNDSPA1:LD	A,C		;is block 0 specified?
2657:	E7C1  B0      		OR	B
2658:	E7C2  CAD1E7  		JP	Z,FNDSPA2
2659:	E7C5  0B      		DEC	BC		;nope, check previous block.
2660:	E7C6  D5      		PUSH	DE
2661:	E7C7  C5      		PUSH	BC
2662:	E7C8  CD35E6  		CALL	CKBITMAP
2663:	E7CB  1F      		RRA			;is this block empty?
2664:	E7CC  D2ECE7  		JP	NC,FNDSPA3	;yes. use this.
2665:			;
2666:			;   Note that the above logic gets the first block that it finds
2667:			; that is empty. Thus a file could be written 'backward' making
2668:			; it very slow to access. This could be changed to look for the
2669:			; first empty block and then continue until the start of this
2670:			; empty space is located and then used that starting block.
2671:			; This should help speed up access to some files especially on
2672:			; a well used disk with lots of fairly small 'holes'.
2673:			;
2674:	E7CF  C1      		POP	BC		;nope, check some more.
2675:	E7D0  D1      		POP	DE
2676:			;
2677:			;   Now look after target block.
2678:			;
2679:	E7D1  2AC6ED  	FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
2680:	E7D4  7B      		LD	A,E
2681:	E7D5  95      		SUB	L
2682:	E7D6  7A      		LD	A,D
2683:	E7D7  9C      		SBC	A,H
2684:	E7D8  D2F4E7  		JP	NC,FNDSPA4
2685:	E7DB  13      		INC	DE		;yes, move on to next one.
2686:	E7DC  C5      		PUSH	BC
2687:	E7DD  D5      		PUSH	DE
2688:	E7DE  42      		LD	B,D
2689:	E7DF  4B      		LD	C,E
2690:	E7E0  CD35E6  		CALL	CKBITMAP	;check it.
2691:	E7E3  1F      		RRA			;empty?
2692:	E7E4  D2ECE7  		JP	NC,FNDSPA3
2693:	E7E7  D1      		POP	DE		;nope, continue searching.
2694:	E7E8  C1      		POP	BC
2695:	E7E9  C3C0E7  		JP	FNDSPA1
2696:			;
2697:			;   Empty block found. Set it as used and return with (HL)
2698:			; pointing to it (true?).
2699:			;
2700:	E7EC  17      	FNDSPA3:RLA			;reset byte.
2701:	E7ED  3C      		INC	A		;and set bit 0.
2702:	E7EE  CD64E6  		CALL	STBMAP1		;update bit map.
2703:	E7F1  E1      		POP	HL		;set return registers.
2704:	E7F2  D1      		POP	DE
2705:	E7F3  C9      		RET
2706:			;
2707:			;   Free block was not found. If (BC) is not zero, then we have
2708:			; not checked all of the disk space.
2709:			;
2710:	E7F4  79      	FNDSPA4:LD	A,C
2711:	E7F5  B0      		OR	B
2712:	E7F6  C2C0E7  		JP	NZ,FNDSPA1
2713:	E7F9  210000  		LD	HL,0		;set 'not found' status.
2714:	E7FC  C9      		RET
2715:			;
2716:			;   Move a complete fcb entry into the directory and write it.
2717:			;
2718:	E7FD  0E00    	FCBSET:	LD	C,0
2719:	E7FF  1E20    		LD	E,32		;length of each entry.
2720:			;
2721:			;   Move (E) bytes from the fcb pointed to by (PARAMS) into
2722:			; fcb in directory starting at relative byte (C). This updated
2723:			; directory buffer is then written to the disk.
2724:			;
2725:	E801  D5      	UPDATE:	PUSH	DE
2726:	E802  0600    		LD	B,0		;set (BC) to relative byte position.
2727:	E804  2A43E3  		LD	HL,(PARAMS)	;get address of fcb.
2728:	E807  09      		ADD	HL,BC		;compute starting byte.
2729:	E808  EB      		EX	DE,HL
2730:	E809  CD5EE5  		CALL	FCB2HL		;get address of fcb to update in directory.
2731:	E80C  C1      		POP	BC		;set (C) to number of bytes to change.
2732:	E80D  CD4FE3  		CALL	DE2HL
2733:	E810  CDC3E3  	UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
2734:	E813  C3C6E5  		JP	DIRWRITE	;then write this sector out.
2735:			;
2736:			;   Routine to change the name of all files on the disk with a
2737:			; specified name. The fcb contains the current name as the
2738:			; first 12 characters and the new name 16 bytes into the fcb.
2739:			;
2740:	E816  CD54E5  	CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
2741:	E819  0E0C    		LD	C,12		;match first 12 bytes of fcb only.
2742:	E81B  CD18E7  		CALL	FINDFST		;get first name.
2743:	E81E  2A43E3  		LD	HL,(PARAMS)	;get address of fcb.
2744:	E821  7E      		LD	A,(HL)		;get user number.
2745:	E822  111000  		LD	DE,16		;move over to desired name.
2746:	E825  19      		ADD	HL,DE
2747:	E826  77      		LD	(HL),A		;keep same user number.
2748:	E827  CDF5E5  	CHGNAM1:CALL	CKFILPOS	;any matching file found?
2749:	E82A  C8      		RET	Z		;no, we must be done.
2750:	E82B  CD44E5  		CALL	CHKROFL		;check for read only file.
2751:	E82E  0E10    		LD	C,16		;start 16 bytes into fcb.
2752:	E830  1E0C    		LD	E,12		;and update the first 12 bytes of directory.
2753:	E832  CD01E8  		CALL	UPDATE
2754:	E835  CD2DE7  		CALL	FINDNXT		;get te next file name.
2755:	E838  C327E8  		JP	CHGNAM1		;and continue.
2756:			;
2757:			;   Update a files attributes. The procedure is to search for
2758:			; every file with the same name as shown in fcb (ignoring bit 7)
2759:			; and then to update it (which includes bit 7). No other changes
2760:			; are made.
2761:			;
2762:	E83B  0E0C    	SAVEATTR: LD	C,12		;match first 12 bytes.
2763:	E83D  CD18E7  		CALL	FINDFST		;look for first filename.
2764:	E840  CDF5E5  	SAVATR1:CALL	CKFILPOS	;was one found?
2765:	E843  C8      		RET	Z		;nope, we must be done.
2766:	E844  0E00    		LD	C,0		;yes, update the first 12 bytes now.
2767:	E846  1E0C    		LD	E,12
2768:	E848  CD01E8  		CALL	UPDATE		;update filename and write directory.
2769:	E84B  CD2DE7  		CALL	FINDNXT		;and get the next file.
2770:	E84E  C340E8  		JP	SAVATR1		;then continue until done.
2771:			;
2772:			;  Open a file (name specified in fcb).
2773:			;
2774:	E851  0E0F    	OPENIT:	LD	C,15		;compare the first 15 bytes.
2775:	E853  CD18E7  		CALL	FINDFST		;get the first one in directory.
2776:	E856  CDF5E5  		CALL	CKFILPOS	;any at all?
2777:	E859  C8      		RET	Z
2778:	E85A  CDA6E4  	OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
2779:	E85D  7E      		LD	A,(HL)		;and get it.
2780:	E85E  F5      		PUSH	AF		;save it and address.
2781:	E85F  E5      		PUSH	HL
2782:	E860  CD5EE5  		CALL	FCB2HL		;point to fcb in directory.
2783:	E863  EB      		EX	DE,HL
2784:	E864  2A43E3  		LD	HL,(PARAMS)	;this is the users copy.
2785:	E867  0E20    		LD	C,32		;move it into users space.
2786:	E869  D5      		PUSH	DE
2787:	E86A  CD4FE3  		CALL	DE2HL
2788:	E86D  CD78E5  		CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
2789:	E870  D1      		POP	DE		;now get the extent byte from this fcb.
2790:	E871  210C00  		LD	HL,12
2791:	E874  19      		ADD	HL,DE
2792:	E875  4E      		LD	C,(HL)		;into (C).
2793:	E876  210F00  		LD	HL,15		;now get the record count byte into (B).
2794:	E879  19      		ADD	HL,DE
2795:	E87A  46      		LD	B,(HL)
2796:	E87B  E1      		POP	HL		;keep the same extent as the user had originally.
2797:	E87C  F1      		POP	AF
2798:	E87D  77      		LD	(HL),A
2799:	E87E  79      		LD	A,C		;is it the same as in the directory fcb?
2800:	E87F  BE      		CP	(HL)
2801:	E880  78      		LD	A,B		;if yes, then use the same record count.
2802:	E881  CA8BE8  		JP	Z,OPENIT2
2803:	E884  3E00    		LD	A,0		;if the user specified an extent greater than
2804:	E886  DA8BE8  		JP	C,OPENIT2	;the one in the directory, then set record count to 0.
2805:	E889  3E80    		LD	A,128		;otherwise set to maximum.
2806:	E88B  2A43E3  	OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
2807:	E88E  110F00  		LD	DE,15
2808:	E891  19      		ADD	HL,DE		;compute relative position.
2809:	E892  77      		LD	(HL),A		;and set the record count.
2810:	E893  C9      		RET
2811:			;
2812:			;   Move two bytes from (DE) to (HL) if (and only if) (HL)
2813:			; point to a zero value (16 bit).
2814:			;   Return with zero flag set it (DE) was moved. Registers (DE)
2815:			; and (HL) are not changed. However (A) is.
2816:			;
2817:	E894  7E      	MOVEWORD: LD	A,(HL)		;check for a zero word.
2818:	E895  23      		INC	HL
2819:	E896  B6      		OR	(HL)		;both bytes zero?
2820:	E897  2B      		DEC	HL
2821:	E898  C0      		RET	NZ		;nope, just return.
2822:	E899  1A      		LD	A,(DE)		;yes, move two bytes from (DE) into
2823:	E89A  77      		LD	(HL),A		;this zero space.
2824:	E89B  13      		INC	DE
2825:	E89C  23      		INC	HL
2826:	E89D  1A      		LD	A,(DE)
2827:	E89E  77      		LD	(HL),A
2828:	E89F  1B      		DEC	DE		;don't disturb these registers.
2829:	E8A0  2B      		DEC	HL
2830:	E8A1  C9      		RET
2831:			;
2832:			;   Get here to close a file specified by (fcb).
2833:			;
2834:	E8A2  AF      	CLOSEIT:XOR	A		;clear status and file position bytes.
2835:	E8A3  3245E3  		LD	(STATUS),A
2836:	E8A6  32EAED  		LD	(FILEPOS),A
2837:	E8A9  32EBED  		LD	(FILEPOS+1),A
2838:	E8AC  CD1EE5  		CALL	GETWPRT		;get write protect bit for this drive.
2839:	E8AF  C0      		RET	NZ		;just return if it is set.
2840:	E8B0  CD69E5  		CALL	GETS2		;else get the 's2' byte.
2841:	E8B3  E680    		AND	80H		;and look at bit 7 (file unmodified?).
2842:	E8B5  C0      		RET	NZ		;just return if set.
2843:	E8B6  0E0F    		LD	C,15		;else look up this file in directory.
2844:	E8B8  CD18E7  		CALL	FINDFST
2845:	E8BB  CDF5E5  		CALL	CKFILPOS	;was it found?
2846:	E8BE  C8      		RET	Z		;just return if not.
2847:	E8BF  011000  		LD	BC,16		;set (HL) pointing to records used section.
2848:	E8C2  CD5EE5  		CALL	FCB2HL
2849:	E8C5  09      		ADD	HL,BC
2850:	E8C6  EB      		EX	DE,HL
2851:	E8C7  2A43E3  		LD	HL,(PARAMS)	;do the same for users specified fcb.
2852:	E8CA  09      		ADD	HL,BC
2853:	E8CB  0E10    		LD	C,16		;this many bytes are present in this extent.
2854:	E8CD  3ADDED  	CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
2855:	E8D0  B7      		OR	A
2856:	E8D1  CAE8E8  		JP	Z,CLOSEIT4
2857:	E8D4  7E      		LD	A,(HL)		;just 8 bit. Get one from users fcb.
2858:	E8D5  B7      		OR	A
2859:	E8D6  1A      		LD	A,(DE)		;now get one from directory fcb.
2860:	E8D7  C2DBE8  		JP	NZ,CLOSEIT2
2861:	E8DA  77      		LD	(HL),A		;users byte was zero. Update from directory.
2862:	E8DB  B7      	CLOSEIT2: OR	A
2863:	E8DC  C2E1E8  		JP	NZ,CLOSEIT3
2864:	E8DF  7E      		LD	A,(HL)		;directories byte was zero, update from users fcb.
2865:	E8E0  12      		LD	(DE),A
2866:	E8E1  BE      	CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
2867:	E8E2  C21FE9  		JP	NZ,CLOSEIT7	;then close error if they are not the same.
2868:	E8E5  C3FDE8  		JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
2869:	E8E8  CD94E8  	CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
2870:	E8EB  EB      		EX	DE,HL
2871:	E8EC  CD94E8  		CALL	MOVEWORD	;update directories fcb if it is zero.
2872:	E8EF  EB      		EX	DE,HL
2873:	E8F0  1A      		LD	A,(DE)		;if these two values are no different,
2874:	E8F1  BE      		CP	(HL)		;then a close error occured.
2875:	E8F2  C21FE9  		JP	NZ,CLOSEIT7
2876:	E8F5  13      		INC	DE		;check second byte.
2877:	E8F6  23      		INC	HL
2878:	E8F7  1A      		LD	A,(DE)
2879:	E8F8  BE      		CP	(HL)
2880:	E8F9  C21FE9  		JP	NZ,CLOSEIT7
2881:	E8FC  0D      		DEC	C		;remember 16 bit values.
2882:	E8FD  13      	CLOSEIT5: INC	DE		;bump to next item in table.
2883:	E8FE  23      		INC	HL
2884:	E8FF  0D      		DEC	C		;there are 16 entries only.
2885:	E900  C2CDE8  		JP	NZ,CLOSEIT1	;continue if more to do.
2886:	E903  01ECFF  		LD	BC,0FFECH	;backup 20 places (extent byte).
2887:	E906  09      		ADD	HL,BC
2888:	E907  EB      		EX	DE,HL
2889:	E908  09      		ADD	HL,BC
2890:	E909  1A      		LD	A,(DE)
2891:	E90A  BE      		CP	(HL)		;directory's extent already greater than the
2892:	E90B  DA17E9  		JP	C,CLOSEIT6	;users extent?
2893:	E90E  77      		LD	(HL),A		;no, update directory extent.
2894:	E90F  010300  		LD	BC,3		;and update the record count byte in
2895:	E912  09      		ADD	HL,BC		;directories fcb.
2896:	E913  EB      		EX	DE,HL
2897:	E914  09      		ADD	HL,BC
2898:	E915  7E      		LD	A,(HL)		;get from user.
2899:	E916  12      		LD	(DE),A		;and put in directory.
2900:	E917  3EFF    	CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
2901:	E919  32D2ED  		LD	(CLOSEFLG),A
2902:	E91C  C310E8  		JP	UPDATE1		;update the directory now.
2903:	E91F  2145E3  	CLOSEIT7: LD	HL,STATUS	;set return status and then return.
2904:	E922  35      		DEC	(HL)
2905:	E923  C9      		RET
2906:			;
2907:			;   Routine to get the next empty space in the directory. It
2908:			; will then be cleared for use.
2909:			;
2910:	E924  CD54E5  	GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
2911:	E927  2A43E3  		LD	HL,(PARAMS)	;save current parameters (fcb).
2912:	E92A  E5      		PUSH	HL
2913:	E92B  21ACED  		LD	HL,EMPTYFCB	;use special one for empty space.
2914:	E92E  2243E3  		LD	(PARAMS),HL
2915:	E931  0E01    		LD	C,1		;search for first empty spot in directory.
2916:	E933  CD18E7  		CALL	FINDFST		;(* only check first byte *)
2917:	E936  CDF5E5  		CALL	CKFILPOS	;none?
2918:	E939  E1      		POP	HL
2919:	E93A  2243E3  		LD	(PARAMS),HL	;restore original fcb address.
2920:	E93D  C8      		RET	Z		;return if no more space.
2921:	E93E  EB      		EX	DE,HL
2922:	E93F  210F00  		LD	HL,15		;point to number of records for this file.
2923:	E942  19      		ADD	HL,DE
2924:	E943  0E11    		LD	C,17		;and clear all of this space.
2925:	E945  AF      		XOR	A
2926:	E946  77      	GETMT1:	LD	(HL),A
2927:	E947  23      		INC	HL
2928:	E948  0D      		DEC	C
2929:	E949  C246E9  		JP	NZ,GETMT1
2930:	E94C  210D00  		LD	HL,13		;clear the 's1' byte also.
2931:	E94F  19      		ADD	HL,DE
2932:	E950  77      		LD	(HL),A
2933:	E951  CD8CE5  		CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
2934:	E954  CDFDE7  		CALL	FCBSET		;write out this fcb entry to directory.
2935:	E957  C378E5  		JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
2936:			;
2937:			;   Routine to close the current extent and open the next one
2938:			; for reading.
2939:			;
2940:	E95A  AF      	GETNEXT:XOR	A
2941:	E95B  32D2ED  		LD	(CLOSEFLG),A	;clear close flag.
2942:	E95E  CDA2E8  		CALL	CLOSEIT		;close this extent.
2943:	E961  CDF5E5  		CALL	CKFILPOS
2944:	E964  C8      		RET	Z		;not there???
2945:	E965  2A43E3  		LD	HL,(PARAMS)	;get extent byte.
2946:	E968  010C00  		LD	BC,12
2947:	E96B  09      		ADD	HL,BC
2948:	E96C  7E      		LD	A,(HL)		;and increment it.
2949:	E96D  3C      		INC	A
2950:	E96E  E61F    		AND	1FH		;keep within range 0-31.
2951:	E970  77      		LD	(HL),A
2952:	E971  CA83E9  		JP	Z,GTNEXT1	;overflow?
2953:	E974  47      		LD	B,A		;mask extent byte.
2954:	E975  3AC5ED  		LD	A,(EXTMASK)
2955:	E978  A0      		AND	B
2956:	E979  21D2ED  		LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
2957:	E97C  A6      		AND	(HL)
2958:	E97D  CA8EE9  		JP	Z,GTNEXT2	;if zero, we must read in next extent.
2959:	E980  C3ACE9  		JP	GTNEXT3		;else, it is already in memory.
2960:	E983  010200  	GTNEXT1:LD	BC,2		;Point to the 's2' byte.
2961:	E986  09      		ADD	HL,BC
2962:	E987  34      		INC	(HL)		;and bump it.
2963:	E988  7E      		LD	A,(HL)		;too many extents?
2964:	E989  E60F    		AND	0FH
2965:	E98B  CAB6E9  		JP	Z,GTNEXT5	;yes, set error code.
2966:			;
2967:			;   Get here to open the next extent.
2968:			;
2969:	E98E  0E0F    	GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
2970:	E990  CD18E7  		CALL	FINDFST		;find the first one.
2971:	E993  CDF5E5  		CALL	CKFILPOS	;none available?
2972:	E996  C2ACE9  		JP	NZ,GTNEXT3
2973:	E999  3AD3ED  		LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
2974:	E99C  3C      		INC	A		;0ffh means reading (so not possible).
2975:	E99D  CAB6E9  		JP	Z,GTNEXT5	;or an error.
2976:	E9A0  CD24E9  		CALL	GETEMPTY	;we are writing, get an empty entry.
2977:	E9A3  CDF5E5  		CALL	CKFILPOS	;none?
2978:	E9A6  CAB6E9  		JP	Z,GTNEXT5	;error if true.
2979:	E9A9  C3AFE9  		JP	GTNEXT4		;else we are almost done.
2980:	E9AC  CD5AE8  	GTNEXT3:CALL	OPENIT1		;open this extent.
2981:	E9AF  CDBBE4  	GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
2982:	E9B2  AF      		XOR	A		;clear status and return.
2983:	E9B3  C301E3  		JP	SETSTAT
2984:			;
2985:			;   Error in extending the file. Too many extents were needed
2986:			; or not enough space on the disk.
2987:			;
2988:	E9B6  CD05E3  	GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
2989:	E9B9  C378E5  		JP	SETS2B7		;so this is not written on a close.
2990:			;
2991:			;   Read a sequential file.
2992:			;
2993:	E9BC  3E01    	RDSEQ:	LD	A,1		;set sequential access mode.
2994:	E9BE  32D5ED  		LD	(MODE),A
2995:	E9C1  3EFF    	RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
2996:	E9C3  32D3ED  		LD	(RDWRTFLG),A
2997:	E9C6  CDBBE4  		CALL	STRDATA		;put rec# and ext# into fcb.
2998:	E9C9  3AE3ED  		LD	A,(SAVNREC)	;get next record to read.
2999:	E9CC  21E1ED  		LD	HL,SAVNXT	;get number of records in extent.
3000:	E9CF  BE      		CP	(HL)		;within this extent?
3001:	E9D0  DAE6E9  		JP	C,RDSEQ2
3002:	E9D3  FE80    		CP	128		;no. Is this extent fully used?
3003:	E9D5  C2FBE9  		JP	NZ,RDSEQ3	;no. End-of-file.
3004:	E9D8  CD5AE9  		CALL	GETNEXT		;yes, open the next one.
3005:	E9DB  AF      		XOR	A		;reset next record to read.
3006:	E9DC  32E3ED  		LD	(SAVNREC),A
3007:	E9DF  3A45E3  		LD	A,(STATUS)	;check on open, successful?
3008:	E9E2  B7      		OR	A
3009:	E9E3  C2FBE9  		JP	NZ,RDSEQ3	;no, error.
3010:	E9E6  CD77E4  	RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
3011:	E9E9  CD84E4  		CALL	CHKBLK		;check it. Within bounds?
3012:	E9EC  CAFBE9  		JP	Z,RDSEQ3	;no, error.
3013:	E9EF  CD8AE4  		CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
3014:	E9F2  CDD1E3  		CALL	TRKSEC1		;set the track and sector for this block #.
3015:	E9F5  CDB2E3  		CALL	DOREAD		;and read it.
3016:	E9F8  C3D2E4  		JP	SETNREC		;and set the next record to be accessed.
3017:			;
3018:			;   Read error occured. Set status and return.
3019:			;
3020:	E9FB  C305E3  	RDSEQ3:	JP	IOERR1
3021:			;
3022:			;   Write the next sequential record.
3023:			;
3024:	E9FE  3E01    	WTSEQ:	LD	A,1		;set sequential access mode.
3025:	EA00  32D5ED  		LD	(MODE),A
3026:	EA03  3E00    	WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
3027:	EA05  32D3ED  		LD	(RDWRTFLG),A
3028:	EA08  CD54E5  		CALL	CHKWPRT		;check write protect status.
3029:	EA0B  2A43E3  		LD	HL,(PARAMS)
3030:	EA0E  CD47E5  		CALL	CKROF1		;check for read only file, (HL) already set to fcb.
3031:	EA11  CDBBE4  		CALL	STRDATA		;put updated data into fcb.
3032:	EA14  3AE3ED  		LD	A,(SAVNREC)	;get record number to write.
3033:	EA17  FE80    		CP	128		;within range?
3034:	EA19  D205E3  		JP	NC,IOERR1	;no, error(?).
3035:	EA1C  CD77E4  		CALL	COMBLK		;compute block number.
3036:	EA1F  CD84E4  		CALL	CHKBLK		;check number.
3037:	EA22  0E00    		LD	C,0		;is there one to write to?
3038:	EA24  C26EEA  		JP	NZ,WTSEQ6	;yes, go do it.
3039:	EA27  CD3EE4  		CALL	GETBLOCK	;get next block number within fcb to use.
3040:	EA2A  32D7ED  		LD	(RELBLOCK),A	;and save.
3041:	EA2D  010000  		LD	BC,0		;start looking for space from the start
3042:	EA30  B7      		OR	A		;if none allocated as yet.
3043:	EA31  CA3BEA  		JP	Z,WTSEQ2
3044:	EA34  4F      		LD	C,A		;extract previous block number from fcb
3045:	EA35  0B      		DEC	BC		;so we can be closest to it.
3046:	EA36  CD5EE4  		CALL	EXTBLK
3047:	EA39  44      		LD	B,H
3048:	EA3A  4D      		LD	C,L
3049:	EA3B  CDBEE7  	WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
3050:	EA3E  7D      		LD	A,L		;check for a zero number.
3051:	EA3F  B4      		OR	H
3052:	EA40  C248EA  		JP	NZ,WTSEQ3
3053:	EA43  3E02    		LD	A,2		;no more space?
3054:	EA45  C301E3  		JP	SETSTAT
3055:	EA48  22E5ED  	WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
3056:	EA4B  EB      		EX	DE,HL		;put block number into (DE).
3057:	EA4C  2A43E3  		LD	HL,(PARAMS)	;now we must update the fcb for this
3058:	EA4F  011000  		LD	BC,16		;newly allocated block.
3059:	EA52  09      		ADD	HL,BC
3060:	EA53  3ADDED  		LD	A,(BIGDISK)	;8 or 16 bit block numbers?
3061:	EA56  B7      		OR	A
3062:	EA57  3AD7ED  		LD	A,(RELBLOCK)	;(* update this entry *)
3063:	EA5A  CA64EA  		JP	Z,WTSEQ4	;zero means 16 bit ones.
3064:	EA5D  CD64E5  		CALL	ADDA2HL		;(HL)=(HL)+(A)
3065:	EA60  73      		LD	(HL),E		;store new block number.
3066:	EA61  C36CEA  		JP	WTSEQ5
3067:	EA64  4F      	WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
3068:	EA65  0600    		LD	B,0
3069:	EA67  09      		ADD	HL,BC
3070:	EA68  09      		ADD	HL,BC
3071:	EA69  73      		LD	(HL),E		;stuff block number (DE) there.
3072:	EA6A  23      		INC	HL
3073:	EA6B  72      		LD	(HL),D
3074:	EA6C  0E02    	WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
3075:	EA6E  3A45E3  	WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
3076:	EA71  B7      		OR	A
3077:	EA72  C0      		RET	NZ
3078:	EA73  C5      		PUSH	BC		;yes, save write flag for bios (register C).
3079:	EA74  CD8AE4  		CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
3080:	EA77  3AD5ED  		LD	A,(MODE)	;get access mode flag (1=sequential,
3081:	EA7A  3D      		DEC	A		;0=random, 2=special?).
3082:	EA7B  3D      		DEC	A
3083:	EA7C  C2BBEA  		JP	NZ,WTSEQ9
3084:			;
3085:			;   Special random i/o from function #40. Maybe for M/PM, but the
3086:			; current block, if it has not been written to, will be zeroed
3087:			; out and then written (reason?).
3088:			;
3089:	EA7F  C1      		POP	BC
3090:	EA80  C5      		PUSH	BC
3091:	EA81  79      		LD	A,C		;get write status flag (2=writing unused space).
3092:	EA82  3D      		DEC	A
3093:	EA83  3D      		DEC	A
3094:	EA84  C2BBEA  		JP	NZ,WTSEQ9
3095:	EA87  E5      		PUSH	HL
3096:	EA88  2AB9ED  		LD	HL,(DIRBUF)	;zero out the directory buffer.
3097:	EA8B  57      		LD	D,A		;note that (A) is zero here.
3098:	EA8C  77      	WTSEQ7:	LD	(HL),A
3099:	EA8D  23      		INC	HL
3100:	EA8E  14      		INC	D		;do 128 bytes.
3101:	EA8F  F28CEA  		JP	P,WTSEQ7
3102:	EA92  CDE0E5  		CALL	DIRDMA		;tell the bios the dma address for directory access.
3103:	EA95  2AE7ED  		LD	HL,(LOGSECT)	;get sector that starts current block.
3104:	EA98  0E02    		LD	C,2		;set 'writing to unused space' flag.
3105:	EA9A  22E5ED  	WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
3106:	EA9D  C5      		PUSH	BC
3107:	EA9E  CDD1E3  		CALL	TRKSEC1		;determine its track and sector numbers.
3108:	EAA1  C1      		POP	BC
3109:	EAA2  CDB8E3  		CALL	DOWRITE		;now write out 128 bytes of zeros.
3110:	EAA5  2AE5ED  		LD	HL,(BLKNMBR)	;get sector number.
3111:	EAA8  0E00    		LD	C,0		;set normal write flag.
3112:	EAAA  3AC4ED  		LD	A,(BLKMASK)	;determine if we have written the entire
3113:	EAAD  47      		LD	B,A		;physical block.
3114:	EAAE  A5      		AND	L
3115:	EAAF  B8      		CP	B
3116:	EAB0  23      		INC	HL		;prepare for the next one.
3117:	EAB1  C29AEA  		JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
3118:	EAB4  E1      		POP	HL		;reset next sector number.
3119:	EAB5  22E5ED  		LD	(BLKNMBR),HL
3120:	EAB8  CDDAE5  		CALL	DEFDMA		;and reset dma address.
3121:			;
3122:			;   Normal disk write. Set the desired track and sector then
3123:			; do the actual write.
3124:			;
3125:	EABB  CDD1E3  	WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
3126:	EABE  C1      		POP	BC		;get write status flag.
3127:	EABF  C5      		PUSH	BC
3128:	EAC0  CDB8E3  		CALL	DOWRITE		;and write this out.
3129:	EAC3  C1      		POP	BC
3130:	EAC4  3AE3ED  		LD	A,(SAVNREC)	;get number of records in file.
3131:	EAC7  21E1ED  		LD	HL,SAVNXT	;get last record written.
3132:	EACA  BE      		CP	(HL)
3133:	EACB  DAD2EA  		JP	C,WTSEQ10
3134:	EACE  77      		LD	(HL),A		;we have to update record count.
3135:	EACF  34      		INC	(HL)
3136:	EAD0  0E02    		LD	C,2
3137:			;
3138:			;*   This area has been patched to correct disk update problem
3139:			;* when using blocking and de-blocking in the BIOS.
3140:			;
3141:	EAD2  00      	WTSEQ10:NOP			;was 'dcr c'
3142:	EAD3  00      		NOP			;was 'dcr c'
3143:	EAD4  210000  		LD	HL,0		;was 'jnz wtseq99'
3144:			;
3145:			; *   End of patch.
3146:			;
3147:	EAD7  F5      		PUSH	AF
3148:	EAD8  CD69E5  		CALL	GETS2		;set 'extent written to' flag.
3149:	EADB  E67F    		AND	7FH		;(* clear bit 7 *)
3150:	EADD  77      		LD	(HL),A
3151:	EADE  F1      		POP	AF		;get record count for this extent.
3152:	EADF  FE7F    	WTSEQ99:CP	127		;is it full?
3153:	EAE1  C200EB  		JP	NZ,WTSEQ12
3154:	EAE4  3AD5ED  		LD	A,(MODE)	;yes, are we in sequential mode?
3155:	EAE7  FE01    		CP	1
3156:	EAE9  C200EB  		JP	NZ,WTSEQ12
3157:	EAEC  CDD2E4  		CALL	SETNREC		;yes, set next record number.
3158:	EAEF  CD5AE9  		CALL	GETNEXT		;and get next empty space in directory.
3159:	EAF2  2145E3  		LD	HL,STATUS	;ok?
3160:	EAF5  7E      		LD	A,(HL)
3161:	EAF6  B7      		OR	A
3162:	EAF7  C2FEEA  		JP	NZ,WTSEQ11
3163:	EAFA  3D      		DEC	A		;yes, set record count to -1.
3164:	EAFB  32E3ED  		LD	(SAVNREC),A
3165:	EAFE  3600    	WTSEQ11:LD	(HL),0		;clear status.
3166:	EB00  C3D2E4  	WTSEQ12:JP	SETNREC		;set next record to access.
3167:			;
3168:			;   For random i/o, set the fcb for the desired record number
3169:			; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3170:			; used as follows:
3171:			;
3172:			;       fcb+35            fcb+34            fcb+33
3173:			;  |     'r-2'      |      'r-1'      |      'r-0'     |
3174:			;  |7             0 | 7             0 | 7             0|
3175:			;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3176:			;  |    overflow   | | extra |  extent   |   record #  |
3177:			;  | ______________| |_extent|__number___|_____________|
3178:			;                     also 's2'
3179:			;
3180:			;   On entry, register (C) contains 0ffh if this is a read
3181:			; and thus we can not access unwritten disk space. Otherwise,
3182:			; another extent will be opened (for writing) if required.
3183:			;
3184:	EB03  AF      	POSITION: XOR	A		;set random i/o flag.
3185:	EB04  32D5ED  		LD	(MODE),A
3186:			;
3187:			;   Special entry (function #40). M/PM ?
3188:			;
3189:	EB07  C5      	POSITN1:PUSH	BC		;save read/write flag.
3190:	EB08  2A43E3  		LD	HL,(PARAMS)	;get address of fcb.
3191:	EB0B  EB      		EX	DE,HL
3192:	EB0C  212100  		LD	HL,33		;now get byte 'r0'.
3193:	EB0F  19      		ADD	HL,DE
3194:	EB10  7E      		LD	A,(HL)
3195:	EB11  E67F    		AND	7FH		;keep bits 0-6 for the record number to access.
3196:	EB13  F5      		PUSH	AF
3197:	EB14  7E      		LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3198:	EB15  17      		RLA
3199:	EB16  23      		INC	HL
3200:	EB17  7E      		LD	A,(HL)
3201:	EB18  17      		RLA
3202:	EB19  E61F    		AND	1FH		;and save this in bits 0-4 of (C).
3203:	EB1B  4F      		LD	C,A		;this is the extent byte.
3204:	EB1C  7E      		LD	A,(HL)		;now get the extra extent byte.
3205:	EB1D  1F      		RRA
3206:	EB1E  1F      		RRA
3207:	EB1F  1F      		RRA
3208:	EB20  1F      		RRA
3209:	EB21  E60F    		AND	0FH
3210:	EB23  47      		LD	B,A		;and save it in (B).
3211:	EB24  F1      		POP	AF		;get record number back to (A).
3212:	EB25  23      		INC	HL		;check overflow byte 'r2'.
3213:	EB26  6E      		LD	L,(HL)
3214:	EB27  2C      		INC	L
3215:	EB28  2D      		DEC	L
3216:	EB29  2E06    		LD	L,6		;prepare for error.
3217:	EB2B  C28BEB  		JP	NZ,POSITN5	;out of disk space error.
3218:	EB2E  212000  		LD	HL,32		;store record number into fcb.
3219:	EB31  19      		ADD	HL,DE
3220:	EB32  77      		LD	(HL),A
3221:	EB33  210C00  		LD	HL,12		;and now check the extent byte.
3222:	EB36  19      		ADD	HL,DE
3223:	EB37  79      		LD	A,C
3224:	EB38  96      		SUB	(HL)		;same extent as before?
3225:	EB39  C247EB  		JP	NZ,POSITN2
3226:	EB3C  210E00  		LD	HL,14		;yes, check extra extent byte 's2' also.
3227:	EB3F  19      		ADD	HL,DE
3228:	EB40  78      		LD	A,B
3229:	EB41  96      		SUB	(HL)
3230:	EB42  E67F    		AND	7FH
3231:	EB44  CA7FEB  		JP	Z,POSITN3	;same, we are almost done then.
3232:			;
3233:			;  Get here when another extent is required.
3234:			;
3235:	EB47  C5      	POSITN2:PUSH	BC
3236:	EB48  D5      		PUSH	DE
3237:	EB49  CDA2E8  		CALL	CLOSEIT		;close current extent.
3238:	EB4C  D1      		POP	DE
3239:	EB4D  C1      		POP	BC
3240:	EB4E  2E03    		LD	L,3		;prepare for error.
3241:	EB50  3A45E3  		LD	A,(STATUS)
3242:	EB53  3C      		INC	A
3243:	EB54  CA84EB  		JP	Z,POSITN4	;close error.
3244:	EB57  210C00  		LD	HL,12		;put desired extent into fcb now.
3245:	EB5A  19      		ADD	HL,DE
3246:	EB5B  71      		LD	(HL),C
3247:	EB5C  210E00  		LD	HL,14		;and store extra extent byte 's2'.
3248:	EB5F  19      		ADD	HL,DE
3249:	EB60  70      		LD	(HL),B
3250:	EB61  CD51E8  		CALL	OPENIT		;try and get this extent.
3251:	EB64  3A45E3  		LD	A,(STATUS)	;was it there?
3252:	EB67  3C      		INC	A
3253:	EB68  C27FEB  		JP	NZ,POSITN3
3254:	EB6B  C1      		POP	BC		;no. can we create a new one (writing?).
3255:	EB6C  C5      		PUSH	BC
3256:	EB6D  2E04    		LD	L,4		;prepare for error.
3257:	EB6F  0C      		INC	C
3258:	EB70  CA84EB  		JP	Z,POSITN4	;nope, reading unwritten space error.
3259:	EB73  CD24E9  		CALL	GETEMPTY	;yes we can, try to find space.
3260:	EB76  2E05    		LD	L,5		;prepare for error.
3261:	EB78  3A45E3  		LD	A,(STATUS)
3262:	EB7B  3C      		INC	A
3263:	EB7C  CA84EB  		JP	Z,POSITN4	;out of space?
3264:			;
3265:			;   Normal return location. Clear error code and return.
3266:			;
3267:	EB7F  C1      	POSITN3:POP	BC		;restore stack.
3268:	EB80  AF      		XOR	A		;and clear error code byte.
3269:	EB81  C301E3  		JP	SETSTAT
3270:			;
3271:			;   Error. Set the 's2' byte to indicate this (why?).
3272:			;
3273:	EB84  E5      	POSITN4:PUSH	HL
3274:	EB85  CD69E5  		CALL	GETS2
3275:	EB88  36C0    		LD	(HL),0C0H
3276:	EB8A  E1      		POP	HL
3277:			;
3278:			;   Return with error code (presently in L).
3279:			;
3280:	EB8B  C1      	POSITN5:POP	BC
3281:	EB8C  7D      		LD	A,L		;get error code.
3282:	EB8D  3245E3  		LD	(STATUS),A
3283:	EB90  C378E5  		JP	SETS2B7
3284:			;
3285:			;   Read a random record.
3286:			;
3287:	EB93  0EFF    	READRAN:LD	C,0FFH		;set 'read' status.
3288:	EB95  CD03EB  		CALL	POSITION	;position the file to proper record.
3289:	EB98  CCC1E9  		CALL	Z,RDSEQ1	;and read it as usual (if no errors).
3290:	EB9B  C9      		RET
3291:			;
3292:			;   Write to a random record.
3293:			;
3294:	EB9C  0E00    	WRITERAN: LD	C,0		;set 'writing' flag.
3295:	EB9E  CD03EB  		CALL	POSITION	;position the file to proper record.
3296:	EBA1  CC03EA  		CALL	Z,WTSEQ1	;and write as usual (if no errors).
3297:	EBA4  C9      		RET
3298:			;
3299:			;   Compute the random record number. Enter with (HL) pointing
3300:			; to a fcb an (DE) contains a relative location of a record
3301:			; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3302:			; byte, and (A) the 'r2' byte.
3303:			;
3304:			;   On return, the zero flag is set if the record is within
3305:			; bounds. Otherwise, an overflow occured.
3306:			;
3307:	EBA5  EB      	COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
3308:	EBA6  19      		ADD	HL,DE		;compute relative position of record #.
3309:	EBA7  4E      		LD	C,(HL)		;get record number into (BC).
3310:	EBA8  0600    		LD	B,0
3311:	EBAA  210C00  		LD	HL,12		;now get extent.
3312:	EBAD  19      		ADD	HL,DE
3313:	EBAE  7E      		LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
3314:	EBAF  0F      		RRCA			;move lower bit into bit 7.
3315:	EBB0  E680    		AND	80H		;and ignore all other bits.
3316:	EBB2  81      		ADD	A,C		;add to our record number.
3317:	EBB3  4F      		LD	C,A
3318:	EBB4  3E00    		LD	A,0		;take care of any carry.
3319:	EBB6  88      		ADC	A,B
3320:	EBB7  47      		LD	B,A
3321:	EBB8  7E      		LD	A,(HL)		;now get the upper bits of extent into
3322:	EBB9  0F      		RRCA			;bit positions 0-3.
3323:	EBBA  E60F    		AND	0FH		;and ignore all others.
3324:	EBBC  80      		ADD	A,B		;add this in to 'r1' byte.
3325:	EBBD  47      		LD	B,A
3326:	EBBE  210E00  		LD	HL,14		;get the 's2' byte (extra extent).
3327:	EBC1  19      		ADD	HL,DE
3328:	EBC2  7E      		LD	A,(HL)
3329:	EBC3  87      		ADD	A,A		;and shift it left 4 bits (bits 4-7).
3330:	EBC4  87      		ADD	A,A
3331:	EBC5  87      		ADD	A,A
3332:	EBC6  87      		ADD	A,A
3333:	EBC7  F5      		PUSH	AF		;save carry flag (bit 0 of flag byte).
3334:	EBC8  80      		ADD	A,B		;now add extra extent into 'r1'.
3335:	EBC9  47      		LD	B,A
3336:	EBCA  F5      		PUSH	AF		;and save carry (overflow byte 'r2').
3337:	EBCB  E1      		POP	HL		;bit 0 of (L) is the overflow indicator.
3338:	EBCC  7D      		LD	A,L
3339:	EBCD  E1      		POP	HL		;and same for first carry flag.
3340:	EBCE  B5      		OR	L		;either one of these set?
3341:	EBCF  E601    		AND	01H		;only check the carry flags.
3342:	EBD1  C9      		RET
3343:			;
3344:			;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3345:			; reflect the last record used for a random (or other) file.
3346:			; This reads the directory and looks at all extents computing
3347:			; the largerst record number for each and keeping the maximum
3348:			; value only. Then 'r0', 'r1', and 'r2' will reflect this
3349:			; maximum record number. This is used to compute the space used
3350:			; by a random file.
3351:			;
3352:	EBD2  0E0C    	RANSIZE:LD	C,12		;look thru directory for first entry with
3353:	EBD4  CD18E7  		CALL	FINDFST		;this name.
3354:	EBD7  2A43E3  		LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
3355:	EBDA  112100  		LD	DE,33
3356:	EBDD  19      		ADD	HL,DE
3357:	EBDE  E5      		PUSH	HL
3358:	EBDF  72      		LD	(HL),D		;note that (D)=0.
3359:	EBE0  23      		INC	HL
3360:	EBE1  72      		LD	(HL),D
3361:	EBE2  23      		INC	HL
3362:	EBE3  72      		LD	(HL),D
3363:	EBE4  CDF5E5  	RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
3364:	EBE7  CA0CEC  		JP	Z,RANSIZ3	;no, we are done.
3365:	EBEA  CD5EE5  		CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
3366:	EBED  110F00  		LD	DE,15		;point to last record in extent.
3367:	EBF0  CDA5EB  		CALL	COMPRAND	;and compute random parameters.
3368:	EBF3  E1      		POP	HL
3369:	EBF4  E5      		PUSH	HL		;now check these values against those
3370:	EBF5  5F      		LD	E,A		;already in fcb.
3371:	EBF6  79      		LD	A,C		;the carry flag will be set if those
3372:	EBF7  96      		SUB	(HL)		;in the fcb represent a larger size than
3373:	EBF8  23      		INC	HL		;this extent does.
3374:	EBF9  78      		LD	A,B
3375:	EBFA  9E      		SBC	A,(HL)
3376:	EBFB  23      		INC	HL
3377:	EBFC  7B      		LD	A,E
3378:	EBFD  9E      		SBC	A,(HL)
3379:	EBFE  DA06EC  		JP	C,RANSIZ2
3380:	EC01  73      		LD	(HL),E		;we found a larger (in size) extent.
3381:	EC02  2B      		DEC	HL		;stuff these values into fcb.
3382:	EC03  70      		LD	(HL),B
3383:	EC04  2B      		DEC	HL
3384:	EC05  71      		LD	(HL),C
3385:	EC06  CD2DE7  	RANSIZ2:CALL	FINDNXT		;now get the next extent.
3386:	EC09  C3E4EB  		JP	RANSIZ1		;continue til all done.
3387:	EC0C  E1      	RANSIZ3:POP	HL		;we are done, restore the stack and
3388:	EC0D  C9      		RET			;return.
3389:			;
3390:			;   Function to return the random record position of a given
3391:			; file which has been read in sequential mode up to now.
3392:			;
3393:	EC0E  2A43E3  	SETRAN:	LD	HL,(PARAMS)	;point to fcb.
3394:	EC11  112000  		LD	DE,32		;and to last used record.
3395:	EC14  CDA5EB  		CALL	COMPRAND	;compute random position.
3396:	EC17  212100  		LD	HL,33		;now stuff these values into fcb.
3397:	EC1A  19      		ADD	HL,DE
3398:	EC1B  71      		LD	(HL),C		;move 'r0'.
3399:	EC1C  23      		INC	HL
3400:	EC1D  70      		LD	(HL),B		;and 'r1'.
3401:	EC1E  23      		INC	HL
3402:	EC1F  77      		LD	(HL),A		;and lastly 'r2'.
3403:	EC20  C9      		RET
3404:			;
3405:			;   This routine select the drive specified in (ACTIVE) and
3406:			; update the login vector and bitmap table if this drive was
3407:			; not already active.
3408:			;
3409:	EC21  2AAFED  	LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
3410:	EC24  3A42E3  		LD	A,(ACTIVE)	;get the default drive.
3411:	EC27  4F      		LD	C,A
3412:	EC28  CDEAE4  		CALL	SHIFTR		;position active bit for this drive
3413:	EC2B  E5      		PUSH	HL		;into bit 0.
3414:	EC2C  EB      		EX	DE,HL
3415:	EC2D  CD59E3  		CALL	SELECT		;select this drive.
3416:	EC30  E1      		POP	HL
3417:	EC31  CC47E3  		CALL	Z,SLCTERR	;valid drive?
3418:	EC34  7D      		LD	A,L		;is this a newly activated drive?
3419:	EC35  1F      		RRA
3420:	EC36  D8      		RET	C
3421:	EC37  2AAFED  		LD	HL,(LOGIN)	;yes, update the login vector.
3422:	EC3A  4D      		LD	C,L
3423:	EC3B  44      		LD	B,H
3424:	EC3C  CD0BE5  		CALL	SETBIT
3425:	EC3F  22AFED  		LD	(LOGIN),HL	;and save.
3426:	EC42  C3A3E6  		JP	BITMAP		;now update the bitmap.
3427:			;
3428:			;   Function to set the active disk number.
3429:			;
3430:	EC45  3AD6ED  	SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
3431:	EC48  2142E3  		LD	HL,ACTIVE	;represents a change in drives.
3432:	EC4B  BE      		CP	(HL)
3433:	EC4C  C8      		RET	Z
3434:	EC4D  77      		LD	(HL),A		;yes it does, log it in.
3435:	EC4E  C321EC  		JP	LOGINDRV
3436:			;
3437:			;   This is the 'auto disk select' routine. The firsst byte
3438:			; of the fcb is examined for a drive specification. If non
3439:			; zero then the drive will be selected and loged in.
3440:			;
3441:	EC51  3EFF    	AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
3442:	EC53  32DEED  		LD	(AUTO),A
3443:	EC56  2A43E3  		LD	HL,(PARAMS)	;get drive specified.
3444:	EC59  7E      		LD	A,(HL)
3445:	EC5A  E61F    		AND	1FH		;look at lower 5 bits.
3446:	EC5C  3D      		DEC	A		;adjust for (1=A, 2=B) etc.
3447:	EC5D  32D6ED  		LD	(EPARAM),A	;and save for the select routine.
3448:	EC60  FE1E    		CP	1EH		;check for 'no change' condition.
3449:	EC62  D275EC  		JP	NC,AUTOSL1	;yes, don't change.
3450:	EC65  3A42E3  		LD	A,(ACTIVE)	;we must change, save currently active
3451:	EC68  32DFED  		LD	(OLDDRV),A	;drive.
3452:	EC6B  7E      		LD	A,(HL)		;and save first byte of fcb also.
3453:	EC6C  32E0ED  		LD	(AUTOFLAG),A	;this must be non-zero.
3454:	EC6F  E6E0    		AND	0E0H		;whats this for (bits 6,7 are used for
3455:	EC71  77      		LD	(HL),A		;something)?
3456:	EC72  CD45EC  		CALL	SETDSK		;select and log in this drive.
3457:	EC75  3A41E3  	AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
3458:	EC78  2A43E3  		LD	HL,(PARAMS)	;(* upper half of first byte *)
3459:	EC7B  B6      		OR	(HL)
3460:	EC7C  77      		LD	(HL),A
3461:	EC7D  C9      		RET			;and return (all done).
3462:			;
3463:			;   Function to return the current cp/m version number.
3464:			;
3465:	EC7E  3E22    	GETVER:	LD	A,022H		;version 2.2
3466:	EC80  C301E3  		JP	SETSTAT
3467:			;
3468:			;   Function to reset the disk system.
3469:			;
3470:	EC83  210000  	RSTDSK:	LD	HL,0		;clear write protect status and log
3471:	EC86  22ADED  		LD	(WRTPRT),HL	;in vector.
3472:	EC89  22AFED  		LD	(LOGIN),HL
3473:	EC8C  AF      		XOR	A		;select drive 'A'.
3474:	EC8D  3242E3  		LD	(ACTIVE),A
3475:	EC90  218000  		LD	HL,TBUFF	;setup default dma address.
3476:	EC93  22B1ED  		LD	(USERDMA),HL
3477:	EC96  CDDAE5  		CALL	DEFDMA
3478:	EC99  C321EC  		JP	LOGINDRV	;now log in drive 'A'.
3479:			;
3480:			;   Function to open a specified file.
3481:			;
3482:	EC9C  CD72E5  	OPENFIL:CALL	CLEARS2		;clear 's2' byte.
3483:	EC9F  CD51EC  		CALL	AUTOSEL		;select proper disk.
3484:	ECA2  C351E8  		JP	OPENIT		;and open the file.
3485:			;
3486:			;   Function to close a specified file.
3487:			;
3488:	ECA5  CD51EC  	CLOSEFIL: CALL	AUTOSEL		;select proper disk.
3489:	ECA8  C3A2E8  		JP	CLOSEIT		;and close the file.
3490:			;
3491:			;   Function to return the first occurence of a specified file
3492:			; name. If the first byte of the fcb is '?' then the name will
3493:			; not be checked (get the first entry no matter what).
3494:			;
3495:	ECAB  0E00    	GETFST:	LD	C,0		;prepare for special search.
3496:	ECAD  EB      		EX	DE,HL
3497:	ECAE  7E      		LD	A,(HL)		;is first byte a '?'?
3498:	ECAF  FE3F    		CP	'?'
3499:	ECB1  CAC2EC  		JP	Z,GETFST1	;yes, just get very first entry (zero length match).
3500:	ECB4  CDA6E4  		CALL	SETEXT		;get the extension byte from fcb.
3501:	ECB7  7E      		LD	A,(HL)		;is it '?'? if yes, then we want
3502:	ECB8  FE3F    		CP	'?'		;an entry with a specific 's2' byte.
3503:	ECBA  C472E5  		CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
3504:	ECBD  CD51EC  		CALL	AUTOSEL		;select proper drive.
3505:	ECC0  0E0F    		LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
3506:	ECC2  CD18E7  	GETFST1:CALL	FINDFST		;find an entry and then move it into
3507:	ECC5  C3E9E5  		JP	MOVEDIR		;the users dma space.
3508:			;
3509:			;   Function to return the next occurence of a file name.
3510:			;
3511:	ECC8  2AD9ED  	GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
3512:	ECCB  2243E3  		LD	(PARAMS),HL	;other dbos calls are allowed.
3513:	ECCE  CD51EC  		CALL	AUTOSEL		;no error will be returned, but the
3514:	ECD1  CD2DE7  		CALL	FINDNXT		;results will be wrong.
3515:	ECD4  C3E9E5  		JP	MOVEDIR
3516:			;
3517:			;   Function to delete a file by name.
3518:			;
3519:	ECD7  CD51EC  	DELFILE:CALL	AUTOSEL		;select proper drive.
3520:	ECDA  CD9CE7  		CALL	ERAFILE		;erase the file.
3521:	ECDD  C301E7  		JP	STSTATUS	;set status and return.
3522:			;
3523:			;   Function to execute a sequential read of the specified
3524:			; record number.
3525:			;
3526:	ECE0  CD51EC  	READSEQ:CALL	AUTOSEL		;select proper drive then read.
3527:	ECE3  C3BCE9  		JP	RDSEQ
3528:			;
3529:			;   Function to write the net sequential record.
3530:			;
3531:	ECE6  CD51EC  	WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
3532:	ECE9  C3FEE9  		JP	WTSEQ
3533:			;
3534:			;   Create a file function.
3535:			;
3536:	ECEC  CD72E5  	FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
3537:	ECEF  CD51EC  		CALL	AUTOSEL		;select proper drive and get the next
3538:	ECF2  C324E9  		JP	GETEMPTY	;empty directory space.
3539:			;
3540:			;   Function to rename a file.
3541:			;
3542:	ECF5  CD51EC  	RENFILE:CALL	AUTOSEL		;select proper drive and then switch
3543:	ECF8  CD16E8  		CALL	CHGNAMES	;file names.
3544:	ECFB  C301E7  		JP	STSTATUS
3545:			;
3546:			;   Function to return the login vector.
3547:			;
3548:	ECFE  2AAFED  	GETLOG:	LD	HL,(LOGIN)
3549:	ED01  C329ED  		JP	GETPRM1
3550:			;
3551:			;   Function to return the current disk assignment.
3552:			;
3553:	ED04  3A42E3  	GETCRNT:LD	A,(ACTIVE)
3554:	ED07  C301E3  		JP	SETSTAT
3555:			;
3556:			;   Function to set the dma address.
3557:			;
3558:	ED0A  EB      	PUTDMA:	EX	DE,HL
3559:	ED0B  22B1ED  		LD	(USERDMA),HL	;save in our space and then get to
3560:	ED0E  C3DAE5  		JP	DEFDMA		;the bios with this also.
3561:			;
3562:			;   Function to return the allocation vector.
3563:			;
3564:	ED11  2ABFED  	GETALOC:LD	HL,(ALOCVECT)
3565:	ED14  C329ED  		JP	GETPRM1
3566:			;
3567:			;   Function to return the read-only status vector.
3568:			;
3569:	ED17  2AADED  	GETROV:	LD	HL,(WRTPRT)
3570:	ED1A  C329ED  		JP	GETPRM1
3571:			;
3572:			;   Function to set the file attributes (read-only, system).
3573:			;
3574:	ED1D  CD51EC  	SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
3575:	ED20  CD3BE8  		CALL	SAVEATTR
3576:	ED23  C301E7  		JP	STSTATUS
3577:			;
3578:			;   Function to return the address of the disk parameter block
3579:			; for the current drive.
3580:			;
3581:	ED26  2ABBED  	GETPARM:LD	HL,(DISKPB)
3582:	ED29  2245E3  	GETPRM1:LD	(STATUS),HL
3583:	ED2C  C9      		RET
3584:			;
3585:			;   Function to get or set the user number. If (E) was (FF)
3586:			; then this is a request to return the current user number.
3587:			; Else set the user number from (E).
3588:			;
3589:	ED2D  3AD6ED  	GETUSER:LD	A,(EPARAM)	;get parameter.
3590:	ED30  FEFF    		CP	0FFH		;get user number?
3591:	ED32  C23BED  		JP	NZ,SETUSER
3592:	ED35  3A41E3  		LD	A,(USERNO)	;yes, just do it.
3593:	ED38  C301E3  		JP	SETSTAT
3594:	ED3B  E61F    	SETUSER:AND	1FH		;no, we should set it instead. keep low
3595:	ED3D  3241E3  		LD	(USERNO),A	;bits (0-4) only.
3596:	ED40  C9      		RET
3597:			;
3598:			;   Function to read a random record from a file.
3599:			;
3600:	ED41  CD51EC  	RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
3601:	ED44  C393EB  		JP	READRAN
3602:			;
3603:			;   Function to compute the file size for random files.
3604:			;
3605:	ED47  CD51EC  	WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
3606:	ED4A  C39CEB  		JP	WRITERAN
3607:			;
3608:			;   Function to compute the size of a random file.
3609:			;
3610:	ED4D  CD51EC  	FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
3611:	ED50  C3D2EB  		JP	RANSIZE
3612:			;
3613:			;   Function #37. This allows a program to log off any drives.
3614:			; On entry, set (DE) to contain a word with bits set for those
3615:			; drives that are to be logged off. The log-in vector and the
3616:			; write protect vector will be updated. This must be a M/PM
3617:			; special function.
3618:			;
3619:	ED53  2A43E3  	LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
3620:	ED56  7D      		LD	A,L		;for each bit that is set, we want
3621:	ED57  2F      		CPL			;to clear that bit in (LOGIN)
3622:	ED58  5F      		LD	E,A		;and (WRTPRT).
3623:	ED59  7C      		LD	A,H
3624:	ED5A  2F      		CPL
3625:	ED5B  2AAFED  		LD	HL,(LOGIN)	;reset the login vector.
3626:	ED5E  A4      		AND	H
3627:	ED5F  57      		LD	D,A
3628:	ED60  7D      		LD	A,L
3629:	ED61  A3      		AND	E
3630:	ED62  5F      		LD	E,A
3631:	ED63  2AADED  		LD	HL,(WRTPRT)
3632:	ED66  EB      		EX	DE,HL
3633:	ED67  22AFED  		LD	(LOGIN),HL	;and save.
3634:	ED6A  7D      		LD	A,L		;now do the write protect vector.
3635:	ED6B  A3      		AND	E
3636:	ED6C  6F      		LD	L,A
3637:	ED6D  7C      		LD	A,H
3638:	ED6E  A2      		AND	D
3639:	ED6F  67      		LD	H,A
3640:	ED70  22ADED  		LD	(WRTPRT),HL	;and save. all done.
3641:	ED73  C9      		RET
3642:			;
3643:			;   Get here to return to the user.
3644:			;
3645:	ED74  3ADEED  	GOBACK:	LD	A,(AUTO)	;was auto select activated?
3646:	ED77  B7      		OR	A
3647:	ED78  CA91ED  		JP	Z,GOBACK1
3648:	ED7B  2A43E3  		LD	HL,(PARAMS)	;yes, but was a change made?
3649:	ED7E  3600    		LD	(HL),0		;(* reset first byte of fcb *)
3650:	ED80  3AE0ED  		LD	A,(AUTOFLAG)
3651:	ED83  B7      		OR	A
3652:	ED84  CA91ED  		JP	Z,GOBACK1
3653:	ED87  77      		LD	(HL),A		;yes, reset first byte properly.
3654:	ED88  3ADFED  		LD	A,(OLDDRV)	;and get the old drive and select it.
3655:	ED8B  32D6ED  		LD	(EPARAM),A
3656:	ED8E  CD45EC  		CALL	SETDSK
3657:	ED91  2A0FE3  	GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
3658:	ED94  F9      		LD	SP,HL
3659:	ED95  2A45E3  		LD	HL,(STATUS)	;get return status.
3660:	ED98  7D      		LD	A,L		;force version 1.4 compatability.
3661:	ED99  44      		LD	B,H
3662:	ED9A  C9      		RET			;and go back to user.
3663:			;
3664:			;   Function #40. This is a special entry to do random i/o.
3665:			; For the case where we are writing to unused disk space, this
3666:			; space will be zeroed out first. This must be a M/PM special
3667:			; purpose function, because why would any normal program even
3668:			; care about the previous contents of a sector about to be
3669:			; written over.
3670:			;
3671:	ED9B  CD51EC  	WTSPECL:CALL	AUTOSEL		;select proper drive.
3672:	ED9E  3E02    		LD	A,2		;use special write mode.
3673:	EDA0  32D5ED  		LD	(MODE),A
3674:	EDA3  0E00    		LD	C,0		;set write indicator.
3675:	EDA5  CD07EB  		CALL	POSITN1		;position the file.
3676:	EDA8  CC03EA  		CALL	Z,WTSEQ1	;and write (if no errors).
3677:	EDAB  C9      		RET
3678:			;
3679:			;**************************************************************
3680:			;*
3681:			;*     BDOS data storage pool.
3682:			;*
3683:			;**************************************************************
3684:			;
3685:	EDAC  E5      	EMPTYFCB: DEFB	0E5H		;empty directory segment indicator.
3686:	EDAD  0000    	WRTPRT:	DEFW	0		;write protect status for all 16 drives.
3687:	EDAF  0000    	LOGIN:	DEFW	0		;drive active word (1 bit per drive).
3688:	EDB1  8000    	USERDMA:DEFW	080H		;user's dma address (defaults to 80h).
3689:			;
3690:			;   Scratch areas from parameter block.
3691:			;
3692:	EDB3  0000    	SCRATCH1: DEFW	0		;relative position within dir segment for file (0-3).
3693:	EDB5  0000    	SCRATCH2: DEFW	0		;last selected track number.
3694:	EDB7  0000    	SCRATCH3: DEFW	0		;last selected sector number.
3695:			;
3696:			;   Disk storage areas from parameter block.
3697:			;
3698:	EDB9  0000    	DIRBUF:	DEFW	0		;address of directory buffer to use.
3699:	EDBB  0000    	DISKPB:	DEFW	0		;contains address of disk parameter block.
3700:	EDBD  0000    	CHKVECT:DEFW	0		;address of check vector.
3701:	EDBF  0000    	ALOCVECT: DEFW	0		;address of allocation vector (bit map).
3702:			;
3703:			;   Parameter block returned from the bios.
3704:			;
3705:	EDC1  0000    	SECTORS:DEFW	0		;sectors per track from bios.
3706:	EDC3  00      	BLKSHFT:DEFB	0		;block shift.
3707:	EDC4  00      	BLKMASK:DEFB	0		;block mask.
3708:	EDC5  00      	EXTMASK:DEFB	0		;extent mask.
3709:	EDC6  0000    	DSKSIZE:DEFW	0		;disk size from bios (number of blocks-1).
3710:	EDC8  0000    	DIRSIZE:DEFW	0		;directory size.
3711:	EDCA  0000    	ALLOC0:	DEFW	0		;storage for first bytes of bit map (dir space used).
3712:	EDCC  0000    	ALLOC1:	DEFW	0
3713:	EDCE  0000    	OFFSET:	DEFW	0		;first usable track number.
3714:	EDD0  0000    	XLATE:	DEFW	0		;sector translation table address.
3715:			;
3716:			;
3717:	EDD2  00      	CLOSEFLG: DEFB	0		;close flag (=0ffh is extent written ok).
3718:	EDD3  00      	RDWRTFLG: DEFB	0		;read/write flag (0ffh=read, 0=write).
3719:	EDD4  00      	FNDSTAT:DEFB	0		;filename found status (0=found first entry).
3720:	EDD5  00      	MODE:	DEFB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
3721:	EDD6  00      	EPARAM:	DEFB	0		;storage for register (E) on entry to bdos.
3722:	EDD7  00      	RELBLOCK: DEFB	0		;relative position within fcb of block number written.
3723:	EDD8  00      	COUNTER:DEFB	0		;byte counter for directory name searches.
3724:	EDD9  00000000	SAVEFCB:DEFW	0,0		;save space for address of fcb (for directory searches).
3725:	EDDD  00      	BIGDISK:DEFB	0		;if =0 then disk is > 256 blocks long.
3726:	EDDE  00      	AUTO:	DEFB	0		;if non-zero, then auto select activated.
3727:	EDDF  00      	OLDDRV:	DEFB	0		;on auto select, storage for previous drive.
3728:	EDE0  00      	AUTOFLAG: DEFB	0		;if non-zero, then auto select changed drives.
3729:	EDE1  00      	SAVNXT:	DEFB	0		;storage for next record number to access.
3730:	EDE2  00      	SAVEXT:	DEFB	0		;storage for extent number of file.
3731:	EDE3  0000    	SAVNREC:DEFW	0		;storage for number of records in file.
3732:	EDE5  0000    	BLKNMBR:DEFW	0		;block number (physical sector) used within a file or logical sect
3733:	EDE7  0000    	LOGSECT:DEFW	0		;starting logical (128 byte) sector of block (physical sector).
3734:	EDE9  00      	FCBPOS:	DEFB	0		;relative position within buffer for fcb of file of interest.
3735:	EDEA  0000    	FILEPOS:DEFW	0		;files position within directory (0 to max entries -1).
3736:			;
3737:			;   Disk directory buffer checksum bytes. One for each of the
3738:			; 16 possible drives.
3739:			;
3740:	EDEC  00000000	CKSUMTBL: DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	      00000000
	      00000000
	      00000000
3741:			;
3742:			;   Extra space ?
3743:			;
3744:	EDFC  00000000		DEFB	0,0,0,0
3745:			;
3746:	1600          		.dephase
3747:			;
3748:			;*
3749:			;******************   E N D   O F   C P / M   *****************
3750:			;*
3751:			



Statistics:

     4	passes
     0	jr promotions
   509	symbols
     0	bytes



Symbol Table:

active          e342     fbase           e006+    rdbuf4          e226     
adda2hl         e564     fbase1          e011     rdbuf5          e237     
addhl           da59     fcb             dfcd     rdbuf6          e248     
alloc0          edca     fcb2hl          e55e     rdbuf7          e24e     
alloc1          edcc     fcbpos          ede9     rdbuf8          e25f     
alocvect        edbf     fcbset          e7fd     rdbuf9          e26b     
auto            edde     fcreate         ecec     rdbuff          e1e1     
autoflag        ede0     ff             =   c+    rderr           dbdf     
autosel         ec51     filepos         edea     rderror         dbd9     
autosl1         ec75     filero          e0dc     rdrandom        ed41     
backup          e1a4     filesize        ed4d     rdrec           d8f9     
backup1         e1ac     findfst         e718     rdseq           e9bc     
badload         df7a     findnxt         e72d     rdseq1          e9c1     
badsctr         e009     fndnxt1         e74a     rdseq2          e9e6     
badsec          e0ca     fndnxt2         e753     rdseq3          e9fb     
badsel          e0d5     fndnxt3         e773     rdwrtflg        edd3     
badslct         e00b     fndnxt4         e77c     read           =ee27+    
batch           dfab     fndnxt5         e783     reader         =ee15+    
batchfcb        dfac     fndnxt6         e794     readfcb         d8fe     
bdos           =e006+    fndspa1         e7c0     readran         eb93     
bdosdrv         e0c6     fndspa2         e7d1     readseq         ece0     
bdose          =e000+    fndspa3         e7ec     relblock        edd7     
bdoserr         e0ba     fndspa4         e7f4     renam           d90e     
bias           =a400+    fndspace        e7be     rename          de10     
bigdisk         eddd     fndstat         edd4     rename1         de3f     
bios           =ee00+    functns         e047     rename2         de59     
bitmap          e6a3     getaloc         ed11     rename3         de5e+    
bitmap1         e6b1     getback         df86     rename4         de6d     
bitmap2         e6d2     getback1        df89     rename5         de73     
bitmap3         e6f6     getblk1         e445     rename6         de79     
blkmask         edc4     getblk2         e453     renfile         ecf5     
blknmbr         ede5     getblk3         e45c     resdsk          d8b8     
blkshft         edc3     getblock        e43e     resetdr         dc66     
boot           =ee00+    getchar         e0fb     rodisk          e00d     
bs             =   8+    getcon          e2c8     rofile          e00f     
cbase           d800     getcrnt         ed04     rstdsk          ec83     
ccp            =d800+    getcsts         e2fe     rtn             e304     
ccpstack       =dfab+    getdsk          d9d0     rtncode         dfee     
cdrive          dfef     getecho         e106     samext          e707     
charbuf         e30e     getempty        e924     savatr1         e840     
check           da30     getext          dac0     save            ddad     
checkdir        e59e     getext1         dac8     save1           ddd4     
checksum        e4f7     getext2         dad9     save2           ddf1     
chgdrv          dff0     getext3         dadb     save3           ddfb     
chgnam1         e827     getext4         dadf     save4           de01     
chgnames        e816     getext5         dae9     saveattr        e83b     
chkblk          e484     getext6         daf0     savefcb         edd9     
chkchar         e114     getext7         daf2     savext          ede2     
chkcon          d9c2     getext8         db01     savnrec         ede3     
chkdir1         e5c4     getext9         db09     savnxt          ede1     
chknmbr         e58c     getfst          ecab     scratch1        edb3     
chkrofl         e544     getfst1         ecc2     scratch2        edb5     
chksum1         e4fd     getinp          d939     scratch3        edb7     
chkvect         edbd     getinp1         d996     search          db2e     
chkwprt         e554     getinp2         d9a7     search1         db33     
ckbitmap        e635     getinp3         d9ab     search2         db3c     
ckbmap1         e656     getinp4         d9ba     search3         db4f     
ckcon1          e142     getiob          e2ed     search4         db54     
ckcon2          e145     getlog          ecfe     sectors         edc1     
ckconsol        e123     getmt1          e946     sectran        =ee30+    
ckfilpos        e5f5     getnext         e95a     seldsk         =ee1b+    
ckrof1          e547     getnxt          ecc8     select          e359     
cksumtbl        edec     getparm         ed26     select1         e39d     
clearbuf        db58     getprm1         ed29     setattr         ed1d     
clears2         e572     getrdr          e2ce     setbit          e50b     
close           d8da     getrov          ed17     setcdrv         d91a     
closefil        eca5     gets2           e569     setdir          e59c     
closeflg        edd2     getsetuc        d915     setdma         =ee24+    
closeit         e8a2     getuser         ed2d     setdsk          ec45     
closeit1        e8cd     getusr          d913     setext          e4a6     
closeit2        e8db     getver          ec7e     setfile         e66b     
closeit3        e8e1     getwprt         e51e     setfl1          e675     
closeit4        e8e8     goback          ed74     setfl2          e688     
closeit5        e8fd     goback1         ed91     setfl3          e68e     
closeit6        e917     gtnext1         e983     setfl4          e69d     
closeit7        e91f     gtnext2         e98e     sethlde         e4ae     
cmdadr          dbc1     gtnext3         e9ac     setiob          e2f3     
cmdtbl          db10     gtnext4         e9af     setnrec         e4d2     
cmmnd1          db82     gtnext5         e9b6     setran          ec0e     
cmmnd2          db98     hl2de           dc42     sets2b7         e578     
cmsize         =  3d+    home           =ee18+    setsec         =ee21+    
cntrlc         =   3+    homedrv         e3a1     setstat         e301     
cntrle         =   5+    inbuff          d806     settrk         =ee1e+    
cntrlp         =  10+    inpoint         d888     setuser         ed3b     
cntrlr         =  12+    iobyte         =   3+    shiftl          e504     
cntrls         =  13+    ioerr1          e305     shiftl1         e505     
cntrlu         =  15+    ioret           e3bb     shiftr          e4ea     
cntrlx         =  18+    ipl            =1000+    shiftr1         e4eb     
cntrlz         =  1a+    jumphl          e34a     showit          e17f     
comblk          e477     lf             =   a+    slcterr         e347     
comfile         df83     listd          =ee0f+    srchfcb         d8e9     
command         db5c     logical         e48a     srchfst         d8df     
comprand        eba5     logicl1         e490     srchnxt         d8e4     
conin          =ee09+    login           edaf     starting        e30b     
conout         =ee0c+    logindrv        ec21     status          e345     
const          =ee06+    logoff          ed53     stbitmap        e65c     
convert         da60     logsect         ede7     stbmap1         e664     
convfst         da5e     mem            =  3d+    stddma          d9d5     
convrt1         da89     mode            edd5     stfilpos        e5fe     
convrt2         da90     morefls         e57f     stkarea        =e341+    
convrt3         da96     move3           dc40     stnrec1         e4de     
convrt4         da98     movecd          d929     strdata         e4bb     
convrt5         daa9     movedir         e5e9     ststatus        e701     
convrt6         daab     moveword        e894     subhl           e595     
convrt7         daaf     mres           =   1+    synerr          da09     
convrt8         dab9     msize          =  3e+    synerr1         da0f     
counter         edd8     namepnt         d88a     synerr2         da22     
cr             =   d+    nbytes          dff1     syshalt         dbcf     
create          d909     newline         e1b1     tab            =   9+    
crlf            d898     newln1          e1b9     tbase          = 100+    
curpos          e30c     nfuncts        =  29+    tbuff          =  80+    
de2hl           e34f     nofile          dbf0     tdrive         =   4+    
de2hl1          e350     nonblank        da4f     tfcb           =  5c+    
decode          dbf8     none            dbea     trksec          e3c3     
decode1         dc08     nospace         de07     trksec1         e3d1     
decode2         dc2a+    numcmds        =   6+    trksec2         e3e4     
decode3         dc33     nxent1          e619     trksec3         e3fa     
decode4         dc3a+    nxent2          e620     trksec4         e40f     
defdma          e5da     nxentry         e605     type            dd5d     
del            =  7f+    offset          edce     type1           dd74     
delbatch        d9dd     olddrv          eddf     type2           dd77+    
delete          d8ef     open            d8cb     type3           dd87     
delfile         ecd7     openfcb         d8d0     type4           dda0     
dirbuf          edb9     openfil         ec9c     type5           dda7     
dirc1           e2e0     openit          e851     unknown         dea5     
dircio          e2d4     openit1         e85a     unkwn0          df71     
dirdma          e5e0     openit2         e88b     unkwn1          dec4     
dirdma1         e5e3     outchar         e148     unkwn2          decd+    
direct          dc77     outchr1         e162     unkwn3          dee1     
direct1         dc88     outchr2         e179     unkwn4          df01     
direct2         dc8f     outcon          e190     unkwn5          df30     
direct3         dc98     outcon1         e196     unkwn6          df3e     
direct4         dccc     outcrlf         e1c9     unkwn7          df43     
direct5         dcd4     outflag         e30a     unkwn8          df4f     
direct6         dcd9     params          e343     unkwn9          df6b     
direct7         dd0e     pattrn1         db28     update          e801     
direct8         dd0f     pattrn2         e000     update1         e810     
direct9         dd1b     pline           d8a7     upper           d930     
dirread         e5d4     pline2          d8ac     user            de8e     
dirsize         edc8     position        eb03     userdma         edb1     
dirwrite        e5c6     positn1         eb07     userno          e341     
diskpb          edbb     positn2         eb47     usrstack        e30f     
diskro          e0e1     positn3         eb7f     verify          d9f5     
dmaset          d9d8     positn4         eb84     verify1         d9fd     
doread          e3b2     positn5         eb8b     wboot          =ee03+    
dowrite         e3b8     print           d88c     write          =ee2a+    
drect63         dcf7     printb          d892     writeran        eb9c     
drect65         dcf9     prstat         =ee2d+    wrtprt          edad     
dselect         dc54     prterr          e0e5     wrtprtd         e52c     
dsksel          d8bd     prtflag         e30d     wrtrec          d904     
dsksize         edc6     prtmesg         e1d3     wrtseq          ece6     
emptyfcb        edac     prtstr          e2f8     wtrandom        ed47     
entry1          d8c3     pspace          d8a2     wtseq           e9fe     
entry2          d8f4     punch          =ee12+    wtseq1          ea03     
entryp         =   5+    putdma          ed0a     wtseq10         ead2     
eparam          edd6     ransiz1         ebe4     wtseq11         eafe     
erafil1         e7a4     ransiz2         ec06     wtseq12         eb00     
erafile         e79c     ransiz3         ec0c     wtseq2          ea3b     
erase           dd1f     ransize         ebd2     wtseq3          ea48     
erase1          dd42     rdbuf1          e1ef     wtseq4          ea64     
error1          e099     rdbuf10         e270     wtseq5          ea6c     
error2          e0a5     rdbuf11         e278     wtseq6          ea6e     
error3          e0ab     rdbuf12         e28a     wtseq7          ea8c     
error4          e0b1     rdbuf13         e299     wtseq8          ea9a     
error5          e0b4     rdbuf14         e2a6     wtseq9          eabb     
exists          de82     rdbuf15         e2a9     wtseq99         eadf+    
extblk          e45e     rdbuf16         e2bd     wtspecl         ed9b     
extblk1         e471     rdbuf17         e2c1     xlate           edd0     
extmask         edc5     rdbuf2          e1f1     yesno           dd52     
extract         dc4b     rdbuf3          e216     
