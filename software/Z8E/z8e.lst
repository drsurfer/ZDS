   1:			;		************************************************
   2:			;		*   *** 18E - Z80/HD64180 DEBUG MONITOR ***    *
   3:			;		*  (c) Copyright 1984  by Richard A. Surwilo   *
   4:			;		*  (c) Copyright 1988  by Damon R. Gibson      *
   5:			;		************************************************
   6:			
   7:				title	*   *** 18E - Z80/HD64180 Debug Monitor ***    *
   8:			; 	subttl	(C) 1984, 1985 by R. A. Surwilo, (C) 1988 by D. R. Gibson
   9:			
  10:			;------------------------------------------------------------------------------
  11:			;
  12:			;  Copyright (C) 1984, 1985   by Richard A. Surwilo.  All rights reserved.
  13:			;
  14:			;  No part of this publication may be reproduced, transmitted, transcribed,
  15:			;  stored in a retrieval system, or translated into any language or computer
  16:			;  language in any form or by any means, electronic, mechanical, magnetic,
  17:			;  optical, chemical, manual or otherwise, without express prior written
  18:			;  permission of:
  19:			;
  20:			;      Richard  A. Surwilo  330 Calvin Court, Wyckoff, NJ 074816
  21:			;
  22:			;  Note:
  23:			;	    This program is distributed in violation of the restrictions
  24:			;	    on reproduction and transmission outlined above.  It would
  25:			;	    appear that Rick Surwilo released this program to the public
  26:			;	    domain without removing the notice.
  27:			;
  28:			;------------------------------------------------------------------------------
  29:			;
  30:			;                       Revision history
  31:			;
  32:			;  19 Dec 00 hp  v3.6	Added HD64180 support from Damon R. Gibson's
  33:			;			18E V1.0, together with the auxiliary terminal
  34:			;			support. Set the H64180 variable below to TRUE
  35:			;			to generate a 18E debugger or FALSE to generate
  36:			;			a standard Z8E.
  37:			;
  38:			;  27 Dec 88 jrs v3.5	Released 24 Jan 89.  Includes a few patches by
  39:			;			George Havach.
  40:			;
  41:			;		1.	Changed operation of <cr> in some commands to make
  42:			;			a more consistent user interface.  (I won't be
  43:			;			offended if users want it changed back - jrs.)
  44:			;
  45:			;		2.	Enhancement to patch 1.5:- altered the search for
  46:			;			"MACRO-80" sentinel in .PRN files to allow for a
  47:			;			TITLE pseudo-op.
  48:			;
  49:			;		3.	Shortened and improved the code for the 'I' command.
  50:			;
  51:			;		4.	Tested and corrected the ANSIXYCP module which I have
  52:			;			been supplying since May 1987.  The code has now been
  53:			;			incorporated into the main source file and can be
  54:			;			activated during assembly by setting "aterm equ true".
  55:			;
  56:			;		5.	Discarded the '#' command introduced in 3.3.11 as with
  57:			;			a minor adjustment the 'L' command with no file name
  58:			;			does the same thing.
  59:			;
  60:			;		6.	If S or J was last command issued then <cr> alone
  61:			;			repeats S or J in single-step mode.  Very useful for
  62:			;			stepping through a small section of a program.
  63:			;
  64:			;	(gah)	7.	Adapted a patch by George Havach to correct the display
  65:			;			of IX and IY in disassembled instructions when upper
  66:			;			case is set.
  67:			;
  68:			;	(gah)	8.	Made room for patching in 'clear screen' code at
  69:			;			MBANNR: for more dignified start-up.
  70:			;
  71:			;	(gah)	9.	Replaced tilde ("~") with period (".") as a general
  72:			;			substitute for non-displayable ASCII characters, for
  73:			;			consistency with practically every other screen-dump
  74:			;			utility.  [Retained "hazeltine" conditional - jrs]
  75:			;
  76:			;  12 Dec 88 jrs v3.4	Made patch 3.3.1 object-configurable because some
  77:			;			terminals, particularly those which have binary
  78:			;			cursor addressing, must use an offset of 80h to stop
  79:			;			the BDOS from expanding tabs and for those terminals
  80:			;			clearing bit 7 is nasty.
  81:			;
  82:			;   5 Dec 88 eg  v3.3	Included a number of fixes and features submitted by
  83:			;  (installed by jrs)	Eric Gans in January and March 88.
  84:			;
  85:			;		 1.	Clear bit 7 of characters sent to screen to avoid
  86:			;			strange effects on some computers (such as Kaypro
  87:			;			which prints graphic characters if bit 7 is on).
  88:			;
  89:			;		 2.	Allow 'z' command without an address to mean dis-
  90:			;			assemble from last instruction for last-specified
  91:			;			number of lines.
  92:			;
  93:			;		 3.	Allow 'g' command without an address to mean the
  94:			;			equivalent of 'g  pc'  or  'g  $' (i.e. continue
  95:			;			execution from current instruction).
  96:			;
  97:			;		 4.	Show absolute destination addresses when dis-
  98:			;			assembling relative jump instructions (jr and djnz).
  99:			;
 100:			;		 5.	Display flags along with registers when using the
 101:			;			's' and 'x' commands.
 102:			;
 103:			;		 6.	Allow easy refresh of the 'animated debug' screen
 104:			;			after program output has disturbed it.  Use 'j  #'
 105:			;			to force refresh.
 106:			;
 107:			;		 7.	After Z8E's internal disk I/O operations, reset
 108:			;			DMA to 80h for the benefit of target programs.
 109:			;
 110:			;		 8.	Allow cancellation of commands with CAN (ctrl-X)
 111:			;			when argument buffer is empty.  For example if you
 112:			;			have entered 'd  100' then first ^X erases the '100'
 113:			;			and the second cancels the 'd'.
 114:			;
 115:			;		 9.	Implement '>' command to change user number and so
 116:			;			allow loading of files from user areas other than
 117:			;			that from which Z8E was initiated.
 118:			;
 119:			;		10.	Implement '?' command to evaluate and display argument
 120:			;			expressions.  Accepts a register name as the first
 121:			;			operand.  (reg) allows indirect addressing so that,
 122:			;			for example, '?  (hl)' displays value at the memory
 123:			;			location whose address is contained in HL.
 124:			;
 125:			;		11.	Implement '#' command to recall and display the
 126:			;			highest address occupied by a program.
 127:			;
 128:			;   4 Dec 88 jrs v3.2	Expand asterisks in file names when using 'i' command.
 129:			;
 130:			;  27 Nov 88 jrs v3.1	Bug fix - deleted three spurious instructions from
 131:			;			the initialisation code which was added to support
 132:			;			breakpoint vectors at addresses other than 38h.
 133:			;
 134:			;  16 Nov 88 jrs v3.0	Bumped version number to regain sequence with USA.
 135:			;			Until now there were two independent streams of
 136:			;			development.  (A date prefixed by '-' denotes a
 137:			;			version from the "USA" stream).
 138:			;
 139:			;			Extended Jim Moore's idea of substituting RST 30h
 140:			;			(RST 6) for RST 38h (RST 7).  Now the breakpoint
 141:			;			vector address can be patched without re-assembling.
 142:			;
 143:			;  11 Nov 88 jrs v1.5	Added code to distinguish between .PRN files created
 144:			;			by Macro-80 and Z80ASM 1.3 so Z8E can load symbols
 145:			;			from either type of .PRN file.
 146:			;
 147:			;- 30 Nov 87 eg  v2.1	FCB and command tail initialisation routine supplied
 148:			;			by Eric Gans.  [Does not appear in the current source
 149:			;			as it duplicated v1.4 but consumed more code space.]
 150:			;
 151:			;  15 May 87 jrs v1.4	Implemented "I" command to initialise the command
 152:			;			tail at 80h and the default FCB name blocks at 5Ch
 153:			;			and 6Ch.
 154:			;
 155:			;			Renamed I(nput) command to L(oad) to make way for new
 156:			;			I(nitialise) command.  Documentation changed 13/6/87.
 157:			;
 158:			;			Filtered source code to all lower case.  Sometime
 159:			;			Between 1.0 And 1.2 The Comments Had Been Modified So
 160:			;			That Every Word Started With A Capital Letter And It
 161:			;			Really Did Look Quite Silly.
 162:			;
 163:			;  20 Apr 87 jrs v1.3	Fixed register display in animated debug mode.  Z8E
 164:			;			now handles EX AF,AF' and EXX instructions correctly.
 165:			;			Duplicates patch of 21 Oct 86 but was developed quite
 166:			;			independently and coded very differently.
 167:			;
 168:			;			Added equates to tailor the source to assemblers
 169:			;			other than M80.
 170:			;
 171:			;- 21 Oct 86 fh  v2.0	Fixed register display in animated debug mode.  Z8E
 172:			;  (installed by gmi)	now handles EX AF,AF' and EXX instructions correctly.
 173:			;
 174:			;  08 Mar 86 jrs v1.2	(No version number change - all mods purely cosmetic)
 175:			;			Modified org directives to bypass bug in M80
 176:			;			Added jterm conditional for testing
 177:			;			Added hazeltine conditional for tilde suppression
 178:			;			Changed dates to more universal format
 179:			;
 180:			;  16 Jan 86 ijb v1.2	Cursor addressing for post '=>' in jdbg75
 181:			;			to cover systems that have a destructive bs
 182:			;
 183:			;-  3 Dec 85 jgm v?.?	Added EQUates for breakpoint address so it could be
 184:			;			something other than 38h.
 185:			;
 186:			;  25 Sep 85 ras v1.1	Fix case bug
 187:			;			Fix usym bug
 188:			;			Clean up comments
 189:			;
 190:			;	ras = Richard Surwilo		Stamford, Connecticut
 191:			;	ijb = ?
 192:			;	jrs = Jon Saxton		Sydney, New South Wales
 193:			;	jgm = Jim Moore			Anaheim, California
 194:			;	eg  = Eric Gans			Los Angeles, California
 195:			;	fh  = Frankie Hogan
 196:			;	gbi = Gary Inman		Los Angeles, California
 197:			;	gah = George Havach		California
 198:			;	hp  = Hector Peraza
 199:			;
 200:			;------------------------------------------------------------------------------
 201:			
 202:	FFFF          	true	equ	-1
 203:	0000          	false	equ	0
 204:			
 205:			;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 206:			; The following EQUates should both be set to FALSE to generate a "standard"
 207:			; Z8E.COM for distribution.
 208:			;
 209:			; The JTERM is mine which I only put in for use while testing to save having
 210:			; to configure the object code for my terminal.  (jrs 8 mar 86)
 211:			;
 212:			; The ATERM is for an ANSI-compatible terminal such as a VT100 in which case
 213:			; setting ATERM to TRUE will cause the ANSIXYCP module to be included during
 214:			; assembly.  (jrs 28 dec 88)
 215:			;
 216:			; Setting H64180 to TRUE enables Hitachi HD64180 support. Set it to FALSE
 217:			; for a Z80-only version of Z8E.
 218:			;
 219:			; Setting AUXPRT to TRUE enables auxiliary debug terminal support, FALSE
 220:			; uses the main terminal only.
 221:			
 222:	0000          	jterm	equ	false		;Should always be false for distribution
 223:	0000          	aterm	equ	false		;- - - ditto - - -
 224:	0000          	h64180	equ	false		;true = Hitachi HD64180 support
 225:							;false = Z80 only
 226:	0000          	auxprt	equ	false		;true = auxiliary debug terminal support
 227:							;false = main terminal only
 228:			
 229:			;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 230:			; The following equ should normally be set to 0.  It is only required if
 231:			; you have a Hazeltine terminal which uses tilde as a command character
 232:			
 233:	0000          	hazeltine equ	false
 234:			
 235:			;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 236:			; Configure this source to your favourite assembler by setting one of
 237:			; the following equates to true.  If you use an assembler not mentioned
 238:			; below then make up a new equate for it.
 239:			
 240:	0000          	M80	equ	false		;Microsoft's Macro-80
 241:	0000          	ASMB	equ	false		;Cromemco's Z80 assembler
 242:	FFFF          	SLR	equ	true		;SLR's lightning-fast Z80ASM assembler
 243:			
 244:			; (Note that there is no real distinction between M80 and SLR.  Either
 245:			;  assembler may be used with either EQUate set TRUE.)
 246:			;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 247:			
 248:			; compact	equ	jterm or aterm
 249:			;
 250:			;      if	compact
 251:			; 	if	ASMB
 252:			; 	  conmsg	Non-standard version (not for distribution)
 253:			; 	else
 254:			; 	  .printx	* Non-standard version (not for distribution) *
 255:			; 	endif
 256:			;      endif
 257:			
 258:	FFFF          	compact	equ	true		;Already patched for ZDS
 259:			
 260:	FFFF          	     if	not ASMB
 261:				.Z80			;so M80 users don't need /z switch
 262:			     endif
 263:			
 264:	0000          	     if	ASMB
 269:			     endif
 270:			
 271:	0010          	maxbp	equ	16		;Number of breakpoints configured
 272:			
 273:	0008          	bs	equ	08h		;ASCII 	backspace
 274:	0009          	tab	equ	09h		;	tab
 275:	000A          	lf	equ	0Ah		;	line feed
 276:	000C          	formf	equ	0Ch		;	form feed
 277:	000D          	cr	equ	0Dh		;	carriage return
 278:	001B          	esc	equ	1Bh		;       escape
 279:	0018          	ctlx	equ	'X' and	1fh	;	control x - delete line
 280:	0003          	ctlc	equ	'C' and	1fh	;	control c - warm boot
 281:	001A          	eof	equ	'Z' and	1fh	;	control z - logical eof
 282:	0027          	quote	equ	27h		;	quote
 283:	007E          	tilde	equ	7Eh		;	tilde
 284:	007F          	del	equ	7Fh		;	del
 285:			
 286:	0005          	bdos	equ	5
 287:	005C          	fcb5c	equ	5Ch		;CP/M default FCB
 288:			
 289:	0000          	znop	equ	000		;Z80 instructions
 290:	00C3          	zjp	equ	0C3h
 291:	00FF          	rst38	equ	0FFh
 292:			
 293:	0080          	iobuf	equ	80h		;Disk read buffer for symbol loading
 294:			
 296:			
 297:			;******************************************************************************
 298:			;*
 299:			;*	nint:	  Initialization - relocating loader - symbol loader
 300:			;*
 301:			;*	Initialization:
 302:			;*	- Save system I register
 303:			;*	- Determine max symbol length before loading symbol table
 304:			;*        permissable values are 6 and 14 which are converted to bit
 305:			;*	  masks by bumping by one
 306:			;*	- Set CP/M DMA address to 80h
 307:			;*	- Check first command line argument for (xx) where xx is the
 308:			;*	  number of slots in the symbol table to reserve.
 309:			;*	- Move first file name found in command line to local memory
 310:			;*	  since it will be loaded last.  At the end of initialization
 311:			;*	  (or symbol loading if required) this file name will be loaded
 312:			;*	  into the keyboard input buffer and the file will be loaded
 313:			;*	  just as if the user had entered the info as a Z8E command.
 314:			;*	- Move all subsequent file names in the command line buffer to
 315:			;*	  local input buffer (inbf) in low memory, where they can
 316:			;*	  be found by the parse routine (prsr).
 317:			;*
 318:			;*	Relocating loader:
 319:			;*	- Move absolute memory image of Z8E to top of TPA
 320:			;*	- Adjust all addresses in relocated monitor to reflect new
 321:			;*	  execution area.  This is accomplished by repeated calls to
 322:			;*	  zlen to calculate instruction lengths.
 323:			;*	- All addresses < the absolute value of z8eorg are considered
 324:			;*	  to be absolute values and are not modified.
 325:			;*	- Relocate all address pointers in command and operand jump
 326:			;*	  tables.
 327:			;*
 328:			;******************************************************************************
 329:			
 330:	FFFF          	      if	M80 or SLR
 331:				aseg
 332:			      endif
 333:			
 334:	0000          	      if ASMB
 336:			      endif
 337:			
 338:	0000          	      if	ASMB
 345:			      endif
 346:			
 347:			;     if	SLR or M80
 348:			;	Use :: at end of label name to generate a global symbol
 349:			;	when assembling to a .REL file (i.e. when using M80 or
 350:			;	when using Z80ASM with the /M switch).  Doing it this
 351:			;	way lets us assemble to a .REL file with either assembler
 352:			;	or directly to a .COM file with Z80ASM without changing
 353:			;	the source at all.
 354:			;     endif
 355:			
 356:	0100          		org	100h
 357:			
 358:	0100  C37201  		jp	nint
 359:			
 360:	0000          	      if	ASMB
 362:			      else
 363:	0103          	rstVec::
 364:			      endif
 365:	0103  38      		defb	38h		;Default (but patchable) breakpoint vector
 366:			
 367:	0000          	      if	ASMB
 369:			      else
 370:	0104          	coMask::
 371:			      endif
 372:	0104  FF      		defb	0FFh		;Mask applied to characters before output
 373:							;to screen.  Patch to 0FFh if your terminal
 374:							;needs high-order bit set on occasions.
 375:			
 376:	0000          	      if	ASMB
 378:			      else
 379:	0105          	mbannr::
 380:			      endif
 381:	0000          	      if	jTerm
 383:			      else
 384:	0105  0C      		defb	0ch		;ZDS "clear screen" code
 385:			      endif
 386:	0106  0D0A    		defb	cr,lf
 387:	0000          		if	h64180
 389:				else
 390:	0108  5A3845  		  defb	'Z8E'
 391:				endif
 392:	010B  2056332E		defb	' V3.6 - 19 Dec 2000'
	      36202D20
	      31392044
	      65632032
	      303030
 393:	011E  0D0A    		defb	cr,lf
 394:	0120  436F7079		defb	'Copyright (c) 1984, 1985  Richard A. Surwilo'
	      72696768
	      74202863
	      29203139
	      38342C20
	      31393835
	      20205269
	      63686172
	      6420412E
	      20537572
	      77696C6F
 395:	014C  0D0A    		defb	cr,lf
 396:	014E  5A38304E		defb	'Z80NE (ZDS) port 2017 by P.Betti'
	      4520285A
	      44532920
	      706F7274
	      20323031
	      37206279
	      20502E42
	      65747469
 397:	016E  0D0A0A  		defb	cr,lf,lf
 398:	0171  00      		defb	0
 399:			
 400:	0172          	nint:
 401:	0172  311B2F  		ld	sp,stack
 402:	0175  ED57    		ld	a,i		;Save i reg for user
 403:	0177  320A2E  		ld	(ireg),a
 404:	017A  CDFD09  		call	init
 405:	017D  110501  		ld	de,mbannr	;Dispense with formalities
 406:	0180  CD6F27  		call	print
 407:			
 408:			; Patch code for a specific breakpoint routine address.
 409:			;
 410:			; Adapted from an idea by Jim Moore (3 Dec 85) but made object-patchable
 411:			; (jrs 15 Nov 88)
 412:			
 413:	0183  3A0301  		ld	a,(rstVec)	;Get breakpoint vector address
 414:	0186  6F      		ld	l,a
 415:	0187  2600    		ld	h,0
 416:	0189  22D001  		ld	(nint03+1),hl	;Patch the code
 417:	018C  23      		inc	hl		;HL now holds rstVec+1
 418:	018D  229702  		ld	(nint71+1),hl	;Patch some more code
 419:	0190  F6C7    		or	0C7h		;Convert vector address into RST xx
 420:	0192  326813  		ld	(g400+1),a	;Patch the code
 421:	0195  329513  		ld	(g518+1),a
 422:			
 423:			; Patch code for terminal output - jrs 3.4
 424:			
 425:	0198  3A0401  		ld	a,(coMask)	;Get console output character mask
 426:	019B  328B24  		ld	(ttyo00+1),a
 427:			
 428:			; Do config based on max length of symbol names
 429:			
 430:	019E  3A7E2D  		ld	a,(maxlen)	;Check max symbol length
 431:	01A1  3C      		inc	a		;Create mask
 432:	01A2  FE0F    		cp	15
 433:	01A4  47      		ld	b,a		;B - maxlen mask - 15
 434:	01A5  3E3E    		ld	a,62		;A - maxlin disassembly line length (62)
 435:	01A7  0E44    		ld	c,68		;C - column to display first byte of memory
 436:							;    window for J command
 437:	01A9  1603    		ld	d,3		;D - bytes per line of memory window display
 438:	01AB  CAB601  		jp	z,nint00	;Z - max symbol length is 14
 439:			
 440:							;If not 14 - use default values
 441:	01AE  0607    		ld	b,7		;B - maxlen mask -  7
 442:	01B0  3E1E    		ld	a,30		;A - maxlin disassembly line length (30)
 443:	01B2  0E38    		ld	c,56		;C - column to display first byte of memory
 444:	01B4  1607    		ld	d,7		;    window for J command
 445:	01B6  32802D  	nint00:	ld	(maxlin),a
 446:	01B9  78      		ld	a,b
 447:	01BA  327E2D  		ld	(maxlen),a
 448:	01BD  79      		ld	a,c
 449:	01BE  32822D  		ld	(fwndow),a
 450:	01C1  7A      		ld	a,d
 451:	01C2  32832D  		ld	(nlmask),a
 452:			
 453:			; Reset CP/M DMA address for those instances in which Z8E is used to debug
 454:			; itself.  Otherwise DMA address is left where Z8E stopped loading itself.
 455:			; (Last statement no longer true - see patch 3.3.1)
 456:			
 457:	01C5  118000  		ld	de,80h
 458:	01C8  0E1A    		ld	c,26
 459:	01CA  CD0500  		call	bdos
 460:			
 461:	01CD  3EC3    		ld	a,zjp		;Initialize where L80 fears to tread
 462:			
 463:			; The next instruction is PATCHED before it is executed
 464:	01CF  323800  	nint03:	ld	(38h),a		;Init trap to breakpoint handler
 465:			
 466:	01D2  215D00  		ld	hl,5dh		;Save current contents of default fcb
 467:	01D5  7E      		ld	a,(hl)
 468:	01D6  FE28    		cp	'('		;Is first char in fcb a paren?
 469:	01D8  2B      		dec	hl
 470:	01D9  2048    		jr	nz,nint25	;Not paren - no user symbol table requested
 471:	01DB  23      		inc	hl		;Point back to paren
 472:	01DC  11552E  		ld	de,inbf		;Start of input buffer here in low memory
 473:	01DF  060F    		ld	b,15		;Max chars in fcb following first paren
 474:	01E1  23      	nint05:	inc	hl		;Bump fcb pointer
 475:	01E2  12      		ld	(de),a		;Move char to low memory keyboard input buffer
 476:							;so that prsr thinks this is keyboard input
 477:	01E3  13      		inc	de		;Bump input buffer pointer
 478:	01E4  7E      		ld	a,(hl)
 479:	01E5  FE29    		cp	')'		;Look for trailing paren
 480:	01E7  2807    		jr	z,nint10
 481:	01E9  10F6    		djnz	nint05		;Examine entire fcb at 5ch looking for paren
 482:	01EB  215C00  		ld	hl,fcb5c	;Trailing paren not found - this must be
 483:							; kookie file name
 484:	01EE  1833    		jr	nint25		;Ignore
 485:			
 486:			; Call iarg to determine amount of space to allocate in user symbol table.
 487:			; This arg must be enclosed in parentheses and must appear after the first
 488:			; arg in the command line.  Since opening and closing parens were found
 489:			; add a pound sign to make this into default decimal number then call xval
 490:			; to evaluate.
 491:			
 492:	01F0  EB      	nint10:	ex	de,hl		;HL - input buffer pointer
 493:	01F1  3623    		ld	(hl),'#'	;Add trailing paren before calling iarg
 494:							;who will evaluate argument as if it was
 495:							;entered from keyboard
 496:	01F3  23      		inc	hl
 497:	01F4  77      		ld	(hl),a		;Restore trailing paren following pound sign
 498:	01F5  23      		inc	hl
 499:	01F6  3600    		ld	(hl),0		;Add end of line null
 500:	01F8  CDA025  		call	iarg
 501:	01FB  EB      		ex	de,hl		;DE - evaluated argument
 502:	01FC  215C00  		ld	hl,fcb5c
 503:	01FF  2022    		jr	nz,nint25	;Arg error - ignore input
 504:	0201  218100  		ld	hl,81h		;Start of command line tail
 505:	0204  7E      	nint15:	ld	a,(hl)
 506:	0205  3620    		ld	(hl),' '	;Replace the text which appeared between
 507:							;the parens and the parens themselves with
 508:							;spaces
 509:			
 510:	0207  FE29    		cp	')'		;Closing paren ends search
 511:	0209  2803    		jr	z,nint20
 512:	020B  23      		inc	hl		;Point to char following closing paren
 513:	020C  18F6    		jr	nint15
 514:	020E  EB      	nint20:	ex	de,hl		;Arg to hl for mult times maxlen bytes per
 515:							;symbol table entry
 516:	020F  29      		add	hl,hl
 517:	0210  29      		add	hl,hl
 518:	0211  29      		add	hl,hl
 519:	0212  3A7E2D  		ld	a,(maxlen)	;8 or 16 bytes per symbol table entry?
 520:	0215  FE07    		cp	7
 521:	0217  CA1B02  		jp	z,nint22	;z - must be 8
 522:	021A  29      		add	hl,hl
 523:	021B  EB      	nint22:	ex	de,hl
 524:	021C  ED53F008		ld	(usymbl),de	;Save number of bytes to reserve
 525:	0220  216C00  		ld	hl,6ch		;since user symbol table arg was present then
 526:							;target file must be in default fcb number 2
 527:			
 528:	0223  11A509  	nint25:	ld	de,zbuf		;Local buffer
 529:	0226  011000  		ld	bc,16
 530:	0229  EDB0    		ldir			;Move FCB contents to local memory
 531:	022B  218000  		ld	hl,80h		;Command line buffer address
 532:	022E  7E      		ld	a,(hl)
 533:	022F  A7      		and	a		;Test for no input
 534:	0230  2834    		jr	z,nint55	;No input - clear symbol table
 535:	0232  4F      		ld	c,a		;BC - number of chars in command line buffer
 536:	0233  70      		ld	(hl),b		;Clear byte count
 537:	0234  09      		add	hl,bc		;Point to last char in buffer
 538:	0235  23      		inc	hl
 539:	0236  70      		ld	(hl),b		;Set end of line null after last char
 540:	0237  218100  		ld	hl,81h
 541:	023A  7E      	nint30:	ld	a,(hl)		;Look for start of first file name
 542:	023B  A7      		and	a		;Found the end of line null?
 543:	023C  2828    		jr	z,nint55	;Z - no files to load
 544:	023E  FE20    		cp	' '		;Leading space?
 545:	0240  2004    		jr	nz,nint35	;Not space - found start of file name
 546:	0242  23      		inc	hl
 547:	0243  0D      		dec	c		;Decrement command line byte count
 548:	0244  18F4    		jr	nint30		;Keep looking for start of file name
 549:	0246  11B509  	nint35:	ld	de,znmbuf	;Save name here for later display
 550:	0249  12      		ld	(de),a
 551:	024A  13      		inc	de
 552:	024B  23      	nint40:	inc	hl		;Find first trailing space
 553:	024C  7E      		ld	a,(hl)
 554:	024D  FE20    		cp	' '
 555:	024F  2808    		jr	z,nint45	;Found space - move remainder of buffer
 556:	0251  12      		ld	(de),a		;Save file name character for display
 557:	0252  13      		inc	de
 558:	0253  A7      		and	a		;End of line?
 559:	0254  2810    		jr	z,nint55	;z - only one file specified
 560:	0256  0D      		dec	c
 561:	0257  18F2    		jr	nint40
 562:	0259  79      	nint45:	ld	a,c		;Check byte count
 563:	025A  FE52    		cp	inbfsz		;versus size of our local input buffer
 564:	025C  3802    		jr	c,nint50	;carry - size is ok
 565:	025E  0E52    		ld	c,inbfsz	;Only move as much as will fit
 566:	0260  11552E  	nint50:	ld	de,inbf
 567:	0263  EDB0    		ldir			;Move command line to local memory
 568:	0265  AF      		xor	a
 569:			
 570:	0266  21000B  	nint55:	ld	hl,z8eorg	;clear local symbol table to nulls
 571:	0269  0610    		ld	b,z8e-z8eorg	;symbol table size
 572:	026B  77      	nint60:	ld	(hl),a		;nulls to entire local symbol table
 573:	026C  23      		inc	hl
 574:	026D  10FC    		djnz	nint60
 575:	026F  2A0600  		ld	hl,(06)		;start of bdos
 576:	0272  6F      		ld	l,a		;init stack address to 256 boundary
 577:	0273  010025  		ld	bc,nmem		;monitor size
 578:	0276  A7      		and	a
 579:	0277  ED42    		sbc	hl,bc		;hl - starting address of z8e in upper
 580:							;memory
 581:	0279  22A009  		ld	(z8eb),hl	;monitor bias - for relocation work
 582:	027C  ED5BF008		ld	de,(usymbl)
 583:	0280  ED52    		sbc	hl,de
 584:	0282  22A209  		ld	(ntpa),hl	;end of tpa - for symbol loading
 585:	0285  7A      		ld	a,d		;check for no user symbol table
 586:	0286  B3      		or	e
 587:	0287  2808    		jr	z,nint75	;no table - no clearing required
 588:	0289  3600    	nint70:	ld	(hl),0		;fill user symbol table with nulls
 589:	028B  23      		inc	hl
 590:	028C  1B      		dec	de
 591:	028D  7A      		ld	a,d
 592:	028E  B3      		or	e
 593:	028F  20F8    		jr	nz,nint70
 594:	0291  EB      	nint75:	ex	de,hl		;hl - start of z8e in hi memory
 595:			
 596:	0292  217100  		ld	hl,bphn-z8eorg	;entry point to breakpoint handler
 597:	0295  19      		add	hl,de
 598:			
 599:			; The next instruction will be PATCHED by the time it is executed.
 600:	0296  223900  	nint71:	ld	(39h),hl	;Init RST 38h trap location
 601:			
 602:	0299  21000B  		ld	hl,z8eorg
 603:	029C  EDB0    		ldir			;z8e now in hi memory - relocate addresses
 604:	029E  2AA009  		ld	hl,(z8eb)	;recover hi memory starting address
 605:	02A1  111400  		ld	de,z8ecmd-z8eorg
 606:	02A4  19      		add	hl,de		;first instruction to relocate
 607:	02A5  EB      		ex	de,hl
 608:	02A6  CDC419  	nint80:	call	zlen00		;calculate instruction length
 609:	02A9  62      		ld	h,d
 610:	02AA  6B      		ld	l,e		;de - current instruction   hl - ditto
 611:	02AB  0600    		ld	b,0
 612:	02AD  09      		add	hl,bc
 613:	02AE  EB      		ex	de,hl		;de - next address to relocate
 614:	02AF  79      		ld	a,c		;test length
 615:	02B0  D603    		sub	3
 616:	02B2  381B    		jr	c,nint90	;one or two byters are non-relocatable
 617:	02B4  4F      		ld	c,a
 618:	02B5  09      		add	hl,bc		;bump if four byter
 619:	02B6  7E      		ld	a,(hl)
 620:	02B7  21C428  		ld	hl,z80r		;table of relocatable instructions
 621:	02BA  0E20    		ld	c,z80rl		;size
 622:	02BC  EDB1    		cpir
 623:	02BE  200F    		jr	nz,nint90	;nz - not relocatable
 624:	02C0  EB      		ex	de,hl
 625:	02C1  2B      		dec	hl		;point to address byte requiring bias
 626:	02C2  7E      		ld	a,(hl)
 627:	02C3  D60B    		sub	z8eorg shr 8	;test for absolute address < z8eorg
 628:	02C5  3806    		jr	c,nint85	;absolute - no relocation needed
 629:	02C7  47      		ld	b,a
 630:	02C8  3AA109  		ld	a,(z8ebh)	;hi order byte of address bias
 631:	02CB  80      		add	a,b		;plus upper byte of operand address
 632:	02CC  77      		ld	(hl),a		;set relocated address
 633:	02CD  23      	nint85:	inc	hl
 634:	02CE  EB      		ex	de,hl		;de - next address to test
 635:	02CF  01831C  	nint90:	ld	bc,nrel-z8eorg	;end of relocatable portion of monitor
 636:	02D2  2AA009  		ld	hl,(z8eb)
 637:	02D5  09      		add	hl,bc		;hl - absolute end of relocated monitor
 638:	02D6  A7      		and	a
 639:	02D7  ED52    		sbc	hl,de		;reached end?
 640:	02D9  30CB    		jr	nc,nint80	;nc - more
 641:	02DB  112400  		ld	de,ncmd+zopjtl	;size - command and operand jump tables
 642:	02DE  2AA009  		ld	hl,(z8eb)	;base of relocated monitor
 643:	02E1  3EF5    		ld	a,-(high z8eorg); [was:  ld a,-(z8eorg/256)]
 644:	02E3  84      		add	a,h		;relocation bias byte to add to ptrs
 645:	02E4  57      		ld	d,a		;d - bias to add  e - count of pointers
 646:							;		      requiring relocation
 647:	02E5  09      		add	hl,bc		;first point to operand names
 648:	02E6  013000  		ld	bc,zopjtb	;add length of operand name table
 649:	02E9  09      		add	hl,bc		;point to first entry in jump table
 650:	02EA  23      	nint95:	inc	hl
 651:	02EB  7E      		ld	a,(hl)		;hi byte jump table entry
 652:	02EC  82      		add	a,d		;plus bias
 653:	02ED  77      		ld	(hl),a		;replace in table
 654:	02EE  23      		inc	hl
 655:	02EF  1D      		dec	e
 656:	02F0  20F8    		jr	nz,nint95	;nz - more table entries to relocate
 657:			
 658:			
 659:			;******************************************************************************
 660:			;*
 661:			;*	ZSYM:	Symbol table build from .SYM and .PRN files
 662:			;*
 663:			;*	LFCB called to parse the input buffer (inbf) in low memory.
 664:			;*	INBF contains the command line tail which bdos passed to us at
 665:			;*	80h and which we have since moved to inbf (so that prsr thinks
 666:			;*	it's just keyboard input).
 667:			;*
 668:			;*	All valid file names are opened for input.
 669:			;*
 670:			;*	If the file name terminates with a comma then we assume the
 671:			;*	user is specifying a bias which is to be added to every symbol
 672:			;*	loaded from the file.
 673:			;*
 674:			;*	zsym	general file handiling
 675:			;*	.SYM	load L80 .SYM file or load SLR .LST file
 676:			;*	.PRN	load M80 .PRN file or load SLR .PRN file
 677:			;*
 678:			;*	Symbol table always begins on an 8 or 16 byte boundary
 679:			;*	depending on the value in maxlen.
 680:			;*
 681:			;******************************************************************************
 682:			
 683:	02F2  CD0B1D  	zsym:	call	lfcb		;Initialize fcb
 684:	02F5  C24D08  		jp	nz,zstx		;nz - error
 685:	02F8  113A28  		ld	de,mldg		;Display loading message
 686:	02FB  CD6C27  		call	nprint		;Output crlf - then print
 687:	02FE  11A72E  		ld	de,prsbf
 688:	0301  CD6F27  		call	print		;Display file name
 689:	0304  79      		ld	a,c 		;lfcb returns delimeter in c reg
 690:	0305  326C2D  		ld	(delim),a	;Temp save delimiter so we know if a bias has
 691:							;been specified
 692:	0308  CD0C25  		call	crlf
 693:	030B  CD721D  		call	lopn		;Try to open symbol table file
 694:	030E  3D      		dec	a		;
 695:	030F  FA6C08  		jp	m,zfnf		;m - file not found
 696:	0312  3A6C2D  		ld	a,(delim)	;Check delimeter
 697:	0315  FE2C    		cp	','
 698:	0317  210000  		ld	hl,00
 699:	031A  2048    		jr	nz,zsym10	;nz - no comma means no symbol bias
 700:	031C  CD2719  		call	prsr		;Let prsr extract symbol bias
 701:	031F  C28B08  		jp	nz,zoff		;Parse error - use bias of 0000
 702:	0322  326C2D  		ld	(delim),a	;Save delimeter which followed bias
 703:	0325  11A72E  		ld	de,prsbf
 704:	0328  210000  		ld	hl,00
 705:	032B  CDC017  		call	xval		;Evaluate bias
 706:	032E  2834    		jr	z,zsym10	;z - numeric bias specified
 707:			
 708:							;User has specified a bias in the form
 709:							; of a symbol name
 710:	0330  2AA209  		ld	hl,(ntpa)	;Check bias specified by symbol name
 711:	0333  3A7E2D  		ld	a,(maxlen)
 712:	0336  2F      		cpl
 713:	0337  5F      		ld	e,a
 714:	0338  16FF    		ld	d,0ffh		;Lower end of TPA by amount equal to
 715:							; the value of maxlen negated to insert
 716:							; jump to bdos
 717:	033A  19      		add	hl,de
 718:	033B  3A842D  		ld	a,(case)	;Check case of symbol table
 719:	033E  A7      		and	a
 720:	033F  CA5203  		jp	z,zsym05	;z - symbol names are already in upper case
 721:	0342  11A72E  		ld	de,prsbf	;prsr stored symbol name here
 722:	0345  1A      	zsym00:	ld	a,(de)
 723:	0346  A7      		and	a
 724:	0347  CA5203  		jp	z,zsym05	;z - end of label symbol name
 725:	034A  CDFA24  		call	ilcs		;Change each char in symbol name to lower case
 726:	034D  12      		ld	(de),a
 727:	034E  13      		inc	de		;Store converted character
 728:	034F  C34503  		jp	zsym00
 729:	0352  11A72E  	zsym05:	ld	de,prsbf
 730:	0355  CDC718  		call	fsym00		;Search symbol table
 731:	0358  C28B08  		jp	nz,zoff		;nz - not found
 732:	035B  3A7E2D  		ld	a,(maxlen)
 733:	035E  B5      		or	l
 734:	035F  6F      		ld	l,a
 735:	0360  7E      		ld	a,(hl)		;Fetch hi order address associated
 736:							; with symbol
 737:	0361  2B      		dec	hl
 738:	0362  6E      		ld	l,(hl)
 739:	0363  67      		ld	h,a		;HL - symbol value
 740:	0364  225E2D  	zsym10:	ld	(bias),hl	;Bias to add to each symbol address
 741:	0367  210000  		ld	hl,00
 742:	036A  3A342E  		ld	a,(fcbtyp)
 743:	036D  ED4BA209		ld	bc,(ntpa)	;Current end of TPA
 744:	0371  FE53    		cp	'S'		;Is this a .SYM file?
 745:	0373  CA8503  		jp	z,.sym		;.SYM file loaded differently from .PRN
 746:	0376  FE4C    		cp	'L'
 747:	0378  C27C04  		jp	nz,.prn		;If not .LST then must be .PRN
 748:	037B  11B408  		ld	de,.lst??	;Look for .LST string id string
 749:	037E  ED53F208		ld	(pstrng),de	;Store pointer to string to find
 750:	0382  CD9708  		call	fstrng
 751:			
 752:							;BC - symbol table pointer
 753:			
 754:	0385  3A7E2D  	.sym:	ld	a,(maxlen)	;Lower TPA address by 16 or 8
 755:	0388  2F      		cpl
 756:	0389  A1      		and	c		;for storing next symbol and address
 757:	038A  4F      		ld	c,a
 758:	038B  3A7E2D  		ld	a,(maxlen)
 759:	038E  2F      		cpl			;This is negate plus one
 760:	038F  81      		add	a,c
 761:	0390  4F      		ld	c,a
 762:	0391  DA9503  		jp	c,.sym00	;Treat carry as complement of subtraction
 763:	0394  05      		dec	b
 764:	0395          	.sym00:
 765:	0395  EB      		ex	de,hl
 766:	0396  21232F  		ld	hl,stack+8	;Check for monster symbol table ready to eat us
 767:	0399  A7      		and	a
 768:	039A  ED42    		sbc	hl,bc
 769:	039C  D27508  		jp	nc,zmem		;End symbol load before stack is clobbered
 770:	039F  EB      		ex	de,hl
 771:	03A0  3A7E2D  		ld	a,(maxlen)	;Load symbol length mask (7 or 15)
 772:	03A3  3D      		dec	a		;
 773:	03A4  57      		ld	d,a		;D - actual max length of symbols (6 or 14)
 774:	03A5  AF      		xor	a
 775:	03A6  02      	.sym10:	ld	(bc),a		;Init symbol table entry to nulls
 776:	03A7  03      		inc	bc
 777:	03A8  15      		dec	d
 778:	03A9  20FB    		jr	nz,.sym10
 779:	03AB  5A      		ld	e,d		;Clear DE for hex00
 780:	03AC  AF      		xor	a
 781:	03AD  32F608  		ld	(star),a	;Clear ** found flag
 782:	03B0  3E04    		ld	a,4		;Convert four bytes of address
 783:	03B2  32A409  		ld	(bytes),a
 784:	03B5  CDB707  	.sym20:	call	nchr		;Fetch next character in file
 785:	03B8  FE1A    		cp	eof
 786:	03BA  CA4006  		jp	z,.eof		;End of this symbol file
 787:	03BD  FE30    		cp	'0'
 788:	03BF  3051    		jr	nc,.sym25	;c -  must be control character or space
 789:							;nc - possible first char of address
 790:	03C1  FE0A    		cp	lf
 791:	03C3  CAD103  		jp	z,.sym21
 792:	03C6  FE2A    		cp	'*'		;** in SLR .SYM file?
 793:	03C8  C2B503  		jp	nz,.sym20
 794:	03CB  32F608  		ld	(star),a
 795:	03CE  C31204  		jp	.sym25
 796:			
 797:	03D1          	.sym21:
 798:	03D1  CDB707  		call	nchr		;Fetch char following lf
 799:	03D4  FE0D    		cp	cr
 800:	03D6  CAEE03  		jp	z,.sym22	;z - consecutive crlf's means end of page
 801:	03D9  FE30    		cp	'0'
 802:	03DB  D21204  		jp	nc,.sym25	;nc - symbol address on new line
 803:	03DE  FE1A    		cp	eof
 804:	03E0  CA4006  		jp  	z,.eof
 805:	03E3  FE2A    		cp	'*'		;** ?
 806:	03E5  C2B503  		jp	nz,.sym20
 807:	03E8  32F608  		ld	(star),a
 808:	03EB  C31204  		jp	.sym25
 809:			
 810:	03EE          	.sym22:
 811:	03EE  3A342E  		ld	a,(fcbtyp)
 812:	03F1  FE4C    		cp	'L'		;z80asm .LST file?
 813:	03F3  CAFB03  		jp	z,.sym23
 814:	03F6  FE50    		cp	'P'		;Macro 80 V3.4?
 815:	03F8  C2B503  		jp	nz,.sym20
 816:	03FB          	.sym23:
 817:	03FB  11B408  		ld	de,.lst??	;Bypass inter-page verbiage
 818:	03FE  ED53F208		ld	(pstrng),de
 819:	0402  CD9708  		call	fstrng
 820:	0405  FE1A    		cp	eof
 821:	0407  CA4006  		jp	z,.eof
 822:			
 823:	040A  CDB707  		call	nchr
 824:	040D  FE1A    		cp	eof
 825:	040F  CA4006  		jp	z,.eof
 826:			
 827:			
 828:	0412  CDF207  	.sym25:	call	hex00		;Have first char of address - convert
 829:	0415  CD3D08  		call	totsym		;Bump total of symbols loaded
 830:	0418  3A342E  		ld	a,(fcbtyp)	;Is this a .SYM file?
 831:	041B  FE53    		cp	'S'
 832:	041D  C4B707  		call	nz,nchr		;Eat addrress/symbol separator for .LST file
 833:	0420  3A7E2D  		ld	a,(maxlen)
 834:	0423  3D      		dec	a
 835:	0424  32A409  		ld	(bytes),a	;Init max symbol length counter
 836:	0427  CDB707  	.sym30:	call	nchr		;Read symbol name char
 837:	042A  FE09    		cp	tab
 838:	042C  CA5F04  		jp	z,.sym45
 839:	042F  FE0D    		cp	cr
 840:	0431  CA5F04  		jp	z,.sym45
 841:	0434  FE20    		cp	' '
 842:	0436  CA5F04  		jp	z,.sym45
 843:	0439  02      		ld	(bc),a
 844:	043A  3A842D  	        ld	a,(case)	;Check user requested case
 845:	043D  A7      		and	a
 846:	043E  280D    		jr	z,.sym35	;z - upper case requested by user
 847:	0440  0A      		ld	a,(bc)		;Recover char
 848:	0441  FE41    		cp	'A'
 849:	0443  3808    		jr	c,.sym35	;c - must be number
 850:	0445  FE5B    		cp	'Z'+1
 851:	0447  D24D04  		jp	nc,.sym35
 852:	044A  F620    		or	20h
 853:	044C  02      		ld	(bc),a		;Restore symbol name char as lower case
 854:	044D  03      	.sym35:	inc	bc
 855:	044E  3AA409  		ld	a,(bytes)
 856:	0451  3D      		dec	a
 857:	0452  32A409  		ld	(bytes),a
 858:	0455  20D0    		jr	nz,.sym30
 859:	0457  CDB707  	.sym40:	call	nchr
 860:	045A  FE21    		cp	21h
 861:	045C  D25704  		jp	nc,.sym40
 862:	045F  3AF608  	.sym45:	ld	a,(star)	;Check if this was ** in address field
 863:	0462  A7      		and	a
 864:	0463  C27304  		jp	nz,.sym50
 865:	0466  3AF408  		ld	a,(relchr)	;Check for external symbol
 866:	0469  FE20    		cp	' '
 867:	046B  CA8503  		jp	z,.sym		;Space means absolute
 868:	046E  FE27    		cp	quote
 869:	0470  CA8503  		jp	z,.sym		;Quote means relocatable
 870:	0473  3A7E2D  	.sym50:	ld	a,(maxlen)
 871:	0476  B1      		or	c
 872:	0477  4F      		ld	c,a
 873:	0478  03      		inc	bc		;Point BC to next higher symbol block so
 874:							;that rewinding by maxlen bytes will actually
 875:							;overlay this symbol.  This ensures that
 876:							;external symbols are not kept in table.
 877:			
 878:	0479  C38503  		jp	.sym
 879:			
 880:			
 881:	047C          	.prn:				;Don't yet know if this .PRN file was
 882:							;generated by M80 or Z80ASM.  To find out
 883:							;I pull a dirty trick.  I force a read
 884:							;and look for a formfeed, up to 80 characters
 885:							;of program title, a HT and "MACRO-80" in the
 886:							;I/O buffer, then I reset the pointer so that
 887:							;the next character read comes from the
 888:							;beginning of the file.  Will probably get
 889:							;confused by a HT in the program title.
 890:							;  jrs 14/11/88, 22/12/88.
 891:			
 892:	047C  CDB707  		call	nchr		;Force a read.  First byte of file is
 893:							; returned in A, pointer to next byte in HL
 894:	047F  FE0C    		cp	formf		;Test character
 895:	0481  2017    		jr	nz,.prnBB	;Exit M80 testing now if not a formfeed
 896:	0483  0652    		ld	b,82		;Maximum number of characters to search
 897:	0485  3E09    		ld	a,tab		;What to look for
 898:	0487  EDB1    		cpir
 899:	0489  200F    		jr	nz,.prnBB	;If no tab then not an M80 .PRN file
 900:	048B  EB      		ex	de,hl		;Point at strings to be compared
 901:	048C  21E508  		ld	hl,.m80??
 902:	048F  46      		ld	b,(hl)		;Number of bytes to compare
 903:	0490  23      		inc	hl
 904:	0491          	.prnAA:
 905:	0491  1A      		ld	a,(de)		;Compare bytes
 906:	0492  BE      		cp	(hl)
 907:	0493  C29A04  		jp	nz,.prnBB	;Exit loop if different
 908:	0496  23      		inc	hl		; otherwise step the pointers
 909:	0497  13      		inc	de
 910:	0498  10F7    		djnz	.prnAA		;Loop until difference encountered or
 911:	049A          	.prnBB:				; all bytes compared.
 912:	049A  218000  		ld	hl,iobuf	;Reset buffer pointer
 913:	049D  ED4BA209		ld	bc,(ntpa)
 914:	04A1  C22806  		jp	nz,.slr		;If not M80 then do Z80ASM .PRN file load
 915:			
 916:				; End of dirty trick code
 917:			
 918:	04A4  11C608  		ld	de,.prn??
 919:	04A7  ED53F208		ld	(pstrng),de
 920:	04AB  CD9708  		call	fstrng
 921:	04AE  FE1A    		cp	eof
 922:	04B0  C2BC04  		jp	nz,.prn00
 923:	04B3          	.prnCC:
 924:	04B3  112D09  		ld	de,msymnf	;display symbol table not found message
 925:	04B6  CD6F27  		call	print
 926:	04B9  C3A606  		jp	.eof50		;check for more symbol files to load
 927:			
 928:	04BC          	.prn00:
 929:	04BC  ED4BA209		ld	bc,(ntpa)	;bc - current end of the tpa
 930:	04C0  0B      		dec	bc		;this points us into the next lower
 931:							;symbol table block
 932:							;this is first char of symbol table
 933:	04C1  AF      		xor	a
 934:	04C2  B5      		or	l		;get next byte from file but without bumping
 935:							;pointer allowing us to reread same char in
 936:							;case it is last character in buffer
 937:			
 938:	04C3  CCBF07  		call	z,read		;only do true read if last character was last
 939:							;in buffer
 940:	04C6  7E      		ld	a,(hl)
 941:	04C7  FE30    		cp	'0'
 942:	04C9  DAD104  		jp	c,.pr325	;non-numeric: Macro-80 V3.44
 943:			
 944:	04CC  FE3A    		cp	'9'+1
 945:	04CE  DA7905  		jp	c,.pr4		;numeric:     Macro-80 V3.4
 946:			
 947:			
 948:			; Macro-80 V3.4 dec 1980 symbol table load
 949:			
 950:	04D1  3A7E2D  	.pr325:	ld	a,(maxlen)
 951:	04D4  2F      		cpl
 952:	04D5  A1      		and	c		;now rewind within 8 or 16 byte block
 953:							;(depending on maxlen) in order to point
 954:							;to first byte
 955:	04D6  4F      		ld	c,a
 956:			
 957:	04D7  EB      	        ex	de,hl		;de - save file buffer pointer
 958:	04D8  212B2F  		ld	hl,stack + 16	;check for encroaching symbol table
 959:	04DB  ED42    		sbc	hl,bc		;versus current symbol table address
 960:	04DD  D27508  		jp	nc,zmem		;nc - out of memory
 961:	04E0  EB      		ex	de,hl		;return file buffer pointer
 962:	04E1  3A7E2D  		ld	a,(maxlen)
 963:	04E4  57      		ld	d,a
 964:	04E5  15      		dec	d		;d - symbol name length
 965:	04E6  AF      		xor	a
 966:	04E7  5F      		ld	e,a
 967:	04E8  02      	.pr330:	ld	(bc),a		;pre-clear name portion of symbol table to
 968:							;nulls
 969:	04E9  03      		inc	bc
 970:	04EA  15      		dec	d		;now any name less than maxlen chars in length
 971:	04EB  C2E804  		jp	nz,.pr330	;is terminated with a null
 972:	04EE  3A7E2D  		ld	a,(maxlen)
 973:	04F1  2F      		cpl
 974:	04F2  A1      		and	c
 975:	04F3  4F      		ld	c,a
 976:	04F4  CDB707  	.pr335:	call	nchr		;next char from file buffer
 977:	04F7  FE21    		cp	21h
 978:	04F9  D23F05  		jp	nc,.pr351	;nc - this is first character of symbol name
 979:	04FC  FE1A    		cp	eof		;end of file?
 980:	04FE  CA4006  		jp	z,.eof
 981:	0501  FE0A    		cp	lf		;line feed?
 982:	0503  C2F404  		jp	nz,.pr335
 983:	0506  CDB707  	.pr340:	call	nchr		;get character following line feed
 984:	0509  FE0D    		cp	cr
 985:	050B  CA1305  		jp	z,.pr342
 986:	050E  FE0C    		cp	formf		;form feed?
 987:	0510  C23F05  		jp	nz,.pr351
 988:	0513  1E03    	.pr342:	ld	e,3		;symbols resume three lines hence following
 989:							;a form feed character - so count linefeeds
 990:	0515  FE0D    		cp	cr		;did we find cr or a formf?
 991:	0517  C21B05  		jp	nz,.pr345	;nz - formf
 992:	051A  1D      		dec	e		;just look for two lf's
 993:	051B  CDB707  	.pr345:	call	nchr
 994:	051E  FE0A    		cp	lf
 995:	0520  C21B05  		jp	nz,.pr345	;loop til three found
 996:	0523  1D      		dec	e
 997:	0524  C21B05  		jp	nz,.pr345
 998:			
 999:	0527  AF      		xor	a
1000:	0528  B5      		or	l		;get next byte from file but without bumping
1001:							;pointer allowing us to reread same char in
1002:							;case it is last character in buffer
1003:			
1004:	0529  CCBF07  		call	z,read		;only do true read if last character was last
1005:							;in buffer
1006:	052C  7E      		ld	a,(hl)
1007:	052D  FE0D    		cp	cr		;four crlf's is eof
1008:	052F  CA4006  		jp	z,.eof
1009:			
1010:	0532  CDB707  	.pr350:	call	nchr		;next char from file
1011:	0535  FE1A    		cp	eof
1012:	0537  CA4006  		jp	z,.eof
1013:	053A  FE09    		cp	tab
1014:	053C  CA5605  		jp	z,.pr355
1015:	053F  02      	.pr351:	ld	(bc),a		;move character of symbol name
1016:	0540  3A842D  		ld	a,(case)	;check user requested case
1017:	0543  A7      		and	a
1018:	0544  280C    		jr	z,.pr352	;z - user wants upper case
1019:	0546  0A      		ld	a,(bc)		;get char back from symbol table
1020:	0547  FE41    		cp	'A'
1021:	0549  3807    		jr	c,.pr352	;must be numeric - no case here
1022:	054B  FE5B    		cp	'Z'+1
1023:	054D  3003    		jr	nc,.pr352
1024:	054F  C620    		add	a,20h
1025:	0551  02      		ld	(bc),a		;replace char with lower case equivalent
1026:	0552  03      	.pr352:	inc	bc
1027:	0553  C33205  		jp	.pr350
1028:			
1029:	0556  3E04    	.pr355:	ld	a,4
1030:	0558  32A409  		ld	(bytes),a
1031:	055B  CDB707  	.pr357:	call	nchr
1032:	055E  FE20    		cp	' '
1033:	0560  CA5B05  		jp	z,.pr357
1034:			
1035:	0563  CDF207  		call	hex00		;now read the next four characters from the
1036:							;file and convert them to a hex address -
1037:							;store in symbol table entry
1038:			
1039:			
1040:	0566  3AF408  		ld	a,(relchr)	;recover char which followed address
1041:			
1042:	0569  FE20    		cp	' '		;this char followed address
1043:	056B  2805    		jr	z,.pr370	;microsoft absolute address
1044:	056D  FE27    		cp	quote		;relocatable address?
1045:	056F  C2D104  		jp	nz,.pr325
1046:							;by not rewinding the symbol table pointer
1047:							;the next symbol will overlay this one.
1048:			
1049:	0572  0B      	.pr370:	dec	bc
1050:	0573  CD3D08  		call	totsym
1051:			
1052:	0576  C3D104  		jp	.pr325
1053:			
1054:			
1055:			; Macro-80 V3.44 symbol loading routine
1056:			
1057:	0579  3A7E2D  	.pr4:	ld	a,(maxlen)	;lower tpa address by maxlen
1058:	057C  2F      		cpl
1059:	057D  A1      		and	c		;for storing next symbol and address
1060:	057E  4F      		ld	c,a		;bc - next address of symbol table entry
1061:							;     on an 8 or 16 byte boundary
1062:	057F  EB      		ex	de,hl
1063:	0580  21232F  		ld	hl,stack+8	;check for monster symbol table
1064:	0583  A7      		and	a
1065:	0584  ED42    		sbc	hl,bc
1066:	0586  D27508  		jp	nc,zmem		;end symbol load before stack is clobbered
1067:	0589  EB      		ex	de,hl
1068:	058A  3A7E2D  		ld	a,(maxlen)
1069:	058D  3D      		dec	a		;pre-clear symbol table entry with nulls
1070:	058E  57      		ld	d,a
1071:	058F  AF      		xor	a
1072:	0590  02      	.pr410:	ld	(bc),a		;for length equal to maxlen
1073:	0591  03      		inc	bc
1074:	0592  15      		dec	d
1075:	0593  20FB    		jr	nz,.pr410
1076:	0595  5A      		ld	e,d		;clear de for hex00
1077:	0596  3E04    		ld	a,4		;convert four bytes of address
1078:	0598  32A409  		ld	(bytes),a
1079:	059B  CDB707  	.pr420:	call	nchr		;fetch next character in file
1080:	059E  FE1A    		cp	eof
1081:	05A0  CA4006  		jp	z,.eof
1082:	05A3  FE30    		cp	'0'
1083:	05A5  3028    		jr	nc,.pr425	;nc - address digit
1084:	05A7  FE0A    		cp	lf
1085:	05A9  C29B05  		jp	nz,.pr420	;nz - leading space or cr
1086:			
1087:			
1088:	05AC  CDB707  		call	nchr		;check character following lf
1089:	05AF  FE0D    		cp	cr
1090:	05B1  CA4006  		jp	z,.eof		;blank line is eof
1091:			
1092:	05B4  FE0C    		cp	formf		;form feed?
1093:	05B6  C2CF05  		jp	nz,.pr425	;no - first character of next address
1094:			
1095:	05B9  1E03    		ld	e,3		;must be form feed
1096:	05BB  CDB707  	.pr421:	call	nchr
1097:	05BE  FE0A    		cp	lf		;three lf's follow form feed before symbols
1098:							;resume on next page
1099:	05C0  C2BB05  		jp	nz,.pr421
1100:	05C3  1D      		dec	e
1101:	05C4  C2BB05  		jp	nz,.pr421
1102:			
1103:	05C7  CDB707  		call	nchr
1104:	05CA  FE1A    		cp	eof
1105:	05CC  CA4006  		jp	z,.eof
1106:			
1107:	05CF          	.pr425:
1108:	05CF  CDF207  		call	hex00		;have first char of address - convert
1109:			
1110:	05D2  CDB707  		call	nchr		;eat address/symbol separator
1111:			
1112:	05D5  3A7E2D  		ld	a,(maxlen)
1113:	05D8  3D      		dec	a
1114:	05D9  32A409  		ld	(bytes),a	;max chars to store in symbol table
1115:			
1116:			
1117:	05DC  CDB707  	.pr430:	call	nchr		;read symbol name char
1118:	05DF  FE21    		cp	21h
1119:	05E1  DA0F06  		jp	c,.pr440	;found separator
1120:	05E4  02      		ld	(bc),a
1121:	05E5  3A842D  	        ld	a,(case)	;check user requested case
1122:	05E8  A7      		and	a
1123:	05E9  280C    		jr	z,.pr435	;z - upper case requested by user
1124:	05EB  0A      		ld	a,(bc)		;recover char
1125:	05EC  FE41    		cp	'A'
1126:	05EE  3807    		jr	c,.pr435	;c - must be number
1127:	05F0  FE5B    		cp	'Z'+1
1128:	05F2  3003    		jr	nc,.pr435
1129:	05F4  F620    		or	20h
1130:	05F6  02      		ld	(bc),a		;restore symbol name char as lower case
1131:	05F7  03      	.pr435:	inc	bc		;bump symbol table pointer
1132:	05F8  3AA409  		ld	a,(bytes)	;character counter
1133:	05FB  3D      		dec	a
1134:	05FC  32A409  		ld	(bytes),a
1135:	05FF  C2DC05  		jp	nz,.pr430	;not max length
1136:			
1137:			
1138:	0602  CDB707  	.pr438:	call	nchr		;eat chars until next address found
1139:	0605  FE1A    		cp	eof
1140:	0607  CA4006  		jp	z,.eof
1141:	060A  FE20    		cp	' '		;found symbol/address
1142:	060C  C20206  		jp	nz,.pr438
1143:			
1144:			
1145:	060F  3A7E2D  	.pr440:	ld	a,(maxlen)
1146:	0612  2F      		cpl
1147:	0613  A1      		and	c
1148:	0614  4F      		ld	c,a
1149:			
1150:	0615  3AF408  		ld	a,(relchr)	;recover char which followed address
1151:	0618  FE20    		cp	' '		;this char followed address
1152:	061A  2805    		jr	z,.pr450	;Microsoft absolute address
1153:	061C  FE27    		cp	quote		;relocatable address?
1154:	061E  C27905  		jp	nz,.pr4		;nz - must be  external symbol. We don't
1155:							;actually load them or count them in total.
1156:							;By not rewinding the symbol table pointer
1157:							;the next symbol will overlay this one.
1158:			
1159:	0621  0B      	.pr450:	dec	bc
1160:	0622  CD3D08  		call	totsym
1161:	0625  C37905  		jp	.pr4
1162:			
1163:			; SLR Z80ASM symbol table loading routines
1164:			
1165:	0628          	.slr:
1166:	0628  11D108  		ld	de,.slr??	;If this .PRN file really is a Z80ASM
1167:	062B  ED53F208		ld	(pstrng),de	;product then we can use existing code
1168:	062F  CD9708  		call	fstrng		;to load the symbols.
1169:	0632  FE1A    		cp	eof
1170:	0634  C28503  		jp	nz,.sym
1171:	0637  112D09  		ld	de,msymnf	;display symbol table not found message
1172:	063A  CD6F27  		call	print
1173:	063D  C3A606  		jp	.eof50		;check for more symbol files to load
1174:			
1175:			
1176:	0640          	.eof:				;We always pre-decrement the symbol table
1177:							;pointer in anticipation of storing the next
1178:							;symbol.  Now that we hit the end of a symbol
1179:							;table we must adjust the pointer in
1180:							;preparation for loading the symbols from the
1181:							;next file (if there is one).
1182:	0640  3A7E2D  	        ld	a,(maxlen)
1183:	0643  6F      		ld	l,a
1184:	0644  2600    		ld	h,0
1185:	0646  2C      		inc	l
1186:	0647  09      		add	hl,bc		;point to last loaded symbol
1187:	0648  44      		ld	b,h
1188:	0649  4D      		ld	c,l		;bc - spare copy
1189:	064A  2F      		cpl
1190:	064B  A1      		and	c
1191:	064C  4F      		ld	c,a
1192:	064D  ED43A209		ld	(ntpa),bc	;save current end of tpa address
1193:	0651  3AF708  	        ld	a,(nsymhi)	;hi order number of symbols loaded (bcd)
1194:	0654  CDDC07  		call	hexc		;convert to ascii
1195:	0657  67      		ld	h,a		;returned in a - move to h (other digit in l)
1196:	0658  22F908  		ld	(mhex),hl	;store in message
1197:	065B  3AF808  		ld	a,(nsymlo)
1198:	065E  CDDC07  		call	hexc		;convert lo order
1199:	0661  67      		ld	h,a
1200:	0662  22FB08  		ld	(mhex+2),hl
1201:	0665  11FE08  		ld	de,msym..	;display number of symbols loaded message
1202:	0668  0E09    		ld	c,9
1203:	066A  CD0500  		call	bdos
1204:	066D  11F908  		ld	de,mhex		;now look thru ascii number of symbols to
1205:							;strip leading zeros
1206:	0670  0603    		ld	b,3
1207:	0672  1A      	.eof10:	ld	a,(de)
1208:	0673  FE30    		cp	'0'
1209:	0675  2003    		jr	nz,.eof20	;nz - found first non-zero
1210:	0677  13      		inc	de
1211:	0678  10F8    		djnz	.eof10		;if first three chars zero - fall thru and
1212:							;print the fourth regardless
1213:	067A  0E09    	.eof20: ld      c,09
1214:	067C  CD0500  		call	bdos		;print the number as string ending with $
1215:	067F  CD0C25  		call	crlf
1216:	0682  2AEE08  		ld	hl,(tsym)	;now add in bcd total for this file to bcd
1217:							;total for all files
1218:	0685  ED5BF708		ld	de,(nsym)	;tsym - total for all files
1219:							;nsym - total for this file
1220:	0689  7C      		ld	a,h
1221:	068A  82      		add	a,d
1222:	068B  27      		daa
1223:	068C  67      		ld	h,a
1224:	068D  7D      		ld	a,l
1225:	068E  8B      		adc	a,e
1226:	068F  27      		daa
1227:	0690  6F      		ld	l,a
1228:	0691  22EE08  		ld	(tsym),hl
1229:	0694  210000  		ld      hl,00		;clear out total for next file
1230:	0697  22F708  		ld	(nsym),hl
1231:	069A  2AA009  		ld	hl,(z8eb)
1232:	069D  114F22  		ld	de,symflg-z8eorg
1233:	06A0  19      		add	hl,de		;hl - pointer to symbol flag in hi memory
1234:	06A1  AF      		xor	a
1235:	06A2  77      		ld	(hl),a		;zero - symbol table present
1236:	06A3  324F2D  		ld	(symflg),a	;also set flag in lo memory where we are
1237:							;currently so that fsym knows theres a symbol
1238:							;table to search thru if the user specified a
1239:							;symbol name bias as part of the command line
1240:			
1241:	06A6  3A6C2D  	.eof50:	ld	a,(delim)	;check command line delimter
1242:	06A9  A7      		and	a		;test for end of line null
1243:	06AA  C2F202  		jp	nz,zsym		;nz - not null means more files
1244:			
1245:			
1246:			
1247:			
1248:	06AD  2AA209  	load:	ld	hl,(ntpa)	;current end of memory
1249:	06B0  3A4F2D  		ld	a,(symflg)	;check for symbol table
1250:	06B3  A7      		and	a
1251:	06B4  2008    		jr	nz,load00	;nz - no symbol table
1252:	06B6  57      		ld	d,a
1253:	06B7  3A7E2D  		ld	a,(maxlen)
1254:	06BA  5F      		ld	e,a		;de - length of a symbol table block
1255:	06BB  1C      		inc	e
1256:	06BC  ED52    		sbc	hl,de		;compensate for pre-increment of pointer
1257:	06BE  ED5B0600	load00:	ld	de,(06)		;de - real entry point to bdos
1258:	06C2  220600  		ld	(06),hl		;point to our origin in hi memory
1259:	06C5  36C3    		ld	(hl),zjp	;init jump to bdos at start of z8e
1260:	06C7  23      		inc	hl
1261:	06C8  73      		ld	(hl),e
1262:	06C9  23      		inc	hl
1263:	06CA  72      		ld	(hl),d
1264:	06CB  1E00    		ld	e,0		;de - old start of bdos address in also our
1265:							;ending address
1266:	06CD  2AA009  		ld	hl,(z8eb)	;load out starting address in hi memory
1267:	06D0  011000  		ld	bc,z8e-z8eorg	;fetch the number of bytes between z8e's base
1268:							;address and the entry point of the command
1269:							;processor  - internal symbol table size
1270:			
1271:	06D3  09      		add	hl,bc
1272:	06D4  44      		ld	b,h
1273:	06D5  4D      		ld	c,l		;BC - relocated z8e address
1274:	06D6  EB      		ex	de,hl		;DE - entry point z8e   HL - old start of bdos
1275:	06D7  2B      		dec	hl		;HL - last byte in our memory
1276:			
1277:							;Now we "rom" our entry Point onto the top of
1278:							;the stack so that all commands can return to
1279:							;the command processor via a simple RET.
1280:	06D8  70      		ld      (hl),b
1281:	06D9  2B      		dec	hl
1282:	06DA  71      		ld	(hl),c		;z8e (monitor entry point) on stack
1283:	06DB  F9      		ld	sp,hl		;now set current stack to just below our
1284:							;return address
1285:	06DC  EB      		ex	de,hl		;hl - relocated address z8e
1286:	06DD  23      		inc	hl
1287:	06DE  23      		inc	hl		;hl - points to ld  sp,0000 instruction at the
1288:							;start of the command processor. Replace 0000
1289:							;with the address bdos-1
1290:	06DF  73      		ld	(hl),e		;set real stack address
1291:	06E0  23      		inc	hl
1292:	06E1  72      		ld	(hl),d
1293:	06E2  2AA009  		ld	hl,(z8eb)	;base of relocated code
1294:	06E5  112B23  		ld	de,fcb-z8eorg	;relative offset from start of monitor
1295:	06E8  19      		add	hl,de
1296:	06E9  EB      		ex	de,hl		;de - fcb address in relocated monitor in hi
1297:							;memory
1298:	06EA  21A509  		ld	hl,zbuf
1299:	06ED  011000  		ld	bc,16
1300:	06F0  EDB0    		ldir			;init fcb with saved file name
1301:	06F2  117809  		ld	de,mz8eld	;print memory space occupied by z8e
1302:	06F5  CD6F27  		call	print
1303:	06F8  2AA009  		ld	hl,(z8eb)	;display our base address in upper memory
1304:	06FB  CD3025  		call	outadr
1305:	06FE  3E2D    		ld	a,'-'
1306:	0700  CD8224  		call	ttyo
1307:	0703  CD1925  		call	space1
1308:	0706  CD1925  		call	space1
1309:	0709  2A0600  		ld	hl,(06)		;this points to the new jump to bdos
1310:	070C  23      		inc	hl
1311:	070D  5E      		ld	e,(hl)		;de - old start of bdos address
1312:	070E  23      		inc	hl
1313:	070F  56      		ld	d,(hl)
1314:	0710  EB      		ex	de,hl
1315:	0711  2E00    		ld	l,0		;256 byte boundary to bypass cp/m serial no.
1316:	0713  CD3025  		call	outadr
1317:			
1318:	0716  3A4F2D  		ld	a,(symflg)	;test for presence of symbol table
1319:	0719  A7      		and	a
1320:	071A  204C    		jr	nz,load40	;nz - no table
1321:	071C  116409  		ld	de,msymld	;display start address of symbol table message
1322:	071F  CD6F27  		call	print
1323:	0722  2A0600  		ld	hl,(06)		;vector to bdos is start of symbol table
1324:	0725  CD3025  		call	outadr
1325:	0728  3E2D    		ld	a,'-'
1326:	072A  CD8224  		call	ttyo
1327:	072D  CD1925  		call	space1
1328:	0730  CD1925  		call	space1
1329:	0733  2AA009  		ld	hl,(z8eb)	;start of internal symbol table is end of
1330:							;symbol table built from files
1331:	0736  2B      		dec	hl
1332:	0737  CD3025  		call	outadr
1333:			
1334:	073A  3AEE08  		ld	a,(tsymhi)	;total number of symbols from all files (bcd)
1335:	073D  CDDC07  		call	hexc		;convert to ascii
1336:	0740  67      		ld	h,a		;move hi order ascii digit to h
1337:	0741  22F908  		ld	(mhex),hl	;store double ascii digit
1338:	0744  3AEF08  		ld	a,(tsymlo)
1339:	0747  CDDC07  		call	hexc		;convert lo order
1340:	074A  67      		ld	h,a
1341:	074B  22FB08  		ld	(mhex+2),hl	;save in string
1342:	074E  111909  		ld	de,tsym..	;total symbols message
1343:	0751  0E09    		ld	c,9
1344:	0753  CD0500  		call	bdos
1345:	0756  11F908  		ld	de,mhex		;address of ascii digits
1346:	0759  0603    		ld	b,3		;check for leading zeros
1347:	075B  1A      	load20:	ld	a,(de)
1348:	075C  FE30    		cp	'0'
1349:	075E  2003    		jr	nz,load30	;nz - found first nz in string
1350:	0760  13      		inc	de
1351:	0761  10F8    		djnz	load20		;check first three digits then fall thru and
1352:							;print fourth regardless
1353:	0763  0E09    	load30:	ld	c,09
1354:	0765  CD0500  		call	bdos
1355:			
1356:	0768  2A0600  	load40:	ld	hl,(06)
1357:	076B  2B      		dec	hl		;hl - address of new tpa
1358:	076C  118C09  		ld	de,mnvmem	;display address as memory available
1359:	076F  CD6F27  		call	print
1360:	0772  CD3025  		call	outadr
1361:	0775  CD0C25  		call	crlf
1362:	0778  3600    		ld	(hl),0		;now store two zeros at the top of the tpa and
1363:							;set stack pointer to this very same address.
1364:							;this allows users to do a warm boot via ret
1365:							;in the same way as if they had been loaded by
1366:							;cp/m.
1367:	077A  2B      		dec	hl
1368:	077B  3600    		ld	(hl),0
1369:	077D  ED4BA009		ld	bc,(z8eb)	;our relocated address in hi memory
1370:	0781  EB      		ex	de,hl		;de - last available location in tpa
1371:	0782  210323  		ld	hl,spreg-z8eorg ;address (relative to the start of z8e) where
1372:							;we store the user stack pointer address
1373:	0785  09      		add	hl,bc		;hl - pointer to
1374:	0786  73      		ld	(hl),e		;save user stack in spreg in hi memory
1375:	0787  23      		inc	hl
1376:	0788  72      		ld	(hl),d
1377:	0789  211000  		ld	hl,z8e-z8eorg
1378:	078C  3AA609  		ld	a,(zbufnm)	;first char of file name
1379:	078F  FE20    		cp	' '		;do we have a file to load?
1380:	0791  2813    		jr	z,load50	;z - no
1381:	0793  113A28  		ld	de,mldg		;display loading message and target file name
1382:	0796  CD6C27  		call	nprint
1383:	0799  11B509  		ld	de,znmbuf
1384:	079C  CD6F27  		call	print
1385:							;enter the monitor in hi memory at entry
1386:							;point lldr10
1387:			
1388:	079F  216211  		ld	hl,lldr10-z8eorg
1389:	07A2  ED4BA009		ld	bc,(z8eb)
1390:	07A6  09      	load50:	add	hl,bc		;hl - actual address of lldr10 in hi memory
1391:	07A7  EB      		ex	de,hl		;now clear out the buffer at 80h so the user
1392:							;program doesn't mistakenly think that our
1393:							;command line tail is really his.
1394:	07A8  218000  		ld	hl,iobuf
1395:	07AB  3600    		ld	(hl),0		;set number of chars zero (80h)
1396:	07AD  23      		inc	hl
1397:	07AE  067F    		ld	b,127		;clear until start of tpa
1398:	07B0  3620    	load60:	ld	(hl),' '
1399:	07B2  23      		inc	hl
1400:	07B3  10FB    		djnz	load60
1401:	07B5  EB      		ex	de,hl		;lldr10 address back to HL
1402:	07B6  E9      		jp	(hl)		;Hi-ho, hi-ho to the loader we must go
1403:			
1404:			
1405:			
1407:			
1408:			; This routine reads one char from the disk I/O buffer returning it in A.
1409:			; Upon entry we check the low order buffer pointer: 0 means we hit the 256
1410:			; boundary (end of buffer) and a read is needed.
1411:			
1412:	07B7  AF      	nchr:	xor	a
1413:	07B8  B5      		or	l
1414:	07B9  CCBF07  		call	z,read
1415:	07BC  7E      		ld	a,(hl)
1416:	07BD  23      		inc	hl
1417:	07BE  C9      		ret
1418:			
1419:	07BF  C5      	read:	push	bc
1420:	07C0  D5      		push	de
1421:	07C1  112B2E  		ld	de,fcb
1422:	07C4  0E14    		ld	c,20		;sequential file read
1423:	07C6  CD0500  		call	bdos
1424:	07C9  A7      		and	a		;test for error
1425:	07CA  218000  		ld	hl,iobuf	;assume ok - init i/o buffer address
1426:	07CD  D1      		pop	de
1427:	07CE  C1      		pop	bc
1428:	07CF  C8      		ret	z		;z - no errors
1429:	07D0  112D09  		ld	de,msymnf	;display symbol table not found message
1430:	07D3  CD6F27  		call	print
1431:	07D6  311B2F  		ld	sp,stack	;reinit stack
1432:	07D9  C3A606  		jp	.eof50		;check for more symbol files to load
1433:			
1434:			
1435:			; hexc
1436:			; Convert byte in a to two ASCII hex digits.
1437:			; return: a - converted hi order digit
1438:			;         l - converted lo order digit
1439:			
1440:	07DC  67      	hexc:	ld	h,a
1441:	07DD  0F      		rrca
1442:	07DE  0F      		rrca
1443:	07DF  0F      		rrca
1444:	07E0  0F      		rrca
1445:	07E1  CDE607  		call	hexc00
1446:	07E4  6F      		ld	l,a
1447:	07E5  7C      		ld	a,h
1448:	07E6  E60F    	hexc00:	and	0fh
1449:	07E8  C690    		add	a,90h
1450:	07EA  27      		daa
1451:	07EB  CE40    		adc	a,40h
1452:	07ED  27      		daa
1453:	07EE  C9      		ret
1454:			
1455:			
1456:			;hex:
1457:			; This routine is called by the symbol table building routines,
1458:			; .SYM and .PRN and its function is to convert ascii addresses
1459:			; into binary.  Since we are reading files in a known format
1460:			; we don't init any loop counts; instead, we look for delimeters.
1461:			
1462:			
1463:	07EF  CDB707  	hex:	call	nchr		;get char from disk i/o buffer
1464:	07F2  FE3A    	hex00:	cp	3ah		;convert ascii to hex
1465:	07F4  DAF907  		jp	c,hex10		;c - must be delimeter
1466:	07F7  D607    		sub	7
1467:	07F9  D630    	hex10:	sub	'0'
1468:	07FB  EB      		ex	de,hl		;shift hl left four
1469:	07FC  29      		add	hl,hl
1470:	07FD  29      		add	hl,hl
1471:	07FE  29      		add	hl,hl
1472:	07FF  29      		add	hl,hl
1473:	0800  B5      		or	l		;or in this new digit
1474:	0801  6F      		ld	l,a
1475:	0802  EB      		ex	de,hl
1476:	0803  3AA409  		ld	a,(bytes)
1477:	0806  3D      		dec	a
1478:	0807  32A409  		ld	(bytes),a
1479:	080A  C2EF07  		jp	nz,hex
1480:	080D  CDB707  		call	nchr
1481:	0810  FE49    		cp	'I'		;global?
1482:	0812  CCB707  		call	z,nchr		;z - need to read next to determine absolute
1483:							;    or relocatable
1484:			
1485:	0815  32F408  		ld	(relchr),a	;we need to save this character for .PRN files
1486:							;so we can tell whether to add this symbol
1487:							;to the count of symbols loaded.  If this
1488:							;is an external name we skip the add.
1489:			
1490:	0818  FE20    		cp	' '		;space means absolute
1491:	081A  280A    		jr	z,hex30		;no bias added to absolute symbols
1492:	081C  3A5E2D  		ld	a,(biaslo)
1493:	081F  83      		add	a,e		;add in bias as specified by user or default
1494:							;as initialized by us (zero)
1495:	0820  5F      		ld	e,a
1496:	0821  3A5F2D  		ld	a,(biashi)
1497:	0824  8A      		adc	a,d
1498:	0825  57      		ld	d,a
1499:	0826  3A7E2D  	hex30:	ld	a,(maxlen)	;now point to last byte of symbol table
1500:							;entry, which is where we will store
1501:							;address just computed
1502:	0829  2F      		cpl
1503:	082A  A1      		and	c
1504:	082B  4F      		ld	c,a
1505:	082C  3A7E2D  		ld	a,(maxlen)
1506:	082F  B1      		or	c
1507:	0830  4F      		ld	c,a		;never worry about carry - we always start
1508:							;with 256 boundary
1509:	0831  7A      	        ld	a,d		;store lo order symbol address
1510:	0832  02      		ld	(bc),a
1511:	0833  0B      		dec	bc		;point to penultimate byte in block
1512:	0834  7B      		ld	a,e		;hi order byte of address into symbol table
1513:	0835  02      		ld	(bc),a
1514:	0836  3A7E2D  		ld	a,(maxlen)	;mask to rewind symbol table pointer to the
1515:							;start of this block
1516:	0839  2F      		cpl
1517:	083A  A1      		and	c
1518:	083B  4F      		ld	c,a
1519:	083C  C9      		ret
1520:			
1521:			
1522:	083D  11F808  	totsym:	ld	de,nsymlo	;nsym - bcd running count of the number of
1523:	0840  1A      		ld	a,(de)		;       symbols loaded so far
1524:	0841  C601    		add	a,1		;bump by one symbol
1525:	0843  27      		daa			;keep bcd format
1526:	0844  12      		ld	(de),a
1527:	0845  D0      		ret	nc
1528:	0846  1B      		dec	de		;account for carry by bumping hi order byte
1529:	0847  1A      		ld	a,(de)
1530:	0848  C601    		add	a,1
1531:	084A  27      		daa
1532:	084B  12      		ld	(de),a
1533:	084C  C9      		ret
1534:			
1535:			
1536:			;zstx:
1537:			; Possible syntax error was detected as lfcb tried to init the FCB.
1538:			; However, we never keep track of how many files appeared in the
1539:			; command line we just keep calling lfcb.  Hence, we will always get
1540:			; an error return at some point when the input buffer runs out of
1541:			; valid input.  We check for real syntax error or end of command
1542:			; line by examining the first byte of the parse buffer:  if zero then
1543:			; prsr found no valid characters in the input buffer and this is the
1544:			; end of input - else, lfcb found real syntax error.
1545:			
1546:			
1547:	084D  3AA72E  	zstx:	ld	a,(prsbf)
1548:	0850  A7      		and	a		;real syntax error - or end of input?
1549:	0851  CAAD06  		jp	z,load		;z - more files
1550:	0854  113A28  		ld	de,mldg		;display loading message and symbol name
1551:							;to preserve the syntax used on good loads
1552:	0857  CD6C27  		call	nprint
1553:	085A  11A72E  		ld	de,prsbf	;display file name currently in parse buffer so
1554:							;user knows where goof was
1555:	085D  CD6F27  		call	print
1556:	0860  CD0C25  		call	crlf
1557:	0863  116928  		ld	de,msntx	;now display syntax error
1558:	0866  CD6F27  		call	print
1559:	0869  C3A606  		jp	.eof50		;check for more files to load
1560:			
1561:			
1562:	086C  114428  	zfnf:	ld	de,mfilnf	;display file not found
1563:	086F  CD6F27  		call	print
1564:	0872  C3A606  		jp	.eof50
1565:			
1566:			
1567:	0875  117828  	zmem:	ld	de,mmem??	;display out of memory message
1568:	0878  CD6F27  		call	print
1569:	087B  CD0C25  		call	crlf
1570:	087E  217E2D  		ld	hl,maxlen
1571:	0881  6E      		ld	l,(hl)
1572:	0882  2600    		ld	h,00
1573:	0884  09      		add	hl,bc
1574:	0885  22A209  		ld	(ntpa),hl
1575:	0888  C3AD06  		jp	load
1576:			
1577:			
1578:	088B  114609  	zoff:	ld	de,minvof	;display invalid offset using 0000 message
1579:	088E  CD6F27  		call	print
1580:	0891  210000  		ld	hl,00
1581:	0894  C36403  		jp	zsym10
1582:			
1583:			
1584:	0897          	fstrng:
1585:	0897  C5      		push	bc
1586:	0898  D5      		push	de
1587:	0899          	fstr00:
1588:	0899  ED5BF208		ld	de,(pstrng)	;address of canned string pointer
1589:	089D  1A      		ld	a,(de)		;length
1590:	089E  47      		ld	b,a
1591:	089F  13      		inc	de
1592:	08A0  CDB707  	fstr10:	call	nchr		;get char
1593:	08A3  FE1A    		cp	eof
1594:	08A5  CAB108  		jp	z,fstr20
1595:	08A8  EB      		ex	de,hl		;DE - buffer ptr  HL - "symbols:" string ptr
1596:	08A9  BE      		cp	(hl)
1597:	08AA  EB      		ex	de,hl
1598:	08AB  C29908  		jp	nz,fstr00	;mismatch read more from file
1599:	08AE  13      		inc	de
1600:	08AF  10EF    		djnz	fstr10		;check entire string length
1601:	08B1  D1      	fstr20:	pop	de
1602:	08B2  C1      		pop	bc
1603:	08B3  C9      		ret
1604:			
1605:	08B4  11      	.lst??:	defb	.lstsz		;string length
1606:	08B5  53796D62		defb	'Symbol Table:'
	      6F6C2054
	      61626C65
	      3A
1607:	08C2  0D0A0D0A		defb	cr,lf,cr,lf
1608:	0011          	.lstsz	equ	$ - .lst?? - 1
1609:			
1610:			
1611:	08C6  0A      	.prn??:	defb	.prnsz		;string length
1612:	08C7  53796D62		defb	'Symbols:'	;string to search for in M80's .PRN files
	      6F6C733A
1613:							;indicating start of symbol table
1614:	08CF  0D0A    		defb	cr,lf
1615:	000A          	.prnsz	equ	$ - .prn?? - 1
1616:			
1617:	08D1  13      	.slr??:	defb	.slrsz
1618:	08D2  53796D62		defb	'Symbols Detected.'
	      6F6C7320
	      44657465
	      63746564
	      2E
1619:	08E3  0D0A    		defb	cr,lf
1620:	0013          	.slrsz	equ	$ - .slr?? - 1
1621:			
1622:	08E5  08      	.m80??:	defb	.m80sz
1623:	08E6  4D414352		defb	'MACRO-80'
	      4F2D3830
1624:	0008          	.m80sz	equ	$ - .m80?? - 1
1625:			
1626:	08EE          	tsym:
1627:	08EE  00      	tsymhi:	defb	0
1628:	08EF  00      	tsymlo:	defb	0
1629:			
1630:	08F0  0000    	usymbl:	defw	0
1631:			
1632:	08F2  0000    	pstrng:	defw	0
1633:			
1634:	08F4  00      	relchr:	defb	0
1635:			
1636:	08F5  00      	.idprn:	defb	0
1637:			
1638:	08F6  00      	star:	defb	0
1639:			
1640:	08F7          	nsym:
1641:	08F7  00      	nsymhi:	defb	0
1642:	08F8  00      	nsymlo:	defb	0
1643:	08F9  20202020	mhex:	defb	'    '
1644:	08FD  24      		defb	'$'
1645:			
1646:	08FE  4E756D62	msym..:	defb	'Number of Symbols Loaded: $'
	      6572206F
	      66205379
	      6D626F6C
	      73204C6F
	      61646564
	      3A2024
1647:			
1648:	0919  0D0A    	tsym..:	defb	cr,lf
1649:	091B  546F7461		defb	'Total Symbols:   $'
	      6C205379
	      6D626F6C
	      733A2020
	      2024
1650:			
1651:	092D  53796D62	msymnf:	defb	'Symbol Table Not Found'
	      6F6C2054
	      61626C65
	      204E6F74
	      20466F75
	      6E64
1652:	0943  0D0A00  		defb	cr,lf,0
1653:			
1654:	0946  496E7661	minvof:	defb	'Invalid Offset - Using 0000'
	      6C696420
	      4F666673
	      6574202D
	      20557369
	      6E672030
	      303030
1655:	0961  0D0A00  		defb	cr,lf,0
1656:			
1657:	0964  0D0A    	msymld:	defb	cr,lf
1658:	0966  53796D62		defb	'Symbol Table:    '
	      6F6C2054
	      61626C65
	      3A202020
	      20
1659:	0977  00      		defb	0
1660:			
1661:	0978  0D0A    	mz8eld:	defb	cr,lf
1662:	0000          		if	h64180
1664:				else
1665:	097A  5A3845  		  defb	'Z8E'
1666:				endif
1667:	097D  2052656C		defb	' Relocated:   '
	      6F636174
	      65643A20
	      2020
1668:	098B  00      		defb	0
1669:			
1670:	098C  0D0A    	mnvmem:	defb	cr,lf
1671:	098E  546F7020		defb	'Top of Memory:   '
	      6F66204D
	      656D6F72
	      793A2020
	      20
1672:	099F  00      		defb	00
1673:			
1674:	09A0  00      	z8eb:	defb	00
1675:	09A1  00      	z8ebh:	defb	00
1676:	09A2  0000    	ntpa:	defw	00
1677:			
1678:	09A4  00      	bytes:	defb	00
1679:			
1680:	09A5  00      	zbuf:	defb	00
1681:	09A6  00000000	zbufnm:	defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	      00000000
	      00000000
	      000000
1682:	09B5          	znmbuf:
1683:			; 	rept	18
1684:	09B5  00000000		defw	0,0
1685:	09B9  00000000		defw	0,0
1686:	09BD  00000000		defw	0,0
1687:	09C1  00000000		defw	0,0
1688:	09C5  00000000		defw	0,0
1689:	09C9  00000000		defw	0,0
1690:	09CD  00000000		defw	0,0
1691:	09D1  00000000		defw	0,0
1692:	09D5  00000000		defw	0,0
1693:	09D9  00000000		defw	0,0
1694:	09DD  00000000		defw	0,0
1695:	09E1  00000000		defw	0,0
1696:	09E5  00000000		defw	0,0
1697:	09E9  00000000		defw	0,0
1698:	09ED  00000000		defw	0,0
1699:	09F1  00000000		defw	0,0
1700:	09F5  00000000		defw	0,0
1701:	09F9  00000000		defw	0,0
1702:			; 	endm
1703:	0000          	    if	ASMB
1705:			    else
1706:	09FD          	init::
1707:			    endif
1708:	09FD  C9      		ret
1709:	09FE .. 0AFC 00		defs	255
1710:			
1712:			;******************************************************************************
1713:			;*
1714:			;*	z8e:	Entry point to monitor
1715:			;*
1716:			;*		Each command begins with the output of the '*' prompt.
1717:			;*		Command character is validated by checking the cmd table.
1718:			;*
1719:			;*		Relative position of command letter in cmd table also used
1720:			;*		as index into command jump table jtcmd.
1721:			;*
1722:			;*		All commands entered with b = 0.
1723:			;*
1724:			;******************************************************************************
1725:			
1726:			
1727:	0B00          		org	($+255) and 0ff00h
1728:			;was	org	256*(($+255)/256)
1729:			
1730:	0B00          	z8eorg:
1731:							;Note: first three bytes here become a jump to
1732:	0B00 .. 0B0F 00		defs	16		;      BDOS after we are loaded
1733:							;
1734:							;This is the internal symbol table
1735:			
1736:	0B10  A7      	z8e:	and	a		;Any do-nothing instruction with the sign
1737:							;bit set to indicate end of internal symbol
1738:							;table
1739:			
1740:	0B11  31      		defb	31h		;LD SP,nnnn - Load monitor stack pointer
1741:	0B12  0080    	z8esp:	defw	8000h		;Actual address filled in by nint at load
1742:							;time when we figure out where bdos is
1743:			
1744:	0B14  21100B  	z8ecmd:	ld	hl,z8e
1745:	0B17  E5      		push	hl
1746:	0B18  112528  		ld	de,prompt	;display prompt (asterisk)
1747:	0B1B  CD6C27  		call	nprint
1748:	0B1E  21852D  		ld	hl,jstepf	;full screen debugging in effect?
1749:	0B21  7E      		ld	a,(hl)
1750:	0B22  A7      		and	a
1751:	0B23  200C    		jr	nz,z8e10	;nz - no
1752:			
1753:	0B25  0E0A    		ld	c,10
1754:	0B27  CD2025  		call	spaces		;If this was jdbg clear command line residue
1755:	0B2A  060A    		ld	b,10
1756:	0B2C  CD3927  	z8e00:	call	bksp
1757:	0B2F  10FB    		djnz	z8e00
1758:			
1759:	0B31  CDCC24  	z8e10:	call	inchar		;Read in command character
1760:			
1761:			; +++ jrs 3.5.6 ++++++++++++++++++
1762:	0B34  FE0D    		cp	cr		;+Check for empty command line
1763:	0B36  2012    		jr	nz,z8e16	;+Something there - process it
1764:	0B38  3A3528  		ld	a,(lcmd)	;+Nothing - see if S or J was last command
1765:	0B3B  FE4A    		cp	'J'		;+Repeat 'J' command?
1766:	0B3D  CA870C  		jp	z,jdbg00	;+
1767:	0B40  210100  		ld	hl,1		;+
1768:	0B43  FE53    		cp	'S'		;+Repeat 'S' command?
1769:	0B45  CA7414  		jp	z,step40	;+
1770:	0B48  3E0D    		ld	a,cr		;+
1771:	0B4A          	z8e16:				;+
1772:			; ++++++++++++++++++++++++++++++++
1773:	0B4A  CD0325  		call	ixlt		;Translate to upper case for compare
1774:	0B4D  323528  		ld	(lcmd),a
1775:	0B50  FE4A    		cp	'J'		;If command is anything but J then indicate
1776:							;that screen is corrupted.  At next invokation
1777:							;jdbg will know to repaint the screen.
1778:	0B52  2803    		jr	z,z8e20
1779:	0B54  32852D  		ld	(jstepf),a	;Full screen flag nz - full screen debugging
1780:							;in progress
1781:			
1782:			
1783:	0B57  011B00  	z8e20:	ld	bc,ncmd		;total number of commands
1784:	0B5A  21FB27  		ld	hl,cmd		;table of ascii command characters
1785:	0B5D  EDB1    		cpir
1786:	0B5F  C2780C  		jp	nz,e???		;command letter not found in table
1787:	0B62  21C527  		ld	hl,jtcmd	;command jump table
1788:	0B65  09      		add	hl,bc
1789:	0B66  09      		add	hl,bc		;index into table
1790:	0B67  5E      		ld	e,(hl)		;lo order command processing routine
1791:	0B68  23      		inc	hl
1792:	0B69  56      		ld	d,(hl)		;upper address
1793:	0B6A  0E03    		ld	c,3
1794:	0B6C  CD2025  		call	spaces		;print spaces regardless
1795:	0B6F  EB      		ex	de,hl		;hl - address of command processing routine
1796:	0B70  E9      		jp	(hl)
1797:			
1799:			;******************************************************************************
1800:			;*
1801:			;*	bphn:	Breakpoint handler - rst38s land here
1802:			;*
1803:			;*		bphn   - bphn00	  save all user registers
1804:			;*		bphn10 - bphn20	  check that user pc matches entry in brktbl.
1805:			;*		bphn80		  special single step processing.
1806:			;*
1807:			;*	Note:	Sbps is both a flag and the count of the number of step bps.
1808:			;*		Sbps is set to 1 merely to indicate that the single-stepping
1809:			;*		is in effect.  Then the number of step bps is added to one.
1810:			;*		Hence, if 1 step bp was set then  sbps = 2 and if 2 step bps
1811:			;*		were set (conditional jump, call, ret) sbps = 3.
1812:			;*
1813:			;******************************************************************************
1814:			
1815:	0B71  22F72D  	bphn:	ld	(hlreg),hl	;save user hl
1816:	0B74  E1      		pop	hl		;pop breakpoint pc from stack
1817:	0B75  ED73032E		ld	(spreg),sp	;save user sp
1818:	0B79  ED7B120B		ld	sp,(z8esp)	;switch to our stack
1819:	0B7D  2B      		dec	hl		;point to location of rst instruction
1820:	0B7E  22012E  		ld	(pcreg),hl	;save user pc
1821:	0B81  ED53F52D		ld	(dereg),de	;save user de
1822:	0B85  ED43F32D		ld	(bcreg),bc	;save user bc
1823:	0B89  F5      		push	af
1824:	0B8A  E1      		pop	hl		;user accumulator and flag to hl
1825:	0B8B  22F12D  		ld	(afreg),hl	;save user af
1826:	0B8E  ED57    		ld	a,i
1827:	0B90  67      		ld	h,a		;save user i reg
1828:	0B91  ED5F    		ld	a,r
1829:	0B93  6F      		ld	l,a		;save user r reg
1830:	0B94  22092E  		ld	(rreg),hl
1831:	0B97  08      		ex	af,af'		;Bank In Prime Regs
1832:	0B98  D9      		exx
1833:	0B99  22FF2D  		ld	(hlpreg),hl	;save
1834:	0B9C  ED53FD2D		ld	(depreg),de
1835:	0BA0  ED43FB2D		ld	(bcpreg),bc
1836:	0BA4  F5      		push	af
1837:	0BA5  E1      		pop	hl
1838:	0BA6  22F92D  		ld	(afpreg),hl
1839:	0BA9  DD22052E		ld	(ixreg),ix	;save user ix
1840:	0BAD  FD22072E		ld	(iyreg),iy	;save user iy
1841:	0BB1  3A682D  		ld	a,(bps)
1842:	0BB4  A7      		and	a		;check for zero bp count
1843:	0BB5  CA690C  		jp	z,bp???		;error - no bps set
1844:	0BB8  47      		ld	b,a		;b - number of breakpoints
1845:	0BB9  219B2D  		ld	hl,brktbl	;breakpoint storage table
1846:	0BBC  AF      		xor	a
1847:	0BBD  4F      		ld	c,a		;init breakpoint found flag
1848:	0BBE  5E      	bphn10:	ld	e,(hl)
1849:	0BBF  23      		inc	hl
1850:	0BC0  56      		ld	d,(hl)		;de - breakpoint address
1851:	0BC1  23      		inc	hl
1852:	0BC2  7E      		ld	a,(hl)		;saved contents of breakpoint address
1853:	0BC3  23      		inc	hl
1854:	0BC4  12      		ld	(de),a		;replace rst 38 with actual data
1855:	0BC5  3A012E  		ld	a,(pcregl)	;user pc - lo order
1856:	0BC8  AB      		xor	e
1857:	0BC9  5F      		ld	e,a		;versus breakpoint address in table
1858:	0BCA  3A022E  		ld	a,(pcregh)
1859:	0BCD  AA      		xor	d		;check hi order
1860:	0BCE  B3      		or	e
1861:	0BCF  2001    		jr	nz,bphn20	;no match - check next entry in table
1862:	0BD1  48      		ld	c,b		;pc found in table set c reg nz
1863:	0BD2  10EA    	bphn20:	djnz	bphn10		;restore all user data
1864:	0BD4  21672D  		ld	hl,sbps		;fetch number of step bps (0-2)
1865:	0BD7  46      		ld	b,(hl)
1866:	0BD8  AF      		xor	a
1867:	0BD9  77      		ld	(hl),a		;clear regardless
1868:	0BDA  B1      		or	c		;test bp found flag
1869:	0BDB  CA690C  		jp	z,bp???		;z - bp not in table
1870:	0BDE  23      		inc	hl		;point to bp count
1871:	0BDF  56      		ld	d,(hl)		;d - bp count
1872:	0BE0  05      		dec	b
1873:	0BE1  FAF30B  		jp	m,bphn30	;m - this was user bp not step or jdbg
1874:	0BE4  7E      		ld	a,(hl)
1875:	0BE5  90      		sub	b		;subtract number of step bps from bp count
1876:	0BE6  77      		ld	(hl),a		;restore bp count
1877:	0BE7  3A3528  		ld	a,(lcmd)	;what command got us here?
1878:	0BEA  FE53    		cp	'S'		;step?
1879:	0BEC  2861    		jr	z,bphn90	;step command - check count
1880:			
1881:							;now we know we have jdbg in progress.  Need
1882:							;to check for user specified bp at the same
1883:							;address. If we find one stop trace.
1884:	0BEE  78      		ld	a,b		;number of step bps to accumulator (1 or 2).
1885:			
1886:	0BEF  91      		sub	c		;compare number of step bps with the offset
1887:							;into the bp table where the current bp was
1888:							;found.  Since step bps are always at the end
1889:							;of the table we can determine how bp was set.
1890:			
1891:	0BF0  D2340D  	 	jp	nc,jdbg30	;nc - we are at end of table so more tracing
1892:			
1893:	0BF3  79      	bphn30:	ld	a,c
1894:	0BF4  ED44    		neg
1895:	0BF6  82      		add	a,d		;create index into pass count table
1896:	0BF7  87      		add	a,a
1897:	0BF8  21D12D  		ld	hl,psctbl	;pass count table
1898:	0BFB  85      		add	a,l
1899:	0BFC  6F      		ld	l,a
1900:	0BFD  3001    		jr	nc,bphn35
1901:	0BFF  24      		inc	h
1902:	0C00  5E      	bphn35:	ld	e,(hl)
1903:	0C01  23      		inc	hl
1904:	0C02  56      		ld	d,(hl)		;de - pass count
1905:	0C03  7A      		ld	a,d
1906:	0C04  B3      		or	e
1907:	0C05  2813    		jr	z,bphn50	;no count in effect
1908:	0C07  1B      		dec	de
1909:	0C08  72      		ld	(hl),d
1910:	0C09  2B      		dec	hl
1911:	0C0A  73      		ld	(hl),e		;restored updated count
1912:	0C0B  7A      		ld	a,d
1913:	0C0C  B3      		or	e		;did it just go zero?
1914:	0C0D  280B    		jr	z,bphn50	;count just expired
1915:	0C0F  78      		ld	a,b		;pass count not zero - go or jdbg?
1916:	0C10  A7      		and	a
1917:	0C11  F2340D  		jp	p,jdbg30	;if step flag p we had step bps
1918:	0C14  2A012E  		ld	hl,(pcreg)
1919:	0C17  C33A13  		jp	g100		;continue go command
1920:	0C1A  B0      	bphn50:	or	b		;test if we had step bps
1921:	0C1B  FA300C  		jp	m,bphn60	;this was go - print bp message
1922:	0C1E  3E58    		ld	a,'X'
1923:	0C20  323528  		ld	(lcmd),a	;clear command letter so xreg disassembles
1924:	0C23  CD9324  		call	home		;home cursor
1925:	0C26  CD931E  		call	xreg
1926:	0C29  0616    		ld	b,22		;cursor on penultimate line
1927:	0C2B  0E00    		ld	c,00
1928:	0C2D  CD9624  		call	xycp
1929:			
1930:	0C30  111D28  	bphn60:	ld	de,bpmsg	;print *bp*
1931:	0C33  CD6F27  		call	print		;print message pointed to by de
1932:	0C36  2A012E  		ld	hl,(pcreg)
1933:	0C39  CD3025  		call	outadr		;display breakpoint address
1934:	0C3C  EB      		ex	de,hl
1935:	0C3D  CD0624  		call	fadr		;attempt to find label at this address
1936:	0C40  EB      		ex	de,hl		;de - bp address
1937:	0C41  C2100B  		jp	nz,z8e		;nz - no label found
1938:	0C44  3A7E2D  		ld	a,(maxlen)
1939:	0C47  3D      		dec	a
1940:	0C48  4F      		ld	c,a		;c - max size of label
1941:	0C49  CD7827  		call	printb
1942:	0C4C  C3100B  		jp	z8e
1943:	0C4F  CD931E  	bphn90:	call	xreg		;display all registers
1944:	0C52  2A652D  		ld	hl,(nstep)	;fetch trace count
1945:	0C55  2B      		dec	hl
1946:	0C56  7D      		ld	a,l
1947:	0C57  B4      		or	h
1948:	0C58  CA100B  		jp	z,z8e		;count expired - prompt for command
1949:	0C5B  CD5824  		call	ttyq		;test for abort trace
1950:	0C5E  FE0D    		cp	cr
1951:	0C60  CA100B  		jp	z,z8e
1952:	0C63  CD0C25  		call	crlf		;
1953:	0C66  C37414  		jp	step40		;continue trace
1954:			
1955:			
1956:	0C69  111628  	bp???:	ld	de,bpemsg
1957:	0C6C  CD6F27  		call	print
1958:	0C6F  2A012E  		ld	hl,(pcreg)
1959:	0C72  CD3025  		call	outadr
1960:	0C75  C3100B  		jp	z8e
1961:			
1962:			
1963:	0C78  EB      	e???:	ex	de,hl
1964:	0C79  113628  		ld	de,em???
1965:	0C7C  CD6F27  		call	print
1966:	0C7F  EB      		ex	de,hl
1967:	0C80  C9      		ret
1968:			
1969:	0000          		 if	auxprt
2029:				 endif
2030:			
2032:			;******************************************************************************
2033:			;*
2034:			;*	jdbg:	Animated debugger
2035:			;*
2036:			;*	Jdbg allows the user to watch the Z80 CPU actually execute the
2037:			;*	code.  Jdbg displays 18 disassembled instructions on the screen
2038:			;*	as well as a user defined memory block referred to in the
2039:			;*	comments as a window.
2040:			;*
2041:			;*	Entry point jdbg:
2042:			;*
2043:			;*	Jdbg processes user input as a prelude to the actual animation
2044:			;*	of the code.  The user enters the starting address to animate
2045:			;*	optionally preceded by a subroutine qualifier.  The subroutine
2046:			;*	qualifier may be either a "*" which instructs Z8E not to trace
2047:			;*	any subroutines which are located below 100h (ie. bdos calls),
2048:			;*	or it may be a "/" which means no tracing of any subroutines.
2049:			;*	Jdbg will also paint the original screen with the register
2050:			;*	contents as well as the memory window.  The contents of the
2051:			;*	memory window are also moved into argbuf so that we can compare
2052:			;*	the 'old' contents with the 'new' contents once a the first bp
2053:			;*	is reached.
2054:			;*
2055:			;*	Entry point jdbg30:
2056:			;*
2057:			;* 	Entered here via bphn who determines that animation is in
2058:			;*	effect.  In order to cut down on superfluous cursor move-
2059:			;*	ment on the screen we compare the old register and memory
2060:			;*	window contents with the new contents following the latest
2061:			;*	bp.  We only output the changes.  Next we determine if the
2062:			;*	current pc exists in disassembled form somewhere on the
2063:			;*	screen; if not, we display 18 new disassembled instructions
2064:			;*	with the current pc as line one.
2065:			;*
2066:			;*	Exit jdbg95:
2067:			;*
2068:			;*	Save current register contents and jump to step40 for next
2069:			;*	single step.
2070:			;*
2071:			;******************************************************************************
2072:			
2073:	0C81          	jdbg:
2074:	0C81  CD7E26  		call	iedtbc		;get command line
2075:	0C84  F2AA0C  		jp	p,jdbg02	;p - have input
2076:			
2077:	0C87  21862D  	jdbg00:	ld	hl,lastro
2078:	0C8A  46      		ld	b,(hl)		;row position of arrow on screen
2079:	0C8B  0E12    		ld	c,18		;column
2080:	0C8D  CD9624  		call	xycp
2081:	0C90  0E02    		ld	c,2
2082:	0C92  CD2025  		call	spaces
2083:	0C95  0617    		ld	b,17h
2084:	0C97  0E00    		ld	c,00
2085:	0C99  CD9624  		call	xycp
2086:	0C9C  21852D  		ld	hl,jstepf
2087:	0C9F  7E      		ld	a,(hl)
2088:	0CA0  3601    		ld	(hl),1
2089:	0CA2  A7      		and	a
2090:	0CA3  CA240E  		jp	z,jdbg90	;J was last means screen intact - just move
2091:							;arrow, else fall thru and repaint screen.
2092:							;Indicate single step
2093:	0CA6          	jdbg01:				;+ eg 3.3.6
2094:	0CA6  3E0A    		ld	a,10
2095:	0CA8  183F    		jr	jdbg10		;init timer
2096:			
2097:	0CAA  7E      	jdbg02:	ld	a,(hl)		;check first char of input
2098:	0CAB  FE23    		cp	'#'		;+ eg 3.3.6
2099:	0CAD  2007    		jr	nz,jdbg2a	;+ Skip if not repaint request
2100:	0CAF  21852D  		ld	hl,jstepf	;+
2101:	0CB2  3601    		ld	(hl),1		;+ Signal repaint request
2102:	0CB4  18F0    		jr	jdbg01		;+
2103:	0CB6          	jdbg2a:				;+
2104:	0CB6  EB      		ex	de,hl		;de - save input buffer address
2105:	0CB7  21642D  		ld	hl,wflag	;wflag tells us whether to trace subroutines
2106:							;or walk around them
2107:	0CBA  36FF    		ld	(hl),0ffh	;conditionally assume trace all
2108:	0CBC  D62F    		sub	'/'		;slash means don't trace any
2109:	0CBE  2805    		jr	z,jdbg03	;
2110:	0CC0  C605    		add	a,'/'-'*'	;check for star - no trace of bdos subs
2111:	0CC2  2004    		jr	nz,jdbg05
2112:	0CC4  3C      		inc	a		;set flag one to indicate no trace of subs
2113:							;at address < 100h (bdos calls)
2114:	0CC5  77      	jdbg03:	ld	(hl),a		;set wflag
2115:	0CC6  AF      		xor	a		;if slash or space replace with null in inbf
2116:							;so parser will ignore
2117:	0CC7  12      		ld	(de),a
2118:	0CC8  CDA025  	jdbg05:	call	iarg		;now evaluate address
2119:	0CCB  280C    		jr	z,jdbg08	;z - no error
2120:	0CCD  3A542E  		ld	a,(inbfnc)	;check number of characters
2121:	0CD0  3D      		dec	a		;check for just / or just *
2122:	0CD1  28B4    		jr	z,jdbg00	;treat as single step
2123:	0CD3  32852D  		ld	(jstepf),a	;indicate screen corrupted
2124:	0CD6  C3780C  		jp	e???		;error -
2125:	0CD9  22012E  	jdbg08:	ld	(pcreg),hl	;save address at which to start tracing
2126:	0CDC  A7      		and	a		;check delimter
2127:	0CDD  3E0A    		ld	a,10		;no delimeter use default timer value
2128:	0CDF  2808    		jr	z,jdbg10
2129:	0CE1  CDA025  		call	iarg		;check if user wants non-default timer
2130:	0CE4  3E0A    		ld	a,10
2131:	0CE6  2001    		jr	nz,jdbg10	;error - use default
2132:	0CE8  7D      		ld	a,l		;a - timer value as entered by user
2133:	0CE9  32752D  	jdbg10:	ld	(timer),a
2134:	0CEC  0618    		ld	b,24		;xmit crlf's to clear screen
2135:	0CEE  CD0C25  	jdbg15:	call	crlf		;clear screen
2136:	0CF1  10FB    		djnz	jdbg15
2137:	0CF3  CD720E  		call	rgdisp		;display current user regs
2138:	0CF6  CD400E  		call	zwnw		;display disassembled window
2139:	0CF9  3A972D  		ld	a,(wnwsiz)
2140:	0CFC  A7      		and	a		;test if window being displayed
2141:	0CFD  2830    		jr	z,jdbg28
2142:	0CFF  11292E  		ld	de,window	;save user specified memory block til next bp
2143:	0D02  2A952D  		ld	hl,(wnwtab)	;start of memory window address
2144:	0D05  010300  		ld	bc,3
2145:	0D08  3A822D  	jdbg20: ld	a,(fwndow)	;position cursor starting at column
2146:	0D0B  D606    		sub	6
2147:	0D0D  CD7E0E  		call	curs
2148:	0D10  CD3025  	       	call	outadr		;display address of memory window
2149:	0D13  3A822D  	jdbg25:	ld	a,(fwndow)
2150:	0D16  CD7E0E  		call	curs		;column position on screen of memory window
2151:							;is (rel pos * 3) + (fwndow)
2152:	0D19  7E      		ld	a,(hl)		;display this byte
2153:			
2154:	0D1A  12      		ld	(de),a		;save this byte in window between bps
2155:	0D1B  CD3A25  		call	outhex
2156:	0D1E  04      		inc	b		;move and display user specifed number
2157:							;of bytes (wnwsiz)
2158:	0D1F  3A972D  		ld	a,(wnwsiz)
2159:	0D22  90      		sub	b
2160:	0D23  280A    		jr	z,jdbg28
2161:	0D25  23      		inc	hl
2162:	0D26  13      		inc	de
2163:	0D27  3A832D  		ld	a,(nlmask)	;check for new line time
2164:	0D2A  A0      		and	b
2165:	0D2B  20E6    		jr	nz,jdbg25	;not end of line - display next byte else...
2166:	0D2D  18D9    		jr	jdbg20		;...display address first
2167:	0D2F  3E03    	jdbg28:	ld	a,3		;point to very first instruction
2168:	0D31  C3E80D  		jp	jdbg75
2169:			
2170:			
2171:							;breakpoint handler jumps here for full
2172:							;screen single step
2173:	0D34  0E03    	jdbg30:	ld  	c,3
2174:	0D36  CD2025  		call	spaces		;remove => from screen
2175:	0D39  41      		ld	b,c		;(c=0 after spaces executes)
2176:	0D3A  21F12D  		ld	hl,regcon	;new contents of registers following bp
2177:	0D3D  11112E  		ld	de,regsav	;old prior to bp
2178:	0D40  1A      	jdbg35:	ld	a,(de)		;compare old vs new
2179:	0D41  BE      		cp	(hl)
2180:	0D42  23      		inc	hl
2181:	0D43  13      		inc	de
2182:	0D44  2004    		jr	nz,jdbg40	;different - display new
2183:	0D46  1A      		ld	a,(de)		;check hi order byte of this reg pair
2184:	0D47  BE      		cp	(hl)
2185:	0D48  2827    		jr	z,jdbg45	;z - hi and lo bytes the same so try next reg
2186:	0D4A          	jdbg40:
2187:			;	ld	a,4		;col position of reg pair is (rel pos * 9) + 3
2188:			;	and	b
2189:			;	jr	z,jdbg42
2190:			;	ld	a,3
2191:			;	and	b		;- 9 bytes deleted here
2192:			;	inc	a
2193:	0D4A  C5      		push	bc		;+save register number
2194:	0D4B  48      		ld	c,b		;+move it to c while we build line number
2195:	0D4C  0600    		ld	b,0		;+assume first line for now
2196:	0D4E  3E07    		ld	a,7		;+regs-per-line mask
2197:	0D50  B9      		cp	c		;+generate carry if second line
2198:	0D51  CB10    		rl	b		;+shift carry into line number
2199:	0D53  A1      		and	c		;+generate line-relative register number
2200:	0D54  4F      		ld	c,a		;+col = reg * 9 + 3 if non-prime
2201:	0D55  87      		add	a,a		;+ *2
2202:	0D56  87      		add	a,a		;+ *4
2203:	0D57  87      		add	a,a		;+ *8
2204:	0D58  81      		add	a,c		;+ *9
2205:	0D59  CB51    		bit	2,c		;+is it a prime (alternate) register?
2206:	0D5B  2803    		jr	z,jdbg42	;+skip if not
2207:	0D5D  81      		add	a,c		;+*10
2208:	0D5E  D603    		sub	3		;+col = reg * 10 if prime
2209:	0D60          	jdbg42:
2210:	0D60  C603    		add	a,3		;+
2211:	0D62  4F      		ld	c,a		;+
2212:	0D63  CD9624  		call	xycp		;+
2213:	0D66  C1      		pop	bc		;+ added 29 bytes
2214:			
2215:			;	add	a,3		;- deleted another 5 bytes here
2216:			;	call	curs		;- nett cost = 14 bytes for new code
2217:			;				;- but we save 19 bytes in 'curs:' routine
2218:			
2219:	0D67  7E      		ld	a,(hl)		;display upper byte of reg contents
2220:	0D68  CD3A25  		call	outhex
2221:	0D6B  2B      		dec	hl		;rewind to pick up lo order byte
2222:	0D6C  7E      		ld	a,(hl)
2223:	0D6D  23      		inc	hl
2224:	0D6E  CD3A25  		call	outhex		;display lo order
2225:	0D71  23      	jdbg45:	inc	hl
2226:	0D72  13      		inc	de
2227:	0D73  04      		inc	b
2228:	0D74  3E0C    		ld	a,regsiz/2	;number of reg pairs to display
2229:	0D76  90      		sub	b
2230:	0D77  20C7    		jr	nz,jdbg35
2231:	0D79  CD1925  		call	space1
2232:	0D7C  0601    		ld	b,1
2233:	0D7E  0E24    		ld	c,36
2234:	0D80  CD9624  		call	xycp
2235:			
2236:	0D83  0600    		ld	b,0
2237:	0D85  CDC81A  		call	pswDsp		;now display flag reg mnemonics
2238:			
2239:	0D88  3A972D  		ld	a,(wnwsiz)	;check window size
2240:	0D8B  A7      		and	a
2241:	0D8C  2821    		jr	z,jdbg60	;z - no memory window in effect
2242:	0D8E  2A952D  		ld	hl,(wnwtab)	;hl - address of start of window
2243:	0D91  010300  		ld	bc,03
2244:	0D94  11292E  		ld	de,window	;old contents of window stored here
2245:	0D97  1A      	jdbg50:	ld	a,(de)		;compare old vs new
2246:	0D98  BE      		cp	(hl)
2247:	0D99  280B    		jr	z,jdbg55	;same - no reason to display
2248:	0D9B  3A822D  		ld	a,(fwndow)	;col position of byte is (rel pos * 3) + 50
2249:	0D9E  CD7E0E  		call	curs
2250:	0DA1  7E      		ld	a,(hl)		;display byte
2251:			
2252:	0DA2  12      		ld	(de),a		;we only need to move byte if it changed
2253:			
2254:	0DA3  CD3A25  		call	outhex
2255:	0DA6  04      	jdbg55:	inc	b		;bump memory window byte count
2256:	0DA7  3A972D  		ld	a,(wnwsiz)  	;max size
2257:	0DAA  23      		inc	hl
2258:	0DAB  13      		inc	de
2259:	0DAC  90      		sub	b
2260:	0DAD  20E8    		jr	nz,jdbg50	;loop until entire window examined
2261:			
2262:	0DAF  3E12    	jdbg60:	ld	a,18		;init count of disassembled instructions
2263:	0DB1  326B2D  		ld	(jlines),a
2264:	0DB4  ED5B5A2D		ld	de,(zasmfl)	;address of first disassembled instruction
2265:							;on screen
2266:	0DB8  2A012E  	jdbg65:	ld	hl,(pcreg)
2267:	0DBB  A7      		and	a
2268:	0DBC  ED52    		sbc	hl,de
2269:	0DBE  2821    		jr	z,jdbg70	;found - pc exists somewhere on screen
2270:	0DC0  CDC419  		call	zlen00		;compute length of this instruction
2271:	0DC3  0600    		ld	b,0
2272:	0DC5  EB      		ex	de,hl		;hl - address on disassembled instruction
2273:	0DC6  09      		add	hl,bc		;add length to compute address of next inline
2274:							;instruction for display
2275:	0DC7  EB      		ex	de,hl		;de - restore new istruction pointer
2276:	0DC8  216B2D  		ld	hl,jlines
2277:	0DCB  35      		dec	(hl)		;dec screen line count
2278:	0DCC  20EA    		jr	nz,jdbg65
2279:	0DCE  2A012E  		ld	hl,(pcreg)	;pc not on screen - so current pc will be new
2280:							;first pc on screen
2281:	0DD1  225A2D  		ld	(zasmfl),hl
2282:	0DD4  010003  		ld	bc,0300h	;cursor row 4 - col 1
2283:	0DD7  CD9624  		call	xycp
2284:	0DDA  CD400E  		call	zwnw		;instruction not on screen so paint a new
2285:							;screen starting at current pc
2286:	0DDD  3E03    		ld	a,3		;disassembled instructions start on line 4
2287:	0DDF  1807    		jr	jdbg75
2288:	0DE1  3A6B2D  	jdbg70:	ld	a,(jlines)
2289:	0DE4  ED44    		neg
2290:	0DE6  C615    		add	a,21		;a - screen row on which to position cursor
2291:	0DE8  32862D  	jdbg75:	ld	(lastro),a	;save position of arrow
2292:	0DEB  47      		ld	b,a		;pass to xycp
2293:	0DEC  0E12    		ld	c,18		;pass column
2294:	0DEE  CD9624  		call	xycp		;position cursor routine
2295:	0DF1  112928  		ld	de,mrrow
2296:	0DF4  CD6F27  		call	print
2297:	0DF7  3A862D  		ld	a,(lastro)	;xy positioning added after '=>' as
2298:							;some systems have a destructive bs
2299:	0DFA  0E11    		ld	c,17		;new cursor loc
2300:	0DFC  CD9624  		call	xycp		;put it there
2301:	0DFF  3A852D  		ld	a,(jstepf)
2302:	0E02  3D      		dec	a		;test if single stepping
2303:	0E03  CA320E  		jp	z,jdbg95
2304:	0E06  CD5824  		call	ttyq
2305:	0E09  21752D  		ld	hl,timer
2306:	0E0C  46      		ld	b,(hl)
2307:	0E0D  2812    		jr	z,jdbg80
2308:	0E0F  FE30    		cp	'0'
2309:	0E11  380A    		jr	c,jdbg78
2310:	0E13  FE3A    		cp	3ah
2311:	0E15  301B    		jr	nc,jdbg95
2312:	0E17  E60F    		and	0fh
2313:	0E19  77      		ld	(hl),a
2314:	0E1A  47      		ld	b,a
2315:	0E1B  1804    		jr	jdbg80
2316:	0E1D  FE0D    	jdbg78:	cp	cr		;carriage return ends command
2317:	0E1F  2811    		jr	z,jdbg95
2318:			
2319:	0E21  CDA50E  	jdbg80:	call	clok
2320:			
2321:	0E24  11112E  	jdbg90:	ld	de,regsav	;move current reg contents to save area
2322:	0E27  21F12D  		ld	hl,regcon
2323:	0E2A  011800  		ld	bc,regsiz
2324:	0E2D  EDB0    		ldir
2325:	0E2F  C37414  		jp	step40
2326:			
2327:			
2328:							;user requested abort from console
2329:	0E32  0616    	jdbg95: ld	b,22		;position cursor on line 23 for prompt
2330:	0E34  0E00    		ld	c,0
2331:	0E36  CD9624  		call	xycp
2332:	0E39  AF      		xor	a
2333:	0E3A  32852D  		ld	(jstepf),a	;indicate we have full screen of data
2334:	0E3D  C3100B  		jp	z8e		;to z8e command processor
2335:			
2336:			
2337:			
2338:	0E40          	zwnw:				;display disassembly window
2339:	0E40  3E12    		ld	a,18		;number of instructions to disassemble
2340:	0E42  2A012E  	zwnw05:	ld	hl,(pcreg)
2341:	0E45  225A2D  		ld	(zasmfl),hl	;save pc of first line
2342:	0E48  326B2D  	zwnw10:	ld	(jlines),a
2343:	0E4B  22582D  		ld	(zasmpc),hl	;save here as well
2344:	0E4E  11D32E  		ld	de,zasmbf+96	;disassemble in upper portion of buffer to
2345:							;prevent overlap with big memory windows.
2346:							;otherwise, every time we disassemble a new
2347:							;screen we have to repaint the window.
2348:			
2349:	0E51  CD4A1F  		call	zasm10		;disassemble first instruction
2350:	0E54  3E1E    		ld	a,30		;test line length
2351:	0E56  B9      		cp	c
2352:	0E57  2802    		jr	z,zwnw20
2353:	0E59  0E2A    		ld	c,42
2354:	0E5B  CD7827  	zwnw20:	call	printb
2355:	0E5E  CD0C25  		call	crlf
2356:	0E61  2A5C2D  		ld	hl,(zasmnx)	;hl - next address to disassemble
2357:	0E64  3A6B2D  		ld	a,(jlines)
2358:	0E67  3D      		dec	a
2359:	0E68  20DE    		jr	nz,zwnw10
2360:	0E6A  0603    		ld	b,3		;position cursor next to next instruction
2361:							;to execute which is the first one on the
2362:							;screen - line 4  col 20
2363:	0E6C  0E14    		ld	c,20
2364:	0E6E  CD9624  		call	xycp
2365:	0E71  C9      		ret
2366:			
2367:			
2368:							;display regs at top of screen:
2369:	0E72  CD9324  	rgdisp:	call	home		;home cursor
2370:	0E75  CD931E  		call	xreg		;display regs
2371:	0E78  CDC81A  		call	pswDsp		;display flag reg
2372:	0E7B  C30C25  		jp	crlf
2373:			
2374:			
2375:			
2376:	0E7E  C5      	curs:	push	bc		;This routine has been simplified and shortened
2377:	0E7F  D5      		push	de		;by 19 bytes because it is no longer used for
2378:	0E80  E5      		push	hl		;register display positioning.  jrs 20/4/87
2379:	0E81  57      		ld	d,a
2380:	0E82  59      		ld	e,c		;save base row address
2381:			;	cp	3		;test if reg or memory window (3 is reg)
2382:			;	ld	a,7
2383:			;	jr	z,curs00	;z - regs are eight per line (first line)
2384:			
2385:	0E83  3A832D  		ld	a,(nlmask)
2386:	0E86  A0      	curs00:	and	b		;item number mod lnmask is the relative pos of
2387:	0E87  4F      		ld	c,a		;reg contents or memory data byte
2388:	0E88  87      		add	a,a		;
2389:	0E89  81      		add	a,c
2390:	0E8A  4F      		ld	c,a		;c - rel pos times three
2391:			
2392:			;	ld	a,d		;if base column address is < 50 then this is
2393:							;reg display
2394:			;	sub	3
2395:			;	ld	h,a
2396:			;	ld	a,c
2397:			;	jr	nz,curs20	;nz - not reg display - must be memory
2398:			;	add	a,a		;so multiply times three again
2399:			;	add	a,c		;times 9 in all for register display
2400:			
2401:	0E8B  82      	curs20:	add	a,d		;add in base
2402:	0E8C  4F      		ld	c,a		;c - absolute col number
2403:			;	xor	a		;test if this is reg or memory window display
2404:			;	or	h
2405:			;	jr	z,curs30	;z - this is register display
2406:	0E8D  3A822D  		ld	a,(fwndow)
2407:	0E90  FE44    		cp	68		;14-char symbols in effect?
2408:	0E92  CA970E  		jp	z,curs40
2409:	0E95  CB38    	curs30:	srl	b
2410:	0E97  3EFC    	curs40:	ld	a,0fch
2411:	0E99  A0      		and	b		;now compute row number
2412:	0E9A  0F      		rrca
2413:	0E9B  0F      		rrca
2414:	0E9C  83      		add	a,e		;base row address
2415:	0E9D  47      		ld	b,a		;b - absolute row number
2416:	0E9E  CD9624  		call	xycp		;convert row and column to xy cursor address
2417:	0EA1  E1      		pop	hl
2418:	0EA2  D1      		pop	de
2419:	0EA3  C1      		pop	bc
2420:	0EA4  C9      		ret
2421:			
2422:			
2423:			
2424:	0EA5          	clok:
2425:	0EA5  1632    		ld	d,50  		;idle loop - decrement to 0 and reload
2426:	0EA7  1E00    		ld	e,00
2427:	0EA9  05      		dec	b		;user specified the loop counter
2428:	0EAA  F8      		ret	m
2429:	0EAB  1B      	clok10:	dec	de
2430:	0EAC  7B      		ld	a,e
2431:	0EAD  B2      		or	d
2432:	0EAE  20FB    		jr	nz,clok10
2433:	0EB0  18F3    		jr	clok
2434:			
2436:			;******************************************************************************
2437:			;*
2438:			;*	exam:	Examine memory and display in hex and ascii.  User is allowed
2439:			;*		to modify memory after every byte is displayed. Ilin called
2440:			;*		to parse input buffer into a single string of bytes which is
2441:			;*		returned in argbuf.  The byte count of the string is returned
2442:			;*		in argbc, and this number of bytes is transferred to the
2443:			;*		current memory address.
2444:			;*
2445:			;*		User may optionally scan memory by entering cr.  Command
2446:			;*		terminates when a single space is entered.
2447:			;*
2448:			;*		Enter:	B - 0
2449:			;*		       DE - address at which to display first byte
2450:			;*
2451:			;******************************************************************************
2452:			
2453:	0EB2  CD5525  	exam:	call	ilin
2454:	0EB5  C2780C  		jp	nz,e???
2455:	0EB8  EB      		ex	de,hl
2456:	0EB9  CD2725  	exam00:	call	newlin
2457:	0EBC  1A      		ld	a,(de)		;fetch byte to display regardless
2458:	0EBD  CD2E26  		call	outbyt
2459:	0EC0  CD3E26  		call	dbyte
2460:	0EC3  20F4    		jr	nz,exam00 	;nz - don't replace memory contents
2461:	0EC5  FE2E    		cp	'.'
2462:	0EC7  2005    		jr	nz,exam10
2463:	0EC9  3A542E  		ld	a,(inbfnc)
2464:	0ECC  3D      		dec	a
2465:	0ECD  C8      		ret	z
2466:	0ECE  210D2E  	exam10:	ld	hl,argbc	;byte count to c
2467:	0ED1  4E      		ld	c,(hl)
2468:	0ED2  0600    		ld	b,0
2469:	0ED4  ED535C2D		ld	(exampt),de
2470:	0ED8  21112E  		ld	hl,argbf	;start of evaluated input
2471:	0EDB  EDB0    		ldir
2472:	0EDD  3A772D  		ld	a,(trmntr)
2473:	0EE0  FE0D    		cp	cr
2474:	0EE2  28D5    		jr	z,exam00
2475:	0EE4  ED5B5C2D		ld	de,(exampt)
2476:	0EE8  18CF    		jr	exam00
2477:			
2479:			;------------------------------------------------------------------------------
2480:			;
2481:			;	hsym:	Display symbol table
2482:			;
2483:			;	User may display the symbol table on the console.  If no arg
2484:			;	entered on command line then the entire table is dumped start-
2485:			;	ing with the first symbol.  If a valid symbol is entered then
2486:			;	we will try to find the symbol in the table; if found, the
2487:			;	table is dumped starting at that point.  If the symbol is not
2488:			;	found the user gets a ? and the command terminates.
2489:			;
2490:			;	Symbols are displayed in blocks of 32.  After each block the
2491:			;	user is given the opportunity of continuing or ending the
2492:			;	command:
2493:			;
2494:			;		cr - Terminate			\  jrs 27 Dec 88
2495:			;	    not cr - Display next block		/  v 3.5.1
2496:			;
2497:			;------------------------------------------------------------------------------
2498:			
2499:	0EEA  CD5525  	hsym:	call	ilin		;Read in line of data
2500:	0EED  21100B  		ld	hl,z8e		;Assume no symbol entered
2501:	0EF0  200F    		jr	nz,hsym10	;NZ - no input means display entire table
2502:	0EF2  11A72E  		ld	de,prsbf
2503:	0EF5  CDC418  		call	fsym		;Attempt to find this symbol name in table
2504:	0EF8  C2780C  		jp	nz,e???		;Error - symbol not found in symbol table
2505:	0EFB  3A7E2D  		ld	a,(maxlen)
2506:	0EFE  B5      		or	l		;Point to next symbol table entry (next block)
2507:	0EFF  6F      		ld	l,a		;HL - ptr to last byte in this entry
2508:	0F00  23      		inc	hl		;Now next entry toward hi memory
2509:	0F01  3A7E2D  	hsym10:	ld	a,(maxlen)	;Max size of symbol name
2510:	0F04  4F      		ld	c,a
2511:	0F05  0D      		dec	c
2512:	0F06  3C      		inc	a		;Make 8 or 16
2513:	0F07  5F      		ld	e,a
2514:	0F08  AF      		xor	a
2515:	0F09  57      		ld	d,a		;DE - size of symbol table entry
2516:	0F0A  ED52    		sbc	hl,de		;Previous entry toward low memory
2517:	0F0C  7E      		ld	a,(hl)		;Null means this is unused slot is user
2518:							;defined symbol table
2519:	0F0D  A7      		and	a
2520:	0F0E  28F1    		jr	z,hsym10
2521:	0F10  3D      		dec	a		;Neg means this is jp opcode (0c3h) of jump to
2522:							;BDOS
2523:	0F11  F8      		ret	m
2524:	0F12  3A7E2D  		ld	a,(maxlen)
2525:	0F15  CB3F    		srl	a
2526:	0F17  CB3F    		srl	a
2527:	0F19  EE02    		xor	2
2528:	0F1B  A0      		and	b		;Check symbols per line count
2529:	0F1C  CC0C25  		call	z,crlf		;crlf every fourth
2530:	0F1F  05      		dec	b		;Now decrement symbols per line count
2531:	0F20  CD7827  		call	printb		;Treat symbol table entry as a buffer and
2532:							;Six chars or until null, whichever is first
2533:	0F23  0C      		inc	c		;Tack on two spaces
2534:	0F24  0C      		inc	c
2535:	0F25  CD2025  		call	spaces
2536:	0F28  3A7E2D  		ld	a,(maxlen)
2537:	0F2B  B5      		or	l		;Point to last byte in symbol table block
2538:	0F2C  6F      		ld	l,a
2539:	0F2D  56      		ld	d,(hl)		;Upper byte of symbol address
2540:	0F2E  2B      		dec	hl
2541:	0F2F  5E      		ld	e,(hl)		;Low order
2542:	0F30  EB      		ex	de,hl
2543:	0F31  CD3025  		call	outadr		;HL - symbol address to display
2544:	0F34  0E04    		ld	c,4
2545:	0F36  CD2025  		call	spaces		;Next symbol name starts 4 spaces to the right
2546:	0F39  EB      		ex	de,hl		;HL - symbol table pointer
2547:	0F3A  3A7E2D  		ld	a,(maxlen)
2548:	0F3D  2F      		cpl
2549:	0F3E  A5      		and	l		;Rewind to point to byte zero of entry
2550:	0F3F  6F      		ld	l,a
2551:	0F40  78      		ld	a,b
2552:	0F41  E61F    		and	31		;Displayed block of 32 symbols?
2553:	0F43  20BC    		jr	nz,hsym10
2554:	0F45  CD0C25  		call	crlf
2555:	0F48  CD6F24  		call	ttyi		;Test if user wants abort
2556:	0F4B  FE0D    		cp	cr
2557:	0F4D  20B2    		jr	nz,hsym10	;Not CR - continue (jrs v3.5.1)
2558:	0F4F  C9      		ret			;CR - end command
2559:			
2561:			;*****************************************************************************
2562:			;*
2563:			;*	usym:   write symbol table to disk
2564:			;*
2565:			;*****************************************************************************
2566:			
2567:	0F50  CD7E26  	usym:	call	iedtbc		;get a command line
2568:	0F53  F8      		ret	m		;no input ends command
2569:	0F54  CD4822  		call	bldf		;build fcb
2570:	0F57  C2971D  		jp	nz,esntx	;syntax error
2571:	0F5A  21100B  		ld	hl,z8e		;start at beginning
2572:	0F5D  3A4F2D  		ld	a,(symflg)	;do we even have a symbol table?
2573:	0F60  A7      		and	a
2574:	0F61  C0      		ret	nz		;no table - end command
2575:	0F62  0680    		ld	b,128		;disk write buffer size
2576:	0F64  325C2D  		ld	(lines),a	;clear symbols per line counter
2577:	0F67  114F2E  		ld	de,symbuf
2578:	0F6A  3A7E2D  	usym10:	ld	a,(maxlen)
2579:	0F6D  4F      		ld	c,a		;max size of symbol name
2580:	0F6E  2F      		cpl
2581:	0F6F  A5      		and	l		;rewind to byte zero of symbol table entry
2582:	0F70  6F      		ld	l,a
2583:	0F71  78      		ld	a,b		;temp save buffer count
2584:	0F72  0600    		ld	b,0
2585:	0F74  ED42    		sbc	hl,bc
2586:	0F76  2B      		dec	hl		;point to 8 or 16 byte boundary
2587:	0F77  47      		ld	b,a		;restore buffer count
2588:			
2589:	0F78  7E      		ld	a,(hl)		;null means this is unused slot in user
2590:							;defined symbol table
2591:	0F79  A7      		and	a
2592:	0F7A  28EE    		jr	z,usym10
2593:	0F7C  3D      		dec	a		;neg means this is jp opcode (0c3h) of jump to
2594:							;bdos
2595:	0F7D  F28D0F  		jp	p,usym20
2596:	0F80  CDC30F  		call	pcrlf		;hit end of table - put crlf in buffer
2597:	0F83  3E1A    		ld	a,eof
2598:	0F85  0601    		ld	b,1		;force buffer write
2599:	0F87  CDDB0F  		call	putc		;put eof in file
2600:	0F8A  C30D22  		jp	closef		;this is a wrap
2601:			
2602:	0F8D  3A7E2D  	usym20:	ld	a,(maxlen)
2603:	0F90  B5      		or	l
2604:	0F91  6F      		ld	l,a		;point to hi order byte of symbol address
2605:	0F92  CDCC0F  		call	pbin		;put address in buffer
2606:	0F95  3E20    		ld	a,' '
2607:	0F97  CDDB0F  		call	putc		;followed by space just like l80
2608:	0F9A  3A7E2D  		ld	a,(maxlen)
2609:	0F9D  2F      		cpl
2610:	0F9E  A5      		and	l		;rewind to byte zero of symbol entry
2611:	0F9F  6F      		ld	l,a
2612:			
2613:	0FA0  0D      		dec	c		;14 Sep 85   restore maxlen size as count
2614:			
2615:	0FA1  7E      	usym25:	ld	a,(hl)		;fetch char of symbol name
2616:	0FA2  A7      		and	a		;null?
2617:	0FA3  2809    		jr	z,usym40	;name is less than 6 chars long
2618:	0FA5  CDDB0F  		call	putc		;put valid symbol name chars in buffer
2619:	0FA8  0D      		dec	c
2620:	0FA9  2803    		jr	z,usym40	;z - just moved last char
2621:	0FAB  23      		inc	hl
2622:	0FAC  18F3    		jr	usym25
2623:	0FAE  3E09    	usym40:	ld	a,tab		;tab separates name and next address
2624:	0FB0  CDDB0F  		call	putc		;insert tab before address field
2625:	0FB3  3A5C2D  		ld	a,(lines)
2626:	0FB6  3D      		dec	a
2627:	0FB7  325C2D  		ld	(lines),a
2628:	0FBA  E603    		and	3		;insert crlf every fourth symbol
2629:	0FBC  20AC    		jr	nz,usym10
2630:	0FBE  CDC30F  		call	pcrlf
2631:	0FC1  18A7    		jr	usym10
2632:			
2633:			
2634:			
2635:	0FC3  3E0D    	pcrlf:	ld	a,cr
2636:	0FC5  CDDB0F  		call	putc
2637:	0FC8  3E0A    		ld	a,lf
2638:	0FCA  180F    		jr	putc
2639:			
2640:			
2641:							;convert two byte binary address to ascii
2642:							;and put into buffer
2643:	0FCC  CDD00F  	pbin:	call	pbin00
2644:	0FCF  2B      		dec	hl
2645:	0FD0  7E      	pbin00:	ld	a,(hl)
2646:	0FD1  CD4825  		call	binx
2647:	0FD4  CDDB0F  		call	putc
2648:	0FD7  7E      		ld	a,(hl)
2649:	0FD8  CD4C25  		call	binx00
2650:			
2651:			
2652:	0FDB  12      	putc:	ld	(de),a		;just like pascal - put char into buffer
2653:	0FDC  13      		inc	de
2654:	0FDD  05      		dec	b		;buffer count passed in b
2655:	0FDE  C0      		ret	nz
2656:	0FDF  114F2E  	putc00:	ld	de,symbuf	;hit end of buffer - reinit pointer to start
2657:	0FE2  CD2C22  		call	bwrite		;write current buffer [ras 14 sep 85]
2658:	0FE5  0680    		ld	b,128		;reinit tally
2659:	0FE7  C9      		ret
2660:			
2662:			;------------------------------------------------------------------------------
2663:			;
2664:			;	dump:  Dump memory in hex and ASCII
2665:			;
2666:			;	Memory is dumped in hex and ASCII in user-specified block size.
2667:			;	If the D command is given without arguments then memory is dumped
2668:			;	beginning at the address where we left off as store in blkptr.
2669:			;	User is queried after each block is dumped:
2670:			;
2671:			;		cr - End command			\  v 3.5.1
2672:			;	    Not	cr - Dump next consecutive block	/  jrs 27 Dec 88
2673:			;
2674:			;------------------------------------------------------------------------------
2675:			
2676:	0FE8  CD7E26  	dump:	call	iedtbc		;Solicit input
2677:	0FEB  F2F70F  		jp	p,dump00	;p - input present
2678:	0FEE  ED5B502D		ld	de,(bsiz)	;No input means use previous block size
2679:	0FF2  2A522D  		ld	hl,(blkptr)	;   ... and address
2680:	0FF5  1823    		jr	dump30
2681:	0FF7  CDA025  	dump00:	call	iarg		;Read in next arg (starting address)
2682:	0FFA  C2780C  		jp	nz,e???		;Invalid starting address
2683:	0FFD  EB      		ex	de,hl		;DE - starting address to dump
2684:	0FFE  CDA025  		call	iarg		;Next arg (block size)
2685:	1001  2805    		jr	z,dump15	;Z - no errors
2686:	1003  210000  		ld	hl,000		;Default to block size of 256
2687:	1006  1809    		jr	dump20
2688:	1008  AF      	dump15:	xor	a
2689:	1009  B4      		or	h		;Test for block size or ending address
2690:	100A  2805    		jr	z,dump20	;Less than 256 must be block size
2691:	100C  ED52    		sbc	hl,de		;Compute size
2692:	100E  DA780C  		jp	c,e???
2693:	1011  7D      	dump20:	ld	a,l
2694:	1012  B4      		or	h
2695:	1013  2001    		jr	nz,dump25
2696:	1015  24      		inc	h
2697:	1016  22502D  	dump25:	ld	(bsiz),hl
2698:	1019  EB      		ex	de,hl		;DE - block size   HL - memory pointer
2699:	101A  0610    	dump30:	ld	b,16		;Init bytes-per-line count
2700:	101C  CD5824  		call	ttyq
2701:	101F  FE0D    		cp	cr
2702:	1021  C8      		ret	z
2703:	1022  CD0C25  		call	crlf		;Display current address on new line
2704:	1025  CD3025  		call	outadr
2705:	1028  0E02    		ld	c,2
2706:	102A  CD2025  		call	spaces		;Hex display starts two spaces right
2707:	102D  05      	dump40:	dec	b		;Decrement column count
2708:	102E  7E      		ld	a,(hl)
2709:	102F  23      		inc	hl
2710:	1030  CD1625  		call	othxsp		;Display memory in hex
2711:	1033  0C      		inc	c		;Tally of hex bytes displayed
2712:	1034  1B      		dec	de		;Decrement block count
2713:	1035  7A      		ld	a,d
2714:	1036  B3      		or	e		;Test for end of block
2715:	1037  2806    		jr	z,dump50	;Z - end of block
2716:	1039  AF      		xor	a
2717:	103A  B0      		or	b		;End of line?
2718:	103B  20F0    		jr	nz,dump40	;Not end of line - dump more in hex
2719:	103D  181B    		jr	dump60
2720:	103F  3A512D  	dump50:	ld	a,(bsizhi)
2721:	1042  A7      		and	a		;Block size greater than 256?
2722:	1043  2007    		jr	nz,dump55	;NZ - greater
2723:	1045  3A502D  		ld	a,(bsizlo)
2724:	1048  E6F0    		and	0f0h		;Block size less than 16?
2725:	104A  280E    		jr	z,dump60	;Z - less
2726:	104C  3A502D  	dump55:	ld	a,(bsizlo)
2727:	104F  E60F    		and	0fh		;Block size multiple of 16?
2728:	1051  2807    		jr	z,dump60	;Multiple of 16
2729:	1053  ED44    		neg
2730:	1055  C610    		add	a,16
2731:	1057  47      		ld	b,a
2732:	1058  87      		add	a,a
2733:	1059  80      		add	a,b
2734:	105A  C603    	dump60:	add	a,3		;Plus three - begin ASCII display
2735:	105C  47      		ld	b,a		;Pad line until ASCII display area
2736:	105D  CD1925  	dump70:	call	space1
2737:	1060  10FB    		djnz	dump70
2738:	1062  ED42    		sbc	hl,bc		;Rewind memory point by like amount
2739:	1064  7E      	dump80:	ld	a,(hl)		;Start ASCII display
2740:	1065  23      		inc	hl
2741:	1066  CD4427  		call	asci
2742:	1069  0D      		dec	c
2743:	106A  20F8    		jr	nz,dump80
2744:	106C  CD5824  		call	ttyq		;CR aborts command
2745:	106F  FE0D    		cp	cr
2746:	1071  CA100B  		jp	z,z8e
2747:	1074  7A      		ld	a,d		;Test for block size tally expired
2748:	1075  B3      		or	e
2749:	1076  20A2    		jr	nz,dump30
2750:	1078  ED5B502D		ld	de,(bsiz)	;Reinit block size
2751:	107C  CD6F24  		call	ttyi		;Query user for more
2752:	107F  FE0D    		cp	cr
2753:			; Next two lines replaced by inverted test - 27 Dec 88 - jrs - V 3.5.1
2754:			;	call	z,crlf
2755:			;	jr	z,dump30	;not cr - next block
2756:			;----				(Comment on last line is wrong anyway!)
2757:	1081  C40C25  		call	nz,crlf		;Not cr - next block
2758:	1084  2094    		jr	nz,dump30
2759:			;----
2760:	1086  22522D  		ld	(blkptr),hl
2761:	1089  C9      		ret			;end command
2762:			
2764:			;******************************************************************************
2765:			;*
2766:			;*	rgst:  Display and optionally modify individual registers
2767:			;*
2768:			;*	call iedt:   read edited input into inbf
2769:			;*	call prsr:   parse input
2770:			;*	call mreg:   validate register name and map into reg storage
2771:			;*	call iarg:   query user for replacement
2772:			;*
2773:			;******************************************************************************
2774:			
2775:	108A  0E20    	rgst:	ld	c,' '		;get edited input
2776:	108C  0652    		ld	b,inbfsz
2777:	108E  CD8526  		call	iedt
2778:	1091  F8      		ret	m
2779:	1092  3A772D  		ld	a,(trmntr)
2780:	1095  FE20    		cp	' '
2781:	1097  CC3927  		call	z,bksp
2782:	109A  CD2719  		call	prsr
2783:	109D  B0      		or	b		;unbalanced quotes (prime reg?)
2784:	109E  F2AE10  		jp	p,rgst00
2785:	10A1  E67F    		and	7fh
2786:	10A3  FE03    		cp	3
2787:	10A5  2063    		jr	nz,rgst25
2788:	10A7  2B      		dec	hl
2789:	10A8  7E      		ld	a,(hl)
2790:	10A9  D627    		sub	quote
2791:	10AB  205D    		jr	nz,rgst25
2792:	10AD  77      		ld	(hl),a
2793:	10AE  3A542E  	rgst00:	ld	a,(inbfnc)	;number of characters in buffer
2794:	10B1  FE04    		cp	4
2795:	10B3  3055    		jr	nc,rgst25	;error - too many chars
2796:	10B5  ED44    		neg
2797:	10B7  C604    		add	a,4		;calculate space padding
2798:	10B9  4F      		ld	c,a
2799:	10BA  FE03    		cp	3		;was it one?
2800:	10BC  200B    		jr	nz,rgst10
2801:	10BE  1A      		ld	a,(de)
2802:	10BF  CD0325  		call	ixlt
2803:	10C2  FE50    		cp	'P'
2804:	10C4  2003    		jr	nz,rgst10
2805:	10C6  32542E  		ld	(inbfnc),a	;any number > 2 indicates 16 bit register
2806:	10C9  CD2025  	rgst10:	call	spaces
2807:	10CC  7E      		ld	a,(hl)		;check last char in parse buffer
2808:	10CD  D627    		sub	quote
2809:	10CF  2001    		jr	nz,rgst15	;not quote
2810:	10D1  77      		ld	(hl),a		;replace with null
2811:	10D2  CD1F11  	rgst15:	call	mreg		;validate register name
2812:	10D5  2033    		jr	nz,rgst25	;error
2813:	10D7  3A762D  		ld	a,(regtrm)	;mreg stored char following reg name
2814:	10DA  A7      		and	a
2815:	10DB  202D    		jr	nz,rgst25	;error - no operators allowed
2816:	10DD  3A542E  		ld	a,(inbfnc)	;now check number of chars in buffer
2817:	10E0  47      		ld	b,a		;save in b reg for 8 or 16 bit reg test
2818:	10E1  3D      		dec	a		;test for one - 8 bit reg
2819:	10E2  0E03    		ld	c,3
2820:	10E4  2807    		jr	z,rgst20
2821:	10E6  7E      		ld	a,(hl)
2822:	10E7  CD3A25  		call	outhex		;display byte of reg contents
2823:	10EA  2B      		dec	hl
2824:	10EB  0E01    		ld	c,1
2825:	10ED  7E      	rgst20:	ld	a,(hl)
2826:	10EE  CD1625  		call	othxsp
2827:	10F1  CD2025  		call	spaces		;reg c - number of spaces to print
2828:	10F4  EB      		ex	de,hl		;de - save reg contents pointer
2829:	10F5  CD6125  	rgst22:	call	istr		;query user for reg value replacement
2830:	10F8  3A542E  		ld	a,(inbfnc)	;test number of chars in input buffer
2831:	10FB  3D      		dec	a		;
2832:	10FC  FA1611  		jp	m,rgst40	;none - prompt for next reg name
2833:	10FF  CD6D25  		call	irsm
2834:	1102  280B    		jr	z,rgst30
2835:	1104  3A542E  		ld	a,(inbfnc)
2836:	1107  A7      		and	a
2837:	1108  28EB    		jr	z,rgst22
2838:	110A  CD780C  	rgst25:	call	e???
2839:	110D  1807    		jr	rgst40		;accept new reg name
2840:	110F  EB      	rgst30:	ex	de,hl
2841:	1110  73      		ld	(hl),e
2842:	1111  05      		dec	b		;test for 16 bit reg
2843:	1112  2802    		jr	z,rgst40	;z - 8 bit reg
2844:	1114  23      		inc	hl
2845:	1115  72      		ld	(hl),d		;save upper byte of user input
2846:	1116  CD0C25  	rgst40:	call	crlf
2847:	1119  CD1E25  		call	space5
2848:	111C  C38A10  		jp	rgst
2849:			
2850:			
2851:			
2852:	111F  0E17    	mreg:	ld	c,23		;number of reserved operands
2853:	1121  CD2917  		call	oprn00		;check validity of register name
2854:	1124  1A      		ld	a,(de)		;last char examined by operand routine
2855:	1125  CDAC19  		call	oprtor
2856:	1128  C0      		ret	nz		;error - not null or valid operator
2857:	1129  32762D  		ld	(regtrm),a	;save terminator character for rgst
2858:	112C  79      		ld	a,c
2859:	112D  FE11    		cp	17		;valid reg names are less than 17
2860:	112F  3805    		jr	c,mreg00	;so far so good
2861:	1131  D617    		sub	23		;last chance - may be pc
2862:	1133  C0      		ret	nz		;error - invalid reg name
2863:	1134  3E0A    		ld	a,10		;make pc look like p for mapping
2864:	1136  21302D  	mreg00:	ld	hl,regmap	;ptrs to register contents storage
2865:	1139  85      		add	a,l		;index into table by operand value
2866:	113A  6F      		ld	l,a
2867:	113B  3001    		jr	nc,mreg05
2868:	113D  24      		inc	h
2869:	113E  78      	mreg05:	ld	a,b		;b reg set m by prsr if trailing quote
2870:	113F  A7      		and	a
2871:	1140  3E00    		ld	a,0		;assume no quote - not prime reg
2872:	1142  F24711  		jp	p,mreg10	;p - correct assumption
2873:	1145  3E08    		ld	a,8		;bias pointer for prime reg contents
2874:	1147  86      	mreg10:	add	a,(hl)
2875:	1148  4F      		ld	c,a		;save mapping byte
2876:	1149  E67F    		and	7fh		;strip sign
2877:							;so iarg knows 16 bit reg pair
2878:	114B  21F12D  		ld	hl,regcon	;use mapping byte to build pointer
2879:	114E  85      		add	a,l
2880:	114F  6F      		ld	l,a
2881:	1150  3001    		jr	nc,mreg50
2882:	1152  24      		inc	h
2883:	1153  AF      	mreg50:	xor	a		;hl - pointer to register contents
2884:	1154  C9      		ret
2885:			
2887:			;******************************************************************************
2888:			;*
2889:			;*	qprt:	Read and display / write to i/o ports
2890:			;*
2891:			;*		Contents of ports are displayed and the user is queried
2892:			;*		input character effects the current port address:
2893:			;*
2894:			;*		space -	display next sequential port on same line
2895:			;*		lf    -	display next sequential port on new line
2896:			;*		cr    -	end command
2897:			;*		slash -	display same port on same line
2898:			;*		^     -	display previous port on new line
2899:			;*
2900:			;*		Any other input is treated as a replacement byte and
2901:			;*		is output to the current port address.  Any of the
2902:			;*		above characters may be used to continue the display.
2903:			;*
2904:			;*		enter: e  - port at which to begin display
2905:			;*
2906:			;******************************************************************************
2907:			
2908:	1155          	qprt:
2909:	1155          	nprt:
2910:	1155  AF      		xor	a
2911:	1156  326B2D  		ld	(parenf),a
2912:	1159  CD7E26  	  	call	iedtbc		;get port specified by user
2913:	115C  21992D  		ld	hl,port
2914:	115F  5E      		ld	e,(hl)
2915:	1160  FAAB11  		jp	m,qprt30	;m - no input means use last port number
2916:	1163  EB      		ex	de,hl
2917:	1164  CDA025  	        call	iarg		;extract address
2918:	1167  C2780C  		jp	nz,e???
2919:	116A  EB      		ex	de,hl 		;e - new port number
2920:	116B  73      		ld	(hl),e
2921:	116C  3A6B2D  		ld	a,(parenf)
2922:	116F  FE28    		cp	'('
2923:	1171  2038    		jr	nz,qprt30
2924:	1173  0E02    		ld	c,2
2925:	1175  CD2025  		call	spaces
2926:			
2927:			; Enter continuous monitor mode
2928:			
2929:	1178  4B      	qprt00:	ld	c,e
2930:			
2931:	0000          		if	h64180
2933:				endif
2934:			
2935:	1179  ED78    		in	a,(c)
2936:			
2937:	117B  47      		ld	b,a
2938:	117C  CD3A25  		call	outhex
2939:	117F  0E02    		ld	c,2
2940:	1181  CD2025  		call	spaces
2941:	1184  0E08    		ld	c,8		;number of bits to display
2942:	1186  CB20    	qprt10:	sla	b		;most significant bit to carry
2943:	1188  3E30    		ld	a,'0'
2944:	118A  CE00    		adc	a,0		;carry makes it a 1
2945:	118C  CD8224  		call	ttyo
2946:	118F  0D      		dec	c
2947:	1190  20F4    		jr	nz,qprt10
2948:	1192  4B      		ld	c,e
2949:	1193  0603    		ld	b,3
2950:	1195  CD5824  		call	ttyq
2951:	1198  FE0D    		cp	cr
2952:	119A  C8      		ret	z
2953:	119B  CDA50E  		call	clok		;so we don't go faster than the terminal
2954:	119E  59      		ld	e,c
2955:	119F  78      		ld	a,b
2956:	11A0  A7      		and	a
2957:	11A1  F0      		ret	p
2958:	11A2  060C    		ld	b,12
2959:	11A4  CD3927  	qprt20:	call	bksp
2960:	11A7  10FB    		djnz	qprt20
2961:	11A9  18CD    		jr	qprt00
2962:			
2963:			; Non-continuous monitor mode
2964:			
2965:	11AB  CD0C25  	qprt30:	call	crlf
2966:	11AE  7B      		ld	a,e
2967:	11AF  32992D  		ld	(port),a
2968:	11B2  CD1625  		call	othxsp		;output port address
2969:	11B5  CD1925  		call	space1
2970:	11B8  4B      		ld	c,e
2971:	11B9  3A3528  		ld	a,(lcmd)	;are we running N command?
2972:	11BC  FE4E    		cp	'N'
2973:	11BE  2805    		jr	z,qprt50	;if so, skip port reading
2974:			
2975:	0000          		if	h64180
2977:				endif
2978:			
2979:	11C0  ED78    	       	in	a,(c)		;read byte from port
2980:			
2981:	11C2  CD2E26  		call	outbyt		;output the byte in hex and ascii
2982:	11C5  CD3E26  	qprt50:	call	dbyte		;get and process argument string
2983:	11C8  3A772D  		ld	a,(trmntr)
2984:	11CB  200F    		jr	nz,qprt60	;if no replacement data, skip port update
2985:	11CD  FE2E    		cp	'.'		;else, user wants to exit?
2986:	11CF  C8      		ret	z		;return if so
2987:			
2988:	0000          		if	h64180
2997:				else
2998:	11D0  210D2E  		ld	hl,argbc
2999:	11D3  46      		ld	b,(hl)
3000:	11D4  21112E  		ld	hl,argbf
3001:	11D7  4B      		ld	c,e		;port number
3002:	11D8  EDB3    		otir
3003:				endif
3004:			
3005:	11DA  18CF    		jr	qprt30
3006:	11DC  FE20    	qprt60:	cp	' '
3007:	11DE  20CB    		jr	nz,qprt30
3008:	11E0  1B      		dec	de
3009:	11E1  18C8    		jr	qprt30
3010:			
3012:			;******************************************************************************
3013:			;*
3014:			;*	break:	Set breakpoint routine
3015:			;*
3016:			;*	Breakpoint address storage table (brktbl) is examined and user
3017:			;*	specified breakpoint is considered valid unless:
3018:			;*
3019:			;*		     - table full
3020:			;*		     - address already exists in table
3021:			;*
3022:			;*	Optional pass counts can be specified by the user immediatley following
3023:			;*	the breakpoint if they are enclosed in parens.
3024:			;*
3025:			;*	Entry point brk30:
3026:			;*	      Entered from single step command to set breakpoint.  Two table
3027:			;*	      slots are permanently available for step breakpoints. STEP
3028:			;*	      routine calls with C pos to tell us not to look for more args
3029:			;*	      in the input buffer.
3030:			;*
3031:			;******************************************************************************
3032:			
3033:	11E3  CD7E26  	break:	call	iedtbc
3034:	11E6  F8      		ret	m		;end command - no input
3035:	11E7  0EFF    		ld	c,0ffh		;set neg - distinguish ourselves from step
3036:	11E9  3A682D  	brk10:	ld	a,(bps)		;fetch current bp count
3037:	11EC  FE10    		cp	maxbp		;table full
3038:	11EE  D2780C  		jp	nc,e???		;full - abort command
3039:	11F1  47      		ld	b,a		;save current count
3040:	11F2  CDA025  		call	iarg
3041:	11F5  C2780C  		jp	nz,e???
3042:	11F8  EB      		ex	de,hl		;de - breakpoint address to set
3043:	11F9  219B2D  	brk30:	ld	hl,brktbl
3044:	11FC  AF      		xor	a
3045:	11FD  B0      		or	b		;check for no breakpoints in effect
3046:	11FE  2816    		jr	z,brk60		;none - bypass check for duplicate
3047:	1200  7B      	brk40:	ld	a,e
3048:	1201  BE      		cp	(hl)		;check lo order address match
3049:	1202  23      		inc	hl
3050:	1203  200D    		jr	nz,brk50	;no match - check next
3051:	1205  7A      		ld	a,d
3052:	1206  96      		sub	(hl)		;check hi order
3053:	1207  2009    		jr	nz,brk50	;no match - check next
3054:	1209  B1      		or	c
3055:	120A  F0      		ret	p
3056:	120B  21682D  		ld	hl,bps		;pointer to bp count
3057:	120E  7E      		ld	a,(hl)
3058:	120F  90      		sub	b		;create index into psctbl
3059:	1210  180C    		jr	brk70
3060:	1212  23      	brk50:	inc	hl
3061:	1213  23      		inc	hl		;bump past contents storage byte
3062:	1214  10EA    		djnz	brk40
3063:	1216  73      	brk60:	ld	(hl),e		;set in table
3064:	1217  23      		inc	hl
3065:	1218  72      		ld	(hl),d
3066:	1219  21682D  		ld	hl,bps		;breakpoint count
3067:	121C  7E      		ld	a,(hl)		;fetch current count for user as index
3068:	121D  34      		inc	(hl)		;bump bp count
3069:	121E  11D12D  	brk70:	ld	de,psctbl	;base of pass count table
3070:	1221  87      		add	a,a		;two byte table
3071:	1222  83      		add	a,e
3072:	1223  5F      		ld	e,a
3073:	1224  3001    		jr	nc,brk80
3074:	1226  14      		inc	d
3075:	1227  AF      	brk80:	xor	a
3076:	1228  12      		ld	(de),a		;pre-clear pass count table entry
3077:	1229  13      		inc	de
3078:	122A  12      		ld	(de),a
3079:	122B  B1      		or	c		;test if this was step calling
3080:	122C  F0      		ret	p		;i'm positive it was
3081:	122D  3A6C2D  		ld	a,(delim)	;check delimeter which followed bp address
3082:	1230  A7      		and	a
3083:	1231  C8      		ret	z		;end of line null - terminate command
3084:	1232  FE2C    		cp	','		;check for pass count delimeter
3085:	1234  C2E911  		jp	nz,brk10	;not comma means treat this as new bp
3086:	1237  CDA025  		call	iarg		;get next arg
3087:	123A  C2780C  		jp	nz,e???		;nz - evaluation error
3088:	123D  EB      		ex	de,hl		;de - pass count as entered by user
3089:	123E  72      		ld	(hl),d		;store pass count in table
3090:	123F  2B      		dec	hl
3091:	1240  73      		ld	(hl),e
3092:	1241  A7      		and	a		;check delimeter
3093:	1242  C2E911  		jp	nz,brk10	;nz - more arguments follow
3094:	1245  C9      		ret			;end of line null - terminate command
3096:			
3097:			;******************************************************************************
3098:			;*
3099:			;*	cbreak:	Clear breakpoint
3100:			;*
3101:			;*	Breakpoint address storage table (brktbl) is examined and breakpoint
3102:			;*	is removed if found. Breakpoint is removed by bubbling up all bp
3103:			;*	addresses which follow, ditto for pass counts.
3104:			;*
3105:			;******************************************************************************
3106:			
3107:	1246  CD7E26  	cbreak:	call	iedtbc
3108:	1249  F8      		ret	m		;no input ends command
3109:	124A  3A682D  		ld	a,(bps)		;fetch breakpoint count
3110:	124D  B7      		or	a		;any if effect
3111:	124E  C8      		ret	z		;no
3112:	124F  47      		ld	b,a		;temp save count
3113:	1250  CDA025  		call	iarg		;extract address to clear from input buffer
3114:	1253  119B2D  		ld	de,brktbl	;bp address storage table
3115:	1256  2813    		jr	z,cbrk10
3116:	1258  3AA72E  		ld	a,(prsbf)
3117:	125B  FE2A    		cp	'*'
3118:	125D  C2780C  		jp	nz,e???
3119:	1260  3A542E  		ld	a,(inbfnc)
3120:	1263  3D      		dec	a
3121:	1264  C2780C  		jp	nz,e???
3122:	1267  32682D  		ld	(bps),a
3123:	126A  C9      		ret
3124:			
3125:	126B  1A      	cbrk10:	ld	a,(de)		;test lo order address for match
3126:	126C  BD      		cp	l
3127:	126D  13      		inc	de
3128:	126E  2002    		jr	nz,cbrk20	;no match - examine next entry
3129:	1270  1A      		ld	a,(de)
3130:	1271  BC      		cp	h		;versus hi order bp address
3131:	1272  13      	cbrk20:	inc	de
3132:	1273  13      		inc	de		;bump past contents save location
3133:	1274  2805    		jr	z,cbrk30	;zero - found bp in table
3134:	1276  10F3    		djnz	cbrk10
3135:	1278  C3780C  		jp	e???		;error - breakpoint not found
3136:	127B  26FF    	cbrk30:	ld	h,0ffh		;rewind to point to bp address
3137:	127D  2EFD    		ld	l,-3
3138:	127F  19      		add	hl,de
3139:	1280  EB      		ex	de,hl		;de - ptr to bp   hl - ptr to next bp
3140:	1281  78      		ld	a,b		;multiply number of bps remaining in table
3141:							;times three bytes per entry
3142:	1282  87      		add	a,a
3143:	1283  80      		add	a,b
3144:	1284  4F      		ld	c,a		;init c for ldir
3145:	1285  78      		ld	a,b		;save number of bps remaining
3146:	1286  0600    		ld	b,0
3147:	1288  EDB0    		ldir			;bubble up all remaining entries in table
3148:	128A  4F      		ld	c,a		;
3149:	128B  21682D  		ld	hl,bps		;address of bp count
3150:	128E  7E      		ld	a,(hl)		;
3151:	128F  35      		dec	(hl)		;decrement system breakpoint count
3152:	1290  91      		sub	c		;compute relative number of pass count table
3153:							;entry we wish to clear
3154:	1291  87      		add	a,a		;times two bytes per entry
3155:	1292  6F      		ld	l,a
3156:	1293  60      		ld	h,b		;cheap clear
3157:	1294  11D12D  		ld	de,psctbl
3158:	1297  19      		add	hl,de		;index into pass count table
3159:	1298  EB      		ex	de,hl
3160:	1299  210200  		ld	hl,02
3161:	129C  19      		add	hl,de		;de - ptr to pass count  hl - next in table
3162:	129D  CB21    		sla	c		;number of pass counts to move
3163:	129F  EDB0    		ldir
3164:	12A1  3A6C2D  		ld	a,(delim)	;recheck delimeter
3165:	12A4  A7      		and	a
3166:	12A5  209F    		jr	nz,cbreak	;not end of line terminator - clear more
3167:	12A7  C9      		ret
3168:			
3170:			;***********************************************************************
3171:			;*
3172:			;*     obreak:	Output all breakpoints and associated pass counts to
3173:			;*		console.  Search symbol table for match, if symbol name
3174:			;*		found display it along with address.
3175:			;*
3176:			;*     wbreak:	wipe out (clear) all breakpoints currently in effect
3177:			;*
3178:			;*		entered:  b - zero
3179:			;*
3180:			;***********************************************************************
3181:			
3182:	12A8  3A682D  	obreak:	ld	a,(bps)		;fetch bp count
3183:	12AB  3D      		dec	a		;test for no breakpoints
3184:	12AC  F8      		ret	m		;m - none
3185:	12AD  47      		ld	b,a		;save count
3186:	12AE  219B2D  	obrk00:	ld	hl,brktbl	;base of breakpoint storage table
3187:	12B1  58      		ld	e,b		;use current breakpoint count as index
3188:	12B2  1600    		ld	d,0		;clear
3189:	12B4  19      		add	hl,de		;this is a three byte table
3190:	12B5  19      		add	hl,de
3191:	12B6  19      		add	hl,de
3192:	12B7  5E      		ld	e,(hl)		;fetch lo order bp address
3193:	12B8  23      		inc	hl
3194:	12B9  56      		ld	d,(hl)		;upper address
3195:	12BA  EB      		ex	de,hl
3196:	12BB  CD3025  		call	outadr		;display address
3197:	12BE  EB      		ex	de,hl		;hl - breakpoint table
3198:	12BF  CD0624  		call	fadr		;check symbol table for name match
3199:							;   symbol table pointer returned in de
3200:							;   zero flag set if found
3201:	12C2  3A7E2D  		ld	a,(maxlen)
3202:	12C5  4F      		ld	c,a
3203:	12C6  0B      		dec	bc		;max number of chars in a symbol name
3204:	12C7  EB      		ex	de,hl		;hl - symbol table address if
3205:	12C8  CC7827  		call	z,printb	;display name if found in symbol table
3206:	12CB  78      		ld	a,b
3207:	12CC  87      		add	a,a		;bp number times two
3208:	12CD  21D12D  		ld	hl,psctbl	;base of pass count table
3209:	12D0  85      		add	a,l
3210:	12D1  6F      		ld	l,a
3211:	12D2  3001    		jr	nc,obrk10
3212:	12D4  24      		inc	h
3213:	12D5  5E      	obrk10:	ld	e,(hl)		;lo order pass count
3214:	12D6  23      		inc	hl
3215:	12D7  56      		ld	d,(hl)		;upper byte
3216:	12D8  7A      		ld	a,d		;test if pass count in effect
3217:	12D9  B3      		or	e
3218:	12DA  2808    		jr	z,obrk20	;z - no pass count for this bp
3219:	12DC  0C      		inc	c
3220:	12DD  CD2025  		call	spaces
3221:	12E0  EB      		ex	de,hl
3222:	12E1  CD3025  		call	outadr		;display pass count in hex
3223:	12E4  CD0C25  	obrk20:	call	crlf
3224:	12E7  0E05    		ld	c,5
3225:	12E9  CD2025  		call	spaces
3226:	12EC  05      		dec	b		;dec bp count
3227:	12ED  F2AE12  		jp	p,obrk00
3228:	12F0  C9      		ret
3229:			
3230:			
3231:			
3232:	12F1  CD7E26  	kdmp:	call	iedtbc		;let user input address of memory to display
3233:	12F4  F8      		ret	m		;no input ends command
3234:	12F5  CDA025  		call	iarg		;evaluate user arg
3235:	12F8  C2780C  		jp	nz,e???
3236:	12FB  EB      		ex	de,hl		;de - save memory address
3237:	12FC  CDA025  		call	iarg		;now get count
3238:	12FF  3E00    		ld	a,0
3239:	1301  2018    		jr	nz,kdmp20	;error during input - display 00 bytes
3240:	1303  B4      		or	h
3241:	1304  C2780C  		jp	nz,e???		;greater than 256 is error
3242:	1307  3A7E2D  		ld	a,(maxlen)	;max symbol length
3243:	130A  0602    		ld	b,2		;assume big names
3244:	130C  FE0F    		cp	15
3245:	130E  3E12    		ld	a,18		;number of disassembled lines displayed
3246:	1310  2802    		jr	z,kdmp00
3247:	1312  0603    		ld	b,3		;double number of lines one extra time
3248:	1314  87      	kdmp00:	add	a,a		;times two
3249:	1315  10FD    		djnz	kdmp00
3250:	1317  BD      		cp	l
3251:	1318  3801    		jr	c,kdmp20	;if number of bytes specified by user is too
3252:							;large then use default
3253:	131A  7D      		ld	a,l		;use value specified by user
3254:	131B  ED53952D	kdmp20:	ld	(wnwtab),de
3255:	131F  32972D  		ld	(wnwsiz),a
3256:	1322  C9      		ret
3257:			
3259:			;**************************************************************************
3260:			;*
3261:			;*		     Begin/resume execution of user program
3262:			;*
3263:			;*	Address entered:     execution begins at entered address
3264:			;*	No address entered:  execution resumed at specified by saved pc
3265:			;*
3266:			;*	Breakpoint table examined:
3267:			;*	      -	memory contents from each address is removed from user
3268:			;*		program and saved in breakpoint table
3269:			;*	      -	rst 38 instruction is placed at each breakpoint address
3270:			;*		in user program
3271:			;*
3272:			;*	user registers restored
3273:			;*
3274:			;***************************************************************************
3275:			
3276:	1323  CD7E26  	go:	call	iedtbc		;query user for execution address
3277:			
3278:			;	ret	m		;- eg 3.3.3 no input - reprompt
3279:	1326  F22E13  		jp	p,g001		;+ Skip if argument supplied, else:
3280:	1329  2A012E  		ld	hl,(pcreg)	;+ Use current PC
3281:	132C  1806    		jr	g002		;+
3282:	132E          	g001:				;+
3283:	132E  CDA025  		call	iarg
3284:	1331  C2780C  		jp	nz,e???		;error - invalid argument
3285:	1334          	g002:				;+
3286:	1334  CD0C25  		call	crlf
3287:	1337  CD0C25  		call	crlf
3288:	133A  22732D  	g100:	ld	(jmplo),hl	;store execution address
3289:	133D  3EC3    		ld	a,zjp
3290:	133F  32722D  		ld	(zjmp),a	;set jp instruction
3291:	1342  326F2D  		ld	(jmp2jp),a	;just in case
3292:	1345  3A682D  		ld	a,(bps)		;check breakpoint count
3293:	1348  A7      		and	a
3294:	1349  CA0114  		jp	z,g600		;z - no bps in effect - no restoration needed
3295:	134C  47      		ld	b,a
3296:	134D  219B2D  		ld	hl,brktbl
3297:	1350  0EFF    		ld	c,0ffh
3298:	1352  5E      	g300:	ld	e,(hl)
3299:	1353  23      		inc	hl
3300:	1354  56      		ld	d,(hl)		;de - breakpoint address removed from table
3301:	1355  23      		inc	hl		;point to contents save byte in table
3302:	1356  1A      		ld	a,(de)
3303:	1357  77      		ld	(hl),a
3304:	1358  3A732D  		ld	a,(jmplo)
3305:	135B  BB      		cp	e		;check if bp from table matches next pc
3306:	135C  2009    		jr	nz,g400		;no match - set breakpoint
3307:	135E  3A742D  		ld	a,(jmphi)
3308:	1361  BA      		cp	d		;check hi order next pc address
3309:	1362  2003    		jr	nz,g400		;no match - set bp
3310:	1364  48      		ld	c,b		;set flag - current pc matches breakpoint
3311:	1365  1803    		jr	g500
3312:	1367  3EFF    	g400:	ld	a,rst38		;set rst38 instruction
3313:	1369  12      		ld	(de),a		;save user byte in brktbl
3314:	136A  23      	g500:	inc	hl
3315:	136B  10E5    		djnz	g300		;examine all entries
3316:	136D  0C      		inc	c		;current pc match breakpoint?
3317:	136E  CA0114  		jp	z,g600		;z - no (c reg not 0ffh)
3318:	1371  3A672D  		ld	a,(sbps)	;check number of step breakpoints
3319:	1374  A7      		and	a		;tracing?
3320:	1375  C20114  		jp	nz,g600		;nz - this is trace
3321:			
3322:							;PC points to address in breakpoint table
3323:							;next instruction will not be executed where
3324:							;it resides.  It will be moved to our internal
3325:							;buffer (execbf) and executed there. Then we
3326:							;set an rst38 at actual location in user
3327:							;program.  This allows us to debug loops in
3328:							;which only one bp is set.  Otherwise we would
3329:							;not be able to set a bp at the address where
3330:							;the PC points and debugging loops would be
3331:							;impossible.
3332:	1378  216B2D  		ld	hl,execbf
3333:	137B  ED5B732D		ld	de,(jmplo)	;de - pointer to next instruction to execute
3334:	137F  22732D  		ld	(jmplo),hl	;execute buffer
3335:	1382  0604    		ld	b,4		;clear execute buffer
3336:	1384  3600    	g505:	ld	(hl),znop
3337:	1386  23      		inc	hl
3338:	1387  10FB    		djnz	g505
3339:	1389  CDC419  		call	zlen00		;calculate length
3340:							;if instruction modifies PC then zlen lets us
3341:							;know by setting B reg nz and C contains
3342:							;instruction length
3343:			
3344:	138C  227A2D  		ld	(jropnd),hl	;if this is a jr instruction we need to save
3345:							;address where we will be jumping
3346:			
3347:			
3348:							;default execbf has been initialized:
3349:							;
3350:							;four nops
3351:							;     jp   user program
3352:							;
3353:	138F  EB      		ex	de,hl		;hl - ptr to user instruction
3354:	1390  116B2D  		ld	de,execbf
3355:	1393  7E      		ld	a,(hl)		;first object byte from user program
3356:	1394  36FF    	g518:	ld	(hl),rst38	;replace
3357:	1396  C5      		push	bc		;b - if nz this is a pc modifying instruction
3358:							;c - number of bytes of object code for this
3359:							;    instruction
3360:	1397  12      	g520:	ld	(de),a		;into execute buffer
3361:	1398  13      		inc	de
3362:	1399  23      		inc	hl		;bump user program pointer
3363:	139A  7E      		ld	a,(hl)		;next byte of instruction from user program
3364:	139B  0D      		dec	c
3365:	139C  20F9    		jr	nz,g520
3366:	139E  C1      		pop	bc
3367:							;the four nops in execbf have now been replaced
3368:							;by from one to four bytes of actual user
3369:							;instruction.  If user instruction was shorter
3370:							;than four bytes the nops remain and are
3371:							;executed until the jump back to the user
3372:							;program at jmp2jp is reached.
3373:			
3374:			
3375:	139F  22702D  		ld	(jmp2),hl	;address of next inline instruction within
3376:							;user code
3377:			
3378:	13A2  EB      		ex	de,hl		;de - next inline instruction in user program
3379:	13A3  AF      		xor	a
3380:	13A4  B0      		or	b
3381:	13A5  285A    		jr	z,g600		;z - the instruction in execbf is not a PC
3382:							;modifying instruction
3383:			
3384:	13A7  3A6B2D  		ld	a,(execbf)	;first byte of instruction
3385:	13AA  0D      		dec	c		;one byte instruction?
3386:	13AB  2854    		jr	z,g600
3387:	13AD  0D      		dec	c
3388:	13AE  2827    		jr	z,g550		;two byter
3389:	13B0  0D      		dec	c
3390:	13B1  204E    		jr	nz,g600		;nz - must be four byter
3391:	13B3  41      		ld	b,c		;clear for cpir
3392:	13B4  0E09    		ld	c,z803sl	;test for call instruction
3393:	13B6  21CC28  		ld	hl,z803s	;load list of first byte of call instructions
3394:	13B9  EDB1    		cpir
3395:	13BB  2044    		jr	nz,g600		;nz - not call
3396:			
3397:							;moving call instructions and executing them
3398:							;locally requires special processing because
3399:							;the Z80 will store the address pc+3 on the
3400:							;stack.  In this case we do not want the
3401:							;address execbf+3 on the stack.  We want the
3402:							;address of the actual location of the user
3403:							;instruction+3 on the stack.  We must do this
3404:							;by simulating a call instruction. We use the
3405:							;jp instruction which is equivalent to the
3406:							;call and we also push a computed return
3407:							;address on to the user stack pointed to by
3408:							;spreg.
3409:			
3410:	13BD  010800  		ld	bc,08		;point to jump instruction which is equivalent
3411:							;to call (call nz = jp nz)
3412:	13C0  09      		add	hl,bc
3413:	13C1  7E      		ld	a,(hl)		;fetch jump object byte
3414:	13C2  2A032E  		ld	hl,(spreg)	;push next pc onto user stack
3415:	13C5  2B      		dec	hl		;decrement user sp
3416:	13C6  72      		ld	(hl),d		;de - "return address"
3417:	13C7  2B      		dec	hl
3418:	13C8  73      		ld	(hl),e
3419:	13C9  22032E  		ld	(spreg),hl
3420:	13CC  326B2D  		ld	(execbf),a	;store jp op code
3421:	13CF  21702D  		ld	hl,jmp2		;if conditional call and we fall thru
3422:							;we need to go back to address of call
3423:							;in user program + 3
3424:	13D2  73      		ld	(hl),e
3425:	13D3  23      		inc	hl
3426:	13D4  72      		ld	(hl),d
3427:	13D5  182A    		jr	g600
3428:							;if next instruction to execute is a
3429:							;relative jump we need to replace it with
3430:							;an absolute equivalent.  This is because
3431:							;having relocated the user jr instruction
3432:							;into execbf we will undoubtedly be out of
3433:							;range of the destination.
3434:			
3435:	13D7  0E06    	g550:	ld	c,z802cl	;check if this is relative jump
3436:	13D9  21BE28  		ld	hl,z802c
3437:	13DC  A7      		and	a		;clear carry
3438:	13DD  EDB1    		cpir
3439:	13DF  2020    		jr	nz,g600		;not a jr
3440:	13E1  79      		ld	a,c
3441:	13E2  01BE28  		ld	bc,z802c
3442:	13E5  ED42    		sbc	hl,bc
3443:	13E7  2B      		dec	hl
3444:	13E8  01D528  		ld	bc,z803c
3445:	13EB  09      		add	hl,bc		;point to equivalent absolute jump
3446:	13EC  A7      		and	a
3447:	13ED  7E      		ld	a,(hl)
3448:	13EE  216B2D  		ld	hl,execbf
3449:	13F1  2005    		jr	nz,g555		;nz - not last in list (not djnz)
3450:			
3451:							;replace djnz with  dec   b
3452:							;		    jp    nz,
3453:			
3454:	13F3  3605    		ld	(hl),05		;dec b instruction
3455:	13F5  23      		inc	hl
3456:	13F6  3EC2    		ld	a,0c2h		;jp nz absolute
3457:	13F8  77      	g555:	ld	(hl),a
3458:	13F9  23      		inc	hl
3459:	13FA  ED4B7A2D		ld	bc,(jropnd)	;if this is a conditional jr we need the
3460:							;absolute destination of the jump
3461:	13FE  71      		ld	(hl),c
3462:	13FF  23      		inc	hl
3463:	1400  70      		ld	(hl),b
3464:			
3465:	1401  FD2A072E	g600:	ld	iy,(iyreg)	;restore user iy
3466:	1405  DD2A052E		ld	ix,(ixreg)	;restore user ix
3467:	1409  3A092E  		ld	a,(rreg)
3468:	140C  ED4F    		ld	r,a		;restore user r reg
3469:	140E  3A0A2E  		ld	a,(ireg)
3470:	1411  ED47    		ld	i,a		;restore user i reg
3471:	1413  ED4BFB2D		ld	bc,(bcpreg)	;restore user grade a prime regs
3472:	1417  ED5BFD2D		ld	de,(depreg)
3473:	141B  2AF92D  		ld	hl,(afpreg)
3474:	141E  E5      		push	hl
3475:	141F  F1      		pop	af
3476:	1420  2AFF2D  		ld	hl,(hlpreg)
3477:	1423  08      		ex	af,af'
3478:	1424  D9      		exx
3479:	1425  2AF12D  		ld	hl,(afreg)	;restore user accumulator and flag
3480:	1428  E5      		push	hl
3481:	1429  F1      		pop	af
3482:	142A  ED4BF32D		ld	bc,(bcreg)	;restore user bc
3483:	142E  ED5BF52D		ld	de,(dereg)	;restore user de
3484:	1432  2AF72D  		ld	hl,(hlreg)	;restore user hl
3485:	1435  ED7B032E		ld	sp,(spreg)	;restore user sp
3486:	1439  C3722D  		jp	zjmp
3487:			
3489:			;******************************************************************************
3490:			;*
3491:			;*	step:  Single step (trace) routine
3492:			;*
3493:			;*	Call zlen to determine where to set breakpoint.
3494:			;*
3495:			;*		pass:	   de -	current PC address
3496:			;*
3497:			;*		returned:  b:  z - next instruction will not modify PC.
3498:			;*				   Set bp at address specified by PC+length.
3499:			;*
3500:			;*			   b: nz - next instruction will modify PC (jumps,
3501:			;*				   calls, and returns) thus set bp at address
3502:			;*				   returned in HL.
3503:			;*
3504:			;*			   c:	 - number of bytes in current instruction.
3505:			;*
3506:			;*		Zlen handles secondary breakpoint to set for all conditional
3507:			;*		call, return, and jump instructions.
3508:			;*
3509:			;*	Call brk00 to set breakpoint.
3510:			;*
3511:			;*		pass:	   b - current number of breakpoints.
3512:			;*			  hl - address at which to set breakpoint.
3513:			;*
3514:			;*	entry point step:    entered by user via (s)ingle step command.
3515:			;*	entry point step40:  entered by breakpoint handler - step count nz
3516:			;*
3517:			;*	exit:	to go routine to resume execution.
3518:			;*
3519:			;******************************************************************************
3520:			
3521:	143C  3EFF    	step:	ld	a,0ffh
3522:	143E  32642D  		ld	(wflag),a	;set trace subroutine flag on
3523:	1441  CD7E26  		call	iedtbc		;query user for trace count
3524:	1444  210100  		ld	hl,0001
3525:	1447  FA7414  		jp	m,step40	;null input - step count of one
3526:	144A  CD2719  		call	prsr
3527:	144D  C2780C  		jp	nz,e???
3528:	1450  1A      		ld	a,(de)		;first character from parse buffer
3529:	1451  D62F    		sub	'/'
3530:	1453  32642D  		ld	(wflag),a	;may be slash - no subroutine tracing
3531:	1456  210000  		ld	hl,00
3532:	1459  2009    		jr	nz,step20
3533:	145B  12      		ld	(de),a
3534:	145C  3A542E  		ld	a,(inbfnc)
3535:	145F  3D      		dec	a
3536:	1460  23      		inc	hl
3537:	1461  2811    		jr	z,step40
3538:	1463  2B      		dec	hl
3539:	1464  CDC017  	step20:	call	xval		;evaluate contents of parse buffer
3540:	1467  C2780C  		jp	nz,e???
3541:	146A  ED5B012E		ld	de,(pcreg)
3542:	146E  1A      		ld	a,(de)		;first byte of op code at current pc
3543:	146F  FEC7    		cp	0c7h		;test for rst
3544:	1471  CA780C  		jp	z,e???		;no tracing of rsts
3545:	1474  22652D  	step40:	ld	(nstep),hl	;save step count
3546:	1477  21672D  		ld	hl,sbps		;set step flag nz - trace in effect
3547:	147A  34      		inc	(hl)
3548:	147B  ED5B012E		ld	de,(pcreg)	;fetch current pc
3549:	147F  CDC419  		call	zlen00		;determine number of bytes in instruction
3550:	1482  04      		inc	b		;test where to set breakpoint
3551:	1483  1002    		djnz	step50		;nz - set at address in hl
3552:	1485  EB      		ex	de,hl
3553:	1486  09      		add	hl,bc		;z - set at address pc + instruction length
3554:	1487  3A682D  	step50:	ld	a,(bps)		;get current number of bps
3555:	148A  47      		ld	b,a		;pass to set bp routine in b reg
3556:	148B  EB      		ex	de,hl		;de - bp address to set
3557:	148C  CDF911  		call	brk30
3558:	148F  2A012E  		ld	hl,(pcreg)	;resume execution at next pc
3559:	1492  AF      		xor	a
3560:	1493  B0      		or	b
3561:	1494  C23A13  		jp	nz,g100		;nz - collision with user bp
3562:	1497  EB      		ex	de,hl
3563:	1498  21672D  		ld	hl,sbps		;step bp set by brk30 - bump count
3564:	149B  34      		inc	(hl)
3565:	149C  EB      		ex	de,hl
3566:	149D  C33A13  		jp	g100
3567:			
3569:			;******************************************************************************
3570:			;*
3571:			;*	asmblr:	z80 assembler
3572:			;*
3573:			;******************************************************************************
3574:			
3575:	14A0          	asmblr:
3576:	14A0  CD5525  		call	ilin
3577:	14A3  C2780C  		jp	nz,e???
3578:	14A6  CD0C25  	asm000:	call	crlf
3579:	14A9  22582D  		ld	(zasmpc),hl	;save here as well
3580:	14AC  CD471F  		call	zasm08		;disassemble first instruction
3581:			
3582:	14AF          	asm005:
3583:	14AF  2A582D  		ld	hl,(asmbpc)
3584:	14B2  CD0C25  	asm010:	call	crlf
3585:	14B5  CD3025  		call	outadr		;display current assembly pc
3586:	14B8  0E16    		ld	c,22		;
3587:	14BA  CD2025  		call	spaces		;leave room for object code
3588:	14BD  3E03    		ld	a,3
3589:	14BF  214F2E  		ld	hl,objbuf	;zero scratch object code buffer
3590:	14C2  71      	asm015:	ld	(hl),c
3591:	14C3  23      		inc	hl
3592:	14C4  3D      		dec	a
3593:	14C5  F2C214  		jp	p,asm015
3594:	14C8  325C2D  		ld	(oprn01),a	;init operand key values to 0ffh
3595:	14CB  325F2D  		ld	(oprn02),a
3596:	14CE  CD7E26  		call	iedtbc		;get user input
3597:	14D1  F8      		ret	m		;m - no input ends command
3598:	14D2  CD1125  		call	cret
3599:	14D5  CD2719  		call	prsr		;parse to obtain label
3600:	14D8  7E      		ld	a,(hl)		;check last character
3601:	14D9  FE3A    		cp	':'
3602:	14DB  202B    		jr	nz,asm040	;no colon found - must be op code
3603:	14DD  3600    		ld	(hl),0		;erase colon
3604:	14DF  1A      		ld	a,(de)		;fetch first char of label from parse buffer
3605:	14E0  FE41    		cp	'A'
3606:	14E2  DA7619  		jp	c,asm??l	;error - first character must be alpha
3607:	14E5  FE7B    		cp	'z'+1
3608:	14E7  D27619  		jp	nc,asm??l	;label error
3609:	14EA  FE61    		cp	'a'
3610:	14EC  3005    		jr	nc,asm030
3611:	14EE  FE5B    		cp	'Z'+1
3612:	14F0  D27619  		jp	nc,asm??l
3613:	14F3  210000  	asm030:	ld	hl,00
3614:	14F6  22782D  		ld	(isympt),hl	;clear pointer
3615:	14F9  CD0319  		call	isym		;attempt to insert symbol into symbol table
3616:	14FC  C28619  		jp	nz,asm??t	;error - symbol table full
3617:	14FF  22782D  		ld	(isympt),hl	;save pointer to symbol value in symbol table
3618:	1502  CD2719  		call	prsr		;extract opcode
3619:	1505  FAAF14  		jp	m,asm005	;m - statement contains label only
3620:	1508  3A6C2D  	asm040:	ld	a,(delim)	;check delimeter
3621:	150B  FE2C    		cp	','		;check for invalid terminator
3622:	150D  CA7A19  		jp	z,asm??o
3623:			
3624:	0000          		if	h64180
3626:				else
3627:	1510  0E49    		ld	c,73		;number of Z80 opcodes in table as index
3628:				endif
3629:			
3630:	1512  0D      	asm050:	dec	c
3631:	1513  FA7A19  		jp	m,asm??o	;opcode not found
3632:	1516  0600    		ld	b,0
3633:	1518  21FC2B  		ld	hl,zopcnm	;table of opcode names
3634:	151B  09      		add	hl,bc
3635:	151C  09      		add	hl,bc		;index times four
3636:	151D  09      		add	hl,bc
3637:	151E  09      		add	hl,bc
3638:	151F  11A72E  		ld	de,prsbf	;start of parse buffer
3639:	1522  0604    		ld	b,4
3640:	1524  1A      	asm060:	ld	a,(de)		;character from parse buffer
3641:	1525  A7      		and	a		;null?
3642:	1526  2002    		jr	nz,asm070
3643:	1528  3E20    		ld	a,' '		;for comparison purposes
3644:	152A  CD0325  	asm070:	call	ixlt		;force upper case for compare
3645:	152D  BE      		cp	(hl)
3646:	152E  20E2    		jr	nz,asm050	;mismatch - next opcode name
3647:	1530  13      		inc	de
3648:	1531  23      		inc	hl
3649:	1532  10F0    		djnz	asm060		;must match all four
3650:	1534  1A      		ld	a,(de)		;null following opcode?
3651:	1535  A7      		and	a
3652:	1536  C27A19  		jp	nz,asm??o	;error - opcode more than 4 characaters
3653:	1539  21722D  		ld	hl,ikey		;relative position in table is key value
3654:	153C  71      		ld	(hl),c		;save opcode key value
3655:	153D  CD2719  		call	prsr		;extract first operand
3656:	1540  FA6B15  		jp	m,asm085	;m - none
3657:	1543  CD2617  		call	oprn		;evaluate operand
3658:	1546  2047    		jr	nz,asm??u	;error - bad first operand
3659:	1548  115C2D  		ld	de,oprn01
3660:	154B  CDB419  		call	opnv		;save operand value and key
3661:	154E  3A6C2D  		ld	a,(delim)
3662:	1551  FE2C    		cp	','
3663:	1553  2016    		jr	nz,asm085	;need comma for two operands
3664:	1555  CD2719  		call	prsr		;extract second operand
3665:	1558  FA8219  		jp	m,asm??s	;error - comma with no second operand
3666:	155B  FE2C    		cp	','
3667:	155D  CA8219  		jp	z,asm??s	;illegal line termination
3668:	1560  CD2617  		call	oprn		;evaluate operand
3669:	1563  202A    		jr	nz,asm??u	;error - bad second operand
3670:	1565  115F2D  		ld	de,oprn02
3671:	1568  CDB419  		call	opnv		;save second operand value and key
3672:	156B  AF      	asm085:	xor	a
3673:	156C  4F      		ld	c,a
3674:	156D  21FC28  	asm090:	ld	hl,zopcpt	;opcode name pointer table
3675:	1570  0600    		ld	b,0
3676:	1572  09      		add	hl,bc		;index into table
3677:	1573  3A722D  		ld	a,(ikey)	;fetch opcode key value
3678:	1576  BE      		cp	(hl)		;check for match
3679:	1577  2013    		jr	nz,asm095	;
3680:	1579  24      		inc	h		;point to first operand table
3681:	157A  115C2D  		ld	de,oprn01	;address of first operand key value
3682:	157D  CD5B16  		call	opnm		;check validity
3683:	1580  200A    		jr	nz,asm095	;no match - next
3684:	1582  47      		ld	b,a		;save modified key value
3685:	1583  24      		inc	h		;point to second operand table
3686:	1584  115F2D  		ld	de,oprn02	;address of second operand key value
3687:	1587  CD5B16  		call	opnm
3688:	158A  2808    		jr	z,ibld		;match - attempt final resolution
3689:	158C  0C      	asm095:	inc	c		;bump index
3690:	158D  20DE    		jr	nz,asm090	;nz - check more
3691:	158F  3E55    	asm??u:	ld	a,'U'		;error
3692:	1591  C38C19  		jp	asm???
3693:			
3694:			
3695:	1594  214F2E  	ibld:	ld	hl,objbuf	;object code temp buffer
3696:	1597  5F      		ld	e,a		;save second operand key
3697:	1598  7E      		ld	a,(hl)		;check first byte of object buffer
3698:	1599  A7      		and	a		;null?
3699:	159A  79      		ld	a,c		;instruction key to accumulator regardless
3700:	159B  4B      		ld	c,e		;save second operand modified key
3701:	159C  2801    		jr	z,ibld00	;z - not ix or iy instruction
3702:	159E  23      		inc	hl		;point to byte two of object code
3703:	159F  FE40    	ibld00:	cp	40h
3704:	15A1  3844    		jr	c,ibld55	;c - 8080 instruction
3705:	15A3  FEA0    		cp	0a0h
3706:	15A5  300B    		jr	nc,ibld10	;nc - not ed instruction
3707:	15A7  36ED    		ld	(hl),0edh	;init byte one of object code
3708:	15A9  23      		inc	hl
3709:			
3710:	0000          		if	h64180
3713:				else
3714:	15AA  FE80    		cp	80h		;check which ED instruction we have
3715:	15AC  3839    		jr	c,ibld55	;c - this is exact object byte
3716:	15AE  C620    		add	a,20h		;add bias to obtain object byte
3717:	15B0  1835    		jr	ibld55
3718:				endif
3719:			
3720:	15B2  FEE0    	ibld10:	cp	0e0h
3721:	15B4  3004    		jr	nc,ibld20
3722:	15B6  C620    		add	a,20h		;8080 type - range 0c0h to 0ffh
3723:	15B8  182D    		jr	ibld55		;object byte built
3724:	15BA  FEE8    	ibld20:	cp	0e8h
3725:	15BC  3824    		jr	c,ibld50	;8 bit reg-reg arithmetic or logic
3726:	15BE  FEF7    		cp	0f7h		;check for halt disguised as ld (hl),(hl)
3727:	15C0  2004    		jr	nz,ibld30
3728:	15C2  3E76    		ld	a,76h		;halt object code
3729:	15C4  1821    		jr	ibld55
3730:	15C6  FEF8    	ibld30:	cp	0f8h
3731:	15C8  3018    		jr	nc,ibld50	;8 bit reg-reg load
3732:	15CA  57      		ld	d,a		;temp save instruction key value
3733:	15CB  3A4F2E  		ld	a,(objbuf)
3734:	15CE  A7      		and	a		;check for previously stored first object byte
3735:	15CF  7A      		ld	a,d
3736:	15D0  36CB    		ld	(hl),0cbh	;init byte regardless
3737:	15D2  23      		inc	hl
3738:	15D3  2801    		jr	z,ibld40	;z - not ix or iy instruction
3739:	15D5  23      		inc	hl		;bump object code pointer - this is four byter
3740:	15D6  C6A8    	ibld40:	add	a,0a8h		;add bias for comparison purposes
3741:	15D8  FE98    		cp	98h
3742:	15DA  3806    		jr	c,ibld50	;c - shift or rotate instruction
3743:	15DC  0F      		rrca
3744:	15DD  0F      		rrca
3745:	15DE  E6C0    		and	0c0h		;this is skeleton for bit instuctions
3746:	15E0  1805    		jr	ibld55
3747:	15E2  87      	ibld50:	add	a,a		;form skeleton
3748:	15E3  87      		add	a,a
3749:	15E4  87      		add	a,a
3750:	15E5  C680    		add	a,80h
3751:	15E7  77      	ibld55:	ld	(hl),a		;store object byte
3752:	15E8  AF      		xor	a
3753:	15E9  B1      		or	c		;second operand need more processing?
3754:	15EA  115F2D  		ld	de,oprn02
3755:	15ED  C49916  		call	nz,rslv		;resolve second operand
3756:	15F0  C28A19  		jp	nz,asm??v	;error - invalid operand size
3757:	15F3  115C2D  		ld	de,oprn01
3758:	15F6  78      		ld	a,b
3759:	15F7  A7      		and	a		;first operand resolved?
3760:	15F8  C49916  		call	nz,rslv		;more work to do
3761:	15FB  C28A19  		jp	nz,asm??v	;error - invalid operand size
3762:	15FE  3A722D  		ld	a,(ikey)
3763:	1601  D643    		sub	67		;org directive?
3764:	1603  2007    		jr	nz,ibld60
3765:	1605  56      		ld	d,(hl)
3766:	1606  2B      		dec	hl
3767:	1607  5E      		ld	e,(hl)
3768:	1608  EB      		ex	de,hl
3769:	1609  C3A614  		jp	asm000		;z - org directive
3770:			
3771:	160C  114F2E  	ibld60:	ld	de,objbuf
3772:	160F  3831    		jr	c,ibld70	;c - instruction  nc - directive
3773:			
3774:	0000          		if	h64180
3777:				endif
3778:			
3779:	1611  47      		ld	b,a		;number of bytes for defb or defw or ddb
3780:	1612  13      		inc	de		;point past erroneous assembled opcode
3781:	1613  13      		inc	de
3782:	1614  D603    		sub	3		;test for ddb
3783:	1616  382E    		jr	c,ibld75	;c - must be defb or defw
3784:	1618  3D      		dec	a
3785:	1619  201E    		jr	nz,ibld65	;nz - must be ddb
3786:	161B  56      		ld	d,(hl)		;must be equ
3787:	161C  2B      		dec	hl
3788:	161D  5E      		ld	e,(hl)
3789:	161E  2A782D  		ld	hl,(isympt)	;fetch pointer to entry in symbol table
3790:	1621  7C      		ld	a,h
3791:	1622  B5      		or	l
3792:	1623  CA8F15  		jp	z,asm??u	;error - no label on equ statement
3793:	1626  72      		ld	(hl),d
3794:	1627  2B      		dec	hl
3795:	1628  73      		ld	(hl),e		;store value of symbol in symbol table
3796:	1629  0E06    		ld	c,6
3797:	162B  CD2025  		call	spaces
3798:	162E  7A      		ld	a,d
3799:	162F  CD1625  		call	othxsp
3800:	1632  7B      		ld	a,e
3801:	1633  CD1625  		call	othxsp
3802:	1636  C3AF14  		jp	asm005		;ready for next input
3803:	1639  05      	ibld65:	dec	b		;set count of object bytes to 2
3804:	163A  4E      		ld	c,(hl)		;exchange hi and lo order bytes for ddb
3805:	163B  2B      		dec	hl
3806:	163C  7E      		ld	a,(hl)
3807:	163D  71      		ld	(hl),c		;new hi order
3808:	163E  23      		inc	hl
3809:	163F  77      		ld	(hl),a		;new hi order replaces old lo order
3810:	1640  1804    		jr	ibld75
3811:	1642  CDC419  	ibld70:	call	zlen00		;compute length of instruction in bytes
3812:	1645  41      		ld	b,c		;b - number of bytes of object code
3813:	1646  2A582D  	ibld75:	ld	hl,(asmbpc)
3814:	1649  CD3025  		call	outadr		;re-display current location counter
3815:	164C  1A      	ibld80:	ld	a,(de)		;move from scratch object buffer
3816:	164D  77      		ld	(hl),a		;into address pointed to by location counter
3817:	164E  23      		inc	hl
3818:	164F  13      		inc	de
3819:	1650  CD1625  		call	othxsp		;display each object code byte
3820:	1653  10F7    		djnz	ibld80
3821:	1655  22582D  	ibld90:	ld	(asmbpc),hl
3822:	1658  C3AF14  		jp	asm005		;next input from user
3823:			
3824:			
3825:			
3826:			
3827:	165B  1A      	opnm:	ld	a,(de)		;key value computed by operand routine
3828:	165C  AE      		xor	(hl)		;compare with table operand table entry
3829:	165D  C8      		ret	z		;true match of operand key values
3830:	165E  AE      		xor	(hl)		;restore
3831:	165F  87      		add	a,a		;86 all no operand key values (0ffh)
3832:	1660  F8      		ret	m
3833:	1661  7E      		ld	a,(hl)		;fetch table entry
3834:	1662  E67F    		and	7fh		;sans paren flag for comparison purposes
3835:	1664  FE1B    		cp	1bh		;check table entry 8 bit - 16 bit - $ rel ?
3836:	1666  380B    		jr	c,opnm00	;c - none of the above
3837:	1668  1A      		ld	a,(de)		;fetch computed key
3838:	1669  AE      		xor	(hl)		;compare with paren flags
3839:	166A  F8      		ret	m		;error - paren mismatch
3840:	166B  1A      		ld	a,(de)		;fetch key once more
3841:	166C  E67F    		and	7fh		;remove paren flag
3842:	166E  FE17    		cp	17h		;computed as 8 bit - 16 bit - $ rel?
3843:	1670  2820    		jr	z,opnm40	;so far so good
3844:	1672  C9      		ret			;
3845:	1673  FE19    	opnm00:	cp	19h		;check for 8 bit reg
3846:	1675  300C    		jr	nc,opnm20	;8 bit register match
3847:	1677  FE18    		cp	18h		;table says must be hl - ix - iy
3848:	1679  C0      		ret	nz		;computed key disagrees
3849:	167A  1A      		ld	a,(de)		;fetch computed key
3850:	167B  E607    		and	7		;computed as hl - ix - iy ?
3851:	167D  C0      		ret	nz		;no
3852:	167E  1A      	opnm10:	ld	a,(de)		;fetch computed key
3853:	167F  AE      		xor	(hl)
3854:	1680  F8      		ret	m		;error - paren mismatch on hl - ix - iy
3855:	1681  180F    		jr	opnm40
3856:	1683  1A      	opnm20:	ld	a,(de)		;fetch computed key of 8 bit reg
3857:	1684  A7      		and	a		;
3858:	1685  2002    		jr	nz,opnm30	;nz - not (hl)
3859:	1687  3D      		dec	a		;error - 8 bit (hl) missing parens
3860:	1688  C9      		ret
3861:	1689  FE08    	opnm30:	cp	8		;test user entered valid 8 bit reg
3862:	168B  3805    		jr	c,opnm40	;c - ok
3863:	168D  A7      		and	a		;test if no carry caused by paren flag
3864:	168E  F0      		ret	p		;error - this is not 8 bit reg with parens
3865:	168F  E607    		and	7		;psuedo 8 bit reg: (hl) (ix) (iy)?
3866:	1691  C0      		ret	nz		;no
3867:	1692  7E      	opnm40:	ld	a,(hl)		;fetch table entry
3868:	1693  E67F    		and	7fh
3869:	1695  D618    		sub	18h		;make values 18 thru 1f relative zero
3870:	1697  BF      		cp	a		;zero means match
3871:	1698  C9      		ret
3872:			
3873:	1699  3D      	rslv:	dec	a
3874:	169A  2804    		jr	z,rslv00	;z - 8 bit reg (bits 0-2 of object byte)
3875:	169C  3D      		dec	a
3876:	169D  2011    		jr	nz,rslv20	;nz - not 8 bit reg (bits 3-5 of object byte)
3877:	169F  3D      		dec	a		;make neg to indicate shift left required
3878:	16A0  4F      	rslv00:	ld	c,a
3879:	16A1  1A      		ld	a,(de)		;fetch computed operand key
3880:	16A2  E607    		and	07		;lo three bits specify reg
3881:	16A4  EE06    		xor	6		;create true object code bits
3882:	16A6  0C      		inc	c		;test if bits 0-2 or bits 3-5
3883:	16A7  2003    		jr	nz,rslv10	;nz - 0 thru 2
3884:	16A9  87      		add	a,a
3885:	16AA  87      		add	a,a
3886:	16AB  87      		add	a,a
3887:	16AC  B6      	rslv10:	or	(hl)		;or with skeleton
3888:	16AD  77      		ld	(hl),a		;into scratch object buffer
3889:	16AE  BF      		cp	a		;set zero - no error
3890:	16AF  C9      		ret
3891:	16B0  13      	rslv20:	inc	de		;point to low order of operand value
3892:	16B1  4E      		ld	c,(hl)		;c - current skeleton  (if needed)
3893:	16B2  23      		inc	hl		;bump object code buffer pointer
3894:	16B3  3D      		dec	a
3895:	16B4  201D    		jr	nz,rslv30	;nz - not relative jump
3896:	16B6  EB      		ex	de,hl		;save object code pointer in de
3897:	16B7  7E      		ld	a,(hl)
3898:	16B8  23      		inc	hl
3899:	16B9  66      		ld	h,(hl)
3900:	16BA  6F      		ld	l,a		;hl - operand value computed by xval
3901:	16BB  78      		ld	a,b
3902:	16BC  ED4B582D		ld	bc,(asmbpc)	;current location counter
3903:	16C0  03      		inc	bc
3904:	16C1  03      		inc	bc
3905:	16C2  ED42    		sbc	hl,bc		;calculate displacement from current counter
3906:	16C4  EB      		ex	de,hl		;de - displacement  hl - object code pointer
3907:	16C5  47      		ld	b,a		;restore b reg
3908:	16C6  7B      		ld	a,e		;lo order displacement
3909:	16C7  14      		inc	d		;test hi order
3910:	16C8  2803    		jr	z,rslv25	;must have been ff (backward displacement)
3911:	16CA  15      		dec	d
3912:	16CB  C0      		ret	nz		;error - hi order not zero or ff
3913:	16CC  2F      		cpl			;set sign bit for valid forward displacement
3914:	16CD  EE80    	rslv25:	xor	80h		;toggle sign bit
3915:	16CF  F8      		ret	m		;error - sign bit disagrees with upper byte
3916:	16D0  73      		ld	(hl),e		;store displacement object byte
3917:	16D1  BF      		cp	a		;set zero flag - no errors
3918:	16D2  C9      		ret
3919:	16D3  3D      	rslv30:	dec	a
3920:	16D4  2014    		jr	nz,rslv40	;nz - not 8 bit immediate
3921:	16D6  3E36    		ld	a,36h		;test for reg indirect - (hl),nn
3922:	16D8  B9      		cp	c
3923:	16D9  2007    		jr	nz,rslv35
3924:	16DB  3A4F2E  		ld	a,(objbuf)	;test first object byte
3925:	16DE  B9      		cp	c
3926:	16DF  2801    		jr	z,rslv35	;z - (hl),nn
3927:	16E1  23      		inc	hl		;must be (ix+index),nn  or  (iy+index),nn
3928:	16E2  1A      	rslv35:	ld	a,(de)		;move lo order operand value to object buffer
3929:	16E3  77      		ld	(hl),a
3930:	16E4  13      		inc	de
3931:	16E5  1A      		ld	a,(de)		;test hi order
3932:	16E6  A7      		and	a		;
3933:	16E7  C8      		ret	z		;z - must be 0 thru +255
3934:	16E8  3C      		inc	a		;error if not -1 thru -256
3935:	16E9  C9      		ret
3936:	16EA  3D      	rslv40:	dec	a
3937:	16EB  2008    		jr	nz,rslv50	;nz - not 16 bit operand
3938:	16ED  1A      		ld	a,(de)		;move both bytes of operand to object buffer
3939:	16EE  77      		ld	(hl),a
3940:	16EF  23      		inc	hl
3941:	16F0  13      		inc	de
3942:	16F1  1A      		ld	a,(de)		;byte two
3943:	16F2  77      		ld	(hl),a
3944:	16F3  BF      		cp	a		;set zero flag - no errors of course
3945:	16F4  C9      		ret
3946:	16F5  3D      	rslv50:	dec	a		;test restart instruction or bit number
3947:	16F6  200D    		jr	nz,rslv60	;nz - bit or interrupt mode number
3948:	16F8  1A      		ld	a,(de)		;check restart value specified
3949:	16F9  E6C7    		and	0c7h		;betweed 0 and 38h?
3950:	16FB  C0      		ret	nz		;error
3951:	16FC  1A      		ld	a,(de)		;fetch lo order operand value
3952:	16FD  F6C7    		or	0c7h		;or with instruction skeleton
3953:	16FF  2B      		dec	hl
3954:	1700  77      		ld	(hl),a		;rewind object code pointer
3955:	1701  13      		inc	de
3956:	1702  1A      		ld	a,(de)		;check hi order operand value
3957:	1703  A7      		and	a		;error if not zero
3958:	1704  C9      		ret
3959:	1705  2B      	rslv60:	dec	hl		;rewind object code buffer pointer
3960:	1706  1A      		ld	a,(de)
3961:	1707  E6F8    		and	0f8h		;ensure bit number in range 0 - 7
3962:	1709  C0      		ret	nz		;error
3963:	170A  3A722D  		ld	a,(ikey)	;fetch opcode key value
3964:	170D  D613    		sub	13h		;is this bit number of interrupt mode number?
3965:	170F  1A      		ld	a,(de)		;fetch operand value regardless
3966:	1710  200D    		jr	nz,rslv70	;nz - bit number
3967:	1712  3646    		ld	(hl),46h
3968:	1714  E603    		and	03		;im 0?
3969:	1716  C8      		ret	z
3970:	1717  3656    		ld	(hl),56h
3971:	1719  3D      		dec	a		;im 1?
3972:	171A  C8      		ret	z
3973:	171B  365E    		ld	(hl),5eh
3974:	171D  3D      		dec	a		;error if not im 2
3975:	171E  C9      		ret
3976:	171F  87      	rslv70:	add	a,a		;shift bit number left three
3977:	1720  87      		add	a,a
3978:	1721  87      		add	a,a
3979:	1722  B6      		or	(hl)		;or with skeleton
3980:	1723  77      		ld	(hl),a
3981:	1724  BF      		cp	a		;indicate no error
3982:	1725  C9      		ret
3983:			
3984:			
3985:			
3986:	1726  011600  	oprn:	ld	bc,22		;count of reserved operand
3987:	1729  11A72E  	oprn00:	ld	de,prsbf	;buffer contains operand
3988:	172C  7E      		ld	a,(hl)		;last character of operand in parse buffer
3989:	172D  D629    		sub	')'
3990:	172F  2007    		jr	nz,oprn20	;not paren
3991:	1731  77      		ld	(hl),a		;remove trailing paren - replace with null
3992:	1732  1A      		ld	a,(de)		;check first character of parse buffer
3993:	1733  D628    		sub	'('
3994:	1735  C0      		ret	nz		;error - unbalanced parens
3995:	1736  12      		ld	(de),a		;remove leading paren - replace with null
3996:	1737  13      		inc	de		;point to next character in parse buffer
3997:	1738  218327  	oprn20:	ld	hl,zopnm	;index into reserved operand name table
3998:	173B  79      		ld	a,c
3999:	173C  87      		add	a,a		;index times two
4000:	173D  85      		add	a,l
4001:	173E  6F      		ld	l,a
4002:	173F  3001    		jr	nc,oprn25
4003:	1741  24      		inc	h
4004:	1742  1A      	oprn25:	ld	a,(de)		;from parse buffer
4005:	1743  CD0325  		call	ixlt		;translate to upper case for compare
4006:	1746  BE      		cp	(hl)		;versus table entry
4007:	1747  13      		inc	de
4008:	1748  205D    		jr	nz,oprn70	;no match - check next
4009:	174A  1A      		ld	a,(de)		;check second character
4010:	174B  CD0325  		call	ixlt		;translate to upper case
4011:	174E  A7      		and	a		;if null - this is one character reg name
4012:	174F  2002    		jr	nz,oprn30
4013:	1751  3E20    		ld	a,' '		;for comparison purposes
4014:	1753  23      	oprn30:	inc	hl		;bump table pointer
4015:	1754  96      		sub	(hl)
4016:	1755  2050    		jr	nz,oprn70	;no match - check next
4017:	1757  13      		inc	de		;have match - bump buffer pointer
4018:	1758  B0      		or	b		;
4019:	1759  C0      		ret	nz		;nz - mreg calling
4020:	175A  79      		ld	a,c		;check index value
4021:	175B  E607    		and	07
4022:	175D  2050    		jr	nz,oprn80	;not hl ix iy - check for residue
4023:	175F  1A      		ld	a,(de)
4024:	1760  CDAC19  		call	oprtor		;check for expression operator
4025:	1763  204D    		jr	nz,oprn85	;no operator but not end of operand
4026:	1765  3E18    		ld	a,ix.. or iy..	;special ix iy hl processing
4027:	1767  A1      		and	c		;test for index reg
4028:	1768  2805    		jr	z,oprn35	;z - must be hl
4029:	176A  E610    		and	10h		;transform index into 0ddh or 0fdh
4030:	176C  87      		add	a,a
4031:	176D  C6DD    		add	a,0ddh		;a - first byte of index reg opcode
4032:	176F  4F      	oprn35:	ld	c,a		;temp save first object byte
4033:	1770  214F2E  		ld	hl,objbuf
4034:	1773  AE      		xor	(hl)
4035:	1774  280A    		jr	z,oprn40	;z - first operand matches second
4036:	1776  B9      		cp	c
4037:	1777  C0      		ret	nz		;illegal ix iy hl combination
4038:	1778  3A5C2D  		ld	a,(oprn01)
4039:	177B  A7      		and	a		;test if index reg was first operand
4040:	177C  2002    		jr	nz,oprn40
4041:	177E  3D      		dec	a		;error - hl illegal as second
4042:	177F  C9      		ret
4043:			
4044:			
4045:	1780  71      	oprn40:	ld	(hl),c		;init first byte of object code
4046:	1781  3AA72E  		ld	a,(prsbf)
4047:	1784  A7      		and	a		;check for previously removed parens
4048:	1785  79      		ld	a,c
4049:	1786  0E00    		ld	c,0
4050:	1788  2025    		jr	nz,oprn80	;no parens - no indexed displacement
4051:	178A  A7      		and	a		;check for ix or iy indexed instruction
4052:	178B  2822    		jr	z,oprn80	;z - not index reg instruction
4053:			
4054:	178D  ED62    		sbc	hl,hl		;clear hl
4055:	178F  1A      		ld	a,(de)		;index reg displacement processing
4056:	1790  A7      		and	a		;test for default displacement
4057:	1791  C4C017  		call	nz,xval		;not zero - evaluate
4058:	1794  201C    		jr	nz,oprn85	;nz - displacement in error
4059:	1796  0E00    		ld	c,00
4060:	1798  7D      		ld	a,l
4061:	1799  32512E  		ld	(objbuf+2),a	;displacement always third byte
4062:	179C  24      		inc	h		;check upper byte of index value
4063:	179D  2803    		jr	z,oprn50	;must have been 0ffh
4064:	179F  25      		dec	h
4065:	17A0  C0      		ret	nz		;error - index not -128 to +127
4066:	17A1  2F      		cpl
4067:	17A2  EE80    	oprn50:	xor	80h		;check sign bit
4068:	17A4  F8      		ret	m		;bit on - index out of range
4069:	17A5  BF      		cp	a		;no error - set zero flag
4070:	17A6  C9      		ret
4071:	17A7  0D      	oprn70:	dec	c		;decrement reserved operand table index
4072:	17A8  FAB217  		jp	m,oprn85	;m - not a reserved operand
4073:	17AB  1B      		dec	de		;rewind parse buffer pointer
4074:	17AC  C33817  		jp	oprn20		;next table entry
4075:	17AF  1A      	oprn80:	ld	a,(de)		;check for end of parse buffer
4076:	17B0  A7      		and	a
4077:	17B1  C8      		ret	z		;found end of line null
4078:	17B2  11A72E  	oprn85:	ld	de,prsbf	;rewind to start of input
4079:	17B5  AF      		xor	a
4080:	17B6  B0      		or	b
4081:	17B7  C0      		ret	nz		;nz - this was mreg calling
4082:	17B8  ED62    		sbc	hl,hl		;clear hl
4083:	17BA  CDC017  		call	xval		;evaluate operand
4084:	17BD  0E17    		ld	c,17h		;assume numeric operand found
4085:	17BF  C9      		ret
4086:			
4087:			
4088:	17C0  1A      	xval:	ld	a,(de)		;check first char of parse buffer
4089:	17C1  A7      		and	a
4090:	17C2  2001    		jr	nz,xval00
4091:	17C4  13      		inc	de		;bump past previously removed paren
4092:	17C5  22732D  	xval00:	ld	(mexp),hl	;init expression accumulator
4093:	17C8  AF      		xor	a
4094:	17C9  326E2D  		ld	(base10),a	;clear upper digit decimal accumulator
4095:	17CC  ED62    		sbc	hl,hl		;clear hl
4096:	17CE  227C2D  		ld	(fndsym),hl	;clear symbol found flag
4097:	17D1  227A2D  		ld	(pass2),hl
4098:	17D4  1A      	xval05:	ld	a,(de)		;char from parse buffer
4099:	17D5  CD0325  		call	ixlt		;translate to upper case
4100:	17D8  4F      		ld	c,a		;save character
4101:	17D9  13      		inc	de		;bump parse buffer pointer
4102:	17DA  FE30    		cp	'0'		;check for valid ascii hex digit
4103:	17DC  3833    		jr	c,xval25
4104:	17DE  FE3A    		cp	':'
4105:	17E0  3817    		jr	c,xval15
4106:	17E2  FE41    		cp	'A'
4107:	17E4  382B    		jr	c,xval25
4108:	17E6  FE47    		cp	'G'
4109:	17E8  3027    		jr	nc,xval25
4110:	17EA  AF      		xor	a		;check number entered flag (b reg sign bit)
4111:	17EB  B0      		or	b
4112:	17EC  FAF317  		jp	m,xval10	;m - this was not first char
4113:	17EF  3A4F2D  		ld	a,(symflg)	;check if symbol table present in memory
4114:	17F2  A7      		and	a
4115:	17F3  79      	xval10:	ld	a,c		;input character back to accumulator
4116:	17F4  F21118  		jp	p,xval25	;p - have symbol table or invalid hex digit
4117:	17F7  D607    		sub	7
4118:	17F9  D630    	xval15:	sub	'0'		;ascii hex to hex nibble
4119:	17FB  87      		add	a,a		;shift left five - hi bit of nibble to carry
4120:	17FC  87      		add	a,a
4121:	17FD  87      		add	a,a
4122:	17FE  87      		add	a,a
4123:	17FF  87      		add	a,a
4124:	1800  0E04    		ld	c,4		;loop count
4125:	1802  ED6A    	xval20:	adc	hl,hl		;hl left into carry - rotate carry into hl
4126:	1804  8F      		adc	a,a		;next bit of nibble into carry
4127:	1805  0D      		dec	c
4128:	1806  20FA    		jr	nz,xval20
4129:	1808  326E2D  		ld	(base10),a	;store what was shifted left out of hl
4130:	180B  3E80    		ld	a,80h		;set sign of b - number entered flag
4131:	180D  B0      		or	b
4132:	180E  47      		ld	b,a
4133:	180F  18C3    		jr	xval05		;next character
4134:			
4135:	1811  CDAC19  	xval25:	call	oprtor		;have expression operator?
4136:	1814  280D    		jr	z,xval30
4137:	1816  3A7A2D  		ld	a,(pass2)
4138:	1819  A7      		and	a
4139:	181A  C0      		ret	nz
4140:	181B  3A7B2D  		ld	a,(pass2+1)
4141:	181E  A7      		and	a
4142:	181F  CA2E18  		jp	z,xval35
4143:	1822  C9      		ret
4144:			
4145:	1823  AF      	xval30:	xor	a
4146:	1824  B0      		or	b		;check number entered flag
4147:	1825  79      		ld	a,c		;restore unmodified input character to a
4148:	1826  C2A818  		jp	nz,xval90	;nz - take care of previous operator
4149:	1829  A7      		and	a		;end of line null?
4150:	182A  C8      		ret	z		;
4151:	182B  41      		ld	b,c		;this operator was first char of parse buffer
4152:	182C  18A6    		jr	xval05		;extract what follows this leading operator
4153:			
4154:	182E  79      	xval35:	ld	a,c		;recover character
4155:	182F  FE23    		cp	'#'		;decimal processing?
4156:	1831  2029    		jr	nz,xval50	;nz - not decimal
4157:	1833  78      		ld	a,b		;check number entered flag
4158:	1834  EE80    		xor	80h		;toggle
4159:	1836  F8      		ret	m		;error - pound sign with no number
4160:	1837  47      		ld	b,a
4161:	1838  C5      		push	bc
4162:	1839  D5      		push	de
4163:	183A  EB      		ex	de,hl		;save hex number in de
4164:	183B  216E2D  		ld	hl,base10
4165:	183E  3E06    		ld	a,6
4166:	1840  BE      		cp	(hl)		;check ten thousands digit
4167:	1841  3814    		jr	c,xval40	;error - obviously greater than 65535
4168:	1843  ED67    		rrd			;nibble to accumulator
4169:	1845  23      	 	inc	hl
4170:	1846  72      		ld	(hl),d		;store hex number in temp buffer
4171:	1847  23      		inc	hl
4172:	1848  73      		ld	(hl),e		;lo order hex number
4173:	1849  2B      		dec	hl		;point back to upper byte
4174:	184A  5F      		ld	e,a
4175:	184B  AF      		xor	a
4176:	184C  57      		ld	d,a		;de - hex nibble
4177:	184D  CD5427  		call	bcdx		;convert hi order byte
4178:	1850  2005    		jr	nz,xval40	;nz - error detected during conversion
4179:	1852  23      		inc	hl		;bump to lo byte to convert
4180:	1853  CD5427  		call	bcdx
4181:	1856  EB      		ex	de,hl		;hl - converted value
4182:	1857  D1      	xval40:	pop	de
4183:	1858  C1      		pop	bc
4184:	1859  2841    		jr	z,xval65	;z - no errors detected
4185:	185B  C9      		ret
4186:			
4187:			
4188:			
4189:	185C  FE27    	xval50:	cp	quote		;ascii literal processing
4190:	185E  200F    		jr	nz,xval60	;nz - not quote
4191:	1860  EB      		ex	de,hl		;
4192:	1861  5E      		ld	e,(hl)		;fetch literal from buffer
4193:	1862  23      		inc	hl
4194:	1863  BE      		cp	(hl)		;trailing quote found?
4195:	1864  2805    		jr	z,xval55	;found
4196:	1866  53      		ld	d,e		;make literal just fetch hi order of operand
4197:	1867  5E      		ld	e,(hl)		;fetch new literal as lo order
4198:	1868  23      		inc	hl
4199:	1869  BE      		cp	(hl)		;trailing quote?
4200:	186A  C0      		ret	nz		;error - more than two chars between quotes
4201:	186B  EB      	xval55:	ex	de,hl		;de - parse buffer ptr   hl - operand
4202:	186C  13      		inc	de		;bump past trailing quote
4203:	186D  182D    		jr	xval65
4204:			
4205:			
4206:	186F  1B      	xval60:	dec	de		;point to start of operand in parse buffer
4207:	1870  ED537A2D		ld	(pass2),de
4208:	1874  CDC418  		call	fsym		;search symbol table
4209:	1877  CA9318  		jp	z,xval62	;symbol found
4210:	187A  1A      		ld	a,(de)
4211:	187B  13      		inc	de
4212:	187C  FE24    		cp	'$'		;check for pc relative expression
4213:	187E  C28618  		jp	nz,xval61
4214:	1881  2A582D  		ld	hl,(asmbpc)	;current location value is expression value
4215:	1884  1816    		jr	xval65
4216:							;symbol not found - retry evaluation process
4217:							;with pass2 flag set.  Now token must be a
4218:							;valid hex digit or error
4219:	1886  ED5B7A2D	xval61:	ld	de,(pass2)
4220:	188A  78      		ld	a,b
4221:	188B  F680    		or	80h		;set sign in b - valid digit detected which
4222:							;tells xval this must be hex number
4223:	188D  47      		ld	b,a
4224:	188E  ED62    		sbc	hl,hl		;clear hex number accumulator
4225:	1890  C3D417  		jp	xval05
4226:	1893  3A7E2D  	xval62:	ld	a,(maxlen)	;point to last byte of sym table entry
4227:	1896  B5      		or	l
4228:	1897  6F      		ld	l,a
4229:	1898  7E      		ld	a,(hl)		;hi order symbol address
4230:	1899  2B      		dec	hl
4231:	189A  6E      		ld	l,(hl)		;lo order
4232:	189B  67      		ld	h,a
4233:	189C  78      	xval65:	ld	a,b		;check number entered flag
4234:	189D  A7      		and	a
4235:	189E  F8      		ret	m		;error - numbers entered previous to symbol
4236:	189F  EE80    		xor	80h		;toggle flag
4237:	18A1  47      		ld	b,a
4238:	18A2  1A      		ld	a,(de)		;check char following symbol name in buffer
4239:	18A3  4F      		ld	c,a		;make it new current character
4240:	18A4  13      		inc	de
4241:	18A5  C32318  		jp	xval30
4242:			
4243:			
4244:			
4245:			
4246:			
4247:	18A8  4F      	xval90:	ld	c,a		;temp save operator
4248:	18A9  3E80    		ld	a,80h		;toggle number entered flag
4249:	18AB  A8      		xor	b
4250:	18AC  F8      		ret	m		;return nz - consecutive operators
4251:	18AD  41      		ld	b,c		;new on deck operator
4252:	18AE  FE2D    		cp	'-'		;test last operator
4253:	18B0  D5      		push	de		;save buffer pointer
4254:	18B1  2005    		jr	nz,xval95	;nz - addition
4255:	18B3  EB      		ex	de,hl
4256:	18B4  ED62    		sbc	hl,hl		;clear
4257:	18B6  ED52    		sbc	hl,de		;force current value neg by subtraction from 0
4258:	18B8  EB      	xval95:	ex	de,hl
4259:	18B9  2A732D  		ld	hl,(mexp)	;fetch accumulated operand total
4260:	18BC  19      		add	hl,de		;add in current
4261:	18BD  D1      		pop	de		;restore buffer pointer
4262:	18BE  78      		ld	a,b		;check operator that got us here
4263:	18BF  A7      		and	a		;end of line null?
4264:	18C0  C2C517  		jp	nz,xval00	;no -
4265:	18C3  C9      		ret			;operand processing complete
4266:			
4267:			
4268:			
4269:	18C4          	fsym:
4270:	18C4  2A0600  		ld	hl,(06)		;de - buffer   hl - symbol table
4271:	18C7  3A7E2D  	fsym00:	ld	a,(maxlen)
4272:	18CA  A5      		and	l
4273:	18CB  4F      		ld	c,a
4274:	18CC  78      		ld	a,b		;temp save
4275:	18CD  0600    		ld	b,0
4276:	18CF  EB      		ex	de,hl		;de - symbol table ptr  hl - parse buffer
4277:	18D0  ED42    		sbc	hl,bc		;rewind parse buffer to start of symbol
4278:	18D2  EB      		ex	de,hl		;de - parse buffer  hl - symbol table pointer
4279:	18D3  47      		ld	b,a		;restore b reg
4280:	18D4  3A7E2D  		ld	a,(maxlen)
4281:	18D7  B5      		or	l
4282:	18D8  6F      		ld	l,a
4283:	18D9  23      		inc	hl		;next block of symbol table
4284:	18DA  7E      		ld	a,(hl)		;first character of symbol name
4285:	18DB  3D      		dec	a
4286:	18DC  F8      		ret	m		;end of table
4287:	18DD  3A7E2D  		ld	a,(maxlen)
4288:	18E0  3D      		dec	a
4289:	18E1  4F      		ld	c,a		;chars per symbol
4290:	18E2  1A      	fsym10:	ld	a,(de)		;fetch char from buffer
4291:	18E3  CDAC19  		call	oprtor
4292:	18E6  2008    		jr	nz,fsym20	;nz - not operator or end of line null
4293:	18E8  7E      		ld	a,(hl)
4294:	18E9  A7      		and	a		;null means end of symbol name in symbol table
4295:	18EA  20DB    		jr	nz,fsym00
4296:	18EC  227C2D  		ld	(fndsym),hl	;set symbol found flag nz -
4297:	18EF  C9      		ret
4298:	18F0  BE      	fsym20:	cp	(hl)
4299:	18F1  20D4    		jr	nz,fsym00
4300:	18F3  23      		inc	hl
4301:	18F4  13      		inc	de
4302:	18F5  0D      		dec	c
4303:	18F6  20EA    		jr	nz,fsym10
4304:	18F8  227C2D  		ld	(fndsym),hl	;set symbol found flag nz -
4305:	18FB  1A      	fsym30:	ld	a,(de)
4306:	18FC  CDAC19  		call	oprtor
4307:	18FF  C8      		ret	z
4308:	1900  13      		inc	de
4309:	1901  18F8    		jr	fsym30
4310:			
4311:			
4312:			
4313:	1903  CDC418  	isym:	call	fsym		;search for symbol in table
4314:	1906  2806    		jr	z,isym00	;z - symbol found
4315:	1908  7E      		ld	a,(hl)		;test for empty slot in table
4316:	1909  A7      		and	a
4317:	190A  C0      		ret	nz		;symbol table full
4318:	190B  324F2D  		ld	(symflg),a	;indicate non-empty symbol table
4319:	190E  3A7E2D  	isym00:	ld	a,(maxlen)	;rewind point to start of table entry
4320:	1911  4F      		ld	c,a
4321:	1912  2F      		cpl
4322:	1913  A5      		and	l
4323:	1914  6F      		ld	l,a
4324:	1915  EB      		ex	de,hl		;de - pointer to start of symbol
4325:	1916  21A72E  		ld	hl,prsbf
4326:	1919  0600    		ld	b,0		;move symbol from parse buffer to table
4327:	191B  0D      		dec	c
4328:	191C  EDB0    		ldir
4329:	191E  2A582D  		ld	hl,(asmbpc)	;fetch value of symbol
4330:	1921  EB      		ex	de,hl		;hl - pointer to address storage
4331:	1922  73      		ld	(hl),e		;lo order current location into table
4332:	1923  23      		inc	hl
4333:	1924  72      		ld	(hl),d		;upper byte
4334:	1925  AF      		xor	a
4335:	1926  C9      		ret
4336:			
4338:			;******************************************************************************
4339:			;*
4340:			;*	prsr:	Command line parse routine
4341:			;*
4342:			;*	Prsr will extract one argument from the input buffer (inbf) and
4343:			;*	write it into the parse buffer (prsbf). An argument is treated
4344:			;*	as starting with the first non-delimeter character encountered
4345:			;*	in the input buffer and ends with the next delimeter found.
4346:			;*	All intervening characters between the two delimeters are
4347:			;*	treated as the argument and are moved to prsbf.
4348:			;*
4349:			;*	As each character is extracted from inbf a zero is written back
4350:			;*	to replace it.  Thus a program which needs to extract multiple args
4351:			;*	need not save pointers in between calls since prsr is trained
4352:			;*	to strip leading delimeters while looking for the start of an
4353:			;*	argument:
4354:			;*
4355:			;*	     delimeters: null, space, comma
4356:			;*
4357:			;*	exit:	    de - starting address of parse buffer
4358:			;*		     b - sign bit: set if unbalanced parens, else sign reset
4359:			;*			 bits 6-0: number of chars in the parse buffer
4360:			;*		     a - actual delimter char which caused to terminate
4361:			;*		     f - zero flag set if no error
4362:			;*		quoflg - set equal to ascii quote if at least one quote found
4363:			;*
4364:			;*	error exit:  f - zero flag reset
4365:			;*
4366:			;******************************************************************************
4367:			
4368:	1927  AF      	prsr:	xor	a
4369:	1928  32632D  		ld	(quoflg),a	;clear quote flag
4370:	192B  21A72E  		ld	hl,prsbf	;start of parser scratch buffer
4371:	192E  0652    		ld	b,prsbfz	;buffer size
4372:	1930  48      		ld	c,b
4373:	1931  3600    	prsr10:	ld	(hl),0		;clear parse buffer to nulls
4374:	1933  23      		inc	hl
4375:	1934  10FB    		djnz	prsr10
4376:	1936  21A72E  		ld	hl,prsbf	;start of parse buffer
4377:	1939  11552E  		ld	de,inbf		;start of input buffer
4378:	193C  0E51    		ld	c,inbfl		;max size of input buffer
4379:	193E  1A      	prsr20:	ld	a,(de)		;from input buffer
4380:	193F  EB      		ex	de,hl
4381:	1940  3600    		ld	(hl),0		;erase as we pick from input buffer
4382:	1942  EB      		ex	de,hl
4383:	1943  0D      		dec	c		;decrement buffer size tally
4384:	1944  F8      		ret	m		;error -  end of input buffer reached
4385:	1945  13      		inc	de		;bump input buffer pointer
4386:	1946  CDA419  		call	zdlm00		;check for delimeter
4387:	1949  28F3    		jr	z,prsr20	;delimeter found - continue search
4388:	194B  326B2D  		ld	(parenf),a
4389:	194E  0E52    		ld	c,nprsbf-prsbf	;parse buffer size
4390:	1950  77      	prsr30:	ld	(hl),a
4391:	1951  A7      		and	a
4392:	1952  281B    		jr	z,prsr60	;end of line null always ends parse
4393:	1954  FE27    		cp	quote		;quote?
4394:	1956  2007    		jr	nz,prsr50
4395:	1958  32632D  		ld	(quoflg),a
4396:	195B  78      		ld	a,b		;quote found - toggle flag
4397:	195C  EE80    		xor	80h
4398:	195E  47      		ld	b,a
4399:	195F  0D      	prsr50:	dec	c		;decrement buffer size tally
4400:	1960  F8      		ret	m		;error - end of parse buffer reached
4401:	1961  1A      		ld	a,(de)		;next char from input buffer
4402:	1962  EB      		ex	de,hl
4403:	1963  3600    		ld	(hl),0		;clear as we remove
4404:	1965  EB      		ex	de,hl
4405:	1966  13      		inc	de
4406:	1967  04      		inc	b		;bumping character count tests quote flag
4407:	1968  F4A119  		call	p,zdlm		;only look for delimeters if quote flag off
4408:	196B  23      		inc	hl		;bump parse buffer pointer
4409:	196C  20E2    		jr	nz,prsr30
4410:	196E  2B      		dec	hl
4411:	196F  11A72E  	prsr60:	ld	de,prsbf	;return pointing to start of parse buffer
4412:	1972  326C2D  		ld	(delim),a
4413:	1975  C9      		ret			;zero flag set - no errors
4414:			
4415:			
4416:			
4417:	1976  3E4C    	asm??l:	ld	a,'L'
4418:	1978  1812    		jr	asm???
4419:	197A  3E4F    	asm??o:	ld	a,'O'
4420:	197C  180E    		jr	asm???
4421:	197E  3E50    	asm??p:	ld	a,'P'
4422:	1980  180A    		jr	asm???
4423:	1982  3E53    	asm??s:	ld	a,'S'
4424:	1984  1806    		jr	asm???
4425:	1986  3E54    	asm??t:	ld	a,'T'
4426:	1988  1802    		jr	asm???
4427:	198A  3E56    	asm??v:	ld	a,'V'
4428:			
4429:	198C  323328  	asm???:	ld	(asmflg),a
4430:	198F  CD1125  		call	cret
4431:	1992  2A582D  		ld	hl,(asmbpc)
4432:	1995  CD3025  		call	outadr
4433:	1998  112C28  		ld	de,m????
4434:	199B  CD6F27  		call	print
4435:	199E  C3B214  		jp	asm010
4436:			
4437:			
4438:	19A1  FE2C    	zdlm:	cp	','
4439:	19A3  C8      		ret	z
4440:	19A4  A7      	zdlm00:	and	a
4441:	19A5  C8      		ret	z
4442:	19A6  FE09    		cp	tab
4443:	19A8  C8      		ret	z
4444:	19A9  FE20    		cp	' '
4445:	19AB  C9      		ret
4446:			
4447:	19AC  FE2B    	oprtor: cp	'+'
4448:	19AE  C8      		ret	z
4449:	19AF  FE2D    		cp	'-'
4450:	19B1  C8      		ret	z
4451:	19B2  A7      		and	a
4452:	19B3  C9      		ret
4453:			
4454:			
4455:			
4456:	19B4  EB      	opnv:	ex	de,hl		;de - operand value  hl - operand key storage
4457:	19B5  3AA72E  		ld	a,(prsbf)	;check first byte of parse buffer
4458:	19B8  A7      		and	a		;if null - paren was removed
4459:	19B9  79      		ld	a,c		;key value to accumulator
4460:	19BA  2002    		jr	nz,opnv00	;nz - no paren
4461:	19BC  F680    		or	80h		;found null - set paren flag
4462:	19BE  77      	opnv00:	ld	(hl),a		;store key value
4463:	19BF  23      		inc	hl
4464:	19C0  73      		ld	(hl),e		;lo order operand value
4465:	19C1  23      		inc	hl
4466:	19C2  72      		ld	(hl),d		;hi order
4467:	19C3  C9      		ret
4468:			
4469:			
4471:			;******************************************************************************
4472:			;*
4473:			;*	zlen:  Determine the number of bytes in a z80 instruction
4474:			;*
4475:			;*
4476:			;*	Entry point zlen00: used to return instruction length.
4477:			;*
4478:			;*			    de:	 address of instruction
4479:			;*
4480:			;*	Return:	 b:  z - inline instruction (next pc will be pc plus length)
4481:			;*		    nz - pc modifying instruction such as call, jump, or ret
4482:			;*			 (see hl below)
4483:			;*		 c:	 number of bytes in this instruction.
4484:			;*		de:	 preserved
4485:			;*		hl:	 next pc following the execution of the instruction
4486:			;*			 pointed to by de.
4487:			;*
4488:			;******************************************************************************
4489:			
4490:	19C4  1A      	zlen00:	ld	a,(de)		;fetch first byte of op code
4491:	19C5  FECB    		cp	0cbh		;test for shift/bit manipulation instruction
4492:	19C7  010200  		ld	bc,02
4493:	19CA  C8      		ret	z		;10-4 this is a CB and length is always 2
4494:	19CB  FEED    		cp	0edh		;test for fast eddie
4495:	19CD  201B    		jr	nz,zlen15	;
4496:	19CF  13      		inc	de		;fetch byte two of ED instruction
4497:	19D0  1A      		ld	a,(de)
4498:	19D1  1B      		dec	de		;restore pointer
4499:			
4500:	0000          		if	h64180
4506:				endif
4507:			
4508:	19D2  21DE28  		ld	hl,z80ed	;ED four byter table
4509:	19D5  0E06    		ld	c,z80edl	;length
4510:	19D7  EDB1    		cpir
4511:	19D9  0E04    		ld	c,4		;assume ED four byter
4512:	19DB  C8      		ret	z		;correct assumption
4513:			
4514:	19DC  0E02    		ld	c,2		;set length for return - if not 2 must be 4
4515:	19DE  FE45    		cp	45h		;test for retn
4516:	19E0  2803    		jr	z,zlen10
4517:	19E2  FE4D    		cp	4dh		;test for reti
4518:	19E4  C0      		ret	nz		;non-pc modifying two byte ED
4519:	19E5  3EC9    	zlen10:	ld	a,0c9h		;treat as ordinary return instruction
4520:	19E7  C3A21A  		jp	zlen80
4521:	19EA  FEDD    	zlen15:	cp	0ddh		;check for DD and FD index reg instructions
4522:	19EC  2804    		jr	z,zlen20
4523:	19EE  FEFD    		cp	0fdh
4524:	19F0  2029    		jr	nz,zlen40
4525:	19F2  13      	zlen20:	inc	de		;fetch byte two of index reg instruction
4526:	19F3  1A      		ld	a,(de)
4527:	19F4  1B      		dec	de		;restore pointer
4528:	19F5  FEE9    		cp	0e9h		;check for reg indirect jump
4529:	19F7  200C    		jr	nz,zlen30	;
4530:	19F9  04      		inc	b		;reg indirect jump - set pc modified flag nz
4531:	19FA  1A      		ld	a,(de)		;recheck for ix or iy
4532:	19FB  2A052E  		ld	hl,(ixreg)	;assume ix
4533:	19FE  FEDD    		cp	0ddh
4534:	1A00  C8      		ret	z		;correct assumption
4535:	1A01  2A072E  		ld	hl,(iyreg)
4536:	1A04  C9      		ret
4537:	1A05  219928  	zlen30:	ld	hl,z80fd	;check for DD or FD two byter
4538:	1A08  0E0B    		ld	c,z80fdl
4539:	1A0A  EDB1    		cpir
4540:	1A0C  0E02    		ld	c,2		;assume two
4541:	1A0E  C8      		ret	z
4542:	1A0F  21A428  		ld	hl,z80f4	;not two - try four
4543:	1A12  0E05    		ld	c,z80f4l
4544:	1A14  EDB1    		cpir
4545:	1A16  0E04    		ld	c,4		;assume four
4546:	1A18  C8      		ret	z		;correct assumption
4547:	1A19  0D      		dec	c		;must be three
4548:	1A1A  C9      		ret
4549:	1A1B  E6C7    	zlen40:	and	0c7h		;check for 8 bit immediate load
4550:	1A1D  FE06    		cp	06
4551:	1A1F  0E02    		ld	c,2		;assume so
4552:	1A21  C8      		ret	z
4553:	1A22  0D      		dec	c		;assume one byte op code
4554:	1A23  1A      		ld	a,(de)
4555:	1A24  FE3F    		cp	3fh
4556:	1A26  3803    		jr	c,zlen50	;opcodes 0 - 3f require further investigation
4557:	1A28  FEC0    		cp	0c0h		;8 bit reg-reg loads and arithmetics do not
4558:	1A2A  D8      		ret	c
4559:	1A2B  21C428  	zlen50:	ld	hl,z803		;check for three byter
4560:	1A2E  0E1A    		ld	c,z803l
4561:	1A30  EDB1    		cpir
4562:	1A32  2036    		jr	nz,zlen60	;nz - not three
4563:	1A34  21CC28  		ld	hl,z803s	;established three byter - test conditional
4564:	1A37  0E12    		ld	c,z803cl
4565:	1A39  EDB1    		cpir
4566:	1A3B  0E03    		ld	c,3		;set length
4567:	1A3D  C0      		ret	nz		;nz - three byte inline instruction
4568:	1A3E  21CC28  		ld	hl,z803s
4569:	1A41  0E09    		ld	c,z803sl	;now weed out jumps from calls
4570:	1A43  EDB1    		cpir
4571:	1A45  0E03    		ld	c,3
4572:	1A47  41      		ld	b,c		;set pc modified flag - we have call or jump
4573:	1A48  EB      		ex	de,hl
4574:	1A49  23      		inc	hl
4575:	1A4A  5E      		ld	e,(hl)
4576:	1A4B  23      		inc	hl
4577:	1A4C  56      		ld	d,(hl)		;de - address from instruction
4578:	1A4D  EB      		ex	de,hl
4579:	1A4E  1B      		dec	de
4580:	1A4F  1B      		dec	de		;restore instruction pointer
4581:	1A50  2805    		jr	z,zlen55	;z - this is a call
4582:	1A52  FEC3    		cp	zjp		;test for unconditional jump
4583:	1A54  2057    		jr	nz,zlen85
4584:	1A56  C9      		ret
4585:	1A57  3A642D  	zlen55:	ld	a,(wflag)	;test for no subroutine trace flag
4586:	1A5A  A7      		and	a		;zero means no sub tracing
4587:	1A5B  47      		ld	b,a		;clear for return - if sub trace off
4588:	1A5C  C8      		ret	z		;subroutine trace off - return with b reg 00
4589:							;so bp is set at next inline instruction
4590:	1A5D  05      		dec	b
4591:	1A5E  2003    		jr	nz,zlen58
4592:	1A60  78      		ld	a,b
4593:	1A61  B4      		or	h
4594:	1A62  C8      		ret	z
4595:	1A63  1A      	zlen58:	ld	a,(de)		;recover call object byte
4596:	1A64  41      		ld	b,c		;set nz - pc modifying instruction
4597:	1A65  FECD    		cp	0cdh		;unconditional call??
4598:	1A67  2044    		jr	nz,zlen85	;zlen85 - set secondary breakpoint if tracing
4599:	1A69  C9      		ret
4600:			
4601:	1A6A  21B328  	zlen60:	ld	hl,z802
4602:	1A6D  0E11    		ld	c,z802l		;test for two byter
4603:	1A6F  EDB1    		cpir
4604:	1A71  201C    		jr	nz,zlen70	;not two
4605:	1A73  21BE28  		ld	hl,z802c	;test for relative jump
4606:	1A76  0E06    		ld	c,z802cl
4607:	1A78  EDB1    		cpir
4608:	1A7A  0E02    		ld	c,2		;in any case length is two
4609:	1A7C  C0      		ret	nz		;nz - not relative jump
4610:	1A7D  60      		ld	h,b		;clear
4611:	1A7E  04      		inc	b		;set pc modified flag nz
4612:	1A7F  13      		inc	de		;fetch relative displacement
4613:	1A80  1A      		ld	a,(de)
4614:	1A81  6F      		ld	l,a
4615:	1A82  87      		add	a,a		;test forward or backward
4616:	1A83  3001    		jr	nc,zlen65	;p - forward
4617:	1A85  25      		dec	h		;set hl negative
4618:	1A86  19      	zlen65:	add	hl,de		;compute distance from instruction
4619:	1A87  23      		inc	hl		;adjust for built in bias
4620:	1A88  1B      		dec	de		;restore pointer
4621:	1A89  1A      		ld	a,(de)		;fetch first byte of instruction
4622:	1A8A  FE18    		cp	18h		;uncondtional jump?
4623:	1A8C  201F    		jr	nz,zlen85	;conditional - set secondary bp if tracing
4624:	1A8E  C9      		ret
4625:	1A8F  21A928  	zlen70:	ld	hl,z801		;check for return instruction
4626:	1A92  0E0A    		ld	c,z801l
4627:	1A94  EDB1    		cpir
4628:	1A96  0E01    		ld	c,1		;length must be 1 in any case
4629:	1A98  C0      		ret	nz
4630:	1A99  FEE9    		cp	0e9h
4631:	1A9B  2005    		jr	nz,zlen80	;nz - not  jp (hl)
4632:	1A9D  04      		inc	b		;set pc modified flag
4633:	1A9E  2AF72D  		ld	hl,(hlreg)	;next pc contained in hlreg
4634:	1AA1  C9      		ret
4635:	1AA2  2A032E  	zlen80:	ld	hl,(spreg)	;return instructions hide next pc in stack
4636:	1AA5  46      		ld	b,(hl)
4637:	1AA6  23      		inc	hl
4638:	1AA7  66      		ld	h,(hl)
4639:	1AA8  68      		ld	l,b		;hl - return address removed from stack
4640:	1AA9  41      		ld	b,c		;set b nz - pc modification flag
4641:	1AAA  FEC9    		cp	0c9h
4642:	1AAC  C8      		ret	z		;unconditional return
4643:	1AAD  3A672D  	zlen85:	ld	a,(sbps)	;count of special step breakpoints
4644:	1AB0  A7      		and	a		;test for zero
4645:	1AB1  C8      		ret	z		;zero - monitor is not tracing
4646:	1AB2  3A682D  		ld	a,(bps)		;fetch number of bps currently in effect
4647:	1AB5  47      		ld	b,a		;pass to set breakpoint routine in b reg
4648:	1AB6  EB      		ex	de,hl		;de - bp to set
4649:	1AB7  CDF911  		call	brk30		;set conditional breakpoint
4650:	1ABA  AF      		xor	a
4651:	1ABB  B0      		or	b
4652:	1ABC  0600    		ld	b,0
4653:	1ABE  ED5B012E		ld	de,(pcreg)	;for setting inline bp - condition not m
4654:	1AC2  C0      		ret	nz		;nz - collision with user bp
4655:	1AC3  21672D  		ld	hl,sbps
4656:	1AC6  34      		inc	(hl)		;bump count of step bps
4657:	1AC7  C9      		ret
4658:			
4660:			;******************************************************************************
4661:			;*
4662:			;*	pswDsp:	Display current state of flag register
4663:			;*
4664:			;*	pswbit:	Table of bit masks with which to test f reg.
4665:			;*		Two byte entry per bit (sign, zero, carry, parity).
4666:			;*
4667:			;*	pswmap - table of offsets into operand name table featuring a
4668:			;*		 two byte entry for each flag bit.
4669:			;*		 bit 4 (unused by z80) from pswbit entry is on/off flag
4670:			;*		 lo bytes are the off states (p nz nc po).
4671:			;*		 hi bytes are the on states  (m  z  c pe).
4672:			;*
4673:			;*	- current state of flag register is displayed
4674:			;*	- user queried for changes
4675:			;*	- input is parsed and tested for valid flag reg mnemonics
4676:			;*	- if valid mnemonic found flag bit is set or reset accordingly
4677:			;*
4678:			;*	exit:	to z8e for next command
4679:			;*
4680:			;******************************************************************************
4681:			
4682:	1AC8  110300  	pswDsp:	ld	de,3
4683:	1ACB  0600    		ld	b,0			;+ eg 3.3.5a
4684:	1ACD  21202D  	psw00:	ld	hl,pswbit		;table of bit mask for flags
4685:	1AD0  19      		add	hl,de			;
4686:	1AD1  19      		add	hl,de			;index times two
4687:	1AD2  7B      		ld	a,e
4688:	1AD3  ED44    		neg				;now calculate index into pswmap
4689:	1AD5  C603    		add	a,3
4690:	1AD7  87      		add	a,a
4691:	1AD8  4F      		ld	c,a
4692:	1AD9  3AF12D  		ld	a,(freg)		;fetch current flag of user
4693:	1ADC  E6F7    		and	0f7h
4694:	1ADE  A6      		and	(hl)			;unused bit in flag - ensure it's off
4695:	1ADF  21282D  		ld	hl,pswmap
4696:	1AE2  09      		add	hl,bc			;pointer to mnemonic is 8 bytes away
4697:	1AE3  2801    		jr	z,psw10			;this is an off bit (nz nc p po)
4698:	1AE5  23      		inc	hl			;on
4699:	1AE6  4E      	psw10:	ld	c,(hl)			;fetch index into operand name table
4700:	1AE7  218327  		ld	hl,zopnm
4701:	1AEA  09      		add	hl,bc			;two bytes per table entry
4702:	1AEB  09      		add	hl,bc
4703:	1AEC  0E02    		ld	c,2			;print both chars of mnemonic name
4704:	1AEE  CD7827  		call	printb
4705:	1AF1  CD1925  		call	space1
4706:	1AF4  1D      		dec	e			;do all four flag bits
4707:	1AF5  F2CD1A  		jp	p,psw00
4708:	1AF8  CD0C25  		call	crlf
4709:	1AFB  3A3528  		ld	a,(lcmd)
4710:			
4711:			;	cp	'J'			;- eg 3.3.5a
4712:			;	ret	z			;-
4713:	1AFE  FE50    		cp	'P'			;+ Routine can now be called from
4714:	1B00  C0      		ret	nz			;+  elsewhere
4715:			
4716:	1B01  CD1E25  		call	space5
4717:	1B04  CD7E26  	psw50:	call	iedtbc
4718:	1B07  F8      		ret	m			;no input
4719:	1B08  CD2719  	psw55:	call	prsr
4720:	1B0B  C0      		ret	nz			;parse error - end command
4721:	1B0C  011601  		ld	bc,116h			;
4722:	1B0F  CD3817  		call	oprn20			;check validity of this token
4723:	1B12  79      		ld	a,c
4724:	1B13  010800  		ld	bc,pswcnt		;number of flag reg mnemonics
4725:	1B16  21282D  		ld	hl,pswmap
4726:	1B19  EDB1    		cpir				;check table
4727:	1B1B  C2780C  		jp	nz,e???			;error - nmemonic not found
4728:	1B1E  21202D  		ld	hl,pswbit		;bit mask table
4729:	1B21  09      		add	hl,bc
4730:	1B22  7E      		ld	a,(hl)			;fetch mask
4731:	1B23  EB      		ex	de,hl			;
4732:	1B24  21F12D  		ld	hl,freg			;de - mask ptr   hl - user flag ptr
4733:	1B27  E608    		and	08			;bit says turn on or off
4734:	1B29  1A      		ld	a,(de)			;new copy of mask
4735:	1B2A  2005    		jr	nz,psw60		;nz - turn on
4736:	1B2C  2F      		cpl
4737:	1B2D  A6      		and	(hl)			;and with current user flag
4738:	1B2E  77      		ld	(hl),a			;return flag reg with bit now off
4739:	1B2F  18D7    		jr	psw55			;check for more input
4740:	1B31  E6F7    	psw60:	and	0f7h			;turn off on/off flag (bit 4)
4741:	1B33  B6      		or	(hl)
4742:	1B34  77      		ld	(hl),a			;now turn on specified bit
4743:	1B35  18D1    		jr	psw55
4744:			
4746:			;******************************************************************************
4747:			;*
4748:			;*	movb:	Move memory
4749:			;*
4750:			;*	call bcde to fetch destination block address and byte count
4751:			;*	call prsr
4752:			;*	check for head to head or tail to tail move
4753:			;*
4754:			;*	exit: to z8e for next command
4755:			;*
4756:			;******************************************************************************
4757:			
4758:	1B37  CD3F24  	movb:	call	bcde		;bc - byte count  de - destination  hl - source
4759:	1B3A  C2780C  		jp	nz,e???		;input error ends command
4760:	1B3D  AF      		xor	a
4761:	1B3E  ED52    		sbc	hl,de
4762:	1B40  8F      		adc	a,a
4763:	1B41  19      		add	hl,de
4764:	1B42  09      		add	hl,bc
4765:	1B43  2B      		dec	hl
4766:	1B44  EB      		ex   	de,hl		;de - address of last byte of source block
4767:	1B45  ED52    		sbc	hl,de
4768:	1B47  8F      		adc	a,a
4769:	1B48  19      		add	hl,de		;hl - original destination address
4770:	1B49  EB      		ex	de,hl
4771:	1B4A  FE03    		cp	3
4772:	1B4C  2007    		jr	nz,movb00	;head to head
4773:	1B4E  EB      		ex	de,hl
4774:	1B4F  09      		add	hl,bc
4775:	1B50  2B      		dec	hl
4776:	1B51  EB      		ex	de,hl
4777:	1B52  EDB8    		lddr
4778:	1B54  C9      		ret
4779:	1B55  23      	movb00:	inc	hl
4780:	1B56  A7      		and	a
4781:	1B57  ED42    		sbc	hl,bc
4782:	1B59  EDB0    		ldir
4783:	1B5B  C9      		ret
4784:			
4786:			;******************************************************************************
4787:			;*
4788:			;*	yfil:	Fill memory
4789:			;*
4790:			;*	call bcde to get byte count, starting address, and fill byte
4791:			;*
4792:			;*	exit:	to z8e for next command
4793:			;*
4794:			;******************************************************************************
4795:			
4796:	1B5C  CD3F24  	yfil:	call	bcde		;bc - byte count  de - fill byte  hl - block
4797:	1B5F  C2780C  		jp	nz,e???		;input error ends command
4798:	1B62  EB      		ex	de,hl
4799:	1B63  21112E  	yfil00:	ld	hl,argbf
4800:	1B66  3A0D2E  		ld	a,(argbc)
4801:	1B69  EDA0    	yfil10:	ldi
4802:	1B6B  04      		inc	b
4803:	1B6C  1003    		djnz	yfil20
4804:	1B6E  0C      		inc	c
4805:	1B6F  0D      		dec	c
4806:	1B70  C8      		ret	z
4807:	1B71  3D      	yfil20:	dec	a
4808:	1B72  20F5    		jr	nz,yfil10
4809:	1B74  18ED    		jr	yfil00
4810:			
4812:			;*********************************************************************
4813:			;
4814:			;	CUSER	Change user routine	EG	5 Jan 88
4815:			;
4816:			;	10 Jan 88	Added check for bad args
4817:			;
4818:			;	Uses '>' as command
4819:			;
4820:			;*********************************************************************
4821:			
4822:	1B76  CD7E26  	cuser:	call 	iedtbc
4823:	1B79  F8      		ret 	m
4824:	1B7A  CDA025  		call 	iarg		; gets user in HL as a hex no
4825:	1B7D  C2780C  		jp 	nz,e???		; don't allow bad (would go to user 0)
4826:	1B80  7C      		ld 	a,h
4827:	1B81  B7      		or 	a
4828:	1B82  C2780C  		jp 	nz,e???		; 2 - byte user number?
4829:	1B85  7D      		ld 	a,l
4830:	1B86  FE10    		cp 	10h
4831:	1B88  3807    		jr 	c,cusok		; you can enter user in hex or decimal with '#'
4832:	1B8A  D606    		sub 	6		; else convert to decimal
4833:	1B8C  FE10    		cp 	10h		; see if still too big
4834:	1B8E  D2780C  		jp	nc,e???
4835:	1B91  0E20    	cusok:	ld 	c,32
4836:	1B93  5F      		ld 	e,a
4837:	1B94  C30500  		jp 	bdos		; change user
4838:			
4839:			;*******************************************************************
4840:			;
4841:			;	QEVAL - expression evaluator	EG 10 Jan 88
4842:			;
4843:			;	Uses '?' as command
4844:			;
4845:			;*******************************************************************
4846:	1B97  CD7E26  	qeval: 	call 	iedtbc		; get input
4847:	1B9A  F8      		ret 	m		; none
4848:	1B9B  CDA025  		call 	iarg		; Z8E does all the real work
4849:	1B9E  C2780C  		jp 	nz,e???		; check for valid arg
4850:	1BA1  CD0C25  		call 	crlf
4851:	1BA4  7C      		ld 	a,h		; see if 1 byte
4852:	1BA5  B7      		or 	a
4853:	1BA6  201E    		jr 	nz,qev01	; 2-byte number
4854:	1BA8  7D      		ld 	a,l
4855:	1BA9  CD3A25  		call 	outhex		; hex byte
4856:	1BAC  7D      		ld 	a,l
4857:	1BAD  FE7F    		cp 	7fh		; see if printable
4858:	1BAF  D0      		ret 	nc
4859:	1BB0  FE20    		cp 	' '
4860:	1BB2  D8      		ret 	c
4861:	1BB3  0E03    		ld 	c,3
4862:	1BB5  CD2025  		call 	spaces		; even up with spaces
4863:	1BB8  3E27    		ld 	a,27h		; quote
4864:	1BBA  CD8224  		call 	ttyo
4865:	1BBD  7D      		ld 	a,l		; show char
4866:	1BBE  CD8224  		call 	ttyo
4867:	1BC1  3E27    		ld 	a,27h
4868:	1BC3  C38224  		jp 	ttyo
4869:	1BC6  C33025  	qev01:	jp 	outadr		; output 2-byte result
4870:			
4871:			;***********************************************************
4872:			;
4873:			;	GADR - Get program addr data	EG 20 Feb 88
4874:			;
4875:			;	Uses '#' as command
4876:			;
4877:			;	Deleted 5/Jan/89 by jrs - unnecessary as L command
4878:			;	with no file name (now) does the same thing.
4879:			;
4880:			;************************************************************
4881:			;gadr:	ld 	hl,(loadn)
4882:			;	ld 	c,10		; out-of-memory flag
4883:			;	jp 	lbin22
4884:			
4886:			;------------------------------------------------------------------------------
4887:			;
4888:			;	Initialise default FCB fields and command line	(16 may 87  jrs)
4889:			;
4890:			;	Calls iedtbc to get command tail
4891:			;	      lfcb   twice to extract file names
4892:			;
4893:			;	exit:	FCB name fields at 5Ch and 6Ch initialised
4894:			;		Command tail set up at 80h
4895:			;
4896:			;------------------------------------------------------------------------------
4897:			
4898:	1BC9          	ifcb:				;(Condensed, improved version - jrs 27 Dec 88)
4899:			
4900:	1BC9  CD7E26  		call	iedtbc		;Get command tail
4901:	1BCC  2B      		dec	hl		;Point at input buffer length
4902:	1BCD  E5      		push	hl		;Save input buffer pointer
4903:	1BCE  215C00  		ld	hl,fcb5c	;Zero out the default FCB
4904:	1BD1  0620    		ld	b,32
4905:	1BD3  3600    	ifcb00:	ld	(hl),0
4906:	1BD5  23      		inc	hl
4907:	1BD6  10FB    		djnz	ifcb00
4908:	1BD8  2E5D    		ld	l,fcb5c+1	;Blank out the two file names
4909:	1BDA  CD141C  		call	iblank
4910:	1BDD  2E6D    		ld	l,fcb5c+17
4911:	1BDF  CD141C  		call	iblank
4912:	1BE2  E1      		pop	hl		;Get input buffer pointer
4913:	1BE3  118000  		ld	de,80h		;Destination is command line buffer
4914:	1BE6  46      		ld	b,(hl)		;Get input buffer length
4915:	1BE7  78      		ld	a,b		;Load length ready to put in command buffer
4916:	1BE8  04      		inc	b		;Account for the length byte itself
4917:	1BE9          	ifcb02:
4918:	1BE9  12      		ld	(de),a		;Store character in command buffer
4919:	1BEA  13      		inc	de		;Increment pointers
4920:	1BEB  23      		inc	hl
4921:	1BEC  7E      		ld	a,(hl)		;Load character from input buffer
4922:	1BED  CD0325  		call	ixlt		;Translate to upper case
4923:	1BF0  10F7    		djnz	ifcb02		;Loop until all copied
4924:	1BF2  AF      		xor	a		;Terminate the command buffer properly
4925:	1BF3  12      		ld	(de),a
4926:	1BF4  CD0B1D  		call	lfcb		;Get a file name (if any)
4927:	1BF7  200B    		jr	nz,ifcb12	;Skip if error
4928:	1BF9  115C00  		ld	de,fcb5c	;Copy FCB to default FCB at 5ch
4929:	1BFC  212B2E  		ld	hl,fcb
4930:	1BFF  010C00  		ld	bc,12		;(only move 12 bytes)
4931:	1C02  EDB0    		ldir
4932:	1C04          	ifcb12:
4933:	1C04  CD0B1D  		call	lfcb		;Do second file name (if any)
4934:	1C07  C0      		ret	nz		;Exit now if error
4935:	1C08  212B2E  		ld	hl,fcb		;Copy file name part of FCB to
4936:	1C0B  116C00  		ld	de,fcb5c+16	; second segment of default FCB
4937:	1C0E  010C00  		ld	bc,12
4938:	1C11  EDB0    		ldir
4939:	1C13  C9      		ret
4940:			
4941:	1C14          	iblank:				;Blank out 11 bytes at HL
4942:	1C14  060B    		ld	b,11
4943:	1C16  3620    	ibl00:	ld	(hl),' '
4944:	1C18  23      		inc	hl
4945:	1C19  10FB    		djnz	ibl00
4946:	1C1B  C9      		ret
4947:			
4948:			
4949:			; I originally intended that the following code should be used to expand
4950:			; asterisks in file names but I never invoked it anywhere!  Eventually
4951:			; someone complained and I corrected the omission by adding some code to
4952:			; the LFCB routine.  When I (re)discovered this code I noticed that it was
4953:			; longer than the code added to LFCB so I commented it out.  I am leaving
4954:			; it here because LFCB was never intended to handle ambiguous file names.
4955:			; I don't think there is a problem but should there turn out to be some
4956:			; sort of wierd conflict then it should be easy to activate this little
4957:			; routine.	jrs 27 Dec 88
4958:			;
4959:			;iwild:				;Expand asterisks in file names
4960:			;	ld	bc,8		;Enter with HL pointing at FCB+1
4961:			;	call	iexp		; i.e. first byte of file name.
4962:			;	ld	bc,3
4963:			;;	call	iexp
4964:			;;	ret
4965:			;iexp:
4966:			;	ld	a,'*'
4967:			;	cpir
4968:			;	ret	nz
4969:			;	inc	bc
4970:			;	dec	hl
4971:			;iexp10:
4972:			;	ld	(hl),'?'
4973:			;	inc	hl
4974:			;	dec	c
4975:			;	ret	z
4976:			;	jr	iexp10
4977:			
4979:			;******************************************************************************
4980:			;*
4981:			;*	lldr:	Load file
4982:			;*	User may supply optional load bias if file name ends with comma.
4983:			;*
4984:			;*	lfcb:	Parse input buffer (inbf) and init FCB
4985:			;*
4986:			;*		Return:	z  - FCB initialized
4987:			;*			nz - syntax error
4988:			;*
4989:			;*	lopn:	Attempt to open file
4990:			;*
4991:			;*		Return:	nz - file opened
4992:			;*			 z - file not found
4993:			;*
4994:			;*	lmem:	Test if sufficient memory available for loading
4995:			;*
4996:			;*		Return: nc - out of memory
4997:			;*
4998:			;*	lbin: Loader
4999:			;*
5000:			;*		Eof found:     end command
5001:			;*		Out of memory: query user whether to continue
5002:			;*
5003:			;******************************************************************************
5004:			
5005:	1C1C  CD7E26  	lldr:	call	iedtbc		;Get file name
5006:	1C1F  F22F1C  		jp 	p,lldr00     	;P - have input in inbf
5007:	1C22  2A562D  		ld	hl,(loadn)
5008:	1C25  7D      		ld	a,l
5009:	1C26  B4      		or	h
5010:	1C27  CA780C  		jp	z,e???
5011:			;	ld	c,a		;-
5012:	1C2A  0E0A    		ld	c,10		;+ 3.5.5 jrs 5/jan/89
5013:	1C2C  C3901C  		jp	lbin22
5014:	1C2F  CD0C25  	lldr00:	call	crlf
5015:	1C32  CD0B1D  		call	lfcb		;Init FCB with name and drive
5016:	1C35  C2971D  		jp	nz,esntx	;nz - syntax error
5017:	1C38  113A28  		ld	de,mldg		;Display loading string
5018:	1C3B  CD6C27  		call	nprint
5019:	1C3E  11A72E  		ld	de,prsbf
5020:	1C41  1A      		ld	a,(de)		;A - first char of file name
5021:	1C42  47      		ld	b,a
5022:	1C43  CD6F27  		call	print
5023:	1C46  3E2C    		ld	a,','
5024:	1C48  B9      		cp	c		;C - terminator following file name (from lfcb)
5025:	1C49  210001  		ld	hl,100h		;Assume no bias
5026:	1C4C  200C    		jr	nz,lldr05	;NZ - no comma means no load bias
5027:	1C4E  CDA025  		call	iarg		;Check for load bias
5028:	1C51  C2971D  		jp	nz,esntx	;Error - bad argument
5029:	1C54  CD8D1D  		call	imem		;Check available memory
5030:	1C57  D29C1D  		jp	nc,emem??	;Out of memory
5031:	1C5A  22542D  	lldr05:	ld	(loadb),hl	;Save load bias
5032:	1C5D  3E2E    		ld	a,'.'		;Test if file name is period
5033:	1C5F  90      		sub	b
5034:	1C60  2806    		jr	z,lbin		;File name is period - no open needed
5035:	1C62  CD721D  	lldr10:	call	lopn		;Attempt to open file - entry from nint
5036:	1C65  CAA41D  		jp	z,efilnf	;Z - file not found
5037:			
5038:			
5039:	1C68          	lbin:
5040:	1C68  2A542D  		ld	hl,(loadb)	;Fetch starting load address
5041:	1C6B  E5      	lbin00:	push	hl
5042:	1C6C  EB      		ex	de,hl
5043:	1C6D  0E1A    		ld	c,26		;Set CP/M DMA address
5044:	1C6F  CD0500  		call	bdos
5045:	1C72  112B2E  		ld	de,fcb
5046:	1C75  0E14    		ld	c,20		;CP/M sequential file read
5047:	1C77  CD0500  		call	bdos
5048:	1C7A  D1      		pop	de		;Recover DMA address
5049:	1C7B  218000  		ld	hl,80h
5050:	1C7E  19      		add	hl,de		;Compute next DMA address
5051:	1C7F  32712D  		ld	(cflag),a	;Save EOF indicator as continuation flag
5052:	1C82  4F      		ld	c,a
5053:	1C83  A7      		and	a
5054:	1C84  2005    		jr	nz,lbin20	;NZ - end of file
5055:	1C86  CD8D1D  		call	imem		;Test if memory available to load next sector
5056:	1C89  38E0    		jr	c,lbin00	;C - not out of memory
5057:	1C8B  EB      	lbin20:	ex	de,hl
5058:	1C8C  2B      		dec	hl
5059:	1C8D  22562D  		ld      (loadn),hl	;End of load address
5060:	1C90  115528  	lbin22: ld	de,mlodm	;Print loaded message
5061:	1C93  CD6C27  		call	nprint
5062:	1C96  EB      		ex	de,hl		;DE - ending address of load
5063:	1C97  2A542D  		ld	hl,(loadb)
5064:	1C9A  CD3025  		call	outadr		;Display starting address of load
5065:	1C9D  EB      		ex	de,hl
5066:	1C9E  CD3025  		call	outadr		;Display ending address
5067:	1CA1  A7      		and	a
5068:	1CA2  ED52    		sbc	hl,de
5069:	1CA4  24      		inc	h
5070:	1CA5  115F28  		ld	de,mlodpg
5071:	1CA8  CD6C27  		call	nprint		;Display pages string
5072:	1CAB  6F      		ld	l,a		;zero L reg
5073:	1CAC  7C      		ld	a,h		;Hi byte of ending address is number of pages
5074:	1CAD  FE64    		cp	100
5075:	1CAF  380E    		jr	c,lbin30	;Less than 100
5076:	1CB1  2E32    		ld	l,'2'
5077:	1CB3  D6C8    		sub	200
5078:	1CB5  3003    		jr	nc,lbin25	;Greater than 200
5079:	1CB7  2D      		dec	l		;change to ASCII 1
5080:	1CB8  C664    		add	a,100		;Restore actual page count less 100
5081:	1CBA  67      	lbin25:	ld	h,a		;Save page count
5082:	1CBB  7D      		ld	a,l
5083:	1CBC  CD8224  		call	ttyo
5084:	1CBF  162F    	lbin30:	ld	d,2fh
5085:	1CC1  7C      		ld	a,h
5086:	1CC2  14      	lbin35:	inc	d		;Tens and units decimal conversion loop
5087:	1CC3  D60A    		sub	10
5088:	1CC5  30FB    		jr	nc,lbin35
5089:	1CC7  C60A    		add	a,10		;Restore remainder
5090:	1CC9  5F      		ld	e,a		;Temp save while we print tens
5091:	1CCA  7A      		ld	a,d
5092:	1CCB  2C      		inc	l
5093:	1CCC  2D      		dec	l		;Test L reg
5094:	1CCD  2002    		jr	nz,lbin40	;NZ - ASCII 1 or 2 in L
5095:	1CCF  FE30    		cp	'0'		;Suppress leading zero - less than 10 pages
5096:	1CD1  C48224  	lbin40:	call	nz,ttyo		;Print tens digit
5097:	1CD4  7B      		ld	a,e
5098:	1CD5  F630    		or	'0'
5099:	1CD7  CD8224  		call	ttyo		;Print units
5100:	1CDA  CD0C25  		call	crlf
5101:			;	xor	a		;- eg 3.3.7a Test eof flag
5102:			;	or	c		;-
5103:	1CDD  79      		ld	a,c		;+ Test EOF flag
5104:	1CDE  FE0A    		cp	10		;+ Was it set by GADR (see 3.3.11)
5105:	1CE0  CA100B  		jp	z,z8e		;+ Exit if so
5106:	1CE3  B7      		or	a		;+
5107:			;	jp	nz,z8e		;- nz - true eof means file loading complete
5108:	1CE4  201A    		jr	nz,z8ej		;+
5109:	1CE6  117828  		ld	de,mmem??	;Print "out of memory" message
5110:	1CE9  CD6F27  		call	print
5111:	1CEC  118628  		ld	de,mcntu
5112:	1CEF  CD6F27  		call	print		;Print continue? prompt
5113:	1CF2  CDCC24  		call	inchar
5114:	1CF5  CD0325  		call	ixlt		;Make sure its upper case
5115:	1CF8  FE59    		cp	'Y'
5116:	1CFA  CD0C25  		call	crlf
5117:	1CFD  CA681C  		jp	z,lbin		;User wants more loading
5118:	1D00          	z8ej:				;+
5119:	1D00  0E1A    		ld	c,26		;+ "Set DMA" function
5120:	1D02  118000  		ld	de,80h		;+ Restore default DMA for user program
5121:	1D05  CD0500  		call	bdos		;+
5122:	1D08  C3100B  		jp	z8e		;Next command
5123:			
5124:			
5125:	1D0B  CD2719  	lfcb:	call	prsr		;parse input buffer to extract file name
5126:	1D0E  57      		ld	d,a		;save char which terminated file name
5127:	1D0F  3E0E    		ld	a,14
5128:	1D11  B8      		cp	b		;over 14 chars is ng file name
5129:	1D12  D8      		ret	c
5130:	1D13  48      		ld	c,b		;b and c - byte count of file name
5131:	1D14  100D    		djnz	lfcb00		;test for only one char in name
5132:	1D16  3AA72E  		ld	a,(prsbf)	;only one - is it period?
5133:	1D19  D62E    		sub	'.'
5134:	1D1B  2006    		jr	nz,lfcb00
5135:	1D1D  4A      		ld	c,d		;return terminator
5136:	1D1E  3A712D  		ld	a,(cflag)	;continuation allowed?
5137:	1D21  A7      		and	a		;let lldr decide
5138:	1D22  C9      		ret
5139:	1D23  0600    	lfcb00:	ld	b,0
5140:	1D25  3E3A    		ld	a,':'		;check for drive specifier in input
5141:	1D27  EDB9    		cpdr
5142:	1D29  41      		ld	b,c		;b - number of chars preceding colon
5143:	1D2A  4A      		ld	c,d		;return terminator in c
5144:	1D2B  112B2E  		ld	de,fcb
5145:	1D2E  3E00    		ld	a,0
5146:	1D30  200A    		jr	nz,lfcb10	;nz - no colon
5147:	1D32  05      		dec	b
5148:	1D33  C0      		ret	nz		;syntax error - more than one char
5149:	1D34  7E      		ld	a,(hl)		;fetch drive specifier
5150:	1D35  CD0325  		call	ixlt
5151:	1D38  77      		ld	(hl),a		;back to parse buffer as upper case
5152:	1D39  D640    		sub	40h		;make name into number
5153:	1D3B  23      		inc	hl
5154:	1D3C          	lfcb10:
5155:	1D3C  12      	       	ld	(de),a		;store drive number in fcb
5156:	1D3D  3E20    		ld	a,' '
5157:	1D3F  060B    		ld	b,11		;clear file name in fcb to spaces
5158:	1D41  13      	lfcb20:	inc	de
5159:	1D42  12      		ld	(de),a
5160:	1D43  10FC    		djnz	lfcb20
5161:	1D45  0608    		ld	b,8		;max chars allowed in file name
5162:	1D47  112C2E  		ld	de,fcbnam
5163:	1D4A  CD551D  	lfcb30:	call	lfcb90
5164:	1D4D  F8      		ret	m		;error - too many chars in file name
5165:	1D4E  0603    		ld	b,3		;max chars allowed in file type
5166:	1D50  11342E  		ld	de,fcbtyp
5167:	1D53  A7      		and	a
5168:	1D54  C8      		ret	z		;z - no file type after all
5169:			
5170:			
5171:			
5172:	1D55  23      	lfcb90:	inc	hl		;Bump buffer pointer
5173:	1D56  7E      		ld	a,(hl)
5174:	1D57  A7      		and	a		;Test for null at end of file name
5175:	1D58  C8      		ret	z		;Null found - nothing more to parse
5176:	1D59  CD0325  		call	ixlt
5177:	1D5C  77      		ld	(hl),a		;Translate parse buffer to upper case
5178:	1D5D  FE2E    		cp	'.'
5179:	1D5F  C8      		ret	z		;Period found - move file type into FCB
5180:			
5181:			; --- Added 4 Dec 88 --- jrs
5182:	1D60  FE2A    		cp	'*'		;Expandable wildcard?
5183:	1D62  2806    		jr	z,lfcb95
5184:			; --- end of added code ---
5185:	1D64  05      		dec	b		;Dec max chars allowed
5186:	1D65  F8      		ret	m		;Error if name or extension is too long
5187:							; or a character follows an asterisk
5188:	1D66  12      		ld	(de),a		;Upper case only into FCB
5189:	1D67  13      		inc	de
5190:	1D68  18EB    		jr	lfcb90
5191:			; --- Added 4 Dec 88 --- jrs
5192:	1D6A          	lfcb95:
5193:	1D6A  3E3F    		ld	a,'?'
5194:	1D6C          	lfcb96:
5195:	1D6C  12      		ld	(de),a
5196:	1D6D  13      		inc	de
5197:	1D6E  10FC    		djnz	lfcb96
5198:	1D70  18E3    		jr	lfcb90
5199:			; --- end of added code ---
5200:	1D72          	lopn:
5201:	1D72  212C2E  		ld	hl,fcbnam	;test for file name present
5202:	1D75  7E      		ld	a,(hl)
5203:	1D76  FE20    		cp	' '
5204:	1D78  C8      		ret	z		;space found means not file
5205:			;;	dec	hl
5206:			;;	ld	a,(hl)		;drive specifier
5207:			;;	and	a		;test for default drive
5208:			;	jr	z,lopn00	;z - default means no selection required
5209:			;	dec	a		;select drive
5210:			;	ld	e,a
5211:			;	ld	c,14
5212:			;	call	bdos
5213:	1D79  112B2E  	lopn00:	ld	de,fcb
5214:	1D7C  0618    		ld	b,nfcb-fcbext
5215:	1D7E  21372E  		ld	hl,fcbext	;clear remainder of fcb
5216:	1D81  3600    	lopn10:	ld	(hl),0
5217:	1D83  23      		inc	hl
5218:	1D84  10FB    		djnz	lopn10
5219:	1D86  0E0F    		ld	c,15
5220:	1D88  CD0500  		call	bdos		;tell bdos to open file
5221:	1D8B  3C      		inc	a		;test open return code
5222:	1D8C  C9      		ret			;nz - open ok
5223:			
5224:	1D8D  EB      	imem:	ex	de,hl		;de - next load address
5225:	1D8E  7A      		ld	a,d
5226:	1D8F  210700  		ld	hl,07		;ptr to prt to start of z8e
5227:	1D92  BE      		cp	(hl)
5228:	1D93  EB      		ex	de,hl
5229:	1D94  D8      		ret	c		;c - not out of memory
5230:	1D95  EB      		ex	de,hl
5231:	1D96  C9      		ret			;de - last address loaded plus one
5232:			
5233:	1D97  116928  	esntx:	ld	de,msntx	;print syntax error
5234:	1D9A  180B    		jr	eprint
5235:			
5236:	1D9C  117828  	emem??:	ld	de,mmem??	;print out of memory
5237:	1D9F  CD6C27  		call	nprint
5238:	1DA2  1803    		jr	eprint
5239:			
5240:	1DA4  114428  	efilnf:	ld	de,mfilnf	;print file not found
5241:			
5242:	1DA7  CD6C27  	eprint:	call	nprint
5243:	1DAA  C3100B  		jp	z8e
5244:			
5246:			;*****************************************************************************
5247:			;*
5248:			;*            write memory segment to disk command
5249:			;*
5250:			;*****************************************************************************
5251:			
5252:	1DAD  CD7E26  	writ:	call	iedtbc		;fetch line of input
5253:	1DB0  F8      		ret	m		;no input -
5254:	1DB1  CD4822  		call	bldf		;build fcb with first arg in buffer
5255:	1DB4  20E1    		jr	nz,esntx	;oops - syntax error
5256:	1DB6  3A6C2D  		ld	a,(delim)	;check char that terminated file name
5257:	1DB9  A7      		and	a
5258:	1DBA  2009    		jr	nz,writ10	;nz - not null means user entered addresses
5259:			
5260:	1DBC  ED5B542D		ld	de,(loadb)	;use default begin and end address of the last
5261:	1DC0  2A562D  		ld	hl,(loadn)	;file loaded
5262:	1DC3  1812    		jr	writ30
5263:	1DC5  CDA025  	writ10:	call	iarg		;get address
5264:	1DC8  C2780C  		jp	nz,e???		;invalid address
5265:	1DCB  EB      		ex	de,hl
5266:	1DCC  FE20    		cp	' '		;space terminator
5267:	1DCE  C2780C  		jp	nz,e???		;anything but is error
5268:	1DD1  CDA025  	writ20:	call	iarg		;get end address
5269:	1DD4  C2780C  		jp	nz,e???
5270:	1DD7  225C2D  	writ30:	ld	(endw),hl	;save address of where to end writing
5271:	1DDA  EB      		ex	de,hl
5272:	1DDB  0E03    		ld	c,3
5273:	1DDD  CD2025  		call	spaces
5274:	1DE0  CD3025  		call	outadr
5275:	1DE3  EB      		ex	de,hl
5276:	1DE4  0E06    		ld	c,6
5277:	1DE6  CD2025  		call	spaces
5278:	1DE9  CD2C22  	writ40:	call	bwrite
5279:	1DEC  217F00  		ld	hl,127
5280:	1DEF  19      		add	hl,de
5281:	1DF0  0606    		ld	b,6
5282:	1DF2  CD3927  	writ50:	call	bksp
5283:	1DF5  10FB    		djnz	writ50
5284:	1DF7  CD3025  		call	outadr
5285:	1DFA  23      		inc	hl
5286:	1DFB  EB      		ex	de,hl
5287:	1DFC  2A5C2D  		ld	hl,(endw)
5288:	1DFF  ED52    		sbc	hl,de
5289:	1E01  30E6    		jr	nc,writ40
5290:	1E03  C30D22  		jp	closef
5291:			
5292:			
5293:			
5294:			;******************************************************************************
5295:			;*
5296:			;*	find:	Locate string in memory
5297:			;*
5298:			;*		call iarg - get starting address of seach
5299:			;*
5300:			;*		call in00 - get match data concatenating multiple arguments
5301:			;*			    into a single string
5302:			;*
5303:			;*		Addresses at which matches found displayed 8 per line.
5304:			;*		Search continues until end of memory reached.
5305:			;*		User may cancel search at any time by hitting any key.
5306:			;*
5307:			;*		exit: to z8e for next command
5308:			;*
5309:			;******************************************************************************
5310:			
5311:	1E06  CD7E26  	find:	call	iedtbc
5312:	1E09  F8      		ret	m		;m - no input
5313:	1E0A  CDA025  		call	iarg		;extract starting address of search
5314:	1E0D  C2780C  		jp	nz,e???		;error
5315:	1E10  EB      		ex	de,hl		;save starting address of search in de
5316:	1E11  CD8E25  	find00:	call	in00		;extract search string concatenating multiple
5317:							;arguments
5318:	1E14  C2780C  		jp	nz,e???		;error - output command prompt
5319:	1E17  AF      		xor	a
5320:	1E18  325C2D  		ld	(lines),a	;clear crlf flag
5321:	1E1B  EB      		ex	de,hl		;starting address of search - hl
5322:	1E1C  11112E  		ld	de,argbf	;argument stored here
5323:			
5324:	1E1F  ED4B7C2D		ld	bc,(fndsym)
5325:	1E23  79      		ld	a,c
5326:	1E24  B0      		or	b		;symbol found?
5327:	1E25  CA301E  		jp	z,find40	;no
5328:			
5329:	1E28  EB      		ex	de,hl		;hl - argument buffer
5330:	1E29  46      		ld	b,(hl)		;reverse order of the two bytes for symbols
5331:	1E2A  23      		inc	hl
5332:	1E2B  7E      		ld	a,(hl)
5333:	1E2C  70      		ld	(hl),b
5334:	1E2D  2B      		dec	hl
5335:	1E2E  77      		ld	(hl),a
5336:	1E2F  EB      		ex	de,hl
5337:			
5338:	1E30  ED4B0D2E	find40:	ld	bc,(argbc)	;number of bytes to look for
5339:	1E34  CD0C25  		call	crlf
5340:	1E37  CD581E  	find50:	call	srch		;do the search
5341:	1E3A  2015    		jr	nz,find60	;not found
5342:	1E3C  CD3025  		call	outadr		;display address where match found
5343:	1E3F  3A5C2D  		ld	a,(lines)
5344:	1E42  3D      		dec	a		;carriage return after 8 addresses displayed
5345:	1E43  325C2D  		ld	(lines),a
5346:	1E46  E607    		and	7
5347:	1E48  CC0C25  		call	z,crlf
5348:	1E4B  CD5824  		call	ttyq		;user requesting abort?
5349:	1E4E  FE0D    		cp	cr
5350:	1E50  C8      		ret	z		;abort - return to z8e
5351:	1E51  23      	find60:	inc	hl		;point to next address at which to start search
5352:	1E52  09      		add	hl,bc		;ensure we won't hit end of memory by adding
5353:							;in string size
5354:	1E53  D8      		ret	c		;impending end of memory
5355:	1E54  ED42    		sbc	hl,bc		;restore pointer
5356:	1E56  18DF    		jr	find50
5357:			
5358:	1E58  C5      	srch:	push	bc
5359:	1E59  D5      		push	de
5360:	1E5A  E5      		push	hl
5361:	1E5B  1A      	srch00:	ld	a,(de)
5362:	1E5C  EDA1    		cpi
5363:	1E5E  C2651E  		jp	nz,srch10	;no match
5364:	1E61  13      		inc	de
5365:	1E62  EA5B1E  		jp	pe,srch00	;tally not expired - check next
5366:	1E65  E1      	srch10:	pop	hl
5367:	1E66  D1      		pop	de
5368:	1E67  C1      		pop	bc
5369:	1E68  C9      		ret
5370:			
5372:			;******************************************************************************
5373:			;*
5374:			;*	verify:	Verify two blocks of data are identical
5375:			;*
5376:			;*		enter: de - starting address of block 1
5377:			;*
5378:			;*		call bcde to get address of block 2 and byte count
5379:			;*
5380:			;*		mismatch:   block 1 address and byte are displayed
5381:			;*			    block 2 address and byte are displayed
5382:			;*			    console intrrogated - any input terminates verify
5383:			;*
5384:			;*		exit:	to z8e for next command
5385:			;*
5386:			;******************************************************************************
5387:			
5388:	1E69  CD3F24  	verify:	call	bcde		;get block 2 address and byte count
5389:	1E6C  C2780C  		jp	nz,e???
5390:	1E6F  EB      		ex	de,hl
5391:	1E70  1A      	verf00:	ld	a,(de)		;byte from block 1
5392:	1E71  AE      		xor	(hl)		;versus byte from block two
5393:	1E72  2817    		jr	z,verf10	;match - no display
5394:	1E74  CD2725  		call	newlin
5395:	1E77  1A      		ld	a,(de)
5396:	1E78  CD1625  		call	othxsp		;display block 1 data
5397:	1E7B  CD1925  		call	space1
5398:	1E7E  CD3025  		call	outadr		;display block two address
5399:	1E81  7E      		ld	a,(hl)
5400:	1E82  CD3A25  		call	outhex		;display results of xor
5401:	1E85  CD5824  		call	ttyq		;check input status
5402:	1E88  FE0D    		cp	cr
5403:	1E8A  C8      		ret	z
5404:	1E8B  23      	verf10:	inc	hl		;bump block 1 pointer
5405:	1E8C  13      		inc	de		;bump block 2 pointer
5406:	1E8D  0B      		dec	bc		;dec byte count
5407:	1E8E  78      		ld	a,b
5408:	1E8F  B1      		or	c
5409:	1E90  20DE    		jr	nz,verf00
5410:	1E92  C9      		ret
5411:			
5413:			;******************************************************************************
5414:			;*
5415:			;*	xreg:	Display machine state
5416:			;*
5417:			;*		regptr:	Table contains offsets to names in operand name table.
5418:			;*			Sign bit set indicates prime register.
5419:			;*
5420:			;*		regmap:	Table contains offsets to reg contents table (regcon)
5421:			;*			Sign bit ignored (used by rgst command).
5422:			;*
5423:			;*		regcon:	Table of register contents.
5424:			;*
5425:			;*		exit:	Make current pc current disassembly location counter.
5426:			;*			Set bit 6 of disassembly flag byte (zasmfb)
5427:			;*			Jump to zasm30 to disassemble current instruction.
5428:			;*
5429:			;******************************************************************************
5430:			
5431:	1E93  CD1125  	xreg:	call	cret
5432:	1E96  010000  		ld	bc,0		;init reg index
5433:	1E99  CDBC1E  	xreg00:	call	xreg05		;display reg name and contents
5434:	1E9C  0C      		inc	c
5435:	1E9D  79      		ld	a,c
5436:	1E9E  FE08    		cp	8
5437:	1EA0  CC0C25  		call	z,crlf
5438:	1EA3  79      		ld	a,c
5439:	1EA4  FE0C    		cp	0ch
5440:	1EA6  0600    		ld	b,0
5441:	1EA8  20EF    		jr	nz,xreg00
5442:	1EAA  3A3528  		ld	a,(lcmd)
5443:	1EAD  FE4A    		cp	'J'		;animated command in effect?
5444:	1EAF  C8      		ret	z		;z - no disassembly required
5445:	1EB0  2A012E  		ld	hl,(pcreg)
5446:	1EB3  22582D  		ld	(zasmpc),hl
5447:			;	jp	zasm30		;- eg 3.3.5b
5448:	1EB6  CD7E1F  		call	zasm30		;+
5449:	1EB9  C3C81A  		jp	pswDsp		;+
5450:			
5451:	1EBC  21412D  	xreg05:	ld	hl,regptr	;map of reg name pointers
5452:	1EBF  50      		ld	d,b
5453:	1EC0  09      		add	hl,bc
5454:	1EC1  7E      		ld	a,(hl)		;extract pointer
5455:	1EC2  E67F    		and	7fh		;strip sign for name indexing
5456:	1EC4  5F      		ld	e,a
5457:	1EC5  46      		ld	b,(hl)		;save copy of offset - need sign later
5458:	1EC6  218327  		ld	hl,zopnm	;register name table
5459:	1EC9  19      		add	hl,de
5460:	1ECA  19      		add	hl,de		;two bytes per entry
5461:	1ECB  7E      		ld	a,(hl)
5462:	1ECC  CD8224  		call	ttyo		;display character one
5463:	1ECF  23      		inc	hl
5464:	1ED0  7E      		ld	a,(hl)
5465:	1ED1  FE20    		cp	' '		;is second character a space?
5466:	1ED3  2002    		jr	nz,xreg10
5467:	1ED5  3E43    		ld	a,'C'		;replace space - this is pc
5468:	1ED7  CD8224  	xreg10:	call	ttyo		;display second character
5469:	1EDA  AF      		xor	a
5470:	1EDB  B0      		or	b		;now test sign
5471:	1EDC  F2E41E  		jp	p,xreg20	;sign not set - not prime reg
5472:	1EDF  3E27    		ld	a,27h		;display quote
5473:	1EE1  CD8224  		call	ttyo
5474:	1EE4  3E3A    	xreg20:	ld	a,':'
5475:	1EE6  CD8224  		call	ttyo
5476:	1EE9  21302D  		ld	hl,regmap	;map of pointers to reg contents
5477:	1EEC  19      		add	hl,de
5478:	1EED  7E      		ld	a,(hl)
5479:	1EEE  F2F31E  		jp	p,xreg30	;p - not prime reg
5480:	1EF1  C608    		add	a,8		;prime contents 8 bytes past non-prime
5481:	1EF3  E67F    	xreg30:	and	7fh		;ignore sign
5482:	1EF5  5F      		ld	e,a
5483:	1EF6  21F12D  		ld	hl,regcon	;start of register contents storage
5484:	1EF9  19      		add	hl,de
5485:	1EFA  56      		ld	d,(hl)		;hi order contents
5486:	1EFB  2B      		dec	hl
5487:	1EFC  5E      		ld	e,(hl)
5488:	1EFD  EB      		ex	de,hl
5489:	1EFE  CD3025  		call	outadr		;display contents
5490:	1F01  C9      		ret
5491:			
5493:			;******************************************************************************
5494:			;*
5495:			;*	zasm
5496:			;*
5497:			;*	The disassembler is divided into two routines:
5498:			;*
5499:			;*	zasm - computes the instruction key value and finds the opcode nmemonic
5500:			;*	opn  - uses the key value to determine the number of operands and
5501:			;*	       displays the operands.
5502:			;*
5503:			;*	entered: de - starting address to disassemble
5504:			;*
5505:			;*		Zasm maps the 695 z80 instrucions into 256 key values.
5506:			;*              the instruction key value becomes the index into the
5507:			;*              opcode name pointer table (zopcnm), the first operand table
5508:			;*		(zopnd1), and the second operand table (zopnd2).
5509:			;*
5510:			;*		Disassembly is done in user specified block sizes if the
5511:			;*		disassembly count evaluates to a number between 1 and 255. If
5512:			;*		the count is greater than 255 the block is disassembled and the
5513:			;*		the command terminates.
5514:			;*
5515:			;*
5516:			;*		zasm15 - start of the disassembly loop
5517:			;*		zasmpc - address of the instruction being disassembled
5518:			;*		zasmfb - disassembly flag byte
5519:			;*		zmflag - flag indicating directive processing (defb and defw)
5520:			;*
5521:			;*			    bit 6 - xreg calling
5522:			;*			    bit 5 - asmblr calling
5523:			;*			    bit 0 - write to disk flag
5524:			;*
5525:			;*
5526:			;*
5527:			;******************************************************************************
5528:			
5529:			
5530:	1F02          	zasm:
5531:	1F02  CD7E26  		call	iedtbc
5532:			
5533:			;	ret	m		;- eg 3.3.2
5534:	1F05  F2151F  		jp	p,zasm0		;+ Skip if arguments supplied, otherwise ...
5535:	1F08  0600    		ld	b,0		;+ Signal no file write
5536:	1F0A  211000  		ld	hl,16		;+ Assume 16 lines of code
5537:	1F0D  22602D  		ld	(zasmwt),hl	;+
5538:	1F10  225E2D  		ld	(zasmct),hl	;+
5539:	1F13  1824    		jr	zasm06		;+
5540:	1F15          	zasm0:				;+
5541:	1F15  CDA025  		call	iarg
5542:	1F18  C2780C  		jp	nz,e???
5543:	1F1B  EB      		ex	de,hl
5544:	1F1C  CDA025  		call	iarg		;read in block size
5545:	1F1F  47      		ld	b,a		;save delimeter
5546:	1F20  2803    		jr	z,zasm00
5547:	1F22  210100  		ld	hl,1		;change zero count to one
5548:	1F25  AF      	zasm00:	xor	a
5549:	1F26  B4      		or	h
5550:	1F27  2806    		jr	z,zasm05
5551:	1F29  ED52    		sbc	hl,de
5552:	1F2B  DA780C  		jp	c,e???		;error - start address greater than end
5553:	1F2E  19      		add	hl,de
5554:	1F2F  225E2D  	zasm05:	ld	(zasmct),hl	;save as permanent block count
5555:	1F32  22602D  		ld	(zasmwt),hl	;save as working tally
5556:	1F35  EB      		ex	de,hl		;hl - current instruction pointer
5557:	1F36  22582D  		ld	(zasmpc),hl
5558:	1F39          	zasm06:				;+ eg 3.3.2
5559:	1F39  CD0C25  		call	crlf
5560:	1F3C  78      		ld	a,b		;check command line delimeter
5561:	1F3D  32712D  		ld	(dwrite),a	;save as write to disk flag:
5562:							;z - no write   nz - write
5563:	1F40  A7      		and	a
5564:	1F41  C44822  		call	nz,bldf		;not end of line - build fcb
5565:	1F44  C2971D  		jp	nz,esntx
5566:			
5567:	1F47  11732E  	zasm08:	ld	de,zasmbf	;start of disassembly buffer
5568:			
5569:	1F4A  ED53C327	zasm10:	ld	(zasmio),de	;init pointer
5570:			
5571:	1F4E  ED5B582D	zasm15:	ld	de,(zasmpc)	;fetch address to disassemble
5572:	1F52  CDC419  		call	zlen00		;calculate length
5573:	1F55  EB      		ex	de,hl
5574:			
5575:							;loop back here for interactive disassembly -
5576:							;user requests format change. C reg:
5577:							;     6 and 7 off: disassemble as code
5578:							;     6       on:  hex defb
5579:							;     7       on:  hex defw or ascii defb
5580:			
5581:	1F56  CD3025  	zasm18:	call	outadr		;display instruction address
5582:	1F59  11692D  		ld	de,zmflag
5583:	1F5C  79      		ld	a,c		;save instruction length and format bits
5584:	1F5D  12      		ld	(de),a
5585:	1F5E  E63F    		and	3fh
5586:	1F60  47      		ld	b,a		;b  - length
5587:	1F61  4F      		ld	c,a		;c  - ditto
5588:	1F62  7E      	zasm20:	ld	a,(hl)
5589:	1F63  CD1625  		call	othxsp		;display object code
5590:	1F66  23      		inc	hl
5591:	1F67  10F9    		djnz	zasm20
5592:	1F69  79      		ld	a,c		;number of object bytes
5593:	1F6A  3D      		dec	a
5594:	1F6B  EE03    		xor	3
5595:	1F6D  47      		ld	b,a		;calculate space padding
5596:	1F6E  87      		add	a,a
5597:	1F6F  80      		add	a,b
5598:	1F70  C602    		add	a,2
5599:	1F72  47      		ld	b,a
5600:	1F73  CD1925  	zasm25:	call	space1
5601:	1F76  10FB    		djnz	zasm25
5602:	1F78  225C2D  		ld	(zasmnx),hl	;store address of next instruction
5603:	1F7B  A7      		and	a		;clear carry
5604:	1F7C  ED42    		sbc	hl,bc		;point to first byte in instruction
5605:	1F7E  EB      	zasm30:	ex	de,hl		;de - current instruction pointer
5606:	1F7F  2AC327  		ld	hl,(zasmio)	;buffer address storage
5607:	1F82  3A802D  		ld	a,(maxlin)
5608:	1F85  47      		ld	b,a		;line length based on max symbol size
5609:	1F86  3620    	zasm35:	ld	(hl),' '	;space out buffer
5610:	1F88  23      		inc	hl
5611:	1F89  10FB    		djnz	zasm35
5612:	1F8B  78      		ld	a,b
5613:	1F8C  32622D  		ld	(opnflg),a
5614:	1F8F  360D    		ld	(hl),cr		;append crlf
5615:	1F91  23      		inc	hl
5616:	1F92  360A    		ld	(hl),lf
5617:	1F94  CD0624  		call	fadr		;find address match
5618:	1F97  2AC327  		ld	hl,(zasmio)
5619:	1F9A  2009    		jr	nz,zasm40	;nz - no table or not found
5620:	1F9C  CD3024  		call	xsym
5621:	1F9F  363A    		ld	(hl),':'
5622:	1FA1  ED5B582D		ld	de,(zasmpc)
5623:	1FA5  21692D  	zasm40:	ld	hl,zmflag	;check interactive disassembly flag
5624:	1FA8  7E      		ld	a,(hl)		;sign bit tells all
5625:	1FA9  A7      		and	a
5626:	1FAA  F2B71F  		jp	p,zasm42	;bit off - not interactive
5627:			
5628:			; Test for defw
5629:			
5630:	0000          		if	h64180
5632:				else
5633:	1FAD  066D    		ld	b,6DH
5634:				endif
5635:			
5636:	1FAF  D682    		sub	82h
5637:	1FB1  287F    		jr	z,zasm90
5638:	1FB3  AF      		xor	a		;must be defw
5639:	1FB4  05      		dec	b
5640:	1FB5  187B    		jr	zasm90
5641:	1FB7  1A      	zasm42:	ld	a,(de)		;first byte of op code
5642:	1FB8  211C2D  		ld	hl,op1000	;table of z80 specific opcodes
5643:	1FBB  0E04    		ld	c,4
5644:	1FBD  EDB1    	zasm45:	cpir			;check for fd dd ed or cb
5645:	1FBF  2818    		jr	z,zasm55	;z - found
5646:	1FC1  FE40    	zasm50:	cp	40h
5647:	1FC3  386D    		jr	c,zasm90	;opcode range 0 - 3f
5648:	1FC5  06E0    		ld	b,0e0h		;
5649:	1FC7  FEC0    		cp	0c0h		;
5650:	1FC9  3067    		jr	nc,zasm90	;opcode range c0 - ff
5651:	1FCB  FE80    		cp	80h
5652:	1FCD  305E    		jr	nc,zasm85	;opcode range 80 - bf
5653:	1FCF  06F8    		ld	b,0f8h		;
5654:	1FD1  FE76    		cp	76h		;test for halt instruction
5655:	1FD3  2058    		jr	nz,zasm85	;opcode range 40 - 7f
5656:	1FD5  3EFF    		ld	a,0ffh		;set halt instruction key value to 0f7h
5657:	1FD7  1859    		jr	zasm90
5658:	1FD9  13      	zasm55:	inc	de
5659:	1FDA  1A      		ld	a,(de)		;byte two of multi-byte instruction
5660:	1FDB  0D      		dec	c		;test for ED instruction
5661:	1FDC  2016    		jr	nz,zasm65	;nz - not an ED
5662:			
5663:	0000          		if	h64180
5668:				else
5669:			
5670:	1FDE  FE80    		cp	80h
5671:	1FE0  3008    		jr	nc,zasm60	;opcode range ed 40 - ed 7f
5672:	1FE2  FE40    		cp	40h
5673:	1FE4  304C    		jr	nc,zasm90	;legal
5674:	1FE6  3E9F    		ld	a,09fh
5675:	1FE8  1848    		jr	zasm90		;map to question marks
5676:	1FEA  06E0    	zasm60:	ld	b,0e0h		;set bias
5677:	1FEC  FEC0    		cp	0c0h		;test for illegal ed
5678:	1FEE  3842    		jr	c,zasm90	;legal
5679:	1FF0  3EBF    		ld	a,0bfh		;map to question marks
5680:	1FF2  183E    		jr	zasm90		;opcode range ed a0 - ed bb
5681:			
5682:				endif
5683:			
5684:	1FF4  0C      	zasm65:	inc	c
5685:	1FF5  2828    		jr	z,zasm80	;z - cb instruction
5686:	1FF7  FECB    		cp	0cbh		;fd or dd - check for cb in byte two
5687:	1FF9  200F    		jr	nz,zasm70
5688:	1FFB  13      		inc	de		;fetch last byte of fdcb or ddcb
5689:	1FFC  13      		inc	de
5690:	1FFD  1A      		ld	a,(de)
5691:	1FFE  0F      		rrca
5692:	1FFF  381A    		jr	c,zasm75
5693:	2001  E603    		and	3
5694:	2003  FE03    		cp	3
5695:	2005  2014    		jr	nz,zasm75	;error
5696:	2007  1A      		ld	a,(de)
5697:	2008  1815    		jr	zasm80
5698:	200A  3A692D  	zasm70:	ld	a,(zmflag)
5699:	200D  D603    		sub	3
5700:	200F  1A      		ld	a,(de)
5701:	2010  20AF    		jr	nz,zasm50
5702:	2012  21E428  		ld	hl,z80f3
5703:	2015  0E18    		ld	c,z80f3l
5704:	2017  EDB1    		cpir
5705:	2019  28A6    		jr	z,zasm50
5706:	201B  3E9F    	zasm75:	ld	a,09fh
5707:	201D  1813    		jr	zasm90
5708:	201F  FE40    	zasm80:	cp	40h		;test type of cb instruction
5709:	2021  06E8    		ld	b,0e8h
5710:	2023  3808    		jr	c,zasm85	;opcode range cb 00 - cb 3f (shift)
5711:	2025  07      		rlca
5712:	2026  07      		rlca
5713:	2027  E603    		and	03		;hi order bits become index
5714:	2029  06F0    		ld	b,0f0h
5715:	202B  1805    		jr	zasm90		;opcode range cb 40 - cb ff
5716:	202D  0F      	zasm85:	rrca
5717:	202E  0F      		rrca
5718:	202F  0F      		rrca			;bits 3-5 of cb shift yield key
5719:	2030  E607    		and	07h
5720:	2032  80      	zasm90:	add	a,b		;add in bias from b reg
5721:	2033  4F      		ld	c,a		;c - instruction key value
5722:	2034  AF      		xor	a
5723:	2035  47      		ld	b,a
5724:	2036  21FC28  		ld	hl,zopcpt	;opcode name pointer table
5725:	2039  09      		add	hl,bc		;index into table
5726:	203A  6E      		ld	l,(hl)		;fetch opname index
5727:	203B  67      		ld	h,a
5728:	203C  29      		add	hl,hl
5729:	203D  29      		add	hl,hl		;index times four
5730:	203E  11FC2B  		ld	de,zopcnm	;op code name table
5731:	2041  19      		add	hl,de
5732:	2042  EB      		ex	de,hl		;de - pointer to opcode name
5733:	2043  2AC327  		ld	hl,(zasmio)	;buffer pointer storage
5734:	2046  79      		ld	a,c
5735:	2047  32722D  		ld	(zasmkv),a	;opcode key value
5736:	204A  3A7E2D  		ld	a,(maxlen)
5737:	204D  4F      		ld	c,a
5738:	204E  0C      		inc	c		;set label length based on max size
5739:			
5740:	204F  3A3528  		ld	a,(lcmd)	;if xreg use compressed output format
5741:	2052  FE58    		cp	'X'
5742:	2054  2802    		jr	z,zasm92
5743:	2056  FE53    		cp	'S'		;step needs compressed format
5744:	2058  09      	zasm92:	add	hl,bc
5745:	2059  0E04    		ld	c,4
5746:	205B  EB      		ex	de,hl		;de - buffer   hl - opcode name pointer
5747:	205C  EDB0    		ldir
5748:	205E  03      		inc	bc		;one space after opcode for compressed format
5749:	205F  2802    		jr	z,zasm95
5750:	2061  0E04    		ld	c,4		;four spaces for true disassembly
5751:	2063  EB      	zasm95:	ex	de,hl		;hl - buffer pointer
5752:	2064  09      		add	hl,bc		;start of operand field in buffer
5753:	2065  3A722D  		ld	a,(zasmkv)	;save the instruction key value
5754:	2068  FE9F    		cp	09fh
5755:	206A  2018    		jr	nz,zasm99
5756:	206C  ED5B582D		ld	de,(zasmpc)
5757:	2070  3A692D  		ld	a,(zmflag)
5758:	2073  47      		ld	b,a
5759:	2074  1A      	zasm97:	ld	a,(de)
5760:	2075  4A      		ld	c,d
5761:	2076  CDB823  		call	zhex
5762:	2079  05      		dec	b
5763:	207A  CAB920  		jp	z,opn020
5764:	207D  362C    		ld	(hl),','
5765:	207F  23      		inc	hl
5766:	2080  51      		ld	d,c
5767:	2081  13      		inc	de
5768:	2082  18F0    		jr	zasm97
5769:	2084  11FC29  	zasm99:	ld	de,zopnd1	;table of first operands
5770:	2087  83      		add	a,e
5771:	2088  5F      		ld	e,a		;instant offset
5772:	2089  7A      		ld	a,d
5773:	208A  88      		adc	a,b
5774:	208B  57      		ld	d,a
5775:	208C  1A      		ld	a,(de)
5776:	208D  3C      		inc	a
5777:	208E  284F    		jr	z,opn040	;no operands
5778:			
5780:			;******************************************************************************
5781:			;*
5782:			;*                          - operand processing -
5783:			;*
5784:			;*	enter:	b - zero (process first operand)
5785:			;*		c - instruction key value
5786:			;*
5787:			;*   instruction key value is used to fetch operand key value:
5788:			;*
5789:			;*	operand key value is in the range 0 - 1fh
5790:			;*	operand key value interpretted as follows:
5791:			;*
5792:			;*      0 - 17h  use as index to fetch literal from operand
5793:			;*		 name table (sign bit set - parens required)
5794:			;*
5795:			;*     18 - 1fh  operand requires processing - use as index
5796:			;*	         into operand jump table which is located
5797:			;*	         immediately after name table
5798:			;*
5799:			;*	   0ffh  no operand
5800:			;*
5801:			;*   operand key value jump table routines: (buffer address in de)
5802:			;*
5803:			;*
5804:			;*   entry point   key         action
5805:			;*
5806:			;*     opn100	   18h	 relative jump
5807:			;*     opn200	   19h	 register specified in instruction
5808:			;*     opn300	   1ah	 convert 16 bit operand to hex
5809:			;*     opn400	   1ch	 convert 8 bit operand to hex
5810:			;*     opn600	   1dh	 hl/ix/iy instruction
5811:			;*     opn700	   1eh	 mask rst operand from bit 3-5 of rst instruction
5812:			;*     opn800	   1fh	 bit number is specified in bits 3-5 of opcode
5813:			;*
5814:			;*    exit: to zasm15 to continue block disassembly
5815:			;*
5816:			;******************************************************************************
5817:			
5818:	2090  3D      	opn:	dec	a		;save operand key value
5819:	2091  F29720  		jp	p,opn010
5820:	2094  3628    		ld	(hl),'('
5821:	2096  23      		inc	hl
5822:	2097  EB      	opn010:	ex	de,hl		;de - buffer address
5823:	2098  47      		ld	b,a
5824:	2099  87      		add	a,a		;operand key value times two
5825:	209A  218327  	opn012:	ld	hl,zopnm	;base of operand name/jump table
5826:	209D  85      		add	a,l		;index into table
5827:	209E  6F      		ld	l,a
5828:	209F  3001    		jr	nc,opn014
5829:	20A1  24      		inc	h		;account for carry
5830:	20A2  3E1F    	opn014:	ld	a,1fh
5831:	20A4  A0      		and	b
5832:	20A5  FE18    		cp	zopnml		;test if processing required
5833:	20A7  3805    		jr	c,opn015	;c - operand is a fixed literal
5834:	20A9  7E      		ld	a,(hl)		;fetch processing routine address
5835:	20AA  23      		inc	hl
5836:	20AB  66      		ld	h,(hl)		;
5837:	20AC  6F      		ld	l,a		;hl - operand processing routine
5838:	20AD  E9      		jp	(hl)		;geronimoooooooo
5839:	20AE  EDA0    	opn015:	ldi			;first byte of operand literal
5840:	20B0  03      		inc	bc		;compensate for ldi
5841:	20B1  EB      		ex	de,hl		;hl - buffer
5842:	20B2  1A      		ld	a,(de)
5843:	20B3  FE20    		cp	' '		;test for space as byte two of literal
5844:	20B5  2802    		jr	z,opn020	;ignore spaces appearing in byte two
5845:	20B7  77      		ld	(hl),a
5846:	20B8  23      		inc	hl		;bump buffer pointer
5847:	20B9  78      	opn020:	ld	a,b		;operand key value
5848:	20BA  FE80    		cp	80h		;test for closed paren required
5849:	20BC  3803    		jr	c,opn030	;c - none required
5850:	20BE  3629    		ld	(hl),')'
5851:	20C0  23      		inc	hl
5852:	20C1  3A622D  	opn030:	ld	a,(opnflg)	;get flag byte
5853:	20C4  EEFF    		xor	0ffh		;toggle operand number
5854:	20C6  32622D  		ld	(opnflg),a	;
5855:	20C9  2814    		jr	z,opn040	;z - just finished number two
5856:	20CB  3A722D  		ld	a,(zasmkv)	;get op code key value
5857:	20CE  11FC2A  		ld	de,zopnd2	;index into operand2 table
5858:	20D1  83      		add	a,e
5859:	20D2  5F      		ld	e,a
5860:	20D3  3001    		jr	nc,opn035
5861:	20D5  14      		inc	d
5862:	20D6  1A      	opn035:	ld	a,(de)		;get operand2 key value
5863:	20D7  3C      		inc	a
5864:	20D8  2805    		jr	z,opn040	;z - no second operand
5865:	20DA  362C    		ld	(hl),','	;separate operands with comma in buffer
5866:	20DC  23      		inc	hl
5867:	20DD  18B1    		jr	opn
5868:	20DF  2AC327  	opn040:	ld	hl,(zasmio)	;rewind buffer pointer
5869:	20E2  3A802D  		ld	a,(maxlin)
5870:	20E5  4F      		ld	c,a
5871:	20E6          	opn041:
5872:	20E6  3A842D  		ld	a,(case)
5873:	20E9  A7      		and	a
5874:	20EA  280C    		jr	z,opn043	;Upper case requested - no need to convert
5875:							;reg names [ras 19 Sep 85]
5876:	20EC  7E      	opn042:	ld	a,(hl)
5877:	20ED  A7      		and	a		;if sign bit on then no case conversion
5878:	20EE  F4FA24  		call	p,ilcs
5879:	20F1  E67F    		and	7Fh		;in case we fell thru
5880:	20F3  77      		ld	(hl),a
5881:	20F4  23      		inc	hl
5882:	20F5  0D      		dec	c
5883:	20F6  20F4    		jr	nz,opn042
5884:	20F8          	opn043:				;correct jmp from opn041 4-9-85
5885:	20F8  3A802D  		ld	a,(maxlin)
5886:	20FB  FE1E    		cp	30
5887:	20FD  2802    		jr	z,opn044
5888:	20FF  3E2C    		ld	a,44		;allow 16 comment chars
5889:	2101          	opn044:
5890:	2101  4F      		ld	c,a		;number of chars to print (omit crlf)
5891:	2102  2AC327  		ld	hl,(zasmio)
5892:	2105  3A3528  		ld	a,(lcmd)
5893:	2108  FE4A    		cp	'J'		;j command
5894:	210A  C8      		ret	z		;end of the line for full screen animation
5895:	210B  CD7827  		call	printb		;print buffer
5896:	210E  23      		inc	hl		;point past crlf to next 32 byte group
5897:	210F  23      		inc	hl
5898:	2110  EB      		ex	de,hl
5899:	2111  3A3528  		ld	a,(lcmd)	;jettison all commands except z
5900:	2114  FE58    		cp	'X'
5901:	2116  CA0C25  		jp	z,crlf
5902:	2119  FE41    		cp	'A'
5903:	211B  CA0C25  		jp	z,crlf
5904:	211E  FE53    		cp	'S'
5905:	2120  CA0C25  		jp	z,crlf
5906:	2123  AF      		xor	a
5907:	2124  326A2D  		ld	(zasmf),a
5908:	2127  2A5E2D  		ld	hl,(zasmct)	;check disassembly count
5909:	212A  2B      		dec	hl
5910:	212B  7C      		ld	a,h
5911:	212C  B5      		or	l		;test for count expired
5912:	212D  C2AB21  		jp	nz,opn060	;nz - this is not a count of one so this is not
5913:							;interactive disassebly
5914:			
5915:	2130  CD6F24  		call	ttyi		;check input command letter for interactive
5916:	2133  CD0325  		call	ixlt		;force upper case
5917:	2136  326A2D  		ld	(zasmf),a
5918:	2139  FE43    		cp	'C'		;code?
5919:	213B  CC1125  		call	z,cret		;if user wants code return cursor to start of
5920:							;line and disassemble again
5921:	213E  CA4E1F  		jp	z,zasm15
5922:	2141  0E82    		ld	c,82h		;assume defw
5923:	2143  FE44    		cp	'D'
5924:	2145  280B    		jr	z,opn045	;defw - 082h
5925:	2147  0D      		dec	c		;assume ascii defb
5926:	2148  FE41    		cp	'A'
5927:	214A  2806    		jr	z,opn045	;ascii defb - 081h
5928:	214C  FE42    		cp	'B'
5929:	214E  200B    		jr	nz,opn046	;none of the above
5930:	2150  0EC1    		ld	c,0c1h		;hex defb - 0c1h
5931:	2152  CD1125  	opn045:	call	cret
5932:	2155  2A582D  		ld	hl,(zasmpc)
5933:	2158  C3561F  		jp	zasm18
5934:			
5935:							;zasmf - 0 means this is block disassembly
5936:							;      - nz means char entered during
5937:			          			;        interactive mode was not c d a or b.
5938:			
5939:	215B  FE3B    	opn046:	cp	';'		;check if user wants to insert comments
5940:	215D  204C    		jr	nz,opn060	;nz - user does not want to add comment
5941:			
5942:	215F  CD8224  		call	ttyo		;echo semicolon
5943:	2162  1B      		dec	de
5944:	2163  1B      		dec	de		;point to carriage return
5945:	2164  3E20    		ld	a,' '
5946:	2166  12      		ld	(de),a		;clear crlf from buffer
5947:	2167  13      		inc	de
5948:	2168  12      		ld	(de),a
5949:	2169  13      		inc	de
5950:	216A  CD1522  		call	write		;end of buffer - write if required
5951:	216D  061D    		ld	b,29
5952:	216F  3A802D  		ld	a,(maxlin)
5953:	2172  D61E    		sub	30
5954:	2174  CA7B21  		jp	z,opn048
5955:	2177  1B      		dec	de
5956:	2178  0610    		ld	b,16
5957:	217A  AF      		xor	a
5958:	217B  4F      	opn048:	ld	c,a
5959:	217C  C5      		push	bc
5960:	217D  D5      		push	de		;save disassembly buffer pointer
5961:	217E  57      		ld	d,a
5962:	217F  CD9926  		call	iedt03
5963:	2182  D1      		pop	de
5964:	2183  C1      		pop	bc
5965:	2184  78      		ld	a,b		;recover max size of comment
5966:	2185  2B      		dec	hl
5967:	2186  46      		ld	b,(hl)		;number actually entered
5968:	2187  90      		sub	b
5969:	2188  4F      		ld	c,a		;trailing spaces
5970:	2189  23      		inc	hl
5971:	218A  EB      		ex	de,hl		;de - input buffer   hl - disassembly buffer
5972:	218B  363B    		ld	(hl),';'
5973:	218D  23      		inc	hl
5974:	218E  05      	opn049:	dec	b		;pre-test count
5975:	218F  FA9821  		jp	m,opn050
5976:	2192  1A      		ld	a,(de)		;first char of input
5977:	2193  13      		inc	de
5978:	2194  77      		ld	(hl),a		;into disassembly buffer
5979:	2195  23      		inc	hl
5980:	2196  18F6    		jr	opn049
5981:	2198  0D      	opn050:	dec	c
5982:	2199  FAA121  		jp	m,opn055
5983:	219C  3620    		ld	(hl),' '
5984:	219E  23      		inc	hl
5985:	219F  18F7    		jr	opn050
5986:	21A1  360D    	opn055:	ld	(hl),cr
5987:	21A3  23      		inc	hl
5988:	21A4  360A    		ld	(hl),lf
5989:	21A6  23      		inc	hl
5990:	21A7  EB      		ex	de,hl
5991:	21A8  C3BB21  		jp	opn065
5992:			
5993:	21AB          	opn060:
5994:	21AB  3A802D  		ld	a,(maxlin)
5995:	21AE  FE1E    		cp	30		;test for 6 chars in label
5996:	21B0  CABB21  		jp	z,opn065	;z - buffer point ok
5997:	21B3  3E12    		ld	a,64-46		;bump buffer pointer to next 64 byte chunk
5998:	21B5  83      		add	a,e
5999:	21B6  5F      		ld	e,a
6000:	21B7  D2BB21  		jp	nc,opn065
6001:	21BA  14      		inc	d
6002:			
6003:	21BB  CD1522  	opn065:	call	write		;check if write to disk flag in effect
6004:			
6005:	21BE  CD0C25  		call	crlf
6006:	21C1  ED53C327		ld	(zasmio),de	;save new buffer pointer
6007:	21C5  2A602D  		ld	hl,(zasmwt)	;check disassembly count
6008:	21C8  AF      		xor	a
6009:	21C9  B4      		or	h		;less than 256?
6010:	21CA  280B    		jr	z,opn080	;less - this is tally
6011:	21CC  ED4B5C2D		ld	bc,(zasmnx)	;fetch next disassembly address
6012:	21D0  ED42    		sbc	hl,bc		;versus requested end address
6013:	21D2  382B    		jr	c,opn095	;c - end
6014:	21D4  09      		add	hl,bc		;restore next disassembly address
6015:	21D5  1815    		jr	opn085		;more
6016:	21D7  2B      	opn080:	dec	hl
6017:	21D8  7C      		ld	a,h
6018:	21D9  B5      		or	l
6019:	21DA  2010    		jr	nz,opn085	;nz - more
6020:	21DC  2A5E2D  		ld	hl,(zasmct)	;fetch permanent block size
6021:	21DF  3A6A2D  		ld	a,(zasmf)
6022:	21E2  A7      		and	a
6023:	21E3  CC6F24  		call	z,ttyi		;query user - more?
6024:	21E6  FE0D    		cp	cr		;return means end
6025:	21E8  2815    		jr	z,opn095
6026:	21EA  1807    		jr	opn090
6027:	21EC          	opn085:
6028:	21EC  CD5824  		call	ttyq
6029:	21EF  FE0D    		cp	cr
6030:	21F1  280C    		jr	z,opn095	;nz - terminate disassembly
6031:	21F3          	opn090:
6032:	21F3  22602D  		ld	(zasmwt),hl	;restore count
6033:	21F6  2A5C2D  		ld	hl,(zasmnx)	;next instruction pointer
6034:	21F9  22582D  		ld	(zasmpc),hl	;make current
6035:	21FC  C34E1F  		jp	zasm15		;disassemble next instruction
6036:			
6037:	21FF  3A712D  	opn095:	ld	a,(dwrite)	;writing to disk?
6038:	2202  A7      		and	a
6039:	2203  C8      		ret	z
6040:	2204  3E1A    		ld	a,eof		;
6041:	2206  12      		ld	(de),a		;set eof
6042:	2207  11732E  		ld	de,zasmbf
6043:	220A  CD1522  		call	write
6044:			
6045:			
6046:			
6047:	220D  112B2E  	closef:	ld	de,fcb		;close file
6048:	2210  0E10    		ld	c,16
6049:	2212  C30500  		jp	bdos
6050:			
6051:	0000          		if	h64180
6209:				endif
6210:			
6211:			
6212:	2215  C5      	write:	push	bc
6213:	2216  E5      		push	hl
6214:	2217  21F32E  		ld	hl,nzasm	;address of end of disassembly buffer
6215:	221A  A7      		and	a
6216:	221B  ED52    		sbc	hl,de
6217:	221D  200A    		jr	nz,wrt10	;not end of buffer
6218:	221F  11732E  		ld	de,zasmbf	;need to rewind buffer pointer
6219:	2222  3A712D  		ld	a,(dwrite)	;test write to disk flag
6220:	2225  A7      		and	a
6221:	2226  C42C22  		call	nz,bwrite	;nz - writing to disk
6222:	2229  E1      	wrt10:	pop	hl
6223:	222A  C1      		pop	bc
6224:	222B  C9      		ret
6225:			
6226:			
6227:			
6228:	222C  C5      	bwrite:	push	bc		;bdos write routine
6229:	222D  D5      		push	de
6230:	222E  E5      		push	hl
6231:	222F  0E1A    		ld	c,26		;set dma address
6232:	2231  CD0500  		call	bdos
6233:	2234  112B2E  		ld	de,fcb
6234:	2237  0E15    		ld	c,21
6235:	2239  CD0500  		call	bdos		;write buffer
6236:							;+ eg 3.3.7b
6237:	223C  0E1A    		ld	c,26		;+ "Set DMA" function
6238:	223E  118000  		ld	de,80h		;+ Restore default DMA for user program
6239:	2241  CD0500  		call	bdos		;+
6240:	2244  E1      		pop	hl
6241:	2245  D1      		pop	de
6242:	2246  C1      		pop	bc
6243:	2247  C9      		ret
6244:			
6245:			
6246:			
6247:	2248  CD0B1D  	bldf:	call	lfcb		;initialize fcb
6248:	224B  C0      		ret	nz		;error - invalid file name
6249:	224C  CD721D  		call	lopn
6250:	224F  2808    		jr	z,bldf00	;no file - create one
6251:	2251  112B2E  		ld	de,fcb
6252:	2254  0E13    		ld	c,19		;file exists - delete it
6253:	2256  CD0500  		call	bdos
6254:	2259  112B2E  	bldf00:	ld	de,fcb		;create new file
6255:	225C  0E16    		ld	c,22
6256:	225E  CD0500  		call	bdos		;if no file create one
6257:	2261  AF      		xor	a
6258:	2262  C9      		ret
6259:			
6261:			
6262:	2263  2A582D  	opn100:	ld	hl,(zasmpc)
6263:	2266  23      		inc	hl
6264:	2267  7E      		ld	a,(hl)		;fetch relative displacement
6265:	2268  4F      		ld	c,a
6266:	2269  0C      		inc	c
6267:	226A  87      		add	a,a		;test sign for displacement direction
6268:	226B  0600    		ld	b,0
6269:	226D  3001    		jr	nc,opn105
6270:	226F  05      		dec	b		;produce zero for forward - ff for back
6271:	2270  09      	opn105:	add	hl,bc		;adjust pc
6272:	2271  EB      		ex	de,hl		;de - instruction ptr   hl - buffer
6273:	2272  CD0624  		call	fadr
6274:	2275  CC3024  		call	z,xsym
6275:	2278  CADF20  		jp	z,opn040	;symbol found
6276:			;	ld	(hl),'$'	;- eg 3.3.4a
6277:			;	inc	hl		;-
6278:			;	ld	a,c		;-
6279:			;	inc	a		;-
6280:	227B  0600    		ld	b,0
6281:			;	cp	82h		;-
6282:			;	jp	opn610		;- convert displacement to ascii
6283:	227D  C3DF22  		jp	opn316		;+
6284:			
6285:	2280  CDE023  	opn200:	call	zmqf		;check for interactive disassembly
6286:	2283  300C    		jr	nc,opn205	;sign off - not interactive
6287:	2285  87      		add	a,a		;shift out bit 6
6288:	2286  7E      		ld	a,(hl)
6289:	2287  3826    		jr	c,opn215	;on - must be hex defb
6290:	2289  CDEB23  		call	zascii		;user wants ascii - check validity
6291:	228C  2021    		jr	nz,opn215	;nz - untable to convert to ascii
6292:	228E  C3B920  		jp	opn020
6293:	2291  CD9F23  	opn205:	call	zndx		;check for ix or iy instruction
6294:	2294  EB      		ex	de,hl		;buffer back to de
6295:	2295  2002    		jr	nz,opn210	;nz - not ix or iy
6296:	2297  23      		inc	hl
6297:	2298  23      		inc	hl		;must be  ld (ix+ind),nn
6298:	2299  23      	opn210:	inc	hl		;
6299:	229A  7E      		ld	a,(hl)		;fetch object byte
6300:	229B  2812    		jr	z,opn215	;no conversion of ix and iy displacements
6301:							;to ascii
6302:	229D  3A722D  		ld	a,(zasmkv)	;check for in or out instruction
6303:	22A0  FEB3    		cp	0b3h
6304:	22A2  280B    		jr	z,opn215	;no conversion of port addresses to ascii
6305:	22A4  FEBB    		cp	0bbh
6306:	22A6  2807    		jr	z,opn215
6307:	22A8  7E      		ld	a,(hl)
6308:	22A9  CDEB23  		call	zascii
6309:	22AC  CAB920  		jp	z,opn020
6310:	22AF  EB      	opn215:	ex	de,hl
6311:	22B0  1A      		ld	a,(de)
6312:	22B1  FE0A    		cp	10		;decimal number?
6313:	22B3  3006    		jr	nc,opn220	;no - convert to hex
6314:	22B5  CDD523  		call	zhex20		;86 the leading zero and trailing h
6315:	22B8  C3B920  		jp	opn020
6316:	22BB  CDB823  	opn220:	call	zhex		;do hex to ascii conversion
6317:	22BE  3648    		ld	(hl),'H'	;following 8 bit hex byte
6318:	22C0  23      		inc	hl
6319:	22C1  C3B920  		jp	opn020
6320:			
6321:	22C4  CDE023  	opn300:	call	zmqf
6322:	22C7  3808    		jr	c,opn315	;c - this is defw
6323:	22C9  CD9F23  		call	zndx
6324:	22CC  EB      		ex	de,hl		;de - buffer   hl - instruction pointer
6325:	22CD  2001    		jr	nz,opn310	;nz - not ix or iy
6326:	22CF  23      		inc	hl
6327:	22D0  23      	opn310:	inc	hl
6328:	22D1  7E      	opn315:	ld	a,(hl)		;fetch lo order 16 bit operand
6329:	22D2  23      		inc	hl
6330:	22D3  66      		ld	h,(hl)		;hi order
6331:	22D4  6F      		ld	l,a
6332:	22D5  EB      		ex	de,hl		;de - 16 bit operand   hl - buffer
6333:	22D6  CD0624  		call	fadr
6334:	22D9  CC3024  		call	z,xsym
6335:	22DC  CAB920  		jp	z,opn020	;symbol found
6336:	22DF          	opn316:				;+ eg 3.3.4b
6337:	22DF  7A      		ld	a,d		;convert hi order to hex
6338:	22E0  4F      		ld	c,a		;save spare copy
6339:	22E1  CDB823  		call	zhex
6340:	22E4  7B      		ld	a,e
6341:	22E5  57      		ld	d,a
6342:	22E6  CDC623  		call	zhex10
6343:	22E9  AF      		xor	a
6344:	22EA  B1      		or	c
6345:	22EB  2006    		jr	nz,opn320
6346:	22ED  7A      		ld	a,d
6347:	22EE  FE0A    		cp	10
6348:	22F0  DAB920  		jp	c,opn020
6349:	22F3  3668    	opn320:	ld	(hl),'h'
6350:	22F5  23      		inc	hl
6351:	22F6  C3B920  		jp	opn020
6352:			
6353:	22F9          	opn400:
6354:	22F9  CD9F23  		call	zndx
6355:	22FC  2008    		jr	nz,opn410	;nz - not ix or iy instruction
6356:	22FE  13      		inc	de
6357:	22FF  1A      		ld	a,(de)
6358:	2300  FECB    		cp	0cbh		;check for indexed bit instruction
6359:	2302  2002    		jr	nz,opn410
6360:	2304  13      		inc	de		;byte of interest is number four
6361:	2305  13      		inc	de
6362:	2306  3E01    	opn410:	ld	a,01		;check low bit of operand key value
6363:	2308  A0      		and	b
6364:	2309  1A      		ld	a,(de)		;fetch op code
6365:	230A  2003    		jr	nz,opn500	;nz - index 01bh
6366:	230C  1F      		rra			;register specified in bits 0-5
6367:	230D  1F      		rra
6368:	230E  1F      		rra
6369:	230F  E607    	opn500:	and	007		;register specified in bits 0-2
6370:	2311  EE06    		xor	006		;from the movie of the same name
6371:	2313  C29720  		jp	nz,opn010	;nz - not hl or ix or iy
6372:	2316  3A582D  		ld	a,(zasmpc)
6373:	2319  AB      		xor	e		;test if pc was incremented
6374:	231A  3628    		ld	(hl),'('	;set leading paren
6375:	231C  23      		inc	hl
6376:	231D  0680    		ld	b,080h		;set sign bit - closed paren required
6377:	231F  EB      		ex	de,hl		;de - buffer
6378:	2320  CA9A20  		jp	z,opn012
6379:			
6380:			
6381:			
6382:	2323          	opn600:
6383:	2323  CD9F23  		call	zndx		;determine if ix or iy
6384:	2326  2806    		jr	z,opn605	;z - must be ix of iy
6385:	2328  3E80    		ld	a,80h
6386:	232A  A0      		and	b
6387:	232B  C39720  		jp	opn010
6388:	232E          	opn605:
6389:							;+Fix display of IX/IY when upper case is set
6390:	232E  F5      		push	af		;+Adapted from patch by George Havach (3.5.7)
6391:	232F  0EDF    		ld	c,0DFh		;+Upper case mask
6392:	2331  3A842D  		ld	a,(case)	;+See if upper or lower case
6393:	2334  B7      		or	a		;+
6394:	2335  2802    		jr	z,opn606	;+Skip if upper case, otherwise
6395:	2337  0EFF    		ld	c,0FFh		;+ adjust mask
6396:	2339          	opn606:				;+
6397:	2339  3E69    		ld	a,'i'		;+First character
6398:	233B  A1      		and	c		;+Select case
6399:			;	ld	(hl),'i'	;-Set first character
6400:	233C  77      		ld	(hl),a		;+Set first character
6401:	233D  23      		inc	hl
6402:	233E  F1      		pop	af		;+Second character
6403:	233F  CE78    		adc	a,'x'		;Carry determines x or y (from zndx)
6404:	2341  A1      		and	c		;+Select case
6405:	2342  77      		ld	(hl),a
6406:	2343  23      		inc	hl
6407:	2344  3E80    		ld	a,80h		;Test for parens
6408:	2346  A0      		and	b
6409:	2347  CAC120  		jp	z,opn030	;z - not indexed instruction
6410:	234A  13      		inc	de
6411:	234B  1A      		ld	a,(de)		;fetch second byte of instruction
6412:	234C  FEE9    		cp	0e9h		;test for jp (ix) or jp (iy)
6413:	234E  CAB920  		jp	z,opn020	;output closed paren
6414:	2351  13      		inc	de
6415:	2352  1A      		ld	a,(de)		;fetch displacement byte
6416:	2353  FE80    		cp	80h		;test sign
6417:	2355  362B    	opn610:	ld	(hl),'+'	;assume forward
6418:	2357  3804    		jr	c,opn620	;c - forward
6419:	2359  ED44    		neg			;force positive
6420:	235B  362D    		ld	(hl),'-'
6421:	235D  23      	opn620:	inc	hl		;bump buffer pointer
6422:	235E  E67F    		and	7fh		;strip sign
6423:	2360  CDB823  		call	zhex		;convert to hex
6424:	2363  3E09    		ld	a,9
6425:	2365  BA      		cp	d
6426:	2366  D2B920  		jp	nc,opn020
6427:	2369  3668    		ld	(hl),'h'
6428:	236B  23      		inc	hl
6429:	236C  C3B920  		jp	opn020		;output closed paren
6430:			
6431:			
6432:			
6433:			
6434:	236F  2A582D  	opn700:	ld	hl,(zasmpc)
6435:	2372  7E      		ld	a,(hl)		;fetch restart instruction
6436:	2373  EB      		ex	de,hl		;de - buffer   hl instruction pointer
6437:	2374  E638    		and	38h
6438:	2376  CDB823  		call	zhex		;convert restart number to ascii
6439:	2379  3648    		ld	(hl),'H'
6440:	237B  C3B920  		jp	opn020
6441:			
6442:			
6443:			
6444:	237E  CD9F23  	opn800:	call	zndx
6445:	2381  2006    		jr	nz,opn810	;nz - not ddcb or fdcb instruction
6446:	2383  13      		inc	de
6447:	2384  13      		inc	de
6448:	2385  13      		inc	de		;
6449:	2386  1A      		ld	a,(de)		;byte 4 of ix or iy bit instruction
6450:	2387  180B    		jr	opn820
6451:	2389  FE10    	opn810:	cp	10h		;weed out interrupt mode instructions
6452:	238B  1A      		ld	a,(de)		;second byte of instruction regardless
6453:	238C  2006    		jr	nz,opn820	;nz - cb bit instruction
6454:	238E  EE46    		xor	046h		;
6455:	2390  2807    		jr	z,opn830	;z - interrupt mode zero
6456:	2392  D608    		sub	8
6457:	2394  1F      	opn820:	rra
6458:	2395  1F      		rra
6459:	2396  1F      		rra
6460:	2397  E607    		and	07		;leave only bit number
6461:	2399  CDD523  	opn830:	call	zhex20		;convert to ascii
6462:	239C  C3C120  		jp	opn030
6463:			
6465:			;******************************************************************************
6466:			;*
6467:			;*		     Disassembler utility subroutines
6468:			;*
6469:			;*	zndx:	  Determines if FD DD ED or CB instruction
6470:			;*		  Caller uses returned values on an individual basis
6471:			;*
6472:			;*		   z  -	DD FD
6473:			;*		  nz  -	neither of the above
6474:			;*		  current instruction pointer bumped if CB or ED instruction
6475:			;*
6476:			;*	zhex:	  Convert to byte in the accumulator to ascii with leading zero
6477:			;*		  store in buffer
6478:			;*		  d - reg destroyed
6479:			;*
6480:			;*	zhex10:	  no leading zero permitted
6481:			;*	zhex20:	  convert lo order nibble only
6482:			;*
6483:			;******************************************************************************
6484:			
6485:	239F  2A582D  	zndx:	ld	hl,(zasmpc)	;fetch current instruction pointer
6486:	23A2  EB      		ex	de,hl		;de - instruction pointer   hl - buffer
6487:	23A3  1A      		ld	a,(de)
6488:			; 	add	a,-0fdh		;iy check
6489:	23A4  C603    		add	a,03h		;iy check
6490:	23A6  C8      		ret	z
6491:	23A7  D6E0    		sub	0ddh-0fdh	;ix check
6492:	23A9  C8      		ret	z
6493:	23AA  FE10    		cp	10h		;ed check
6494:	23AC  2805    		jr	z,zndx00
6495:	23AE  FEEE    		cp	0eeh		;cb check
6496:	23B0  3E00    		ld	a,0		;clear
6497:	23B2  C0      		ret	nz
6498:	23B3  13      	zndx00:	inc	de		;cb or ed - bump instruction pointer
6499:	23B4  2F      		cpl
6500:	23B5  A7      		and	a		;ensure nz set
6501:	23B6  2F      		cpl
6502:	23B7  C9      		ret
6503:			
6504:			
6505:			
6506:	23B8  57      	zhex:	ld	d,a
6507:	23B9  FEA0    		cp	0a0h		;test byte to convert
6508:	23BB  3805    		jr	c,zhex00	;starts with decimal digit - 86 the lead zero
6509:	23BD  3630    		ld	(hl),'0'
6510:	23BF  23      		inc	hl
6511:	23C0  1804    		jr	zhex10
6512:	23C2  FE0A    	zhex00:	cp	10
6513:	23C4  380F    		jr	c,zhex20
6514:	23C6  0F      	zhex10:	rrca
6515:	23C7  0F      		rrca
6516:	23C8  0F      		rrca
6517:	23C9  0F      		rrca
6518:	23CA  E60F    		and	0fh
6519:	23CC  C690    		add	a,90h
6520:	23CE  27      		daa
6521:	23CF  CE40    		adc	a,40h
6522:	23D1  27      		daa			;a - ascii digit
6523:	23D2  77      		ld	(hl),a
6524:	23D3  23      		inc	hl
6525:	23D4  7A      		ld	a,d		;lo nibble conversion
6526:	23D5  E60F    	zhex20:	and	0fh
6527:	23D7  C690    		add	a,90h
6528:	23D9  27      		daa
6529:	23DA  CE40    		adc	a,40h
6530:	23DC  27      		daa
6531:	23DD  77      		ld	(hl),a
6532:	23DE  23      		inc	hl
6533:	23DF  C9      		ret
6534:			
6535:			
6536:			
6537:	23E0  21692D  	zmqf:	ld	hl,zmflag	;check interactive disassembly flag
6538:	23E3  7E      		ld	a,(hl)
6539:	23E4  3600    		ld	(hl),0		;clear regardless
6540:	23E6  2A582D  		ld	hl,(zasmpc)	;fetch current disassembly address
6541:	23E9  87      		add	a,a		;check sign - on means interactive
6542:	23EA  C9      		ret
6543:			
6544:			
6545:	23EB  FE20    	zascii:	cp	' '
6546:	23ED  D8      		ret	c
6547:	23EE  A7      		and	a
6548:	23EF  F8      		ret	m
6549:	23F0  FE7F    		cp	7fh		;rubout?
6550:	23F2  2804    		jr	z,zasc10
6551:	23F4  FE27    		cp	quote
6552:	23F6  2002    		jr	nz,zasc20
6553:	23F8  A7      	zasc10:	and	a		;set nz - conversion not done
6554:	23F9  C9      		ret
6555:	23FA  EB      	zasc20:	ex	de,hl
6556:	23FB  3627    		ld	(hl),quote	;defb - quoted character
6557:	23FD  23      		inc	hl
6558:	23FE  F680    		or	80h		;hi bit on - no case conversion for this guy
6559:	2400  77      		ld	(hl),a
6560:	2401  23      		inc	hl
6561:	2402  3627    		ld	(hl),quote
6562:	2404  BF      		cp	a
6563:	2405  C9      		ret
6564:			
6565:			
6566:			
6567:	2406  C5      	fadr:	push	bc
6568:	2407  E5      		push	hl
6569:	2408  2A0600  		ld	hl,(06)		;fetch top of tpa - start of symbol table
6570:	240B  ED4B7E2D		ld	bc,(maxlen)
6571:	240F  09      		add	hl,bc		;point to start of symbol name
6572:	2410  23      		inc	hl
6573:	2411  7E      	fadr00:	ld	a,(hl)		;first byte of symbol name
6574:	2412  3D      		dec	a		;check validity
6575:	2413  FA2D24  		jp	m,fadr30	;end of table
6576:	2416  09      		add	hl,bc
6577:	2417  7E      		ld	a,(hl)		;fetch hi order address from table
6578:	2418  BA      		cp	d
6579:	2419  C22324  		jp	nz,fadr10
6580:	241C  2B      		dec	hl
6581:	241D  7E      		ld	a,(hl)
6582:	241E  23      		inc	hl
6583:	241F  BB      		cp	e
6584:	2420  CA2724  		jp	z,fadr20
6585:	2423  23      	fadr10:	inc	hl
6586:	2424  C31124  		jp	fadr00
6587:	2427  EB      	fadr20:	ex	de,hl		;return pointer in de
6588:	2428  79      		ld	a,c
6589:	2429  2F      		cpl
6590:	242A  A3      		and	e
6591:	242B  5F      		ld	e,a
6592:	242C  AF      		xor	a
6593:	242D  E1      	fadr30:	pop	hl
6594:	242E  C1      		pop	bc
6595:	242F  C9      		ret
6596:			
6597:	2430          	xsym:
6598:	2430  3A7E2D  		ld	a,(maxlen)
6599:	2433  3D      		dec	a
6600:	2434  4F      		ld	c,a
6601:	2435  1A      	xsym00:	ld	a,(de)
6602:	2436  A7      		and	a
6603:	2437  C8      		ret	z
6604:	2438  77      		ld	(hl),a
6605:	2439  23      		inc	hl
6606:	243A  13      		inc	de
6607:	243B  0D      		dec	c
6608:	243C  20F7    		jr	nz,xsym00
6609:	243E  C9      		ret
6610:			
6612:			;******************************************************************************
6613:			;*
6614:			;*	bcde:  query user for 3 arguments: source address
6615:			;*					   destination address
6616:			;*					   byte count
6617:			;*
6618:			;*	       used by move, verify, and yfil routines
6619:			;*
6620:			;*	       return: bc - byte count
6621:			;*		       de - destination
6622:			;*		       hl - source pointer
6623:			;*			z - no errors
6624:			;*
6625:			;*		       nz - no input entered
6626:			;*			  - untable to evaluate argument
6627:			;*			  - destination address < source
6628:			;*
6629:			;******************************************************************************
6630:			
6631:	243F  CD7E26  	bcde:	call	iedtbc
6632:	2442  F8      		ret	m		;no input is treated as error
6633:	2443  CDA025  		call	iarg		;read in starting block address
6634:	2446  C0      		ret	nz
6635:	2447  EB      		ex	de,hl
6636:	2448  CDA025  		call	iarg
6637:	244B  C0      		ret	nz
6638:	244C  ED52    		sbc	hl,de		;end - start = byte count - 1
6639:	244E  D8      		ret	c
6640:	244F  44      		ld	b,h
6641:	2450  4D      		ld	c,l
6642:	2451  03      		inc	bc
6643:	2452  CD8E25  		call	in00		;read in destination block address
6644:	2455  C0      		ret	nz
6645:	2456  EB      		ex	de,hl		;set regs right
6646:	2457  C9      		ret
6647:			
6649:			;****************************************************************************
6650:			;*
6651:			;*	CONSOLE I/O PRIMITIVES
6652:			;*
6653:			;*	"logical" i/o primitives:
6654:			;*
6655:			;*		ttyq  - console status
6656:			;*		ttyi  - keyboard Input
6657:			;*		ttyo  - console Output
6658:			;*		xycp  - cursor positioner
6659:			;*
6660:			;*	"physical" i/o primitives:
6661:			;*
6662:			;*		mttyq  - main console status
6663:			;*		mttyi  - main keyboard Input
6664:			;*		mttyo  - main console Output
6665:			;*		mxyprg - main cursor positioner
6666:			;*
6667:			;*		attyq  - auxiliary console status
6668:			;*		attyi  - auxiliary keyboard Input
6669:			;*		attyo  - auxiliary console Output
6670:			;*		axyprg - auxiliary cursor positioner
6671:			;*
6672:			;****************************************************************************
6673:			
6674:			; Logical console status routine
6675:			
6676:	2458  C5      	ttyq:	push	bc
6677:	2459  D5      		push	de
6678:	245A  E5      		push	hl
6679:	245B  21C824  		ld	hl,tqret
6680:	245E  E5      		push	hl
6681:			
6682:	0000          	    if	auxprt
6704:			    endif
6705:			
6706:			; Main physical console status routine
6707:			; (Default is CP/M console device)
6708:			
6709:	0000          	    if	ASMB
6711:			    else
6712:	245F          	mttyq::
6713:			    endif
6714:	245F  0E0B    		ld	c,11
6715:	2461  CD0500  		call	bdos
6716:	2464  A7      		and	a
6717:	2465  0E06    		ld	c,6
6718:	2467  1EFF    		ld	e,0FFH
6719:	2469  C40500  		call	nz,bdos
6720:	246C  E67F    		and	7FH
6721:	246E  C9      		ret
6722:	0000          	    if not compact
6724:			    endif
6725:			
6726:			; Logical keyboard input routine
6727:			
6728:	246F  C5      	ttyi:	push	bc
6729:	2470  D5      		push	de
6730:	2471  E5      		push	hl
6731:	2472  21C824  		ld	hl,tiret
6732:	2475  E5      		push	hl
6733:			
6734:	0000          	    if	auxprt
6755:			    endif
6756:			
6757:			; Main physical keyboard input routine
6758:			; (Default is CP/M console device)
6759:			
6760:	0000          	    if	ASMB
6762:			    else
6763:	2476          	mttyi::
6764:			    endif
6765:	2476  0E06    		ld	c,6
6766:	2478  1EFF    		ld	e,0FFH
6767:	247A  CD0500  		call	bdos
6768:	247D  E67F    		and	7FH
6769:	247F  28F5    		jr	z,mttyi
6770:	2481  C9      		ret
6771:	0000          	    if not compact
6773:			    endif
6774:			
6775:			; Logical console output routine
6776:			
6777:	2482  C5      	ttyo:	push	bc
6778:	2483  D5      		push	de
6779:	2484  E5      		push	hl
6780:	2485  F5      		push	af
6781:	2486  21C724  		ld	hl,toret
6782:	2489  E5      		push	hl
6783:			
6784:	248A          	ttyo00:
6785:	248A  E67F    		and	7Fh		;+ eg 3.3.1 (but this instruction will be
6786:							;            patched during initialisation
6787:							;            according to value stored at
6788:							;            coMask: [3.4])
6789:			
6790:	0000          	    if	auxprt
6812:			    endif
6813:			
6814:			; Main physical console output routine
6815:			; (Default is CP/M console device)
6816:			
6817:	0000          	    if	ASMB
6819:			    else
6820:	248C          	mttyo::
6821:			    endif
6822:	248C  5F      		ld	e,a
6823:	0000          		if	jterm		;My terminal uses tab as cursor position
6825:				else			;the tab to a string of spaces.
6826:	248D  0E02    		ld	c,2
6827:				endif
6828:	248F  CD0500  		call	bdos
6829:	2492  C9      		ret
6830:	0000          	    if not compact
6832:			    endif
6833:			
6834:			; Home cursor routine
6835:			
6836:	2493  010000  	home:	ld	bc,00
6837:			
6838:			; Logical cursor position routine
6839:			
6840:	2496  C5      	xycp:	push	bc
6841:	2497  D5      		push	de
6842:	2498  E5      		push	hl
6843:	2499  21C824  		ld	hl,xyret
6844:	249C  E5      		push	hl
6845:			
6846:	0000          	    if	auxprt
6888:			    endif
6889:			
6890:			; Main physical cursor position routine
6891:			; (Uses MXYSTR, MROWB4, MROW and MCOL for configuration)
6892:			;
6893:			; Two versions are supplied and either can be selected during
6894:			; assembly according to the setting of ATERM.
6895:			;
6896:			;	aterm	equ	TRUE		Selects ANSI screen driver
6897:			;	aterm	equ	FALSE		Selects default screen driver
6898:			;
6899:			; In either  case, this routine is invoked with the row in B and
6900:			; the column in C.
6901:			
6902:	0000          	    if	ASMB
6904:			    else
6905:	249D          	mxyprg::
6906:			    endif
6907:			
6908:	0000          	    if aterm
6956:			    else
6957:			
6958:			;	Default screen driver - ras
6959:	249D  04      		inc	b		; ZDS origin 1,1
6960:	249E  0C      		inc	c
6961:	249F  218A2D  		ld	hl,mxystr
6962:	24A2  3A882D  		ld	a,(mrow)	;Add in row offset
6963:	24A5  80      		add	a,b
6964:	24A6  47      		ld	b,a		;Save row character
6965:	24A7  3A892D  		ld	a,(mcol)	;Add column bias
6966:	24AA  81      		add	a,c
6967:	24AB  4F      		ld	c,a
6968:	24AC  5E      		ld	e,(hl)		;Number of chars in cursor addressing string
6969:	24AD          	mxypr0:
6970:	24AD  23      		inc	hl
6971:	24AE  7E      		ld	a,(hl)
6972:	24AF  CD8224  		call	ttyo
6973:	24B2  1D      		dec	e
6974:	24B3  20F8    		jr	nz,mxypr0
6975:	24B5  3A872D  		ld	a,(mrowb4)
6976:	24B8  A7      		and	a
6977:	24B9  2003    		jr	nz,mxypr1
6978:	24BB  78      		ld	a,b
6979:	24BC  41      		ld	b,c
6980:	24BD  4F      		ld	c,a
6981:	24BE          	mxypr1:
6982:	24BE  78      		ld	a,b
6983:	24BF  CD8224  		call	ttyo
6984:	24C2  79      		ld	a,c
6985:	24C3  CD8224  		call	ttyo
6986:			; 	ld	a,0DH		;ZDS lead out
6987:			; 	call	ttyo
6988:	24C6  C9      		ret
6989:	0000          	     if not compact		;..then leave room for patching
6991:			     endif
6992:			
6993:			    endif
6994:			
6995:			;	Return routines for ttyo, ttyi, ttyq and xycp
6996:	24C7  F1      	toret:	pop	af
6997:	24C8          	tiret:
6998:	24C8          	tqret:
6999:	24C8  E1      	xyret:	pop	hl
7000:	24C9  D1      		pop	de
7001:	24CA  C1      		pop	bc
7002:	24CB  C9      		ret
7003:			
7004:			
7005:			;****************************************************************************
7006:			;*
7007:			;*	CONSOLE I/O UTILITIES
7008:			;*
7009:			;*	Console Input utilities:
7010:			;*
7011:			;*		inchar - Input Character processing
7012:			;*			 control Characters echoed with ^
7013:			;*
7014:			;*	Console Output utilities:
7015:			;*
7016:			;*		crlf   - Output carriage return/line feed
7017:			;*		cret   - Output carriage return only
7018:			;*		space1  - Output space
7019:			;*		spaces - Output Number of spaces in C
7020:			;*		outhex - Output hex Byte in a
7021:			;*		othxsp - Output hex Byte in a followed by space
7022:			;*		outadr - Output 16 bit hex value in hl followed
7023:			;*		           by space - hl preserved
7024:			;*		print  - Output string - Address in de
7025:			;*			   string terminated by null
7026:			;*		printb - Output string - Address in hl
7027:			;*			   Byte count in c; End at First null
7028:			;*
7029:			;****************************************************************************
7030:			
7031:	24CC  CD6F24  	inchar:	call	ttyi
7032:	24CF  FE03    		cp	ctlc
7033:	24D1  CA0000  		jp	z,00
7034:	24D4  FE0D    		cp	cr
7035:	24D6  C8      		ret	z
7036:	24D7  FE09    		cp	tab
7037:	24D9  C8      		ret	z
7038:	24DA  FE0A    		cp	lf
7039:	24DC  C8      		ret	z
7040:	24DD  FE08    		cp	bs
7041:	24DF  C8      		ret	z
7042:	24E0  FE7F    		cp	del
7043:	24E2  C8      		ret	z
7044:	24E3  FE18    		cp	ctlx
7045:	24E5  C8      		ret	z
7046:	24E6  FE20    		cp	' '
7047:	24E8  D28224  		jp	nc,ttyo
7048:	24EB  F5      		push	af
7049:	24EC  3E5E    		ld	a,'^'
7050:	24EE  CD8224  		call	ttyo
7051:	24F1  F1      		pop	af
7052:	24F2  EE40    		xor	40h
7053:	24F4  CD8224  		call	ttyo
7054:	24F7  EE40    		xor	40h
7055:	24F9  C9      		ret
7056:			
7057:			
7058:	24FA  FE41    	ilcs:	cp	'A'
7059:	24FC  D8      		ret	c
7060:	24FD  FE5B    		cp	'Z'+1
7061:	24FF  D0      		ret	nc
7062:	2500  F620    		or	20h
7063:	2502  C9      		ret
7064:			
7065:			
7066:			
7067:	2503  FE61    	ixlt:	cp	'a'
7068:	2505  D8      		ret	c
7069:	2506  FE7B    		cp	'z'+1
7070:	2508  D0      		ret	nc
7071:	2509  D620    		sub	20h
7072:	250B  C9      		ret
7073:			
7075:	250C  3E0A    	crlf:	ld	a,lf
7076:	250E  CD8224  		call	ttyo
7077:	2511  3E0D    	cret:	ld	a,cr
7078:	2513  C38224  		jp	ttyo
7079:			
7080:	2516  CD3A25  	othxsp:	call	outhex
7081:			
7082:	2519  3E20    	space1:	ld	a,' '
7083:	251B  C38224  		jp	ttyo
7084:			
7085:	251E  0E05    	space5:	ld	c,5
7086:			
7087:	2520  CD1925  	spaces:	call	space1
7088:	2523  0D      		dec	c
7089:	2524  20FA    		jr	nz,spaces
7090:	2526  C9      		ret
7091:			
7092:			
7093:			
7094:	2527  CD0C25  	newlin:	call	crlf
7095:	252A  EB      		ex	de,hl
7096:	252B  CD3025  		call	outadr
7097:	252E  EB      		ex	de,hl
7098:	252F  C9      		ret
7099:			
7100:			
7101:	2530  7C      	outadr:	ld	a,h
7102:	2531  CD3A25  		call	outhex
7103:	2534  7D      		ld	a,l
7104:	2535  CD1625  		call	othxsp
7105:	2538  18DF    		jr	space1
7106:			
7107:			
7108:			
7109:	253A  F5      	outhex:	push	af
7110:	253B  CD4825  		call	binx
7111:	253E  CD8224  		call	ttyo
7112:	2541  F1      		pop	af
7113:	2542  CD4C25  		call	binx00
7114:	2545  C38224  		jp	ttyo
7115:			
7116:			
7117:			
7118:	2548  0F      	binx:	rrca
7119:	2549  0F      		rrca
7120:	254A  0F      		rrca
7121:	254B  0F      		rrca
7122:	254C  E60F    	binx00:	and	0fh
7123:	254E  C690    		add	a,90h
7124:	2550  27      		daa
7125:	2551  CE40    		adc	a,40h
7126:	2553  27      		daa
7127:	2554  C9      		ret
7129:	2555  C5      	ilin:	push	bc
7130:	2556  D5      		push	de
7131:	2557  0652    		ld	b,inbfsz
7132:	2559  0E00    		ld	c,0
7133:	255B  CD8A25  		call	din
7134:	255E  D1      		pop	de
7135:	255F  C1      		pop	bc
7136:	2560  C9      		ret
7137:			
7138:			
7139:	2561  C5      	istr:	push	bc
7140:	2562  D5      		push	de
7141:	2563  0601    		ld	b,1
7142:	2565  0E20    		ld	c,' '
7143:	2567  CD8526  		call	iedt
7144:	256A  D1      		pop	de
7145:	256B  C1      		pop	bc
7146:	256C  C9      		ret
7147:			
7148:			
7149:							;resume input after reading in one char
7150:			
7151:	256D  C5      	irsm:	push	bc
7152:	256E  D5      		push	de
7153:	256F  0651    		ld	b,inbfsz-1	;max input size less one char already read in
7154:	2571  0E20    		ld	c,' '		;this is terminator char
7155:	2573  1601    		ld	d,1		;preset byte count
7156:	2575  7A      		ld	a,d
7157:	2576  32742D  		ld	(strngf),a	;set nz - this is string function
7158:	2579  21562E  		ld	hl,inbf+1	;init buffer pointer
7159:	257C  CD9F26  		call	iedt05
7160:	257F  AF      		xor	a
7161:	2580  32742D  		ld	(strngf),a	;this is no longer string function
7162:	2583  B2      		or	d
7163:	2584  F48E25  		call	p,in00
7164:	2587  D1      		pop	de
7165:	2588  C1      		pop	bc
7166:	2589  C9      		ret
7167:			
7168:			
7169:			
7170:	258A  CD8526  	din:	call	iedt
7171:	258D  F8      		ret	m
7172:	258E  AF      	in00:	xor	a
7173:	258F  320D2E  		ld	(argbc),a
7174:	2592  21112E  		ld	hl,argbf
7175:	2595  220F2E  		ld	(argbpt),hl
7176:	2598  CDA025  	in10:	call	iarg
7177:	259B  C0      		ret	nz
7178:	259C  A7      		and	a
7179:	259D  20F9    		jr	nz,in10
7180:	259F  C9      		ret
7181:			
7182:			
7183:			
7184:	25A0  C5      	iarg:	push	bc
7185:	25A1  D5      		push	de
7186:	25A2  CDAB25  		call	parg
7187:	25A5  3A6C2D  		ld	a,(delim)
7188:	25A8  D1      		pop	de
7189:	25A9  C1      		pop	bc
7190:	25AA  C9      		ret
7192:	25AB  CD2719  	parg:	call	prsr		;extract next argument
7193:	25AE  C0      		ret	nz		;parse error
7194:	25AF  3A632D  		ld	a,(quoflg)	;test for ascii literal
7195:	25B2  A7      		and	a
7196:	25B3  2834    		jr	z,parg10	;quote character not found
7197:	25B5  AF      		xor	a
7198:	25B6  B0      		or	b		;test for balanced quotes
7199:	25B7  F8      		ret	m		;error - unbalanced quotes
7200:	25B8  1A      		ld	a,(de)		;first character of parse buffer
7201:	25B9  D627    		sub	quote
7202:	25BB  2035    		jr	nz,parg50	;invalid literal string but may be expression
7203:							;involving a literal
7204:	25BD  68      		ld	l,b		;l - character count of parse buffer
7205:	25BE  67      		ld	h,a		;clear
7206:	25BF  19      		add	hl,de		;
7207:	25C0  2B      		dec	hl		;hl - pointer to last char in parse buffer
7208:	25C1  7E      		ld	a,(hl)		;
7209:	25C2  D627    		sub	quote		;ensure literal string ends with quote
7210:	25C4  202C    		jr 	nz,parg50
7211:	25C6  77      		ld	(hl),a		;clear trailing quote
7212:	25C7  48      		ld	c,b		;c - character count of parse buffer
7213:	25C8  47      		ld	b,a		;clear
7214:	25C9  0D      		dec	c		;subtract the quote characters from the count
7215:	25CA  0D      		dec	c
7216:	25CB  0D      		dec	c		;extra dec set error flag nz for '' string
7217:	25CC  F8      		ret	m		;inform caller of null string
7218:	25CD  0C      		inc	c		;c - actual string length
7219:	25CE  79      		ld	a,c		;spare copy
7220:	25CF  13      		inc	de		;point to second character of parse buffer
7221:	25D0  2A0F2E  		ld	hl,(argbpt)	;caller wants evaluated arg stored here
7222:	25D3  EB      		ex	de,hl
7223:	25D4  EDB0    		ldir
7224:	25D6  EB      		ex	de,hl
7225:	25D7  2B      		dec	hl
7226:	25D8  5E      		ld	e,(hl)
7227:	25D9  2B      		dec	hl
7228:	25DA  56      		ld	d,(hl)
7229:	25DB  23      		inc	hl
7230:	25DC  23      		inc	hl		;point to where to store next arg
7231:	25DD  3D      		dec	a		;argument length 1?
7232:	25DE  2001    		jr	nz,parg00
7233:	25E0  57      		ld	d,a
7234:	25E1  4F      	parg00:	ld	c,a
7235:	25E2  0C      		inc	c		;account for increment
7236:	25E3  3A0D2E  		ld	a,(argbc)	;fetch current argument byte counter
7237:	25E6  81      		add	a,c
7238:	25E7  183C    		jr	parg90
7239:	25E9  CD1F11  	parg10:	call	mreg		;check for register specified
7240:	25EC  2004    		jr	nz,parg50	;nz - invalid register name
7241:	25EE  79      		ld	a,c
7242:	25EF  87      		add	a,a
7243:	25F0  380D    		jr	c,parg60	;sign bit reset - 16 bit register pair
7244:	25F2  210000  	parg50:	ld	hl,00
7245:	25F5  45      		ld	b,l
7246:	25F6  11A72E  		ld	de,prsbf	;reinit starting address of parse buffer
7247:	25F9  CDC017  		call	xval
7248:	25FC  2816    		jr	z,parg70
7249:	25FE  C9      		ret
7250:	25FF  7E      	parg60:	ld	a,(hl)
7251:	2600  2B      		dec	hl
7252:	2601  6E      		ld	l,(hl)
7253:	2602  67      		ld	h,a
7254:	2603  3AA72E  		ld	a,(prsbf)	;check paren flag for indirection
7255:	2606  A7      		and	a
7256:	2607  2005    		jr	nz,parg65	;nz - parens not removed
7257:	2609  13      		inc	de		;bump past trailing null
7258:	260A  7E      		ld	a,(hl)
7259:	260B  23      		inc	hl
7260:	260C  66      		ld	h,(hl)
7261:	260D  6F      		ld	l,a
7262:	260E  0680    	parg65:	ld	b,80h
7263:	2610  CDC017  		call	xval
7264:	2613  C0      		ret	nz
7265:	2614  EB      	parg70:	ex	de,hl
7266:	2615  2A0F2E  		ld	hl,(argbpt)
7267:	2618  3A0D2E  		ld	a,(argbc)
7268:	261B  14      		inc	d
7269:	261C  15      		dec	d
7270:	261D  2803    		jr	z,parg80
7271:	261F  72      		ld	(hl),d
7272:	2620  23      		inc	hl
7273:	2621  3C      		inc	a
7274:	2622  73      	parg80:	ld	(hl),e
7275:	2623  23      		inc	hl
7276:	2624  3C      		inc	a
7277:	2625  320D2E  	parg90:	ld	(argbc),a
7278:	2628  220F2E  		ld	(argbpt),hl
7279:	262B  EB      		ex	de,hl
7280:	262C  AF      		xor	a
7281:	262D  C9      		ret
7283:	262E  47      	outbyt:	ld	b,a		;save spare copy
7284:	262F  CD1625  		call	othxsp		;hex - display
7285:	2632  CD1925  		call	space1
7286:	2635  78      		ld	a,b		;display byte in ascii
7287:	2636  CD4427  		call	asci		;display ascii equivalent
7288:	2639  0E03    		ld	c,3
7289:	263B  C32025  		jp	spaces		;solicit input three spaces right
7290:			
7291:	263E  CD6125  	dbyte:	call	istr
7292:	2641  3A542E  		ld	a,(inbfnc)	;number of chars in input buffer
7293:	2644  3D      		dec	a		;test for input buffer count of zero
7294:	2645  13      		inc	de		;assume zero - examine next
7295:	2646  F8      		ret	m		;no input means examine next
7296:	2647  1B      		dec	de		;incorrect assumption
7297:	2648  3A552E  		ld	a,(inbf)	;check first char of input buffer
7298:	264B  FE2E    		cp	'.'
7299:	264D  C8      		ret	z		;period ends command
7300:	264E  FE3D    		cp	'='		;new address?
7301:	2650  2014    		jr	nz,byte10
7302:	2652  AF      		xor	a		;clear equal sign so prsr ignores it
7303:	2653  32552E  		ld	(inbf),a
7304:	2656  CD6D25  		call	irsm		;fetch new address to examine
7305:	2659  201D    		jr	nz,byte30	;error
7306:	265B  3A542E  		ld	a,(inbfnc)
7307:	265E  D602    		sub	2
7308:	2660  3816    		jr	c,byte30	;c - error - equal sign was only char of input
7309:	2662  EB      		ex	de,hl		;return new address in de
7310:	2663  37      		scf			;ensure nz set for caller - no replacement data
7311:							;was entered
7312:	2664  9F      		sbc	a,a
7313:	2665  C9      		ret
7314:	2666  FE5E    	byte10:	cp	'^'		;
7315:	2668  2004    		jr	nz,byte15	;nz - not up arrow means need more input
7316:	266A  1B      		dec	de		;dec current memory pointer
7317:	266B  37      		scf	 		;set nz - no replacement data entered
7318:	266C  9F      		sbc	a,a
7319:	266D  C9      		ret
7320:	266E  CD6D25  	byte15:	call	irsm		;resume input from console
7321:	2671  C8      		ret	z		;no errors on input
7322:	2672  3A542E  		ld	a,(inbfnc)	;check number of chars input
7323:	2675  A7      		and	a
7324:	2676  28C6    		jr	z,dbyte		;none - user hit control x or backspaced to
7325:							;beginning of buffer
7326:	2678  CD780C  	byte30:	call	e???
7327:	267B  37      		scf
7328:	267C  9F      		sbc	a,a		;set nz - no replacement
7329:	267D  C9      		ret
7330:			
7332:			;******************************************************************************
7333:			;*
7334:			;*	BDOS function 10 replacement to make romming this program easier since
7335:			;*	only two console i/o routines (ttyi and ttyo) are required. This
7336:			;*	routine supports backspace, line delete, and tab expansion.
7337:			;*
7338:			;*	All input stored in input buffer inbf.
7339:			;*
7340:			;*
7341:			;*	iedtbc:	Solicit console for new input and initialize b and c registers
7342:			;*		for max size and input and no special line terminator.
7343:			;*
7344:			;*
7345:			;*	iedt:	Solicit console for new input using non-default byte count for
7346:			;*		buffer or non-standard terminator.
7347:			;*
7348:			;*		called:	 b - max number of characters to receive
7349:			;*			 c - special terminator other than carriage return
7350:			;*
7351:			;*
7352:			;*	iedt00:	Resume input - used by routines which call iedt with a buffer
7353:			;*		count of 1 to check for special character as the first char
7354:			;*		received (such as exam looking for period).
7355:			;*
7356:			;*		called:	 b - max number of characters to receive
7357:			;*			 c - special terminator other than carriage return
7358:			;*
7359:			;******************************************************************************
7360:			
7361:	267E  0652    	iedtbc:	ld	b,inbfsz
7362:	2680  AF      		xor	a
7363:	2681  4F      		ld	c,a
7364:	2682  32742D  		ld	(strngf),a
7365:	2685  AF      	iedt:	xor	a
7366:	2686  1652    		ld	d,inbfsz
7367:	2688  21552E  		ld	hl,inbf
7368:	268B  77      	iedt00:	ld	(hl),a
7369:	268C  23      		inc	hl
7370:	268D  15      		dec	d
7371:	268E  20FB    		jr	nz,iedt00
7372:	2690  320D2E  		ld	(argbc),a	;init number of arguments tally
7373:	2693  21112E  		ld	hl,argbf
7374:	2696  220F2E  		ld	(argbpt),hl	;init pointer to start of buffer
7375:	2699  21552E  	iedt03:	ld	hl,inbf		;start of input buffer
7376:	269C  32632D  		ld	(quoflg),a
7377:	269F  CDCC24  	iedt05:	call	inchar		;read char from console
7378:	26A2  32772D  		ld	(trmntr),a	;assume line terminator until proven otherwise
7379:	26A5  FE0D    		cp	cr		;end of line?
7380:	26A7  CA3227  		jp	z,iedt90	;z - end (jr changed to jp:  eg 3.3.8a)
7381:	26AA  5F      		ld	e,a
7382:	26AB  FE27    		cp	quote
7383:	26AD  3A632D  		ld	a,(quoflg)
7384:	26B0  2009    		jr	nz,iedt10
7385:	26B2  EE27    		xor	quote
7386:	26B4  32632D  		ld	(quoflg),a
7387:	26B7  3E27    		ld	a,quote
7388:	26B9  186D    		jr	iedt60
7389:	26BB  A7      	iedt10:	and	a		;quote flag on?
7390:	26BC  7B      		ld	a,e		;recover input character
7391:	26BD  280B    		jr	z,iedt15	;off - check terminator
7392:	26BF  3A3528  		ld	a,(lcmd)
7393:	26C2  CD0325  		call	ixlt
7394:	26C5  FE52    		cp	'R'
7395:	26C7  7B      		ld	a,e
7396:	26C8  2003    		jr	nz,iedt20
7397:	26CA  B9      	iedt15:	cp	c		;compare with auxiliary terminator
7398:	26CB  2865    		jr	z,iedt90	;z - end
7399:	26CD  FE09    	iedt20:	cp	tab
7400:	26CF  200F    		jr	nz,iedt35	;nz - not tab check backspace
7401:	26D1  CD1925  	iedt25:	call	space1		;space out until char position mod 8 = zero
7402:	26D4  77      		ld	(hl),a		;store space in buffer as we expand tab
7403:	26D5  23      		inc	hl
7404:	26D6  14      		inc	d
7405:	26D7  3E07    		ld	a,7
7406:	26D9  A2      		and	d
7407:	26DA  20F5    		jr	nz,iedt25
7408:	26DC  3600    		ld	(hl),0		;set end of line null
7409:	26DE  184D    		jr	iedt70
7410:	26E0  1E01    	iedt35:	ld	e,1		;assume one backspace required
7411:	26E2  FE08    		cp	bs
7412:	26E4  2810    		jr	z,iedt40	;z - correct assumption
7413:	26E6  FE7F    		cp	del
7414:	26E8  280C    		jr	z,iedt40
7415:	26EA  FE18    		cp	ctlx		;erase line?
7416:	26EC  203A    		jr	nz,iedt60	;nz - process normal input character
7417:			
7418:	26EE  AF      		xor	a		;+ eg 3.3.8b
7419:	26EF  B2      		or	d		;+ See if ^X with empty buffer
7420:	26F0  CA100B  		jp	z,z8e		;+ Abandon current command if so
7421:			
7422:	26F3  5A      		ld	e,d		;backspace count is number of chars in buffer
7423:			
7424:	26F4  1804    		jr	iedt50		;+
7425:			
7426:	26F6  AF      	iedt40:	xor	a		;test if already at beginning of buffer
7427:	26F7  B2      		or	d
7428:	26F8  28A5    		jr	z,iedt05	;z - at beginning so leave cursor as is
7429:	26FA  CD3927  	iedt50:	call	bksp		;transmit bs - space - bs string
7430:	26FD  15      		dec	d		;sub one from input buffer count
7431:	26FE  2B      		dec	hl		;rewind buffer pointer on notch
7432:	26FF  7E      		ld	a,(hl)		;check for control characters
7433:	2700  3600    		ld	(hl),0
7434:	2702  FE27    		cp	quote		;check for backspacing over a quote
7435:	2704  200A    		jr	nz,iedt55
7436:	2706  3A632D  		ld	a,(quoflg)	;toggle quote flag so we keep track of balance
7437:							;factor
7438:	2709  EE27    		xor	quote
7439:	270B  32632D  		ld	(quoflg),a
7440:	270E  1805    		jr	iedt58
7441:	2710  FE20    	iedt55:	cp	' '
7442:	2712  DC3927  		call	c,bksp		;c - control char requires extra bs for caret
7443:	2715  1D      	iedt58:	dec	e		;dec backspace count
7444:	2716  20E2    		jr	nz,iedt50	;more backspacing
7445:	2718  3A742D  		ld	a,(strngf)	;string function flag on?
7446:	271B  A7      		and	a
7447:	271C  2881    		jr	z,iedt05	;off - get next input char
7448:	271E  AF      		xor	a		;did we backspace to start of buffer?
7449:	271F  B2      		or	d		;test via character count
7450:	2720  C29F26  		jp	nz,iedt05	;not rewound all the way
7451:	2723  32542E  		ld	(inbfnc),a	;set a zero byte count so caller knows
7452:	2726  15      		dec	d		;something is fishy
7453:	2727  C9      		ret
7454:	2728  77      	iedt60:	ld	(hl),a		;store char in inbf
7455:	2729  23      		inc	hl		;bump inbf pointer
7456:	272A  3600    		ld	(hl),0		;end of line
7457:	272C  14      		inc	d		;bump number of chars in buffer
7458:	272D  7A      	iedt70:	ld	a,d		;current size
7459:	272E  90      		sub	b		;versus max size requested by caller
7460:	272F  DA9F26  		jp	c,iedt05	;more room in buffer
7461:	2732  21542E  	iedt90:	ld	hl,inbfnc	;store number of characters received ala
7462:							;bdos function 10
7463:	2735  72      		ld	(hl),d
7464:	2736  23      		inc	hl		;point to first char in buffer
7465:	2737  15      		dec	d		;set m flag if length is zero
7466:	2738  C9      		ret			;sayonara
7467:			
7468:			
7469:			
7470:	2739  CD3F27  	bksp:	call	bksp00
7471:	273C  CD1925  		call	space1
7472:	273F  3E08    	bksp00:	ld	a,bs
7473:	2741  C38224  		jp	ttyo
7474:			
7475:			
7476:			
7477:	2744  E67F    	asci:	and	7fh		;Convert contents of accumulator to ascii
7478:	0000          		if	hazeltine	;Hazeltine terminal?
7481:				else			;Non-hazeltine terminal
7482:	2746  FE7F    		cp	del		;	check for del
7483:	2748  2805    		jr	z,asci00	;	yes - translate to '.'
7484:				endif			;Any terminal - other characters
7485:	274A  FE20    		cp	20h		;	check for control character
7486:	274C  D28224  		jp	nc,ttyo		;	no - output as is
7487:	274F          	asci00:				;	yes - translate to '.'
7488:			;	if	hazeltine
7489:	274F  3E2E    		ld	a,'.'		;Non-printables replaced with dot
7490:			;	else
7491:			;	ld	a,tilde		;Non-printables replaced with squiggle
7492:			;	endif
7493:	2751  C38224  	       	jp	ttyo
7494:			
7495:			
7496:			
7497:	2754  CD5827  	bcdx:	call	bcdx00
7498:	2757  C0      		ret	nz
7499:	2758  ED6F    	bcdx00:	rld
7500:	275A  EB      		ex	de,hl
7501:	275B  29      		add	hl,hl
7502:	275C  44      		ld	b,h
7503:	275D  4D      		ld	c,l
7504:	275E  29      		add	hl,hl
7505:	275F  29      		add	hl,hl
7506:	2760  09      		add	hl,bc
7507:	2761  4F      		ld	c,a
7508:	2762  3E09    		ld	a,9
7509:	2764  B9      		cp	c
7510:	2765  D8      		ret	c
7511:	2766  AF      		xor	a
7512:	2767  47      		ld	b,a
7513:	2768  09      		add	hl,bc
7514:	2769  EB      		ex	de,hl
7515:	276A  8F      		adc	a,a
7516:	276B  C9      		ret
7517:			
7518:			
7519:			
7520:	276C  CD0C25  	nprint:	call	crlf
7521:	276F  1A      	print:	ld	a,(de)
7522:	2770  A7      		and	a
7523:	2771  C8      		ret	z
7524:	2772  CD8224  		call	ttyo
7525:	2775  13      		inc	de
7526:	2776  18F7    		jr	print
7527:			
7528:			
7529:	2778  7E      	printb:	ld	a,(hl)
7530:	2779  A7      		and	a
7531:	277A  C8      		ret	z
7532:	277B  CD8224  		call	ttyo
7533:	277E  23      		inc	hl
7534:	277F  0D      		dec	c
7535:	2780  20F6    		jr	nz,printb
7536:	2782  C9      		ret
7537:			
7538:			
7539:			
7540:			
7541:	2783          	nrel:					;end of relocatable code
7543:			
7544:	2783          	zopnm:
7545:	2783  484C    		defb	'HL'
7546:	2785  4120    		defb	'A '
7547:	2787  4820    		defb	'H '
7548:	2789  4C20    		defb	'L '
7549:	278B  4420    		defb	'D '
7550:	278D  4520    		defb	'E '
7551:	278F  4220    		defb	'B '
7552:	2791  4320    		defb	'C '
7553:	2793  4958    	ix.:	defb	'IX'
7554:	2795  5350    		defb	'SP'
7555:	2797  5020    		defb	'P '
7556:	2799  5220    		defb	'R '
7557:	279B  4920    		defb	'I '
7558:	279D  4146    		defb	'AF'
7559:	279F  4243    		defb	'BC'
7560:	27A1  4445    		defb	'DE'
7561:	27A3  4959    	iy.:	defb	'IY'
7562:	27A5  5A20    		defb	'Z '
7563:	27A7  4E43    		defb	'NC'
7564:	27A9  4E5A    		defb	'NZ'
7565:	27AB  5045    		defb	'PE'
7566:	27AD  504F    		defb	'PO'
7567:	27AF  4D20    		defb	'M '
7568:	27B1  5043    		defb	'PC'
7569:			
7570:	0008          	ix..	equ	(ix.-zopnm)/2		;relative position - ix
7571:	0010          	iy..	equ	(iy.-zopnm)/2		;		     iy
7572:			
7573:	0018          	zopnml	equ	($-zopnm)/2
7574:			
7575:	0030          	zopjtb	equ	 $-nrel			;nrel to jump table bias for loader
7576:			
7577:	27B3          	zoprjt:
7578:	27B3  2323    		defw	opn600			;18 - hl/ix/iy test
7579:	27B5  F922    		defw	opn400			;19 - register specified in bits 0-2
7580:	27B7  F922    		defw	opn400			;1a - register specified in bits 3-5
7581:	27B9  6322    		defw	opn100			;1b - relative jump
7582:	27BB  8022    		defw	opn200			;1c - nn
7583:	27BD  C422    		defw	opn300			;1d - nnnn
7584:	27BF  6F23    		defw	opn700			;1e - restart
7585:	27C1  7E23    		defw	opn800			;1f - bit number
7586:			
7587:	27C3  732E    	zasmio:	defw	zasmbf
7588:			
7589:	0009          	zopjtl	equ	($-zoprjt)/2		;length of operand jump table
7590:			
7591:	27C5          	jtcmd:
7592:	27C5  C91B    		defw	ifcb			; i
7593:	27C7  A014    		defw	asmblr			; a
7594:	27C9  500F    		defw	usym			; u
7595:	27CB  5511    		defw	nprt			; n
7596:	27CD  810C    		defw	jdbg			; j
7597:	27CF  021F    		defw	zasm			; z
7598:	27D1  B20E    		defw	exam			; e
7599:	27D3  8A10    		defw	rgst			; r
7600:	27D5  2313    		defw	go			; g
7601:	27D7  5C1B    		defw	yfil			; y
7602:	27D9  371B    		defw	movb			; m
7603:	27DB  691E    		defw	verify			; v
7604:	27DD  C81A    		defw	pswDsp			; p
7605:	27DF  E311    		defw	break			; b
7606:	27E1  4612    		defw	cbreak			; c
7607:	27E3  061E    		defw	find			; f
7608:	27E5  EA0E    		defw	hsym			; h
7609:	27E7  3C14    		defw	step			; s
7610:	27E9  A812    		defw	obreak			; o
7611:	27EB  1C1C    		defw	lldr			; l
7612:	27ED  E80F    		defw	dump			; d
7613:	27EF  5511    		defw	qprt			; q
7614:	27F1  931E    		defw	xreg			; x
7615:	27F3  F112    		defw	kdmp			; k
7616:	27F5  AD1D    		defw	writ			; w
7617:	27F7  761B    		defw	cuser			; >
7618:	27F9  971B    		defw	qeval			; ?
7619:			;	defw	gadr			; #
7620:	0000          		if	auxprt
7622:				endif
7623:	27FB          	cmd:
7624:	0000          		if	auxprt
7626:				endif
7627:			;	defb	'#?>WKXQDLOSHFCB'
7628:	27FB  3F3E574B		defb	'?>WKXQDLOSHFCB'
	      5851444C
	      4F534846
	      4342
7629:	2809  50564D59		defb	'PVMYGREZJNUAI'
	      4752455A
	      4A4E5541
	      49
7630:	001B          	ncmd	equ	$-cmd		;number of commands
7631:			
7632:			
7633:			;*****************************
7634:			;*	Message Strings      *
7635:			;*****************************
7636:			
7637:	2816          	bpemsg:
7638:	2816  2A455252		defb	'*ERROR*'
	      4F522A
7639:	281D          	bpmsg:
7640:	281D  2A42502A		defb	'*BP* @ '
	      204020
7641:	2824  00      		defb	0
7642:	2825          	prompt:
7643:	2825  2A200800		defb	'*',' ',bs,0
7644:			
7645:	2829  3D3E    	mrrow:	defb	'=','>'		;backspaces taken out
7646:	282B  00      		defb	00
7647:			
7648:	282C  3F3F    	m????:	defb	'??'
7649:	282E  203F3F20	m??:	defb	' ??  '
	      20
7650:			
7651:			
7652:	2833  20      	asmflg:	defb	' '
7653:	2834  00      		defb	0
7654:			
7655:	2835  20      	lcmd:	defb	' '
7656:	2836  203F3F  	em???:	defb	' ??'
7657:	2839  00      		defb	0
7658:			
7659:	283A          	mldg:
7660:	283A  4C6F6164		defb	'Loading: '
	      696E673A
	      20
7661:	2843  00      		defb	0
7662:			
7663:	2844          	mfilnf:
7664:	2844  46696C65		defb	'File not Found'
	      206E6F74
	      20466F75
	      6E64
7665:	2852  0D0A00  		defb	cr,lf,00
7666:			
7667:	2855          	mlodm:
7668:	2855  4C6F6164		defb	'Loaded:  '
	      65643A20
	      20
7669:	285E  00      		defb	0
7670:	285F          	mlodpg:
7671:			
7672:	285F  50616765		defb	'Pages:   '
	      733A2020
	      20
7673:	2868  00      		defb	0
7674:			
7675:	2869          	msntx:
7676:	2869  53796E74		defb	'Syntax Error'
	      61782045
	      72726F72
7677:	2875  0D0A00  		defb	cr,lf,0
7678:			
7679:	2878  4F757420	mmem??:	defb	'Out of Memory'
	      6F66204D
	      656D6F72
	      79
7680:	2885  00      		defb	0
7681:			
7682:	2886  202D2043	mcntu:	defb	' - Continue? '
	      6F6E7469
	      6E75653F
	      20
7683:	2893  00      		defb	0
7684:			
7685:	2894          	mireg:
7686:	2894  49523A20		defb	'IR: '
7687:	2898  00      		defb	0
7689:			
7690:	0000          		if	auxprt
7697:				endif
7698:			
7699:			
7700:	2899  09192B  	z80fd:	defb	009h,019h,02bh
7701:	289C  232939E1		defb	023h,029h,039h,0e1h
7702:	28A0  E3E5E9F9		defb	0e3h,0e5h,0e9h,0f9h
7703:	000B          	z80fdl	equ	$-z80fd
7704:			
7705:	28A4  21222A36	z80f4:	defb	021h,022h,02ah,036h,0cbh
	      CB
7706:	0005          	z80f4l	equ	$-z80f4
7707:			
7708:			
7709:	28A9  C0E9C9D8	z801:	defb	0c0h,0e9h,0c9h,0d8h
7710:	28AD  D0C8E8E0		defb	0d0h,0c8h,0e8h,0e0h
7711:	28B1  F8F0    		defb	0f8h,0f0h
7712:	000A          	z801l	equ	$-z801
7713:			
7714:			
7715:	28B3  36C6CED3	z802:	defb	036h,0c6h,0ceh,0d3h
7716:	28B7  D6DBDEE6		defb	0d6h,0dbh,0deh,0e6h
7717:	28BB  EEF6FE  		defb	0eeh,0f6h,0feh
7718:	28BE  183830  	z802c:	defb	018h,038h,030h
7719:	28C1  282010  		defb	028h,020h,010h
7720:	0011          	z802l	equ	$-z802
7721:	0006          	z802cl	equ	$-z802c
7722:			
7723:			
7724:	28C4          	z80r:
7725:	28C4  01112122	z803:	defb	001h,011h,021h,022h
7726:	28C8  2A31323A		defb	02ah,031h,032h,03ah
7727:			
7728:	28CC  CD      	z803s:	defb	0cdh
7729:	28CD  DCD4CCC4		defb	0dch,0d4h,0cch,0c4h
7730:	28D1  ECE4FCF4		defb	0ech,0e4h,0fch,0f4h
7731:			
7732:	0009          	z803sl	equ	$-z803s			;number of call instructions
7733:			
7734:	28D5  C3      	z803c:	defb	0c3h
7735:	28D6  DAD2CAC2		defb	0dah,0d2h,0cah,0c2h
7736:	28DA  EAE2FAF2		defb	0eah,0e2h,0fah,0f2h
7737:			
7738:	001A          	z803l	equ	$-z803			;number of 3 byte instructions
7739:	0012          	z803cl	equ	$-z803s			;number of 3 byte pc mod instructions
7740:			
7741:	28DE  434B53  	z80ed:	defb	043h,04bh,053h
7742:	28E1  5B737B  		defb	05bh,073h,07bh
7743:			
7744:	0006          	z80edl	equ	$-z80ed			;number of 4 byte ED instructions
7745:			
7746:	0020          	z80rl	equ	$-z80r			;number of relocatable z80 instructions
7747:			
7748:	0000          		if	h64180
7781:				endif
7782:			
7783:	28E4          	z80f3:
7784:	28E4  3435464E		defb	034h,035h,046h,04eh
7785:	28E8  565E666E		defb	056h,05eh,066h,06eh
7786:	28EC  70717273		defb	070h,071h,072h,073h
7787:	28F0  7475777E		defb	074h,075h,077h,07eh
7788:	28F4  868E969E		defb	086h,08eh,096h,09eh
7789:	28F8  A6AEB6BE		defb	0a6h,0aeh,0b6h,0beh
7790:			
7791:	0018          	z80f3l	equ	$-z80f3
7792:			
7793:	28FC          		org	($+3) and 0fffch
7794:			
7795:	0000          		if	h64180
8046:				else
8047:			
8048:			;***********************************************************************
8049:			;*
8050:			;*	Table of opcodes for Z80 support only
8051:			;*
8052:			;***********************************************************************
8053:			
8054:	28FC          	zopcpt:
8055:	28FC  221C1C15		defb	022h,01ch,01ch,015h	;nop	ld	ld	inc	00 - 03
8056:	2900  150C1C31		defb	015h,00ch,01ch,031h	;inc	dec	ld	rlca	04 - 07
8057:	2904  10001C0C		defb	010h,000h,01ch,00ch	;ex	add	ld	dec	08 - 0b
8058:	2908  150C1C36		defb	015h,00ch,01ch,036h	;inc	dec	ld	rrca	0c - 0f
8059:	290C  0E1C1C15		defb	00eh,01ch,01ch,015h	;djnz	ld	ld	inc	10 - 13
8060:	2910  150C1C2F		defb	015h,00ch,01ch,02fh	;inc	dec	ld	rla	14 - 17
8061:	2914  1B001C0C		defb	01bh,000h,01ch,00ch	;jr	add	ld	dec	18 - 1b
8062:	2918  150C1C34		defb	015h,00ch,01ch,034h	;inc	dec	ld	rra	1c - 1f
8063:	291C  1B1C1C15		defb	01bh,01ch,01ch,015h	;jr	ld	ld	inc	20 - 23
8064:	2920  150C1C0B		defb	015h,00ch,01ch,00bh	;inc	dec	ld	daa	24 - 27
8065:	2924  1B001C0C		defb	01bh,000h,01ch,00ch	;jr	add	ld	dec	28 - 2b
8066:	2928  150C1C0A		defb	015h,00ch,01ch,00ah	;inc	dec	ld	cpl	2c - 2f
8067:	292C  1B1C1C15		defb	01bh,01ch,01ch,015h	;jr	ld	ld	inc	30 - 33
8068:	2930  150C1C3A		defb	015h,00ch,01ch,03ah	;inc	dec	ld	scf	34 - 37
8069:	2934  1B001C0C		defb	01bh,000h,01ch,00ch	;jr	add	ld	dec	38 - 3b
8070:	2938  150C1C04		defb	015h,00ch,01ch,004h	;inc	dec	ld	ccf	3c - 3f
8071:			
8072:			
8073:	293C  1426391C		defb	014h,026h,039h,01ch	;in	out	sbc	ld	ed 40
8074:	2940  212D131C		defb	021h,02dh,013h,01ch	;neg	retn	im	ld
8075:	2944  1426011C		defb	014h,026h,001h,01ch	;in	out	adc	ld
8076:	2948  222C221C		defb	022h,02ch,022h,01ch	;....	reti	...	ld
8077:	294C  1426391C		defb	014h,026h,039h,01ch	;in	out	sbc	ld
8078:	2950  2222131C		defb	022h,022h,013h,01ch	;...	...	im	ld
8079:	2954  1426011C		defb	014h,026h,001h,01ch	;in	out	adc	ld
8080:	2958  2222131C		defb	022h,022h,013h,01ch	;...	...	im	ld
8081:	295C  14263922		defb	014h,026h,039h,022h	;in	out	sbc	...
8082:	2960  22220237		defb	022h,022h,002h,037h	;...	...	...	rrd
8083:	2964  14260122		defb	014h,026h,001h,022h	;in	out	adc	...
8084:	2968  44454632		defb	044h,045h,046h,032h	;defb*	defw*	ddb*	rld
8085:	296C  4347391C		defb	043h,047h,039h,01ch	;org*	equ*	sbc	ld	ed 70
8086:	2970  22222222		defb	022h,022h,022h,022h	;...	...	...	...
8087:	2974  1426011C		defb	014h,026h,001h,01ch	;in	out	adc	ld
8088:	2978  22222222		defb	022h,022h,022h,022h	;...	...	...	...	ed 7f
8089:			
8090:			
8091:	297C  1F081828		defb	01fh,008h,018h,028h	;ldi	cpi	ini	outi
8092:	2980  22222222		defb	022h,022h,022h,022h	;...	...	...	...
8093:	2984  1D061627		defb	01dh,006h,016h,027h	;ldd	cpd	ind	outd
8094:	2988  22222222		defb	022h,022h,022h,022h	;...	...	...	...
8095:	298C  20091925		defb	020h,009h,019h,025h	;ldir	cpir	inir	otir
8096:	2990  22222222		defb	022h,022h,022h,022h	;...	...	...	...
8097:	2994  1E071724		defb	01eh,007h,017h,024h	;lddr	cpdr	indr	otdr
8098:	2998  22222244		defb	022h,022h,022h,044h	;...	....	....	defb*
8099:			
8100:			
8101:	299C  2B291A1A		defb	02bh,029h,01ah,01ah	;ret	pop	jp	jp	c0 - c3
8102:	29A0  032A0038		defb	003h,02ah,000h,038h	;call	push	add	rst	c4 - c7
8103:	29A4  2B2B1A22		defb	02bh,02bh,01ah,022h	;ret	ret	jp	...	c8 - cb
8104:	29A8  03030138		defb	003h,003h,001h,038h	;call	call	adc	rst	cc - cf
8105:	29AC  2B291A26		defb	02bh,029h,01ah,026h	;ret	pop	jp	out	d0 - d3
8106:	29B0  032A3E38		defb	003h,02ah,03eh,038h	;call	push	sub	rst	d4 - d7
8107:	29B4  2B111A14		defb	02bh,011h,01ah,014h	;ret	exx	jp	in	d8 - db
8108:	29B8  03223938		defb	003h,022h,039h,038h	;call	...	sbc	rst	dc - df
8109:	29BC  2B291A10		defb	02bh,029h,01ah,010h	;ret	pop	jp	ex	e0 - e3
8110:	29C0  032A0238		defb	003h,02ah,002h,038h	;call	push	and	rst	e4 - e7
8111:	29C4  2B1A1A10		defb	02bh,01ah,01ah,010h	;ret	jp	jp	ex	e8 - eb
8112:	29C8  03223F38		defb	003h,022h,03fh,038h	;call	...	xor	rst	ec - ef
8113:	29CC  2B291A0D		defb	02bh,029h,01ah,00dh	;ret	pop	jp	di	f0 - f3
8114:	29D0  032A2338		defb	003h,02ah,023h,038h	;call	push	or	rst	f4 - f7
8115:	29D4  2B1C1A0F		defb	02bh,01ch,01ah,00fh	;ret	ld	jp	ei	f8 - fb
8116:	29D8  03220538		defb	003h,022h,005h,038h	;call	...	cp	rst	fc - ff
8117:			
8118:	29DC  00013E39		defb	000h,001h,03eh,039h	;add	adc	sub	sbc
8119:	29E0  023F2305		defb	002h,03fh,023h,005h	;and	xor	or	cp
8120:			
8121:			
8122:	29E4  30352E33		defb	030h,035h,02eh,033h	;rlc	rrc	rl	rr
8123:	29E8  3B3C223D		defb	03bh,03ch,022h,03dh	;sla	sra	...	srl
8124:	29EC  22404142		defb	022h,040h,041h,042h	;...	bit	res	set
8125:			
8126:			
8127:	29F0  22222212		defb	022h,022h,022h,012h	;...	...	...	halt
8128:			
8129:			
8130:	29F4  1C1C1C1C		defb	01ch,01ch,01ch,01ch	;ld	ld	ld	ld
8131:	29F8  1C1C1C1C		defb	01ch,01ch,01ch,01ch	;ld	ld	ld	ld
8132:			
8134:			;****************************************************************************
8135:			;*
8136:			;*	Table of first operands for Z80 support only
8137:			;*
8138:			;****************************************************************************
8139:			
8140:	29FC          	zopnd1:
8141:	29FC  FF0E8E0E		defb	0ffh,00eh,08eh,00eh	;00 - 03
8142:	2A00  060606FF		defb	006h,006h,006h,0ffh	;04 - 07
8143:	2A04  0D18010E		defb	00dh,018h,001h,00eh	;08 - 0b
8144:	2A08  070707FF		defb	007h,007h,007h,0ffh	;0c - 0f
8145:	2A0C  1B0F8F0F		defb	01bh,00fh,08fh,00fh	;10 - 13
8146:	2A10  040404FF		defb	004h,004h,004h,0ffh	;14 - 17
8147:	2A14  1B18010F		defb	01bh,018h,001h,00fh	;18 - 1b
8148:	2A18  050505FF		defb	005h,005h,005h,0ffh	;1c - 1f
8149:	2A1C  13189D18		defb	013h,018h,09dh,018h	;20 - 23
8150:	2A20  020202FF		defb	002h,002h,002h,0ffh	;24 - 27
8151:	2A24  11181818		defb	011h,018h,018h,018h	;28 - 2b
8152:	2A28  030303FF		defb	003h,003h,003h,0ffh	;2c - 2f
8153:	2A2C  12099D09		defb	012h,009h,09dh,009h	;30 - 33
8154:	2A30  989898FF		defb	098h,098h,098h,0ffh	;34 - 37
8155:	2A34  07180109		defb	007h,018h,001h,009h	;38 - 3b
8156:	2A38  010101FF		defb	001h,001h,001h,0ffh	;3c - 3f
8157:			
8158:	2A3C  0687009D		defb	006h,087h,000h,09dh	;40 - 43
8159:	2A40  FFFF1F0C		defb	0ffh,0ffh,01fh,00ch	;44 - 47
8160:	2A44  0787000E		defb	007h,087h,000h,00eh	;48 - 4b
8161:	2A48  FFFFFF0B		defb	0ffh,0ffh,0ffh,00bh	;4c - 4f
8162:	2A4C  0487009D		defb	004h,087h,000h,09dh	;50 - 53
8163:	2A50  FFFF1F01		defb	0ffh,0ffh,01fh,001h	;54 - 57
8164:	2A54  0587000F		defb	005h,087h,000h,00fh	;58 - 5b
8165:	2A58  FFFF1F01		defb	0ffh,0ffh,01fh,001h	;5c - 5f
8166:	2A5C  028700FF		defb	002h,087h,000h,0ffh	;60 - 63
8167:	2A60  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;64 - 67
8168:	2A64  038700FF		defb	003h,087h,000h,0ffh	;68 - 6b
8169:	2A68  1C1D1DFF		defb	01ch,01dh,01dh,0ffh	;6c - 6f	defb  defw  ddb
8170:	2A6C  1D1D009D		defb	01dh,01dh,000h,09dh	;70 - 73	org   equ
8171:	2A70  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;74 - 77
8172:	2A74  01870009		defb	001h,087h,000h,009h	;78 - 7b
8173:	2A78  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;7c - 7f
8174:			
8175:	2A7C  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;a0 - bf
8176:	2A80  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;a4 - a7
8177:	2A84  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;a8 - ab
8178:	2A88  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;ac - af
8179:	2A8C  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;b0 - b3
8180:	2A90  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;b4 - b7
8181:	2A94  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;b8 - bb
8182:	2A98  FFFF0FFF		defb	0ffh,0ffh,00fh,0ffh	;bc - bf
8183:			;??18E	defb	0ffh,0ffh,0ffh,0ffh	;bc - bf
8184:			
8185:	2A9C  130E131D		defb	013h,00eh,013h,01dh	;c0 - c3
8186:	2AA0  130E011E		defb	013h,00eh,001h,01eh	;c4 - c7
8187:	2AA4  11FF11FF		defb	011h,0ffh,011h,0ffh	;c8 - cb
8188:	2AA8  111D011E		defb	011h,01dh,001h,01eh	;cc - cf
8189:	2AAC  120F129C		defb	012h,00fh,012h,09ch	;d0 - d3
8190:	2AB0  120F1C1E		defb	012h,00fh,01ch,01eh	;d4 - d7
8191:	2AB4  07FF0701		defb	007h,0ffh,007h,001h	;d8 - db
8192:	2AB8  07FF011E		defb	007h,0ffh,001h,01eh	;dc - df
8193:	2ABC  15181589		defb	015h,018h,015h,089h	;e0 - e3
8194:	2AC0  15181C1E		defb	015h,018h,01ch,01eh	;e4 - e7
8195:	2AC4  1498140F		defb	014h,098h,014h,00fh	;e8 - eb
8196:	2AC8  14FF1C1E		defb	014h,0ffh,01ch,01eh	;ec - ef
8197:	2ACC  0A0D0AFF		defb	00ah,00dh,00ah,0ffh	;f0 - f3
8198:	2AD0  0A0D1C1E		defb	00ah,00dh,01ch,01eh	;f4 - f7
8199:	2AD4  160916FF		defb	016h,009h,016h,0ffh	;f8 - fb
8200:	2AD8  16FF1C1E		defb	016h,0ffh,01ch,01eh	;fc - ff
8201:			
8202:			
8203:	2ADC  01011901		defb	001h,001h,019h,001h	;8 bit logic and arithmetic
8204:	2AE0  19191919		defb	019h,019h,019h,019h	;
8205:			
8206:			
8207:	2AE4  19191919		defb	019h,019h,019h,019h	;shift and rotate
8208:	2AE8  19191919		defb	019h,019h,019h,019h	;
8209:	2AEC  FF1F1F1F		defb	0ffh,01fh,01fh,01fh	;bit - res - set
8210:			
8211:	2AF0  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;filler
8212:			
8213:	2AF4  1A1A1A1A		defb	01ah,01ah,01ah,01ah	;8 bit load
8214:	2AF8  1A1A1A1A		defb	01ah,01ah,01ah,01ah	;
8215:			
8217:			;***********************************************************************
8218:			;*
8219:			;*	Table of second operands for Z80 support only
8220:			;*
8221:			;***********************************************************************
8222:			
8223:	2AFC          	zopnd2:
8224:	2AFC  FF1D01FF		defb	0ffh,01dh,001h,0ffh	;00 - 03
8225:	2B00  FFFF1CFF		defb	0ffh,0ffh,01ch,0ffh	;04 - 07
8226:	2B04  0D0E8EFF		defb	00dh,00eh,08eh,0ffh	;08 - 0b
8227:	2B08  FFFF1CFF		defb	0ffh,0ffh,01ch,0ffh	;0c - 0f
8228:	2B0C  FF1D01FF		defb	0ffh,01dh,001h,0ffh	;10 - 13
8229:	2B10  FFFF1CFF		defb	0ffh,0ffh,01ch,0ffh	;14 - 17
8230:	2B14  FF0F8FFF		defb	0ffh,00fh,08fh,0ffh	;18 - 1b
8231:	2B18  FFFF1CFF		defb	0ffh,0ffh,01ch,0ffh	;1c - 1f
8232:	2B1C  1B1D18FF		defb	01bh,01dh,018h,0ffh	;20 - 23
8233:	2B20  FFFF1CFF		defb	0ffh,0ffh,01ch,0ffh	;24 - 27
8234:	2B24  1B189DFF		defb	01bh,018h,09dh,0ffh	;28 - 2b
8235:	2B28  FFFF1CFF		defb	0ffh,0ffh,01ch,0ffh	;2c - 2f
8236:	2B2C  1B1D01FF		defb	01bh,01dh,001h,0ffh	;30 - 33
8237:	2B30  FFFF1CFF		defb	0ffh,0ffh,01ch,0ffh	;34 - 37
8238:	2B34  1B099DFF		defb	01bh,009h,09dh,0ffh	;38 - 3b
8239:	2B38  FFFF1CFF		defb	0ffh,0ffh,01ch,0ffh	;3c - 3f
8240:			
8241:			
8242:	2B3C  87060E0E		defb	087h,006h,00eh,00eh	;40 - 43
8243:	2B40  FFFFFF01		defb	0ffh,0ffh,0ffh,001h	;44 - 47
8244:	2B44  87070E9D		defb	087h,007h,00eh,09dh	;48 - 4b
8245:	2B48  FFFFFF01		defb	0ffh,0ffh,0ffh,001h	;4c - 4f
8246:	2B4C  87040F0F		defb	087h,004h,00fh,00fh	;50 - 53
8247:	2B50  FFFFFF0C		defb	0ffh,0ffh,0ffh,00ch	;54 - 57
8248:	2B54  87050F9D		defb	087h,005h,00fh,09dh	;58 - 5b
8249:	2B58  FFFFFF0B		defb	0ffh,0ffh,0ffh,00bh	;5c - 5f
8250:	2B5C  870200FF		defb	087h,002h,000h,0ffh	;60 - 63
8251:	2B60  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;64 - 67
8252:	2B64  870300FF		defb	087h,003h,000h,0ffh	;68 - 6b
8253:	2B68  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;6c - 6f
8254:	2B6C  FFFF0909		defb	0ffh,0ffh,009h,009h	;70 - 73
8255:	2B70  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;74 - 77
8256:	2B74  8701099D		defb	087h,001h,009h,09dh	;78 - 7b
8257:	2B78  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh
8258:			
8259:	2B7C  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;a0 - bf
8260:	2B80  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;a4 - a7
8261:	2B84  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;a8 - ab
8262:	2B88  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;ac - af
8263:	2B8C  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;b0 - b3
8264:	2B90  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;b4 - b7
8265:	2B94  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;b8 - bb
8266:	2B98  FFFF0FFF		defb	0ffh,0ffh,00fh,0ffh	;bc - bf
8267:			
8268:	2B9C  FFFF1DFF		defb	0ffh,0ffh,01dh,0ffh	;c0 - c3
8269:	2BA0  1DFF1CFF		defb	01dh,0ffh,01ch,0ffh	;c4 - c7
8270:	2BA4  FFFF1DFF		defb	0ffh,0ffh,01dh,0ffh	;c8 - cb
8271:	2BA8  1DFF1CFF		defb	01dh,0ffh,01ch,0ffh	;cc - cf
8272:	2BAC  FFFF1D01		defb	0ffh,0ffh,01dh,001h	;d0 - d3
8273:	2BB0  1DFFFFFF		defb	01dh,0ffh,0ffh,0ffh	;d4 - d7
8274:	2BB4  FFFF1D9C		defb	0ffh,0ffh,01dh,09ch	;d8 - db
8275:	2BB8  1DFF1CFF		defb	01dh,0ffh,01ch,0ffh	;dc - df
8276:	2BBC  FFFF1D18		defb	0ffh,0ffh,01dh,018h	;e0 - e3
8277:	2BC0  1DFFFFFF		defb	01dh,0ffh,0ffh,0ffh	;e4 - e7
8278:	2BC4  FFFF1D00		defb	0ffh,0ffh,01dh,000h	;e8 - eb
8279:	2BC8  1DFFFFFF		defb	01dh,0ffh,0ffh,0ffh	;ec - ef
8280:	2BCC  FFFF1DFF		defb	0ffh,0ffh,01dh,0ffh	;f0 - f3
8281:	2BD0  1DFFFFFF		defb	01dh,0ffh,0ffh,0ffh	;f4 - f7
8282:	2BD4  FF181DFF		defb	0ffh,018h,01dh,0ffh	;f8 - fb
8283:	2BD8  1DFFFFFF		defb	01dh,0ffh,0ffh,0ffh	;fc - ff
8284:			
8285:	2BDC  1919FF19		defb	019h,019h,0ffh,019h	;8 bit logic and arithmetic
8286:	2BE0  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;
8287:			
8288:	2BE4  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;shift and rotate
8289:	2BE8  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh	;
8290:	2BEC  FF191919		defb	0ffh,019h,019h,019h	;bit - res - set
8291:			
8292:	2BF0  FFFFFFFF		defb	0ffh,0ffh,0ffh,0ffh
8293:			
8294:	2BF4  19191919		defb	019h,019h,019h,019h	;8 bit load
8295:	2BF8  19191919		defb	019h,019h,019h,019h
8296:			
8297:				endif
8298:			
8300:			
8301:			;***********************************************************************
8302:			;*
8303:			;*			Table of opcode names
8304:			;*
8305:			;*	Supports 67 Z80 Mnemonics, 5 Pseudo-ops and 10 HD64180 Mnemonics
8306:			;*
8307:			;*	Three of Hitachi's HD64180 Mnemonics are 5 characters long
8308:			;*	(only the Japanese know why) but it was decided to implement
8309:			;*	them as 4 characters for 18E as follows:
8310:			;*
8311:			;*			 HITACHI |   18E
8312:			;*			---------+--------
8313:			;*			 TSTIO   |   TSIO
8314:			;*			 OTIMR   |   OIMR
8315:			;*			 OTDMR   |   ODMR
8316:			;*
8317:			;*	The management sincerely hopes that this little exercise in
8318:			;*	poetic license will not inconvenience anyone in the least!!
8319:			;*
8320:			;***********************************************************************
8321:			
8322:			
8323:	2BFC          	zopcnm:
8324:	2BFC  41444420		defb	'ADD ADC AND CALL'
	      41444320
	      414E4420
	      43414C4C
8325:	2C0C  43434620		defb	'CCF CP  CPD CPDR'
	      43502020
	      43504420
	      43504452
8326:	2C1C  43504920		defb	'CPI CPIRCPL DAA '
	      43504952
	      43504C20
	      44414120
8327:	2C2C  44454320		defb	'DEC DI  DJNZEI  '
	      44492020
	      444A4E5A
	      45492020
8328:	2C3C  45582020		defb	'EX  EXX HALTIM  '
	      45585820
	      48414C54
	      494D2020
8329:	2C4C  494E2020		defb	'IN  INC IND INDR'
	      494E4320
	      494E4420
	      494E4452
8330:	2C5C  494E4920		defb	'INI INIRJP  JR  '
	      494E4952
	      4A502020
	      4A522020
8331:	2C6C  4C442020		defb	'LD  LDD LDDRLDI '
	      4C444420
	      4C444452
	      4C444920
8332:	2C7C  4C444952		defb	'LDIRNEG NOP OR  '
	      4E454720
	      4E4F5020
	      4F522020
8333:	2C8C  4F544452		defb	'OTDROTIROUT OUTD'
	      4F544952
	      4F555420
	      4F555444
8334:	2C9C  4F555449		defb	'OUTIPOP PUSHRET '
	      504F5020
	      50555348
	      52455420
8335:	2CAC  52455449		defb	'RETIRETNRL  RLA '
	      5245544E
	      524C2020
	      524C4120
8336:	2CBC  524C4320		defb	'RLC RLCARLD RR  '
	      524C4341
	      524C4420
	      52522020
8337:	2CCC  52524120		defb	'RRA RRC RRCARRD '
	      52524320
	      52524341
	      52524420
8338:	2CDC  52535420		defb	'RST SBC SCF SLA '
	      53424320
	      53434620
	      534C4120
8339:	2CEC  53524120		defb	'SRA SRL SUB XOR '
	      53524C20
	      53554220
	      584F5220
8340:	2CFC  42495420		defb	'BIT RES SET ORG '
	      52455320
	      53455420
	      4F524720
8341:	2D0C  44454642		defb	'DEFBDEFWDDB EQU '
	      44454657
	      44444220
	      45515520
8342:			
8343:	0000          		if	h64180
8347:				endif
8348:			
8349:			
8350:	2D1C          	op1000:
8351:	2D1C  FDDDEDCB		defb	 0fdh,0ddh,0edh,0cbh
8352:			
8353:			
8354:			
8355:	2D20  88      	pswbit:	defb	10001000b		;minus
8356:	2D21  80      		defb	10000000b		;positive
8357:	2D22  0C      		defb	00001100b		;even parity
8358:	2D23  04      		defb	00000100b		;odd parity
8359:	2D24  48      		defb	01001000b		;zero
8360:	2D25  40      		defb	01000000b		;not zero
8361:	2D26  09      		defb	00001001b		;carry
8362:	2D27  01      		defb	00000001b		;no carry
8363:			
8364:	2D28  12071311	pswmap:	defb	18,07,19,17,21,20,10,22
	      15140A16
8365:	0008          	pswcnt	equ	$-pswmap
8366:			
8367:			
8368:	2D30          	regmap:
8369:	2D30  87010706		defb	87h,01h,07h,06h,05h,04h
	      0504
8370:	2D36  03029593		defb	03h,02h,95h,93h,91h,18h
	      9118
8371:	2D3C  19818385		defb	19h,81h,83h,85h,97h
	      97
8372:			
8373:	2D41          	regptr:
8374:	2D41  0D0E0F00		defb	0dh,0eh,0fh,00h
8375:	2D45  8D8E8F80		defb	8dh,8eh,8fh,80h
8376:	2D49  0A090810		defb	0ah,09h,08h,10h
8377:			
8378:	2D4D  F5F7    	siotbl:	defb	0f5h,0f7h
8379:			
8380:	2D4F  FF      	symflg:	defb	0ffh		;symbol table flag   00 - table present
8381:							;		     ff - no table
8382:			
8383:	2D50          	bsiz:				;dump block size storage
8384:	2D50  00      	bsizlo:	defb	0		;     lo order
8385:	2D51  01      	bsizhi:	defb	1		;     hi order
8386:	2D52  0001    	blkptr:	defw	100h		;dump block address
8387:			
8388:	2D54  0001    	loadb:	defw    100h		;z8e load bias for lldr command
8389:	2D56  0000    	loadn:	defw	00		;end of load address
8390:			
8391:	2D58          	asmbpc:				;next pc location for assembly
8392:	2D58  0001    	zasmpc:	defw	100h		;next pc location for disassemble
8393:							;default at load time: start of tpa
8394:	2D5A  0000    	zasmfl:	defw	00		;first disassembled address on jdbg screen
8395:			
8396:			
8397:	2D5C          	from:
8398:	2D5C          	oprn01:
8399:	2D5C          	rlbias:
8400:	2D5C          	lines:
8401:	2D5C          	exampt:
8402:	2D5C          	endw:
8403:	2D5C  00      	zasmnx:	defb	0		;address of next instruction to disassemble
8404:	2D5D  00      	oprx01:	defb	0
8405:	2D5E          	bias:
8406:	2D5E          	biaslo:
8407:	2D5E  00      	zasmct:	defb	0		;disassembly count
8408:	2D5F          	biashi:
8409:	2D5F  00      	oprn02:	defb	0
8410:	2D60          	oprx02:
8411:	2D60  0000    	zasmwt:	defw	0		;disassembly count - working tally
8412:	2D62  00      	opnflg:	defb	0		;00 - operand 1   ff - operand 2   zasm
8413:							;and input character storage for interactive
8414:							;disassembly
8415:	2D63  00      	quoflg:	defb	0
8416:	2D64  FF      	wflag:	defb	0ffh		;trace subroutine flag: nz - trace subs
8417:							;			 z - no trace
8418:			
8419:	2D65          	nstep:
8420:	2D65  00      	nstepl:	defb	0
8421:	2D66  00      	nsteph:	defb	0
8422:			
8423:	2D67  00      	sbps:	defb	0		;number of step breakpoints
8424:	2D68  00      	bps:	defb	0		;number of normal breakpoints
8425:			
8426:	2D69  00      	zmflag:	defb	0
8427:	2D6A  00      	zasmf:	defb	0
8428:	2D6B          	execbf:				;execute buffer for relocated code
8429:	2D6B          	jlines:
8430:	2D6B          	parenf:
8431:	2D6B  00      	nument:	defb	0		;number of digits entered
8432:	2D6C  00      	delim:	defb	0		;argument delimeter character
8433:	2D6D  00      		defb	0
8434:	2D6E  00      	base10:	defb	0
8435:	2D6F  00      	jmp2jp:	defb	0
8436:	2D70  00      	jmp2:	defb	0
8437:	2D71          	dwrite:
8438:	2D71  00      	cflag:	defb	0
8439:			
8440:	2D72          	ikey:
8441:	2D72          	zasmkv:
8442:	2D72  00      	zjmp:	defb	0
8443:	2D73          	mexp:
8444:	2D73  00      	jmplo:	defb	0
8445:	2D74          	strngf:
8446:	2D74  00      	jmphi:	defb	0
8447:	2D75          	timer:
8448:	2D75  00      	first:	defb	0
8449:	2D76  00      	regtrm:	defb	0
8450:	2D77  00      	trmntr: defb	0
8451:	2D78  0000    	isympt:	defw	0
8452:			
8453:	2D7A          	jropnd:
8454:	2D7A  0000    	pass2:	defw	0
8455:			
8456:	2D7C  0000    	fndsym:	defw	0
8457:			
8458:	0000          	    if	ASMB
8460:			    else
8461:	2D7E          	maxlen::
8462:			    endif
8463:	2D7E  0E00    		defw	14
8464:			
8465:	2D80  3E00    	maxlin:	defw	62
8466:			
8467:	2D82  00      	fwndow:	defb	00
8468:			
8469:	2D83  00      	nlmask:	defb	00
8470:			
8471:	0000          	    if	ASMB
8473:			    else
8474:	2D84          	case::
8475:			    endif
8476:	2D84  FF      		defb	0ffh		;flag to indicate case of output
8477:							;nz - lower   z - upper
8478:			
8479:	2D85  FF      	jstepf:	defb	0ffh		;00 -   screen is intact, if user wants J
8480:							;       single step no need to repaint screen,
8481:							;       just move arrow.
8482:							;01   - user wants single-step J command
8483:							;else - J screen corrupted by non-J command
8484:			
8485:	2D86  03      	lastro:	defb	03
8486:			
8487:			
8488:			;************************************************************************
8489:			;*	Configuration bytes for user's main terminal                    *
8490:			;*	(Default is for Wyse, Televideo, Soroc... terminals)            *
8491:			;************************************************************************
8492:			
8493:			; Row before column flag
8494:			
8495:	0000          	    if	ASMB
8497:			    else
8498:	2D87          	mrowb4::
8499:			    endif
8500:	0000          	    if jterm
8502:			    else
8503:	2D87  00      	        defb    0		;ZDS col,row
8504:			    endif
8505:			
8506:			; Row offset value
8507:			
8508:	0000          	    if	ASMB
8510:			    else
8511:	2D88          	mrow::
8512:			    endif
8513:	0000          	    if jterm				;my terminal uses no bias for
8515:			    else
8516:	2D88  20      		defb	' '			;bias for most other terminals
8517:			    endif
8518:			
8519:			; Col offset value
8520:			
8521:	0000          	    if	ASMB
8523:			    else
8524:	2D89          	mcol::
8525:			    endif
8526:	0000          	    if jterm				;see above
8528:			    else
8529:	2D89  20      		defb	' '
8530:			    endif
8531:			
8532:			; Cursor control string
8533:			
8534:	0000          	    if	ASMB
8536:			    else
8537:	2D8A          	mxystr::
8538:			    endif
8539:	0000          	    if jterm
8541:			    else
8542:	0000          	    if aterm
8544:			    else
8545:	2D8A  011B00  		defb	1,1bh,0		;NeZ80 ZDS
8546:	2D8D  00000000		defb	0,0,0,0,0,0,0,0
	      00000000
8547:			    endif
8548:			    endif
8549:			
8550:			
8551:	0000          		if	auxprt
8597:				endif
8598:			
8599:			
8600:	2D95  0000    	wnwtab:	defw	0
8601:	2D97  0000    	wnwsiz:	defw	0
8602:			
8603:	2D99  0000    	port:	defw	0
8604:			
8605:	2D9B .. 2DD0 00	brktbl:	defs	(maxbp+2)*3
8606:	2DD1 .. 2DF0 00	psctbl:	defs	maxbp*2
8607:			
8608:			
8609:	2DF1          	regcon:
8610:	2DF1          	afreg:
8611:	2DF1  00      	freg:	defb	00
8612:	2DF2  00      		defb	00
8613:	2DF3  0000    	bcreg:	defw	00
8614:	2DF5  0000    	dereg:	defw	00
8615:	2DF7  0000    	hlreg:	defw	00
8616:	2DF9  0000    	afpreg:	defw	00
8617:	2DFB  0000    	bcpreg:	defw	00
8618:	2DFD  0000    	depreg:	defw	00
8619:	2DFF  0000    	hlpreg:	defw	00
8620:	2E01          	pcreg:
8621:	2E01  00      	pcregl:	defb	00
8622:	2E02  01      	pcregh:	defb	01
8623:	2E03  0000    	spreg:	defw	00
8624:	2E05  0000    	ixreg:	defw	00
8625:	2E07  0000    	iyreg:	defw	00
8626:			
8627:	0018          	regsiz	equ	$-regcon
8628:			
8629:	2E09  00      	rreg:	defb	00
8630:	2E0A  00      	ireg:	defb	00
8631:			
8632:			
8633:	2E0B  0000    	fstart:	defw	0
8634:	2E0D  0000    	argbc:	defw	0
8635:	2E0F  112E    	argbpt:	defw	argbf
8636:			
8637:	2E11          	regsav	equ	$		;storage for register contents in between bps
8638:							;while jdbg is in control
8639:			
8640:	2E29          	window	equ	regsav+regsiz	;memory window save area
8641:			
8642:	003E          	argbsz	equ	62
8643:			
8644:	2E11 .. 2E4E 00	argbf:	defs	argbsz
8645:			
8646:	2E2B          	fcb	equ     argbf+argbsz-36 ;cp/m file control block
8647:	2E2C          	fcbnam	equ	fcb+1		;start of file name in fcb
8648:	2E34          	fcbtyp	equ	fcbnam+8	;start of file type in fcb
8649:	2E37          	fcbext	equ	fcbtyp+3	;current extent number
8650:	2E4F          	nfcb	equ	$		;last byte of fcb plus one
8651:			
8652:	00A4          	gpbsiz	equ	164		;size of general purpose buffer
8653:			
8654:	2E4F          	symbuf:
8655:	2E4F          	objbuf:				;object code buffer
8656:			; 	rept	gpbsiz
8657:	2E4F .. 2EF2 00		defs	gpbsiz
8658:			; 	endm
8659:	0052          	inbfsz	equ	gpbsiz/2
8660:	2E53          	inbfmx	equ	objbuf+4	;input buffer - max byte count storage
8661:	2E54          	inbfnc	equ	inbfmx+1	;	      - number chars read in
8662:	2E55          	inbf	equ	inbfnc+1	;	      - starting address
8663:	0051          	inbfl	equ	inbfsz-1	;	      - last relative position
8664:	2EA6          	ninbf	equ	inbf+inbfl	;	      - address of last char
8665:			
8666:	0052          	prsbfz	equ	gpbsiz/2
8667:	2EA7          	prsbf	equ	inbf+inbfsz	;parse buffer - starting address
8668:	2EF8          	lprsbf	equ	prsbf+prsbfz-1	;	      - last char of parse buf
8669:	2EF9          	nprsbf	equ	lprsbf+1	;	      - end address plus one
8670:			
8671:	2EF3          	nzasm	equ	$		;end of disassembly buffer
8672:	2E73          	zasmbf	equ	nzasm-128	;start of disassembly buffer
8673:			
8674:	2EF3 .. 2F1A 00		defs	40
8675:	2F1B          	stack:
8676:	2500          	nmem	equ	((($+255) and 0ff00h)-z8eorg) and 0ff00h
8677:			;	was	(256*(($+255)/256)-z8eorg) and 0ff00h
8678:			
8679:	0000          		if M80
8681:				endif
8682:			
8683:	2F1B          		end



Statistics:

     8	passes
     0	jr promotions
   902	symbols
     0	bytes



Symbol Table:

.eof             640     ifcb12          1c04     pcregh          2e02     
.eof10           672     ikey            2d72     pcregl          2e01     
.eof20           67a     ilcs            24fa     pcrlf            fc3     
.eof50           6a6     ilin            2555     port            2d99     
.idprn           8f5+    imem            1d8d     print           276f     
.lst??           8b4     in00            258e     printb          2778     
.lstsz         =  11+    in10            2598     prompt          2825     
.m80??           8e5     inbf           =2e55+    prsbf          =2ea7+    
.m80sz         =   8+    inbfl          =  51+    prsbfz         =  52+    
.pr325           4d1     inbfmx         =2e53+    prsr            1927     
.pr330           4e8     inbfnc         =2e54+    prsr10          1931     
.pr335           4f4     inbfsz         =  52+    prsr20          193e     
.pr340           506+    inchar          24cc     prsr30          1950     
.pr342           513     init             9fd     prsr50          195f     
.pr345           51b     iobuf          =  80+    prsr60          196f     
.pr350           532     ireg            2e0a     psctbl          2dd1     
.pr351           53f     irsm            256d     pstrng           8f2     
.pr352           552     istr            2561     psw00           1acd     
.pr355           556     isym            1903     psw10           1ae6     
.pr357           55b     isym00          190e     psw50           1b04+    
.pr370           572     isympt          2d78     psw55           1b08     
.pr4             579     ix.             2793     psw60           1b31     
.pr410           590     ix..           =   8+    pswbit          2d20     
.pr420           59b     ixlt            2503     pswcnt         =   8+    
.pr421           5bb     ixreg           2e05     pswdsp          1ac8     
.pr425           5cf     iy.             27a3     pswmap          2d28     
.pr430           5dc     iy..           =  10+    putc             fdb     
.pr435           5f7     iyreg           2e07     putc00           fdf+    
.pr438           602     jdbg             c81     qev01           1bc6     
.pr440           60f     jdbg00           c87     qeval           1b97     
.pr450           621     jdbg01           ca6     qprt            1155     
.prn             47c     jdbg02           caa     qprt00          1178     
.prn00           4bc     jdbg03           cc5     qprt10          1186     
.prn??           8c6     jdbg05           cc8     qprt20          11a4     
.prnaa           491     jdbg08           cd9     qprt30          11ab     
.prnbb           49a     jdbg10           ce9     qprt50          11c5     
.prncc           4b3+    jdbg15           cee     qprt60          11dc     
.prnsz         =   a+    jdbg20           d08     quoflg          2d63     
.slr             628     jdbg25           d13     quote          =  27+    
.slr??           8d1     jdbg28           d2f     read             7bf     
.slrsz         =  13+    jdbg2a           cb6     regcon          2df1     
.sym             385     jdbg30           d34     regmap          2d30     
.sym00           395     jdbg35           d40     regptr          2d41     
.sym10           3a6     jdbg40           d4a     regsav         =2e11+    
.sym20           3b5     jdbg42           d60     regsiz         =  18+    
.sym21           3d1     jdbg45           d71     regtrm          2d76     
.sym22           3ee     jdbg50           d97     relchr           8f4     
.sym23           3fb     jdbg55           da6     rgdisp           e72     
.sym25           412     jdbg60           daf     rgst            108a     
.sym30           427     jdbg65           db8     rgst00          10ae     
.sym35           44d     jdbg70           de1     rgst10          10c9     
.sym40           457     jdbg75           de8     rgst15          10d2     
.sym45           45f     jdbg78           e1d     rgst20          10ed     
.sym50           473     jdbg80           e21     rgst22          10f5     
afpreg          2df9     jdbg90           e24     rgst25          110a     
afreg           2df1     jdbg95           e32     rgst30          110f     
argbc           2e0d     jlines          2d6b     rgst40          1116     
argbf           2e11     jmp2            2d70     rlbias          2d5c+    
argbpt          2e0f     jmp2jp          2d6f     rreg            2e09     
argbsz         =  3e+    jmphi           2d74     rslv            1699     
asci            2744     jmplo           2d73     rslv00          16a0     
asci00          274f     jropnd          2d7a     rslv10          16ac     
asm000          14a6     jstepf          2d85     rslv20          16b0     
asm005          14af     jtcmd           27c5     rslv25          16cd     
asm010          14b2     jterm          =   0+    rslv30          16d3     
asm015          14c2     kdmp            12f1     rslv35          16e2     
asm030          14f3     kdmp00          1314     rslv40          16ea     
asm040          1508     kdmp20          131b     rslv50          16f5     
asm050          1512     lastro          2d86     rslv60          1705     
asm060          1524     lbin            1c68     rslv70          171f     
asm070          152a     lbin00          1c6b     rst38          =  ff+    
asm085          156b     lbin20          1c8b     rstvec           103     
asm090          156d     lbin22          1c90     sbps            2d67     
asm095          158c     lbin25          1cba     siotbl          2d4d+    
asm???          198c     lbin30          1cbf     slr            =ffff+    
asm??l          1976     lbin35          1cc2     space1          2519     
asm??o          197a     lbin40          1cd1     space5          251e     
asm??p          197e+    lcmd            2835     spaces          2520     
asm??s          1982     lf             =   a+    spreg           2e03     
asm??t          1986     lfcb            1d0b     srch            1e58     
asm??u          158f     lfcb00          1d23     srch00          1e5b     
asm??v          198a     lfcb10          1d3c     srch10          1e65     
asmb           =   0+    lfcb20          1d41     stack           2f1b     
asmblr          14a0     lfcb30          1d4a+    star             8f6     
asmbpc          2d58     lfcb90          1d55     step            143c     
asmflg          2833     lfcb95          1d6a     step20          1464     
aterm          =   0+    lfcb96          1d6c     step40          1474     
auxprt         =   0+    lines           2d5c     step50          1487     
base10          2d6e     lldr            1c1c     strngf          2d74     
bcde            243f     lldr00          1c2f     symbuf          2e4f     
bcdx            2754     lldr05          1c5a     symflg          2d4f     
bcdx00          2758     lldr10          1c62     tab            =   9+    
bcpreg          2dfb     load             6ad     tilde          =  7e+    
bcreg           2df3     load00           6be     timer           2d75     
bdos           =   5+    load20           75b     tiret           24c8     
bias            2d5e     load30           763     toret           24c7     
biashi          2d5f     load40           768     totsym           83d     
biaslo          2d5e     load50           7a6     tqret           24c8     
binx            2548     load60           7b0     trmntr          2d77     
binx00          254c     loadb           2d54     true           =ffff+    
bksp            2739     loadn           2d56     tsym             8ee     
bksp00          273f     lopn            1d72     tsym..           919     
bldf            2248     lopn00          1d79+    tsymhi           8ee     
bldf00          2259     lopn10          1d81     tsymlo           8ef     
blkptr          2d52     lprsbf         =2ef8+    ttyi            246f     
bp???            c69     m80            =   0+    ttyo            2482     
bpemsg          2816     m??             282e+    ttyo00          248a     
bphn             b71     m????           282c     ttyq            2458     
bphn10           bbe     maxbp          =  10+    usym             f50     
bphn20           bd2     maxlen          2d7e     usym10           f6a     
bphn30           bf3     maxlin          2d80     usym20           f8d     
bphn35           c00     mbannr           105     usym25           fa1     
bphn50           c1a     mcntu           2886     usym40           fae     
bphn60           c30     mcol            2d89     usymbl           8f0     
bphn90           c4f     mexp            2d73     verf00          1e70     
bpmsg           281d     mfilnf          2844     verf10          1e8b     
bps             2d68     mhex             8f9     verify          1e69     
break           11e3     minvof           946     wflag           2d64     
brk10           11e9     mireg           2894+    window         =2e29+    
brk30           11f9     mldg            283a     wnwsiz          2d97     
brk40           1200     mlodm           2855     wnwtab          2d95     
brk50           1212     mlodpg          285f     writ            1dad     
brk60           1216     mmem??          2878     writ10          1dc5     
brk70           121e     mnvmem           98c     writ20          1dd1+    
brk80           1227     movb            1b37     writ30          1dd7     
brktbl          2d9b     movb00          1b55     writ40          1de9     
bs             =   8+    mreg            111f     writ50          1df2     
bsiz            2d50     mreg00          1136     write           2215     
bsizhi          2d51     mreg05          113e     wrt10           2229     
bsizlo          2d50     mreg10          1147     xreg            1e93     
bwrite          222c     mreg50          1153     xreg00          1e99     
byte10          2666     mrow            2d88     xreg05          1ebc     
byte15          266e     mrowb4          2d87     xreg10          1ed7     
byte30          2678     mrrow           2829     xreg20          1ee4     
bytes            9a4     msntx           2869     xreg30          1ef3     
case            2d84     msym..           8fe     xsym            2430     
cbreak          1246     msymld           964     xsym00          2435     
cbrk10          126b     msymnf           92d     xval            17c0     
cbrk20          1272     mttyi           2476     xval00          17c5     
cbrk30          127b     mttyo           248c+    xval05          17d4     
cflag           2d71     mttyq           245f+    xval10          17f3     
clok             ea5     mxypr0          24ad     xval15          17f9     
clok10           eab     mxypr1          24be     xval20          1802     
closef          220d     mxyprg          249d+    xval25          1811     
cmd             27fb     mxystr          2d8a     xval30          1823     
comask           104     mz8eld           978     xval35          182e     
compact        =ffff+    nchr             7b7     xval40          1857     
cr             =   d+    ncmd           =  1b+    xval50          185c     
cret            2511     newlin          2527     xval55          186b     
crlf            250c     nfcb           =2e4f+    xval60          186f     
ctlc           =   3+    ninbf          =2ea6+    xval61          1886     
ctlx           =  18+    nint             172     xval62          1893     
curs             e7e     nint00           1b6     xval65          189c     
curs00           e86+    nint03           1cf     xval90          18a8     
curs20           e8b+    nint05           1e1     xval95          18b8     
curs30           e95+    nint10           1f0     xycp            2496     
curs40           e97     nint15           204     xyret           24c8     
cuser           1b76     nint20           20e     yfil            1b5c     
cusok           1b91     nint22           21b     yfil00          1b63     
dbyte           263e     nint25           223     yfil10          1b69     
del            =  7f+    nint30           23a     yfil20          1b71     
delim           2d6c     nint35           246     z801            28a9     
depreg          2dfd     nint40           24b     z801l          =   a+    
dereg           2df5     nint45           259     z802            28b3     
din             258a     nint50           260     z802c           28be     
dump             fe8     nint55           266     z802cl         =   6+    
dump00           ff7     nint60           26b     z802l          =  11+    
dump15          1008     nint70           289     z803            28c4     
dump20          1011     nint71           296     z803c           28d5     
dump25          1016     nint75           291     z803cl         =  12+    
dump30          101a     nint80           2a6     z803l          =  1a+    
dump40          102d     nint85           2cd     z803s           28cc     
dump50          103f     nint90           2cf     z803sl         =   9+    
dump55          104c     nint95           2ea     z80ed           28de     
dump60          105a     nlmask          2d83     z80edl         =   6+    
dump70          105d     nmem           =2500+    z80f3           28e4     
dump80          1064     nprint          276c     z80f3l         =  18+    
dwrite          2d71     nprsbf         =2ef9+    z80f4           28a4     
e???             c78     nprt            1155     z80f4l         =   5+    
efilnf          1da4     nrel            2783     z80fd           2899     
em???           2836     nstep           2d65     z80fdl         =   b+    
emem??          1d9c     nsteph          2d66+    z80r            28c4     
endw            2d5c     nstepl          2d65+    z80rl          =  20+    
eof            =  1a+    nsym             8f7     z8e              b10     
eprint          1da7     nsymhi           8f7     z8e00            b2c     
esc            =  1b+    nsymlo           8f8     z8e10            b31     
esntx           1d97     ntpa             9a2     z8e16            b4a     
exam             eb2     nument          2d6b+    z8e20            b57     
exam00           eb9     nzasm          =2ef3+    z8eb             9a0     
exam10           ece     objbuf          2e4f     z8ebh            9a1     
exampt          2d5c     obreak          12a8     z8ecmd           b14     
execbf          2d6b     obrk00          12ae     z8ej            1d00     
fadr            2406     obrk10          12d5     z8eorg           b00     
fadr00          2411     obrk20          12e4     z8esp            b12     
fadr10          2423     op1000          2d1c     zasc10          23f8     
fadr20          2427     opn             2090     zasc20          23fa     
fadr30          242d     opn010          2097     zascii          23eb     
false          =   0+    opn012          209a     zasm            1f02     
fcb            =2e2b+    opn014          20a2     zasm0           1f15     
fcb5c          =  5c+    opn015          20ae     zasm00          1f25     
fcbext         =2e37+    opn020          20b9     zasm05          1f2f     
fcbnam         =2e2c+    opn030          20c1     zasm06          1f39     
fcbtyp         =2e34+    opn035          20d6     zasm08          1f47     
find            1e06     opn040          20df     zasm10          1f4a     
find00          1e11+    opn041          20e6+    zasm15          1f4e     
find40          1e30     opn042          20ec     zasm18          1f56     
find50          1e37     opn043          20f8     zasm20          1f62     
find60          1e51     opn044          2101     zasm25          1f73     
first           2d75+    opn045          2152     zasm30          1f7e     
fndsym          2d7c     opn046          215b     zasm35          1f86     
formf          =   c+    opn048          217b     zasm40          1fa5     
freg            2df1     opn049          218e     zasm42          1fb7     
from            2d5c+    opn050          2198     zasm45          1fbd+    
fstart          2e0b+    opn055          21a1     zasm50          1fc1     
fstr00           899     opn060          21ab     zasm55          1fd9     
fstr10           8a0     opn065          21bb     zasm60          1fea     
fstr20           8b1     opn080          21d7     zasm65          1ff4     
fstrng           897     opn085          21ec     zasm70          200a     
fsym            18c4     opn090          21f3     zasm75          201b     
fsym00          18c7     opn095          21ff     zasm80          201f     
fsym10          18e2     opn100          2263     zasm85          202d     
fsym20          18f0     opn105          2270     zasm90          2032     
fsym30          18fb     opn200          2280     zasm92          2058     
fwndow          2d82     opn205          2291     zasm95          2063     
g001            132e     opn210          2299     zasm97          2074     
g002            1334     opn215          22af     zasm99          2084     
g100            133a     opn220          22bb     zasmbf         =2e73+    
g300            1352     opn300          22c4     zasmct          2d5e     
g400            1367     opn310          22d0     zasmf           2d6a     
g500            136a     opn315          22d1     zasmfl          2d5a     
g505            1384     opn316          22df     zasmio          27c3     
g518            1394     opn320          22f3     zasmkv          2d72     
g520            1397     opn400          22f9     zasmnx          2d5c     
g550            13d7     opn410          2306     zasmpc          2d58     
g555            13f8     opn500          230f     zasmwt          2d60     
g600            1401     opn600          2323     zbuf             9a5     
go              1323     opn605          232e     zbufnm           9a6     
gpbsiz         =  a4+    opn606          2339     zdlm            19a1     
h64180         =   0+    opn610          2355+    zdlm00          19a4     
hazeltine      =   0+    opn620          235d     zfnf             86c     
hex              7ef     opn700          236f     zhex            23b8     
hex00            7f2     opn800          237e     zhex00          23c2     
hex10            7f9     opn810          2389     zhex10          23c6     
hex30            826     opn820          2394     zhex20          23d5     
hexc             7dc     opn830          2399     zjmp            2d72     
hexc00           7e6     opnflg          2d62     zjp            =  c3+    
hlpreg          2dff     opnm            165b     zlen00          19c4     
hlreg           2df7     opnm00          1673     zlen10          19e5     
home            2493     opnm10          167e+    zlen15          19ea     
hsym             eea     opnm20          1683     zlen20          19f2     
hsym10           f01     opnm30          1689     zlen30          1a05     
iarg            25a0     opnm40          1692     zlen40          1a1b     
ibl00           1c16     opnv            19b4     zlen50          1a2b     
iblank          1c14     opnv00          19be     zlen55          1a57     
ibld            1594     oprn            1726     zlen58          1a63     
ibld00          159f     oprn00          1729     zlen60          1a6a     
ibld10          15b2     oprn01          2d5c     zlen65          1a86     
ibld20          15ba     oprn02          2d5f     zlen70          1a8f     
ibld30          15c6     oprn20          1738     zlen80          1aa2     
ibld40          15d6     oprn25          1742     zlen85          1aad     
ibld50          15e2     oprn30          1753     zmem             875     
ibld55          15e7     oprn35          176f     zmflag          2d69     
ibld60          160c     oprn40          1780     zmqf            23e0     
ibld65          1639     oprn50          17a2     zndx            239f     
ibld70          1642     oprn70          17a7     zndx00          23b3     
ibld75          1646     oprn80          17af     znmbuf           9b5     
ibld80          164c     oprn85          17b2     znop           =   0+    
ibld90          1655+    oprtor          19ac     zoff             88b     
iedt            2685     oprx01          2d5d+    zopcnm          2bfc     
iedt00          268b     oprx02          2d60+    zopcpt          28fc     
iedt03          2699     othxsp          2516     zopjtb         =  30+    
iedt05          269f     outadr          2530     zopjtl         =   9+    
iedt10          26bb     outbyt          262e     zopnd1          29fc     
iedt15          26ca     outhex          253a     zopnd2          2afc     
iedt20          26cd     parenf          2d6b     zopnm           2783     
iedt25          26d1     parg            25ab     zopnml         =  18+    
iedt35          26e0     parg00          25e1     zoprjt          27b3     
iedt40          26f6     parg10          25e9     zstx             84d     
iedt50          26fa     parg50          25f2     zsym             2f2     
iedt55          2710     parg60          25ff     zsym00           345     
iedt58          2715     parg65          260e     zsym05           352     
iedt60          2728     parg70          2614     zsym10           364     
iedt70          272d     parg80          2622     zwnw             e40     
iedt90          2732     parg90          2625     zwnw05           e42+    
iedtbc          267e     pass2           2d7a     zwnw10           e48     
ifcb            1bc9     pbin             fcc     zwnw20           e5b     
ifcb00          1bd3     pbin00           fd0     
ifcb02          1be9     pcreg           2e01     
