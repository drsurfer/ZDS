
	.Z80
	ASEG

	TITLE	'XYBASIC	REV 2.14.00	05/27/81'

;VERSION 05/18/81
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
;version EQUates

TRUE	EQU	-1
FALSE	EQU	0
	PAGE	0		;lines per page on PRN listing

;version selection switches
VERSN	EQU	21400		;current version number
CPM	EQU	TRUE		;iff CP/M version
NONST	EQU	FALSE		;iff nonstandard (Custom I/O) version
ISIS2	EQU	FALSE		;iff ISIS-II version

;conditional assembly switches
STRNG	EQU	TRUE		;iff string version
FLOAT	EQU	TRUE		;iff floating point version
ROM	EQU	NONST		;iff ROM version (NONST only)
ROMSQ	EQU	FALSE		;iff ROMSQ version
COMPL	EQU	FALSE		;iff COMPILER version (NONST ROM only)
RTPAK	EQU	FALSE		;iff RUNTIME version (ROMSQ COMPL only)
EDITC	EQU	TRUE		;iff editing commands AUTO, DELETE, EDIT, RENUM
SDISK	EQU	TRUE		;iff sequential disk version (CP/M STRNG only)
F9511	EQU	FALSE		;iff 9511 floating point chip version
FPBCD	EQU	FALSE		;iff BCD floating point, 10 digit mantissa
REALT	EQU	FALSE		;iff SBC 80/20 real time clock
FOR0	EQU	TRUE		;iff e.g. FOR I = 1 TO 0 never entered
ASM80	EQU	FALSE		;iff assembling under ASM80
KEY80	EQU	TRUE		;iff more than 80H keywords
DEBUG	EQU	FALSE		;iff debugging
	;CPM and DEBUG: ^B gets SID, ^X echoes to disk
	;ISIS2 and DEBUG: ^B gets monitor
	;NONST:  DEBUG has no effect
	;PACKI and DEBUG: 8251 initialization skipped

;customized versions
AMD	EQU	FALSE		;iff AMD
BENDX	EQU	FALSE		;iff Bendix (STRNG NONST only)
CAMAC	EQU	FALSE		;iff KineticSystems (STRNG, NONST or CP/M only)
C3908	EQU	FALSE		;iff CAMAC version for 3908, false iff 3909
C3885	EQU	FALSE		;iff CP/M SDISK CAMAC version for 3885
EPSTN	EQU	FALSE		;iff Epstein (NONST only)
GENMC	EQU	FALSE		;iff General Microwave (NONST only)
PACKI	EQU	FALSE		;iff Packard Instruments
WILD	EQU	FALSE		;iff Wild Heerbrugg

;location
	IF	ASM80
	NAME	XYBASIC		;ISIS-II module name for ASM80
	CSEG			;start of relocatable code segment
	ELSE
ROMORG	EQU	00100H		;first ROM location
	IF	ROM
RAMORG	EQU	04000H		;first RAM location
	ENDIF
	ENDIF
	ORG	ROMORG

;global EQUates
MAXNL	EQU	8		;max var name length(>=7 for string conversion)
INTTN	EQU	8		;max # of interrupt table entries (< 32)
INTTL	EQU	INTTN * 8 + 1	;int table length = n 8-byte entries + eof
RANDA	EQU	64B5H		;pseudorandom number generator multiplier
RANDC	EQU	3A73H		;pseudorandom number generator constant
STAKL	EQU	80H		;stack length
STAKM	EQU	25		;max stack use without recursion by GTEXP
VBYTS	DEFL	3		;bytes per ESTACK value entry if integer only
DBYTS	DEFL	10		;bytes needed for string space and file areas
NLMAX	EQU	80		;input buffer length
	IF	STRNG
STMAX	EQU	4		;number of string temporaries
VBYTS	DEFL	4		;bytes per value entry if string
DBYTS	DEFL	DBYTS+100H	;100H bytes for string space
	ENDIF
	IF	FLOAT
	IF	FPBCD		;BCD floating point
VBYTS	DEFL	7		;bytes per value entry
FBYTS	EQU	6		;bytes per FOR-entry value
	ELSE			;binary floating point
VBYTS	DEFL	5		;bytes per value entry if floating
FBYTS	EQU	4		;bytes per FOR-entry value
SINDX	EQU	19		;# significant binary places
	ENDIF
	ELSE			;not floating point version
FBYTS	EQU	2		;bytes per FOR-entry value if integer
	ENDIF

;ASCII character equivalents
CNTLB	EQU	02H
CNTLD	EQU	04H
CNTLE	EQU	05H
CNTLF	EQU	06H
CNTLG	EQU	07H
CNTLH	EQU	08H
LF	EQU	0AH
CNTLK	EQU	0BH
CNTLL	EQU	0CH
CR	EQU	0DH
CNTLN	EQU	0EH
CNTLO	EQU	0FH
CNTLQ	EQU	11H
CNTLR	EQU	12H
CNTLS	EQU	13H
CNTLT	EQU	14H
CNTLX	EQU	18H
CNTLY	EQU	19H
CNTLZ	EQU	1AH
SEMIC	EQU	3BH
	IF	NOT EPSTN
CNTLC	EQU	03H
CNTLP	EQU	10H
CNTLU	EQU	15H
RBOUT	EQU	7FH
	ELSE			;Epstein version control chars
CNTLC	EQU	0AH
CNTLP	EQU	04H
CNTLU	EQU	0BH
RBOUT	EQU	1AH
ESCAP	EQU	1BH
	ENDIF

;information passed to compiler
	IF	COMPL AND NOT RTPAK
	DEFB	REMT		;REM token value
	DEFW	ROMEND+1-ROMORG	;ROM use
	DEFW	RAMEND+1-RAMORG	;RAM use
	ENDIF

START:	JP	INIT	;start initialization dialog
	JP	GTPAR		;to get parameters for CALL

;nonstandard system EQUates
	IF	NONST AND NOT CAMAC
TIMEM	EQU	8C13H		;time counts
TIMEN	EQU	0FE12H
TIMEH	EQU	73H
	IF	NOT WILD
	IF	GENMC
HEADL	EQU	17		;header length
	ELSE
HEADL	EQU	13
	ENDIF
STBYT	EQU	3AH		;start byte
TYBYT	EQU	0		;type byte -- for future use
;jump vector for i/o routines
	JP	CONIN
	JP	CNOUT
	JP	RDRIN
	JP	POUT
	JP	LOUT
	JP	CSTAT
;jmp table for user-defined device drivers
JMPTA:	REPT	24
	JP	0
	ENDM
	IF	COMPL
BOOT:	JP	0		;absolute address, else compilation relocates
	ELSE
BOOT:	JP	DMODC		;^B same as ^C in nonstandard versions
	ENDIF
	ENDIF			;end of NOT WILD conditional
	ENDIF			;end of NONST conditional

;CP/M EQUates
	IF	CPM
CPMBA	EQU	0H		;CP/M base address
IOBYT	EQU	CPMBA+3H	;io byte address
BDOS	EQU	CPMBA+5H	;DOS entry point
FCBAD	EQU	CPMBA+5CH	;default file control block address
FCBFN	EQU	FCBAD + 1	;file name address
FCBFT	EQU	FCBAD + 9	;file type address
FCBCR	EQU	FCBAD + 32	;current record number
DMAAD	EQU	CPMBA+80H	;default DMA address
DKOPF	EQU	15		;disk open function
DKCLF	EQU	16		;close
DKDLF	EQU	19		;delete
DKRDF	EQU	20		;read
DKWTF	EQU	21		;write
DKMKF	EQU	22		;make
DKDMF	EQU	26		;set DMA address function
TIMEM	EQU	8C13H		;TIME counts
TIMEN	EQU	0FE12H
TIMEH	EQU	73H
	IF	AMD		;serial SAVE/LOAD for AMD version
HEADL	EQU	13
STBYT	EQU	3AH		;start byte
TYBYT	EQU	0		;type byte -- for future use
	ENDIF
	IF	SDISK
FILEN	EQU	166		;number of bytes per sequential access file
DBYTS	DEFL	DBYTS+2*FILEN	;number of bytes needed
	ENDIF
	IF	DEBUG
BOOT	EQU	CPMBA+38H	;^B gets SID instead of CP/M
	ELSE
BOOT	EQU	CPMBA		;^B gets CP/M if not debugging
	ENDIF
	ENDIF			;end of CPM conditional

;ISIS-II EQUates
	IF	ISIS2
ISIS	EQU	40H		;ISIS-II entry point
DKOPF	EQU	0		;disk open function
DKCLF	EQU	1		;close
DKRDF	EQU	3		;read
DKWRF	EQU	4		;write
EXITF	EQU	9		;exit to ISIS-II
ERRI2	EQU	12		;error
TIMEM	EQU	947BH		;time counts
TIMEN	EQU	0FE36H
TIMEH	EQU	6BH
;MDS monitor EQUates
CONIN	EQU	0F803H		;console in
CNOUT	EQU	0F809H		;console out
LOUT	EQU	0F80FH		;list out
CSTAT	EQU	0F812H		;console status
MECHK	EQU	0F81BH		;top of free RAM function
IOBYT	EQU	3		;iobyte location
	ENDIF			;end of ISIS2 conditional

;CAMAC RTPAK i/o JMP vector
	IF	CAMAC AND NONST AND TRUE
CONIN:	JP	0
CNOUT:	JP	0
RDRIN:	JP	0
POUT:	JP	0
LOUT:	JP	0
CSTAT:	JP	0
BOOT:	JP	0
	ENDIF

;Wild version EQUates
	IF	WILD
	IF	RTPAK
	JP	WTOKE		;tokenization module entry point
WEOM:	DEFW	6000H		;default end of RAM
BOOT	EQU	0H		;boot after program completion in rtpak
	ENDIF
WMON	EQU	38H		;Wild monitor entry point
WDBL	EQU	80H		;length of central data buffer -- 254 max
WDBUF	EQU	80H		;base address of central data buffer
WEXEC	EQU	40H		;base address of 18-byte EXEC buffer
	ENDIF

;ROMSQ version default value bytes
	IF	ROMSQ AND NOT WILD
DFLTW:	DEFB	0		;default width
DFLTM:	DEFW	1		;default end of memory
DFLTA:	DEFW	0		;default program address
	ENDIF

;CAMAC version boot and conditional interrupt enable on reentry
	IF	CAMAC AND NONST AND (NOT TRUE )
BOOT:	JP	NSDDI		;DI and return to DOS
	IF	NOT RTPAK
	CALL	CNDEI		;conditional EI, then DMODE
	ENDIF
	ENDIF

;Packard Instruments version XYBASIC reentry and interrupt entry point
	IF	PACKI
	JP	DMOD2		;to DMODE
	JP	PAISR		;interrupt service routine entry point
	ENDIF

;real-time clock version clock tick routine entry point
	IF	REALT
	JP	DMOD2		;to DMODE
	JP	CLOCK		;clock routine entry
	ENDIF

;IFTYP is a macro to simplify coding of conditional type branches.
IFTYP	MACRO	FADDR,SADDR
	IF	FLOAT
	JP	NZ,FADDR	;;branch to floating routine
	ENDIF
	IF	STRNG
	JP	C,SADDR		;;branch to string routine
	ENDIF			;;else fall through to integer routine
	ENDM

;PUSH3 (and PUSH4) is a macro to save BC, DE, HL (and PSW) on routine entry.
;The corresponding exit is JMP POP3 (POP4), defined in INOUT.
PUSH3	MACRO
	PUSH	BC
	PUSH	DE
	PUSH	HL
	ENDM
PUSH4	MACRO
	PUSH3
	PUSH	AF
	ENDM

;DZ is a macro to fill blocks of RAM with 0 (used like DS).
DZ	MACRO	N
	REPT	N
	DEFB	0
	ENDM
	ENDM

;RIM and SIM are 8085 opcodes to read and set interrupt mask.
RIM	MACRO
	DEFB	20H
	ENDM
SIM	MACRO
	DEFB	30H
	ENDM

;ERROR is a macro to define error calls.
;TYP may be F, N or C for fatal, nonfatal, or continue scanning.
;M1 and M2 are the error message, M2 being the last byte.
ERROR	MACRO	TYP, M1, M2
	CALL	ERRO&TYP	;;call ERROF, ERRON or ERROC
	DEFB	'&M1', '&M2' OR 80H;;error message
	ENDM


;end of VERSION
	PAGE
;AUX 11/19/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;statement auxilliary routines

;general purpose routines used in statement execution

;LINBC gets current line # in BC.
;Call:	(LNNUM)	current line # address, 0 if direct
;Retn:	A	clobbered
;	BC	if (LNNUM) = 0 then 0 else ((LNNUM))
;	DE	preserved
;	HL	if (LNNUM) = 0 then 0 else (LNNUM) + 1
;	Zero	set iff (LNNUM) = 0
LINBC:	LD	HL,(LNNUM)
LINB1:	LD	A,H
	OR	L
	JP	Z,LINB2		;line # is 0, i.e. direct
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;line # to BC
	RET
LINB2:	LD	B,A
	LD	C,A		;0 to BC
	RET

;IDTST issues a fatal ID error if current statement is direct, i.e. (LNNUM)=0.
;IITST performs EOS test, then issues fatal II error if current is indirect.
	IF	COMPL
IDTST	EQU	LINBC		;just return current line in BC
	ELSE
IDTST:	CALL	LINBC		;zero set iff direct
	RET	NZ
IDERR:	ERROR	F, I, D		;fatal ID error
IITST:	CALL	EOS
	CALL	LINBC		;zero set iff direct
	RET	Z		;ok if direct
	ERROR	F, I, I		;issue fatal II error
	ENDIF			;end of NOT COMPL conditional

;RTEST returns Zero set iff location HL is RAM.
RTEST:	LD	A,(HL)		;fetch byte
	CPL
	LD	(HL),A		;store complement
	CP	(HL)		;compare to stored value
	CPL
	LD	(HL),A		;restore value
	RET

	IF	ROMSQ AND NOT COMPL
;ISSRC returns if SOURC address working space, issues fatal RO error otherwise.
ISSRC:	LD	DE,SRCAD
	LD	HL,(SOURC)
	CALL	CMDHU		;compare SOURC to SRCAD
	RET	Z		;addressing working space, OK
ROERR:	ERROR	F, R, O		;fatal RO error

;ISROM checks if current program is running in ROM, issues nonfatal RO error
;and scans to next command if so.
ISROM:	LD	HL,(SOURC)
	CALL	RTEST		;test if ROM
	RET	Z		;RAM, OK
	ERROR	C, R, O		;nonfatal RO error and scan on

	ENDIF			;end of ROMSQ AND NOT COMPL conditional

;EOS checks for garbage on end of statement, and is called by routines which
;alter normal control flow (GOTO, GOSUB, RETURN, etc.).
;Falls through to syntax error if next nonspace char is not :, ' or <cr>.
;Retn:	A	next nonspace char
;	BC,DE	preserved
;	HL	address of next nonspace char (i.e. of :, ' or <cr>)
EOS:	CALL	DTST0
	RET	NC		;ok if next is delimiter
SNERR:	ERROR	C, S, N		;issue SN error and scan to next
EXERR:	ERROR	F, E, X		;fatal EX error

	IF	COMPL
UFERR:	ERROR	C, U, F		;issue UF error and scan to next
	ENDIF

;DTEST tests whether A contains a delimiter.
;Retn:	Carry	reset iff (A) = :, ' or <cr>
;	Registers	preserved
DTST0:	CALL	GTCHO
DTEST:	CP	':'
	RET	Z
DTST1:	CP	CR
	RET	Z
	IF	RTPAK OR NOT COMPL;comments already purged if compiled
	CP	''''
	RET	Z
	ENDIF
	SCF
	RET

;GTLHS gets a destination variable reference.  It calls GTVAR with
;INLHS true (to indicate tracing may be desired) and stores the
;destination returned in LHSAD for ASSGN to perform assignment.
GTLHS:
	IF	NOT COMPL
	LD	A,255
	LD	(INLHS),A	;set INLHS to true
	ENDIF
	CALL	GTVAR		;perform variable reference
	JP	C,SNERR		;no variable name
	LD	(LHSTY),A	;save type
	LD	(LHSAD),HL	;save destination
	IF	NOT COMPL
	LD	B,A		;save type
	XOR	A
	LD	(INLHS),A	;reset INLHS to false
	LD	A,B		;restore type
	ENDIF
	RET

;ASIGN is CALLed by FOR, NEXT, LET, READ, INPUT to change a variable's value.
;The value addressed by HL is assigned to the destination LHSAD.
;Trace information is printed if (VTRAC) is negative.
ASIGV:	CALL	ESVAL		;value to ESTACK
	LD	HL,(ESTKP)
	INC	HL		;point to value
ASIGN:	LD	A,(LHSTY)	;desired type to A
	CALL	CNVRT		;convert value to desired type
	IF	STRNG
	CP	STRST
	CALL	Z,SCOPV		;copy to string space if type string
	ENDIF
	CALL	BYTSD		;# bytes in value to DE
	INC	HL		;point to value
	LD	B,H
	LD	C,L		;value source to BC
	LD	HL,(LHSAD)	;destination to HL
	IF	COMPL
	JP	MOVED		;value to destination and return if COMPL
	ELSE
	PUSH	AF		;save type
	PUSH	BC		;and save value location
	CALL	MOVED		;value to destination
	POP	HL		;value location to HL
	POP	BC		;value type to B
	;and fall through to TRVAL
;TRVAL prints variable value if tracing is desired.
;Call:	VTRAC	bit 7 set iff tracing desired
;	B	value type
;	HL	value location
TRVAL:	LD	A,(VTRAC)
	OR	A
	RET	P		;done if not tracing
TRVA1:	LD	A,'='		;BTEST entry point
	CALL	WRITC		;write the =
	DEC	HL		;point to type
	LD	A,B		;fetch type
	IF	STRNG
	CP	STRST
	JP	NZ,PRVAL	;print nonstring value
	EX	DE,HL
	LD	HL,STEMP
	INC	(HL)		;increment STEMP count before fetching string
	EX	DE,HL
	ENDIF
	JP	PRVAL		;print the value and return
	ENDIF			;end of NOT COMPL conditional

;ASIGI performs traced integer assignment for NEXT and SCALL value return.
ASIGI:	LD	(HL),B
	DEC	HL
	LD	(HL),C		;value to destination
	IF	NOT COMPL
	PUSH	BC
	LD	B,INTST
	CALL	TRVAL		;print trace info if desired
	POP	BC
	ENDIF
	RET

;BYTSD returns with the number of bytes in an value in DE.
BYTSD:	LD	DE,VBYTS-1
	IF	FLOAT
	CP	SNGST
	RET	Z		;return 4 if floating
	IF	FPBCD
	LD	E,3
	ELSE
	DEC	DE
	ENDIF
	ENDIF
	IF	STRNG
	CP	STRST
	RET	Z		;return 3 if string
	ENDIF
	IF	FLOAT OR STRNG
	DEC	DE
	ENDIF
	RET			;return 2 if integer

;FETCH fetches a value addressed by HL and returns its type in the status bits.
;Call:	HL	pointer to type
;Retn:	A	type token
;	BC	value if integer, Carry reset and Zero set
;	C,DE	length, location if string, Carry set and Zero set
;	FACC	value if floating, Carry reset and Zero reset
;FETBC does a FETCH of arg in BC.
FETBC:	LD	H,B
	LD	L,C
FETCH:	LD	A,(HL)		;fetch the type token
FETC1:
	IF	FLOAT
	CP	SNGST
	JP	Z,FETCF		;fetch floating
	ENDIF
	IF	STRNG
	CP	STRST
	JP	Z,FETCS		;fetch string
	ENDIF
FETCI:	CP	INTST
	JP	NZ,EXERR
	IF	FLOAT
	LD	(ARGAD),HL	;save location for retry of ambiguous op
	ENDIF
MOBCM:	INC	HL		;Zero is set, Carry reset
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;fetch integer to BC
	RET
	IF	STRNG
FETCS:	INC	HL
	LD	C,(HL)		;length to C
	CALL	MODEM		;location to DE
	LD	HL,STEMP
	DEC	(HL)		;decrement # string temps in use
	JP	M,EXERR		;EX error if negative
	XOR	A		;Zero is set
	SCF			;and Carry set also
	RET
	ENDIF
	IF	FLOAT
	IF	F9511		;9511 version fetches to 9511 stack
FETCF:	PUSH	HL
	PUSH	BC
	INC	HL		;point to first value byte
	CALL	LOD95		;load value to 9511 stack
	POP	BC		;restore BC
	POP	HL		;restore HL
	LD	A,SNGST		;floating point token to A
	OR	A		;clear Carry and Zero
	RET			;and return
	ELSE			;NOT F9511
FETCF:	PUSH3			;save registers
	INC	HL		;point to value
	CALL	FLOAD		;load value to FACC
	LD	A,SNGST		;return type in A
	OR	A		;Carry reset, Zero reset
	JP	POP3		;restore registers and return
	ENDIF
	ENDIF

;MVDEM returns (M):(M-1) in DE, (HL)-2 in HL
;BC, PSW preserved
MVDEM:	LD	D,(HL)
	DEC	HL
	LD	E,(HL)
	DEC	HL
	RET

;MVMDE moves (DE) to (M-1):(M-2), returns (HL)-2 in HL
MVMDE:	DEC	HL
	LD	(HL),D
	DEC	HL
	LD	(HL),E
	RET

;MODEM moveds (M+2):(M+1) to DE, returns (HL)+2 in HL.
MODEM:	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	RET

;ISBYT checks whether (B) = 0.  If so, it returns.
;If not, a nonfatal BY error is issued and B is set to 0.
;A clobbered, B forced to 0, other registers preserved.
ISBYT:	LD	A,B
	OR	A		;clear carry, set zero iff (B) = 0
	RET	Z
	LD	B,0		;force (B) to 0
	ERROR	N, B, Y		;nonfatal BYte error
	RET			;and return

;CPLDE replaces (DE) with its two's complement.
;CPLD1 replaces (DE) with its one's complement.
;Retn:	A	clobbered
;	BC,HL	preserved
;	DE	two's complemented
;	Carry	set iff (DE) = 8000H, i.e. overflow
CPLDE:	DEC	DE
CPLD1:	LD	A,E		;entry point to one's complement DE --
	CPL			;   NB carry set if called with 7FFFH
	LD	E,A
	LD	A,D
	CPL
	LD	D,A
	XOR	80H
	OR	E		;zero set iff (DE) = 8000H
	RET	NZ
	CCF			;set carry if overflow
	RET

;ADAHL adds (A) + (HL), leaves result in HL and sets carry on overflow.
ADAHL:	ADD	A,L
	LD	L,A
	RET	NC		;done if no carry
	INC	H		;else inc high order
	RET	Z		;return with carry set iff overflow
	CCF
	RET

;SBAHL subtracts (HL) - (A), leaves result in HL and sets carry on underflow.
SBAHL:	SUB	L		;(A) - (L) to A, carry set iff L > A
	CPL			;L - A - 1
	LD	L,A
	INC	HL		;L - A
	RET	C
	DEC	H
	RET

;CMBDU compares (BC) to (DE) as 16 bit unsigned integers.
;Retn:	A	clobbered
;	BC,DE,HL	unchanged
;	Zero	set iff (BC) = (DE)
;	Carry	set iff (BC) < (DE)
CMBDU:	LD	A,B
	CP	D		;carry set iff (B) < (D)
	RET	NZ		;finished unless (B) = (D)
	LD	A,C		;(B) = (D), so compare (C) to (E)
	CP	E
	RET

;CMDHU same as CMBDU except DE::HL
CMDHU:	LD	A,D
	CP	H
	RET	NZ
	LD	A,E
	CP	L
	RET

;CMBDS compares (BC) to (DE) as 16 bit signed (two's complement) integers.
;Retn:	same as CMBDU above.
CMBDS:	LD	A,B
	XOR	D		;sign set iff signs agree
	JP	P,CMBDU		;unsigned compare works when signs agree
	LD	A,B		;signs disagree, sign of B gives result
	RLA			;NB zero is reset from xra above
	RET

;FLIP is called by READ and INPUT to exchange text pointers in TEXTP and TXTP2.
;Clobbers DE, preserves PSW, leaves TEXTP in HL.
FLIP:	LD	HL,(TXTP2)
	EX	DE,HL		;TXTP2 to DE
	LD	HL,(TEXTP)
	LD	(TXTP2),HL	;TEXTP to TXTP2
	EX	DE,HL
	LD	(TEXTP),HL	;TXTP2 to TEXTP
	RET

;DMODX is a common exit for various versions of LOAD and EXEC.
;First the control and expr stacks are reset.  Then execution continues
;if the command was direct, and XYBASIC returns to DMODE if indirect
;(since the source program has been changed by the EXEC or LOAD).
;Call:	HL	eof address of new program
	IF	NOT COMPL
DMODX:	CALL	NEW1		;reset stacks
	CALL	LINBC		;Zero set iff direct
	RET	Z		;continue normally if direct
	JP	DMOD2		;otherwise to DMODE
	ENDIF

;BDTST is called from FOR and NEXT to test FOR-loop termination.
;Call:	BC or FACC	new FOR-variable value (integer or floating)
;	DE	increment pointer
;	HL	bound pointer
;	LHSTY	FOR-variable type
;Retn:	Carry	Set iff exit condition satisfied, i.e. value>bound and inr>=0
;			or value<bound and inr<0
BDTST:	INC	DE		;point to second incr byte
	IF	FLOAT
	LD	A,(LHSTY)
	CP	SNGST
	JP	NZ,BDTS1	;integer type
	PUSH	DE
	IF	F9511
	CALL	LOD95		;load bound to 9511 stack
	CALL	CMPF0		;perform floating compare, no arg switch
	ELSE
	CALL	CMPFL		;do floating compare
	ENDIF
	POP	DE
	RET	Z		;value=bound, return Carry reset
	IF	F9511 OR FPBCD
	DEC	DE		;first byte has sign of 9511, BCD
	ENDIF
	LD	A,(DE)
	RLCA			;incr sign to Carry
	RET	M		;value<bound, return incr sign as result
	CCF			;value>bound, return complemented incr sign
	RET
	ENDIF
BDTS1:	LD	A,(DE)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;integer bound to DE
	RLCA
	CALL	NC,BCDE		;exchange value and bound if incr>=0
	JP	CMBDS		;and CMBDS returns desired Carry status

;FNDST is called from FOR and READ to scan through a program for
;the matching NEXT or next DATA statement.
;Call:	(textp)	text address at which scanning is to begin
;	B	token to be matched (NEXT or DATA)
;		(1) Found				(2) Notfound
;Retn:	A	token					0
;	B	preserved				preserved
;	C,DE	clobbered				clobbered
;	HL	address of next unparsed text char	eof address
;	Carry	reset					set
;	(textp)	ditto					eof address - 1
FNDS0:	CALL	DTST0		;check if at delimiter
	CCF
	RET	NC		;return carry reset if not
	;else empty DATA, fall through to retry
FNDST:	LD	C,1		;initialize FOR count
	LD	DE,4		;to skip bytes after <cr>
FNDS1:	CALL	GTCHA		;get next char
	CP	B
	JP	Z,FNDS3		;found one
	CP	':'
	JP	Z,FNDS1		;multiple statements -- look at next
	IF	RTPAK OR NOT COMPL;comments purged if compiled
	CP	''''
	CALL	Z,REM		;on-line comment -- scan to <cr>
	ENDIF
	CP	CR
	JP	Z,FNDS2		;cr
	CP	FORT
	CALL	Z,INRC		;increment FOR-count if FOR
	CALL	GTDEL		;scan to delimiter
	JP	FNDS1		;keep trying
INRC:	INC	C
	RET
FNDS2:	LD	A,(HL)		;fetch next line length byte
	OR	A		;check for end of file
	JP	Z,BKUPC		;return carry set if failed
	ADD	HL,DE		;point to next text byte
	LD	(TEXTP),HL	;store new pointer
	JP	FNDS1		;and keep looking
FNDS3:	CP	DATAT
	JP	Z,FNDS0		;done if DATA
FNDS4:	CALL	GTNAM		;look for var name after NEXT
	DEC	C		;decrement count
	JP	NC,FNDS5
	CCF			;clear carry in case found
	RET	Z		;done if NEXT and FOR count is 0
	JP	FNDS1		;and keep looking
FNDS5:	RET	Z		;return if counted to 0
	CALL	GTCOM		;look for comma after <var name>
	JP	C,FNDS1		;none
	JP	FNDS4		;else look for more

;FNDLN finds the line # address of the line which DE points into.
;Used by READ for DATA syntax errors.
;Call:	DE	pointer into text
;Retn:	BC,DE	preserved
;	HL	line # address of desired text line
FNDLN:
	IF	NOT ROMSQ
	LD	HL,SRCAD
	ELSE
	LD	HL,(SOURC)
	ENDIF
FNLN1:	LD	(TEMP),HL	;save length byte address
	LD	A,(HL)		;fetch length
	CALL	ADAHL		;address next line
	CALL	CMDHU		;compare to desired pointer
	JP	NC,FNLN1	;keep looking
	LD	HL,(TEMP)	;restore length byte addr
	INC	HL		;point to line #
	RET

	IF	REALT
;CLOCK is the interrupt service routine to tick the real-time clock.
;The interrupt branches to 10H, POKEd during initialization to come here.
;The four bytes at TIMEX contain 20ths-20, seconds-60, minutes-60 and hours-24.
CLOCK:	PUSH	AF
	PUSH	HL
	LD	HL,TIMEX	;address 20ths counter
	INC	(HL)		;tick it
	JP	NZ,CLOCX	;done
	LD	(HL),255 AND -20;reset to -20
	INC	HL		;address seconds counter
	INC	(HL)		;tick it
	JP	NZ,CLOCX	;done
	LD	(HL),255 AND -60;reset to -60
	INC	HL		;address minutes counter
	INC	(HL)		;tick...
	JP	NZ,CLOCX	;done
	LD	(HL),255 AND -60;reset
	INC	HL		;address hours counter
	INC	(HL)		;tick...
	JP	NZ,CLOCX	;done
	LD	(HL),255 AND -24;welcome to tomorrow
CLOCX:	POP	HL
	LD	A,20H
	OUT	(0D8H),A	;reinitialize the clock
	POP	AF
	EI			;reenable interrupts
	RET
	ENDIF

	IF	EDITC AND (NOT COMPL)
;LNREF changes all occurrences of <line #>s in source text for RENUM.
LNREF:	LD	HL,SRCAD	;begin at the beginning
;process next line of source text
LNRE1:	LD	A,(HL)		;fetch length byte
	OR	A
	RET	Z		;eof, done
	PUSH	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL		;address first text byte
;process next byte of source text
LNRE2:	LD	A,(HL)		;fetch a text byte
	INC	HL
	CP	CR		;check if end of line
	JP	Z,LNRE5		;yes
	CP	''''
	JP	Z,LNRE4		;on-line comment, scan to <cr>
	CP	REMT
	JP	Z,LNRE4		;REM, scan to <cr>
	IF	KEY80
	CP	20H
	JP	C,LNRE3		;reserved word token, check it
	ENDIF
	CP	80H
	JP	C,LNRE2		;not a token, try next
;found a <token>, check if <line #> can and does follow
LNRE3:	CALL	KLTST		;test if token can have <line #> following
	JP	C,LNRE2		;no, try next
	LD	(TXTP2),A	;save token in TXTP2 in case ON list or LIST
	LD	(TEXTP),HL	;set TEXTP to scan possible <line #>
LNR3J:	CALL	GTCHO		;skip spaces, if any
	PUSH	HL		;save HL pointing to first nonspace
	CALL	GTLNO		;look for <line #>
	EX	(SP),HL		;restore HL
	POP	BC		;first nondigit location to BC
	JP	C,LNRE2		;not a <line #>, try next byte
;found a <line #>
	PUSH	HL		;save first for insertion of new line #
	EX	DE,HL
	CALL	CPLDE		;- first
	EX	DE,HL
	ADD	HL,BC		;last + 1 - first = <line #> length to HL
	PUSH	HL		;save length
	CALL	FINDL		;look for <line #>
	JP	C,LNR3C		;not found, flag the line
	PUSH	HL		;save location
	LD	HL,(RNOLD)
	EX	DE,HL
	CALL	FINDL		;find location of first renumbered line
	POP	DE		;location of desired line to DE
	CALL	CMDHU
	JP	C,LNR3D		;before renumbered lines, unchanged
	PUSH	HL		;save first loc
	LD	HL,(RNINC)
	LD	B,H
	LD	C,L		;increment to BC
	LD	HL,(RNNEW)	;first destination line # to HL
	JP	Z,LNR3B		;matched, take first line #
;compute new <line #> corresponding to old <line #>
LNR3A:	EX	(SP),HL		;first line loc to HL
	LD	A,(HL)
	CALL	ADAHL		;address next line
	CALL	CMDHU		;compare to desired line #
	EX	(SP),HL
	ADD	HL,BC		;compute new line #
	JP	NZ,LNR3A	;no match, try next
;convert new <line #> to string and compare to length of old
LNR3B:	POP	DE		;discard saved location
	LD	B,H
	LD	C,L		;new line # to BC
	XOR	A
	CALL	CVTIS		;and converted to string, no leading char
	CALL	BCDE		;location to BC, length to E
	POP	HL		;length of old line # to L
	SUB	L		;new length - old length
	POP	HL		;old line # loc to HL
	JP	M,LNR3E		;old line # longer
	JP	NZ,LNR3F	;old line # shorter
	CALL	MOVD0		;move new line # to replace old
	JP	LNR3H		;and keep scanning
;old <line #> not found, flag bit 7 of line break byte
LNR3C:	POP	HL		;discard saved length
	POP	HL		;and discard saved first loc
	POP	HL		;length byte addr to HL
	PUSH	HL		;and resaved
	INC	HL
	INC	HL
	INC	HL		;address break byte
	LD	(HL),80H	;set bit 7 to indicate line # not found
	JP	LNR3H		;and keep scanning
;old <line #> precedes renumbered lines, leave unchanged
LNR3D:	POP	HL		;discard saved length
	POP	HL		;and discard saved first loc
	JP	LNR3H		;and keep scanning
;old <line #> longer than new <line #>
LNR3E:	PUSH	AF		;save offset
	CALL	MOVD0		;copy new line # to old place
	LD	(TEXTP),HL	;and set new TEXTP
	EX	DE,HL		;new destination to DE
	POP	AF		;restore offset
	POP	HL		;line length pointer to HL
	PUSH	AF
	ADD	A,(HL)		;add offset
	LD	(HL),A		;and store new line length
	POP	AF
	PUSH	HL		;resave line length pointer
	CPL
	INC	A		;complement offset
	EX	DE,HL		;restore destination to HL
	PUSH	HL		;save destination
	CALL	ADAHL		;+offset = source
	PUSH	HL
	EX	DE,HL
	CALL	CPLDE		;-source
	LD	HL,(EOFAD)
	INC	HL
	ADD	HL,DE		;count bytes to move
	EX	DE,HL		;to DE
	POP	BC
	POP	HL
	CALL	MOVED		;block move the remaining text
	DEC	HL
	LD	(EOFAD),HL	;store new eof
	JP	LNR3H		;and keep scanning
;old <line #> shorter than new
LNR3F:	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL		;save all
	EX	DE,HL		;first old line # byte addr to DE
	LD	HL,(EOFAD)
	LD	B,H
	LD	C,L		;end of file to BC
	CALL	ADAHL		;offset + eof = new eof
	LD	(EOFAD),HL	;store new eof
LNR3G:	LD	A,(BC)		;fetch a text byte
	LD	(HL),A		;and store in new location
	DEC	BC
	DEC	HL
	LD	A,E
	CP	C
	JP	NZ,LNR3G
	LD	A,D
	CP	B
	JP	NZ,LNR3G	;copy more text bytes
	POP	HL
	POP	DE
	POP	BC		;restore new line # info
	CALL	MOVD0		;and copy line # into text
	LD	(TEXTP),HL
	POP	AF		;offset
	POP	HL		;line length addr
	ADD	A,(HL)		;old length + offset
	LD	(HL),A		;gives new length
	PUSH	HL
LNR3H:	LD	A,(TXTP2)	;recover token preceding <line #>
	LD	HL,(TEXTP)
	CP	GOTOT
	JP	Z,LNR3I		;GOTO
	CP	GSUBT
	JP	Z,LNR3I		;GOSUB
	CP	LISTT
	JP	NZ,LNRE2	;not GOTO, GOSUB nor LIST, keep scanning
LNR3I:	CALL	GTCOM		;look for comma
	JP	C,LNRE2		;none, keep scanning
	JP	LNR3J		;look for next element in <line #> list
;scan to next <cr>
LNRE4:	LD	A,(HL)
	INC	HL
	CP	CR
	JP	NZ,LNRE4
;end of source text line, try the next
LNRE5:	POP	HL		;length byte addr to HL
	LD	A,(HL)
	CALL	ADAHL		;address next line
	JP	LNRE1		;and try next line

;KLTST tests if token in A may have <line #> following.
;Call:	A	Token
;Retn:	C	Clobbered
;	A,B,DE,HL	Preserved
;	Carry	Set iff not found
KLTST:	PUSH	HL
	LD	C,KLNCT		;table count to C
	LD	HL,KLNTA	;table addr to HL
KLTS1:	CP	(HL)		;compare token to table entry
	JP	Z,KLTS2		;matched
	INC	HL
	DEC	C
	JP	NZ,KLTS1	;try next
	SCF			;not found
KLTS2:	POP	HL		;restore HL
	RET			;and return
	ENDIF			;end of EDITC conditional

	IF	NOT COMPL
;BKNAM constructs a 3-byte symbol table 'name' at BUFAD for a line break.
;Byte 1 is H6-H0, byte 2 is L6-L0, both with bit 7 reset.
;Byte 3 has 1,H7,L7 in bits 7-5 and bits 4-0 reset.
;Call:	HL	desired break entry 'name' (i.e. line # addr)
BKNAM:	EX	DE,HL		;desired line # addr to DE
	LD	HL,BUFAD
	LD	A,D
	AND	7FH
	LD	(HL),A		;byte 1 = D6-D0 to BUFAD
	INC	HL
	LD	A,E
	AND	7FH
	LD	(HL),A		;byte 2 = E6-E0 to BUFAD+1
	INC	HL
	LD	A,D
	RLA			;D7 to Carry
	LD	A,E
	RRA			;D7, E7 to A7, A6
	SCF
	RRA			;1, D7, E7 to A7-5
	AND	0E0H		;mask off A4-0
	LD	(HL),A		;byte 3 to BUFAD+2
	RET
	ENDIF			;end of NOT COMPL conditional

;GTPAR gets a parameter from CALL command line.
;Parameters must be <var ref> or *<array var name>.
;Retn:	A	0 if no more params, 1 if integer, 2 if string, 3 if floating
;	B	bytes per entry
;	C	# dims
;	DE	address of first dimension
;	HL	address of first data item
GTPAR:	CALL	GTCND		;look for comma not followed by delimiter
	LD	A,0
	RET	C		;no more parameters, return 0
	LD	D,MULTT
	CALL	GTD		;look for *
	JP	NC,GTPA1	;array passed
	CALL	GTVAR		;else var ref
	LD	BC,0		;# dims = 0 to C
	PUSH	BC		;push 0 for DE
	JP	NC,GTPA2	;and continue below
MCERR:	ERROR	F, M, C		;fatal MC error
GTPA1:	CALL	FDVAR		;look for var name
	JP	C,MCERR
	LD	A,(DE)		;fetch type
	LD	C,(HL)		;# dims to C
	LD	B,0		;to allow dad
	INC	HL		;point to first dim byte
	PUSH	HL		;and save
	ADD	HL,BC
	ADD	HL,BC		;point to first data byte
GTPA2:	CALL	BYTSD		;bytes per entry to DE
	LD	B,E		;and then to B
	POP	DE		;dim addr to DE
	LD	A,B
	DEC	A		;A gets 1 for int, 2 string, 3 floating
	RET

;DISAB disables all interrupts
	IF	NOT WILD
DISAB:	XOR	A
	LD	(INTTC),A	;reset interrupt table count
	LD	(INTAD),A	;clear interrupt table
	RET

;<byte expr> , <byte expr> [, <byte expr>] [,$]
;IINFO gets interrupt information for ENABLE and WAIT.
;Four bytes corresponding to the first four bytes of an interrupt table
;entry are returned in BCDE (type, port, mask, value).
IINFO:	CALL	GTBEX
	LD	B,C		;port # to  B
	LD	C,0C0H		;type to C
	PUSH	BC		;and saved
	CALL	GTCBE
	LD	D,C		;value to D
	LD	E,0		;mask 0 for now
	CALL	GTCOM
	JP	C,IINF3		;default mask 0, null $
	CALL	GTCHO
	CP	'$'
	JP	Z,IINF1		;default mask 0, $
	CALL	GTBEX
	LD	E,C		;mask to E
	CALL	GTCOM
	JP	C,IINF2		;null $
IINF1:	CALL	GTCHA
	CP	'$'
	JP	NZ,SNERR
	LD	A,D
	CPL
	OR	E
	LD	D,A		;value = NOT value OR mask (if $)
	POP	BC
	LD	C,0E0H		;set type $ bit
	RET
IINF2:	LD	A,D
	OR	E
	LD	D,A		;value = value OR mask (if null $)
IINF3:	POP	BC
	RET
	ENDIF			;end of NOT WILD conditional


;end of AUX
	PAGE
;CPM 5/21/81
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
;CP/M version SAVE and LOAD, including GTFIL

	IF	CPM		;CP/M versions

	IF	RTPAK		;UF error in Runtime Module version
SAVE	EQU	UFERR
LOAD	EQU	UFERR
	ELSE

;SAVE <filename> [,A]
SAVE:	CALL	PRNTM		;print SAVING message
	DEFB	'SAVING', ' ' OR 80H
	CALL	GTFIL		;read filename, initialize file control block
	LD	A,B
	OR	A
	JP	NZ,SNERR	;SN error if ,R specified
	LD	A,C
	IF	AMD
	CP	2
	JP	Z,SAVES		;save via PUN device in AMD version
	ENDIF
	OR	A
	PUSH	AF		;save ,A status
	CALL	CDKMK		;delete old one, make new one
	POP	AF		;restore ,A info
	JP	Z,SAVEA		;ASCII save
	IF	AMD
	JP	M,SAVEA		;HEX save in AMD version
	ENDIF
	CALL	RTDMA		;reset DMA address just in case
	IF	ROMSQ
	CALL	LAST		;last to BC
	PUSH	BC		;save last
	LD	HL,(SOURC)	;first source address to HL
	IF	AMD
	DEC	HL
	ENDIF
	ELSE
	LD	HL,(EOFAD)	;eof address to HL
	PUSH	HL		;save last
	LD	HL,SRCAD	;next source address to HL
	ENDIF
;EOF address is stacked, next address to save is in HL
SAVE1:	LD	B,H
	LD	C,L		;next address to BC
	LD	DE,80H
	ADD	HL,DE		;current + 80H = next to HL
	PUSH	HL		;save next
	LD	HL,DMAAD	;destination = default DMA address
	CALL	MOVED		;move current block to default DMA address
	CALL	CDKWT		;write the block
	POP	HL		;next to HL
	POP	DE		;EOF address to DE
	PUSH	DE		;and saved again
	CALL	CMDHU		;compare
	JP	NC,SAVE1	;eof >= current -- keep going
	POP	DE		;unstack saved EOF address
CDKCL:	LD	C,DKCLF
CDKC1:	CALL	BDOSF		;close it
	CP	255
	RET	NZ		;done if closed successfully
DKERR:	CALL	RTDMA		;reset DMA address after errors
	ERROR	F, D, K		;fatal DK error
RTDMA:	LD	DE,DMAAD	;default DMA address to DE
STDMA:	LD	C,DKDMF		;set DMA address to (DE)
	IF	C3885 AND NOT DEBUG
	JP	BDOS1		;disable interrupts if 3885
	ELSE
	JP	BDOS
	ENDIF
BDOSF:	LD	DE,FCBAD	;fcb address to DE
	IF	C3885 AND NOT DEBUG
BDOS1:	LD	A,(IMODE)	;fetch current interrupt mode status
	OR	A
	JP	NZ,BDOS		;disabled, just do the BDOS call
	DI			;enabled, disable around BDOS call
	CALL	BDOS
	EI
	RET
	ELSE
	JP	BDOS		;just do it
	ENDIF
CDKMK:	LD	C,DKDLF
	CALL	BDOSF		;delete old one
	LD	C,DKMKF
	JP	CDKC1		;make new one
CDKWT:	LD	C,DKWTF
	CALL	BDOSF
	OR	A
	RET	Z
	JP	DKERR
SAVEA:
	IF	AMD
	LD	B,A		;save HEX or ASCII status
	ENDIF
	CALL	SPRST		;reset disk buffer pointer
	LD	A,(OMODE)
	PUSH	AF		;save output mode
	LD	A,80H
	LD	(OMODE),A	;80H to OMODE
	IF	AMD
	LD	A,B
	OR	A
	JP	M,SAVEH		;HEX save
	ENDIF
	IF	ROMSQ
	LD	HL,(SOURC)
	ELSE
	LD	HL,SRCAD
	ENDIF
	LD	BC,-1
	CALL	LIST1		;list the program to disk
SAVA1:	LD	C,CNTLZ
	CALL	DKOUT		;end of file
	CALL	CDKWT		;write the last record
	POP	AF
	LD	(OMODE),A	;restore omode
	JP	CDKCL		;close file and return

	IF	AMD		;HEX or serial SAVE in AMD version

SAVEH:	LD	HL,(SOURC)
	DEC	HL		;first - 1 to HL
	PUSH	HL		;and saved
	EX	DE,HL
	CALL	CPLDE		;complemented
	EX	DE,HL
	LD	(TEMP),HL	;-first+1 saved in TEMP
	CALL	LAST		;last to HL
	EX	(SP),HL		;first -1 to HL
	POP	DE		;last to DE
;convert the file to hex and write it
SAVH1:	PUSH	HL		;save current
	LD	BC,10H		;max record length to BC
	ADD	HL,BC		;current + max to HL
	CALL	CMDHU		;compare eof to current + max
	POP	HL		;restore current
	LD	A,C		;max to A
	JP	NC,SAVH2	;eof >= current + max, write max
	LD	A,E
	SUB	L
	INC	A		;eof+1 - current = remaining to be written
	JP	Z,SAVH4		;current = eof+1, just write eof record
SAVH2:	PUSH	DE		;save eof address
	LD	E,A		;length to  E
	LD	D,0		;checksum to D
	LD	C,':'
	CALL	DWRIT		;write record mark
	LD	A,E
	CALL	WBYTE		;write length
	CALL	WADDR		;write address and record type
SAVH3:	LD	A,(HL)		;fetch data byte
	INC	HL
	CALL	WBYTE		;write data
	DEC	E
	JP	NZ,SAVH3	;write more data
	CALL	WCSUM		;write the checksum
	POP	DE		;restore eof address
	JP	SAVH1		;and do more
;write eof record
SAVH4:	LD	C,':'
	CALL	DWRIT		;write :
	XOR	A
	LD	D,A		;checksum to D
	CALL	WBYTE		;write record length = 0
	LD	HL,(SOURC)
	DEC	HL		;first - 1 to HL
	CALL	WADDR		;write starting address 0 and record type
	CALL	WCSUM		;write the checksum
	JP	SAVA1		;write eof, close and return

;save to serial device (PUNch)
SAVES:	LD	BC,FCBAD+1	;filename source
	LD	HL,HEADR+2	;filename destination
	LD	E,8		;filename length
	CALL	MOVD0		;copy filename to headr
	LD	HL,(SOURC)
	DEC	HL		;first to HL
	PUSH	HL
	PUSH	HL		;and saved
	CALL	LAST		;last to HL
	POP	DE		;first to DE
	CALL	CPLDE		;-first to DE
	INC	DE		;-first + 1
	ADD	HL,DE		;last - first + 1 = length
	PUSH	HL		;and saved
	LD	HL,HEADR
	LD	E,HEADL		;header length to E
SAVS1:	LD	C,(HL)		;header char to C
	CALL	POUT		;and out to punch device
	INC	HL
	DEC	E
	JP	NZ,SAVS1	;keep sending header chars
	POP	DE		;file length to DE
	POP	HL
SAVS2:	INC	DE
	PUSH	DE		;save length+1
	LD	A,D
	OR	A		;zero set iff length < 255
	JP	Z,SAVS3
	LD	E,0
SAVS3:	DEC	E		;length of block to E
	LD	C,STBYT
	CALL	POUT		;send start  byte
	LD	C,TYBYT
	CALL	POUT		;send type byte
	LD	C,E
	CALL	POUT		;send length byte
	LD	A,E
	OR	A		;check if length = 0
	JP	Z,SAVS5		;yes, done
	CALL	CTEST		;check for console break char
	LD	D,0		;checksum in D
SAVS4:	LD	C,(HL)
	CALL	POUT		;send source char
	LD	A,(HL)
	ADD	A,D
	LD	D,A		;update checksum
	INC	HL
	DEC	E
	JP	NZ,SAVS4	;send more source chars
	LD	C,D
	CALL	POUT		;send checksum
SAVS5:	POP	DE		;recover length + 1  to DE
	LD	A,D
	OR	A
	RET	Z		;done if length < 255
	DEC	D		;else new length = length+1-256 = length-255
	JP	SAVS2		;and save more blocks

	ENDIF			;end of AMD conditional

;LOAD <filename> [,A] [,R]
LOAD:
	IF	ROMSQ
	CALL	ISSRC		;must be addressing working space
	ENDIF
	CALL	PRNTM		;print LOADING message
	DEFB	'LOADING', ' ' OR 80H
	IF	AMD
	CALL	GTCOM		;look for comma
	JP	NC,LODS0	;LOAD without filename in AMD version
	ENDIF
	CALL	GTFIL		;read file name, initialize FCB
	IF	AMD
	LD	A,C
	CP	2
	JP	Z,LOADS		;load from RDR device in AMD version
	ENDIF
	PUSH	BC		;save ,A and ,R info
	LD	C,DKOPF
	CALL	BDOSF		;try to open it
	CP	255
	JP	NZ,LOAD0	;successful open
	POP	BC
	LD	C,0		;reset C to indicate ,A
	PUSH	BC		;and save
	CALL	GTFL4		;reset file type to .BAS
	CALL	CDKOP		;and try to open .BAS file
LOAD0:	CALL	NEW		;clobber old program
	POP	BC
	LD	A,C
	OR	A
	JP	Z,LOADA		;ASCII load
	IF	AMD
	JP	M,LOADH		;HEX load
	ENDIF
LOD0B:	PUSH	BC		;save ,R status -- initialization entry point
	LD	HL,(SYMTA)
	LD	DE,-7FH
	ADD	HL,DE		;first bad dma address to HL
	IF	AMD
	LD	DE,SRCAD-1
	ELSE
	LD	DE,SRCAD
	ENDIF
LOAD1:	CALL	CMDHU		;compare to see how much space still available
	JP	NC,LOADX	;program too large -- OM error
	PUSH	HL		;save bad address
	PUSH	DE		;save destination
	CALL	STDMA		;set DMA address
	CALL	CDKRD		;read a record
	POP	HL
	POP	DE		;restore destination to HL, bad addr to DE
	JP	Z,LOAD2		;eof
	LD	BC,80H
	ADD	HL,BC		;find next destination
	EX	DE,HL		;destination to DE, bad addr to HL
	JP	LOAD1
LOADA:	LD	A,(OMODE)
	LD	C,A
	PUSH	BC		;save OMODE and ,R status
	CALL	DLOA1		;read a record, set buffer pointer
	LD	A,7FH
	LD	(OMODE),A	;set OMODE for ASCII load
LODA1:	CALL	GTLIN		;get a line
	CALL	TKIZE		;tokenize it
	JP	C,LODA1		;ignore if no line #
	CALL	NZ,ADDLN	;add to source
	JP	LODA1		;and keep loading

	IF	AMD		;HEX or serial LOAD in AMD version

LOADH:	LD	A,(OMODE)
	LD	C,A
	PUSH	BC
	CALL	DLOA1
	LD	A,7FH
	LD	(OMODE),A
LODH1:	CALL	READC		;read a char from hex file
	SUB	':'
	JP	NZ,LODH1	;not record mark, retry
	LD	D,A		;0 for checksum to D
	CALL	RBYTE		;read a file byte
	JP	Z,LODH3		;eof record
	LD	E,A		;else record length to E
	CALL	RBYTE		;read destination msb
	PUSH	AF		;and save
	CALL	RBYTE		;read destination lsb
	POP	HL		;destination msb to H
	LD	L,A		;destination now in HL
	LD	BC,SRCAD-1	;base address to BC
	ADD	HL,BC		;add to base address for actual destination
	CALL	RBYTE		;skip type byte
LODH2:	CALL	RBYTE		;read a data byte
	LD	(HL),A		;and store
	INC	HL		;address next
	DEC	E
	JP	NZ,LODH2	;load another data byte
	CALL	RBYTE		;read checksum
	JP	NZ,LOADX	;checksum error
	DEC	HL		;point to last loaded byte
	CALL	NEW1		;and reset EOFAD in case end of program
	JP	LODH1		;load next record
LODH3:	CALL	READC		;keep reading chars
	JP	LODH3		;until EOF in readc exits from LOAD

;serial LOAD via RDR device
LOADS:	LD	A,B
	PUSH	AF		;save ,R status
	LD	BC,FCBAD+1
	LD	HL,HEADR+2
	LD	E,8
	CALL	MOVD0		;move filename to header block
	JP	LODS1		;and continue as below
LODS0:	LD	D,'S'
	CALL	GTDSN		;skip S after comma
	CALL	GTCOM		;look for comma before ,R
	LD	A,0
	JP	C,LODSA		;not ,R
	LD	D,'R'
	CALL	GTDSN		;skip R after comma
	LD	A,1
LODSA:	PUSH	AF		;save ,R status
	LD	HL,HEADR+2	;first filename char address to HL
	LD	BC,8		;0 to B, # filename chars to C
	CALL	FILLM		;fill filename with 0s
LODS1:	LD	HL,HEADR
	LD	C,HEADL
	CALL	CTEST		;check for console break char
LODS2:	CALL	RDRIN		;read a char
	CP	(HL)		;compare to header char
	JP	Z,LODS3		;matched, try next
	LD	A,(HL)		;else fetch header char
	OR	A		;check if null, i.e. LOAD ,S typed
	JP	NZ,LODS1	;not null, try again from the top
LODS3:	INC	HL
	DEC	C
	JP	NZ,LODS2	;see if next matches too
	CALL	NEW		;got the file header, prepare to load
	LD	HL,SRCAD-1	;load address to HL
LODS4:	CALL	RDRIN		;read start byte
	CP	STBYT		;check if start byte
	JP	NZ,CSERR	;issue CS error if not
	CALL	CTEST		;check for console break char
	CALL	RDRIN		;read type byte
	CP	TYBYT		;check if type byte
	JP	NZ,CSERR	;issue CS error if not
	CALL	RDRIN		;read length byte
	OR	A
	JP	Z,LODS6		;block length 0, done
	LD	E,A		;block length to E
	INC	A
	PUSH	AF		;save length+1
	LD	D,0		;checksum to D
LODS5:	CALL	RDRIN		;read a char
	LD	(HL),A		;store it
	INC	HL
	ADD	A,D
	LD	D,A		;update checksum
	DEC	E
	JP	NZ,LODS5	;more chars in block
	CALL	RDRIN		;read the checksum
	CP	D
	JP	NZ,CSERR	;checksum error
	POP	AF		;recover block length+1
	JP	Z,LODS4		;length was 255, so load more blocks
	DEC	HL		;point to new eof adress
LODS6:	POP	AF		;recover ,R status
	OR	A
	JP	Z,DMODX		;reset stacks and continue iff direct and no ,R
	CALL	NEW1		;else reset stacks
	JP	LOADR		;and run the program
CSERR:	CALL	NEW		;erase the garbage
	ERROR	F, C, S		;fatal CS error

	ENDIF			;end of AMD conditional

CDKOP:	LD	C,DKOPF
	IF	SDISK
	CALL	BDOSF
	CP	255
	RET	NZ		;successful open
	ERROR	F, F, N		;fatal FN error
	ELSE
	JP	CDKC1		;open file
	ENDIF
CDKRD:	LD	C,DKRDF
	CALL	BDOSF		;read a record
	CP	2
	JP	Z,DKERR		;read error
	CP	1
	RET			;Zero set iff eof
LOADX:	CALL	NEW		;clobber bad fragment
	JP	OMERR		;and issue fatal OM error
LOAD2:	CALL	RTDMA		;reset DMA address to default
	LD	DE,-1
	CALL	FINDL		;find bottom of source text
	LD	A,(HL)
	CALL	ADAHL
	POP	AF		;recover ,R status
	OR	A
	JP	Z,DMODX		;no ,R specified, so reset stacks as usual
	CALL	NEW1		;set new eof, cstack, estack
	;and fall through to LOADR to run
LOADR:	CALL	LOADZ		;reset LNNUM and TEXTP
	JP	RUN		;and RUN the program
LOADZ:	CALL	LNNU0		;reset LNNUM to 0
	LD	HL,NLNAD
	LD	(TEXTP),HL	;reset TEXTP to input buffer
	LD	(HL),CR		;and <cr> to input buffer
	RET

	IF	DEBUG
DSAV0:	LD	A,(AMODE)
	CPL
	LD	(AMODE),A	;toggle saving mode if ^D
	OR	A
	JP	Z,DSAV3
	LD	C,7
	LD	DE,LIBAD
	LD	HL,FCBAD+9
DSAV1:	LD	A,(DE)
	LD	(HL),A		;set filetyp to LIB
	INC	DE
	INC	HL
	DEC	C
	JP	NZ,DSAV1	;store another char
	LD	(FCBCR),A	;set current record to 0
	CALL	CDKMK		;delete old one, make new one
	CALL	SPRST		;reset buffer pointer
DSAV2:	LD	A,CNTLX
	JP	POP3		;and return
DSAV3:	LD	C,CNTLZ
	CALL	DKOUT		;write a control-z as eof
	CALL	CDKWT		;write the last record
	CALL	CDKCL		;and close the file
	JP	DSAV2
LIBAD:	DEFB	'LIB', 0, 0, 0, 0
	ENDIF			;end of ^d conditional

;write char to disk file for ASCII SAVE and PRINT @foo
DKOUT:	LD	HL,(SPTR)	;write one char to buffer
	LD	(HL),C
	INC	HL
	LD	(SPTR),HL	;update pointer
	LD	A,H
	OR	A
	RET	Z		;buffer not full -- done
	CALL	CDKWT		;write a record
SPRST:	LD	HL,80H
	LD	(SPTR),HL	;reset SPTR to base of buffer
	RET

;read char from disk for ASCII LOAD and [L]INPUT @foo
DLOAD:	LD	HL,(SPTR)	;buffer pointer to HL
	LD	A,H
	OR	A
	CALL	NZ,DLOA1	;read another record
	LD	A,(HL)		;fetch next char
	AND	7FH		;remove parity bit
	INC	HL
	LD	(SPTR),HL	;move up pointer
	CP	CNTLZ
	JP	NZ,POP3		;return unless eof
	LD	SP,STACK-4	;OMODE and NEXTS return pushed
	POP	BC		;recover ,R status and OMODE
	LD	A,C
	LD	(OMODE),A	;recover OMODE
	LD	A,B
	OR	A
	JP	Z,DMOD2		;return to direct mode if no ,R
	JP	LOADR		;else RUN the program
DLOA1:	CALL	CDKRD		;read a record
	CALL	SPRST		;reset pointer
	RET	NZ		;return unless eof
	LD	(HL),CNTLZ
	RET

;GTFIL gets <filename> [,A] [,R] and initializes a file control block to
;<filename>.XYB or <filename>.BAS.  The name may consist of a letter followed
;by adjacent printable chars, and is padded by spaces to 8 chars.
;The message addressed by HL is printed (SAVING or LOADING), and
;the filename is echoed.
;Retn:	B	0 if no ,R specified, 1 if ,R
;	C	0 if .BAS (,A), 1 if .XYB (no ,A)
;In AMD version, filetype is .HEX and C is 0FFH if ,H specified.
;In AMD version, C is 2 if ,S specified.
BLKFN:	DEFB	0, '           ', 0, 0, 0, 0, 80H;blank filename
AMBFN:	DEFB	'???????????', 0, 0, 0, 0, 80H;ambiguous filename
XYBFT:	DEFB	'XYB', 80H
BASFT:	DEFB	'BAS', 80H
	IF	AMD
HEXFT:	DEFB	'HEX', 80H
	ENDIF
GTFIL:	CALL	GTFNM		;get unambiguous filename
	LD	DE,FCBAD+1
	LD	C,8
	CALL	PRSTR		;echo it
	CALL	WCRLF		;and write crlf
	CALL	GTCOM		;look for comma
	LD	BC,1		;0 to B, 1 to C
	JP	C,GTFL2		;no comma, filetype is .XYB
	LD	D,'A'
	CALL	GTD		;look for A
	IF	AMD
	JP	NC,GTFL0	;ASCII specified
	LD	D,'H'
	CALL	GTD		;look for H
	LD	C,0FFH		;0FFH to C for HEX
	JP	NC,GTF0A	;HEX specified
	LD	D,'S'
	CALL	GTD		;look for S
	LD	C,2		;2 to C for serial
	JP	NC,GTF0A	;serial specified
	LD	C,1		;1 to C for XYB
	JP	GTFL1		;not A or H, must be R
	ELSE			;not AMD
	JP	C,GTFL1		;no A, must be R after comma
	ENDIF
GTFL0:	LD	C,B		;0 to C to indicate .BAS filetype
GTF0A:	CALL	GTCOM		;look for ,R
	JP	C,GTFL2		;none
GTFL1:	LD	D,'R'
	CALL	GTDSN		;skip ,R
	LD	B,1		;1 to B to indicate ,R
GTFL2:	LD	DE,XYBFT
	LD	A,C
	OR	A
	IF	AMD
	JP	Z,GTFL4
	JP	P,GTFL5
	LD	DE,HEXFT
	JP	GTFL5
	ELSE
	JP	NZ,GTFL5
	ENDIF
GTFL4:	LD	DE,BASFT	;filetype .BAS -- LOAD entry point
GTFL5:	PUSH	BC		;save status
	LD	HL,FCBFT
	CALL	CPYST		;copy filetype to FCB
	DEC	HL
	LD	(HL),0		;reset last char
	POP	BC		;restore status
	RET			;and return

;GTFNM gets an unambiguous filename.
GTFNM:	CALL	GTAFN		;get ambiguous filename
	LD	HL,FCBAD+1	;first char location to HL
	LD	C,11		;char count to C
	LD	A,'?'		;? to A
GTFN0:	CP	(HL)		;check if filename char is ?
	JP	Z,SNERR		;yes, SN error
	INC	HL
	DEC	C
	JP	NZ,GTFN0	;try next char
	RET

;GTAFN gets an ambiguous filename and initializes the default FCB.
;Leading spaces are removed and lower case is converted to UPPER.
GTAFN:	LD	DE,BLKFN
	LD	HL,FCBAD
	PUSH	HL
	CALL	CPYST		;copy blank filename to fcb
	XOR	A
	LD	(FCBCR),A	;reset current record field to 0
	IF	STRNG
	CALL	EVALS		;look for filename
	CALL	FETCH
	JP	NC,SNERR	;nonstring filename
	ELSE			;parse string ad hoc if nonstring version
	LD	D,'"'
	CALL	GTDSN
	LD	D,H
	LD	E,L		;first char address to DE
	LD	C,0		;char count to C
GTA0A:	LD	A,(HL)		;fetch possible filename char
	INC	HL		;point to next
	CP	'"'
	JP	Z,GTA0B		;done if at close quote
	CP	CR
	JP	Z,SNERR		;SN error if cr before close quote
	INC	C		;bump count
	JP	GTA0A		;and try next
GTA0B:	LD	(TEXTP),HL	;update TEXTP
	ENDIF
	POP	HL		;restore fcb address to HL
	LD	A,C
	OR	A
	JP	Z,GTAF5		;null file name, take @:*.*
GTAF0:	LD	A,(DE)
	CP	' '
	JP	NZ,GTAF1	;no more leading spaces
	INC	DE
	DEC	C		;remove a leading space
	JP	Z,GTAF5		;no chars after spaces, take @:*.*
	JP	GTAF0		;and try next
GTAF1:	DEC	C
	JP	Z,GTAF2		;one-char filename, skip : check
	INC	DE
	LD	A,(DE)		;fetch second character
	DEC	DE
	CP	':'
	JP	NZ,GTAF2	;no disk specified
	LD	A,(DE)		;fetch disk name
	SUB	'@'		;subtract ASCII bias
	JP	C,SNERR
	AND	1FH		;convert lower to upper
	CP	5
	JP	NC,SNERR
	LD	(HL),A		;store disk number in fcb
	INC	DE
	INC	DE		;point to char after :
	DEC	C
	DEC	C		;and update char count
GTAF2:	INC	C		;correct char count in C
	JP	Z,GTAF5		;no more chars, take *.*
	INC	HL		;point to first filename char destination
	LD	B,8		;max # filename chars to B
GTAF3:	CALL	FCHAR		;process filename char
	DEC	B
	JP	M,GTAF4		;skip it
	LD	(HL),A
	INC	HL		;store it
GTAF4:	INC	DE
	DEC	C
	RET	Z		;done
	JP	GTAF3		;else process next
GTAF5:	LD	DE,AMBFN
	LD	HL,FCBAD+1
	JP	CPYST		;copy *.* to fcb

FCHAR:	LD	A,(DE)	;fetch the char
	AND	7FH		;remove parity
	CP	'"'+1
	JP	C,SNERR		;space, quote, exclam, controls not allowed
	CP	'*'
	JP	Z,FCHA1		;expand * to ???...
	CP	'.'
	JP	Z,FCHA2		;filetype follows
	CP	60H
	RET	C		;printable char
	SUB	20H		;convert lower to upper
	RET
FCHA1:	DEC	B
	JP	M,FCHA3
	LD	(HL),'?'	;store a ?
	INC	HL
	JP	FCHA1
FCHA2:	LD	B,3		;filetype char count
FCHA3:	POP	HL		;pop FCHAR return
	LD	HL,FCBFT	;filetype address to HL
	JP	GTAF4

	IF	AMD		;routines for HEX LOADing and SAVEing

;INTEL HEX format is a series of records, with all info in ASCII:
;frame 0	record mark ':' [3AH]
;frames 1-2	record length n, hex number 0-FFH [0 for eof;  here max=10H]
;frames 3-6	load address
;frames 7-8	record type [here 0]
;frames 9 - 8+2*n	data
;frames 9+2*n - 10+2*n	checksum  [negated sum mod 256 of preceding items]

;WASCI converts A3-A0 to ASCII and falls through to DWRIT to write
WASCI:	AND	0FH		;00H, ..., 09H, 0AH, ..., 0FH
	ADD	A,90H		;90H, ..., 99H, 9AH, ..., 9FH
	DAA			;90H, ..., 99H, 00H+C,...,05H+C
	ADC	A,40H		;D0H, ..., D9H, 41H, ..., 46H
	DAA			;30H, ..., 39H, 41H, ..., 46H
	LD	C,A		;pass value to write through C
	;and fall through to DWRIT
DWRIT:	PUSH4
	CALL	DKOUT		;write the char
	JP	POP4

;WBYTE writes byte from A as two ASCII bytes, updating checksum in D
WBYTE:	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	WASCI		;convert left nibble to ascii and write
	POP	AF
	PUSH	AF
	CALL	WASCI		;convert right nibble to ascii and write
	POP	AF
	ADD	A,D
	LD	D,A		;update checksum
	RET

;WADDR writes address from HL (subtracting loading bias), and record type.
WADDR:	PUSH	HL
	PUSH	DE
	EX	DE,HL		;address to DE
	LD	HL,(TEMP)	;-first to HL
	ADD	HL,DE		;load address to HL
	POP	DE
	LD	A,H
	CALL	WBYTE		;write high byte
	LD	A,L
	CALL	WBYTE		;write low byte
	XOR	A
	CALL	WBYTE		;write record type = 0
	POP	HL
	RET			;and return

;WCSUM writes the checksum from D, followed by CR and LF.
WCSUM:	XOR	A
	SUB	D
	CALL	WBYTE		;write checksum
	LD	C,CR
	CALL	DWRIT
	LD	C,LF
	JP	DWRIT		;write cr and lf and return

;RBYTE reads two ASCII bytes and builds binary char, updating checksum in D.
;Retn:	A	char read
;	C	clobbered
;	D	updated checksum
;	BEHL	preserved
;	Zero	set iff new checksum = 0
RBYTE:	CALL	READC		;read a byte
	CALL	ISHEX		;convert ASCII to binary
	JP	C,LOADX		;not an ASCII hex digit, abort
	RLCA
	RLCA
	RLCA
	RLCA
	LD	C,A		;high nibble to C
	CALL	READC		;read another
	CALL	ISHEX
	JP	C,LOADX		;not ASCII hex digit
	OR	C		;form complete byte from nibbles
	LD	C,A		;and save
	ADD	A,D		;update checksum
	LD	D,A		;and checksum to D
	LD	A,C		;restore result to A
	RET
	ENDIF			;end of AMD conditional
	ENDIF			;end of NOT RTPAK conditional
	ENDIF			;end of CPM conditional


;end of CPM
	PAGE
;DRIVER 10/22/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;interpreter driver


;The interpreter driver has several entry points.
;DMOD2, after errors, resets SP and falls through to...
;DMODE, after execution, prints OK prompt, then...
;DMOD3 is the driver itself.  Gets a line of user text, tokenizes it and
;either executes it (no line #) or adds it to source text, then gets another.

	IF	COMPL		;return to DMODE boots in COMPL version
DMOD2	EQU	BOOT
DMODC	EQU	BOOT
DMODE	EQU	BOOT
	ELSE
DMOD2:	LD	SP,STACK	;reset SP
DMODE:	CALL	PRTM0		;print OK message
	IF	EPSTN
	DEFB	CR, LF, 13H, 'OK', 12H, CR, LF OR 80H
	ELSE
	DEFB	CR, LF, 'OK', CR, LF OR 80H
	ENDIF
	XOR	A
	LD	(GCHAR),A	;clear GET character
	LD	(TRACL),A	;clear tracing status
	IF	STRNG
	LD	(STEMP),A	;clear # string temps in use
	ENDIF
DMOD3:	CALL	LNNU0		;reset LNNUM to 0 in case ^C typed
	CALL	GTLIN		;get a line from user
	CALL	TKIZE		;tokenize it
	JP	C,XSTA1		;execute it if no line #
	CALL	NZ,ADDLN	;else add to source text unless <cr>
	JP	DMOD3		;and get another line
	ENDIF			;end of COMPL conditional

;NEXTC scans to next command, resets SP and falls through to NEXTS.
NEXTC:	LD	HL,(CSTKP)
	LD	(ESTKP),HL	;reset ESTACK in case error within expr
	CALL	GTDEL		;scan to delimiter
	LD	SP,STACK	;reset SP and fall through to NEXTS

;NEXTS is branched to with TEXTP pointing to a delimiter (: ' <cr>), else it
;issues a SN error.  Performs break char and interrupt tests.
;Returns to DMOD1 if at eof.  Moves TEXTP to first char
;of next statement, updates LNNUM and performs break test.  Then falls through
;to XSTAT for statement execution.
NEXTS:
	IF	CAMAC AND NONST AND (NOT RTPAK)
	IN	A,(1)
	AND	2
	CALL	NZ,CTST0	;read char if present
	ELSE
	CALL	CSTAT		;test console for break char
	RRCA
	CALL	C,CTST0		;read char if present
	ENDIF
	IF	NOT WILD
	LD	A,(INTAD)
	RLCA			;test whether interrupt table empty
	CALL	C,ITEST		;no, check if interrupt occurs
	ENDIF
	LD	HL,(TEXTP)
	LD	(SAVTP),HL	;save textp
	LD	A,(HL)		;inline CALL GTCH1 to get next char
	INC	HL
	CP	' '
	JP	Z,$-4
	LD	(TEXTP),HL
	CP	':'
	JP	Z,XSTAT		;another statement on same line
	IF	RTPAK OR NOT COMPL;comments are removed if compiled
	CP	''''
	CALL	Z,REM		;on-line comment
	ENDIF
	CP	CR
	JP	NZ,SNERR	;syntax error -- garbage after statement
	LD	A,(HL)		;fetch length byte of next line
	OR	A
	JP	Z,DMODE		;end of source text
	INC	HL
	LD	(LNNUM),HL	;save line number address
	INC	HL
	INC	HL
	LD	A,(HL)		;fetch break byte
	INC	HL		;point to first text byte
	LD	(TEXTP),HL	;set text pointer
	IF	NOT COMPL
	RRA			;NB carry was reset above!
	CALL	C,BTEST		;test for break if bit 0 was set

;XSTAT is branched to with TEXTP pointing to first char of a statement.
;Performs trace mode test, then falls through to XSTA1 for
;actual statement execution.
;XSTA1 is entry point from direct mode, to avoid trace checks.
;XSTA2 is entry point for THENpart of an IF statement.
XSTAT:	LD	A,(TRACE)
	LD	(TRACL),A	;set tracing status of current statement
	OR	A
	CALL	NZ,TPRNT	;print trace line # if traceon
	ENDIF			;skip trace tests in COMPL version
XSTA1:	LD	BC,NEXTS
	IF	COMPL
XSTAT	EQU	XSTA1
	ENDIF
	PUSH	BC		;stack normal return address to allow RET
XSTA2:	LD	HL,(TEXTP)	;inline CALL GTCHA follows to get next token
	LD	A,(HL)
	INC	HL
	CP	' '
	JP	Z,$-4
	LD	(TEXTP),HL
	OR	A
	JP	P,LET0		;not token, must be LET or null statement
	IF	WILD
	CP	WBUFT
	JP	Z,WLETB		;BUFFER legal lhs in WILD version
	ENDIF
	SUB	CMDTK		;subtract min token value
	JP	C,SNERR		;too small, not a command token
	CP	NCMDS		;compare to number of commands
	JP	NC,SNERR	;too big
	LD	HL,CMDTA	;command branch table address to HL
	ADD	A,A		; * 2 bytes per entry
	LD	C,A
	LD	B,0
	ADD	HL,BC		;add offset to base address
	LD	A,(HL)		;low order address to A, temporarily
	INC	HL
	LD	H,(HL)		;high order addr to H
	LD	L,A		;low order addr to L
	JP	(HL)		;branch to address

;BTEST checks for line breakpoints.
;Called before XSTAT, so TRACL is not yet reinitialized.
;Call:	A	line break byte, RARed once.
	IF	NOT COMPL
BTEST:	OR	A		;test further if more bits set
	LD	HL,XSTA1	;replace XSTAT return addr with XSTA1 to
	EX	(SP),HL		;	avoid resetting TRACL on return
	JP	Z,TPRNT		;print break line and return if only bit 0 set
	RRCA			;bit 1 of break byte to carry
	JP	NC,BTST2	;no count or variables, check for DMODE break
	PUSH	AF		;save break byte, rotated twice
;Now the symbol table entry containing line break info must be found.
	LD	HL,(LNNUM)
	CALL	BKNAM		;break entry 'name' to BUFAD
	LD	A,BRKST
	CALL	STLK0		;look up break entry
	JP	C,EXERR		;not found -- EX error
;Next the count (# times before next break) is fetched.
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;count to DE
	DEC	DE		;decrement count
	LD	A,D
	OR	E
	JP	NZ,BTST3	;nonzero -- return
;Counted to zero, so reset count to original value and print break info.
	LD	B,H
	LD	C,L
	DEC	BC		;BC points to count
	INC	HL		;HL points to reset
	LD	A,(HL)
	LD	(BC),A
	INC	BC
	INC	HL
	LD	A,(HL)
	LD	(BC),A		;copy reset to count
	CALL	TPRNT		;print break [<line #>]
	POP	AF		;restore break byte
	RRCA			;bit 2 of break byte to Carry
	JP	NC,BTST1	;skip var printing
;The break specified a <var list>, so variable values must be printed.
	PUSH	AF		;save break byte, RRCed 3 times
	INC	HL		;point to var list addr
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A		;varlist address to HL
	LD	(TXTP2),HL
	CALL	FLIP		;scan var list
	LD	HL,TRACE
	LD	A,(HL)
	PUSH	AF		;save TRACE
	LD	(HL),255	;and set TRACE to true
BTST0:	CALL	GTLHS		;get var ref
	LD	B,A		;save type
	CALL	TRVA1		;print = value
	CALL	GTCOM		;look for another
	JP	NC,BTST0	;print more vars
	POP	AF
	LD	(TRACE),A	;restore trace
	CALL	FLIP		;restore textp
	POP	AF
;BTEST returns or breaks to DMODE, depending on whether BREAK specified $.
BTST1:	RLCA
BTST2:	AND	2		;test bit 3 (after two rotates)
	RET	Z		;no $ -- continue
	LD	A,CSLBK		;line break entry token to A
	JP	STOP1		;$
BTST3:	LD	(HL),D
	DEC	HL
	LD	(HL),E		;new value to count
	POP	AF		;restore break byte
	POP	HL		;POP the RETurn to XSTA1
	JP	XSTAT		;and return to XSTAT for TRACL initialization

;BPRNT prints <tab>[<line #>] if not TRACL, and is called by NEXT and TRSET.
;TPRNT prints <tab>[<line #>] and sets TRACL to TRUE.
;Both preserve BC,DE,HL and clobber A.
BPRNT:	LD	A,(TRACL)
	OR	A
	RET	NZ		;suppress break printout if traced
TPRNT:	PUSH3
	CALL	WCRLF		;write crlf
	LD	A,'['
	CALL	WRITC		;write [
	LD	HL,(LNNUM)	;line number address to HL
	CALL	PRNTL		;print the line
	LD	A,']'		;write ]
	CALL	WRITC
	IF	WILD
	CALL	WRTSP		;write a space (no tab routine)
	ELSE
	CALL	PRCO1		;tab to next tab stop
	ENDIF
	LD	A,255
	LD	(TRACL),A	;set TRACL to indicate line traced already
	JP	POP3

	ENDIF			;end of NOT COMPL conditional

;ITEST determines whether interrupt occurs and then returns or interrupts.
;If no interrupt:
;Retn:	A,BC,DE	clobbered
;	HL	address of interrupt table eof
;If interrupt occurs, ITEST's return address is POPed, a normal statement
;return address is PUSHed, and a GOSUB to the appropriate line # is executed.
	IF	NOT WILD
ITEST:	LD	HL,INTAD	;first byte address to HL
ITST1:	RLCA			;test enable/suspend bit
	JP	NC,ITST3	;suspended -- look for more
	LD	C,A		;save $ bit in sign bit of C
	LD	D,H
	LD	E,L		;save first byte address in DE
	INC	HL		;point to port # byte
	LD	A,(HL)
	CALL	RDP1		;read the port
	INC	HL		;point to mask byte
	OR	(HL)
	INC	HL		;point to value byte
	XOR	(HL)		;compare & clear carry
	JP	Z,ITST2
	SCF			;carry set iff compare not zero
ITST2:	RRA			;carry to sign bit of A
	XOR	C		;sign bit set iff no interrupt
	JP	P,ITST4		;interrupt occurs
	EX	DE,HL		;restore first byte address to HL
ITST3:	LD	DE,8
	ADD	HL,DE		;address next entry
	LD	A,(HL)		;first byte of table entry to A
	RLCA			;test on/off bit
	RET	NC		;no more table entries -- return
	JP	ITST1		;and check it
ITST4:	CALL	LINBC		;zero set iff direct mode
	RET	Z		;no interrupts from direct mode
	EX	DE,HL		;restore first byte address to HL
	EX	(SP),HL		;pop ITEST return, push first byte address
	LD	A,CSINT
	CALL	CPUSH		;token, textp, lnnum to control stack
	POP	DE
	CALL	MVMDE
	EX	DE,HL		;  and to HL
	LD	A,(HL)		;fetch first byte
	AND	0BFH		;suspend interrupt entry
	LD	(HL),A
	LD	DE,7
	ADD	HL,DE		;address byte 8 of entry
	CALL	MVDEM
	PUSH	HL		;save entry ptr
	CALL	FINDL		;look for ENABLE line # address
	JP	C,ENERR		;none, EN error
	INC	HL		;point to line # byte
	EX	(SP),HL		;push ENABLE line # address, recover ptr
	CALL	MVDEM		;desired interrupt routine line # to DE
	LD	HL,NEXTS
	EX	(SP),HL		;pop ENABLE line # address, push return addr
	LD	(LNNUM),HL	;set lnnum in case line not found
	JP	GOTO2		;find line #, continue from there
	ENDIF			;end of NOT WILD conditional


;end of DRIVER
	PAGE
;EVAL 06/10/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;expression evaluator

;EVAL evaluates an expression.
;Space above the control stack is used as a working stack, called the
;E(xpression)STACK.  Each expression component already scanned is stored on
;the ESTACK as a byte identifier specifying its type (e.g. delimiter, paren,
;unary op) and precedence.  Fns and ops have an addtional byte containing
;the fn id.  Values are stored as a type byte followed by value bytes.  String
;values saved in the ESTACK are addressed by string temporaries, for access
;during garbage collection.
;Many types of errors may occur during EVAL.
;SN error occurs if an expression is illformed.
;OM error occurs if ESTACK overflows the available space.
;TM error occurs if arguments are of wrong type.
;FC, OV, BY and similar errors can occur during fn/op execution.
;EX errors should never occur, and indicate something is wrong.
;Retn:	Carry	Set iff no <expr> found, i.e. first char parsed is bad
;	A	type token of result, preserved if Carry
;	BC, DE	preserved
;	HL	pointer to type (followed by value bytes), preserved if Carry

EVAL:	PUSH4			;save all in case failure
	LD	C,ISDEL+1	;delimiter type/prec to C

;EVAL0 saves the token in C on the ESTACK.  If it is a fn or op,
;the id in B is also ESTACKed.
EVAL0:	LD	A,C		;fetch type/prec
	CP	ISOP1
	JP	C,EVA0A		;not a fn/op, just ESTACK type/prec
	LD	C,B		;else id to C
	LD	B,A		;save type/prec in B
	CALL	ESPSH		;ESTACK the id
	LD	C,B		;restore type/prec to C
EVA0A:	CALL	ESPSH		;ESTACK the type/prec

;EVAL1 is the 'expecting value' state
;The next item parsed must be a literal, variable reference or 0-ary fn
;(evaluated and ESTACKed, then expecting op), or else a fn name, ( or
;unary op (ESTACKed, then expecting value).  Any other acts as delimiter.
EVAL1:	LD	HL,(TEXTP)
EVA1A:	LD	A,(HL)		;fetch next text char
	INC	HL
	CP	' '
	JP	Z,EVA1A		;try next if space
	CP	40H
	JP	C,EVLIP		;0-3FH, must be literal or (
	OR	A
	JP	P,EVVAR		;40-7FH, must be var ref
	CALL	GTTYP		;type to A, id info to BC
	JP	C,EVALX		;not a fn or op
	LD	(TEXTP),HL	;read the fn or op
	CP	ISOP1
	JP	C,EVFN0		; 0-ary or user-defined function
	JP	Z,EVAL0		;ESTACK unary op
	CP	ISOP2
	JP	Z,EVOPU		;binary op must be unary + or -
EVA1B:	LD	D,'('		;otherwise must be a function id
	CALL	GTDSN		;so skip ( after fn
	JP	EVAL0		;ESTACK type/prec and id and expect value

;EVAL2 pushes a value (type token and value bytes) to ESTACK.
EVAL2:	CALL	ESVAL		;value to ESTACK

;EVAL3 is the 'expecting op' state.
;The next item parsed should be a comma [fn(expr,expr)] or
;binary op [expr op expr] or ) [fn(expr) or fn(expr,expr) or (expr)].
;Any other is treated as a delimiter.
EVAL3:	LD	HL,(ESTKP)
	LD	A,(HL)
	AND	TMASK
	LD	D,A		;previous type to D
	LD	A,(HL)
	AND	PMASK
	INC	A
	LD	E,A		;previous precedence + 1 to E
	LD	BC,VBYTS
	ADD	HL,BC		;address new ESTACK top
	LD	(ESTKP),HL	;and update the pointer
	CALL	GTCHO		;look at next item
	CALL	GTTYP		;find its type
	CALL	C,EVARP		;not an op, must be ) or comma or delimiter
	CP	ISOP2		;check if binary op
	JP	NZ,EVAL4	;no, must be delimiter -- reduce
;Compare precedences of current and previous op and reduce when appropriate.
	LD	A,C		;fetch current type/prec
	AND	PMASK
	CP	E		;compare current to previous+1
	JP	C,EVAL4		;reduce
	CALL	GTCHA		;else read current
	JP	EVAL0		;and stack the info bytes

;At EVAL4 previous .>=. current precedence, so the stacktop is reduced
EVAL4:	LD	HL,(ESTKP)
	LD	BC,-VBYTS+1
	ADD	HL,BC		;address value on ESTACK
	LD	A,D		;fetch previous type
	CP	ISDEL
	JP	Z,EVAL5		;delimiter, done
	CP	ISOP1
	JP	Z,EVOP1		;unary op
	CP	ISOP2
	JP	Z,EVOP2		;binary op
	PUSH	HL		;otherwise current char must be )
	CALL	GTCHA		;so read it
	CP	')'
	JP	NZ,SNERR
	POP	HL		;and restore value pointer
	LD	A,D		;restore previous type
	CP	ISCOM
	JP	Z,EVFN2		;comma -- do a binary function
	CP	ISLP
	JP	Z,EVPAR		;( <expr> ) becomes <expr>
	CP	ISFN1
	JP	Z,EVFN1		;unary function
	CP	ISUFN
	JP	Z,EVUF1		;unary user-defined function
	CP	ISFN2
	JP	Z,SNERR		;binary fn with one arg
	JP	EXERR		;else fatal EX error -- something wrong

;EVAL5 is the exit from a successful EVAL.
EVAL5:	POP	DE		;discard saved PSW value
	POP	DE		;and also saved HL value
	PUSH	HL		;save return value for HL
	LD	A,(HL)		;fetch result type
	DEC	HL		;NB carry is reset from CPI ISDEL
	DEC	HL		;HL points to location before delimiter
EVAL6:	LD	(ESTKP),HL	;reset ESTACK past delimiter
POP3:	POP	HL		;value to HL
	POP	DE
POP1:	POP	BC		;restore registers
	RET			;and done

;EVALX is the abnormal exit from EVAL.  If ESTACK contains only the
;initial delimiter, returns with Carry.  Otherwise issues SN error.
EVALX:	LD	HL,(ESTKP)
	LD	A,(HL)		;fetch top ESTACK item
	CP	ISDEL+1		;compare to delimiter type/prec
	JP	NZ,SNERR	;ESTACK nonempty, SN error
	DEC	HL		;else point past delimiter
	POP	AF		;restore A
	SCF			;set Carry
	JP	EVAL6		;restore and return


;ESVAL pushes a value to the ESTACK.
;Entry:	A	type token
;	BC	value if integer
;	C,DE	value if string
;	(TEMP),BCD	value if floating
ESVAL:	LD	HL,(ESTKP)
	INC	HL
	LD	(HL),A		;store type token
	INC	HL		;point to first value byte
	IF	FLOAT
	CP	SNGST
	JP	NZ,ESVL1	;not floating
	LD	A,(TEMP)	;recover value for A
	IF	F9511
	JP	STO95		;store floating value on ESTACK and return
	ELSE
	JP	FSTOR		;store floating value on ESTACK and return
	ENDIF
	ENDIF
ESVL1:
	IF	STRNG
	CP	STRST
	JP	NZ,ESVL2	;not string
	CALL	ATEMP		;assign ESTACK location to string temp
	LD	(HL),C		;length to ESTACK
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D		;location to ESTACK
	RET
	ENDIF
ESVL2:	CP	INTST
	JP	NZ,EXERR	;not integer
	LD	(HL),C
	INC	HL
	LD	(HL),B		;integer value to ESTACK
	RET

;EVLIP looks for ( and stacks if present, else falls through to...
;EVLIT evaluates a literal, jumps to EVALX if none.
EVLIP:	CP	'('
	JP	NZ,EVLIT	;not (, must be literal
	LD	(TEXTP),HL	;read the (
	LD	C,ISLP+2	;type/prec to C
	JP	EVAL0		;( to ESTACK and expect value next
EVLIT:	CALL	GTLT1		;get literal
	JP	C,EVALX		;exit if not found
	JP	EVAL2		;and ESTACK it

;EVVAR evaluates a variable reference.
EVVAR:	CALL	GTVAR		;perform variable reference
	JP	C,EVALX		;no var
	IF	STRNG
	CP	STRST		;check if type string
	JP	NZ,EVVA0	;nonstring
	EX	DE,HL
	LD	HL,(ESTKP)
	INC	HL
	INC	HL		;point to value destination
	CALL	ATEMP		;assign string temporary
	EX	DE,HL		;restore value location
	LD	A,STRST		;and restore type token
	ENDIF
EVVA0:	LD	B,H		;EVFN0 entry point
	LD	C,L		;source to BC
EVVA1:	LD	HL,(ESTKP)	;EVPAR entry point
	INC	HL
	LD	(HL),A		;ESTACK the type
	INC	HL		;value destination to HL
	LD	E,VBYTS-1	;byte count to E
	CALL	MOVD0		;move value to ESTACK
	JP	EVAL3		;and expect op

;EVOPU deals with unary + and -.
EVOPU:	LD	A,B		;refetch id
	CP	PLUST-UDFNT
	JP	Z,EVAL1		;ignore unary plus
	LD	BC,ISOP1+12	;id=0 to B, type/prec to C for unary minus
	CP	MINT-UDFNT
	JP	Z,EVAL0		;stack unary minus
	CALL	BAKUP		;else unread the binary op
	JP	EVALX		;and exit

;EVPAR reduces (<expr>) to <expr>.
EVPAR:	LD	A,(HL)		;type to A
	PUSH	HL
	DEC	HL		;address (
	DEC	HL		;address previous
	LD	(ESTKP),HL	;reset ESTACK
	POP	BC
	INC	BC		;value location to BC
	JP	EVVA1		;and move down the value

;EVARP deals with ) or comma in expecting op state, loading C with type/prec.
;The previous item must be checked because of cases like DIM A (2,3).
EVARP:	LD	A,D		;fetch previous type
	CP	ISDEL
	JP	Z,EVAR1		;previous was delim, treat current as delim
	LD	A,B		;refetch current
	LD	C,ISRP+2	;right paren type/prec to C
	CP	')'
	RET	Z
	LD	C,ISCOM+3	;comma type/prec to C
	CP	','
	JP	NZ,EVAR1	;treat others as delimiters
	LD	A,ISCOM		;comma type to A
	CP	D		;compare to previous type
	LD	A,ISOP2		;for compare on return
	RET	NZ		;return unless currant and previous both comma
	DEC	E		;to allow successive commas for ternary fns
	RET
EVAR1:	LD	C,ISDEL		;treat any other as delimiter
	RET

;EVFN0 evaluates a 0-ary function and evaluates (if 0-ary)
;or ESTACKs (if N-ary) a user-defined function.
EVFN0:	CP	ISFN0
	LD	A,B		;fn id to A
	JP	Z,EXCUT		;execute 0-ary function
;The current item is a user-defined function call.
	CALL	GTNAM		;get function name
	DEC	HL
	PUSH	HL		;save TEXTP
	LD	A,UFNST
	CALL	STLK0		;look up the fn name
	JP	C,SNERR		;not found
	LD	A,(VARTY)
	LD	C,A		;save desired result type in C
	LD	A,(DE)		;fetch type
	AND	0E0H		;mask off type bytes
	JP	Z,EXUF0		;execute 0-ary user-defined function
	CP	20H
	JP	NZ,FCERF	;not 0-ary or N-ary, must be active already
;N-ary user-definable function information is ESTACKed.
	PUSH	BC		;save desired result type
	PUSH	HL
	LD	B,D
	LD	C,E		;type byte addr to BC
	CALL	EPSH2		;and ESTACKed
	POP	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;bound var addr to BC
	CALL	EPSH2		;and ESTACKed
	POP	BC		;recover desired result type
	CALL	ESPSH		;and ESTACK it
	POP	HL		;pop TEXTP
	LD	C,ISUFN+2	;type token to C
	JP	EVA1B		;skip ( and ESTACK type
EXUF0:	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A		;function body address to HL
	LD	(TEXTP),HL	;reset TEXTP to scan fn body
	LD	HL,(SYMTA)
	PUSH	HL		;save SYMTA
	LD	A,C		;desired result type to A
	JP	EXUFN		;and execute the fn

;EVUFN evaluates a user-defined function.
EVUF1:	LD	B,1		;number of args is in B
EVUFN:	EX	DE,HL		;bound var val addr to DE
	LD	HL,(TEXTP)
	PUSH	HL		;save TEXTP
	LD	HL,(SYMTA)
	PUSH	HL		;and SYMTA
	LD	HL,-7
	ADD	HL,DE
	LD	(ESTKP),HL	;reset ESTACK
	CALL	MODEM		;fetch type byte addr
	PUSH	DE		;and save it
	CALL	MODEM		;bound var addr to DE
	EX	DE,HL
	LD	(TEXTP),HL	;bound var addr to TEXTP
	EX	DE,HL
	INC	HL
	LD	A,(HL)
	PUSH	AF		;save desired result type
	INC	HL
	INC	HL		;point to bound var value
EVUF2:	PUSH	HL		;save value location
	PUSH	BC		;save # args left
	PUSH	HL		;and save value location
	CALL	GTNAM		;scan the bound var
	JP	C,EXERR
	LD	C,A		;name length to C
	CALL	FDVA1		;and build a new symbol table entry for it
	INC	HL		;point to value destination
	EX	(SP),HL		;save destination, bound var value loc to HL
	LD	A,(VARTY)	;bound var type
	CALL	CNVRT		;convert to desired type
	IF	STRNG
	CP	STRST
	CALL	Z,SCOPV		;free temp and copy to string space if string
	ENDIF
	INC	HL		;point to value
	EX	(SP),HL		;destination to HL
	POP	BC		;value loc to BC
	CALL	BYTSD		;byte count to DE
	CALL	MOVED		;copy value to destination
	POP	BC		;arg count to B
	DEC	B		;and decremented
	JP	Z,EVUF3		;no more args
	LD	D,','
	CALL	GTDSN		;skip comma
	POP	HL		;value location to HL
	LD	DE,VBYTS+1
	ADD	HL,DE		;address next value
	JP	EVUF2		;and repeat for next bound var
EVUF3:	POP	HL		;pop saved value location
	CALL	GTREQ		;skip ) = after last bound var
	POP	AF		;restore desired result type
	POP	DE		;type byte location to DE
	;and execute the fn
;EXUFN executes a user-defined function.
;Entry:	A	desired result type
;	DE	symbol table FN entry type byte addr
;	Stacked	SYMTA and TEXTP values
EXUFN:	PUSH	AF
	LD	A,(DE)		;refetch type byte
	OR	80H		;turn on active bit
	LD	(DE),A		;and store
	EX	DE,HL
	LD	DE,STACK+STAKM-STAKL
	CALL	CPLDE
	EX	DE,HL
	ADD	HL,SP		;check for stack overflow
	JP	NC,FCERF	;fatal FC error, recursion too deep
	CALL	EVAL		;evaluate the fn body
	PUSH	AF		;save Carry status
	LD	A,(DE)
	AND	7FH
	LD	(DE),A		;reset active bit
	POP	AF
	EX	DE,HL		;save result location in DE
	POP	HL
	LD	A,H		;desired result type to A
	POP	HL
	LD	(SYMTA),HL	;reset SYMTA
	POP	HL
	LD	(TEXTP),HL	;and reset TEXTP
	JP	C,FCERF		;unsuccessful eval
	EX	DE,HL		;recover result location
	CALL	CNVRT		;convert result to desired type
	INC	HL		;point to value
	JP	EVVA0		;and ESTACK the result

;EVCOM deals with ternary MID$ and INSTR and N-ary user-defined fns.
EVCOM:	POP	BC		;pop the saved arg address
	LD	B,2		;# args seen thus far to B
EVCO1:	INC	HL		;point to arg
	CP	ISUFN+2
	JP	Z,EVUFN		;N-ary user-defined fn
	IF	STRNG
	CP	ISFN2+2
	JP	Z,EVFN3		;binary fn, must be ternary MID$ or INSTR
	ENDIF
	CP	ISCOM+3		;look for another comma
	JP	NZ,SNERR	;not found, something is wrong
	INC	B		;bump arg count
	ADD	HL,DE		;address next token of ESTACK
	LD	A,(HL)		;and fetch it
	JP	EVCO1		;and look for more

;EVFN3 deals with the special cases ternary MID$ and ternary INSTR.
;Branches to routine IINST3 or MID3 with arg pointers to args 1,2,3
;in BC,DE,HL and return address to EVAL2 stacked.
	IF	STRNG
EVFN3:	LD	A,B
	SUB	3
	JP	NZ,SNERR	;number of args must be 3
	PUSH	HL
	DEC	HL
	DEC	HL
	LD	A,(HL)		;fetch fn id
	DEC	HL
	LD	(ESTKP),HL	;reset ESTACK
	LD	DE,VBYTS+1
	LD	HL,EVAL2
	EX	(SP),HL		;push return address, arg1 addr to HL
	PUSH	HL
	ADD	HL,DE		;address arg2
	PUSH	HL
	ADD	HL,DE		;address arg3
	POP	DE
	POP	BC
	CP	INSTT-UDFNT
	JP	Z,INST3		;ternary INSTR
	CP	MIDST-UDFNT
	JP	Z,MID3		;ternary MID$
	JP	SNERR		;else SN error
	ENDIF

;EVOP1 evaluates a unary op.
;EVFN1 evaluates a unary function.
;EVFN2 evaluates a binary function.
EVFN2:	PUSH	HL		;save arg2 address
	LD	DE,-VBYTS-2
	ADD	HL,DE
	LD	A,(HL)		;fetch type/prec byte
	CP	ISFN2+2
	JP	NZ,EVCOM	;must be ternary fn or N-ary user-defined fn
	INC	HL		;point to arg1
	POP	DE		;arg2 address to DE
EVOP1:
EVFN1:	LD	B,H
	LD	C,L		;arg1 address to BC
	DEC	HL		;to type
	DEC	HL		;to id
	LD	A,(HL)		;fn id to A
	JP	EVOPA		;and execute it

;EVOP2 evaluates a binary operator.
EVOP2:	PUSH	HL		;save arg2 address
	DEC	HL
	DEC	HL
	LD	A,(HL)		;op id to A
	LD	DE,-VBYTS
	ADD	HL,DE
	POP	DE		;arg2 addr to DE
	LD	B,H
	LD	C,L		;arg1 addr to BC
EVOPA:	DEC	HL
	LD	(ESTKP),HL	;reset ESTACK
	;and fall through to EXCUT to execute

;EXCUT executes a function or operator.
;Entry:	A	fn/op identifier
;	BC	pointer to arg1 (if any) in expr stack
;	DE	pointer to arg2 (if any) in expr stack
;Exit:	A	result token
;	BC	result if integer
;	C,DE	result if string
;	(FACC)	result if floating
;EXCUT fetches the desired arg types, fn/op address and result type from
;the fn/op type information table.  If the desired arg type is nonzero
;(zero means no arg or arg of ambiguous type), the desired and actual
;arg types are compared and conversion to the desired type performed if
;necessary.  If the desired arg type is integer, the
;pointer in BC or DE is replaced by the actual value of the arg.  If
;the desired arg1 type is floating, the value is loaded to FACC.  Otherwise
;EXCUT branches to the fn/op routine with the pointers in BC and DE intact.
;The result type is returned from the fn/op routine if type AMBST, otherwise
;the specified result type is taken as the actual result type.
EXCUT:	LD	H,0
	LD	L,A		;id * 1
	ADD	HL,HL		;id * 2
	ADD	HL,HL		;id * 4
	CALL	ADAHL		;id * 5
	PUSH	DE
	LD	DE,FUNTA
	ADD	HL,DE		;+ base address = first info addr
	POP	DE
	LD	A,(HL)		;fetch arg2 desired type
	OR	A
	JP	Z,EXCU1		;skip conversion
	PUSH	BC		;save arg1 address
	LD	B,D
	LD	C,E		;arg2 addr to BC
	CALL	CNVTB		;convert arg2 to desire type
	LD	D,B
	LD	E,C		;and return to DE
	POP	BC		;restore arg1
EXCU1:	INC	HL
	LD	A,(HL)		;fetch arg1 desired type
	OR	A
	CALL	NZ,CNVTB	;convert arg1
	INC	HL
	LD	A,(HL)
	INC	HL
	PUSH	HL		;save info pointer
	LD	H,(HL)
	LD	L,A		;fn/op address to HL
	PUSH	HL
	LD	HL,EXRET
	EX	(SP),HL		;return addr to stack, fn/op addr to HL
	JP	(HL)		;execute it
EXRET:	POP	HL		;restore info pointer
	INC	HL
	LD	(TEMP),A	;save returned result type info
	LD	A,(HL)
	IF	F9511
	CP	SNGST		;check if 9511 floating point op
	JP	Z,EXRE1		;yes
	ENDIF
	OR	A
	JP	NZ,EVAL2	;return specified result type
	LD	HL,TEMP
	LD	A,(HL)		;else pass returned result type
	LD	(HL),E		;and save E in TEMP in case floating
	JP	EVAL2		;and ESTACK the result
	IF	F9511
EXRE1:	CALL	FET95		;fetch result from 9511 stack
	LD	(TEMP),A	;save A value
	LD	A,(HL)		;restore floating result type
	JP	EVAL2		;and ESTACK the result
	ENDIF

;CNVRT converts between differing variable types.
;Call:	A	desired type token
;	HL	pointer to value to convert
;Retn:	A,BC,DE,HL	preserved, HL now pointing to converted value.
;A nonfatal TM error occurs if conversion is impossible.
;An EX error should never occur.
;EVALT does an EVALS, then converts result to type LHSTY.
EVALT:	CALL	EVALS
	LD	A,(LHSTY)	;fetch desired type, fall through to...
CNVRT:	CP	(HL)		;compare actual to desired type
	RET	Z		;actual = desired, done
	PUSH	BC
	PUSH	DE
	PUSH	HL		;save registers
	LD	B,A		;save desired type in B
	IF	STRNG
	CP	STRST
	JP	Z,TMERR		;desired=string, actual=numeric
	LD	A,(HL)		;fetch actual
	CP	STRST
	JP	Z,TMERR		;desired=numeric, actual=string
	LD	A,B		;restore desired
	ENDIF
	IF	FLOAT
	CP	INTST
	JP	Z,CNVFI		;convert floating to integer
	CP	SNGST
	JP	NZ,EXERR
;Float an integer value
	LD	A,(HL)		;fetch actual
	CP	INTST
	JP	NZ,EXERR	;must be integer
	LD	(HL),B		;store new type = floating
	INC	HL
	IF	F9511		;load integer value to 9511 stack
	PUSH	HL		;save location
	LD	A,(HL)		;fetch low order byte
	OUT	(D9511),A	;and stack
	INC	HL
	LD	A,(HL)		;fetch high order byte
	OUT	(D9511),A	;and stack
	LD	A,FLT95
	CALL	O9511		;float the integer value
	CALL	FET95		;fetch value from 9511 stack
	POP	HL		;restore value destination
	CALL	STO95		;and store on ESTACK
	JP	CNVRX		;restore registers and return as below
	ELSE
	PUSH	HL
	LD	C,(HL)		;lsbyte of value to C
	INC	HL
	LD	B,(HL)		;msbyte to B
	IF	FPBCD
	CALL	FFLOT		;float the value
	ELSE
	LD	DE,0		;0 to DE
	LD	A,16		;scale factor to A
	CALL	FLOT1		;float the value
	ENDIF
	POP	HL
	CALL	FSTOR		;and store the floated value
	JP	CNVRX		;restore registers and return as below
	ENDIF
;CNVFI fixes a floating value.
CNVFI:	LD	A,(HL)		;fetch actual
	CP	SNGST
	JP	NZ,EXERR	;actual must be floating
	LD	(HL),B		;store new actual type = integer
	INC	HL
	PUSH	HL		;save location
	IF	F9511
	CALL	LOD95		;value to 9511 stack
	CALL	INT95		;fix floating value
	JP	NC,CNVF1	;successful conversion
	ERROR	N, O, V		;else nonfatal OV error
	ELSE
	CALL	FLOAD		;load value to FACC
	CALL	IINT		;convert to integer
	CALL	C,IOVER		;cannot fix, nonfatal OV error
	ENDIF
CNVF1:	POP	HL		;restore value loc
	LD	(HL),C		;store lsbyte
	INC	HL
	LD	(HL),B		;store msbyte
CNVRX:	POP	HL		;restore location
	LD	A,(HL)		;type to A
	POP	DE		;restore DE
	POP	BC		;and BC
	RET
	ENDIF
TMERR:	ERROR	C, T, M		;issue TM error and scan on

;CNVRB is called from EXCUT to perform type conversion on arguments.
;Call:	A	type token
;	BC	arg pointer
;Retn:	A,DE,HL	preserved
;	BC	arg pointer to converted type, or arg value if integer
;	FACC	arg value if floating
CNVBI:	LD	A,INTST		;convert to integer
CNVTB:	PUSH	BC
	EX	(SP),HL		;HL saved, pointer to HL
	CALL	CNVRT		;do the conversion
	CP	INTST
	JP	Z,CNVB1		;integer, fetch it
	IF	FLOAT
	CP	SNGST
	CALL	Z,FETCF		;floating, load the FACC
	ENDIF
	EX	(SP),HL		;pointer saved, HL restored
	POP	BC		;pointer to BC
	RET
CNVB1:	CALL	FETCI		;fetch integer value
	POP	HL		;restore HL
	RET

;GTTYP gets type and precedence info for a fn/op.
;Call:	A	token
;Retn:	A	token type (precedence masked off)
;	B	fn id (offset into function table), ISDEL if Carry
;	C	type/precedence byte
;	DE, HL	preserved
;	Carry	Set iff (A) not fn/op token
GTTYP:	LD	B,A		;char to B
	SUB	UDFNT		;subtract first fn/op token
	RET	C
	CP	NFUNS		;compare to # of fns
	CCF
	RET	C
	LD	B,A		;id to B
	PUSH	HL
	LD	HL,TYPTA
	CALL	ADAHL		;addr type/prec byte
	LD	C,(HL)		;type/prec byte to C
	POP	HL
	LD	A,C
	AND	TMASK		;type to A
	RET

;ESPSH pushes C to ESTACK and checks for OM error.
;Since a value will be ESTACKed next, ESPSH assures that
;at least VBYTS of space remain above the pushed token.
EPSH2:	CALL	ESPSH		;push one byte
	LD	C,B		;and fall through to push another
ESPSH:	LD	HL,(SYMTA)
	LD	DE,-VBYTS-1
	ADD	HL,DE
	EX	DE,HL		;SYMTA - VBYTS - 1 to DE
	LD	HL,(ESTKP)
	INC	HL		;ESTKP + 1 to HL
	CALL	CMDHU
	JP	C,ESERR		;SYMTA <= ESTKP + VBYTS + 1
	LD	(HL),C		;store value
	LD	(ESTKP),HL	;and update pointer
	RET
ESERR:	LD	HL,(EOFAD)
	CALL	CSPST		;reset control stack
	ERROR	C, O, M		;issue OM error and scan to next

;EVALS does an EVAL, issues SN error if no <expr> found.
EVALS:	CALL	EVAL
	RET	NC
	JP	SNERR

;IEVAL does an EVAL, converts result to integer and returns it in BC.
IEVAL:	PUSH	HL
	CALL	EVAL
	JP	C,IEVA1		;no expr
	LD	A,INTST
	CALL	CNVRT		;convert to integer
	CALL	FETCI		;result integer to BC
IEVA1:	POP	HL		;restore HL
	RET

;GTEXP does an IEVAL, issues SN error if no <expr> found.
GTEXP:	CALL	IEVAL
	RET	NC
	JP	SNERR

;GTBEX gets a byte-valued expression.
;GTCBE gets a comma followed by a byte-valued expression, branches to SN error
;if comma is not present.
GTCBE:	CALL	GTCOM
	JP	C,SNERR
GTBEX:	CALL	GTEXP
	JP	ISBYT


;end of EVAL
	PAGE
;FINOUT 10/10/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;floating point input/output routines

	IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)

;CONSTANTS
FPONE:	DEFW	81H, 0		;FLOATING POINT 1.
FPTEN:	DEFB	84H, 20H, 0, 0	;FLOATING POINT 10.
FPRND:	DEFB	6CH, 6H, 37H, 0BCH;FLOATING POINT ROUNDER .000 000 5


;FLOATING POINT INPUT
FINP:	LD	E,(HL)		;1ST CHARACTER OF STRING
	CALL	SVAD		;SET CHARACTER ADDR,PNT FLG,EXP
	INC	HL		;TO ADDR THE VALUE SIGN
	LD	(HL),80H	;SET VALUE SIGN POSITIVE
	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	LD	(HL),D		;SET ACC TO ZERO
	LD	A,(TEMP)	;FETCH DESIRED VALUE SIGN
	OR	A
	LD	A,E		;1ST CHARACTER
	JP	Z,INP2		;IF POSITIVE DESIRED
	LD	HL,TMP3		;TO ADDR THE VALUE SIGN
	LD	(HL),D		;SET VALUE SIGN NEGATIVE
;ANALYZE THE NEXT CHARACTER IN THE STRING
INP2:	LD	B,0		;DIGIT 2ND WORD OR DECIMAL EXPONENT
	CP	'.'		;COMPARE TO DECIMAL POINT
	JP	Z,INP3		;IF DECIMAL POINT
	CP	'E'		;COMPARE TO EXPONENTIATION SIGN
	JP	Z,INP4		;IF EXPONENTIATION
	CP	'E'+20H
	JP	Z,INP4		;allow lower case e in case untokenized
	SUB	'0'		;SUBTRACT ASCII BIAS
	CP	0AH		;SET CARRY IF CHARACTER IS VALID DIGIT
	JP	NC,INP8		;IF CHARACTER IS NOT A VALID DIGIT
	LD	(TMP4),A	;SAVE THE CURRENT DIGIT
	LD	HL,FPTEN	;TO ADDR FLOATING POINT 10
	CALL	FMUL		;MULTIPLY BY TEN
	LD	HL,VALE		;TO ADDR THE VALUE
	CALL	FSTOR		;STORE OLD VALUE TIMES 10
	INC	HL		;TO ADDR THE CURRENT DIGIT
	LD	A,(HL)		;CURRENT DIGIT
	LD	B,0		;CLEAR 2ND WORD OF DIGIT
	LD	C,B		;CLEAR 3RD WORD OF DIGIT
	LD	D,B		;CLEAR 4TH WORD OF DIGIT
	LD	E,08		;INDICATE DIGIT IS IN REGISTER A
	CALL	FFLOT		;CONVERT DIGIT TO FLOATING POINT
	LD	HL,VALE		;TO ADDR THE VALUE
	CALL	FADD		;ADD OLD VALUE TIMES 10
	LD	HL,TMP2		;TO ADDR THE DECIMAL POINT FLAG
	LD	A,(HL)		;DECIMAL POINT FLAG
	AND	A		;SET CONTROL BITS
	JP	Z,INP1		;IF NO DECIMAL POINT ENCOUNTERED
	DEC	HL		;TO ADDR THE INPUT EXPONENT
	DEC	(HL)		;DECREMENT THE INPUT EXPONENT
INP1:	CALL	CHAD		;GET ADDR OF NEXT CHARACTER
	LD	A,(HL)		;NEXT CHAR
	JP	INP2		;TO PROCESS NEXT CHARACTER
INP3:	LD	HL,TMP2		;TO ADDR THE DECIMAL POINT FLAG
	XOR	(HL)		;ZERO IF FLAG SET
	LD	(HL),A		;SET DECIMAL POINT FLAG
	JP	NZ,INP1		;IF FLAG NOT ALREADY SET
	LD	HL,(ADRL)	;READDRESS THE INPUT STRING
	JP	INP8		;IF 2ND DECIMAL POINT

;PROCESS DECIMAL EXPONENT
INP4:	CALL	CHAD		;GET ADDR OF NEXT CHARACTER
	LD	A,(HL)		;NEXT CHARACTER OF STRING
	LD	E,0		;possible exponent sign (-) to E
	CP	MINT		;COMPARE TO MINUS CHARACTER
	JP	Z,INP5		;IF MINUS SIGN
	CP	'-'
	JP	Z,INP5		;allow untokenized minus
	LD	E,A		;else sign positive (nonzero) to E
	CP	PLUST		;COMPARE TO PLUS CHARACTER
	JP	Z,INP5		;plus
	CP	'+'		;check for untoenized plus
	JP	NZ,INP6		;IF NOT PLUS SIGN
INP5:	INC	HL		;TO ADDR THE NEXT CHARACTER
	LD	A,(HL)		;NEXT CHARACTER OF STRING
INP6:	SUB	'0'		;SUBTRACT ASCII BIAS
	JP	Z,INP5		;IGNORE LEADING ZERO ON EXPONENT
	LD	B,0		;POSSIBLE DECIMAL EXPONENT
	CP	0AH		;SET CARRY IF A DECIMAL DIGIT
	JP	NC,INP8		;IF NOT A DECIMAL DIGIT
	LD	B,A		;DECIMAL EXPONENT EQUAL DIGIT
	INC	HL		;TO ADDR THE NEXT CHARACTER
	LD	A,(HL)		;NEXT CHARACTER OF STRING
	SUB	'0'		;SUBTRACT ASCII BIAS
	CP	0AH		;SET CARRY IF A DECIMAL DIGIT
	JP	NC,INP7		;IF NOT A DECIMAL DIGIT
	INC	HL		;ADDRESS NEXT CHAR
	LD	C,A		;LSD OF DECIMAL EXPONENT
	LD	A,(HL)		;FETCH NEXT
	SUB	'0'		;SUBTRACT ASCII BIAS
	CP	0AH
	JP	C,INPOV		;THREE DIGITS, SCAN REMAINING AND RETURN 0 OR OV
	LD	A,B		;MSD OF DECIMAL EXPONENT
;FORM COMPLETE DECIMAL EXPONENT
	ADD	A,A		;2*MSD
	ADD	A,A		;4*MSD
	ADD	A,B		;5*MSD
	ADD	A,A		;10*MSD
	ADD	A,C		;10*MSD + LSD
	LD	B,A		;DECIMAL EXPONENT
INP7:	LD	A,E		;SIGN OF DECIMAL EXPONENT
	AND	A		;SET CONTROL BITS
	JP	NZ,INP8		;IF SIGN POSITIVE
	SUB	B		;COMPLEMENT DECIMAL EXPONENT
	LD	B,A		;DECIMAL EXPONENT
INP8:	LD	(TEXTP),HL
	LD	HL,TMP3		;TO ADDR THE INPUT SIGN
	LD	C,(HL)		;INPUT SIGN
	LD	HL,ACCS		;TO ADDR THE ACC SIGN
	LD	(HL),C		;ACC SIGN
	LD	A,B		;DECIMAL EXPONENT

;CONVERT DECIMAL EXPONENT TO BINARY
INP9:	LD	HL,TMP1		;TO ADDR THE DECIMAL EXPONENT
	ADD	A,(HL)		;ADJUST DECIMAL EXPONENT
	JP	Z,FTEST		;IF DECIMAL EXPONENT IS ZERO
	LD	(HL),A		;CURRENT DECIMAL EXPONENT
	LD	HL,FPTEN	;TO ADDR FLOATING POINT 10
	JP	P,INP10		;IF MULTIPLY REQUIRED
	CALL	FDIV		;DIVIDE BY 10
	LD	A,1		;TO INCREMENT THE DECIMAL EXPONENT
	JP	INP9		;TO TEST FOR COMPLETION
INP10:	CALL	FMUL		;MULTIPLY BY 10
	LD	A,-1		;TO DECREMENT THE DECIMAL EXPONENT
	JP	NC,INP9		;TO TEST FOR COMPLETION
	JP	FOVER		;OV ERROR ON OVERFLOW AND RETURN FPMAX
INPOV:	INC	HL
	LD	A,(HL)
	SUB	'0'
	CP	0AH
	JP	C,INPOV		;SCAN REMAINING EXPONENT DIGITS
	LD	(TEXTP),HL	;RESET TEXTP TO FIRST NONDIGIT
	LD	A,E		;SIGN OF DECIMAL EXPONENT
	OR	A
	JP	Z,FZRO		;LARGE NEGATIVE EXPONENT, RETURN 0.
	JP	FOVER		;POSITIVE, ISSUE FLOATING OVERFLOW ERROR


;FLOATING POINT OUTPUT
;The contents of the FACC is not preserved
FOUT:	LD	HL,BUFAD-1	;USE BUFAD TO STORE CONVERTED VALUE
	CALL	SVAD		;SET CHARACTER ADDRESS, DIGIT COUNT, DECIMAL EXPONENT
	CALL	FTEST		;LOAD ACC TO REGISTERS
	LD	HL,VALE		;TO ADDR THE ACC SAVE AREA
	CALL	FSTOR		;REGISTER STORE

;OUTPUT SIGN CHARACTER
	CALL	CHAD		;GET ADDR OF CHARACTER
	LD	(HL),' '	;STORE SPACE CHARACTER
	AND	A		;SET CONTROL BITS
	JP	Z,OUT3		;IF ACC IS ZERO
	LD	E,A		;ACC EXPONENT
	LD	A,B		;ACC SIGN AND 1ST FRACTION
	AND	A		;SET CONTROL BITS
	LD	A,E		;ACC EXPONENT
	JP	P,OUT0		;IF ACC IS POSITIVE
	LD	(HL),'-'	;CHANGE SIGN TO MINUS
;CHECK IF ACCUMULATOR IN RANGE .01 TO 1 TO ALLOW .01
OUT0:	CP	7AH		;COMPARE TO .01 EXPONENT
	JP	C,OUT1		;TOO SMALL, SCALE NORMALLY
	CP	81H
	JP	C,OUT5		;SKIP SCALING IF BETWEEN .01 AND 1
;SCALE ACCUMULATOR TO 0.1 TO 1.0 RANGE
OUT1:	CP	7EH		;COMPARE TO SMALL EXPONENT
OUT2:	LD	HL,FPTEN	;TO ADDR FLOATING POINT 10
	JP	C,OUT4		;IF EXPONENT TOO SMALL
	CP	81H		;COMPARE TO LARGE EXPONENT
	JP	C,OUT5		;IF EXPONENT NOT TOO LARGE
	CALL	FDIV		;DIVIDE BY 10
OUT3:	LD	HL,TMP2		;TO ADDR THE DECIMAL EXPONENT
	INC	(HL)		;INCREMENT DECIMAL EXPONENT
	JP	OUT2		;TO TEST FOR SCALING COMPLETE
OUT4:	CALL	FMUL		;MULTIPLY BY 10
	LD	HL,TMP2		;TO ADDR THE DECIMAL EXPONENT
	DEC	(HL)		;DECREMENT DECIMAL EXPONENT
	JP	OUT1		;TO TEST FOR SCALING COMPLETE

;ROUND THE VALUE BY ADDING 0.000 000 5
OUT5:	CALL	FABS		;MAKE ACC POSITIVE
	LD	HL,FPRND	;TO ADDR THE ROUNDER
	CALL	FADD		;ADD THE ROUNDER
	CP	81H		;CHECK FOR OVERFLOW
	JP	NC,OUT2		;IF EXPONENT TOO LARGE

;SET DIGIT COUNTS
	LD	HL,TMP2		;TO ADDR THE DECIMAL EXPONENT
	LD	A,(HL)		;DECIMAL EXPONENT
	LD	E,A		;DIGITS BEFORE DECIMAL EXPONENT
	CP	7		;COMPARE TO LARGE EXPONENT
	JP	C,OUT6		;IF EXPONENT IN RANGE
	LD	E,1		;DIGITS BEFORE DECIMAL EXPONENT
OUT6:	SUB	E		;ADJUST DECIMAL EXPONENT
	LD	(HL),A		;DECIMAL EXPONENT
	LD	A,6		;TOTAL NUMBER OF DIGITS
	SUB	E		;DIGITS AFTER DECIMAL POINT
	INC	HL		;TO ADDR THE 2ND DIGIT COUNT
	LD	(HL),A		;DIGITS AFTER DECIMAL POINT
	DEC	E		;DECREMENT THE DIGIT COUNT
	LD	A,E		;DIGITS BEFORE THE DECIMAL POINT

;OUTPUT SIGNIFICANT DIGITS
OUT7:	LD	HL,TMP1		;TO ADDR THE DIGIT COUNT
	ADD	A,(HL)		;ADJUST THE DIGIT COUNT
	LD	(HL),A		;NEW DIGIT COUNT
	JP	M,OUT8		;IF COUNT RUN OUT
	LD	HL,FPTEN	;TO ADDR FLOATING POINT 10
	CALL	FMUL		;MULTIPLY BY 10
	LD	E,8		;TO PLACE DIGIT IN REGISTER 'A'
	CALL	FFIX		;CONVERT TO FIXED FORMAT
	CALL	CHAD		;GET CHARACTER ADDRESS
	ADD	A,'0'		;ADD ASCII BIAS
	LD	(HL),A		;OUTPUT DECIMAL DIGIT
	XOR	A		;CLEAR CURRENT DIGIT
	LD	E,8		;BINARY SCALING FACTOR
	CALL	FFLOT		;RESTORE VALUE MINUS DIGIT
	LD	A,-1		;TO ADJUST THE DIGIT COUNT
	JP	OUT7		;LOOP FOR NEXT DIGIT
OUT8:	LD	HL,TMP3		;TO ADDR 2ND DIGIT COUNT
	LD	A,(HL)		;DIGITS AFTER DECIMAL POINT
	LD	(HL),-1		;SET 2ND COUNT NEGATIVE
	AND	A		;SET CONTROL BITS
	JP	M,OUT9		;IF 2ND COUNT RAN OUT
	CALL	CHAD		;CHARACTER ADDRESS ROUTINE
	LD	(HL),'.'	;STORE DECIMAL POINT
	JP	OUT7		;LOOP FOR NEXT DIGIT
OUT9:	LD	HL,(ADRL)	;ADDR THE LAST DIGIT STORED
OUT9A:	LD	A,(HL)		;FETCH IT
	DEC	HL
	CP	'0'
	JP	Z,OUT9A		;SUPPRESS TRAILING ZEROS
	CP	'.'
	JP	Z,OUT9B		;SUPPRESS TRAILING DECIMAL POINT
	INC	HL		;READDRESS LAST DIGIT
OUT9B:	LD	(ADRL),HL	;STORE FUDGED POINTER
	LD	HL,TMP2		;ADDR THE DECIMAL EXPONENT
	LD	A,(HL)
	OR	A
	JP	Z,OUT13		;IF DECIMAL EXPONENT IS ZERO

;OUTPUT DECIMAL EXPONENT
	LD	B,'+'		;PLUS SIGN
	JP	P,OUT10		;IF EXPONENT IS POSITIVE
	LD	B,'-'		;MINUS SIGN
	LD	C,A		;NEGATIVE EXPONENT
	XOR	A		;ZERO
	SUB	C		;COMPLEMENT THE EXPONENT
OUT10:	LD	C,'0'-1		;EMBRYO ASCII TENS DIGIT
OUT11:	INC	C		;INCREMENT TENS DIGIT
	SUB	0AH		;REDUCE REMAINDER
	JP	NC,OUT11	;IF MORE TENS
	ADD	A,3AH		;RESTORE AND ADD ASCII BIAS
	LD	D,A		;UNITS DIGIT
	LD	A,'E'		;EXPONENT SIGN
	CALL	CHAD		;GET CHARACTER ADDRESS
	CALL	FSTOR		;STORE LAST 4 CHARACTERS
OUT12:	INC	HL		;LAST ADDR + 1
	LD	A,L		;LAST + 1 TO A
	PUSH	AF		;SAVE LAST+1
	LD	HL,VALE		;TO ADDR THE ACC SAVE AREA
	CALL	FLOAD		;RESTORE ACC
	POP	AF		;RESTORE LAST+1
	LD	DE,BUFAD	;FIRST TO DE
	SUB	E		;LAST+1 - FIRST = LENGTH TO A
	LD	C,A		;AND TO C
	RET

;EXPONENT IS ZERO, DONE
OUT13:	LD	HL,(ADRL)	;ADDRESS OF LAST CHAR TO HL
	JP	OUT12		;AND CONTINUE AS ABOVE

;SAVE THE CHARACTER STRING ADDRESS
SVAD:	LD	A,L		;CHARACTER STRING WORD
	LD	B,H		;CHARACTER STRING BANK
	LD	C,0		;INPUT EXPONENT OR DIGIT COUNT
	LD	D,C		;DECIMAL POINT FLAG OR DECIMAL EXPONENT
	LD	HL,ADRL		;TO ADDR THE CHARACTER STRING ADDRESS
	JP	FSTOR		;STORE A, B, C, AND D AND RETURN THRU STR

;OBTAIN THE ADDRESS OF THE NEXT CHARACTER
CHAD:	LD	HL,(ADRL)	;TO ADDR THE CHARACTER STRING ADDRESS
	INC	HL		;BUMP IT
	LD	(ADRL),HL	;RESTORE IT
	RET			;RETURN TO CALLER

	ENDIF			;end of FLOAT conditional

;end of FINOUT
	PAGE
;FMATH 06/09/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;floating point math package


	IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)

;The floating point (FP) math package operates on normalized floating
;binary point numbers stored in four consecutive bytes of memory.
;Byte 1			Binary exponent E
;Byte 2 bit 7		Sign S
;Byte 2 bits 6-0	Mantissa msb M1
;Byte 3			Mantissa 2sb M2
;Byte 4			Mantissa lsb M3
;If E is 0, the value is 0 and bytes 2-4 are meaningless;  otherwise
;E represents the binary exponent with a bias of 80H.
;The sign bit S is 0 for positive, 1 for negative.
;The complete mantissa is M1-M3 with a hidden 1 replacing S in M1 bit 7
;and the binary point located left of M1.  Thus a nonzero value is
; S * [2^(E-80H)] * [(80H+M1) * (2^-8)] * [M2 * (2^-16)] * [M3 * (2^-24)].

;The floating point accumulator (FACC) contains a floating point value
;unpacked into five consecutive bytes of RAM starting at ACCE.
;Byte 1 (ACCE)		Exponent E, biased as above
;Byte 2 (ACCS)		Sign, 0 if negative and 80H if positive
;Bytes 3-5 (ACC1-ACC3)	Mantissa with hidden 1 restored in ACC1

;FLOATING POINT STORE
FSTR0:	LD	(HL),E		;STORE ZEROETH WORD
	INC	HL		;TO ADDR THE 1ST WORD
FSTOR:	LD	(HL),A		;STORE 1ST WORD
FSTR1:	INC	HL		;TO ADDR THE 2ND WORD
	LD	(HL),B		;STORE 2ND WORD
	INC	HL		;TO ADDR THE 3RD WORD
	LD	(HL),C		;STORE 3RD WORD
	INC	HL		;TO ADDR THE 4TH WORD
	LD	(HL),D		;STORE 4TH WORD
	RET			;RETURN TO CALLER

;FLOATING POINT ZERO
FZRO:	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	XOR	A		;ZERO
	LD	(HL),A		;CLEAR ACC EXPONENT
	RET			;RETURN TO CALLER

;FLOATING POINT CHANGE SIGN
FCHS:	LD	A,80H		;MASK TO CHANGE ACC SIGN BIT
	DEFB	6		;THIS MVI A, SAVES A JUMP
	;AND CONTINUE AS IN FABS

;FLOATING POINT ABSOLUTE VALUE
FABS:	XOR	A		;NB MUST BE 1-BYTE INSTRUCTION
	LD	HL,ACCS		;TO ADDR THE ACC SIGN
	AND	(HL)		;COMPLIMENT OF SIGN
	XOR	80H		;COMPLIMENT THE SIGN BIT
	LD	(HL),A		;ACC SIGN

;FLOATING POINT TEST
FTEST:	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	LD	A,(HL)		;ACC EXPONENT
	AND	A		;SET CONTROL BITS
	JP	Z,FZRO		;IF ACC IS ZERO
	LD	E,A		;ACC EXPONENT
	INC	HL		;TO ADDR THE ACC SIGN
	LD	A,(HL)		;ACC SIGN
	INC	HL		;TO ADDR THE ACC 1ST FRACTION
	XOR	(HL)		;ACC SIGN AND 1ST FRACTION
	INC	HL		;TO ADDR THE ACC 2ND FRACTION
	LD	C,(HL)		;ACC 2ND FRACTION
	INC	HL		;TO ADDR THE ACC 3RD FRACTION
	LD	D,(HL)		;ACC 3RD FRACTION
	JP	FADD8		;TO SET EXIT CONDITIONS

;FLOATING POINT LOAD
FLOAD:	LD	A,(HL)		;OPERAND EXPONENT
	AND	A		;SET CONTROL BITS
	JP	Z,FZRO		;IF OPERAND IS ZERO
	LD	E,A		;OPERAND EXPONENT
	INC	HL		;TO ADDR THE OPERAND SIGN AND 1ST FRACTION
	LD	A,(HL)		;OPERAND SIGN AND 1ST FRACTION
	INC	HL		;TO ADDR THE OPERAND 2ND FRACTION
	LD	C,(HL)		;OPERAND 2ND FRACTION
	INC	HL		;TO ADDR THE OPERAND 3RD FRACTION
	LD	D,(HL)		;OPERAND 3RD FRACTION

;STORE THE OPERAND IN THE ACCUMULATOR
	LD	L,A		;OPERAND SIGN AND 1ST FRACTION
	OR	80H		;ACC 1ST FRACTION
	LD	B,A		;ACC 1ST FRACTION
	XOR	L		;ACC SIGN
	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	CALL	FSTR0		;SET THE ACC
	XOR	B		;ACC SIGN AND 1ST FRACTION

; SET CONTROL BITS AND EXIT

	LD	B,A		;ACC SIGN AND 1ST FRACTION
	OR	01		;SET SIGN BIT FOR EXIT
	LD	A,E		;ACC EXPONENT
	RET			;RETURN TO CALLER

;FLOATING POINT MULTIPLY
FMUL:	LD	A,(HL)		;OPERAND EXPONENT
	AND	A		;SET CONTROL BITS
	CALL	NZ,MDEX		;READ OPERAND IF NOT ZERO
	JP	Z,FZRO		;IF ZERO OR UNDERFLOW
	JP	C,FOVER		;IF OVERFLOW
	CALL	MULX		;FIXED POINT MULTIPLY

;NORMALIZE IF NECESSARY
	LD	A,B		;1ST PRODUCT
	AND	A		;SET CONTROL BITS
	JP	M,RNDA		;IF NO NORMALIZATION REQUIRED
	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	LD	A,(HL)		;ACC EXPONENT
	SBC	A,01		;DECREMENT ACC EXPONENT
	LD	(HL),A		;ACC EXPONENT
	RET	Z		;RETURN TO CALLER IF UNDERFLOW
	CALL	LSH		;LEFT SHIFT SUBROUTINE

;ROUND IF NECESSARY
RNDA:	CALL	ROND		;ROUNDING SUBROUTINE
	JP	C,FOVER		;IF OVERFLOW
	LD	B,A		;ACC SIGN AND 1ST FRACTION
	OR	01		;SET SIGN BIT
	LD	A,E		;ACC EXPONENT
	RET			;RETURN TO CALLER

;FLOATING POINT DIVIDE
FDIVD:	EX	DE,HL		;XYBASIC ENTRY POINT
	INC	HL
FDIV:	XOR	A		;ZERO
	SUB	(HL)		;COMPLEMENT OF DIVISOR EXPONENT
	CP	01		;SET CARRY IF DIVISION BY ZERO
	CALL	NC,MDEX		;READ OPERAND IF NOT ZERO
	JP	C,FOVER		;IF OVERFLOW OR DIVISION BY ZERO
	JP	Z,FZRO		;IF UNDERFLOW OR ZERO
	LD	C,A		;DIVISOR 1ST FRACTION
	CALL	DIVX		;FIXED POINT DIVIDE
	JP	C,RNDA		;IF NO OVERFLOW
;FLOATING OVERFLOW -- ISSUE NONFATAL OV ERROR AND RETURN MAX VALUE
FOVER:	ERROR	N, O, V		;ISSUE NONFATAL OV ERROR
	LD	HL,FPMAX	;MAX POSITIVE FP VALUE
	JP	FLOAD		;TO ACC AND RETURN

;FLOATING POINT SUBTRACT
FSUB:	LD	A,80H		;MASK TO CHANGE OPERAND SIGN
	DEFB	6		;THIS MVI B, SAVES A JUMP
	;CONTINUE AS IN FADD

;FLOATING POINT ADD
FADD:	XOR	A		;NB MUST BE 1-BYTE INSTRUCTION
;LOAD THE OPERAND
	LD	E,(HL)		;OPERAND EXPONENT
	INC	HL		;TO ADDR THE OPERAND SIGN, 1ST FRACTION
	XOR	(HL)		;OPERAND SIGN AND 1ST FRACTION
	LD	B,A		;OPERAND SIGN AND 1ST FRACTION
	INC	HL		;TO ADDR THE OPERAND 2ND FRACTION
	LD	C,(HL)		;OPERAND 2ND FRACTION
	INC	HL		;TO ADDR THE OPERAND 3RD FRACTION
	LD	D,(HL)		;OPERAND 3RD FRACTION

;SAVE INITIAL EXPONENT
	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	LD	A,(HL)		;ACC EXPONENT
	DEC	HL		;TO ADDR THE INITIAL EXPONENT
	LD	(HL),A		;INITIAL EXPONENT

;CHECK FOR ZERO OPERAND
	LD	A,E		;OPERAND EXPONENT
	AND	A		;SET CONTROL BITS
	JP	Z,FTEST		;IF OPERAND IS ZERO

;GENERATE SUBTRACT FLAG AND RESTORE SUPPRESSED FRACTION BIT
	LD	L,B		;OPERAND SIGN AND 1ST FRACTION
	LD	A,B		;OPERAND SIGN AND 1ST FRACTION
	OR	80H		;OPERAND 1ST FRACTION
	LD	B,A		;OPERAND 1ST FRACTION
	XOR	L		;OPERAND SIGN
	LD	HL,ACCS		;TO ADDR THE ACC SIGN
	XOR	(HL)		;SUBTRACTION FLAG
	LD	(SFLAG),A	;SUBTRACTION FLAG

;DETERMINE RELATIVE MAGNITUDES OF OPERAND AND ACCUMULATOR
	DEC	HL		;TO ADDR THE ACC EXPONENT
	LD	A,(HL)		;ACC EXPONENT
	AND	A		;SET CONTROL BITS
	JP	Z,FADD9		;IF ACC IS ZERO
	SUB	E		;DIFFERENCE OF EXPONENTS
	JP	C,FADD2		;IF ACC SMALLER THAN OPERAND

;CHECK FOR INSIGNIFICANT OPERAND
	JP	M,FTEST		;IF OPERAND IS INSIGNIFICANT
	CP	19H		;COMPARE SHIFT COUNT TO 25
	JP	C,FADD3		;POSITION THE OPERAND
	JP	FTEST		;OPERAND IS INSIGNIFICANT

;CHECK FOR INSIGNIFICANT ACCUMULATOR
FADD2:	JP	P,FADD9		;IF ACC IS INSIGNIFICANT
	CP	0E7H		;COMPARE SHIFT COUNT TO -25
	JP	C,FADD9		;IF ACC IS INSIGNIFICANT
	LD	(HL),E		;OPERAND EXPONENT
	LD	E,A		;SHIFT COUNT
	LD	A,(SFLAG)	;SUBTRACT FLAG
	LD	HL,ACCS		;TO ADDR THE ACC SIGN
	XOR	(HL)		;OPERAND SIGN
	LD	(HL),A		;ACC SIGN
	XOR	A		;ZERO
	SUB	E		;COMPLIMENT SHIFT COUNT

;EXCHANGE ACCUMULATOR AND OPERAND
	INC	HL		;TO ADDR THE ACC 1ST FRACTION
	LD	E,(HL)		;ACC 1ST FRACTION
	LD	(HL),B		;OPERAND 1ST FRACTION
	LD	B,E		;ACC 1ST FRACTION
	INC	HL		;TO ADDR THE ACC 2ND FRACTION
	LD	E,(HL)		;ACC 2ND FRACTION
	LD	(HL),C		;OPERAND 2ND FRACTION
	LD	C,E		;ACC 2ND FRACTION
	INC	HL		;TO ADDR THE ACC 3RD FRACTION
	LD	E,(HL)		;ACC 3RD FRACTION
	LD	(HL),D		;OPERAND 3RD FRACTION
	LD	D,E		;ACC 3RD FRACTION

;POSITION THE OPERAND
FADD3:	CALL	RSH		;POSITION THE OPERAND
	LD	A,(SFLAG)	;SUBTRACT FLAG
	AND	A		;SET CONTROL BITS
	LD	HL,ACC3		;TO ADDR THE ACC 3RD FRACTION
	JP	M,FADD5		;IF SUBTRACT REQUIRED

;ADD ADDEND TO AUGEND
FADD4:	LD	A,(HL)		;AUGEND 3RD FRACTION
	ADD	A,D		;ADDEND 3RD FRACTION
	LD	D,A		;SUM 3RD FRACTION
	DEC	HL		;TO ADDR THE AUGEND 2ND FRACTION
	LD	A,(HL)		;AUGEND 2ND FRACTION
	ADC	A,C		;ADDEND 2ND FRACTION
	LD	C,A		;SUM 2ND FRACTION
	DEC	HL		;TO ADDR THE AUGEND 1ST FRACTION
	LD	A,(HL)		;AUGEND 1ST FRACTION
	ADC	A,B		;ADDEND 1ST FRACTION
	LD	B,A		;SUM 1ST FRACTION
	JP	NC,FADD7	;IF NO CARRY FROM 1ST FRACTION

;RIGHT SHIFT SUM TO NORMALIZED POSITION
	RRA			;RIGHT SHIFT SUM 1ST FRACTION
	LD	B,A		;SUM 1ST FRACTION
	LD	A,C		;SUM 2ND FRACTION
	RRA			;RIGHT SHIFT SUM 2ND FRACTION
	LD	C,A		;SUM 2ND FRACTION
	LD	A,D		;SUM 3RD FRACTION
	RRA			;RIGHT SHIFT SUM 3RD FRACTION
	LD	D,A		;SUM 3RD FRACTION
	RRA			;4TH FRACTION = LOW BIT OF 3RD
	LD	E,A		;SUM 4TH FRACTION
	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	LD	A,(HL)		;ACC EXPONENT
	ADD	A,1		;INCREMENT THE ACC EXPONENT
	JP	C,FOVER		;IF OVERFLOW
	LD	(HL),A		;ACC EXPONENT
	JP	FADD7		;TO ROUND FRACTION

;SUBTRACT SUBTRAHEND FROM MINUEND
FADD5:	XOR	A		;MINUEND 4TH FRACTION IS ZERO
	SUB	E		;SUBTRAHEND 4TH FRACTION
	LD	E,A		;DIFFERENCE 4TH FRACTION
	LD	A,(HL)		;MINUEND 3RD FRACTION
	SBC	A,D		;SUBTRAHEND 3RD FRACTION
	LD	D,A		;DIFFERENCE 3RD FRACTION
	DEC	HL		;TO ADDR THE MINUEND 2ND FRACTION
	LD	A,(HL)		;MINUEND 2ND FRACTION
	SBC	A,C		;SUBTRAHEND 2ND FRACTION
	LD	C,A		;DIFFERENCE 2ND FRACTION
	DEC	HL		;TO ADDR THE MINUEND 1ST FRACTION
	LD	A,(HL)		;MINUEND 1ST FRACTION
	SBC	A,B		;SUBTRAHEND 1ST FRACTION
	LD	B,A		;DIFFERENCE 1ST FRACTION
FADD6:	CALL	C,COMP		;COMPLIMENT IF NEGATIVE
	CALL	P,NORM		;NORMALIZE IF NECESSARY
	JP	P,FZRO		;IF UNDERFLOW OR ZERO
FADD7:	CALL	ROND		;ROUNDING
	JP	C,FOVER		;IF OVERFLOW
FADD8:	LD	B,A		;ACC SIGN AND 1ST FRACTION
	LD	HL,PREX		;TO ADDR THE PREVIOUS EXPONENT
	LD	A,E		;ACC EXPONENT
	SUB	(HL)		;DIFFERENCE THE EXPONENTS
	LD	L,A		;DIFFERENCE IN EXPONENTS
	LD	A,B		;ACC SIGN AND 1ST FRACTION
	OR	1		;SET SIGN BIT FOR EXIT
	LD	A,E		;ACC EXPONENT
	LD	E,L		;SIGNIFICANCE INDEX
	RET			;RETURN TO CALLER

;LOAD THE ACCUMULATOR WITH THE OPERAND
FADD9:	LD	A,(SFLAG)	;SUBTRACTION FLAG
	LD	HL,ACCS		;TO ADDR THE ACC SIGN
	XOR	(HL)		;OPERAND SIGN
	DEC	HL		;TO ADDR THE ACC EXPONENT
	CALL	FSTR0		;SET THE ACC
	XOR	B		;ACC SIGN AND 1ST FRACTION
	JP	FADD8		;JOIN EXIT CODE

;READ THE OPERAND AND CHECK THE ACCUMULATOR EXPONENT
MDEX:	LD	B,A		;EXPONENT MODIFIER
	INC	HL		;TO ADDR THE OPERAND SIGN AND 1ST FRACTION
	LD	C,(HL)		;OPERAND SIGN AND 1ST FRACTION
	INC	HL		;TO ADDR OPERAND 2ND FRACTION
	LD	D,(HL)		;OPERAND 2ND FRACTION
	INC	HL		;TO ADDR OPERAND 3RD FRACTION
	LD	E,(HL)		;OPERAND 3RD FRACTION
	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	LD	A,(HL)		;ACC EXPONENT
	AND	A		;SET CONTROL BITS
	RET	Z		;RETURN IF ACC IS ZERO
	ADD	A,B		;RESULT EXPONENT PLUS BIAS
	LD	B,A		;RESULT EXPONENT PLUS BIAS
	RRA			;CARRY TO SIGN BIT
	XOR	B		;CARRY AND SIGN MUST DIFFER
	LD	A,B		;RESULT EXPONENT PLUS BIAS
	LD	B,80H		;EXPONENT BIAS, SIGN MASK, MSB
	JP	P,OVUN		;IF OVERFLOW OR UNDERFLOW
	SUB	B		;REMOVE EXCESS EXPONENT BIAS
	RET	Z		;RETURN IF UNDERFLOW
	LD	(HL),A		;RESULT EXPONENT
	INC	HL		;TO ADDR THE ACC SIGN
	LD	A,(HL)		;ACC SIGN
	XOR	C		;RESULT SIGN IN SIGN BIT
	AND	B		;RESULT SIGN
	LD	(HL),A		;RESULT SIGN
	LD	A,C		;OPERAND SIGN AND 1ST FRACTION
	OR	B		;OPERAND 1ST FRACTION
	RET			;RETURN TO CALLER
OVUN:	RLCA			;SET CARRY BIT IF OVERFLOW
	RET	C		;RETURN IF OVERFLOW
	XOR	A		;ZERO
	RET			;RETURN IF UNDERFLOW

;LEFT SHIFT THE B, C, D, AND E REGISTERS ONE BIT
LSH:	LD	A,E		;ORIGINAL CONTENTS OF E
	RLA			;LEFT SHIFT E
	LD	E,A		;RESTORE TO E
	LD	A,D		;ORIGINAL CONTENTS OF D
	RLA			;LEFT SHIFT D
	LD	D,A		;RESTORE TO D
	LD	A,C		;ORIGINAL CONTENTS OF C
	RLA			;LEFT SHIFT C
	LD	C,A		;RESTORE TO C
	LD	A,B		;ORIGINAL CONTENTS OF B
	ADC	A,A		;LEFT SHIFT B
	LD	B,A		;RESTORE TO B
	RET			;RETURN TO CALLER

;RIGHT SHIFT THE B, C, D, AND E REGISTERS
;BY THE SHIFT COUNT IN THE A REGISTER.
;              - OR -
;SHIFT OPERAND TO REGISTER INDICATED
;BY THE SHIFT COUNT(MODULO 8).
RSH:	LD	E,0		;OPERAND 4TH FRACTION IS ZERO
	LD	L,08		;EACH REG IS 8 BITS OF SHIFT
RSH1:	CP	L		;COMPARE SHIFT COUNT TO 8
	JP	M,RSH2		;IF REQUIRED SHIFT IS < 8
	LD	E,D		;OPERAND 4TH FRACTION
	LD	D,C		;OPERAND 3RD FRACTION
	LD	C,B		;OPERAND 2ND FRACTION
	LD	B,0		;OPERAND 1ST FRACTION IS ZERO
	SUB	L		;REDUCE SHIFT COUNT BY ONE REGISTER
	JP	NZ,RSH1		;IF MORE SHIFTS REQUIRED

;SHIFT OPERAND RIGHT BY 'SHIFT COUNT' BITS
RSH2:	AND	A		;SET CONTROL BITS
	RET	Z		;RETURN IF SHIFT COMPLETE
	LD	L,A		;SHIFT COUNT
RSH3:	AND	A		;CLEAR CARRY BIT
	LD	A,B		;OPERAND 1ST FRACTION
	RRA			;RIGHT SHIFT 1ST FRACTION
	LD	B,A		;OPERAND 1ST FRACTION
	LD	A,C		;OPERAND 2ND FRACTION
	RRA			;RIGHT SHIFT 2ND FRACTION
	LD	C,A		;OPERAND 2ND FRACTION
	LD	A,D		;OPERAND 3RD FRACTION
	RRA			;RIGHT SHIFT 3RD FRACTION
	LD	D,A		;OPERAND 3RD FRACTION
	LD	A,E		;OPERAND 4TH FRACTION
	RRA			;RIGHT SHIFT 4TH FRACTION
	LD	E,A		;OPERAND 4TH FRACTION
	DEC	L		;DECREMENT SHIFT COUNT
	JP	NZ,RSH3		;IF MORE SHIFTS REQUIRED
	RET			;RETURN TO CALLER

;COMPLIMENT THE B, C, D, AND E REGISTERS
COMP:	DEC	HL		;TO ADDR THE ACC SIGN
	LD	A,(HL)		;ACC SIGN
	XOR	80H		;CHANGE SIGN
	LD	(HL),A		;ACC SIGN
COMP1:	XOR	A		;ZERO -- FFIX ENTRY POINT
	LD	L,A		;ZERO
	SUB	E		;COMPLIMENT 4TH FRACTION
	LD	E,A		;RESTORE TO E
	LD	A,L		;ZERO
	SBC	A,D		;COMPLIMENT 3RD FRACTION
	LD	D,A		;RESTORE TO D
	LD	A,L		;ZERO
	SBC	A,C		;COMPLIMENT 2ND FRACTION
	LD	C,A		;RESTORE TO C
	LD	A,L		;ZERO
	SBC	A,B		;COMPLIMENT 1ST FRACTION
	LD	B,A		;RESTORE TO B
	RET			;RETURN TO CALLER

;NORMALIZE THE REGISTERS
NORM:	LD	L,20H		;MAXIMUM NORMALIZING SHIFT
NORM1:	LD	A,B		;1ST FRACTION
	AND	A		;SET CONTROL BITS
	JP	NZ,NORM3	;IF 1ST FRACTION IS NON ZERO
	LD	B,C		;1ST FRACTION
	LD	C,D		;2ND FRACTION
	LD	D,E		;3RD FRACTION
	LD	E,A		;ZERO 4TH FRACTION
	LD	A,L		;NORMALIZING SHIFT COUNT
	SUB	08		;REDUCE SHIFT COUNT
	LD	L,A		;NORMALIZING SHIFT COUNT
	JP	NZ,NORM1	;IF FRACTION NON ZERO
	RET			;IF FRACTION IS ZERO
NORM2:	DEC	L		;DECREMENT SHIFT COUNT
	LD	A,E		;ORIGINAL CONTENTS OF E
	RLA			;LEFT SHIFT E
	LD	E,A		;RESTORE TO E
	LD	A,D		;ORIGINAL CONTENTS OF D
	RLA			;LEFT SHIFT D
	LD	D,A		;RESTORE TO D
	LD	A,C		;ORIGINAL CONTENTS OF C
	RLA			;LEFT SHIFT C
	LD	C,A		;RESTORE TO C
	LD	A,B		;ORIGINAL CONTENTS OF B
	ADC	A,A		;LEFT SHIFT B
	LD	B,A		;RESTORE TO B
NORM3:	JP	P,NORM2		;IF NOT YET NORMALIZED
	LD	A,L		;NORMALIZING SHIFT COUNT
	SUB	20H		;REMOVE BIAS
	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	ADD	A,(HL)		;ADJUST ACC EXPONENT
	LD	(HL),A		;NEW ACC EXPONENT
	RET	Z		;RETURN IF ZERO EXPONENT
	RRA			;BORROW BIT TO SIGN
	AND	A		;SET SIGN TO INDICATE UNDERFLOW
	RET			;RETURN TO CALLER

;ROUND THE B, C, AND D REGISTERS
ROND:	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	LD	A,E		;4TH FRACTION
	AND	A		;SET CONTROL BITS
	LD	E,(HL)		;ACC EXPONENT
	CALL	M,RNDR		;CALL 2ND LEVEL ROUNDER
	RET	C		;RETURN IF OVERFLOW
	LD	A,B		;1ST FRACTION
	INC	HL		;TO ADDR THE ACC SIGN
	XOR	(HL)		;ACC SIGN AND 1ST FRACTION
	JP	FSTR1		;RETURN THRU 'STORE' SUBROUTINE

;SECOND LEVEL ROUNDER
RNDR:	INC	D		;ROUND 3RD FRACTION
	RET	NZ		;RETURN IF NO CARRY
	INC	C		;CARRY TO 2ND FRACTION
	RET	NZ		;RETURN IF NO CARRY
	INC	B		;CARRY TO 1ST FRACTION
	RET	NZ		;RETURN IF NO CARRY
	LD	A,E		;ACC EXPONENT
	ADD	A,1		;INCREMENT ACC EXPONENT
	LD	E,A		;NEW ACC EXPONENT
	LD	B,80H		;NEW 1ST FRACTION
	LD	(HL),A		;NEW ACC EXPONENT
	RET			;RETURN TO 1ST LEVEL ROUNDER

;FIXED POINT MULTIPLY
MULX:	LD	HL,MULX4+9	;TO ADDR THE 1ST MULTIPLICAND
	LD	(HL),A		;1ST MULTIPLICAND
	LD	HL,MULX4+5	;TO ADDR THE 2ND MULTIPLICAND
	LD	(HL),D		;2ND MULTIPLICAND
	LD	HL,MULX4+1	;TO ADDR THE 3RD MULTIPLICAND
	LD	(HL),E		;3RD MULTIPLICAND
	XOR	A		;CLEAR 6TH PRODUCT
	LD	E,A		;CLEAR 5TH PRODUCT
	LD	D,A		;CLEAR 4TH PRODUCT

;MULTIPLY BY EACH ACCUMULATOR FRACTION IN TURN
	LD	HL,ACC3		;TO ADDR THE 3RD FRACTION
	CALL	MULX2		;MULTIPLY BY ACC 3RD FRACTION
	LD	HL,ACC2		;TO ADDR THE 2ND FRACTION
	CALL	MULX1		;MULTIPLY BY ACC 2ND FRACTION
	LD	HL,ACC1		;TO ADDR THE 1ST FRACTION

;MULTIPLY BY ONE ACCUMULATOR WORD
MULX1:	LD	A,D		;5TH PARTIAL PRODUCT
	LD	E,C		;4TH PARTIAL PRODUCT
	LD	D,B		;3RD PARTIAL PRODUCT
MULX2:	LD	B,(HL)		;MULTIPLIER
	LD	L,A		;5TH PARTIAL PRODUCT
	XOR	A		;ZERO
	LD	C,A		;TO 2ND PARTIAL PRODUCT
	SUB	B		;SET CARRY BIT FOR EXIT FLAG
	JP	NC,FFIX0	;MULTIPLY BY 0

;LOOP FOR EACH BIT OF MULTIPLIER WORD
MULX3:	LD	A,L		;5TH PARTIAL PRODUCT, EXIT FLAG
	ADC	A,A		;SHIFT EXIT FLAG OUT IF DONE
	RET	Z		;EXIT IF MULTIPLICATION DONE
	LD	L,A		;5TH PARTIAL PRODUCT, EXIT FLAG
	LD	A,E		;4TH PARTIAL PRODUCT
	RLA			;SHIFT 4TH PARTIAL PRODUCT
	LD	E,A		;4TH PARTIAL PRODUCT
	LD	A,D		;3RD PARTIAL PRODUCT
	RLA			;SHIFT 3RD PARTIAL PRODUCT
	LD	D,A		;3RD PARTIAL PRODUCT
	LD	A,C		;2ND PARTIAL PRODUCT
	RLA			;SHIFT 2ND PARTIAL PRODUCT
	LD	C,A		;2ND PARTIAL PRODUCT
	LD	A,B		;1ST PARTIAL PRODUCT AND MULTIPLIER
	RLA			;SHIFT THEM
	LD	B,A		;1ST PARTIAL PRODUCT AND MULTIPLIER
	JP	NC,MULX3	;IF NO ADDITION REQUIRED

;ADD THE MULTIPLICAND TO THE PRODUCT IF THE MULTIPLIER BIT IS A ONE
	LD	A,E		;4TH PARTIAL PRODUCT
	CALL	MULX4		;TO RAM CODE

;COMPLETE ADDITION OF MULTIPLICAND
	LD	C,A		;2ND PARTIAL PRODUCT
	JP	NC,MULX3	;IF NO CARRY TO 1ST PRODUCT
	INC	B		;ADD CARRY TO 1ST PRODUCT
	AND	A		;CLEAR CARRY BIT
	JP	MULX3

;FIXED POINT DIVIDE
;
;SUBTRACT THE DIVISOR FROM THE ACCUMULATOR TO OBTAIN THE FIRST REMAINDER
DIVX:	LD	HL,ACC3		;TO ADDR THE ACC 3RD FRACTION
	LD	A,(HL)		;ACC 3RD FRACTION
	SUB	E		;DIVISOR 3RD FRACTION
	LD	(HL),A		;REMAINDER 3RD FRACTION
	DEC	HL		;TO ADDR THE ACC 2ND FRACTION
	LD	A,(HL)		;ACC 2ND FRACTION
	SBC	A,D		;DIVISOR 2ND FRACTION
	LD	(HL),A		;REMAINDER 2ND FRACTION
	DEC	HL		;TO ADDR THE ACC 1ST FRACTION
	LD	A,(HL)		;ACC 1ST FRACTION
	SBC	A,C		;DIVISOR 1ST FRACTION
	LD	(HL),A		;REMAINDER 1ST FRACTION

;HALVE THE DIVISOR AND STORE FOR ADDITION OR SUBTRACTION
	LD	A,C		;DIVISOR 1ST FRACTION
	RLA			;SET CARRY BIT
	LD	A,C		;DIVISOR 1ST FRACTION
	RRA			;HALF OF DIVISOR 1ST FRACTION
	LD	(DIVX5+12),A	;1ST SUBTRACT DIVISOR
	LD	(DIVX6+9),A	;1ST ADD DIVISOR
	LD	A,D		;DIVISOR 2ND FRACTION
	RRA			;HALF OF DIVISOR 2ND FRACTION
	LD	(DIVX5+8),A	;2ND SUBTRACT DIVISOR
	LD	(DIVX6+5),A	;2ND ADD DIVISOR
	LD	A,E		;DIVISOR 3RD FRACTION
	RRA			;HALF OF DIVISOR 3RD FRACTION
	LD	(DIVX5+4),A	;3RD SUBTRACT DIVISOR
	LD	(DIVX6+1),A	;3RD ADD DIVISOR
	LD	B,0		;INIT QUOTIENT 1ST FRACTION
	LD	A,B		;DIVISOR 4TH QUOTIENT IS ZERO
	RRA			;LOW BIT OF DIVISOR 3RD FRACTION
	LD	(DIVX5+1),A	;4TH SUBTRACT DIVISOR
	LD	(DIVX5+15),A	;4TH ADD DIVISOR
	LD	(DIVX6+12),A	;4TH ADD DIVISOR

;LOAD FIRST REMAINDER AND CHECK SIGN
	LD	HL,ACC1		;TO ADDR THE REMAINDER 1ST FRACTION
	LD	A,(HL)		;REMAINDER 1ST FRACTION
	INC	HL		;TO ADDR THE REMAINDER 2ND FRACTION
	LD	D,(HL)		;REMAINDER 2ND FRACTION
	INC	HL		;TO ADDR THE REMAINDER 3RD FRACTION
	LD	E,(HL)		;REMAINDER 3RD FRACTION
	AND	A		;SET CONTROL BITS
	JP	M,DIVX4		;IF REMAINDER IS NEGATIVE

;ADJUST THE EXPONENT, POSITION THE REMAINDER, AND INITIALIZE THE QUOTIENT
	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	LD	C,(HL)		;QUOTIENT EXPONENT
	INC	C		;INCREMENT THE QUOTIENT EXPONENT
	RET	Z		;RETURN IF OVERFLOW
	LD	(HL),C		;QUOTIENT EXPONENT
	LD	L,E		;REMAINDER 3RD FRACTION
	LD	H,D		;REMAINDER 2ND FRACTION
	LD	E,A		;REMAINDER 1ST FRACTION
	LD	D,1		;INITIALIZE QUOTIENT 3RD FRACTION
	LD	C,B		;INITIALIZE QUOTIENT 2ND FRACTION

;SUBTRACT THE DIVISOR FROM THE REMAINDER IF IT IS POSITIVE
DIVX1:	XOR	A		;REMAINDER 4TH FRACTION IS ZERO
	CALL	DIVX5		;CALL RAM CODE
DIVX2:	RLCA			;SHIFT REMAINDER 4TH FRACTION TO CARRY

;SHIFT THE REMAINDER LEFT ONE BIT
	LD	A,B		;QUOTIENT 1ST FRACTION
	RLA			;MSB OF QUOTIENT TO CARRY
	RET	C		;IF DIVISION COMLPETE
	RRA			;REMAINDER 4TH FRACTION TO CARRY
	LD	A,L		;REMAINDER 3RD FRACTION
	RLA			;LEFT SHIFT REMAINDER 3RD FRACTION
	LD	L,A		;REMAINDER 3RD FRACTION
	LD	A,H		;REMAINDER 2ND FRACTION
	RLA			;LEFT SHIFT REMAINDER 2ND FRACTION
	LD	H,A		;REMAINDER 2ND FRACTION
	CALL	LSH		;LEFT SHIFT IT

;BRANCH IF SUBTRACTION IS REQUIRED
	LD	A,D		;QUOTIENT 3RD FRACTION
	RRCA			;REMAINDER SIGN TO CARRY BIT
	JP	C,DIVX1		;SUBTRACT DIVISOR IF REMAINDER IS POSITIVE

;ADD THE DIVISOR IF THE REMAINDER IS NEGATIVE
DIVX3:	LD	A,L		;REMAINDER 3RD FRACTION
	CALL	DIVX6		;TO RAM CODE
	JP	DIVX2

;POSITION THE REMAINDER AND INITIALIZE THE QUOTIENT
DIVX4:	LD	L,E		;REMAINDER 3RD FRACTION
	LD	H,D		;REMAINDER 2ND FRACTION
	LD	E,A		;REMAINDER 1ST FRACTION
	LD	D,B		;INITIALIZE QUOTIENT 3RD FRACTION
	LD	C,B		;INITIALIZE QUOTIENT 2ND FRACTION
	JP	DIVX3		;ADD DIVISOR IF REMAINDER IS NEGATIVE

;FIXED POINT TO FLOATING POINT CONVERSION
FFLOT:	LD	L,E		;INPUT EXPONENT
	LD	E,D		;4TH INPUT FRACTION
	LD	D,C		;3RD INPUT FRACTION
	LD	C,B		;2ND INPUT FRACTION
	LD	B,A		;1ST INPUT FRACTION
	LD	A,L		;INPUT EXPONENT
FLOT1:	XOR	80H		;APPLY EXPONENT BIAS
	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	LD	(HL),A		;ACC EXPONENT
	INC	HL		;TO ADDR THE ACC SIGN
	LD	(HL),80H	;SET ACC SIGN POSITIVE
	INC	HL		;TO ADDR THE ACC 1ST FRACTION
	LD	A,B		;1ST INPUT FRACTION
	AND	A		;SET SIGN BIT
	RLA			;INPUT SIGN TO CARRY
	JP	FADD6		;COMPLETE THE CONVERSION

;FLOATING POINT TO FIXED POINT CONVERSION
FFIX:	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
	LD	A,(HL)		;ACC EXPONENT
	AND	A		;SET CONTROL BITS
	JP	Z,FFIX1		;IF ACC IS ZERO
	LD	A,E		;INPUT EXPONENT
	ADD	A,7FH		;APPLY BIAS-1
	SUB	(HL)		;SHIFT COUNT - 1
	JP	C,FFIX2		;check for -32768 if too large
	CP	1FH		;COMPARE TO LARGE SHIFT
	JP	NC,FFIX1	;IF ACC TOO SMALL
	ADD	A,1		;SHIFT COUNT
	LD	HL,ACC1		;TO ADDR THE ACC 1ST FRACTION
	LD	B,(HL)		;ACC 1ST FRACTION
	INC	HL		;TO ADDR THE ACC 2ND FRACTION
	LD	C,(HL)		;ACC 2ND FRACTION
	INC	HL		;TO ADDR THE ACC 3RD FRACTION
	LD	D,(HL)		;ACC 3RD FRACTION
	CALL	RSH		;POSITION THE FRACTION
	LD	HL,ACCS		;TO ADDR THE ACC SIGN
	LD	A,(HL)		;ACC SIGN
	AND	A		;SET CONTROL BITS
	CALL	P,COMP1		;COMPLIMENT FRACTION IF NEGATIVE
	LD	A,1		;NON-ZERO
	OR	B		;SET CONTROL BITS FOR EXIT
	LD	A,B		;1ST RESULT
	LD	B,C		;2ND RESULT
FFIX0:	LD	C,D		;3RD RESULT  -- MULX2 ENTRY POINT
	LD	D,E		;4TH RESULT
	RET			;RETURN TO CALLER
FFIX1:	XOR	A		;ZERO
	LD	B,A		;ZERO
	LD	C,A		;ZERO
	LD	D,A		;ZERO
	RET			;RETURN TO CALLER
;FIX2 checks for -32768 (90H, 0, 80H, 0, 0) in FACC, otherwise returns Carry.
FFIX2:	LD	A,(HL)
	SUB	90H
	INC	HL
	OR	(HL)
	INC	HL
	LD	C,(HL)		;ACC1 to C
	INC	HL
	OR	(HL)
	INC	HL
	OR	(HL)
	SCF
	RET	NZ		;ACCE <> 90H or ACCS, ACC2, ACC3 <> 0
	LD	B,A		;0 to B in case success
	LD	A,C
	CP	80H
	RET	Z		;-32768, return 80H in A and 0 in B
	SCF
	RET			;ACC1 <> 80H

;floating point increment routine for fast NEXT code
FINCR:	LD	A,(HL)		;get argument exponent
	CP	81H		;does it have the exponent of a fp one?
	JP	NZ,FADD		;nope - have to plow thru a fp add
	PUSH	HL		;yup - test remainder of bytes
	INC	HL
	LD	A,(HL)
	INC	HL
	OR	(HL)
	INC	HL
	OR	(HL)
	POP	HL
	JP	NZ,FADD		;not a fp one, have to use add
	PUSH	HL
	LD	HL,ACCE		;see if acc is easy to increment
	LD	A,(HL)
	OR	A		;is it zero?
	JP	Z,FINC1		;yes - hard to increment
	DEC	A		;generate a carry if FACC is >=1 and
	INC	HL
	ADD	A,(HL)		;positive
FINC1:	POP	HL
	JP	NC,FADD		;not easy to increment
	LD	A,(ACCE)	;get current exponent
	LD	E,0		;to defeat etest
	CP	25+81H		;will exponents differ by more than 23?
	RET	NC		;yes - no point in adding
	SUB	81H		;difference of exponents now in reg a
	LD	BC,8000H	;put mantissa of fp one into regs BCD
	LD	D,C
	JP	Z,FINC4
	LD	E,A		;save difference
	AND	7		;take difference mod 8
	LD	L,A		;bits to rotate the signifficant bit
	LD	A,B		;fetch sig bit to rotate
	JP	Z,FINC3		;bit in right pos, now pick right byte
FINC2:	RRCA			;keep rotating until in right place
	DEC	L
	JP	NZ,FINC2
FINC3:	LD	B,A		;assume bit belongs in 1st fraction
	LD	A,E		;test number of bits to see if it is so
	CP	8		;set carry if it belongs here
	JP	C,FINC4		;in which case, all is shifted
	LD	C,B		;assume bit belongs in 2nd fraction
	LD	B,L		;zero 1st fraction
	CP	16		;set carry if it belongs in 2nd fraction
	JP	C,FINC4
	LD	D,C		;well, it must belong in 3rd fraction
	LD	C,L		;zero second fraction
FINC4:	LD	HL,ACC3		;needed by add4
	JP	FADD4


	ENDIF			;end of FLOAT conditional

;end of FMATH
	PAGE
;FNSOPS 11/05/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;arithmetic and control function and op routines

;auxilliary functions called by fn / op routines

;READP reads the port # given in C.
	IF	NOT WILD
READP:	CALL	ISBYT
	LD	A,C
RDP1:	LD	(RPORT+1),A	;set port #
	JP	RPORT		;read the port and return
	ENDIF

;STBIT sets bit # [(E) and (D)] of DE.
;Retn:	A,HL	clobbered
;	BC	preserved
;	DE	bit # [(E) and (D)] set, others reset
	IF	NOT WILD
STBT0:	LD	D,0FH
STBIT:	LD	A,E
	AND	D		;(E) masked by (D) to A, carry reset
	LD	DE,1		;set bit 0 of DE
STBI1:	RET	Z		;done if (A) = 0
	EX	DE,HL
	ADD	HL,HL		;move bit left in HL
	EX	DE,HL
	DEC	A
	JP	STBI1
	ENDIF

;SNFIX replaces (BC) and (DE) by their abs values, sets sign bit
;of TEMP iff exactly one of them was < 0.
;SNFX0 does SNFIX, returns Carry if (DE) = 0.
SNFX0:	LD	A,D
	OR	E
	SCF
	RET	Z		;return Carry if DE=0, else do SNFIX
SNFIX:	LD	A,B
	XOR	D		;desired sign to A7
	LD	(TEMP),A	;and saved
	CALL	IABS		;replace BC by abs(BC)
	RET	C
	LD	A,D
	OR	A
	CALL	M,CPLDE		;replace DE by -(DE) if negative
	RET

;MULTY multiplies nonnegative integers in A and DE, leaves HL + product in HL.
;NB MULTY is used by RND to produce (HL) + (A) * (DE) mod 2 ^ 16 exactly, even
;on overflow, and is therefore more complicated than it would otherwise be.
;Call:	A	nonnegative multiplier
;	DE	nonnegative multiplicand
;Retn:	A	zero unless overflow
;	BC	preserved
;	DE	clobbered
;	HL	(HL) + (A) * (DE), mod 2 ^ 16 if overflow
;	Carry	set iff overflow
;MULBD multiplies unsigned values in BC and DE, returns result in HL.
MULBD:	CALL	CMBDU
	CALL	NC,BCDE		;force BC <= DE
	LD	A,B
	OR	A
	SCF
	RET	NZ		;overflow if both args >= 2 ^ 8
	LD	A,C		;multiplier to A and fall though to MULT0
MULT0:	LD	HL,0
MULTY:	PUSH	BC
	LD	B,0		;keep track of overflow in B
MULT1:	OR	A		;clear carry
	RRA			;get next bit of multiplier in carry
	JP	NC,MULT2
	ADD	HL,DE		;add multiplicand to partial product
	CALL	C,OVSET		;overflow
MULT2:	OR	A
	JP	Z,MULT3		;done when no more bits on
	EX	DE,HL
	ADD	HL,HL		;shift multiplicand left one
	EX	DE,HL
	CALL	C,OVSET		;overflow
	JP	MULT1
MULT3:	LD	A,B
	POP	BC
	RLA			;carry set iff overflow
	RET

;DIVD0 does the work of division.
;Call:	BC	nonnegative dividend
;	DE	nonnegative nonzero divisor
;Retn:	DE	remainder
;	HL	quotient
;The dividend starts in HL and is shifted bit by bit into DE as quotient bits
;are shifted into HL.  At DIVD1, we have [0 bits : current dividend] in DE,
;[dividend bits : quotient bits] in HL.
;A tells us how many bits are left of : in the above description.
DIVD0:	LD	H,B
	LD	L,C		;dividend to HL
	CALL	UMIND		;- divisor to BC
	LD	DE,0		;current dividend 0
	LD	A,16		;count to A
	OR	A		;first quotient bit 0
DIVD1:	PUSH	AF		;save quotient bit
	ADD	HL,HL		;shift HL left
	PUSH	AF		;save high bit of dividend
	EX	DE,HL
	ADD	HL,HL		;shift DE left
	POP	AF
	CALL	C,INXH		;add in dividend bit
	POP	AF
	JP	NC,DIVD3
	INC	DE		;add in quotient bit
DIVD3:	PUSH	HL		;save current dividend
	ADD	HL,BC		;try subtracting divisor
	JP	NC,DIVD4	;too big, retain old one
	EX	(SP),HL		;ok, keep new one
DIVD4:	POP	HL		;carry set iff subtraction worked
	EX	DE,HL
	DEC	A
	JP	NZ,DIVD1	;keep going
	ADC	A,0		;zero set iff carry reset
	ADD	HL,HL		;shift quotient one more time
	RET	Z
INXH:	INC	HL		;add in last quotient bit
	RET

;AMBOP is called during execution of an ambiguous binary op
;(namely + - * / and relations).  The args are forced to
;match and are fetched, and the type is returned in the status bits.
;In addition, the arg1 pointer is saved in TEMP2 for RETRY if integer.
;Call:	BC,DE	arg1, arg2 pointers
;Retn:	BC,DE	arg1, arg2 values if integer
;	CDE,BHL	arg1, arg2 values if string
;	FACC,HL	arg1 value, arg2 pointer if floating
;	Carry	set iff string
;	Zero	set iff integer
AMBOP:	EX	DE,HL		;arg2 addr to HL
	LD	A,(BC)		;fetch arg1 type
AMBO1:	CP	(HL)		;RETRY entry point
	CALL	NZ,AMBTY	;force types to agree
	PUSH	BC		;save arg1 pointer
	CALL	FETCH		;arg2 pointer to HL
	IFTYP	AMBOF, AMBOS	;branch if noninteger
	POP	HL		;arg1 pointer to HL
	PUSH	BC		;save arg2 value
	CALL	FETCH		;fetch arg1 value to BC
	POP	DE		;arg2 value to DE
	RET
	IF	STRNG
AMBOS:	POP	HL		;arg1 pointer to HL
	LD	B,C		;arg2 length to B
	PUSH	DE		;save arg2 loc
	CALL	FETCH		;arg1 to CDE
	POP	HL		;arg2 loc to HL
	RET
	ENDIF
	IF	FLOAT
AMBOF:	EX	(SP),HL		;save arg2 pointer, arg1 pointer to HL
	CALL	FETCH		;fetch arg1
	POP	HL
	INC	HL		;point to arg2 value with HL
	RET
	ENDIF
;AMBTY forces both args to floating.
AMBTY:
	IF	FLOAT
	CALL	CNVTF		;float arg2
	PUSH	BC
	EX	(SP),HL
	CALL	CNVRT		;float arg1
	EX	(SP),HL
	POP	BC
	RET
	ELSE
	JP	TMERR		;fatal TM error if nonfloating version
	ENDIF

;CMPAR does the work of comparing two args for relation routines.
;Call:	BC, DE	arg pointers
;Retn:	BC	0
;	Carry, Zero	set as for CMBDS
CMPAR:	CALL	AMBOP		;fetch args, set status bits
	IFTYP	CMPAF, CMPAS	;branch if noninteger
	CALL	CMBDS		;compare integer arg1 to arg2, signed
	LD	BC,0
	RET
	IF	STRNG
CMPAS:	CALL	CMSTR		;compare string arg1 to arg2
	LD	BC,0
	RET
	ENDIF
	IF	FLOAT
CMPAF:	CALL	CMPFL		;perform floating compare
	LD	BC,0
	RET	P		;arg1 > arg2, return Carry reset
	RET	Z		;arg1 = arg2, return Zero set
	SCF			;arg1 < arg2, return Carry set
	RET

;ETEST tests the significance value in E.  If the result is
;insignificant it is replaced by a floating zero.
	IF	(NOT F9511) AND (NOT FPBCD)
ETEST:	LD	H,A		;save A
	LD	A,E
	ADD	A,80H
	CP	(80H-SINDX) AND 255;compare to desired significance index
	LD	A,H		;restore A
	RET	NC		;result significant
	CP	83H-SINDX	;compare exponent to see if small
	RET	NC		;not small, take computed value
	JP	FZRO		;result insignificant, take 0. instead
	ENDIF

;CMPFL compares two FP numbers, returns Sign and Zero set as for FTEST.
	IF	F9511
CMPFL:	LD	A,XCH95
	CALL	O9511		;exchange order of args
CMPF0:	CALL	FSUB0		;subtract args -- BDTST entry point
	IN	A,(C9511)	;read result status
	AND	ZER95		;check Zero bit
	JP	NZ,CMPF1	;result is 0
	IN	A,(C9511)
	RLA			;sign status to bit A7
	AND	80H		;mask to sign bit
	OR	1		;reset Zero, set Sign appropriately
	RET
CMPF1:	XOR	A		;set Zero, reset Sign
	RET
	ELSE			;NOT F9511
	IF	FPBCD
CMPFL:	CALL	FSUB		;subtract
FTEST:	LD	A,(FACC)	;fetch result sign/exponent byte
	OR	A
	RET			;Zero set iff equal, else sign set
	ELSE
CMPFL:	EX	DE,HL		;arg2 exp address to DE
	LD	HL,ACCE		;arg1 (in FACC) exponent address to HL
	LD	A,(HL)
	OR	A		;Zero set iff exp(arg1) = 0
	LD	A,(DE)		;fetch exp(arg2)
	JP	Z,CMPF5
	OR	A		;Zero set iff exp(arg2) = 0
	INC	HL
	JP	Z,CMPF7
	INC	DE
	LD	A,(DE)		;fetch sign(arg2)
	XOR	(HL)		;compare to sign(arg1)
	JP	P,CMPF6		;signs not equal
	DEC	HL
	DEC	DE
	LD	A,(DE)		;fetch exp(arg2) again
	SUB	(HL)		;compare to exp(arg1)
	JP	NZ,CMPF2	;exponents not equal
	INC	HL
	INC	HL
	INC	DE
	LD	A,(DE)		;fetch mmsb(arg2)
	OR	80H		;restore hidden bit
	CP	(HL)		;compare to msb(arg1)
	JP	NZ,CMPF4	;msb of fraction not equal
	INC	HL
	INC	DE
	LD	A,(DE)		;fetch byte2(arg2)
	CP	(HL)		;compare to byte2(arg1)
	JP	NZ,CMPF4	;byte2 of fraction not equal
	DEC	DE
	DEC	DE		;readdress exp(arg2)
CMPF1:	EX	DE,HL		;arg2 pointer to HL
	CALL	FSUB		;arg1-arg2
	CALL	ETEST		;check if almost 0
	JP	FTEST		;set status bits and return
CMPF2:	DEC	A
	JP	Z,CMPF3		;exponents differ by 1
	INC	A
	INC	A
	JP	NZ,CMPF4	;exponents differ by more than 1
CMPF3:	INC	HL
	INC	HL
	INC	DE
	LD	A,(DE)		;fetch msb(arg2)
	XOR	(HL)		;msb(arg2) xor msb(arg1)
	DEC	DE
	INC	A		;Zero set if near exponent boundary
	JP	Z,CMPF1		;in which case do the subtraction
	DEC	HL
	DEC	HL
	LD	A,(DE)		;fetch exp(arg2)
	CP	(HL)		;Carry set if exp(arg2) < exp(arg1)
CMPF4:	RRA			;Carry to A7
	LD	HL,ACCS		;address arg1 sign
	XOR	(HL)		;complement unless negative
	OR	1		;assure Zero reset
	RET
CMPF5:	OR	A
	RET	Z		;both args 0, hence equal
	INC	DE
CMPF6:	EX	DE,HL		;sign(arg2) will give result
CMPF7:	LD	A,(HL)
	XOR	80H		;complemented sign(arg1) gives result
	OR	1		;assure Zero reset
	RET
	ENDIF			;end of NOT FPBCD conditional
	ENDIF			;end of NOT F9511 conditional

RETRY:	LD	HL,(ARGAD);arg1 pointer to HL
	LD	B,H
	LD	C,L		;and then to BC
	LD	HL,VBYTS+2
	ADD	HL,BC		;arg2 pointer to HL
	XOR	A		;to assure nonzero CMP at AMBO1
	JP	AMBO1		;convert to floating and refetch
RTRY1:	LD	HL,(ARGAD)	;recover arg pointer
CNVTF:	LD	A,SNGST
	JP	CNVRT		;float it and return
	ENDIF

FCERN:	ERROR	N, F, C	;issue nonfatal FC error
	RET			;and return
FCERF:	ERROR	F, F, C		;fatal FC error


;routines for fn and op execution

;ambiguous arithmetic ops
;AOP is a macro for executing ambiguous ops, namely + - * ABS and unary -.
;IOP, FOP and SOP are addresses of integer, floating and string routines.
;UNARY is a flag, TRUE if unary and FALSE if binary.
;SGNIF is a flag for significance checking, TRUE for + and -.
;FCERF is fatal FC error for string arg to arithmetic routine
AOP	MACRO	IOP,FOP,SOP,UNARY,SNGIF
	LOCAL	EXFOP
	IF	UNARY		;;first fetch args and set status bits
	CALL	FETBC		;;fetch one arg from BC if unary
	ELSE
	CALL	AMBOP		;;fetch two agreeing args if binary
	ENDIF
	IFTYP	EXFOP, SOP	;;branch if noninteger
	CALL	IOP		;;execute integer op
	LD	A,INTST		;;return type integer
	RET	NC		;;done unless overflow
	IF	FLOAT
	IF	UNARY
	CALL	RTRY1		;;recover arg and float it
	ELSE
	CALL	RETRY		;;recover args and float them
	ENDIF
EXFOP:	CALL	FOP		;;execute floating op
	IF	F9511
	CALL	FET95		;;fetch result if 9511 op
	ELSE
	IF	SNGIF AND NOT FPBCD
	CALL	ETEST		;;test value in E for significance if SGNIF
	ENDIF
	ENDIF
	LD	E,A		;;save A
	LD	A,SNGST		;;return type floating
	RET
	ELSE
	JP	IOVER		;;integer OV error if not floating version
	ENDIF
	ENDM

;Addition(+): {<integer>|<floating>|<string>} x {<integer>|<floating>|<string>}
;	--> {<integer>|<floating>|<string>}
AADD:	AOP	IADD,FADD,SADD,FALSE,TRUE

;Subtraction (-): {<integer>|<floating>} x {<integer>|<floating>}
;	--> {<integer>|<floating>}
ASUB:	AOP	ISUB,FSUB,FCERF,FALSE,TRUE

;Multiplication (*): {<integer>|<floating>} x {<integer>|<floating>}
;	--> {<integer>|<floating>}
AMUL:	AOP	IMUL,FMUL,FCERF,FALSE,FALSE

;Unary minus (-): {<integer> | <floating>} --> {<integer> | <floating>}
AUMIN:	AOP	IUMIN,FCHS,FCERF,TRUE,FALSE

;ABS: {<integer> | <floating>} --> {<integer> | <floating>}
AABS:	AOP	IABS,FABS,FCERF,TRUE,FALSE

;Integer ABS, unary minus: <integer> --> <integer>
;IABS and IUMIN preserve DE and HL.
IABS:	LD	A,B
IABS1:	OR	A		;sign set iff (BC) <0
	RET	P		;return if > 0, otherwise perform unary minus
IUMIN:	CALL	BCDE		;arg to DE, DE to BC
UMIND:	CALL	CPLDE		;complement it
;BCDE exchanges BC and DE.
BCDE:	PUSH	BC
	LD	B,D
	LD	C,E
	POP	DE
	RET

;Integer addition and subtraction: <integer> x <integer> --> <integer>
ISUB:	CALL	CPLDE		;complement and add
	RET	C
IADD:	LD	A,D
	XOR	B		;sign (BC) xor sign (DE) to sign
	LD	A,B		;sign of BC to A7 in case agree
	EX	DE,HL		;arg2 to HL
	ADD	HL,BC
	LD	B,H
	LD	C,L		;(BC) + (DE) to BC
	JP	M,RETNC		;result ok if signs differ, return Carry reset
	XOR	B		;compare actual & desired result signs
	RET	P		;return if no overflow
STCR:	SCF
	RET

;Integer multiplication: <integer> x <integer> --> <integer>
IMUL:	CALL	SNFIX		;force BC, DE >= 0 and save desired result sign
	RET	C
	CALL	MULBD		;BC * DE to HL
	RET	C
IMUL1:	LD	B,H		;divid entry point
	LD	C,L		;result to BC
	ADD	HL,HL
	RET	C		;overflow if >= 2 ^ 15
	LD	A,(TEMP)
	JP	IABS1		;return according to desired sign

;Integer division (\): <integer> x <integer> --> <integer>
IDIVD:	CALL	SNFX0		;force BC >= 0, DE > 0
	JP	C,IOVER		;integer overflow if DE=0
	CALL	DIVD0		;quotient to HL, remainder to DE
	JP	IMUL1		;fix sign of result and return

;MOD: <integer> x <integer> --> <integer>
;X mod Y = sign(X) * [abs(X) mod abs(Y)], so X = [(X/Y)*Y] + [X mod Y].
OPMOD:	LD	H,B		;save desired result sign in H
	CALL	SNFX0		;force BC >= 0, DE > 0
	RET	C
	LD	A,H
	LD	(TEMP),A	;desired result sign to TEMP
	CALL	DIVD0		;remainder to DE
	EX	DE,HL		;result to HL
	JP	IMUL1		;and return according to desired sign

;Relations: {<integer>|<floating>|<string>} x {<integer>|<floating>|<string>}
;	--> <integer>
;Relations call CMPAR to set status bits and return 0 in BC.  The status
;bits are used to return if false (0), or decrement BC if true (-1).
EQUAL:	CALL	CMPAR		;compare and zero BC
	RET	NZ		;false iff zero reset
	DEC	BC		;true
	RET
NEQ:	CALL	CMPAR
	RET	Z		;false iff zero set
	DEC	BC
	RET
LTHAN:	CALL	CMPAR
	RET	NC		;false iff carry reset
	DEC	BC
	RET
GEQ:	CALL	CMPAR
	RET	C		;false iff carry set
	DEC	BC
	RET
LEQ:	CALL	CMPAR
	JP	C,LEQ1
	RET	NZ		;false iff carry reset and zero reset
LEQ1:	DEC	BC
	RET
GTHAN:	CALL	CMPAR
	RET	Z		;false if zero set
	RET	C		;false if carry set
	DEC	BC
	RET

;LOGOP is a macro to perform logical ops on B and D, and on C and E.
LOGOP	MACRO	LINST
	LD	A,B
	LINST	D		;;apply logical instruction to B and D
	LD	B,A		;;and result to B
	LD	A,C
	LINST	E		;;apply logical instruction to C and E
	LD	C,A		;;and result to C
	RET
	ENDM

;NOT, XOR: <integer> --> <integer>
OPNOT:	LD	DE,-1		;not is xor with -1
OPXOR:	LOGOP	XRA

;AND, RESET: <integer> x <integer> --> <integer>
	IF	NOT WILD
RESET:	CALL	STBT0
	CALL	CPLD1		;reset bit #(E) mod 16 of DE, then AND
	ENDIF
OPAND:	LOGOP	ANA

;OR, SET: <integer> x <integer> --> <integer>
	IF	NOT WILD
SETFN:	CALL	STBT0		;set bit #(E) mod 16 of DE, then OR
	ENDIF
OPOR:	LOGOP	ORA

;JOIN: <integer> x <integer> --> <integer>
	IF	NOT WILD
JOIN:	CALL	ISBYT		;check (B) = 0
	LD	B,D
	CALL	ISBYT		;check (D) = 0
	LD	B,C
	LD	C,E
	RET
	ENDIF

	IF	FLOAT AND NOT F9511
;INT: <floating> --> {<integer> | <floating>}
INT:
	IF	FPBCD
	LD	HL,FTEMP
	CALL	FSTOR		;save arg in FTEMP in case IINT fails
	ENDIF
	CALL	IINT		;try to convert to integer
	LD	A,INTST		;result type = integer
	RET	NC		;return if successful conversion to integer
	IF	FPBCD
	LD	HL,FTEMP
	CALL	FLOAD		;restore arg to FACC
	CALL	FINT		;truncate arg
	DEC	E
	JP	NZ,INT1		;no digits truncated, done
	LD	A,(FACC)
	OR	A
	JP	P,INT1		;truncated and positive, done
	LD	HL,FPONE
	CALL	FSUB		;truncated and negative, subract one for result
	ELSE			;NOT FPBCD
	CALL	FLINT		;get integer part of floating value
	LD	E,A
	ENDIF			;end of NOT FPBCD conditional
INT1:	LD	A,SNGST		;result type = floating
	RET

;IINT fixes a floating value to a two-byte integer value.
	IF	NOT FPBCD	;IINT is same as FFIX in FPBCD version
IINT:	LD	E,16
	CALL	FFIX		;fix floating point value
	RET	C		;cannot fix to integer, return Carry
	LD	C,B
	LD	B,A		;result to BC
	RET
	ENDIF			;end of NOT FPBCD conditional

;UNS: <integer> --> <floating>
	IF	FPBCD
	IF	NOT WILD
UNSFN:	LD	A,B
	OR	A
	PUSH	AF		;save arg sign
	CALL	FFLOT		;float the arg
	POP	AF
	RET	P		;arg was positive, done
	LD	HL,UNSMAX
	JP	FADD		;else result is 65536 + arg
UNSMAX:	DEFB	45H, 65H, 53H, 60H, 0, 0
	ENDIF
	ELSE			;NOT FPBCD
UNSFN:	XOR	A		;0 to A
	LD	DE,24		;0 to D, 24 to E
	JP	FFLOT		;float ABCD and return

FLINT:	LD	E,32
	CALL	FFIX		;try fixing to 3-byte integer
	LD	E,32		;scale factor to E
	JP	NC,FFLOT	;float the fixed value
	JP	FTEST		;fetch the floating value
	ENDIF			;end of NOT FPBCD conditional
	ENDIF

;FIRST, LAST: --> <integer>
	IF	ROMSQ AND (NOT WILD)
FIRST:	LD	HL,(SOURC)
	DEC	HL		;HL points to cr preceding source
	LD	B,H
	LD	C,L		;to BC
	RET
	ELSE
FIRST	EQU	EXERR		;EX error in non-ROMSQ versions
	ENDIF
	IF	ROMSQ		;LAST must be defined in WILD versions
LAST:	LD	DE,-1
	CALL	FINDL		;find line 65535
	LD	E,(HL)
	LD	D,0		;length to DE
	JP	FRE2		;last addr to BC
	ELSE
LAST	EQU	EXERR
	ENDIF

;MSBYTE, LSBYTE: <integer> --> <integer>
	IF	NOT WILD
MSBYT:	LD	C,B		;move ms to ls byte
LSBYT:	LD	B,0		;zero ms byte
	RET
	ENDIF

;BCD: <integer> --> <integer>
	IF	NOT WILD
BCD:	XOR	A
	CALL	CVTIS		;convert integer to string, no leading char
	CP	5
	JP	NC,FCER0	;length >= 5, nonfatal FC error and return 0
	LD	HL,0		;embryo value to HL
BCD1:	LD	A,(DE)		;fetch next char of string
	INC	DE		;and point to next
	SUB	'0'		;subtract ASCII bias
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL		;result left one nibble
	OR	L
	LD	L,A		;and new nibble ORed in
	DEC	C		;count down length
	JP	NZ,BCD1		;more chars in string
	LD	B,H
	LD	C,L		;result to BC
	RET
	ENDIF			;end of NOT WILD conditional
FCER0:	CALL	FCERN		;issue nonfatal FC error
	LD	BC,0
	LD	A,INTST		;and return integer 0 as result
	RET

;BIN: <integer> --> <integer>
	IF	NOT WILD
BIN:	LD	HL,0		;embryo value to HL
	CALL	BIN1		;sum high order byte
	LD	B,C
	CALL	BIN1		;sum low order byte
	LD	B,H
	LD	C,L		;result to BC
	RET
BIN1:	LD	A,B
	RRA
	RRA
	RRA
	RRA			;ms four bits to A3-A0
	CALL	BIN2		;add to sum
	LD	A,B		;ls four bits to A3-A0
BIN2:	AND	0FH		;mask off other bits
	CP	0AH
	JP	NC,FCERF	;not a bcd digit, FC error
	LD	D,H
	LD	E,L		;copy value to DE
	ENDIF			;end of NOT WILD conditional
;HL10A replaces (HL) with 10*(HL)+(A), and is called by GTDEC.
;Call:	DE,HL	value to multiply by 10
;	A	value to add to product
;Retn:	BC	preserved
;	DE	clobbered
;	HL	result
HL10A:	ADD	HL,HL		; * 2
	ADD	HL,HL		; * 4
	ADD	HL,DE		; * 5
	ADD	HL,HL		; * 10
	RET	C		;for GTDEC, never happens from BIN
	LD	E,A
	LD	D,0		;next value to DE
	ADD	HL,DE		;and added also
	RET

;GET, GET$: --> {<integer> | <string>}
GET:	LD	A,(GCHAR)	;value for GET is in GCHAR
	LD	C,A
	XOR	A
	LD	B,A		;value to BC
	LD	(GCHAR),A	;clear GCHAR
	IF	STRNG
	LD	D,'$'
	CALL	GTD		;look for $
	LD	A,INTST		;return type integer
	RET	C		;integer GET
	LD	A,C		;else string GET$
	LD	C,0
	OR	A		;Zero set iff no char in GET
	CALL	NZ,CHRS1	;copy char to string space
	LD	A,STRST		;and return type string
	RET
	ELSE			;NOT STRNG
	LD	A,INTST		;return type integer
	RET
	ENDIF

;IOBYTE: --> <integer>
	IF	(NOT CAMAC) AND (NOT WILD)
IOBYF:	LD	A,(IOBYT)
	JP	PEEK1		;return IOBYTE value in BC
	ENDIF

;PEEK: <integer> --> <integer>
	IF	NOT WILD
PEEK:	LD	A,(BC)		;fetch the byte
	ENDIF			;peek1 is needed for POS
PEEK1:	LD	B,0		;zero the MSbyte
	LD	C,A		;return value in BC
	RET

;POS: --> <integer>
	IF	NOT CAMAC
POS:	LD	A,(COLUM)
	JP	PEEK1		;return current column in BC
	ENDIF

;TEST: <integer> x <integer> --> <integer>
	IF	NOT WILD
TEST:	CALL	STBT0		;set bit # (E) mod 16 of DE
	CALL	OPAND		;AND with (BC) -- returns (C) in A
	OR	B		;zero set iff (BC) = 0
TEST1:	LD	BC,0		;return 0 if zero set
	RET	Z
	INC	BC		;return 1 if zero reset
	RET
	ENDIF

;SGN: {<integer> | <floating>} --> <integer>
SGN:	CALL	FETBC		;fetch arg
	IFTYP	FSGN,FCERF	;branch if noninteger
	LD	A,B
	OR	C		;Zero set iff (BC)=0
	RET	Z		;and result is 0
	LD	A,B
	OR	1		;Zero reset, minus set iff (BC) < 0
SGN1:	LD	BC,-1
	RET	M		;< 0, return -1
	INC	BC
	RET	Z		;= 0, return 0
	INC	BC
	RET			;else > 0, return 1
	IF	FLOAT AND NOT F9511
FSGN:	CALL	FTEST		;set status bits
	JP	SGN1		;and return as above
	ENDIF

;IN: <integer> --> <integer>
	IF	NOT WILD
IMPM:	CALL	READP		;read the port
	LD	C,A		;and return value read in BC
	RET
	ENDIF

;SENSE: <integer> x <integer> --> <integer>
	IF	NOT WILD
SENSE:	LD	D,7
	CALL	STBIT		;set bit # (E) mod 8 of E
	CALL	READP		;read port
	AND	E
	JP	TEST1		;return zero iff bit reset
	ENDIF

;FRE, FRE$: --> <integer>
FREFN:
	IF	STRNG
	LD	D,'$'
	CALL	GTD		;look for $
	JP	C,FRE		;not FRE$, just return FRE
	CALL	GARBG		;garbage collect to compact string space
	JP	FRE1		;and continue as below
	ENDIF
FRE:	LD	HL,(CSTKP)
	EX	DE,HL		;address of control stack top to DE
	INC	DE		;CSTKP + 1
	LD	HL,(SYMTA)	;symbol table address to HL
FRE1:	CALL	CPLDE		;- CSTKP - 1
FRE2:	ADD	HL,DE		;top - [bottom + 1] = available
	LD	B,H		;NB 'subtraction', so carry reset iff borrow
	LD	C,L		;result to BC
	RET

;LSHIFT: <integer> x <integer> --> <integer>
	IF	NOT WILD
LSHFT:	LD	A,E		;shift (BC) left by (E) mod 16 places
	AND	0FH
	LD	D,B
	LD	E,C		;BC to DE for STBI1
	CALL	STBI1		;shift (DE) left (A) bits
	LD	B,D
	LD	C,E
	RET
	ENDIF

;RSHIFT, ROTATE: <integer> x <integer> --> <integer>
	IF	NOT WILD
RSHFT:	LD	D,0		;shift (BC) right by (E) mod 16 places
	DEFB	21H		;lxi h, to skip ensuing two bytes
ROTAT:	LD	D,80H		;rotate / shift (BC) right by (E) mod 16 places
	LD	A,E		;entry point for rshft with (D) = 0
	AND	0FH		;mask E and clear carry
	RET	Z		;done if zero
	LD	E,A		;(E) mod 16 to E
ROTA1:	LD	A,B
	JP	NC,ROTA2
	OR	D		;turn on high bit if rotating and carry
ROTA2:	RRA
	LD	B,A		;carry now has high bit for C
	LD	A,C
	RRA			;carry now has high bit for B if rotating
	LD	C,A
	DEC	E
	JP	NZ,ROTA1	;keep rotating
	RET	NC		;done unless carry
	LD	A,B
	OR	D		;turn on high bit if rotating
	LD	B,A
	RET
	ENDIF			;end of NOT WILD conditional

	IF	REALT
;TIME:  <integer> --> <integer>
;TIME (0) returns current real time clock ticks in 20ths,
;TIME (1) returns current seconds,
;TIME (2) returns current minutes, and
;TIME (3) returns current hours.
;TIME (n) for any other n gives nonfatal FC error and returns 0.
TIMEC:	DEFB	20, 60, 60, 24	;TIMEX offsets
TIME:	LD	DE,4
	CALL	CMBDU
	JP	NC,FCER0	;nonfatal FC error if arg not 0 - 3
	LD	HL,TIMEX
	ADD	HL,BC		;address desired TIMEX component
	LD	A,(HL)		;and fetch current value
	LD	HL,TIMEC
	ADD	HL,BC		;address offset
	ADD	A,M		;current value + offset = correct current count
	LD	C,A		;result to BC
	RET
	ENDIF

;RND: --> <integer> [if nonFLOATing version]
;RND: <floating> --> <floating> [if FLOATing version]
;RND generates the next pseudorandom 16-bit integer
;	RANDX = (RANDA * RANDX + RANDC) mod 2 ^ 16, and returns the 15-bit
;	pseudorandom integer RANDX / 2.  Cf. Knuth Ch. 3, esp. pp. 155-6.
	IF	NOT WILD
RND:
	IF	FLOAT
	INC	BC
	PUSH	BC		;save pointer to arg
	IF	F9511
	LD	A,(BC)		;fetch first byte of arg
	OR	A		;Zero set iff arg is 0
	ELSE
	CALL	FTEST
	ENDIF
	JP	NZ,RND1		;nonzero arg, take it for multiplier
	LD	HL,FPONE	;zero arg, take 1 instead
	EX	(SP),HL
	ENDIF
RND1:	LD	HL,(RANDX)
	PUSH	HL
	EX	DE,HL		;(RANDX) to DE
	LD	A,RANDA SHR 8	;ms bits of RANDA to A
	CALL	MULT0		;ms(RANDA) * (RANDX) to HL
	LD	H,L
	LD	L,0		;and then * 2 ^ 8
	LD	DE,RANDC
	ADD	HL,DE		; + RANDC
	POP	DE		;(RANDX) to DE again
	LD	A,RANDA AND 255	;ls bits of RANDA to A
	CALL	MULTY		;(RANDA) * (RANDX) + RANDC to HL
	LD	(RANDX),HL	;and to RANDX
	IF	FLOAT
	IF	F9511
	LD	A,L
	OUT	(D9511),A	;low order to 9511 stack
	LD	A,H
	OUT	(D9511),A	;high order to stack
	XOR	A
	OUT	(D9511),A
	OUT	(D9511),A	;two high order 0s to stack
	LD	A,FLD95
	CALL	O9511		;float 32 bit integer
	IN	A,(D9511)	;read sign/exponent byte
	OR	A		;check if 0
	JP	Z,RND2
	SUB	16		;fudge exponent
	AND	7FH
RND2:	OUT	(D9511),A	;replace fudged sign and exponent
	POP	HL
	CALL	LOD95		;load the multiplier
	JP	FMUL		;multiply and return
	ELSE			;NOT F9511
	LD	B,H
	LD	C,L		;value to BC
	IF	FPBCD
	CALL	FFLOT		;float to value -32768 to 32767
	LD	HL,INTMN
	CALL	FSUB		;subtract -32768, giving 0 to 65535
	LD	HL,UNSMAX
	CALL	FDIV		;divide by 65536, giving range [0, 1)
	ELSE			;NOT FPBCD
	LD	DE,8		;0 to D, scale factor = 8 to E
	LD	A,D		;0 to A
	CALL	FFLOT		;float to random value in range [0,1)
	ENDIF			;end of NOT FPBCD conditional
	POP	HL		;arg to HL
	JP	FMUL		;result = arg * rnd and return
	ENDIF			;end of F9511 conditional
	ELSE			;NOT FLOAT
	OR	A
	LD	A,H
	RRA
	LD	B,A
	LD	A,L
	RRA
	LD	C,A		;return RANDX / 2
	RET
	ENDIF
	ENDIF			;end of NOT WILD conditional


;end of FNSOPS
	PAGE
;FP9511 12/21/79
;XYBASIC Interpreter Source Module
;Copyright (C) 1979 by Mark Williams Company, Chicago
;floating point package for 9511 chip

	IF	FLOAT AND F9511

;EQUates

;port numbers
	IF	C3885 AND NOT DEBUG
D9511	EQU	6		;9511 data port number for 3885
	ELSE
D9511	EQU	0		;9511 data port number
	ENDIF
C9511	EQU	D9511+1		;9511 control port number

;status bits
ERR95	EQU	1EH		;error status bits
CAR95	EQU	01H		;carry status bit
OVF95	EQU	02H		;overflow status bit
UND95	EQU	04H		;underflow status bit
ZER95	EQU	20H		;zero status bit
SGN95	EQU	40H		;sign status bit
BSY95	EQU	80H		;busy status bit

;function numbers
SQR95	EQU	01H		;SQR: <floating> --> <floating>
SIN95	EQU	02H		;SIN: <floating> --> <floating>
COS95	EQU	03H		;COS: <floating> --> <floating>
TAN95	EQU	04H		;TAN: <floating> --> <floating>
ATN95	EQU	07H		;ATN: <floating> --> <floating>
LOG95	EQU	09H		;LN: <floating> --> <floating>
EXP95	EQU	0AH		;EXP: <floating> --> <floating>
PWR95	EQU	0BH		;^: <floating> x <floating> --> <floating>
ADD95	EQU	10H		;+: <floating> x <floating> --> <floating>
SUB95	EQU	11H		;-: <floating> x <floating> --> <floating>
MUL95	EQU	12H		;*: <floating> x <floating> --> <floating>
DIV95	EQU	13H		;/: <floating> x <floating> --> <floating>
CHS95	EQU	15H		;unary -: <floating> --> <floating>
PTO95	EQU	17H		;push <floating> TOS to NOS
POP95	EQU	18H		;pop <floating> NOS to TOS
XCH95	EQU	19H		;exchange <floating> TOS and NOS
FLD95	EQU	1CH		;convert <32-bit integer> --> <floating>
FLT95	EQU	1DH		;convert <16-bit integer> --> <floating>
FXD95	EQU	1EH		;convert <floating> --> <32-bit integer>
FIX95	EQU	1FH		;convert <floating> --> <16-bit integer>
P1695	EQU	77H		;push <16-bit integer> TOS to NOS

;constants
FPONE:	DEFB	001H, 080H, 000H, 000H;floating point 1.
FPTEN:	DEFB	004H, 0A0H, 000H, 000H;floating point 10.
FPMAX:	DEFB	03FH, 0FFH, 0FFH, 0FFH;floating point max positive value
FPRND:	DEFB	06CH, 086H, 037H, 0BCH;floating point rounder .000 000 5
FPP01:	DEFB	07AH, 0A3H, 0D7H, 00AH;floating point .01

;floating point function routines
;addition
FADD:	LD	A,ADD95
	CALL	FADD1		;perform the addition
	RET	NC		;no error
	JP	FOVER		;overflow

;FADD1 adds floating TOS to NOS, returns Carry on overflow.
;When adding (subtracting) floating values, the result
;may be insignificant if the args arg of almost equal magnitude and
;the opposite (same) sign.  If the arg exponents differ by more than 1,
;this cannot occur.  But if the arg exponents differ by at most 1
;(i.e. -1, 0, 1) and the result exponent is at least SINDX less than
;the arg exponent, the result is insignificant and is replaced by 0.
FADD1:	LD	C,A		;save desired op in C
	CALL	EXNOS		;get NOS exponent
	LD	D,A		;save NOS exponent in D
	CALL	EXNOS		;get TOS exponent
	SUB	D		;TOS exponent - NOS exponent
	INC	A		;+1 so -1 0 1 become 0 1 2
	LD	E,A		;save arg exponent difference + 1 in E
	LD	A,C		;fetch desired op
	CALL	O9511		;perform the operation
	AND	ERR95		;check error status
	JP	NZ,FADD3	;overflow or underflow
	LD	A,E
	CP	3		;Carry reset unless arg diff was -1 0 1
	RET	NC		;arg diff too big, result must be ok
	CALL	EXTOS		;get result exponent
	SUB	D		;result exponent minus arg exponent
	OR	A		;reset Carry
	RET	P		;more significant result, ok
	CP	-SINDX
	RET	NC		;fewer than SINDX binary places lost
	JP	FZERO		;else result insignificant, take 0 instead
FADD3:	AND	UND95		;check for underflow
	SCF
	RET	Z		;overflow, return Carry
;FZERO replaces 9511 stacktop with floating point 0,
;setting status bits accordingly.
FZERO:	LD	A,PTO95
	CALL	O9511		;copy 9511 stacktop
	LD	A,SUB95
	JP	O9511		;subtract to give 0 and set flags

;FADD0 performs addition without significance testing.
FADD0:	LD	A,ADD95
;O9511 performs a 9511 operation and waits for its completion.
;Call:	A	desired 9511 function code
;Retn:	A, B	9511 status register after completion
;	CDEHL	Preserved
O9511:	OUT	(C9511),A	;issue 9511 command
OP95A:	IN	A,(C9511)	;read control port for 9511 status
	LD	B,A		;save control status in B
	AND	BSY95		;check if busy
	LD	A,B		;restore status value for error checking
	RET	Z		;done if not busy
	JP	OP95A		;wait if busy

;subtraction
FSUB:	LD	A,XCH95
	CALL	O9511		;exchange order of operands
FSUB0:	LD	A,SUB95
	CALL	FADD1		;perform the subtraction
	RET	NC		;no error
	JP	FOVER		;overflow

;multiplication
FMUL:	CALL	FMUL1		;perform multiplication
	RET	NC		;no overflow
	JP	FOVER		;else nonfatal OV error and return max
;FMUL1 does the work of floating multiplication.
;Retn:	Carry	Set iff overflow
FMUL1:	LD	A,MUL95
	CALL	O9511		;do the multiplication
	AND	ERR95		;check error status
	RET	Z		;no error
	AND	UND95		;mask to underflow bit
	JP	NZ,FZERO	;underflow, return 0
	SCF			;else return Carry set
	RET

;ABS
FABS:	IN	A,(D9511)	;read sign/exponent byte
	OUT	(D9511),A	;and restore
	AND	80H		;mask to sign
	RET	Z		;positive, just ignore the ABS
	;else fall through to change sign
;unary minus
FCHS:	LD	A,CHS95
	JP	O9511

;division
FDIVD:	EX	DE,HL		;arg2 pointer to HL
	INC	HL		;point to first value byte
	CALL	LOD95		;arg2 to 9511 stack
FDIV1:	LD	A,DIV95
	CALL	O9511		;perform division
	AND	ERR95		;check error status
	RET	Z		;no error
	AND	UND95		;mask to underflow
	JP	Z,FOVER		;overflow or division by 0, FC error
	JP	FZERO		;else underflow, return 0

;exponentiation
;If X is a positive integer between 0 and 255, A ^ X is computed by
;iterated multiplication.  Otherwise the 9511 routine for A ^ X is used.
FATOX:	INC	BC
	EX	DE,HL
	INC	HL
	PUSH	HL		;save X pointer
	PUSH	BC		;save A pointer
	CALL	LOD95		;fetch X to 9511 stack
	LD	A,PTO95
	CALL	O9511		;stack:  X, X
	LD	A,FIX95
	CALL	O9511		;stack:  int(X), X
	AND	OVF95
	JP	NZ,FATX2	;X much too big, use 9511
	IN	A,(D9511)	;read msbyte(int(X))
	OR	A
	IN	A,(D9511)	;read lsbyte(int(X))
	JP	NZ,FATX2	;int(X) > 255 or < 0, use 9511
	LD	E,A		;save int(X) in E
	OUT	(D9511),A
	XOR	A
	OUT	(D9511),A	;restore int(X) to stack
	LD	A,FLT95
	CALL	O9511		;stack:  flt(int(X)), X
	LD	A,SUB95
	CALL	O9511		;flt(int(X)) - X
	AND	ZER95
	JP	Z,FATX2		;flt(int(X)) <> X, use 9511
	LD	HL,FPONE
	CALL	LOD95		;floating point 1 to stack for protoresult
	INC	E		;X + 1
	POP	HL		;A pointer to HL
	POP	BC		;discard X pointer
FATX1:	DEC	E		;decrement power count
	RET	Z		;done
	PUSH	HL		;else save A pointer
	CALL	LOD95		;A to stack
	POP	HL		;restore A pointer
	CALL	FMUL1		;multiply A * result
	JP	NC,FATX1	;continue multiplying
	JP	FOVER		;else issue OV error and return
FATX2:	POP	HL		;recover A pointer
	CALL	LOD95		;fetch A to 9511 stack
	CALL	FARGP		;assure A > 0
	POP	HL		;recover X pointer
	CALL	LOD95		;X to 9511 stack
	LD	C,A		;save X sign/exp byte in C
	LD	A,PWR95
	JP	FEXP1		;continue as for EXP

;SQR
FSQR:	CALL	FARGP		;assure arg is positive
	LD	A,SQR95
	JP	O9511

;EXP
FEXP:	IN	A,(D9511)	;read sign/exp byte
	OUT	(D9511),A	;and restore
	LD	C,A		;save sign/exp in C
	LD	A,EXP95
FEXP1:	CALL	O9511		;perform the EXP
	AND	ERR95		;check error status
	RET	Z		;ok
	LD	A,C		;recover arg sign/exp byte
	AND	80H		;and mask to sign
	JP	NZ,FZERO	;small exponent, result is 0
FOVER:	ERROR	N, O, V		;issue nonfatal OV error
	IN	A,(C9511)	;read stacktop status
	AND	SGN95		;mask to sign
	PUSH	AF		;save sign -- Zero iff positive
	LD	HL,FPMAX
	CALL	LOD95		;load max floating value for result
	POP	AF		;recover desired result sign
	RET	Z		;positive, done
	JP	FCHS		;else change sign to minus

;LOG
FLN:	CALL	FARGP		;assure arg is positive
	LD	A,LOG95
	JP	O9511

;SIN
FSIN:	LD	A,SIN95
	JP	O9511

;COS
FCOS:	LD	A,COS95
	JP	O9511

;TAN
FTAN:	LD	A,TAN95
	CALL	O9511
	AND	ERR95		;check error status
	RET	Z		;no error
	JP	FOVER		;nonfatal OV error and return max value

;ATN
FATAN:	LD	A,ATN95
	JP	O9511

;UNS
UNSFN:	LD	A,C
	OUT	(D9511),A	;low order to 9511 stack
	LD	A,B
	OUT	(D9511),A	;high order to 9511 stack
	XOR	A
	OUT	(D9511),A
	OUT	(D9511),A	;two high order 0s to 9511 stack
	LD	A,FLD95
	JP	O9511		;float 32 bit integer value

;SGN
FSGN:	CALL	FET95		;fetch arg to ABCD
	LD	H,A		;save sign/exponent byte in H
	OR	B
	OR	C
	OR	D		;Zero set iff arg is 0
	RET	Z		;arg is 0, return 0 in BC
	LD	BC,1
	LD	A,H		;restore sign/exp byte
	AND	80H		;mask to sign
	RET	Z		;positive, return 1
	DEC	BC
	DEC	BC		;negative, return -1
	RET

;INT
;The result from the 9511 conversion function must be fudged for
;noninteger negative arguments.
INT:	LD	D,B
	LD	E,C		;save arg location in DE
	IN	A,(D9511)	;read arg sign/exp byte
	OUT	(D9511),A	;and restore
	LD	C,A		;save in C
	LD	A,FXD95
	CALL	O9511		;stack:  fix(arg)
	AND	OVF95
	RET	NZ		;arg very large, just return it
	LD	A,FLD95
	CALL	O9511		;stack:  float(fix(arg))
	LD	A,C		;recover arg sign/exp
	AND	80H		;mask to sign
	RET	Z		;arg positive, return float(fix(arg))
	LD	A,PTO95
	CALL	O9511		;stack:  float(fix(arg)), float(fix(arg))
	EX	DE,HL		;arg location to HL
	INC	HL		;point to arg
	CALL	LOD95		;stack:  arg, float(fix(arg)), float(fix(arg))
	CALL	FSUB0		;stack:	 float(fix(arg))-arg, float(fix(arg))
	IN	A,(C9511)	;read result status
	LD	C,A		;and save in C
	LD	A,POP95
	CALL	O9511		;stack:  float(fix(arg))
	LD	A,C
	AND	ZER95
	RET	NZ		;arg was negative integer, done
	LD	HL,FPONE
	CALL	LOD95		;else stack a 1
	JP	FSUB0		;and return float(fix(arg)) - 1


;routines

;FINP is called from GTLIT to perform floating point input.
;Call:	HL	TEXTP
;	TEMP	value sign (0 positive, 255 negative)
;Retn:	ABCD	floating point value
;Uses:	FPTMP	decimal point flag (0 or '.')
;	FPTMP+1	input exponent
FINP:	CALL	INP0		;value to 9511 stack
	JP	FET95		;fetch value to registers and return
INP0:	XOR	A
	OUT	(D9511),A
	OUT	(D9511),A
	OUT	(D9511),A
	OUT	(D9511),A	;0 to 9511 stack
	LD	(FPTMP),A	;decimal point flag initially 0
	LD	(FPTMP+1),A	;input exponent initially 0
INP2:	PUSH	HL		;save TEXTP
	LD	A,(HL)		;fetch next char
	LD	B,0		;decimal exponent 0 to B in case exit
	CP	'.'
	JP	Z,INP3		;decimal point
	CP	'E'
	JP	Z,INP4		;exponent
	CP	'E'+20H
	JP	Z,INP4		;allow lower case E for exponent also
	SUB	'0'		;subtract ASCII bias
	CP	10
	JP	NC,INP8		;nondigit, done
;digit scanned, add it to 10 * current value
	PUSH	AF		;save digit value
	CALL	LOD10		;floating 10 to 9511 stack
	CALL	FMUL1		;old value * 10
	JP	C,INPOV		;overflow
	POP	AF		;recover digit value
	OUT	(D9511),A	;to 9511 stack
	XOR	A
	OUT	(D9511),A	;high order 0 to 9511 stack
	LD	A,FLT95
	CALL	O9511		;float 16-bit integer value
	CALL	FADD0		;add to old value * 10
	LD	HL,FPTMP
	LD	A,(HL)		;fetch decimal point flag
	OR	A
	JP	Z,INP1		;no decimal point yet, continue scanning
	INC	HL
	DEC	(HL)		;else decrement input exponent
INP1:	POP	HL		;restore current TEXTP
	INC	HL		;address next char
	JP	INP2
;decimal point found, set decimal point flag
INP3:	LD	HL,FPTMP
	XOR	(HL)		;'.' if first decimal point, 0 if second
	LD	(HL),A		;set flag
	JP	NZ,INP1		;first
	JP	INP8		;second, exit
;process exponent
INP4:	POP	HL
	INC	HL		;address next char
	LD	A,(HL)		;and fetch
	LD	E,0		;exponent sign to E (0 minus, nonzero plus)
	CP	MINT
	JP	Z,INP5		;exponent sign -
	CP	'-'
	JP	Z,INP5		;exponent sign -
	LD	E,A		;set exponent sign +
	CP	PLUST
	JP	Z,INP5		;exponent sign +
	CP	'+'
	JP	NZ,INP6		;no sign, assume +
INP5:	INC	HL		;address next char
	LD	A,(HL)		;and fetch
INP6:	SUB	'0'		;subtract ASCII bias
	JP	Z,INP5		;ignore leading 0s
	LD	B,0		;possible exponent to B
	CP	10
	JP	NC,INP7		;not a decimal digit
	LD	B,A		;decimal exponent equals digit
	INC	HL		;address next char
	LD	A,(HL)		;fetch next
	SUB	'0'		;subtract ASCII bias
	CP	10
	JP	NC,INP7		;no more digits
	LD	C,A		;second decimal digit to C
	INC	HL
	LD	A,(HL)		;fetch next
	SUB	'0'
	CP	10
	JP	C,INPO1		;three significant digits, overflow
	LD	A,B		;msd of decimal exponent
	ADD	A,A		;2*msd
	ADD	A,A		;4*msd
	ADD	A,B		;5*msd
	ADD	A,A		;10*msd
	ADD	A,C		;10*msd+lsd
	LD	B,A		;to B
INP7:	PUSH	HL		;save next char address
	LD	A,E		;sign of decimal exponent
	OR	A
	JP	NZ,INP8		;positive
	SUB	B		;complement negative decimal exponent
	LD	B,A		;and restore to B
;finished
INP8:	POP	HL		;pop text pointer
	LD	(TEXTP),HL	;and reset TEXTP
	LD	HL,FPTMP+1	;address input exponent
	LD	A,(HL)		;and fetch
	ADD	A,B		;add decimal exponent
	LD	(HL),A		;and store adjusted exponent
	LD	A,(TEMP)	;fetch value flag
	OR	A
	CALL	NZ,FCHS		;complement value if negative
INP9:	LD	HL,FPTMP+1
	LD	A,(HL)		;fetch decimal exponent
	OR	A
	RET	Z		;zero, done
	JP	P,INP10		;positive, multiply value accordingly
	INC	(HL)		;negative, so increment
	CALL	LOD10		;load 10 to stack
	CALL	FDIV1		;and divide by 10
	JP	INP9		;and repeat
INP10:	DEC	(HL)		;decrement exponent
	CALL	LOD10		;load 10 to stack
	CALL	FMUL1		;multiply by 10
	JP	NC,INP9		;and repeat
	JP	FOVER		;overflow
INPOV:	POP	AF
	POP	HL		;recover TEXTP
	LD	E,1		;to indicate overflow, not underflow
INPO1:	INC	HL		;address next char
	LD	A,(HL)		;fetch next
	SUB	'0'
	CP	10
	JP	C,INPO1		;skip remaining digits
	LD	(TEXTP),HL	;reset TEXTP
	LD	A,E		;fetch exponent sign
	OR	A
	JP	Z,FZERO		;large neg exponent, return 0
	CALL	LOD10
	LD	A,(TEMP)
	OR	A
	CALL	NZ,FCHS		;make stacktop sign as desired
	JP	FOVER		;and issue nonfatal OV error

;FOUT converts the floating value on the 9511 stack to an ASCII string
;starting at BUFAD giving its decimal representation.
;The position of the last string char is on the stack within this routine.
;FPTMP contains the decimal exponent.
;The stacktop is preserved.
FOUT:	LD	HL,BUFAD	;destination to HL
	PUSH	HL		;save destination
	LD	(HL),' '	;store leading space
	LD	A,PTO95
	CALL	O9511		;copy arg to set Sign and Zero status flags
	AND	ZER95		;check if zero
	LD	(FPTMP),A	;0 to decimal exponent if nonzero
	LD	A,'0'		;ASCII 0 to A in case 0
	JP	NZ,OUT13	;arg is 0
	PUSH	HL		;save current address
	LD	A,B
	AND	SGN95		;check sign
	JP	Z,OUT1		;positive
	LD	(HL),'-'	;change leading char to minus sign
	CALL	FCHS		;change stacktop sign to positive
;To allow dollar and cent amounts, arg is unscaled if .01 <= arg < 1.
OUT1:	IN	A,(D9511)	;read stacktop exponent byte
	OUT	(D9511),A	;and restore it
	DEC	A		;so exp 0 becomes 255
	CP	79H
	JP	C,OUT2		;arg < .0078125 or >= 1, scale it
	JP	NZ,OUT4		;.015625 <= arg < 1, skip scaling
;Now .0078125 <= arg < .015625, so scale iff < .01
	LD	A,PTO95
	CALL	O9511		;copy arg
	LD	HL,FPP01
	CALL	LOD95		;stack:  .01, arg, arg
	CALL	FSUB0		;stack:  arg - .01, arg
	IN	A,(C9511)	;read result status
	AND	SGN95		;Zero set iff arg >= .01
	PUSH	AF
	LD	A,POP95
	CALL	O9511		;restore arg to TOS
	POP	AF
	JP	Z,OUT4		;arg >= .01, skip scaling
;TOS is scaled to [.1,1.) by multiplication or division by 10.
OUT2:	OR	A		;reset Carry
OUT2A:	IN	A,(D9511)	;read exponent
	OUT	(D9511),A	;and restore
	DEC	A		;decrement so 0 becomes 255
	LD	HL,FPTMP	;HL addresses decimal exponent
	JP	C,OUT2B		;skip multiply test after dividing in case .1
	CP	7DH
	JP	NC,OUT4		;value in range, done
	CP	3FH
	JP	C,OUT3		;value is > 1, divide it by 10
	DEC	(HL)		;decrement decimal exponent
	CALL	LOD10		;10 to 9511 stack
	CALL	FMUL1		;multiply value by 10
	JP	OUT2		;and repeat
OUT2B:	CP	3FH
	JP	NC,OUT4		;value is in range, scaling complete
OUT3:	INC	(HL)		;increment decimal exponent
	CALL	LOD10		;10 to 9511 stack
	CALL	FDIV1		;divide value by 10
	SCF
	JP	OUT2A		;and repeat, skipping multiply check
;scaling completed, add rounder
OUT4:	LD	HL,FPRND	;address the rounder
	CALL	LOD95		;rounder to stack
	CALL	FADD0		;add the rounder
	IN	A,(D9511)	;read the exponent
	OUT	(D9511),A	;and restore
	DEC	A
	CP	3FH
	JP	C,OUT2		;too big after rounding, refudge
;set digit counts
	LD	HL,FPTMP
	LD	A,(HL)		;fetch decimal exponent
	LD	E,A		;digits before decimal point to E
	CP	7		;compare to max
	JP	C,OUT5		;not too big
	LD	E,1		;else digits before decimal point is 1
OUT5:	SUB	E		;adjust decimal exponent
	LD	(HL),A		;and store
	LD	A,6		;total digit count
	SUB	E		;digits after decimal point
	INC	HL
	LD	(HL),A		;and store digits after decimal point
	DEC	E		;decrement digit count
	LD	A,E		;fetch digits before decimal point
	INC	HL
	LD	(HL),0		;initialize digit count
;add next digit to output string
OUT6:	LD	HL,FPTMP+2	;address digit count
	ADD	A,M
	LD	(HL),A		;store new count
	JP	M,OUT7		;counted out
	CALL	LOD10		;10 to 9511 stack
	CALL	FMUL1		;10 * value
	LD	A,PTO95
	CALL	O9511		;copy 10 * value
	LD	A,FIX95
	CALL	O9511		;fix 10 * value
	LD	A,P1695
	CALL	O9511		;copy 16-bit fixed value
	IN	A,(D9511)	;read high result and ignore
	IN	A,(D9511)	;read low result
	ADD	A,'0'		;add ASCII bias
	POP	HL		;last char address to HL
	INC	HL		;address next char
	PUSH	HL		;and save
	LD	(HL),A		;store new char
	LD	A,FLT95
	CALL	O9511		;float 16-bit value
	CALL	FSUB0		;subtract from 10 * value
	LD	A,255
	JP	OUT6		;decrement count and continue
OUT7:	LD	HL,FPTMP+1	;address digits after decimal point count
	LD	A,(HL)		;and fetch
	LD	(HL),255	;and reset to -1
	OR	A
	JP	M,OUT8		;count ran out, done
	POP	HL		;get last char address
	INC	HL		;point to next
	PUSH	HL
	LD	(HL),'.'	;store decimal point
	JP	OUT6		;repeat for digits after decimal point
;suppress trailing zeroes or trailing decimal point
OUT8:	POP	HL		;last char address to HL
OUT9:	LD	A,(HL)		;fetch last char
	DEC	HL
	CP	'0'
	JP	Z,OUT9		;suppress a trailing zero
	CP	'.'
	JP	Z,OUT10		;suppress trailing decimal point
	INC	HL		;restore last char address
;output decimal exponent
OUT10:	LD	A,(FPTMP)	;fetch decimal exponent
	OR	A
	JP	Z,OUT14		;zero, finished
	INC	HL
	LD	(HL),'E'	;exponent E to result string
	INC	HL
	LD	(HL),'+'	;possible exponent sign to result string
	JP	P,OUT11		;positive exponent
	LD	(HL),'-'	;sign to result
	CPL
	INC	A		;complement exponent to make positive
OUT11:	INC	HL
	LD	(HL),'0'-1	;embryo ASCII tens digit
OUT12:	INC	(HL)		;increment tens digit
	SUB	10		;reduce remainder
	JP	NC,OUT12	;repeat if more tens in exponent
	ADD	A,'0'+10	;restore units digit and add ASCII bias
OUT13:	INC	HL
	LD	(HL),A		;store units digit
;done, return length of result string in C and location in DE
OUT14:	LD	A,POP95
	CALL	O9511		;restore saved value
	INC	HL		;last+1
	LD	A,L		;to A
	POP	DE		;first to DE
	SUB	E		;length to A
	LD	C,A		;and to C
	RET

;INT95 converts floating value on 9511 stack to 16 bit integer value in BC.
;The result is the largest integer less than or equal to the arg.
;The value returned by the FIX95 function must be corrected for
;noninteger negative args and for -32768.
;Call:	TOS	floating value
;Retn:	Carry	Set iff overflow
;	BC	Converted value
;	TOS	floating value preserved
INT95:	LD	A,PTO95
	CALL	O9511		;copy arg
	LD	E,A		;save arg sign status in E
	LD	A,FIX95
	CALL	O9511		;fix arg
	AND	OVF95
	JP	NZ,INTOV	;overflow
	IN	A,(D9511)
	LD	B,A
	IN	A,(D9511)
	LD	C,A		;integer result to BC
	LD	A,E
	AND	SGN95		;recover arg sign
	RET	Z		;arg was positive, done
	LD	D,B
	LD	E,C		;save int(arg) in DE
	LD	A,PTO95
	CALL	O9511		;copy arg
	LD	A,E
	OUT	(D9511),A
	LD	A,D
	OUT	(D9511),A	;fix(arg)  returned to stack
	LD	A,FLT95
	CALL	O9511		;stack: float(fix(arg)), arg, arg
	LD	A,SUB95
	CALL	O9511		;stack: float(fix(arg))-arg, arg
	PUSH	AF		;save status
	LD	A,POP95
	CALL	O9511		;restore arg to TOS
	LD	B,D
	LD	C,E		;restore fix(arg) to BC
	POP	AF
	AND	ZER95
	RET	NZ		;float(fix(arg)) = arg, return fix(arg)
	DEC	BC		;otherwise decrement result
	RET			;and return
INTOV:	LD	BC,7FFFH
	LD	A,E		;fetch arg sign
	AND	SGN95
	SCF			;set Carry to indicate overflow
	RET	Z		;arg was > 0, return 32767
	CALL	FET95		;arg was <0, must check if -32768
	CP	90H		;-32768 is 90H, 80H, 00H, 00H
	JP	NZ,INTO1
	LD	A,B
	SUB	80H
	JP	NZ,INTO1
	OR	C
	OR	D
INTO1:	LD	BC,8000H	;-32768 to BC as result
	RET	Z		;return Carry reset if arg was -32768
	SCF			;else overflow, return Carry
	RET

;EXTOS returns the exponent of TOS, with the exponent sign
;extended to replace the mantissa sign in bit 7.
;EXNOS returns the exponent of NOS, leaving TOS and NOS exchanged.
EXNOS:	LD	A,XCH95
	CALL	O9511		;exchange TOS and NOS
EXTOS:	IN	A,(D9511)	;read sign/exp byte
	OUT	(D9511),A	;and restore
	RLA			;A7 in Carry, A6 A5 A4 A3 A2 A1 A0 C in A
	RLCA			;A6 in Carry, A5 A4 A3 A2 A1 A0 C A6 in A
	RRA			;A6 in Carry, A6 A5 A4 A3 A2 A1 A0 C in A
	RRA			;C  in Carry, A6 A6 A5 A4 A3 A2 A1 A0 in A
	RET

;LOD95 loads four bytes from M to the 9511 stack.
;LOD10 loads a floating point 10.
LOD10:	LD	HL,FPTEN
LOD95:	LD	BC,4		;byte count to BC
	ADD	HL,BC		;point past last byte
LOD9B:	DEC	HL		;address next byte to stack
	LD	A,(HL)		;fetch a byte
	OUT	(D9511),A	;write byte to 9511 stack
	DEC	C
	JP	NZ,LOD9B	;and stack more bytes
	RET

;FET95 fetches four bytes from the 9511 stack to ABCD.
FET95:	IN	A,(D9511)	;read data byte
	PUSH	AF		;and save
	IN	A,(D9511)
	LD	B,A		;second byte to B
	IN	A,(D9511)
	LD	C,A		;third byte to C
	IN	A,(D9511)
	LD	D,A		;fourth byte to D
	POP	AF		;restore first byte
	RET			;and return

;STO95 stores a floating value from ABCD to M.
STO95:	LD	(HL),A
	INC	HL
	LD	(HL),B
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),D
	RET

;FARGP assures that floating point value on 9511 stack is positive for SQR and
;Returns if positive, issues nonfatal FC error and complements before
;returning if negative.
FARGP:	IN	A,(D9511)	;read sign/exponent byte
	OUT	(D9511),A	;and replace
	AND	80H		;mask to sign
	RET	Z		;positive, just return
	CALL	FCERN		;else issue nonfatal FC error
	JP	FCHS		;change sign and return

	ENDIF

;end of FP9511
;FPBCD 11/19/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1980 by Mark Williams Company, Chicago
;BCD floating point package


	IF	FLOAT AND FPBCD
;
;   FORMAT:  6 BYTES
;      BYTE 0
;           BITS 0-6:  EXCESS-64 EXPONENT
;           BIT  7:  SIGN
;      BYTES 1-5:  10-DIGIT BCD FRACTION
;   N = (-1)^S * 10^(E - 64) * 0.DDDDDDDDDD
;
BIAS	EQU	64		;EXPONENT BIAS

;
;  CONSTANT DATA (ROMABLE)
;
EMAX:	DEFB	043H,014H,073H,0,0,0;MAX. EXP. ARGUMENT
FPMAX:	DEFB	07FH,099H,099H,099H,099H,099H
INTMX:	DEFB	045H,032H,076H,070H,0,0
INTMN:	DEFB	0C5H,032H,076H,080H,0,0
;
; CONSTANTS FOR USE IN FUNCTIONS
ATAN1:	DEFB	040H		;ARCTAN(1)
	DEFB	078H,053H,098H,016H,033H
D12PI:	DEFB	040H		;1/(2PI)
	DEFB	015H,091H,054H,094H,031H
D1LE4:	DEFB	040H		;1/(LOG E 4)
	DEFB	057H,056H,046H,027H,031H
D1L10:	DEFB	040H		;1/LN(10)
	DEFB	043H,042H,094H,048H,019H
D4PI:	DEFB	041H		;4/PI
	DEFB	012H,073H,023H,095H,045H
DPI2:	DEFB	041H		;PI/2
	DEFB	015H,070H,079H,063H,027H
DPI4:	DEFB	040H		;PI/4
	DEFB	078H,053H,098H,016H,034H
DSR22:	DEFB	040H		;SQR(2)/2
	DEFB	070H,071H,6,078H,010H
HALF:	DEFB	040H,050H,0,0,0,0
LN10:	DEFB	041H		;LN(10)
	DEFB	023H,2,058H,050H,093H
LN2:	DEFB	040H		;LN(2)
	DEFB	069H,031H,047H,018H,6
PI:	DEFB	041H,031H,041H,059H,026H,054H
SR2M1:	DEFB	040H		;SQR(2) - 1
	DEFB	041H,042H,013H,056H,020H
SR2P1:	DEFB	041H		;SQR(2) + 1
	DEFB	024H,014H,021H,035H,062H
SQR10:	DEFB	041H		;SQR(10)
	DEFB	031H,062H,027H,076H,060H
THIRD:	DEFB	040H,033H,033H	;1/3
	DEFB	033H,033H,033H
TWO:	DEFB	041H,020H,0
	DEFB	0,0,0
TWOPI:	DEFB	041H,062H,083H	;2 PI
	DEFB	018H,053H,7
;
;  COEFFICIENTS FOR FUNCTION EXPANSIONS
;
;  TANGENT
TB3:	DEFB	0C2H,015H,078H
	DEFB	030H,032H,084H
	DEFB	0C4H,014H,9
	DEFB	063H,024H,018H
	DEFB	0C2H,040H,098H
	DEFB	017H,8,075H
	DEFB	0C3H,015H,069H
	DEFB	020H,4,022H
	DEFB	0C2H,055H,020H
	DEFB	040H,041H,071H
	DEFB	0C1H,094H,038H
	DEFB	016H,055H,098H
TC0:	DEFB	03FH,035H,091H
	DEFB	010H,014H,097H
;  COSINE
FPONE:	DEFB	041H,010H,0
	DEFB	0,0,0
	DEFB	0C0H,030H,084H
	DEFB	025H,013H,075H
	DEFB	03FH,015H,085H
	DEFB	043H,044H,020H
	DEFB	0BDH,032H,059H
	DEFB	091H,089H,0
	DEFB	03BH,035H,090H
	DEFB	086H,0,0
CP05:	DEFB	0B9H,024H,061H
	DEFB	0,0,0
	DEFB	040H,078H,053H
	DEFB	098H,016H,034H
	DEFB	0BFH,080H,074H
	DEFB	055H,012H,019H
	DEFB	03EH,024H,090H
	DEFB	039H,045H,070H
	DEFB	0BCH,036H,057H
	DEFB	062H,0,0
CP14:	DEFB	03AH,031H,033H
	DEFB	0,0,0
;  ARCTAN
	DEFB	043H,021H,060H
	DEFB	062H,030H,079H
	DEFB	043H,032H,026H
	DEFB	062H,7,0
	DEFB	043H,013H,027H
	DEFB	2,039H,082H
FATP3:	DEFB	042H,012H,088H
	DEFB	083H,083H,3
	DEFB	043H,021H,060H
	DEFB	062H,030H,079H
	DEFB	043H,039H,046H
	DEFB	082H,083H,093H
	DEFB	043H,022H,010H
	DEFB	050H,088H,030H
FATQ3:	DEFB	042H,038H,050H
	DEFB	014H,086H,051H
;  EXP
EB2:	DEFB	042H,090H,0
	DEFB	0,0,0
	DEFB	042H,028H,0
	DEFB	0,0,0
	DEFB	043H,033H,0
	DEFB	0,0,0
	DEFB	0C5H,014H,058H
	DEFB	0,0,0
;  NATURAL LOG
LB3:	DEFB	0C1H,013H,012H
	DEFB	082H,059H,017H
	DEFB	0C1H,033H,050H
	DEFB	025H,024H,081H
	DEFB	0C1H,025H,084H
	DEFB	017H,087H,055H
	DEFB	0C0H,012H,087H
	DEFB	020H,099H,053H
	DEFB	0C1H,051H,002H
	DEFB	099H,053H,028H
	DEFB	0C1H,059H,041H
	DEFB	022H,044H,090H
LC0:	DEFB	040H,041H,079H
	DEFB	059H,018H,037H
;  SQUARE ROOT
	DEFB	040H,014H,053H
	DEFB	043H,0,051H
	DEFB	041H,018H,046H
	DEFB	072H,073H,095H
	DEFB	0C1H,018H,078H
	DEFB	050H,038H,016H
SR3:	DEFB	040H,090H,010H
	DEFB	015H,056H,4
;  SQUARE ROOT (X >= .25)
	DEFB	040H,025H,092H
	DEFB	080H,058H,067H
	DEFB	041H,010H,052H
	DEFB	3,026H,060H
SR6:	DEFB	0C0H,031H,063H
	DEFB	024H,089H,045H
;
;  BINARY-DECIMAL CONVERSION TABLE
BDTAB:	DEFB	0,0,1
	DEFB	0,0,2
	DEFB	0,0,4
	DEFB	0,0,8
	DEFB	0,0,016H
	DEFB	0,0,032H
	DEFB	0,0,064H
	DEFB	0,1,028H
	DEFB	0,2,056H
	DEFB	0,5,012H
	DEFB	0,010H,024H
	DEFB	0,020H,048H
	DEFB	0,040H,096H
	DEFB	0,081H,092H
	DEFB	1,063H,084H
	DEFB	3,027H,068H

;
;  ADDITION  (FACC) <== (FACC) + (H,L)
FADT2:	LD	HL,FTMP2
FADD:	LD	A,(HL)
	OR	A
	RET	Z		;OP-2 = 0
	LD	DE,FACC
	LD	A,(DE)
	OR	A
	JP	Z,FLOAD		;OP-1 = 0
FADD0:	XOR	(HL)
	PUSH	AF		;(SF) ==> SUBTRACT
	LD	A,(DE)
	AND	080H
	LD	(SIGN),A	;STORE SIGN OF OP-1
	LD	A,6
	LD	(FLEN),A	;DEFAULT LENGTH = 6
	LD	A,(HL)
	AND	07FH		;FORM EXP-2
	LD	(EXP2),A
	CALL	UPAC2
	LD	HL,EXP1
	LD	(HL),A
	INC	HL
	SUB	(HL)		;A <== EXP1 - EXP2
	LD	C,A
	LD	HL,FACC+5
	LD	(RSLT),HL	;SUM LOCATION
	CP	-10
	JP	NC,FAD1		;-10 <= DIFF < 0
	CP	11
	JP	C,FAD1		;0 <= DIFF <= 10
	OR	A
	JP	P,FAD9		;DONE IF DIFF > 10
;    DIFF < -10
	CALL	FZACC		;FACC <== 0
	LD	A,(EXP2)
	LD	(EXP1),A	;EXP1 <== EXP2
FAD1:	LD	B,0
	PUSH	BC
	EX	DE,HL		;(H,L) <== OP-2
	INC	HL		;POINT TO FRACTION
	LD	C,5
	LD	DE,ACALT+6
	CALL	FMOVE		;ACALT+6 <== OP-2 FRACTION
	LD	H,D		;(H,L) = (D,E) = OP-2
	LD	L,E
	POP	BC
	LD	A,C
	OR	A
	JP	Z,FAD8		;DIFF = 0
	JP	M,FAD4		;DIFF < 0
;     DIFF > 0
	AND	1
	JP	Z,FAD2		;EVEN
;        DIFF > 0 AND ODD
	INC	DE
	PUSH	BC
	LD	BC,6
	CALL	FD10		;DIV. OP-2 BY 10
	LD	HL,(RSLT)	;DESTINATION
	INC	HL		;INCR. IT
	POP	BC
	JP	FAD3
FAD2:	LD	HL,(RSLT)
FAD3:	LD	A,C
	RRA
	LD	C,A		;HALF OF DIFF
	ADD	HL,BC		;ADD BYTE SHIFT TO DEST.
	LD	(RSLT),HL
	LD	HL,FLEN
	ADD	A,M
	LD	(HL),A		;TOTAL FIELD LENGTH
	JP	FAD8
;     DIFF < 0
FAD4:	LD	HL,FACC+1
	AND	1
	JP	Z,FAD5		;EVEN
;     ODD AND < 0
	PUSH	BC
	LD	BC,6
	CALL	FD10		;FACC <==  FACC/10
	POP	BC
FAD5:	XOR	A
	LD	B,A		;B=0
	SUB	C		;A = -DIFF
	RRA			;A = BYTE SHIFT
	AND	07FH
	JP	Z,FAD7		;NO BYTE SHIFT
	LD	C,A		;(B,C) <== -DIFF/2
	ADD	HL,BC
	DEC	HL
	PUSH	DE
	CALL	FSTOR		;SHIFT FACC RIGHT
	POP	DE
FAD6:	DEC	HL
	LD	(HL),B		;CLEAR START OF FIELD
	DEC	C
	JP	NZ,FAD6
FAD7:	LD	A,(EXP2)
	LD	(EXP1),A	;EXP1 <== LARGER EXP
FAD8:	EX	DE,HL		;(H,L) <== OP-2
	LD	BC,4
	ADD	HL,BC
	EX	DE,HL		;(D,E) <== LOW END OP-2
	LD	HL,(RSLT)
	INC	C		;LOOP COUNTER = 6
	INC	C
	POP	AF		;XOR OF SIGNS
	JP	M,FSUB1		;SUBTRACT
	CALL	FADDL		;ADD LOOP
	CALL	FRNRM
	JP	FRND		;ROUND
FAD9:	POP	AF
	JP	FRND0
;  ADD LOOP
FADDL:	XOR	A		;CLEAR CARRY
FADL1:	LD	A,(DE)
	ADC	A,M
	DAA
	LD	(HL),A
	DEC	DE
	DEC	HL
	DEC	C
	JP	NZ,FADL1
	RET	NC		;DONE IF NO CARRY
FADL0:	LD	A,(HL)		;CARRY 1
	ADD	A,1
	DAA
	LD	(HL),A
	DEC	HL
	JP	C,FADL0
	RET
;
;  ABSOLUTE VALUE
FABS:	LD	HL,FACC
	LD	A,(HL)
	AND	07FH
	LD	(HL),A
	RET
;
;  ARCTAN
;  IF ABS(X) > 10 E 10 THEN FATAN(X) = SGN(X) * PI/2
;  IF ABS(X) <= 5 E -4 THEN FATAN(X) = X - X^3/3
;  ELSE  ABS(X) <= SQR(2) -1 :   X0=0, Y=X
;        ABS(X) > SQR(2) + 1 :   X0=INFINITY, Y = -1/X
;        SQR(2) - 1 < ABS(X) < SQR(2)+1:  X0=1, Y=(X-1)/(X+1)
;  FATAN(X) = FATAN(X0) + FATAN(Y) WHERE
;     FATAN(Y) = Y * P(Y^2)/Q(Y^2)
FATAN:	LD	HL,FACC
	LD	A,(HL)
	AND	080H
	LD	(SIGN1),A	;SAVE SIGN
	LD	A,(HL)
	AND	07FH
	LD	(HL),A		;X <== ABS(X)
	CP	BIAS+11
	JP	NC,FAT97	;EXP > 10
	CP	BIAS-4
	JP	C,FAT98		;EXP < -4
	JP	NZ,FAT0		;EXP > -4
	INC	HL		;EXP = -4
	LD	A,(HL)
	DEC	HL
	CP	6
	JP	C,FAT98		;Z <= 5 E (-4)
;     5 E (-4) < X < E 10
FAT0:	LD	HL,SR2M1	;SQR(2) - 1
	CALL	FCMP
	JP	NC,FAT1		;X > SQR(2) -1
;     X <= SQR(2) -1
	LD	HL,FTMP2
	LD	C,6
	CALL	FZERO		;X0 = 0 = ARCTAN(0)
	JP	FAT4
FAT1:	LD	HL,SR2P1
	CALL	FCMP
	JP	C,FAT2
;     X > SQR(2) + 1
	LD	HL,DPI2
	LD	DE,FTMP2
	CALL	FLOD1		;X0 = PI/2 = ARCTAN(INFINITY)
	CALL	FLINV		;FACC <== 1/X
	CALL	FCHS		;FACC <== -1/X
	JP	FAT4
;     SQR(2) - 1 < X < SQR(2) + 1
FAT2:	LD	HL,ATAN1
	LD	DE,FTMP2
	CALL	FLOD1		;X0 = ARCTAN(1)
	LD	HL,FPONE
	CALL	FADD		;FACC <== X+1
	CALL	FSTT1		;SAVE IN FTMP1
	LD	HL,TWO
	CALL	FSUB		;FACC <== X-1
	LD	HL,FTMP1
	CALL	FDIV		;FACC <== (X-1)/(X+1)
FAT4:	CALL	FSTT3		;FTMP3 <== Y
	CALL	FCO35		;FTMP1 <== Y^2
;     RATIONAL FUNCTION
;        DENOMINATOR
	LD	HL,FATQ3
	LD	C,3
	CALL	FPLY0
	CALL	FSTT4		;STORE DENOM. IN FTMP4
;        NUMERATOR
	LD	HL,FTMP1
	CALL	FLOAD
	LD	HL,FATP3
	LD	C,3
	CALL	FPOLY
	LD	HL,FTMP3
	CALL	FMUL		; *Y
	LD	HL,FTMP4
	CALL	FDIV		;P/Q
	CALL	FADT2		;+ARCTAN(X0)
FAT6:	LD	HL,FACC
	LD	A,(SIGN1)
	OR	(HL)		;APPEND SIGN
	LD	(HL),A
	RET
;     IF X > 1 E 10 THEN FATAN(X) = SGN(X) * PI/2
FAT97:	LD	HL,DPI2
	CALL	FLOAD
	JP	FAT6
;     IF X < 5 E (-4) THEN FATAN(X) = X - X^3/3
FAT98:	CALL	FSTT1		;STORE IN FTMP1
	CALL	FMUL		;SQUARE X
	LD	HL,FTMP1
	CALL	FMUL		;CUBE X
	LD	HL,THIRD
	CALL	FMUL
	LD	HL,FTMP1
	CALL	FSUB
	JP	FAT6
;
;  FLOATING POINT A TO X POWER
FATOX:	EX	DE,HL
	INC	HL
	LD	A,(FACC)
	OR	A
	JP	Z,FATX1		;0 TO POWER
	JP	M,FATX2		;NEG TO POWER
	PUSH	HL
FATX0:	CALL	FLN
	POP	HL
	CALL	FMUL
	JP	FEXP		;A^X = EXP (X * LN (A))
;     0 TO POWER
FATX1:	OR	(HL)
	JP	M,FOVER		;0 TO NEGATIVE
	RET
;     NEGATIVE TO POWER
FATX2:	PUSH	HL
	CALL	FSTT1		;SAVE A IN FTMP1
	POP	HL
	PUSH	HL
	CALL	FLOAD		;LOAD POWER
	CALL	FSTT2		;AND SAVE IN FTMP2
	CALL	FFIX		;GET INTEGER PART OF POWER
	POP	HL
	PUSH	BC		;AND SAVE INTEGER PART
	PUSH	HL
	CALL	FCMP
	POP	HL
	JP	NZ,FATX4	;NEGATIVE A TO NONINTEGER X
	CALL	FLONE		;LOAD 1 = A^0
	POP	DE		;INTEGER POWER TO DE
	LD	A,(FTMP2)
	OR	A
	RET	Z		;DONE IF POWER IS 0
	CALL	M,CPLDE		;COMPLEMENT POWER IF NEGATIVE
	LD	A,D
	OR	A
	JP	NZ,FOVER	;POWER TOO HIGH
FATX3:	LD	HL,FTMP1
	PUSH	DE
	CALL	FMUL
	POP	DE
	DEC	E
	JP	NZ,FATX3
	LD	A,(FTMP2)
	OR	A
	RET	P		;POSITIVE POWER, DONE
;FACC <== 1/FACC
FLINV:	CALL	FSTT1		;STORE FACC IN FTMP1
	CALL	FLONE		;LOAD 1
	LD	HL,FTMP1
	JP	FDIV		;INVERT
FATX4:	EX	(SP),HL		;POP SAVED POWER, PUSH POWER ADDRESS
	CALL	FCERN		;NONFATAL FC ERROR
	LD	HL,FTMP1
	CALL	FLOAD		;RELOAD A
	CALL	FCHS		;AND FORCE POSITIVE
	JP	FATX0		;RETURN -A ^ X AS RESULT
;
;  CHANGE SIGN
FCHS:	LD	HL,FACC
	LD	A,(HL)
	XOR	080H
	LD	(HL),A
	RET
;
;  COMPARE FACC WITH (H,L)
;     EXIT:  (CF) ==> FACC <= (H,L); (ZF) ==> EQUAL; ELSE >
FCMP:	LD	DE,FACC
	LD	A,(DE)
	OR	A
	JP	P,FCM0		;FACC >= 0
	XOR	(HL)
	SCF
	RET	M		;SIGNS DIFFER
	EX	DE,HL		;BOTH NEGATIVE
	JP	FCM1
FCM0:	OR	(HL)
	RET	M		;(H,L) <0
FCM1:	LD	C,6
FCM2:	LD	A,(DE)
	SUB	(HL)
	RET	C
	RET	NZ
	INC	HL
	INC	DE
	DEC	C
	JP	NZ,FCM2
	SCF
	RET
;
;  COSINE
;  X <== ABS (X) SINCE COS(-X) = COS(X)
;  X > 10 E 10 NOT PERMITTED
;  IF X > 2 * PI THEN X <== X MOD 2*PI
;  IF X > PI THEN X <== 2*PI - X
;  IF X > PI/2 THEN X <== PI -X AND SIGN FLAG IS SET
;       (I.E., COS(X) = - COS (PI - X) )
;  IF X <= PI/4 THEN Y = 4X/PI, COS(X) = POLYNOMIAL(Y^2)
;  IF PI/4 < X <= PI/2 THEN X1 = PI/2 - X, Y = 4*X1/PI,
;     COS(X) = SIN(X1) = Y * POLYNOMIAL(Y^2)
FCOS:	XOR	A
	LD	(SIGN1),A	;SET POSITIVE
	CALL	FABS		;COS(X) = COS(-X)
	CP	BIAS+11
	JP	NC,FCERN	;EXP >= 10 NOT VALID
	LD	HL,TWOPI
	CALL	FCMP
	JP	C,FCO1		;X <= 2 PI
;     IF X > 2 PI  THEN X <== X (MOD 2 PI)
	CALL	FSTT1		;STORE IN FTMP1
	LD	HL,D12PI
	CALL	FMUL		;DIV BY 2 PI
	CALL	FINT		;INTEGER PART
	LD	HL,TWOPI
	CALL	FMUL
	LD	HL,FTMP1
	CALL	FSUB		;MINUS X
	CALL	FCHS
FCO1:	LD	HL,PI
	CALL	FCMP
	JP	C,FCO2
;     IF X > PI THEN X <== 2 PI - X
	CALL	FCHS
	LD	HL,TWOPI
	CALL	FADD
FCO2:	LD	HL,DPI2
	CALL	FCMP
	JP	C,FCO3
;     IF X > PI/2 THEN X <== PI - X AND SIGN = NEGATIVE
	CALL	FCHS
	LD	HL,PI
	CALL	FADD
	LD	HL,SIGN1
	LD	A,(HL)
	XOR	080H
	LD	(HL),A
FCO3:	LD	HL,DPI4
	CALL	FCMP
	JP	C,FCO5		;X <= PI/4
;   PI/4 < X < PI/2
;     X0 = PI/2 - X; Y = (X0 * 4/PI)^2
	CALL	FCHS
	LD	HL,DPI2
	CALL	FADD		;PI/2 -X
	CALL	FCO34
	CALL	FCO35
;    EVAL. POLYNOMIAL
	LD	HL,CP14
	LD	C,4
	CALL	FPOLY
	LD	HL,FTMP2	;Y
	CALL	FMUL
FCO4:	LD	HL,FACC
	LD	A,(SIGN1)
	XOR	(HL)		;SET SIGN
	LD	(HL),A
	RET
;     X <= PI/4
;       Y = (4X/PI)^2
FCO5:	LD	HL,D4PI
	CALL	FMUL
	CALL	FCO35
;     EVAL POLYNOMIAL
	LD	HL,CP05
	LD	C,5
	CALL	FPOLY
	JP	FCO4
;     DIVIDE VARIABLE BY PI/4
FCO34:	LD	HL,D4PI
FC34A:	CALL	FMUL
	JP	FSTT2		;FTMP2 = 4X/PI
;     SQUARE FACC AND STORE AT FTMP1
FCO35:	CALL	FSTT1
	CALL	FMUL
	JP	FSTT1
;
;  FLOATING POINT DIVISION
;     FACC <== FACC / (H,L)
FDIVD:	EX	DE,HL
	INC	HL
FDIV:	LD	A,(HL)
	OR	A
	JP	Z,FOVER		;DIV BY 0
	CALL	UPAC1
	ADD	A,BIAS+1
	SUB	B		;GET RESULT EXPONENT
	JP	C,FZACC		;UNDERFLOW
	JP	Z,FZACC
	JP	M,FOVER		;OVERFLOW
	LD	(EXP1),A
	LD	HL,FTEMP
	LD	BC,5
	LD	(HL),B		;FTEMP 1ST BYTE = 0
	INC	HL
	INC	DE
	EX	DE,HL
	CALL	FMOVE		;FTEMP <== DIVISOR FRACTION
	LD	HL,FACC+1
	LD	DE,ACALT+2
	LD	C,5
FD0:	LD	A,(HL)		;ACALT+2 <== DIVIDEND FRACTION
	LD	(HL),B		;CLEAR FACC TO 0
	LD	(DE),A
	INC	HL
	INC	DE
	DEC	C
	JP	NZ,FD0
	PUSH	HL		;SAVE ACALT LOCATION
	LD	B,11		;NO. OF QUOTIENT DIGITS
;     DIVIDE LOOP
FD1:	LD	HL,FTEMP
	LD	DE,ACALT+1	;QUOTIENT LOCATION
	LD	C,6
FD2:	LD	A,(DE)
	CP	(HL)
	JP	C,FD5		;DIVIDEND < DIVISOR
	JP	NZ,FD3		;DIVISOR < DIVIDEND
	INC	DE
	INC	HL
	DEC	C
	JP	NZ,FD2
FD3:	LD	C,6		;DIVIDEND >= DIVISOR
	LD	HL,FTEMP+5
	LD	DE,ACALT+6
	SCF
;        SUBTRACT LOOP
FD4:	LD	A,099H
	ADC	A,0
	SUB	(HL)
	EX	DE,HL
	ADD	A,M
	DAA
	LD	(HL),A
	EX	DE,HL
	DEC	HL
	DEC	DE
	DEC	C
	JP	NZ,FD4
	POP	HL
	PUSH	HL
	INC	(HL)		;QUOTIENT DIGIT
	JP	FD1
FD5:	LD	HL,FACC+1
	DEC	B
	JP	NZ,FD6		; NEXT DIGIT
	LD	A,(HL)		;END OF DIVISION LOOP
	OR	A
	JP	NZ,FD7		;DONE
	LD	B,1		;LEADING 0 - DO ONE MORE DIGIT
	LD	HL,EXP1
	DEC	(HL)		;ADJUST EXP
	LD	HL,FACC+1
FD6:	LD	C,12
	CALL	FM10		;SHIFT RESULT INTO FACC
	JP	FD1
FD7:	LD	C,6
	CALL	FM10		;SHIFT RESULT INTO PLACE
	POP	HL		;CLEAR STACK
	JP	FRND
;  DIVIDE FLOATING POINT FIELD AT (H,L) BY 10
;     ENTRY: (B,C) = NO OF BYTES
;     EXIT;  (H,L) = START OF FIELD
FD10:	ADD	HL,BC		;(H,L) = LOW ORDER END
FD11:	DEC	HL
	LD	A,(HL)
	RRCA
	RRCA
	RRCA
	RRCA
	AND	0FH
	LD	B,A		;STORE ONE DIGIT
	DEC	HL
	LD	A,(HL)
	RLCA
	RLCA
	RLCA
	RLCA
	AND	0F0H
	OR	B		;APPEND DIGIT
	INC	HL
	LD	(HL),A
	DEC	C
	JP	NZ,FD11
	LD	(HL),B		;MAKE FIRST DIGIT 0
	RET
;
;  EXP FUNCTION
;  IF X = 0 THEN EXP(X) = 1
;  IF X < 0 THEN EXP(X) = 1 / EXP(-X)
;  ELSE   Z = INT (.5 + X/ LN(10))
;         Y = X / LN(10) - Z
;         B = Y / (4 LOG10 E)     I.E., 0 <= B < .3
;         A = 2 + B^2 * (P1/Q1)
;         EXP(B) = (A + B) / (A - B)
;         EXP(X) = 10^Z * (EXP(B))^4
FEXP:	LD	HL,EMAX
	CALL	FCMP
	JP	NC,FEX31	;> MAX
	XOR	A
	LD	(EXP4),A	;CLEAR INVERT FLAG AND SIGN
	LD	(SIGN1),A
	LD	HL,FACC
	OR	(HL)
	JP	Z,FLONE		;EXP(0) = 1
	JP	P,FEXP1
	LD	(EXP4),A	;FLAG NEGATIVE ARGUMENT
	AND	07FH
	LD	(HL),A		;MAKE ABS VALUE
FEXP1:	LD	HL,D1L10
	CALL	FMUL		;T = X / LN(10)
	CALL	FSTT2		;FTMP2 <== T
	LD	HL,HALF
	CALL	FADD
	CALL	FFIX		;A = INT(.5 + T)
	PUSH	BC		;SAVE INT PART
	CALL	FCHS
	CALL	FADT2		;FRAC PART
	LD	HL,D1LE4	;DIVIDE BY 4 LOG E
	CALL	FC34A		;FTMP2 <== Y
	CALL	FCO35		;FTMP1 = T = Y^2
;     EVALUATE CONTINUED FRACTION
	LD	HL,EB2
	CALL	FTAN6
	LD	HL,FTMP4
	CALL	FLOAD		;LOAD P1
	LD	HL,FTMP3
	CALL	FDIV		;P1/Q1
	LD	HL,FTMP1
	CALL	FMUL		; *T
	LD	HL,TWO
	CALL	FADD		; +2
	CALL	FSTT3		;FTMP3 = A = 2 + T(P1/Q1)
	LD	HL,FTMP2	;Y
	CALL	FSUB
	CALL	FSTT4		;FTMP4 = A - Y
	LD	HL,FTMP3
	CALL	FLOAD		;Y
	LD	HL,FTMP2
	CALL	FADD		;FACC = A + Y
	LD	HL,FTMP4
	CALL	FDIV		; (A+Y) / (A - Y)
	CALL	FCO35		;SQUARE
	CALL	FCO35		;4TH POWER
	CALL	FLONE		;LOAD 1
	POP	BC		;GET POWER OF 10
	INC	C
	LD	A,C
	ADD	A,BIAS
	LD	(FACC),A	;FACC = 10 TO POWER
	LD	HL,FTMP1
	CALL	FMUL		;MULT BY E TO POWER
	JP	FTAN5		;SEE WHETHER TO INVERT
FEX31:	CALL	FCERN		; > MAX
	LD	HL,FPMAX
	JP	FLOAD
;  CONVERT FACC TO 16-BIT BINARY INTEGER IN (B,C)
FFIX:	LD	HL,INTMX
IINT	EQU	FFIX		;IINT IS SAME AS FFIX IF FPBCD
	CALL	FCMP
	JP	NC,FFIX1	;OVERFLOW
	LD	HL,INTMN
	CALL	FCMP
	JP	Z,FF0		;-32768
	JP	C,FFIX2		;UNDERFLOW
;     RANGE OK
FF0:	LD	HL,FACC
	LD	A,(HL)
	OR	A
	JP	NZ,FF1
	LD	BC,0		;ZERO VALUE
	RET
FF1:	PUSH	AF		;SAVE SIGN
	CALL	FINT
	LD	A,C
	OR	A
	JP	NZ,FF3		;NONZERO INTEGER PART
;     INTEGER PART 0
	POP	AF
	RET	P		;RETURN IF POSITIVE
	DEC	BC		;NEGATIVE FRACTION
	JP	FF6
FF3:	POP	AF		;REMOVE SAVED SIGN
	LD	D,C		;D = NO. OF INTEGER DIGITS
	LD	HL,0		;(H,L) = BINARY ACCUMULATOR
	LD	BC,FACC+1	;(B,C) = LOC OF FRACTION
FF4:	LD	A,(BC)		;CONVERSION LOOP
	RRA
	RRA
	RRA
	RRA
	CALL	FF7		;LEFT DIGIT
	JP	Z,FF5		;END OF INTEGER DIGITS
	LD	A,(BC)
	CALL	FF7		;RIGHT DIGIT
	INC	BC		;NEXT BYTE
	JP	NZ,FF4		;LOOP
FF5:	LD	B,H
	LD	C,L		;(B,C) <== VALUE
	LD	A,(FACC)
	OR	A
	RET	P		;NOT NEGATIVE
	ADD	HL,DE		;IF NEGATIVE ROUND DOWN
	LD	B,H
	LD	C,L
	XOR	A		;2'S COMPLEMENT
	SUB	C
	LD	C,A
	LD	A,0
	SBC	A,B
	LD	B,A
FF6:	PUSH	BC
	CALL	FFLOT		;FACC <== INTEGER PART
	POP	BC		;VALUE
	XOR	A		;CLEAR CARRY
	RET
FF7:	PUSH	DE		;ADD CURRENT DIGIT TO BINARY TOTAL
	ADD	HL,HL		;(H,L) <== (H,L) * 10
	LD	E,L
	LD	D,H
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,DE
	AND	0FH		;GET DIGIT
	LD	E,A
	LD	D,0
	ADD	HL,DE		;ADD NEW DIGIT
	POP	DE
	DEC	D
	RET
FFIX1:	LD	BC,32767	;OVERFLOW
	JP	FF8
FFIX2:	LD	BC,-32768	;UNDERFLOW
FF8:	CALL	FF6
	SCF
	RET
;
;  FLOAT BINARY VALUE IN (B,C)
;     RESULT IN FACC
FFLOT:	PUSH	BC
	LD	C,11
	LD	HL,FACC
	CALL	FZERO
	POP	BC
	LD	(SIGN),A	;POSITIVE
	LD	DE,BDTAB-3	;CONVERSION TABLE
	OR	B
	JP	M,FFL0		;VALUE <0
	JP	NZ,FFL1		;>0
	CP	C
	RET	Z
	JP	FFL1
FFL0:	AND	080H
	LD	(SIGN),A	;NEGATIVE
	XOR	A		;NEGATE (B,C)
	SUB	C
	LD	C,A
	LD	A,0
	SBC	A,B
	LD	B,A
;     SHIFT (B,C) RIGHT
FFL1:	LD	A,B
	OR	A		;TEST FOR 0 AND CLEAR CARRY
	JP	NZ,FFL2		;B IS NOT 0
	LD	A,C		;B=0
	OR	A
	JP	NZ,FFL3
;     DONE WHEN (B,C) = 0
	LD	HL,EXP1
	LD	(HL),BIAS+6
	JP	FNORM		;NORMALIZE
FFL2:	RRA			;B <== B/10
	LD	B,A
	LD	A,C
FFL3:	RRA			;C <== C/10
	LD	C,A
	INC	DE		;NEXT PLACE IN TABLE
	INC	DE
	INC	DE
	JP	NC,FFL1		;0-BIT
;     ON 1-BIT ADD VALUE FROM TABLE
	PUSH	DE
	PUSH	BC
	INC	DE
	INC	DE
	LD	HL,FACC+3
	LD	C,3
	CALL	FADDL		;ADD DECIMAL VALUE
	POP	BC
	POP	DE
	JP	FFL1
;
;  INPUT FLOATING POINT VALUE FROM STRING
;     RESULT IN FACC
FINP:	LD	(TEXTP),HL	;SAVE STRING POINTER
	CALL	FINP0
	LD	HL,(TEXTP)
	JP	BAKUP		;BACK UP THE TEXT POINTER
FINP0:	LD	HL,FACC
	LD	C,12
	CALL	FZERO
	LD	B,A		;B = 0 = EXPONENT
	LD	E,A		;E = 0 = SIG DIGIT FLAG
	LD	(SIGN),A
	INC	A
	LD	D,A		;D = DEC. POINT FLAG = 1
FIN00:	CALL	FINC		;GET CHARACTER
	JP	C,FIN1B		;NON NUMERIC
FIN0:	CP	'0'
	JP	NZ,FIN2		;NONZERO DIGIT
	JP	FIN00		;SKIP A LEADING 0
FIN1:	CALL	FINC
FIN1A:	JP	NC,FIN2		;DIGIT
FIN1B:	CP	'9'+1
	JP	NC,FIN3		;>9
	CP	'.'
	JP	NZ,FIN7		; END OF STRING
	XOR	A
	CP	D
	JP	Z,FIN7		; 2 DEC. POINTS
	LD	D,A		;FLAG FOR DEC. POINT
	JP	FIN1
;     PROCESS DIGIT
FIN2:	SUB	'0'		;MAKE NUMERIC
	LD	C,A
	LD	A,(FACC+2)
	AND	0F0H
	JP	NZ,FIN22	;10 DIGITS ALREADY IN
	PUSH	BC
	LD	HL,FACC+1
	LD	C,6
	CALL	FM10		;FACC <== FACC * 10
	POP	BC
	LD	A,C		;NEW DIGIT
	ADD	A,M		;ADD IN NEW DIGIT
	LD	(HL),A
	LD	A,C		;RECOVER NEW DIGIT
	OR	E
	LD	E,A		;SIG FLAG NONZERO IF SIG DIGIT SEEN
	LD	A,D		;FETCH DEC PT FLAG
	OR	A
	JP	Z,FIN21		;DEC PT SEEN
	INC	B		;DEC PT NOT SEEN YET, BUMP EXPONENT
FIN21:	LD	A,E		;FETCH SIG DIGIT FLAG
	OR	A
	JP	NZ,FIN1		;TRY NEXT DIGIT
	DEC	B		;PAST DEC PT AND NO SIG DIGIT, DCR EXPONENT
	JP	FIN1
;MORE THAN 10 SIGNIFICANT DIGITS
FIN22:	LD	A,D		;FETCH DECIMAL POINT FLAG
	DEC	A
	JP	NZ,FIN23	;PAST DECIMAL POINT, LEAVE EXPONENT UNCHANGED
	INC	B		;BUMP EXPONENT FOR DIGIT
FIN23:	CALL	FINC		;FETCH ANOTHER CHAR
	JP	C,FIN1B		;NONDIGIT
	JP	FIN22		;ANOTHER DIGIT
FIN3:	CP	'E'
	JP	Z,FIN4
	CP	'E'+20H		;LOWER CASE E
	JP	NZ,FIN7		;NOT VALID CHARACTER
;     PROCESS EXPONENT
FIN4:	LD	C,0		;EXP. DIGIT COUNT
	LD	E,C		;BUILD EXPONENT IN E
	CALL	FINC		;GET CHAR
	JP	NC,FIN4C	;DIGIT
	CP	MINT
	JP	Z,FIN4A		;TOKENIZED MINUS SIGN
	CP	PLUST
	JP	Z,FIN4B		;TOKENIZED PLUS SIGN
	CP	'+'
	JP	Z,FIN4B		;PLUS SIGN
	CP	'-'
	JP	NZ,SNERR	;NOT DIGIT, PLUS, MINUS -- SYNTAX ERROR
FIN4A:	LD	A,080H		;MINUS
	LD	(SIGN),A
FIN4B:	CALL	FINC
	JP	C,SNERR		;SYNTAX ERROR IF NONDIGIT FOLLOWS SIGN
FIN4C:	CP	'0'
	JP	NZ,FIN5
	CALL	FINC		;GET CHAR AFTER LEADING EXPONENT 0
	JP	C,FIN6		;EXPONENT IS 0
	JP	FIN4C		;CHECK FOR ANOTHER LEADING 0
FIN5:	INC	C
	SUB	'0'
	ADD	A,E		;ADD TO EXPONENT
	LD	E,A
	CALL	FINC
	JP	C,FIN6		;END
	PUSH	AF		;ANOTHER EXP. DIGIT
	LD	A,C
	CP	3
	JP	Z,FIN5A		;TOO MANY DIGITS
	LD	A,E		;E <== E * 10
	ADD	A,A
	LD	E,A
	ADD	A,A
	ADD	A,A
	ADD	A,E
	LD	E,A
	POP	AF
	JP	FIN5
FIN5A:	POP	AF
FIN6:	LD	A,(SIGN)
	OR	A
	JP	Z,FIN7A		;EXP >= 0
	LD	A,B		;NEGATE EXPONENT
	SUB	E
	ADD	A,BIAS
	JP	M,FZACC		;UNDERFLOW
	JP	Z,FZACC
	JP	FIN8
FIN7:	LD	E,0
FIN7A:	LD	A,B		;FORM TOTAL EXPONENT
	ADD	A,E
	ADD	A,BIAS
	JP	M,FOVER		;OVERFLOW
FIN8:	LD	(EXP1),A
	LD	HL,FACC
	LD	C,6
FIN9:	INC	HL		;FIND NONZERO BYTE
	LD	A,(HL)
	OR	A
	JP	NZ,FIN10
	DEC	C
	RET	Z		;ZERO RESULT
	JP	FIN9
FIN10:	LD	DE,FACC+1	;NORMALIZE
	CALL	FLOD1		;MOVE OVER TO START OF FACC
	LD	A,(DE)
	CP	010H
	JP	NC,FIN11
	LD	HL,FACC+1
	LD	C,6
	CALL	FM10		;HALF BYTE SHIFT
FIN11:	LD	HL,EXP1
	LD	A,(TEMP)	;SIGN
	AND	080H
	OR	(HL)		;APPEND EXP.
	LD	(FACC),A
	XOR	A
	RET
;     GET CHARACTER FROM STRING
;     CF = 1 ==> NOT NUMERIC
FINC:	LD	HL,(TEXTP)
	LD	A,(HL)
	INC	HL
	LD	(TEXTP),HL	;NEW TEXT POINTER
	CP	'0'
	RET	C		;<0
	CP	'9'+1
	CCF
	RET
;
;  FACC <== INTEGER PART (TRUNCATED)
;  EXIT:  (D,E) = 1 IFF NONZERO DIGITS WERE TRUNCATED
;         (B,C) = NO. OF INTEGER DIGITS
FINT:	XOR	A
	LD	E,A
	LD	D,A
	LD	B,A
	LD	HL,FACC
	OR	(HL)
	RET	Z		;ZERO
	LD	E,1		;FRACTION FLAG
	AND	07FH		;GET EXPONENT
	SUB	BIAS
	JP	Z,FZACC		;PURE FRACTION
	JP	M,FZACC
	LD	E,0
	CP	10
	RET	NC		;ALREADY INTEGER
	PUSH	AF		;SAVE NO. OF DIGITS
	OR	A
	RRA
	PUSH	AF		;(CF) = 1 IF ODD
	LD	C,A
	ADD	HL,BC
	INC	HL		;(H,L)= LOW END OF INTEGER PART
	LD	A,5
	SUB	C
	LD	C,A		;C = NO OF BYTES TO CLEAR
	POP	AF
	JP	NC,FINT2	;EVEN
	LD	A,(HL)		;CLEAR RIGHT DIGIT OF BYTE
	AND	0FH
	JP	Z,FINT3		;NO FRACTION DIGIT
	LD	E,1
	LD	A,(HL)
	AND	0F0H
	LD	(HL),A
	JP	FINT3
FINT2:	LD	A,(HL)
	OR	A
	JP	Z,FINT3		;ALREADY 0
	LD	E,1		;FLAG NONZERO FRACTION
	LD	(HL),0		;CLEAR BYTE
FINT3:	INC	HL
	DEC	C
	JP	NZ,FINT2
	POP	AF		;NO. OF DIGITS
	LD	C,A
	RET
;
;  NATURAL LOG
; X = 10^A * Y WHERE .1 <= Y < 1
; Y = 2^M * Z WHERE 1/2 <= Z < 1, M=0,-1,-2,-3
; V = T * T
; LN (V) = LN (1+T)/(1-T) = T * P2(V) / Q2(V)
; LN (X) = A * LN (10) + (M - 1/2) * LN (2) + LN (1+T)/(1-T)
FLN:	LD	HL,FPONE
	CALL	FCMP
	JP	Z,FZACC		;LN(1) = 0
	LD	HL,FACC
	LD	A,(HL)
	OR	A
	JP	M,FL94		;LOG OF NEGATIVE
	JP	Z,FCERN		;LOG OF 0
	LD	(HL),BIAS	;MAKE PURE FRACTION
	SUB	BIAS
	LD	(EXP3),A	;STORE UNBIASED EXP
	LD	C,0
FL0:	INC	HL
	LD	A,(HL)
	CP	050H
	JP	NC,FL1		;FRAC >= .5
	PUSH	BC
	DEC	HL
	PUSH	HL
	LD	HL,FTEMP
	CALL	FSTOR
	CALL	FADD		;X <== 2*X
	POP	HL
	POP	BC
	INC	C		;COUNT
	JP	FL0
FL1:	LD	HL,EXP4
	LD	(HL),C		;SAVE SCALE FACTOR
	CALL	FSTT1		;FTMP1 = SCALED FRACTION
	LD	HL,DSR22
	CALL	FADD		;ADD SQR(2)/2
	CALL	FSTT2
	LD	HL,FTMP1
	CALL	FLOAD
	LD	HL,DSR22
	CALL	FSUB
	LD	HL,FTMP2
	CALL	FDIV		;T = (Y - SQR(2)/2) /(Y + ...)
	CALL	FSTT2		;FTMP2 = T
	CALL	FCO35		;FTMP1 = T^2
;     LOG ((1+T)/(1-T)) = CONTINUED FRACTION
	LD	HL,LB3
	CALL	FTAN7
	LD	HL,LC0
	CALL	FADD
	LD	HL,FTMP2
	CALL	FMUL		;T * P/Q
	CALL	FSTT1
	LD	A,(EXP3)
	LD	C,A
	LD	B,0		;(B,C) = EXP
	OR	A
	JP	P,FL2
	DEC	B		;SIGN EXTEND
FL2:	CALL	FFLOT
	LD	HL,LN10
	CALL	FMUL		;FACC <== EXP * LN(10)
	CALL	FSTT2
	LD	A,(EXP4)	;M
	LD	C,A
	LD	B,0
	CALL	FFLOT
	LD	HL,HALF
	CALL	FADD
	LD	HL,LN2
	CALL	FMUL		;FACC <== -(M - 1/2) * LN(2)
	CALL	FCHS
	CALL	FADT2
	LD	HL,FTMP1
	JP	FADD
FL94:	AND	07FH		;LOG OF NEGATIVE
	LD	(HL),A		;MAKE POSTIVE
	CALL	FCERN
	JP	FLN
;
;  LOAD FACC FROM (H,L)
;     EXIT:  (D,E) = FACC
FLONE:	LD	HL,FPONE	;LOAD 1
FLOAD:	LD	DE,FACC
FLOD1:	LD	C,6
;     MOVE FIELD FROM (H,L) TO (D,E)
FMOVE:	PUSH	DE
FMOV1:	LD	A,(HL)
	LD	(DE),A
	INC	HL
	INC	DE
	DEC	C
	JP	NZ,FMOV1
	POP	DE
	RET
;
;  F.P . MULTIPLY   FACC <== FACC * (H,L)
FMUL:	LD	A,(HL)
	OR	A
	JP	Z,FZACC		;OP-2 = 0
	CALL	UPAC1
	ADD	A,B		;GET RESULT EXP
	SUB	BIAS-1
	JP	Z,FZACC		;UNDERFLOW
	LD	(EXP1),A	;STORE EXP
	EX	DE,HL
	LD	DE,FTEMP
	LD	C,6
	CALL	FMOVE		;MOVE OP-2 TO FTEMP
	EX	DE,HL
	LD	(HL),0
	LD	BC,5
	ADD	HL,BC		;(H,L) = LOW END OF OP-2
	PUSH	HL
	LD	HL,HOLD4
	CALL	FSTOR		;HOLD4 <== OP-1
	DEC	HL		;(H,L) = END OF HOLD3
	LD	B,3
	EX	DE,HL
FM2:	LD	HL,6
	ADD	HL,DE		;(H,L) <== END OF HOLD(I+1)
	LD	C,6
	OR	A		;CLEAR CARRY
FM3:	LD	A,(HL)		;HOLD(I) <== 2 * HOLD(I+1)
	ADC	A,A		;DOUBLE IT
	DAA
	LD	(DE),A
	DEC	DE
	DEC	HL
	DEC	C
	JP	NZ,FM3
	DEC	B
	JP	NZ,FM2
	CALL	FZACC		;CLEAR FACC
	POP	HL		;(H,L) <== OP-2
	PUSH	HL
	CALL	FMLOP		;MULT LOOP FOR RIGHT DIGITS
	LD	HL,FACC+1
	LD	C,10
	CALL	FD10		;FACC <== FACC/10
	LD	HL,FTEMP+1
	LD	C,5
	CALL	FD10
	POP	HL
	CALL	FMLOP		;MULT LOOP FOR LEFT DIGITS
	JP	FNORM		;NORMALIZE
;   MULTIPLY LOOP
;     FACC <== HOLD1 * RIGHT DIGITS OF FTEMP
FMLOP:	LD	C,5		;OUTER LOOP COUNTER
	LD	DE,FACC+11	;PRODUCT LOCATION
	PUSH	DE
	PUSH	HL		;END OF MULTIPLIER
FML1:	POP	DE
	LD	A,(DE)		;GET MULTIPLIER DIGIT
	DEC	DE		;NEXT DIGIT
	POP	HL		;SUM LOCATION
	DEC	HL
	PUSH	HL		;NEXT SUM LOCATION
	PUSH	DE		;NEXT MPR. DIGIT
	LD	DE,HOLD1+5
	AND	0FH		;DIGIT
	RLCA			;PUT IN LEFT NIBBLE
	RLCA
	RLCA
	RLCA
FML2:	OR	A
	JP	Z,FML4		;SKIP LOOP ON ZERO DIGIT
	PUSH	HL		;ACCUM LOCATION
	ADD	A,A		;DOUBLE DIGIT
	LD	B,A
	JP	NC,FML3		;NO ADD ON 0 BIT
	PUSH	BC
	PUSH	DE
	LD	C,6
	CALL	FADDL		;ACCUMULATE PRODUCT
	POP	DE
	POP	BC
FML3:	LD	HL,6
	ADD	HL,DE		;NEXT HOLD BUFFER
	EX	DE,HL
	POP	HL		;ACCUM. LOCATION
	LD	A,B		;GET DIGIT
	JP	FML2		;INNER LOOP
FML4:	DEC	C
	JP	NZ,FML1		;OUTER LOOP (NEXT DIGIT)
	POP	HL
	POP	HL		;CLEAR STACK
	RET
;  MULTIPLY FLOATING POINT VALUE AT (H,L) BY 10
;   ENTRY:  C = NO OF BYTES IN FIELD
FM10:	LD	A,(HL)
	AND	0FH
	RLA
	RLA
	RLA
	RLA
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	RRA
	RRA
	RRA
	RRA
	AND	0FH
	DEC	HL
	OR	(HL)
	LD	(HL),A		;STORE DIGIT PAIR
	INC	HL
	DEC	C
	JP	NZ,FM10
	DEC	HL
	AND	0F0H		;LAST DIGIT = 0
	LD	(HL),A
	RET
;
;  NORMALIZE
FNORM:	LD	HL,FACC+1
	LD	C,0
FN0:	LD	A,(HL)		;FIND HIGHEST NON-0 DIGIT
	OR	A
	JP	NZ,FN1
	INC	C		;COUNT ZEROS
	INC	C
	INC	HL
	JP	FN0
FN1:	XOR	A
	CP	C
	JP	Z,FN2		;FIRST BYTE NON-0
	DEC	HL
	PUSH	BC
	CALL	FLOAD		;MOVE FRACTION LEFT
	POP	BC
	LD	HL,FACC+1
FN2:	LD	A,(HL)
	AND	0F0H
	JP	NZ,FN3		;DONE
	INC	C
	PUSH	BC
	LD	BC,6
	CALL	FM10		;SHIFT LEFT 1/2 BYTE
	POP	BC
FN3:	LD	HL,EXP1
	LD	A,(HL)
	SUB	C		;ADJUST EXP.
	JP	Z,FZACC		;UNDERFLOW TO 0
	JP	C,FZACC
	JP	M,FOVER		;OVERFLOW
	LD	(HL),A
	JP	FRND
;
;  OUTPUT FROM FLOATING POINT TO STRING
FOUT:	LD	HL,BUFAD	;RESULT ADDRESS
	PUSH	HL		;SAVE ORIG. BUFAD
	PUSH	HL		;CURRENT CHAR. POINTER
	LD	HL,FACC
	LD	A,(HL)
	OR	A
	JP	NZ,FOU1
	POP	HL		;ZERO VALUE
	LD	(HL),' '	;OUTPUT ' 0'
	INC	HL
	LD	(HL),'0'
	LD	C,2
	POP	DE
	RET
FOU1:	AND	080H		;SIGN
	LD	(SIGN),A
	LD	A,(HL)
	AND	07FH
	LD	(EXP1),A	;STORE EXP.
	LD	(HL),0		;MAKE FACC PURE FRACTION
	LD	HL,FACC+5
	CALL	FRND1		;ROUND TO 8 PLACES
	POP	HL
	LD	B,' '		;OUTPUT LEADING ' ' OR '-'
	LD	A,(SIGN)
	OR	A
	JP	P,FOU2
	LD	B,'-'
FOU2:	LD	(HL),B
	LD	C,1		;CHAR. COUNT
	INC	HL
	LD	A,(EXP1)
	SUB	BIAS		;UNBIASED EXPONENT
	LD	E,A		;E = EXP
	LD	B,A		;B = INTEGER DIGIT COUNTER
	JP	M,FOU3		;EXP < 0
	JP	Z,FOU3		;EXP = 0
	CP	9
	JP	C,FOU4		;EXP <= 8
FOU3:	LD	(HL),'.'	;LEADING POINT
	INC	C
	INC	HL
	CP	-7
	JP	C,FOU4		;LARGE NEG EXPONENT, USE E NOTATION
FOU3A:	LD	(HL),'0'	;ELSE STORE 0 AFTER .
	INC	C
	INC	HL
	INC	A
	JP	NZ,FOU3A
	LD	E,0		;RESET EXPONENT TO 0
FOU4:	PUSH	HL		;SAVE OUTPUT POINTER
	LD	HL,FACC
	LD	D,4		;BYTE COUNTER
;      OUTPUT DIGITS
FOU5:	INC	HL		;(H,L) = POINTER TO FACC
	LD	A,(HL)
	RRA			;LEFT DIGIT
	RRA
	RRA
	RRA
	AND	0FH
	EX	(SP),HL		;(H,L) <== OUTPUT POINTER
	CALL	FOUT1		;OUTPUT DIGIT
	EX	(SP),HL
	LD	A,(HL)
	EX	(SP),HL
	AND	0FH		;RIGHT DIGIT
	CALL	FOUT1
	EX	(SP),HL
	DEC	D
	JP	NZ,FOU5
	POP	HL		;CHAR POINTER
FOU6:	DEC	HL		;BACK UP TO LAST CHAR
	DEC	C
	LD	A,(HL)
	CP	'.'
	JP	Z,FOU7		;DELETE TRAILING POINT
	CP	'0'
	JP	Z,FOU6		;BACK UP TO NONZERO
	INC	HL
	INC	C
;     SEE IF 'E' NOTATION NEEDED
FOU7:	LD	A,E
	OR	A
	JP	M,FOU8
	CP	9
	JP	C,FOU12		;0 <= EXP <= 8
;     OUTPUT 'E' AND EXPONENT
FOU8:	LD	(HL),'E'
	INC	HL
	INC	C
	OR	A
	JP	P,FOU9
	LD	(HL),'-'	;NEGATIVE EXP
	INC	HL
	INC	C
	XOR	A
	SUB	E		;MAKE EXP POSITIVE
FOU9:	CP	10
	JP	C,FOU11		;ONE-DIGIT EXP
;  GET FIRST DIGIT OF EXP
	LD	D,0		;D <== EXP/10
FOU10:	SUB	10
	INC	D
	CP	10
	JP	NC,FOU10
	LD	E,A		;E <== REMAINDER
	LD	A,D
	ADD	A,'0'
	LD	(HL),A		;OUTPUT FIRST DIGIT
	INC	HL
	INC	C
	LD	A,E
FOU11:	ADD	A,'0'
	LD	(HL),A
	INC	C
FOU12:	POP	DE		;(D,E) = BUFAD
	RET
;     OUTPUT DIGIT
FOUT1:	ADD	A,'0'		;MAKE CHARACTER
	LD	(HL),A
	INC	C		;CHAR COUNT
	INC	HL
	DEC	B		;INTEGER COUNT
	RET	NZ
	LD	(HL),'.'	;DECIMAL POINT
	INC	C
	INC	HL
	RET
;  OVERFLOW
FOVER:	ERROR	N,O,V
	LD	HL,FPMAX
	CALL	FLOAD		;LOAD MAX VALUE
	LD	HL,FACC
	LD	A,(SIGN)
	OR	(HL)		;APPEND SIGN
	LD	(HL),A
	RET
;
;  EVALUATE POLYNOMIAL
;    ENTRY:  FTMP1 = VARIABLE,  (C) = DEGREE, (H,L) = HIGHEST ORDER COEFFICIENT
; P(Y) = (...(Y*CN+ C(N-1)) * Y + ...) * Y + C0
FPOLY:	PUSH	BC
	PUSH	HL
	CALL	FMUL		;MULT BY HIGHEST COEFFICIENT
	JP	FPLY1
FPLY0:	PUSH	BC
	PUSH	HL
	CALL	FADD
	LD	HL,FTMP1
	CALL	FMUL		;MULT BY VARIABLE
FPLY1:	POP	HL
	POP	BC
	LD	DE,-6
	ADD	HL,DE		;NEXT COEFFICIENT
	DEC	C		;DEGREE COUNT
	JP	NZ,FPLY0
	JP	FADD		;ADD LAST COEFFICIENT
;  RENORMALIZE
FRNRM:	LD	HL,FACC
	LD	A,(HL)
	OR	A
	RET	Z		;NO RENORM NEEDED
	LD	BC,7
	CALL	FD10		;SHIFT RIGHT 1/2 BYTE
	LD	HL,EXP1		;INCR. EXP
	INC	(HL)
	JP	M,FOVER		;OVERFLOW
	RET
;
;  ROUND FLOATING POINT VALUE
FRND:	LD	HL,ACALT
	CALL	FRND1
FRND0:	LD	HL,SIGN
	LD	A,(EXP1)
	OR	(HL)		;REPACK RESULT
	LD	(FACC),A
	RET
FRND1:	LD	A,(HL)
	ADD	A,050H
	DAA
	RET	NC		;DONE IF NO CARRY
	DEC	HL
	CALL	FADL0		;CARRY ONE
	JP	FRNRM		;RENORMALIZE
;
;  SINE FUNCTION
; IF ABS(X) < 4 E (-7) RETURN X
; ELSE SIN (X) = COS (X - PI/2)
FSIN:	LD	HL,FACC
	LD	A,(HL)
	AND	07FH		;GET EXP
	CP	039H
;     IF ABS(X) < 4 E (-7) THEN RETURN X
	RET	C		;EXP < -7
	JP	NZ,FS0
	INC	HL
	LD	A,(HL)
	CP	040H
	RET	C
;     ELSE SIN(X) = COS (X - PI/2)
FS0:	LD	HL,DPI2
	CALL	FSUB
	JP	FCOS
;
;  SQUARE ROOT
; X = Y * 10^A WHERE .1 <= Y < 1
; B <== INT (A/2)
; C <== (A - 2*B) * SQR(10)
; Z0 <== POLYNOMIAL(Y)
; Z1 <== 1/2 (Z0 + Y/Z0), ETC.
; SQR(X) = Z * 10^B * SQR(10) IF C=1
;        = Z * 10^B IF C = 0
FSQR:	LD	HL,FACC
	LD	A,(HL)
	OR	A
	CALL	M,FCERN		;SQR OF NEGATIVE
	AND	7FH
	LD	(HL),A		;FORCE POSITIVE
	SUB	BIAS		;UNBIAS EXP
	RRA			;A <== EXP/2
	PUSH	AF		;SAVE EVEN/ODD FLAG
	LD	(SIGN1),A	;STORE EXP/2
	LD	(HL),BIAS	;SET EXP TO 0
	CALL	FSTT1		;SAVE X
	INC	HL
	LD	A,(HL)
	CP	025H
	JP	NC,FSQ4		;X > .25
;     X <= .25
	LD	HL,SR3
	LD	C,3
FSQ0:	CALL	FPOLY		;POLYNOMIAL
;     2 NEWTON-RAPHSON ITERATIONS
	CALL	FSQ2
	CALL	FSQ2
	POP	AF		;EVEN/ODD FLAG
	JP	NC,FSQ1		;EVEN
	LD	HL,SQR10
	CALL	FMUL		;IF ODD MULT BY SQR(10)
FSQ1:	LD	HL,FACC
	LD	A,(SIGN1)	;GET EXP/2
	ADD	A,M
	LD	(HL),A		; SET RESULT EXP
	RET
;     NEWTON-RAPHSON ITERATION
;       Z1 =   (X/Z0 + Z0) * .5
FSQ2:	CALL	FSTT2		;STORE Z
	LD	HL,FTMP1
	CALL	FLOAD
	LD	HL,FTMP2
	CALL	FDIV		;X/Z0
	LD	HL,FTMP2
	CALL	FADD
	LD	HL,HALF
	JP	FMUL
;     X > .25
FSQ4:	LD	HL,SR6
	LD	C,2
	JP	FSQ0
;
;  STORE FACC AT (H,L)
;     EXIT:  (H,L) = DESTINATION FIELD
FSTT4:	LD	HL,FTMP4
	JP	FSTOR
FSTT3:	LD	HL,FTMP3
	JP	FSTOR
FSTT2:	LD	HL,FTMP2
	JP	FSTOR
FSTT1:	LD	HL,FTMP1
FSTOR:	PUSH	BC
	LD	BC,5
	ADD	HL,BC		;(H,L) = LOW END OF FIELD
	INC	BC
	LD	DE,FACC+5
FST0:	LD	A,(DE)
	LD	(HL),A
	DEC	DE
	DEC	HL
	DEC	C
	JP	NZ,FST0
	INC	HL
	POP	BC
	RET
;
;  FLOATING POINT SUBTRACTION		FACC <== FACC - (H,L)
FSUB:	LD	A,(HL)
	OR	A
	RET	Z		;OP - 2 = 0
	LD	DE,FACC
	LD	A,(DE)
	OR	A
	JP	Z,FSUB0		;SUBTRACT FROM 0
	XOR	080H		;REVERSE SIGN
	JP	FADD0
FSUB0:	CALL	FLOAD		;LOAD OP-2
	JP	FCHS
;  SUBTRACT LOOP
FSUB1:	LD	A,(FLEN)
	LD	C,A		;LENGTH OF LOOP
	SCF
FSU2:	EX	DE,HL
	LD	A,099H
	ADC	A,0
	SUB	(HL)
	EX	DE,HL
	ADD	A,M
	DAA
	LD	(HL),A
	DEC	HL
	DEC	DE
	DEC	C
	JP	NZ,FSU2
	JP	C,FSU4		;FORM CORRECT
	LD	HL,(RSLT)
	LD	A,(FLEN)
	LD	C,A
	SCF
FSU3:	LD	A,099H		;RECOMPLEMENT
	ADC	A,0
	SUB	(HL)
	OR	A		;CLEAR ACY
	DAA
	LD	(HL),A
	DEC	HL
	DEC	C
	JP	NZ,FSU3
	LD	HL,SIGN
	LD	A,(HL)
	XOR	080H		;REVERSE SIGN ON RECOMPLEMENT
	LD	(HL),A
FSU4:	LD	HL,FACC+1
	LD	C,7
FSU5:	LD	A,(HL)		;CHECK FOR 0 RESULT
	OR	A
	JP	NZ,FNORM	;NORMALIZE NON-0
	INC	HL
	DEC	C
	JP	NZ,FSU5
	RET			;RETURN 0
;
;  TANGENT
; STORE SIGN AND MAKE ABS VALUE
; Y <== 4X/PI
; R <== FRAC(Y)
; A <== INT(Y) (MOD 4)
; IF A > 2 THEN REVERSE SIGN
; IF A IS ODD, R <== 1-R
; IF A = 1 OR 2 (MOD 4) SET COTAN FLAG
; Y <== R * PI/4
; T <== Y * Y
; TAN (X) = X * (C0 + P2(T)/Q2(T))
; IF FLAG IS SET, TAKE COTAN I.E. 1/TAN
; APPEND SIGN
FTAN:	XOR	A
	LD	(EXP4),A	;CLEAR COTAN FLAG
	LD	HL,FACC
	LD	A,(HL)
	AND	080H		;GET SIGN
	LD	(SIGN1),A
	LD	A,(HL)
	AND	07FH		;GET EXP
	LD	(HL),A		;MAKE ABS. VALUE
	CALL	FCO34		;FTMP2 <== 4X/PI
	LD	HL,INTMX
	CALL	FCMP
	JP	NC,FCERN	;VALUE TOO LARGE
	CALL	FFIX		;GET INTEGER PART
	PUSH	BC		;SAVE INT PART
	CALL	FCHS		;GET FRAC PART
	CALL	FADT2		;R = FRAC PART
	POP	BC
	LD	A,C
	AND	3		;A <== INT PART (MOD 4)
	CP	2
	JP	C,FTAN2
	LD	HL,SIGN1	;IF > 2 (MOD 4) REVERSE SIGN
	PUSH	AF
	LD	A,(HL)
	XOR	080H
	LD	(HL),A
	POP	AF
FTAN2:	PUSH	AF
	RRA
	JP	NC,FTAN3	;EVEN
	CALL	FCHS		;IF ODD, R = 1 - R
	LD	HL,FPONE
	CALL	FADD
FTAN3:	POP	AF
	INC	A
	AND	2
	JP	Z,FTAN4		;A WAS 0 OR 3 (MOD 4)
	LD	(EXP4),A	;IF 1 OR 2 (MOD 4) SET COTAN FLAG
FTAN4:	LD	HL,DPI4
	CALL	FC34A		;FTMP2 = Y = R * PI/4
	CALL	FCO35		;FTMP1 = Y^2
	LD	HL,TB3
	CALL	FTAN7		;EVAL. CONTINUED FRAC.
	LD	HL,TC0
	CALL	FADD
	LD	HL,FTMP2
	CALL	FMUL		;*Y
FTAN5:	LD	A,(EXP4)	;GET INVERT FLAG
	OR	A
	CALL	NZ,FLINV	;INVERT IF DESIRED
	JP	FAT6		;APPEND SIGN
;     EVALUATE CONTINUED FRACTION
; P1 <== C2 (X + B3)
; Q1 <== (X + B2) (X + B3) + C3
; P2 <== C1 * Q1
; Q2 <== (X + B1) * Q1 + P1
FTAN6:	PUSH	HL
	CALL	FADD		;X + B3
	CALL	FSTT3		;FTMP3 = X + B3
	POP	HL
	LD	DE,6
	ADD	HL,DE		;NEXT COEFFICIENT
	PUSH	HL
	CALL	FMUL		;* C3
	CALL	FSTT4		;FTMP4 = P1
	LD	HL,FTMP1
	CALL	FLOAD		;X
	POP	HL
	LD	DE,6
	ADD	HL,DE
	PUSH	HL
	CALL	FADD		;+ B2
	LD	HL,FTMP3
	CALL	FMUL		; * (X + B3)
	POP	HL
	LD	DE,6
	ADD	HL,DE
	PUSH	HL
	CALL	FADD		; + C3
	CALL	FSTT3		;FTMP3 = Q1
	POP	HL
	RET
FTAN7:	CALL	FTAN6
	PUSH	HL
	LD	HL,FTMP1
	CALL	FLOAD		;X
	POP	HL
	LD	DE,6
	ADD	HL,DE
	PUSH	HL
	CALL	FADD		; + B1
	LD	HL,FTMP3
	CALL	FMUL		; * Q1
	LD	HL,FTMP4
	CALL	FADD		; + P1
	CALL	FSTT4		; FTMP4 = Q2
	LD	HL,FTMP3
	CALL	FLOAD		; Q1
	POP	HL
	LD	DE,6
	ADD	HL,DE
	CALL	FMUL		; * C1 = P2
	LD	HL,FTMP4	; P2/Q2
	JP	FDIV
;
;  ZERO OUT FACC
FZACC:	LD	C,6
	LD	HL,FACC
;  ZERO OUT FLOATING POINT FIELD AT (H,L)
FZERO:	XOR	A
FZER1:	LD	(HL),A
	INC	HL
	DEC	C
	JP	NZ,FZER1
	RET
;
;  UNPACK FLOATING POINT OPERANDS FOR DIV. AND MULT.
UPAC1:	AND	07FH		;GET EXP-2
	LD	B,A		;SAVE EXP-2 IN B
	LD	DE,FACC
	LD	A,(DE)
	OR	A
	JP	NZ,UNP1
;     OP-1 = 0
	INC	SP		;EXIT FROM CALL
	INC	SP
	RET			;RETURN 0
UNP1:	XOR	(HL)		;GET RESULT SIGN
	AND	080H
	LD	(SIGN),A
UPAC2:	EX	DE,HL		;(D,E) = OP-2
	LD	A,(HL)
	PUSH	AF		;SAVE EXP-1
	LD	(HL),0		;FACC <== PURE FRACTION
	LD	HL,ACALT
	LD	C,7
	CALL	FZERO		;CLEAR ACALT
	POP	AF
	AND	07FH		;EXP-1
	RET

	ENDIF

;end of module FPBCD
;INOUT 12/05/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;input / output & error routines

;WRITC writes a character from A.
;Call:	A	char to be written
;Retn:	A,BC,DE,HL	preserved
;The character is sent to the CON device if (OMODE) = 0.
;The char is also sent to the LST device if (LMODE) <> 0.
;The char is sent to the disk (in CP/M nonCOMPL version) if (AMODE) <> 0.
;COLUM gives the print column of the last char written (line of width WIDTH).
;A crlf is written if the current char causes COLUM > WIDTH.
;A linefeed is preceeded by (NULLS) nulls.
	IF	NOT WILD
;WRTS0 is called by print routines to print trailing space after numbers.
WRTS0:	LD	HL,(COLUM)	;column to L, width to H
	LD	A,L
	CP	H
	RET	Z		;suppress trailing space if in last column
	ENDIF
WRTSP:	LD	A,' '
WRITC:	PUSH4			;save registers
	LD	C,A		;char passed in C
	LD	HL,(COLUM)	;width to H, column to L
	CP	CR
	JP	NZ,WRTC1
	LD	L,0		;cr resets column count
WRTC1:
	IF	NOT WILD
	CP	LF
	CALL	Z,WNULS		;write nulls if linefeed
	ENDIF
	IF	NOT EPSTN
	CP	CNTLH
	CALL	Z,DECRC		;decrement column if <control-h>
	ENDIF
	CP	20H
	CALL	NC,BUMPC	;bump column if printable
	LD	(COLUM),HL
	IF	CPM AND SDISK AND (NOT RTPAK)
	LD	HL,(FILEP)
	LD	A,H
	OR	L
	JP	NZ,DWRIT	;write char to disk file
	ENDIF
	IF	BENDX AND SDISK
	LD	A,(BFILP)
	OR	A
	JP	NZ,DWRIT	;write char to disk file
	ENDIF
	LD	A,(OMODE)
	IF	(CPM OR ISIS2 OR GENMC OR (BENDX AND SDISK)) AND NOT COMPL
	CP	80H		;check if doing ASCII save
	JP	Z,DSAVE
	ENDIF
	IF	WILD
	CP	6
	JP	NC,WRTC2	;>= 6, not PRINT @
	OR	A
	JP	NZ,WWRIT	;1 <= OMODE <= 5, PRINT @ to monitor
	ENDIF
WRTC2:	OR	A		;check if output to be suppressed
	IF	(NOT WILD) OR (NOT RTPAK);no CNOUT in WILD RTPAK
	PUSH	BC
	CALL	Z,CNOUT
	POP	BC
	ENDIF
	IF	(CPM OR ISIS2 OR GENMC) AND NOT COMPL
	CP	7FH		;check if doing ASCII LOAD
	JP	Z,POP4		;ignore remaining checks if so
	ENDIF
	IF	CPM AND DEBUG AND NOT COMPL
	LD	A,(AMODE)
	OR	A
	PUSH	BC
	CALL	NZ,DKOUT	;write to disk if saving
	POP	BC
	ENDIF
	IF	NOT WILD
	LD	A,(LMODE)
	OR	A		;check LST write mode
	CALL	NZ,LOUT
	ENDIF
POP4:	POP	AF		;common restore and returns
	JP	POP3
DECRC:	DEC	L		;decrement column count for backspace
	RET	P		;done unless was column 0
	INC	L		;undecrement
	JP	WLF		;write linefeed and return
BUMPC:	LD	A,L
	INC	L		;increment column
	CP	H
	RET	C		;column < width -- ok
	LD	A,H		;fetch width
	OR	A
	RET	Z		;suppress automatic crlfs if width is 0
	LD	L,1		;column >= width -- write crlf and return
	IF	EPSTN
	LD	A,H
	CP	80
	RET	Z		;Epstein hardware does crlf at column 80
	ENDIF
WCRLF:	LD	A,CR
	CALL	WRITC
WLF:	LD	A,LF
	JP	WRITC
	IF	NOT WILD
WNULS:	LD	A,(NULLS)	;fetch null count
	LD	B,A		;save in B
	INC	B
	XOR	A		;null char to A
WNUL1:	DEC	B
	RET	Z		;done
	CALL	WRITC		;write a null
	JP	WNUL1		;and test for more
	ENDIF

;READC reads one char from the console.
;The parity bit (i.e. bit 7) is reset.
;The user is returned to direct mode if the char is <cntl-c>.
;The system is booted if the char is <cntl-b>.
;The LST mode is toggled if  the char is <cntl-p>.
;Retn:	A	char read, masked by 7FH
;	BC,DE,HL	preserved
READC:	PUSH3			;save registers
	IF	(CPM OR ISIS2 OR GENMC OR (BENDX AND SDISK)) AND NOT COMPL
	LD	A,(OMODE)
	CP	7FH		;check if ASCII load
	JP	Z,DLOAD		;yes
	ENDIF
	CALL	CONIN		;read the console
	AND	7FH		;mask off parity
	IF	(NOT WILD) OR (NOT RTPAK);no ^B, ^C in Wild RTPAK
	CP	CNTLB
	CALL	Z,ECHOC
	IF	DEBUG
	CALL	Z,BOOT		;call monitor if debug and control-B
	ELSE
	IF	CAMAC AND CPM
	CALL	Z,CDSAB		;disable interrupt before booting if CP/M CAMAC
	ENDIF
	JP	Z,BOOT		;jmp monitor if not debug and control-B
	ENDIF
	CP	CNTLC
	CALL	Z,ECHOC
	JP	Z,DMODC		;break to direct mode if control-c
	ENDIF
	IF	CPM AND DEBUG AND NOT COMPL
	CP	CNTLX
	JP	Z,DSAV0
	ENDIF
	IF	NOT WILD	;no LST device
	CP	CNTLP
	JP	NZ,POP3
	CALL	ECHOC
	LD	A,(LMODE)	;toggle LST mode if control-p
	CPL
	LD	(LMODE),A
	LD	A,CNTLP		;restore char to A
	ENDIF
	JP	POP3

	IF	(CPM OR ISIS2 OR GENMC) AND NOT COMPL
DSAVE:	CALL	DKOUT		;write char to disk file
	JP	POP4		;restore and return
	ENDIF

;REDYC determines whether char is ready at console.
;Retn:	Carry	set iff char ready
REDYC:	PUSH3			;save registers
	CALL	CSTAT
	RRCA
	JP	POP3		;restore and return

;CTEST looks for character at console, and READCs it if present.
;All chars are ignored except the following:
;	<cntl-b>	reboots (from READC)
;	<cntl-c>	breaks (branch to dmode, with message)
;	<cntl-o>	toggles CONsole output mode
;	<cntl-p>	toggles LST mode (from READC)
;	<cntl-s>	suspends interpreter execution until either
;				<cntl-x> (reboot) or <cntl-q> (resume)
;Retn:	A	clobbered
;	BC,DE,HL	preserved
CTEST:	CALL	REDYC		;check if char ready
	RET	NC		;no char ready
CTST0:	CALL	READC		;ready, so read the char -- driver entry point
	IF	(NOT WILD) OR (NOT RTPAK)
	CP	CNTLO
	CALL	Z,ECHOC
	JP	Z,CTST1		;toggle output mode if cntl-o and return
	ENDIF
	IF	NOT WILD
	CP	CNTLS
	JP	Z,CTST2		;wait for cntl-q if cntl-s
	ENDIF
	LD	(GCHAR),A	;else save it for GET
	RET
	IF	NOT WILD
CTST2:	CALL	READC
	CP	CNTLQ		;check if cntl-q
	RET	Z		;return if so
	CP	CNTLS
	RET	Z		;return if cntl-s toggled also
	JP	CTST2		;else wait
	ENDIF
	IF	(NOT WILD) OR (NOT RTPAK)
CTST1:	LD	A,(OMODE)
	CPL			;toggle omode
	LD	(OMODE),A
	JP	WCRLF		;echo crlf and return
	ENDIF

;WRTBS prints (BC) as a signed decimal number, with leading '-' if negative.
;WRTBU prints (BC) as an unsigned decimal number.
;The current column & width are checked to avoid breaking the number with crlf.
;WRTB1 is an entry point from PRINT, to print nonnegatives with leading space.
;Call:	BC	integer
;Retn:	A	clobbered
;	BC,DE,HL	preserved
WRTBS:	LD	A,B
	OR	A
	JP	P,WRTBU		;write unsigned if positive
	PUSH	BC		;else save BC
	CALL	IUMIN		;negate BC (NB -32768 is OK)
	LD	A,'-'		;leading minus sign
	JP	WRTB2		;and write
WRTBU:	XOR	A		;no leading char
WRTB1:	PUSH	BC		;save BC
WRTB2:	PUSH	DE
	PUSH	HL		;and DE, HL
	CALL	CVTIS		;convert integer to string
	CALL	PRSTL		;print string on one line
	JP	POP3

;PRSTR prints the string addressed by C,DE.
;PRSTL tries to print the string addressed by C,DE without crlf.
PRSTL:	LD	HL,(COLUM)	;width to H, column to L
	LD	A,H		;fetch width
	OR	A
	JP	Z,PRSTR		;just print the string if width is 0
	LD	A,C		;length to A
	ADD	A,L		;column + length = last column needed
	CCF			;carry reset iff > 255
	JP	NC,PRSL1	;much too long, write crlf first
	CP	H		;carry reset iff last needed >= width
	JP	Z,PRSTR		;just fits
PRSL1:	CALL	NC,WCRLF	;write crlf if too long for current printline
PRSTR:	INC	C		;length+1
PRST1:	DEC	C		;decrement length
	RET	Z		;done
	LD	A,(DE)		;fetch next string char
	CALL	WRITC		;print it
	INC	DE
	JP	PRST1		;and write more

;CVTIS converts the integer in BC to a string of ASCII decimal digits.
;The result is loaded into the buffer at BUFAD.
;Call:	A	leading char (ASCII space or minus sign, 0 for none)
;	BC	unsigned integer value
;Retn:	A,C	length of string result
;	DE	location of string result, i.e. BUFAD
;	B,HL	clobbered
CVTIS:	LD	H,B
	LD	L,C		;value to HL
	LD	BC,BUFAD	;destination to BC
	PUSH	BC		;and saved
	OR	A
	JP	Z,CVIS1		;no leading char desired
	LD	(BC),A		;store leading char
	INC	BC		;and point to next available location
	XOR	A		;clear A for mod10
CVIS1:	LD	DE,-10000
	CALL	MOD10
	LD	DE,-1000
	CALL	MOD10
	LD	DE,-100
	CALL	MOD10
	LD	DE,-10
	CALL	MOD10
	LD	A,L		;units digit to A
	CALL	MOD1B		;and to string
	POP	DE		;location to DE
	LD	A,C		;last+1 to A
	SUB	E		;last+1 - first = length
	LD	C,A		;and length to C
	RET

;MOD10 adds the decimal digit n = (HL) div -(DE) to the string at (BC)
;and leaves HL with (HL) + n * (DE).  Zeros suppressed if (A) = 0 when called.
MOD10:	PUSH	BC
	LD	B,255
MOD1A:	LD	(TEMP),HL
	INC	B
	ADD	HL,DE
	JP	C,MOD1A
	LD	HL,(TEMP)	;remainder to HL
	LD	D,B		;result to D, temporarily
	POP	BC		;restore BC
	OR	D		;zero set iff (A) > 0 or (D) > 0
	RET	Z
	LD	A,D		;result to A
MOD1B:	ADD	A,'0'		;entry point for final digit
	LD	(BC),A		;add ASCII digit to string
	INC	BC
	RET

	IF	NOT COMPL
;PRNTL prints line # (as unsigned decimal, suppressed if zero) and space
;and a line of user source text, expanding tokens as necessary.
;Call:	HL	address of line #
;Retn:	A,DE	clobbered
;	BC	preserved
;	HL	address following last text byte, i.e. after <cr>
;PRTL0 prints line with <linefeed> if (DE) matches location.
;PRTLC prints line with <linefeed> at TEXTP.
PRTLC:	LD	HL,(TEXTP)
	EX	DE,HL		;current TEXTP to DE
	LD	HL,(LNNUM)	;current LNNUM to HL
	CALL	PRTL0		;print the line
	JP	WCRLF		;and crlf
PRNTL:	LD	DE,0		;print without linefeed
PRTL0:	PUSH	BC
	CALL	LINB1		;line # to BC
	JP	Z,PRTL3		;zero, i.e. direct mode
	CALL	WRTBU		;write the line #
	INC	HL		;past break byte
	INC	HL		;to first text byte
	LD	A,' '
	CP	(HL)		;check if first char is space
	CALL	NZ,WRTSP	;write a space if not
PRTL1:	POP	BC		;restore BC
PRTL2:	CALL	CMDHU		;compare to text pointer
	CALL	Z,WLF		;write linefeed if equal
	LD	A,(HL)		;fetch next byte from text
	INC	HL
	CP	CR
	RET	Z		;cr, done
	PUSH	HL
	CALL	PRTCH		;print char or token
	POP	HL
	JP	PRTL2
PRTL3:	LD	HL,TLNAD
	JP	PRTL1

;PRTCH prints a char or token.
;Call:	A	char or token
PRTCH:	CALL	FNDTK		;look up the token
	JP	NC,WRITC	;char, just print it
	ENDIF			;else fall through to PRTST to print token

;PRTST prints a string with successive calls to WRITC.
;Call:	HL	address of string's first text char
;Retn:	A	clobbered
;	BC,DE	preserved
;	HL	address following string's last text char
PRTST:	LD	A,(HL)		;fetch a byte to print
	AND	7FH		;mask off end of entry bit
	CALL	WRITC		;print it
	LD	A,(HL)		;check end of entry byte again
	OR	A
	INC	HL		;move up pointer
	JP	P,PRTST		;keep printing
	RET			;end of entry, done

;PRNTM prints the message which directly follows the CALL PRNTM.
;PRTM0 turns on OMODE and then prints message with PRNTM.
PRTM0:	XOR	A
	LD	(OMODE),A	;turn on output mode
	IF	CPM AND SDISK	;reset file pointer
	LD	HL,0
	LD	(FILEP),HL
	ENDIF
	IF	BENDX AND SDISK
	LD	(BFILP),A
	ENDIF
PRNTM:	POP	HL		;address following CALL to HL
	CALL	PRTST		;print the message
	JP	(HL)		;and return to the next address

	IF	WILD		;error handling
ERROF:
ERRON:
ERROC:	XOR	A
	LD	(OMODE),A	;reset OMODE in case within PRINT @
	POP	HL		;recover address of caller
	LD	D,(HL)		;first message char to D
	INC	HL
	LD	A,(HL)
	AND	7FH
	LD	E,A		;second message char to E
	CALL	LINBC		;line number to BC
	LD	H,B
	LD	L,C		;then to HL
	LD	A,9		;error code = 9 to A
	JP	WMON		;and pass to monitor
	ELSE			;NOT WILD
;ERROF, ERRON and ERROC are error routine entry points for Fatal,
;Nonfatal and Continue errors.  In each case the
;error routine is invoked with the ERROR macro, e.g. with
;	ERROR	F, X, Y
;issuing a fatal XY error with the code
;	call	errof
;	db	'X', 'Y' or 80H
;The error message following the call is printed, followed by the
;user source line # (if any) and user source line.
;If TRAP, any error terminates execution and returns the user to DMODE, with
;a CONTinue entry on the CSTACK to allow continuation at the next command.
;If UNTRAP:
;Fatal errors return to DMODE, as if TRAP.
;Nonfatal errors continue execution with all registers preserved.
;Continue errors continue execution with the next source text command.
ERROF:	EX	(SP),HL		;message address to HL, HL to stack
	PUSH	AF		;PSW to stack
	SCF			;Carry set for fatal
	JP	ERRO0
ERROC:	EX	(SP),HL
	PUSH	AF
	XOR	A		;Carry reset, Zero set for Continue
	JP	ERRO0
ERRON:	EX	(SP),HL
	PUSH	AF
	OR	1		;Carry reset, Zero reset for nonfatal
ERRO0:	PUSH	DE		;save DE
	EX	DE,HL		;message address to DE
	IF	CPM AND SDISK AND (NOT RTPAK)
	LD	HL,(FILEP)
	ENDIF
	IF	BENDX AND SDISK
	LD	HL,BFILP
	LD	H,(HL)
	ENDIF
	PUSH	HL		;save current BFILP
	PUSH	AF		;save error type
	CALL	PRTM0		;turn on OMODE, print CRLF
	DEFB	CR, LF OR 80H
	EX	DE,HL		;message address to HL
	CALL	PRTST		;print message
	POP	AF
	PUSH	HL		;save return address in case nonfatal
	PUSH	AF		;and save error type again
	CALL	PRNTM		;print ERROR message
	IF	COMPL
	DEFB	' ERROR IN LINE', ' ' OR 80H
	PUSH	BC
	CALL	LINBC		;line # to BC
	CALL	WRTBU		;write it
	CALL	WCRLF		;and crlf
	POP	BC
	ELSE
	DEFB	' ERROR:', ' ' OR 80H
	CALL	PRTLC		;print the line
	IF	EDITC
	PUSH	BC
	CALL	LINBC		;line number to BC
	JP	Z,ERRO1		;skip resetting ERRLN if 0
	LD	H,B
	LD	L,C		;then to HL
	LD	(ERRLN),HL	;and save for EDIT
ERRO1:	POP	BC		;restore BC
	ENDIF
	LD	A,(TRAP)	;0 trap, 255 untrap
	OR	A
	JP	Z,ERRO2		;TRAP, so scan to next and go to DMODE
	ENDIF
	POP	AF		;recover error type
	JP	C,ERRO2		;fatal, to DMODE as if TRAP
	JP	Z,NEXTC		;continue with next command
	POP	DE		;return address to DE
	IF	CPM AND SDISK AND (NOT RTPAK)
	POP	HL
	LD	(FILEP),HL	;restore FILEP
	ENDIF
	IF	BENDX AND SDISK
	POP	AF
	LD	(BFILP),A
	ENDIF
	CALL	CTEST		;test for console break char
	EX	DE,HL		;return address to HL
	POP	DE		;restore DE
	POP	AF		;restore psw
	EX	(SP),HL		;restore HL, return address to stack
	RET
	IF	CAMAC
ERRO2	EQU	DMOD2		;no continuation after errors in CAMAC versions
	ELSE
;Fatal errors:  build control stack entry, scan to delimiter, and goto DMODE.
ERRO2:	CALL	LINBC		;LNNUM to HL, Zero set iff direct
	JP	Z,DMOD2		;error from DMODE, skip entry building
	DEC	HL		;address length byte of current line
	PUSH	HL		;and save
	LD	E,(HL)
	LD	D,0		;length of current line to DE
	ADD	HL,DE		;address of following line
	EX	DE,HL		;to DE
	LD	HL,(TEXTP)
	CALL	CMDHU		;check if within current text line
	JP	C,DMOD2		;after current line, skip entry building
	POP	DE
	CALL	CMDHU
	JP	NC,DMOD2	;before current line, skip entry building
	CALL	GTDEL		;else scan to delimiter
	JP	ENDC1		;build break entry and go to DMODE
	ENDIF			;end of NOT CAMAC conditional
	ENDIF			;end of NOT WILD condtional


;end of INOUT
	PAGE
;ISIS2 05/21/81
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
;statement routines for ISIS-II version SAVE and LOAD, plus GTFIL

	IF	ISIS2		;ISIS-II versions

	IF	RTPAK		;UF error in Runtime Module version
SAVE	EQU	UFERR
LOAD	EQU	UFERR
	ELSE

;^B exit to ISIS-II
	IF	DEBUG
BOOT	EQU	0		;^B gets MDS monitor rather than ISIS-II
	ELSE
BOOT:	LD	C,EXITF
	LD	DE,EXBLK
	CALL	ISIS		;return to ISIS
	ENDIF

;SAVE <filename>
SAVE:	CALL	PRNTM		;print SAVING message
	DEFB	'SAVING', ' ' OR 80H
	LD	A,2		;set A for writing
	CALL	GTFIL		;get file name and open it
	LD	(WRBLK),HL	;set aft of write block
	JP	NC,SAVEA	;ASCII save
	OR	A
	JP	NZ,SAVEH	;HEX save
	IF	ROMSQ
	LD	HL,(SOURC)
	ELSE
	LD	HL,SRCAD
	ENDIF
	LD	(WRBLK+2),HL	;set starting address = srcad
	IF	ROMSQ
	PUSH	DE
	CALL	LAST
	POP	DE
	ELSE
	LD	HL,(EOFAD)	;eof addr to HL
	ENDIF
	ADD	HL,DE		;length of file to HL
	LD	(WRBLK+4),HL	;set count for write
	CALL	ISISW		;write the file
ISISC:	LD	C,DKCLF		;close the file and return
	LD	DE,CLBLK
ISISE:	CALL	ISIS
	LD	A,(ESTAT)
	OR	A		;check error status
	RET	Z		;no error
	LD	C,ERRI2
	LD	DE,ESTAT
	CALL	ISIS		;issue ISIS error, fall through to DKERR
DKERR:	ERROR	F, D, K		;fatal DK error
;ASCII SAVE
SAVEA:	LD	A,(OMODE)
	PUSH	AF		;save output mode
	LD	A,80H
	LD	(OMODE),A	;80H to OMODE to indicate ASCII save
	CALL	SAVE0		;initialize file block
	LD	BC,-1
	CALL	LIST1		;list the program to disk file
	LD	C,CNTLZ
	CALL	DWRIT		;followed by eof
	POP	AF
	LD	(OMODE),A	;restore omode value
	JP	ISISC		;close the file and return
;SAVE0 initializes WRBLK to write 1 char from TEMP2,
;returns first program loc in HL.
SAVE0:	LD	HL,TEMP2
	LD	(WRBLK+2),HL	;file chars passed in temp2
	LD	HL,1
	LD	(WRBLK+4),HL	;set count = 1 char per call
	IF	ROMSQ
	LD	HL,(SOURC)
	ELSE
	LD	HL,SRCAD
	ENDIF
	RET
;HEX SAVE
SAVEH:	EX	DE,HL		;-first to HL
	LD	(TEMP),HL	;and saved
	CALL	SAVE0		;initialize WRBLK
	PUSH	HL		;save first
	IF	ROMSQ		;last address to HL
	CALL	LAST
	ELSE
	LD	HL,(EOFAD)
	ENDIF
	EX	DE,HL		;last to DE
	POP	HL		;first to HL
	DEC	HL		;first - 1
;convert the file to hex and write it
SAVH1:	PUSH	HL		;save current
	LD	BC,10H		;max record length to BC
	ADD	HL,BC		;current + max to HL
	CALL	CMDHU		;compare eof to current + max
	POP	HL		;restore current
	LD	A,C		;max to A
	JP	NC,SAVH2	;eof >= current + max, write max
	LD	A,E
	SUB	L
	INC	A		;eof+1 - current = remaining to be written
	JP	Z,SAVH4		;current = eof+1, just write eof record
SAVH2:	PUSH	DE		;save eof address
	LD	E,A		;length to  E
	LD	D,0		;checksum to D
	LD	C,':'
	CALL	DWRIT		;write record mark
	LD	A,E
	CALL	WBYTE		;write length
	CALL	WADDR		;write address and record type
SAVH3:	LD	A,(HL)		;fetch data byte
	INC	HL
	CALL	WBYTE		;write data
	DEC	E
	JP	NZ,SAVH3	;write more data
	CALL	WCSUM		;write the checksum
	POP	DE		;restore eof address
	JP	SAVH1		;and do more
;write eof record
SAVH4:	LD	C,':'
	CALL	DWRIT		;write :
	XOR	A
	LD	D,A		;checksum to D
	CALL	WBYTE		;write record length = 0
	IF	ROMSQ
	LD	HL,(SOURC)
	DEC	HL
	ELSE
	LD	HL,SRCAD-1
	ENDIF
	CALL	WADDR		;write starting address 0 and record type
	CALL	WCSUM		;write the checksum
	LD	C,CNTLZ
	CALL	DWRIT		;write eof
	JP	ISISC		;close file and return


;LOAD <filename>
LOAD:
	IF	ROMSQ
	CALL	ISSRC		;must be addressing working space
	ENDIF
	CALL	PRNTM		;print LOADING message
	DEFB	'LOADING', ' ' OR 80H
	LD	A,1		;set A for reading
	CALL	GTFIL		;get file name, open it
	LD	(RDBLK),HL	;set aft of read param block
	JP	NC,LOADA	;ASCII load
	OR	A
	JP	NZ,LOADH	;HEX load
	LD	HL,SRCAD
	LD	(RDBLK+2),HL	;set starting address = srcad
	LD	HL,(MEMT)
	ADD	HL,DE		;max possible program length to HL
	LD	(RDBLK+4),HL	;and then to read block
	CALL	NEW		;clobber old program
	CALL	ISISR		;read the file
	CALL	ISISC		;close the file
	LD	DE,SRCAD-1	;first addr - 1 to DE
	LD	HL,(TEMP)	;actual count to HL
	ADD	HL,DE		;compute eof address
LOAD1:	LD	A,(HL)
	OR	A
	JP	Z,DMODX		;all is well
LOAD2:	CALL	NEW		;else erase the bad prog
	JP	DKERR		;and issue DK error
ISISR:	LD	C,DKRDF
	LD	DE,RDBLK
	JP	ISISE
;ASCII load
LOADA:	CALL	LOAD0		;set RDBLK and clobber old program
	LD	A,(OMODE)
	PUSH	AF		;save OMODE
	LD	A,7FH
	LD	(OMODE),A	;set OMODE for ASCII load
LODA1:	CALL	GTLIN		;get a line
	CALL	TKIZE		;tokenize it
	JP	C,LODA1		;ignore if no line #
	CALL	NZ,ADDLN	;add to source
	JP	LODA1		;and keep loading
;LOAD0 initializes RDBLK to read 1 char to TEMP2.
LOAD0:	LD	HL,TEMP2
	LD	(RDBLK+2),HL
	LD	HL,1
	LD	(RDBLK+4),HL
	JP	NEW
;HEX load
LOADH:	CALL	LOAD0		;initialize RDBLK and clobber old program
LODH1:	CALL	DREAD		;read a char from hex file
	SUB	':'
	JP	NZ,LODH1	;not record mark, retry
	LD	D,A		;0 for checksum to D
	CALL	RBYTE		;read a file byte
	JP	Z,LODH3		;eof record
	LD	E,A		;else record length to E
	CALL	RBYTE		;read destination msb
	PUSH	AF		;and save
	CALL	RBYTE		;read destination lsb
	POP	HL		;destination msb to H
	LD	L,A		;destination now in HL
	LD	BC,SRCAD-1	;base address to BC
	ADD	HL,BC		;add to base address for actual destination
	CALL	RBYTE		;skip type byte
LODH2:	CALL	RBYTE		;read a data byte
	LD	(HL),A		;and store
	INC	HL		;address next
	DEC	E
	JP	NZ,LODH2	;load another data byte
	CALL	RBYTE		;read checksum
	JP	NZ,LOADX	;checksum error
	DEC	HL		;point to last loaded byte
	LD	(EOFAD),HL	;and reset EOFAD in case end of program
	JP	LODH1		;load next record
LODH3:	CALL	ISISC		;close the file
	LD	HL,(EOFAD)	;point to end of file
	JP	LOAD1
LOADX:	CALL	ISISC		;close the file after error
	JP	LOAD2		;erase bad program, issue DK error


;The ISIS-II version of GTFIL gets a file name and opens the file.
;The filename is [:device:]"<filename>" [, {A | H} ] .
;Call:	A	1 to read, 2 to write
;	HL	address of message to print (SAVING or LOADING)
;Retn:	Carry	Reset iff ASCII specified (with ,A)
;	A	0 for .XYB, 1 for .HEX
;	DE	- first address of source + 1
;	HL	aft of opened file
DEVF0:	DEFB	':F0:', 80H	;default device name to copy
BASFT:	DEFB	'.BAS ', 80H	;file type to copy
XYBFT:	DEFB	'.XYB ', 80H	;file type to copy
HEXFT:	DEFB	'.HEX ', 80H	;file type to copy
GTFIL:	LD	(OPBLK+4),A	;set access mode of open parameter block
	LD	D,':'
	CALL	GTD		;look for device name
	LD	DE,FNAME	;file name addr to DE
	JP	C,GTFL0		;no device name, take default
	CALL	GTCHD		;store :, read 1st char
	CALL	GTCHD		;store 1st, read 2nd char
	CALL	GTCHD		;store 2nd, read :
	CP	':'
	JP	NZ,SNERR	;no :
	CALL	GTCHD		;store :, read "
GTFL1:	CP	'"'
	JP	NZ,SNERR	;no "
	CALL	GTILD		;get first filename char
	JP	C,SNERR		;not letter or digit, SN error
	LD	B,5		;max # chars in filename is 6
GTFL2:	LD	(DE),A		;store filename char
	INC	DE
	CALL	WRITC		;echo the char
GTFL3:	CALL	GTILD		;get next filename char
	JP	C,GTFL4		;no more filename chars
	DEC	B
	JP	P,GTFL2		;store and get next
	JP	GTFL3		;too long, skip storing
GTFL4:	PUSH	DE		;save next fname addr
	CALL	WCRLF		;write cr and lf
	LD	D,'"'
	CALL	GTDSN		;skip close quote
	CALL	GTCOM		;look for comma
	LD	DE,XYBFT	;XYB filetype addr to DE
	LD	A,0		;0 to A in case .XYB
	CALL	NC,GTFL5	;use other filetype instead if comma
	POP	HL		;next fname addr to HL
	PUSH	AF		;save carry status
	CALL	CPYST		;copy file type to FNAME
	LD	C,DKOPF
	LD	DE,OPBLK
	CALL	ISISE		;open the file
	IF	ROMSQ
	LD	HL,(SOURC)
	DEC	HL		;address preceding source to HL
	EX	DE,HL		;and then to DE
	ELSE
	LD	DE,SRCAD-1	;address preceding source to DE
	ENDIF
	CALL	CPLDE		;- first address + 1
	LD	HL,(AFT)	;aft to HL
	POP	AF		;restore carry status
	RET
GTFL5:	LD	D,'A'
	CALL	GTD		;look for A
	LD	DE,BASFT
	RET	NC		;gotcha, return Carry reset
	LD	D,'H'
	CALL	GTDSN		;SN error if neither H nor A
	LD	DE,HEXFT
	LD	A,1
	SCF			;return Carry, A = 1 if HEX
	RET
GTFL0:	EX	DE,HL		;FNAME addr to HL
	LD	DE,DEVF0	;default device name addr to DE
	CALL	CPYST		;copy :F0: to FNAME
	DEC	HL		;HL points to next FNAME loc available
	EX	DE,HL		;DE points to next
	CALL	GTCHA		;get next char
	JP	GTFL1		;and continue as above
GTCHD:	LD	(DE),A
	INC	DE
	JP	GTCHA

;routines for disk i/o

;DKOUT writes a character from C to the open disk file
DKOUT:	LD	HL,TEMP2
	LD	(HL),C		;character to temp2 for writing
ISISW:	LD	C,DKWRF
	LD	DE,WRBLK
	JP	ISISE		;write the char and return

;DLOAD reads char from disk for ASCII LOAD
DLOAD:	CALL	DREA1		;read char
	JP	NZ,POP3		;return unless eof
	CALL	ISISC		;close the file
	LD	SP,STACK-4	;omode and nexts return pushed
	POP	AF
	LD	(OMODE),A	;restore omode
	JP	DMOD2		;and return to direct mode

;DREAD reads char for HEX LOAD
DREAD:	PUSH3
	CALL	DREA1
	JP	NZ,POP3
	JP	LOADX		;eof read

;DREA1 is called from DLOAD and DREAD to read a disk char.
;Retn:	A	char read
;	BCDEHL	clobbered
;	Zero	set iff eof
DREA1:	CALL	ISISR		;read char to TEMP2
	LD	A,(TEMP)	;fetch actual count
	OR	A
	RET	Z		;actual = 0, i.e. eof
	LD	A,(TEMP2)	;else fetch char read
	AND	7FH		;remove parity bit
	CP	CNTLZ		;Zero set iff eof
	RET

;routines for HEX LOADing and SAVEing
;INTEL HEX format is a series of records, with all info in ASCII:
;frame 0	record mark ':' [3AH]
;frames 1-2	record length n, hex number 0-FFH [0 for eof;  here max=10H]
;frames 3-6	load address
;frames 7-8	record type [here 0]
;frames 9 - 8+2*n	data
;frames 9+2*n - 10+2*n	checksum  [negated sum mod 256 of preceding items]

;WASCI converts A3-A0 to ASCII and falls through to DWRIT to write
WASCI:	AND	0FH		;00H, ..., 09H, 0AH, ..., 0FH
	ADD	A,90H		;90H, ..., 99H, 9AH, ..., 9FH
	DAA			;90H, ..., 99H, 00H+C,...,05H+C
	ADC	A,40H		;D0H, ..., D9H, 41H, ..., 46H
	DAA			;30H, ..., 39H, 41H, ..., 46H
	LD	C,A		;pass value to write through C
	;and fall through to DWRIT
DWRIT:	PUSH4
	CALL	DKOUT		;write the char
	JP	POP4

;WBYTE writes byte from A as two ASCII bytes, updating checksum in D
WBYTE:	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	WASCI		;convert left nibble to ascii and write
	POP	AF
	PUSH	AF
	CALL	WASCI		;convert right nibble to ascii and write
	POP	AF
	ADD	A,D
	LD	D,A		;update checksum
	RET

;WADDR writes address from HL (subtracting loading bias), and record type.
WADDR:	PUSH	HL
	PUSH	DE
	EX	DE,HL		;address to DE
	LD	HL,(TEMP)	;-first to HL
	ADD	HL,DE		;load address to HL
	POP	DE
	LD	A,H
	CALL	WBYTE		;write high byte
	LD	A,L
	CALL	WBYTE		;write low byte
	XOR	A
	CALL	WBYTE		;write record type = 0
	POP	HL
	RET			;and return

;WCSUM writes the checksum from D, followed by CR and LF.
WCSUM:	XOR	A
	SUB	D
	CALL	WBYTE		;write checksum
	LD	C,CR
	CALL	DWRIT
	LD	C,LF
	JP	DWRIT		;write cr and lf and return

;RBYTE reads two ASCII bytes and builds binary char, updating checksum in D.
;Retn:	A	char read
;	C	clobbered
;	D	updated checksum
;	BEHL	preserved
;	Zero	set iff new checksum = 0
RBYTE:	CALL	DREAD		;read a byte
	CALL	ISHEX		;convert ASCII to binary
	JP	C,LOADX		;not an ASCII hex digit, abort
	RLCA
	RLCA
	RLCA
	RLCA
	LD	C,A		;high nibble to C
	CALL	DREAD		;read another
	CALL	ISHEX
	JP	C,LOADX		;not ASCII hex digit
	OR	C		;form complete byte from nibbles
	LD	C,A		;and save
	ADD	A,D		;update checksum
	LD	D,A		;and checksum to D
	LD	A,C		;restore result to A
	RET

	ENDIF			;end of NOT RTPAK conditional
	ENDIF			;end of ISIS2 conditional


;end of ISIS2
	PAGE
;NONST 08/06/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;routines for nonstandard version SAVE and LOAD, plus GTFIL
;includes custom EPSTN and GENMC versions


	IF	NONST		;NONST versions

	IF	(NOT CAMAC) OR (NOT RTPAK);not for CAMAC RTPAK version
;DOIO is common routine to perform i/o operations in nonstandard version.
;Call:	A	offset of desired JMP from beginning of jump vector
;	E	shift count for finding desired iobyte field
CONIN:	XOR	A
CONI1:	PUSH	DE		;save DE
	LD	E,1
DOIO:	PUSH	HL		;save HL
	LD	HL,JMPTA	;jmp vector base address to HL
	CALL	ADAHL		;+offset = jmp address for device #0
	LD	A,(IOBYT)	;i/o byte to A
DOIO1:	DEC	E
	JP	Z,DOIO2		;shift no more
	RRA
	JP	DOIO1
DOIO2:	AND	3		;mask to desired field only
	LD	E,A		;save in E
	RLA			;desired device # * 2
	ADD	A,E		;desired device # * 3
	CALL	ADAHL		; + base = jmp address for selected device
	POP	DE		;saved HL to DE
	EX	(SP),HL		;saved DE to HL, device jmp address to stack
	EX	DE,HL		;restore DE and HL
	RET			;branch to desired device driver
CNOUT:	LD	A,12
	JP	CONI1
RDRIN:	LD	A,24
	PUSH	DE
	LD	E,3
	JP	DOIO
POUT:	LD	A,36
	PUSH	DE
	LD	E,5
	JP	DOIO
LOUT:	LD	A,48
	PUSH	DE
	LD	E,7
	JP	DOIO
	ENDIF			;end of NOT CAMAC or NOT RTPAK conditional

	IF	COMPL
SAVE	EQU	UFERR		;UF error in COMPL version
LOAD	EQU	UFERR
	ELSE

	IF	(NOT EPSTN) AND (NOT GENMC) AND (NOT BENDX)
;normal NONST SAVE and LOAD
;SAVE <filename>
SAVE:	CALL	PRNTM		;print SAVING message
	DEFB	'SAVING', ' ' OR 80H
	CALL	GTFIL		;get file name
	IF	PACKI
	LD	C,CNTLR
	CALL	POUT		;TAPEON
	CALL	SAVE7		;punch leading nulls
	ENDIF
	IF	NOT ROMSQ
	LD	DE,SRCAD-2
	CALL	CPLDE
	LD	HL,(EOFAD)
	ELSE
	LD	HL,(SOURC)
	DEC	HL		;first to HL
	PUSH	HL
	PUSH	HL		;and saved
	CALL	LAST		;last to HL
	POP	DE		;first to DE
	CALL	CPLDE		;-first to DE
	INC	DE		;-first + 1
	ENDIF
	ADD	HL,DE		;last - first + 1 = length
	PUSH	HL		;and saved
	LD	HL,HEADR
	LD	E,HEADL		;header length to E
SAVE1:	LD	C,(HL)		;header char to C
	CALL	POUT		;and out to punch device
	INC	HL
	DEC	E
	JP	NZ,SAVE1	;keep sending header chars
	POP	DE		;file length to DE
	IF	ROMSQ
	POP	HL
	ELSE
	LD	HL,SRCAD-1	;save pointer to HL
	ENDIF
SAVE2:	INC	DE
	PUSH	DE		;save length+1
	LD	A,D
	OR	A		;zero set iff length < 255
	JP	Z,SAVE3
	LD	E,0
SAVE3:	DEC	E		;length of block to E
	LD	C,STBYT
	CALL	POUT		;send start  byte
	LD	C,TYBYT
	CALL	POUT		;send type byte
	LD	C,E
	CALL	POUT		;send length byte
	LD	A,E
	OR	A		;check if length = 0
	JP	Z,SAVE5		;yes, done
	CALL	CTEST		;check for console break char
	LD	D,0		;checksum in D
SAVE4:	LD	C,(HL)
	CALL	POUT		;send source char
	LD	A,(HL)
	ADD	A,D
	LD	D,A		;update checksum
	INC	HL
	DEC	E
	JP	NZ,SAVE4	;send more source chars
	LD	C,D
	CALL	POUT		;send checksum
SAVE5:	POP	DE		;recover length + 1  to DE
	LD	A,D
	OR	A
	IF	PACKI
	JP	Z,SAVE6
	ELSE
	RET	Z		;done if length < 255
	ENDIF
	DEC	D		;else new length = length+1-256 = length-255
	JP	SAVE2		;and save more blocks
	IF	PACKI
SAVE6:	CALL	SAVE7		;punch trailing nulls
	LD	A,CNTLT
	JP	WRITC		;TAPEOFF and return
SAVE7:	LD	BC,(64 SHL 8)	;64 to B, 0 to C
SAVE8:	CALL	POUT		;punch a null
	DEC	B
	JP	NZ,SAVE8	;punch more nulls
	RET
	ENDIF


;LOAD <filename>
LOAD:
	IF	ROMSQ
	CALL	ISSRC		;must be addressing working space
	ENDIF
	LD	HL,HEADR+2	;first filename char address to HL
	LD	BC,8		;0 to B, # filename chars to C
	CALL	FILLM		;fill filename with 0s
	CALL	PRNTM		;print LOADING message
	DEFB	'LOADING', ' ' OR 80H
	CALL	GTCHO		;look at next char
	CALL	DTEST		;check if delimiter
	CALL	C,GTFIL		;get file name and set up header if not
	IF	PACKI
	LD	C,CNTLQ
	CALL	POUT		;XON to turn on RDR
	ENDIF
LOAD1:	LD	HL,HEADR
	LD	C,HEADL
	CALL	CTEST		;check for console break char
;NB Tarbell needs different startup
;lxi h,headr+2 and mvi c,headl-2 above
;mvi a,10H and out 6EH here
LOAD2:	CALL	RDRIN		;read a char
	CP	(HL)		;compare to header char
	JP	Z,LOAD3		;matched, try next
	LD	A,(HL)		;else fetch header char
	OR	A		;check if null, i.e. LOAD <cr> typed
	JP	NZ,LOAD1	;not null, try again from the top
LOAD3:	INC	HL
	DEC	C
	JP	NZ,LOAD2	;see if next matches too
	CALL	NEW		;got the file header, prepare to load
	LD	HL,SRCAD-1	;load address to HL
LOAD4:	CALL	RDRIN		;read start byte
	CP	STBYT		;check if start byte
	JP	NZ,CSERR	;issue CS error if not
	CALL	CTEST		;check for console break char
	CALL	RDRIN		;read type byte
	CP	TYBYT		;check if type byte
	JP	NZ,CSERR	;issue CS error if not
	CALL	RDRIN		;read length byte
	OR	A
	IF	PACKI
	JP	Z,LOAD6		;XOFF before exiting in Packard version
	ELSE
	JP	Z,DMODX		;block length 0, done
	ENDIF
	LD	E,A		;block length to E
	INC	A
	PUSH	AF		;save length+1
	LD	D,0		;checksum to D
LOAD5:	CALL	RDRIN		;read a char
	LD	(HL),A		;store it
	INC	HL
	ADD	A,D
	LD	D,A		;update checksum
	DEC	E
	JP	NZ,LOAD5	;more chars in block
	CALL	RDRIN		;read the checksum
	CP	D
	JP	NZ,CSERR	;checksum error
	POP	AF		;recover block length+1
	JP	Z,LOAD4		;length was 255, so load more blocks
	DEC	HL		;point to new eof adress
	IF	PACKI
LOAD6:	LD	C,CNTLS
	CALL	POUT		;XOFF to turn off RDR
	ENDIF
	JP	DMODX		;reset stacks and continue iff direct
CSERR:	CALL	NEW		;erase the garbage
	IF	PACKI
	LD	C,CNTLS
	CALL	POUT		;XOFF to turn off RDR
	ENDIF
	ERROR	F, C, S		;fatal CS error
	ENDIF			;end normal NONST conditional

	IF	(NOT EPSTN) AND (NOT BENDX);NONST GTFIL, including GENMC
;the nonstandard version of GTFIL gets a file name and initializes header block
GTFIL:	CALL	GTFL4		;skip the open quote
	IF	NOT GENMC
	LD	BC,HEADR+2	;point to filename location with BC
	ELSE
	LD	BC,HEADR+3
	ENDIF
	CALL	GTALP		;get first char
	JP	C,SNERR
	LD	D,8		;max char count to D
GTFL1:	LD	(BC),A		;store a filename char in header
	INC	BC
	IF	NOT GENMC
	CALL	WRITC		;and echo to console
	ENDIF
	CALL	GTILD
	JP	C,GTFL5		;no more chars, pad with spaces
GTFL2:	DEC	D
	JP	NZ,GTFL1	;store another
GTFL3:	CALL	GTILD
	JP	NC,GTFL3	;scan remaining chars, if any
GTFL4:	LD	D,'"'
	JP	GTDSN		;get quote mark and return
GTFL5:	LD	A,' '
GTFL6:	DEC	D
	JP	Z,GTFL4
	LD	(BC),A
	INC	BC
	JP	GTFL6
	ENDIF


	IF	EPSTN		;EPSTN versions

;SAVE <filename>
SAVE:	LD	HL,SAVMA	;SAVING message address to HL
	CALL	GTFIL		;get file name
	IF	NOT ROMSQ
	LD	BC,SRCAD-1
	ELSE
	CALL	FIRST
	ENDIF			;first addr to BC
	CALL	WRTBH		;write the start address in hex
	LD	A,'-'
	CALL	WRITC		;write a -
	IF	ROMSQ
	CALL	LAST		;last addr to BC
	ELSE
	LD	HL,(EOFAD)
	LD	B,H
	LD	C,L
	ENDIF
	CALL	WRTBH		;write BC as hex number
SAVE1:	CALL	PRNTM		;print escape sequence
	DEFB	CR, ESCAP, ESCAP OR 80H
	RET			;and return
SAVMA:	DEFB	CR, LF, ESCAP, 'DSAV', ' ' OR 80H

;LOAD <filename>
LOAD:
	IF	ROMSQ
	CALL	ISSRC		;must be addressing working space
	ENDIF
	LD	HL,LODMA
	CALL	GTFIL		;get file name and set up header
	CALL	NEW		;got the file, prepare to load
	CALL	SAVE1		;write escape sequence
	IF	ROMSQ
	CALL	LAST
	ELSE
	LD	DE,-1
	CALL	FINDL
	LD	A,(HL)
	CALL	ADAHL
	ENDIF			;last addr to HL
	JP	DMODX		;reset stacks and continue iff direct
LODMA:	DEFB	CR, LF, ESCAP, 'DLOD', ' ' OR 80H

GTFIL:	PUSH	HL	;save message address
	LD	D,'"'
	CALL	GTDSN		;skip open quote
	LD	DE,BUFAD-1	;destination-1 to DE
	CALL	GTALP		;look for alpha first char
	JP	C,SNERR		;SN error if none
	LD	C,5		;max char count to C
GTFL1:	INC	DE
	LD	(DE),A		;store a filename char
GTFL2:	CALL	GTILD		;look for following letter or digit
	JP	C,GTFL3		;done if none
	DEC	C		;else decrement count
	JP	P,GTFL1		;and store the char
	JP	GTFL2		;or scan and ignore remaining chars
GTFL3:	LD	A,(DE)		;recover last filename char
	OR	80H		;turn on high bit
	LD	(DE),A		;and replace
	LD	D,'"'
	CALL	GTDSN		;skip close quote
	POP	HL		;restore message addr
	CALL	PRTST		;print it
	LD	HL,BUFAD
	CALL	PRTST		;print the filename
	CALL	PRNTM		;print filetype XYB
	DEFB	'.XYB', ' ' OR 80H
	RET			;and return

;WRITH writes (A3-A0) as a hex digit, masking off A7-A4.
;WRTBH writes (BC) as hex word, currently as #dddd without suppressing zeroes.
WRITH:	AND	0FH		;00H, ... , 09H, 0AH, ... , 0FH
	ADD	A,90H		;90H, ... , 99H, 9AH, ... , 9FH
	DAA			;90H, ... , 99H, 0H+C,... , 5H+C
	ADC	A,40H		;D0H, ... , D9H, 41H, ... , 46H
	DAA			;30H, ... , 39H, 41H, ... , 46H
	JP	WRITC		;write and return

WRTBH:	PUSH	DE
	LD	D,255
WRTW1:	LD	A,B
	RRCA
	RRCA
	RRCA
	RRCA			;rotate right four places
	CALL	WRITH		;write MS four bits
	LD	A,B
	CALL	WRITH		;write LS four bits
	INC	D
	LD	B,C
	JP	Z,WRTW1
	POP	DE
	RET

	ENDIF			;end of EPSTN conditional

	IF	GENMC		;GENMC versions SAVE and LOAD
;SAVE <filename>
SAVE:	CALL	PRNTM		;print SAVING message
	DEFB	'SAVING', ' ' OR 80H
	CALL	GTFIL		;get file name
	LD	HL,HEADR+3
	CALL	PRTST		;echo the <filename>
	LD	A,(OMODE)
	PUSH	AF		;save current OMODE
	LD	A,80H
	LD	(OMODE),A	;reset OMODE for ASCII saving
	LD	HL,HEADR
	CALL	PRTST		;save header
	IF	ROMSQ
	LD	HL,(SOURC)
	ELSE
	LD	HL,SRCAD	;first prog addr to HL
	ENDIF
	LD	BC,-1
	CALL	LIST1		;do the ASCII save
	LD	C,CNTLZ
	CALL	POUT		;and write an eof
	POP	AF
	LD	(OMODE),A	;restore OMODE
	RET

;LOAD [<filename>]
LOAD:
	IF	ROMSQ
	CALL	ISSRC		;illegal if not addressing working space
	ENDIF
	CALL	PRNTM		;print LOADING message
	DEFB	'LOADING', ' ' OR 80H
	CALL	GTCHO		;look at next char
	CALL	DTEST		;test if delimiter
	JP	NC,LOAD5	;no <filename>, just load next
	CALL	GTFIL		;get <filename> to header
;LOAD1 looks for <filename> matching header
LOAD1:	LD	HL,HEADR
	LD	C,HEADL-1
	CALL	LOADH		;look for matching filename from RDR
	JP	NZ,LOAD1	;does not match <filename>
	CALL	RDRCH		;read last, should be <lf>
	CP	LF
	JP	NZ,LOAD1	;no match
;at LOAD2 the approriate header has been found, so file is loaded
LOAD2:	LD	HL,HEADR+3
	CALL	PRTST		;echo the <filename>
	CALL	NEW		;erase old program
	LD	A,7FH
	LD	(OMODE),A	;reset OMODE for ASCII loading
LOAD3:	CALL	GTLIN
	CALL	TKIZE
	JP	C,LOAD3
	CALL	NZ,ADDLN
	JP	LOAD3
;LOAD5 gets the next file, regardless of filename
LOAD5:	LD	HL,HEADR
	LD	C,3
	CALL	LOADH		;look for <cr> <lf> ' from RDR
	JP	NZ,LOAD5	;not found, try again
	LD	C,8		;now scan eight <filename> chars
LOAD6:	CALL	RDRCH
	LD	(HL),A		;save the char
	INC	HL
	DEC	C
	JP	NZ,LOAD6
	LD	C,5
	CALL	LOADH		;look for .BAS <cr>
	JP	NZ,LOAD5	;no match
	CALL	RDRCH		;read <lf>
	CP	LF
	JP	NZ,LOAD5
	JP	LOAD2		;found good header, load it
;LOADH looks for (C) chars from RDR
;Retn:	Zero	Set iff (C) chars match string addressed by HL
LOADH:	CALL	RDRCH		;read a char
	CP	(HL)
	RET	NZ		;no match, return Zero reset
	INC	HL
	DEC	C
	JP	NZ,LOADH	;look at next
	RET			;match, return Zero set

DKOUT	EQU	POUT		;write to PUN device

RDRCH:	CALL	CTEST	;check for console break char
	CALL	RDRIN		;read from reader
	AND	7FH		;mask off parity
	JP	Z,RDRCH		;ignore nulls (ASCII 0s)
	CP	CNTLY		;check if <control-Y>
	RET	NZ
	ERROR	F, E, F		;fatal EF error
DLOAD:	CALL	RDRCH
	CP	CNTLZ		;look for eof
	JP	NZ,POP3
	JP	DMOD2		;return to DMODE if eof

	ENDIF			;end of GENMC conditional

	ENDIF			;end of NOT COMPL conditional
	ENDIF			;end of NONST conditional


;end of NONST
	PAGE
;PARSING 8/26/79
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979 by Mark Williams Company, Chicago
;parsing routines

;Register use for all parsing routines, except as noted.
;Call:	(textp)	address of next text char
;Retn:	A	clobbered
;	BC,DE	preserved
;	HL	address of next unparsed char
;	(textp)	ditto
;	Carry	set iff failure

;GTCHA fetches the next nonspace character.
GTCHA:	LD	HL,(TEXTP)
GTCH1:	LD	A,(HL)		;fetch character
	INC	HL		;point to next
	CP	' '
	JP	Z,GTCH1		;try again if space
	LD	(TEXTP),HL	;store new text pointer
	RET

;GTCHO looks ahead to the next nonspace char.
GTCHO:	CALL	GTCHA
BAKUP:	DEC	HL		;back up textp
	LD	(TEXTP),HL
	RET

;GTALP fetches the next char if alphabetic, returns Carry if not.
GTALP:	CALL	GTCHO
	CALL	ISALP
	RET	C		;not a letter
READ1:	INC	HL
	LD	(TEXTP),HL	;else read it
	RET

;GTCOM gets a comma.
GTCOM:	CALL	GTCHA
	CP	','
	RET	Z
	JP	BKUPC		;back up textp and return Carry

;GTCND gets a comma not followed by a delimiter.
GTCND:	CALL	GTCOM
	RET	C		;no comma
	CALL	DTST0		;look for delimiter
	CCF			;carry set iff delimiter follows comma
	RET

;GTD returns carry reset and moves up textp if next char matches (D), else
;returns carry set and leaves (textp) unchanged.
;GTDSN gets a char which must match (D), else SN error is issued.
;GTDTR does a GTDSN and echoes the char if trace print is desired.
GTD:	CALL	GTCHA
	CP	D
	RET	Z
BKUPC:	SCF			;return carry set if no match
	JP	BAKUP		;back up textp and return
	IF	NOT COMPL
GTDTR:	LD	A,(INLHS)
	OR	A
	JP	Z,GTDSN		;do not echo unless INLHS
	LD	A,(VTRAC)
	RLA			;carry set iff trace print desired
	LD	A,D
	CALL	C,WRITC		;write it if so
	ENDIF			;and fall through to GTDSN
GTDSN:	CALL	GTD
	RET	NC
	JP	SNERR
	IF	COMPL
GTDTR	EQU	GTDSN
	ENDIF
GTREQ:	LD	D,')'
	CALL	GTDSN		;skip ) and fall through to skip =
GTEQU:	LD	D,EQULT
	JP	GTDSN		;skip = token

;GTDEL scans text until delimiter is found.
GTDEL:	CALL	DTST0		;test if current is delimiter
	RET	NC		;delimiter, done
	CALL	READ1		;no, read the current
	CP	'"'
	CALL	Z,GTCLQ		;watch for quoted strings
	JP	GTDEL		;and try the next

;GTCLQ scans to close quote or <cr>.
;Call:	HL	next char addr
;Retn:	HL	addr of " or cr
;	textp	reset
GTCLQ:	LD	A,(HL)		;fetch next
	CP	CR
	RET	Z		;done if cr
	CALL	READ1		;else read it
	CP	'"'
	JP	NZ,GTCLQ	;and keep reading if not close "
	DEC	HL		;point to "
	RET

;ISDIG presrves A and returns Carry set iff (A) is not ASCII digit.
ISDIG:	CP	'0'
	RET	C		;too small
	CP	'9'+1
	CCF
	RET

;ISHEX converts an ASCII hex digit to binary.
;Both upper and lower case alphabetic characters are allowed.
;Call:	A	character
;Retn:	Carry	set iff not a hex digit
;	A	binary value if Carry reset, clobbered if Carry
;	BCDEHL	preseved
ISHEX:	SUB	'0'		;subtract bias
	CP	'G'+20H-'0'
	CCF
	RET	C		;return Carry set if < '0' or > 'f'
	CP	10
	CCF			;Carry reset for '0' to '9'
	RET	NC		;decimal digit
	AND	1FH		;mask to convert lower case to upper
	SUB	'A'-'0'		;'A' becomes 0, 'B' becomes 1...
	CP	6
	CCF
	RET	C		;return Carry if not legal hex digit
	ADD	A,10		;'A' becomes 10, 'B' becomes 11...
	RET

;GTILD gets the next letter or digit without skipping spaces, and is
;called by GTNAM and GTFIL to build a variable or file name.
;Call:	HL	address of next char to parse
;Retn:	A	next char
;	BC,DE	preserved
;	HL	incremented
;	(textp)	value of HL when called
;	Carry	set iff next not letter or digit
GTILD:	LD	A,(HL)
	LD	(TEXTP),HL	;leave textp set for failure
	INC	HL
LDTST:	CALL	ISDIG
	RET	NC		;digit
ISALP:	CP	'A'
	RET	C		;neither
	CP	'Z'+1
	CCF			;carry iff not letter
	RET

;GTDEC scans an unsigned decimal integer and returns its value.
;An unsigned decimal integer is a string of decimal digits.
;The digit count (not including leading 0s) is used for overflow detection.
;1-4 digits indicates no overflow.
;6+ digits indicates overflow.
;5 digits indicates overflow iff (value of 4 digits)*10 > 65535 or
;	(value of 4 digits)*10 + (value of digit 5) > 65535.
;	Note that 9999*5 is always < 65535.
;Retn:	Carry	set iff no decimmal digit
;	Zero	set if overflow, i.e. integer > 65535
;	A	clobbered
;	BC	preserved
;	DE	integer value 0 <= n <= 65535 if Carry and Zero reset
;	DE	0 if Carry or Zero
;	HL	address of next nondigit
;GTDE0 is called from GTDEC to scan through leading 0s.
GTDE0:	INC	HL
	LD	(TEXTP),HL	;read leading 0
	LD	A,(HL)		;fetch next char
	SUB	'0'
	JP	Z,GTDE0		;another leading 0
	CP	10		;carry set iff decimal digit
	JP	C,GTDE1		;digit follows leading 0s
RETNC:	OR	A		;nondigit, return C,Z reset and result 0
	RET
GTDEC:	LD	DE,0		;default value to DE
	CALL	GTCHO		;next char to A, textp to HL
	SUB	'0'		;subtract ASCII bias
	JP	Z,GTDE0		;strip off leading 0s
	CP	10
	JP	C,GTDE1		;digit
	LD	A,(HL)		;refetch next
	OR	A		;clear Zero
	SCF			;and set Carry
	RET
GTDE1:	LD	E,A		;first digit value to DE
	PUSH	BC		;save BC
	LD	B,-6 AND 255	;-(max # digits + 1) to B
GTDE2:	INC	B		;# digits read - max # - 1
	INC	HL
	LD	A,(HL)		;fetch next char
	SUB	'0'		;subtract ASCII bias
	CP	10
	JP	NC,GTDE3	;nondigit, done
	PUSH	HL		;save textp
	LD	H,D
	LD	L,E		;copy value to HL
	CALL	HL10A		;10 * old value + current digit = new value
	EX	DE,HL		;to DE
	POP	HL		;restore textp
	JP	NC,GTDE2	;get next if no overflow
	INC	B		;bump digit count to assure > 5 on overflow
	JP	GTDE2		;and get next char
GTDE3:	LD	(TEXTP),HL	;update textp
	LD	A,B		;fetch digit count - max - 1
	POP	BC		;restore BC
	OR	A
	RET	M		;count <= max #, return both C and Z reset
	XOR	A		;overflow, return C reset and Z set
	LD	D,A
	LD	E,A		;and 0 in DE
	RET

;GTLNO returns a legal line # in DE, using GTDEC.
;Brances to fatal US error if GTDEC returns overflow or 0.
;Otherwise 	(1) nonexistent or 	(2) 0 < n < 2 ^ 16.
;Retn:	A	next non-space char	clobbered
;	BC	preserved		preserved
;	DE	0			n
;	HL	addr of next nondigit	address of next nondigit
;	Carry	set			reset
GTLNO:	CALL	GTDEC		;look for decimal integer
	RET	C		;none, return Carry
	LD	A,D
	OR	E
	RET	NZ		;legal line #, return Carry reset
USERR:	ERROR	F, U, S		;fatal US error -- illegal line #

;GTLIT gets a literal, and is called by EVAL, READ, INPUT and VAL.
;The literal may be preceeded by optional spaces and untokenized + and - signs.
;Call:	HL	(textp)
;Retn:	Carry	set iff no literal found
;	A	type token
;	BC	value if integer
;	C,DE	value if string
;	(TEMP)BCD	value if floating
GTLIT:	LD	A,(HL)		;fetch next
	INC	HL		;and point to following
GTLT1:	PUSH	AF
	XOR	A
	LD	(TEMP),A	;sign = positive
	POP	AF
GTLT2:	CALL	ISDIG		;check if char is digit
	JP	NC,GTLID
	IF	FLOAT
	CP	'.'
	JP	Z,GTLIF		;get floating literal
	ENDIF
	LD	(TEXTP),HL	;else read the char
	IF	STRNG
	CP	'"'
	JP	Z,GTLIS		;get string literal
	ENDIF
	LD	BC,INTST SHL 8	;overflow flag to B, 0 to C
	LD	D,C
	LD	E,C		;embryo value 0 to DE
	CP	'#'
	JP	Z,GTLIH		;get hex literal
	CP	'&'
	JP	Z,GTLIB		;get binary literal
	CP	' '
	JP	Z,GTLT3		;leading space -- ignore
	CP	'+'
	JP	Z,GTLT3		;unary +
	CP	'-'		;check for unary -
	JP	NZ,BKUPC	;else back up TEXTP and return Carry
	LD	A,(TEMP)	;unary minus -- complement sign
	CPL
	LD	(TEMP),A
GTLT3:	LD	A,(HL)
	INC	HL		;point to next
	JP	GTLT2		;and keep looking
;get a string literal, i.e. quoted string
	IF	STRNG
GTLIS:	PUSH	HL		;save string location
	CALL	GTCLQ		;scan to close " or cr
	POP	DE		;location to DE
GTLS1:	LD	A,L		;last+1 -- EVUNQ entry point
	SUB	E		;last+1-first = length
	LD	C,A		;to C
	LD	A,STRST		;type = string
	OR	A		;return Carry reset
	RET
	ENDIF
;get binary integer literal
GTLIB:	EX	DE,HL		;textp to DE, value to HL
GTLB1:	LD	A,(DE)		;fetch char
	SUB	'0'		;subtract ASCII bias
	CP	2
	JP	NC,OVTST	;not a binary digit, done
	INC	DE
	INC	C		;bump count
	ADD	HL,HL		;shift value left one bit
	CALL	C,OVSET		;set overflow flag
	RRA			;current digit to Carry
	JP	NC,GTLB1	;try next
	INC	HL		;add current digit to value
	JP	GTLB1		;and try next
;get hex integer literal
GTLIH:	EX	DE,HL		;textp to DE, value to HL
GTLH1:	LD	A,(DE)		;fetch next
	CALL	ISHEX
	JP	C,OVTST		;not a hex digit, done
	INC	DE
	INC	C		;bump count
	PUSH	AF
	LD	A,H
	AND	0F0H		;Zero reset if overflow will occur
	CALL	NZ,OVSET	;set overflow flag
	POP	AF		;restore current nibble
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL		;value left four bits
	OR	L
	LD	L,A		;add in current nibble
	JP	GTLH1
;common exit for binary and hex integer literals
OVTST:	EX	DE,HL		;textp to HL
	LD	(TEXTP),HL	;and reset
	LD	A,C		;digit count to A
	OR	A
	JP	Z,BKUPC		;no digits after # or &, return Carry
	LD	A,B		;fetch result type
	LD	B,D
	LD	C,E		;result to DE
	CP	INTST
	RET	Z		;return type integer if no overflow
;issue nonfatal OV error and return max integer value in BC
IOVER:	ERROR	N, O, V		;else issue nonfatal OV error
	LD	BC,7FFFH	;max positive value to BC
	LD	A,INTST		;result is integer
	OR	A		;carry reset
	RET
OVSET:	DEC	B
	RET
;get numeric literal with first char digit
GTLID:	PUSH	HL		;save textp
	CALL	GTDEC		;get decimal number
	LD	A,(HL)		;fetch next char
	POP	HL		;old textp to HL
	IF	FLOAT
	JP	Z,GTLIF		;get floating literal if too big
	CP	'.'
	JP	Z,GTLIF		;or if next is .
	CP	'E'
	JP	Z,GTLIF		;or if next is E
	CP	'E'+20H
	JP	Z,GTLIF		;also allow lower case e in case untokenized
	LD	A,D
	OR	A
	JP	M,GTLIF		;or if value is > 32767 but < 65536
	ELSE
	JP	Z,IOVER		;OV error if too big in nonfloating version
	ENDIF
	LD	A,(TEMP)	;fetch sign
	OR	A
	CALL	NZ,CPLDE	;complement value if negative desired
	LD	B,D
	LD	C,E		;value to BC
	LD	A,INTST
	RET	NC		;return unless cannot complement
	IF	FLOAT
GTLIF:	DEC	HL
	CALL	FINP		;get floating literal
	LD	(TEMP),A	;save A
	LD	A,SNGST
	OR	A		;return Carry reset
	RET
	ELSE
	JP	IOVER
	ENDIF

;GTNAM gets a variable name into buffer at BUFAD, its type into VARTY,
;	and its length into A.
;A name is <letter> [<letter> | <digit>]* [$ | <exclam> | %] without spaces.
;After MAXNL characters, additional chars are scanned but ignored.
;The first letter determines the variable type according to TYBUF,
;	unless the trailing character $ | <exclam> | % is specified.
;Call:	(textp)	current text pointer
;Retn:	A	length of variable name
;	HL	address of first char after name
;	(bufad)	symbol name string
;	(varty)	variable type
;	Carry	set iff no name, i.e. first char not letter
GTNAM:	CALL	GTALP		;get letter
	RET	C
	PUSH	BC
	PUSH	DE
	LD	B,A		;save first char
	IF	STRNG OR FLOAT	;must find var type if noninteger version
	EX	DE,HL		;save HL in DE
	LD	HL,TYBUF-'A'
	CALL	ADAHL		;address default type byte
	LD	A,(HL)		;fetch it
	EX	DE,HL		;restore HL
	ELSE
	LD	A,INTST		;else type is integer
	ENDIF
	LD	(VARTY),A	;store type in VARTY
	LD	A,B		;restore char
	LD	BC,BUFAD
	LD	D,1		;char count to D
GTNM1:	LD	(BC),A		;store a char
GTNM2:	CALL	GTILD		;get next char
	JP	C,GTNM3		;no more
	LD	E,A		;save new char
	LD	A,D
	CP	MAXNL		;compare count to max name length
	JP	NC,GTNM2	;count >= length, so don't insert
	LD	A,E		;restore char
	INC	BC
	INC	D		;bump count and pointer
	JP	GTNM1		;and insert
GTNM3:	CP	'%'
	CALL	Z,GTNM4		;type is integer
	IF	FLOAT
	CP	'!'
	CALL	Z,GTNM6		;type is floating
	ENDIF
	IF	STRNG
	CP	'$'
	CALL	Z,GTNM7		;type is string
	ENDIF
	IF	CAMAC
	CP	'#'
	CALL	Z,GTNM8
	ENDIF
	LD	A,(BC)
	OR	80H
	LD	(BC),A		;end of string bit on
	LD	A,D
	POP	DE
	POP	BC
	RET
GTNM4:	LD	A,INTST		;integer token to A
GTNM5:	LD	(TEXTP),HL	;move textp past trailing char
	INC	HL
	LD	(VARTY),A	;reset VARTY to specified type
	XOR	A		;clear A for following compares
	RET
	IF	FLOAT
GTNM6:	LD	A,SNGST		;single precision token to A
	JP	GTNM5
	ENDIF
	IF	STRNG
GTNM7:	LD	A,STRST		;string token to A
	JP	GTNM5
	ENDIF
	IF	CAMAC
GTNM8:	LD	A,CAMST
	JP	GTNM5
	ENDIF

;FDVAR looks for variable name, returns carry set if none.
;If var not found in symbol table, assumes its type to be simple and
;builds a new symbol table entry for it.
;Retn:	DE	entry type address
;	HL	address following name in entry
FDVAR:	CALL	GTNAM
	RET	C
	LD	C,A		;save length
	CALL	STLKU		;look up symbol in symbol table
	RET	NC		;found it
FDVA1:	LD	A,(VARTY)	;fetch var type -- unary user fn entry point
	IF	CAMAC
	CP	CAMST		;check if camvar
	JP	Z,SNERR		;SN error if undefined camvar
	ENDIF
	CALL	BYTSD		;# bytes per entry to DE
	EX	DE,HL		;and to HL
	LD	B,0		;length to BC
	INC	HL		;+length
	INC	HL		;+type
	INC	HL		;+dims
	ADD	HL,BC		;entry length to HL
	CALL	STPSH		;build the entry
	DEC	DE		;DE points to type byte
	LD	(HL),0		;zero the dim byte
	RET

;GTVAR performs a variable reference.
;Gets a variable name from text, returns with carry set if none.
;If variable name not found in symbol table, assumes its type to be simple
;and builds a new symbol table entry for it.
;Prints trace info if INLHS and either TRACE or variable break bit on,
;and sets VTRAC accordingly.
;Issues BS error if subscript out of bounds.
;Retn:	A	type token of referenced variable
;	DE	type byte address of referenced var
;	HL	address of referenced variable
;	Carry	set iff no name found
;	(vtrac)	bit 7 set iff trace desired
GTVAR:	CALL	FDVAR
	RET	C		;no name found
	IF	NOT COMPL
	LD	A,(INLHS)
	OR	A
	CALL	NZ,TRSET	;set VTRAC if in lhs
	ENDIF
	LD	A,(HL)		;fetch # dims
	LD	C,A		;and save in C
	INC	HL
	OR	A		;zero set iff simple var
	LD	A,(VARTY)	;value to return to A
	RET	Z		;simple var
	IF	CAMAC
	CP	CAMST		;check if camvar reference
	JP	NZ,GTVA0	;no
	LD	A,INTST		;yes, value of camvar ref is integer
GTVA0:	OR	A		;reset Carry for return
	ENDIF
	PUSH	AF		;save value to return
	PUSH	DE
	CALL	BYTSD		;find bytes per entry
	LD	B,E		;and save in B
	PUSH	BC		;save bytes per entry and # dims
	LD	BC,1		;product to BC
	LD	DE,0		;sum to DE
	PUSH	DE		;and saved
	LD	D,'('
;GTVA1 is executed for each subscript of the variable.  The stack contains
;the result type, type byte address, bytes per entry/# dimensions, and sum
;of subscripts thus far.  BC contains the product of bounds thus far, and
;HL points to the next bound.
GTVA1:	PUSH	HL		;save pointer
	CALL	GTDTR		;skip (
	POP	HL		;restore pointer
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;next bound to DE
	INC	HL		;point to next
	EX	(SP),HL		;save pointer, sum to HL
	PUSH	BC		;save product
	PUSH	DE		;save dim
	PUSH	HL		;save sum
	PUSH	BC		;save product
	CALL	GTSUB		;get subscript to BC
	POP	DE		;product to DE
	CALL	MULBD		;subscript * product to HL
	POP	DE		;sum to DE
	ADD	HL,DE		;new sum = sum + subscript * product to HL
	POP	DE		;bound to DE
	POP	BC		;product to BC
	INC	DE		;bound+1
	PUSH	HL		;save sum
	CALL	MULBD		;new product = product * (bound+1) to HL
	POP	DE		;sum to DE
	EX	(SP),HL		;product to stack, pointer to HL
	POP	BC		;product to BC
	EX	(SP),HL		;pointer to stack, counts to HL
	DEC	L		;decrement # dims count
	JP	Z,GTVA2		;done
	EX	(SP),HL		;save counts, restore pointer
	PUSH	DE		;save sum
	LD	D,','
	JP	GTVA1		;and do some more dimensions
GTVA2:	LD	A,H		;bytes per entry to A
	POP	HL		;pointer to HL
GTVA3:	ADD	HL,DE		;add sum once for each value byte
	DEC	A
	JP	NZ,GTVA3	;pointer * sum = location
	PUSH	HL
	LD	D,')'
	CALL	GTDTR		;skip )
	POP	HL
	POP	DE		;restore type byte address
	POP	AF		;and value to return
	RET

;GTSUB gets a subscript expression, issuing nonfatal BS error if out of bounds.
;The subscript value is printed if VTRAC is negative.
;Call:	DE	bound
;Retn:	BC	subscript, 0 <= (BC) <= (DE)
GTSUB:
	IF	NOT COMPL
	LD	A,(INLHS)
	OR	A		;check if INLHS
	JP	M,GTSU2		;yes -- fix so no extraneous tracing
	ENDIF
GTSU0:	PUSH	DE		;save bound
	LD	DE,STACK+STAKM+10-STAKL
	CALL	CPLDE
	EX	DE,HL
	ADD	HL,SP		;number of bytes left to HL
	JP	NC,BSERR	;fatal BS error if too little room left
	CALL	GTEXP		;expr to BC
	LD	DE,0
	LD	A,B
	OR	A		;check sign of subscript
	CALL	M,GTSU1		;negative
	POP	DE		;restore bound
	CALL	CMBDS
	RET	C		;< bound
	RET	Z		;= bound
GTSU1:	LD	B,D
	LD	C,E		;replace expr with bound
	ERROR	N, B, S		;nonfatal BS error and return
	IF	NOT COMPL
GTSU2:	XOR	A
	LD	(INLHS),A	;reset INLHS
	CALL	GTSU0		;get the subscript
	LD	A,255
	LD	(INLHS),A	;turn INLHS back on
	LD	A,(VTRAC)
	OR	A
	RET	P
	JP	WRTBU		;print subscript val if tracing
	ENDIF
BSERR:	ERROR	F, B, S		;fatal BS error

;GTIVA is called from SCALL to perform an integer variable reference.
;Retn:	Carry	Set if not integer var ref
;	BC	value of integer var
;	DE	preserved
GTIVA:	PUSH	DE
	CALL	GTVAR		;look for var ref
	POP	DE
	RET	C		;not found
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;value to BC
	IF	STRNG OR FLOAT
	CP	INTST
	RET	Z		;return Carry reset if integer
	SCF			;and Carry set if not
	ENDIF
	RET

	IF	NOT COMPL
;TRSET determines if trace printing is desired, setting VTRAC accordingly
;and echoing the variable name if so.
;A trailing type char is printed if the type is not the default type.
;Call:	DE	addr of var type byte
;Retn:	A	clobbered
;	BC,DE,HL	preserved
;	Carry	reset
;	(vtrac)	minus iff trace printing desired
TRSET:	PUSH	HL
	LD	HL,(TRACE)	;INLHS to H, TRACE to L
	LD	A,(DE)		;type byte to A -- A7 set iff var break
	OR	L		;minus iff var break or TRACE on
	AND	H		;minus iff tracing desired
	LD	(VTRAC),A
	JP	P,TRST1		;done if not tracing
	CALL	BPRNT		;echo line number if not done already
	LD	H,D
	LD	L,E
	INC	HL		;name addr to HL
	IF	STRNG OR FLOAT
	PUSH	HL		;and saved
	CALL	PRTST		;print it
	POP	HL		;restore addr
	LD	A,(HL)		;refetch first char
	AND	7FH		;mask off possible high bit
	LD	HL,TYBUF-'A'
	CALL	ADAHL		;address default type buffer location
	LD	A,(DE)		;fetch type byte
	AND	1FH		;mask to type
	CP	(HL)		;compare to default
	JP	Z,TRST1		;same as default, no trailing char
	CALL	TYCHA		;type char to H
	LD	A,H
	CALL	WRITC		;and printed
	ELSE			;NOT STRNG and NOT FLOAT
	CALL	PRTST		;just print the name
	ENDIF
TRST1:	POP	HL
	RET

;TYCHA returns type char in H for type in A.
	IF	STRNG OR FLOAT
TYCHA:
	IF	STRNG
	LD	H,'$'
	CP	STRST
	RET	Z		;string
	ENDIF
	IF	FLOAT
	LD	H,'!'
	CP	SNGST
	RET	Z		;floating
	ENDIF
	IF	CAMAC
	LD	H,'#'
	CP	CAMST
	RET	Z		;camvar
	ENDIF
	LD	H,'%'
	RET			;integer
	ENDIF			;end of STRNG or FLOAT conditional
	ENDIF			;end of NOT COMPL conditional

;CMPST compares the strings at (DE) and M.  Zero set iff match.
CMPST:	LD	A,(DE)
	CP	(HL)
	INC	DE
	INC	HL
	RET	NZ		;return zero reset if no match
	OR	A
	JP	P,CMPST		;keep comparing
	XOR	A		;match -- set zero and return
	RET

;CPYST copies a string from (DE) to M.
CPYS0:	LD	DE,BUFAD
CPYST:	LD	A,(DE)
	LD	(HL),A
	INC	DE
	INC	HL
	OR	A
	JP	P,CPYST
	RET


;end of PARSING
	PAGE
;SDISK 1/12/81
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
;statement routines for CP/M SDISK version


	IF	CPM AND SDISK

;The sequential disk file block working space is located at the
;top of RAM, between (STRT) and (FILET).  Location FILES contains the
;number of file blocks currently allocated.

;Each potential sequential disk file has a 166 byte file block, containing:
;1	File #, 0 if unused and nonzero if OPEN
;2	Mode, 0 for Output and nonzero for Input
;3	Count, 0-7FH indicating last position written/read in current buffer
;4	Column, initially 0, ignored for Input
;5	Width, initially 72, ignored for Input
;6-38	File control block (33 bytes)
;39-166	Buffer (128 bytes)


	IF	RTPAK		;EQUates for C3885 RTPAK version
DCLR0	EQU	UFERR
CLOSE	EQU	UFERR
DINP0	EQU	UFERR
OPEN	EQU	UFERR
DPRIN	EQU	UFERR
EOFFN	EQU	UFERR
	ELSE			;NOT RTPAK

;CLEAR @<expr>
DCLR0:	INC	A		;clear @0 means files=1, etc.
	JP	Z,BFERR		;CLEAR @ 255 not allowed
	LD	C,A		;desired # files to C
	CALL	CLOSN		;close any open files
	LD	A,(FILES)	;current #
	SUB	C
	JP	P,DCLR2		;need fewer, so skip memory check
	LD	DE,-FILEN
	LD	HL,(SYMTA)
DCLR1:	ADD	HL,DE
	INC	A
	JP	NZ,DCLR1	;leave room for additional file
	EX	DE,HL		;new symta to DE
	LD	HL,(EOFAD)
	CALL	CMDHU
	JP	C,OMERR		;not enough space, fatal OM error
DCLR2:	LD	HL,(STRT)
	EX	DE,HL
	CALL	CPLDE		;- top of string space to DE
	LD	HL,(MEMT)
	ADD	HL,DE		;-current amount of string space to HL
	PUSH	HL		;and saved
	LD	A,C
	LD	(FILES),A	;save new file max
	LD	HL,(FILET)	;top of file space to HL
	LD	DE,-FILEN	;space per file to DE
DCLR3:	DEC	A
	JP	Z,DCLR4
	LD	(HL),0		;initialize empty file space
	ADD	HL,DE
	JP	DCLR3
DCLR4:	LD	(STRT),HL	;store new top of string space
	POP	DE
	ADD	HL,DE		;subtract string space needed
	JP	CLE0A		;and initialize symbol table, etc.

;CLOSE [@<expr>, ...]
CLOSE:	CALL	GTSFN		;look for file #
	JP	C,CLOSN		;none, close all
	JP	Z,BFERR		;DK error if @0 closed
	LD	H,B
	LD	L,C
CLOS1:	OR	A
	JP	NZ,CLOSI	;close file open for input
	LD	A,(HL)		;fetch count
	SUB	80H
	LD	B,A		;eof count to B
	LD	C,CNTLZ
CLOS2:	PUSH	BC
	PUSH	HL
	CALL	DWRTC		;write an eof
	POP	HL
	POP	BC
	INC	B
	JP	NZ,CLOS2	;write more eofs
CLOSI:	INC	HL
	INC	HL		;point to file number
	LD	(HL),0		;reset to 0
	LD	DE,-37
	ADD	HL,DE
	EX	DE,HL		;fcb address to DE
	LD	C,DKCLF
	IF	C3885 AND NOT DEBUG
	CALL	BDOS1		;BDOS call with interrupts disabled
	ELSE
	CALL	BDOS
	ENDIF
	CP	255
	RET	NZ
	JP	DKERR		;close error
CLOSN:	CALL	SFILS
CLON1:	DEC	B
	RET	Z		;all closed
	PUSH	BC
	PUSH	DE
	PUSH	HL		;save all
	LD	A,(HL)		;fetch file number
	OR	A
	DEC	HL
	LD	A,(HL)		;fetch type
	DEC	HL		;point to count
	CALL	NZ,CLOS1	;close a file
	POP	HL
	POP	DE
	POP	BC		;restore
	ADD	HL,DE		;point to next
	JP	CLON1		;and see if more to close

;DIR [<ambiguous filename>]
	IF	NOT C3885
DIRCM:	CALL	GTAF5		;set filename to *.*
	XOR	A
	LD	(FCBAD),A	;set disk to @
	LD	(FCBCR),A
	CALL	DTST0		;look for delimiter
	CALL	C,GTAFN		;get desired ambiguous filename if present
	LD	C,17
DIRC1:	CALL	CTEST		;look for console break char
	CALL	WCRLF		;write crlf
	CALL	BDOSF		;search for next occurrence of filename
	CP	255
	RET	Z		;no more
	AND	3
	RRCA
	RRCA
	RRCA
	ADD	A,81H
	LD	E,A
	LD	D,0		;address of filename to DE
	LD	C,8
	CALL	PRSTR		;print the filename
	CALL	WRTSP		;and print a space
	LD	C,3
	CALL	PRSTR		;and print filetype
	LD	C,18		;look for next
	JP	DIRC1
	ENDIF

;INPUT @<expr>, <var list>
DINP0:	PUSH	AF
	CALL	GTCOM		;skip trailing comma
	POP	AF
	JP	Z,INPU1		;INPUT @0, normal INPUT with no quoted string
	OR	A
	JP	Z,FMERR		;FM error if file open for Output
	PUSH	BC		;save file count pointer
DINP1:	CALL	GTLHS		;get destination
	POP	HL		;file count pointer to HL
	CP	STRST
	PUSH	AF		;save type (Zero set iff string)
	LD	DE,NLNAD	;input buffer address to DE
	LD	C,0		;char count to C
DINP2:	CALL	DREAD		;read a disk file char
	CP	' '+1
	JP	C,DINP2		;ignore leading spaces or control chars
	CP	','
	JP	Z,DINP2		;and ignore leading commas
DINP3:	CP	' '
	JP	NZ,DINP4	;next not space
	POP	AF
	PUSH	AF		;Zero set iff string
	LD	A,' '
	JP	NZ,DINP6	;done if space and numeric
DINP4:	CP	','
	JP	Z,DINP6		;done if comma
	CP	CR
	JP	Z,DINP5		;done if <cr>
	LD	(DE),A		;else store the char
	INC	DE
	INC	C		;bump the count
	JP	Z,DINP8		;256 chars
	CALL	DREA0		;else look at next char
	JP	Z,DINP6		;done if eof
	INC	(HL)		;else read it
	JP	DINP3		;and repeat
DINP5:	CALL	DINLF		;ignore trailing <linefeed> if present
DINP6:	POP	AF
	PUSH	HL
	LD	HL,NLNAD
	JP	NZ,DINP9	;numeric value
	EX	DE,HL		;location to DE
	LD	A,STRST
DINP7:	CALL	ASIGV		;assign value to destination
	CALL	GTCND		;look for comma and more vars
	JP	NC,DINP1
	POP	HL		;pop saved file count pointer
DIN10:	CALL	DREA0		;look at first unread char
	RET	Z		;eof, done
	CP	' '
	JP	Z,DIN11		;ignore trailing spaces
	CP	CR
	RET	NZ		;done if next char not space or <cr>
	INC	(HL)		;ignore the trailing <cr>
;DINLF ignores next character iff <linefeed>
DINLF:	CALL	DREA0		;look at next char
	RET	Z		;eof
	CP	LF
	RET	NZ		;not <lf>, return
	INC	(HL)		;read the <lf>
	RET			;and return
DIN11:	INC	(HL)		;read the trailing space
	JP	DIN10		;and look for more trailing spaces or <cr>
DINP8:	DEC	(HL)		;unread the 256th char
	DEC	C		;correct the count
	JP	DINP6		;and assign it
DINP9:	LD	A,CR
	LD	(DE),A		;put <cr> after value
	LD	(TXTP2),HL
	CALL	FLIP		;to read the input buffer
	CALL	GTLIT		;evaluate the numeric value
	JP	C,FIERR		;bad value
	CP	STRST
	JP	Z,FIERR		;string value is also bad
	PUSH	DE
	PUSH	AF
	CALL	FLIP		;to read as before
	LD	A,(DE)		;fetch next char from input buffer
	CP	CR
	JP	NZ,FIERR	;FI error if not <cr>, value is bad
	POP	AF
	POP	DE
	JP	DINP7		;else assign value to destination as above
FIERR:	ERROR	F, F, I		;fatal FI error
FMERR:	ERROR	F, F, M		;fatal FM error

;LINPUT [@<expr>] <string var>
	IF	NOT C3885
LINPT:	CALL	IDTST		;LINPUT is illegal in direct mode
	CALL	GTSFN		;look for file #
	PUSH	AF
	PUSH	BC
	CALL	GTCOM		;skip comma, if any
	CALL	GTLHS		;get destination
	CP	STRST
	JP	NZ,SNERR	;must be string
	POP	HL		;count pointer to HL
	POP	AF
	JP	C,LINP0
	JP	Z,LINP0		;normal linput
	OR	A
	JP	Z,FMERR		;FM error if open for output
	LD	DE,NLNAD
	PUSH	DE		;save input buffer address
	LD	C,0
	JP	LINF1
LINF0:	INC	C		;char count to C
	JP	Z,LINF2		;256 chars read
LINF1:	CALL	DREAD		;read a disk char
	LD	(DE),A		;store it
	INC	DE
	CP	CR
	JP	NZ,LINF0	;read another unless at cr
	POP	DE		;location = input buffer to DE
	CALL	DINLF		;skip trailing <lf> if present
	JP	LINP2		;assign value to destination
LINF2:	DEC	(HL)		;unread the 256th char
	DEC	C		;correct the count
	POP	DE		;restore location
	JP	LINP2		;assign value to desination
;LINPUT from the console
LINP0:	LD	HL,(TEXTP)
	PUSH	HL		;save textp
	CALL	GTLIN		;get input line
	EX	(SP),HL		;recover old textp
	LD	(TEXTP),HL
	POP	HL
	LD	D,H
	LD	E,L		;copy first char address to DE
	LD	A,CR
	LD	C,0		;char count to C
LINP1:	CP	(HL)
	JP	Z,LINP2		;done if char is cr
	INC	C
	INC	HL
	JP	LINP1
LINP2:	LD	A,STRST
	JP	ASIGV		;assign string value to destination
	ENDIF

;MARGIN [@<expr>,] <expr>
	IF	NOT C3885
MARGN:	CALL	GTSFN		;find file
	JP	C,MARG0		;none, change WIDTH
	PUSH	AF		;save Zero status
	PUSH	BC		;and pointer
	LD	D,','
	CALL	GTDSN		;skip ,
	CALL	GTBEX		;get byte value
	POP	HL		;pointer to HL
	POP	AF		;restore Zero
	JP	Z,MARG1		;@0, change WIDTH
	DEC	HL
	DEC	HL		;point to file width field
	LD	(HL),C		;and change it
	RET
MARG0:	CALL	GTBEX		;get byte value
MARG1:	LD	A,C
	LD	(WIDTH),A	;value to WIDTH
	RET
	ENDIF

;OPEN {I | O | U} @<expr>, <filename>
OPEN:	CALL	GTCHA		;get desired mode
	PUSH	AF		;and save
	CALL	GTCOM		;allow comma after mode
	CALL	GTATN		;get desired file number
	JP	C,BFERR
	JP	Z,BFERR		;0 not allowed
	CALL	SFILS		;set up B, DE, HL for search
	LD	C,B		;max # files to C also
	PUSH	DE
	PUSH	HL		;and save
;first check if number already associated with open file
OPEN1:	DEC	C
	JP	Z,OPEN2
	CP	(HL)
	JP	Z,FOERR		;desired number already open, FO error
	ADD	HL,DE
	JP	OPEN1		;else try next
OPEN2:	LD	C,A		;desired number to C
	PUSH	BC
	LD	D,','
	CALL	GTDSN		;skip ,
	CALL	GTFNM		;get desired filename
;check if file of same name is already open
	POP	BC
	POP	HL
	PUSH	HL
	PUSH	BC
OPN2A:	DEC	B
	JP	Z,OPN2C		;checked all files, ok
	LD	A,(HL)		;fetch file #
	LD	DE,-37
	ADD	HL,DE		;address the file fcb
	OR	A
	JP	Z,OPN2B		;no file, skip the test
	PUSH	BC
	PUSH	HL
	LD	DE,FCBAD
	LD	BC,(12 SHL 8) OR 12;count = 12 chars to B and C
	CALL	CMSTR		;compare file fcb with new fcb
	JP	Z,FOERR		;already open, FO error
	POP	HL
	POP	BC
OPN2B:	LD	DE,-129
	ADD	HL,DE		;address the next file #
	JP	OPN2A		;and test it
OPN2C:	POP	BC
	POP	HL
	POP	DE
;then check if space available for file
OPEN3:	DEC	B
	JP	Z,OPERR		;all available file areas full
	LD	A,(HL)
	OR	A
	JP	Z,OPEN4		;available
	ADD	HL,DE
	JP	OPEN3		;else try next
OPEN4:	LD	(HL),C
	DEC	HL
	POP	AF		;recover desired mode
	CP	'O'
	JP	Z,OPENO
	CP	'U'
	JP	Z,OPENU
;else open for input
	CP	'I'
	JP	NZ,SNERR	;SN error if not I
	INC	HL
	LD	(HL),0		;reset file # to 0 in case not found
	PUSH	BC
	PUSH	HL
	CALL	CDKOP		;open the file
	POP	HL
	POP	BC
	LD	(HL),C		;set the file #
	DEC	HL
	LD	(HL),255	;mode = input
	DEC	HL
	LD	(HL),7FH	;count = 7FH so next read gets new buffer
	LD	DE,-35
	ADD	HL,DE		;HL addresses file fcb
	JP	OPEN6
;open for output
OPENO:	XOR	A
	LD	(HL),A		;mode = output
	DEC	HL
	LD	(HL),A		;buffer address = 0
	DEC	HL
	LD	(HL),A		;column = 0
	DEC	HL
	LD	(HL),72		;default width = 72
	LD	DE,-33
	ADD	HL,DE		;HL addresses file fcb
	PUSH	HL
	CALL	CDKMK		;delete old, make new
	POP	HL
OPEN6:	LD	BC,FCBAD
	LD	DE,33
	JP	MOVED		;copy default fcb to fcb and return
;open for update
OPENU:	LD	(HL),0		;mode = output
	DEC	HL
	PUSH	HL		;save count address
	DEC	HL
	LD	(HL),72		;column = 72
	DEC	HL
	LD	(HL),72		;default width = 72
	LD	DE,-161
	ADD	HL,DE		;address buffer base
	EX	(SP),HL		;save
	PUSH	HL		;and save count address
	CALL	CDKOP		;open the file
OPNU1:	CALL	CDKRD		;read a record
	LD	A,0		;count zero in case eof
	JP	Z,OPNU4		;eof
	LD	HL,DMAAD	;default dma address to HL
	LD	A,CNTLZ		;eof to A
OPNU2:	CP	(HL)		;check if next char is eof
	JP	Z,OPNU3		;yup
	INC	L		;else try next
	JP	NZ,OPNU2
	JP	OPNU1		;reading another buffer if necessary
OPNU3:	LD	A,L
	SUB	80H		;compute the new count
OPNU4:	POP	HL
	LD	(HL),A		;store the new count
	POP	HL
	LD	BC,DMAAD
	LD	DE,80H
	CALL	MOVED		;copy the buffer to file entry buffer
	LD	A,(FCBCR)
	DEC	A
	LD	(FCBCR),A	;update the cr field to rewrite the same record
	JP	OPEN6		;and copy the fcb to the file entry
FOERR:	ERROR	F, F, O		;fatal FO error
OPERR:	ERROR	F, O, P		;fatal OP error

;PRINT @<expr>, <print list>
DPRIN:	PUSH	AF
	LD	D,','
	CALL	GTD		;skip comma if present
	POP	AF
	JP	Z,PRIN0		;normal PRINT if @0
	OR	A
	JP	NZ,FMERR	;FM error if file is OPEN for input
	LD	HL,NULLS
	LD	A,(HL)		;fetch current NULLS value
	PUSH	AF		;and save
	LD	(HL),0		;and reset to 0 for disk PRINT
	LD	HL,(COLUM)
	PUSH	HL		;save current column and width
	LD	H,B
	LD	L,C
	LD	(FILEP),HL	;set file pointer so PRINT goes to file
	DEC	HL
	LD	E,(HL)		;column to E
	PUSH	HL
	DEC	HL
	LD	D,(HL)		;width to D
	EX	DE,HL
	LD	(COLUM),HL	;set file column and width
	CALL	PRIN0		;print the line
	LD	A,(COLUM)
	POP	HL
	LD	(HL),A		;reset file column
	POP	HL
	LD	(COLUM),HL	;restore column and width
	POP	AF		;recover original NULLS value
	LD	(NULLS),A	;and restore it
	LD	HL,0
	LD	(FILEP),HL	;reset file pointer
	RET

;SCRATCH [<ambiguous filename>]
	IF	NOT C3885
SCRAT:	CALL	GTAFN		;get ambiguous filename
	LD	C,DKDLF
	JP	BDOSF		;delete it
	ENDIF


;functions

;EOF: <integer> --> <integer>
EOFFN:	LD	A,B
	OR	A
	JP	NZ,BFERR	;arg too large, cannot be file #
	LD	A,C
	CALL	GTSF0		;find arg value
	OR	A
	JP	Z,FMERR		;FM error if open for output
	LD	H,B
	LD	L,C
EOFF0:	CALL	DREA0		;look at next char
	LD	BC,-1
	RET	Z		;eof, return -1
	INC	BC
	RET			;no eof, return 0


;routines

;DREAD reads a char from a disk file, issues DK error if char is EOF.
DREAD:	CALL	DREA0		;read a char
	JP	Z,EFERR		;EF error if read through eof
	INC	(HL)		;else read the char
	RET
EFERR:	ERROR	F, E, F		;fatal EF error

;DREA0 looks at the next character from a disk file.
;Call:	HL	pointer to count of file entry
;Retn:	A	next character
;	BC,DE,HL	preserved
;	Zero	Set iff eof
DREA0:	PUSH	HL
	PUSH	DE
	LD	A,(HL)		;fetch count
	INC	A		;and bump it
	JP	P,DREA1		;ok unless 80H
;must read a new buffer of characters and reset count
	LD	(HL),255	;reset count of last char read
	PUSH	HL
	PUSH	BC
	LD	DE,-35
	ADD	HL,DE
	PUSH	HL		;save fcb address
	LD	DE,-128
	ADD	HL,DE		;address buffer
	EX	DE,HL
	CALL	STDMA		;set dma address to buffer
	POP	DE
	LD	C,DKRDF
	IF	C3885 AND NOT DEBUG
	CALL	BDOS1		;BDOS call with interrupts disabled
	ELSE
	CALL	BDOS
	ENDIF
	PUSH	AF		;save status
	CALL	RTDMA		;and reset the dma address to 80H
	POP	AF		;restore status
	POP	BC
	POP	HL
	CP	2
	JP	Z,DKERR		;read error
	CP	1
	LD	A,CNTLZ
	JP	Z,DREA2		;return if eof
	XOR	A		;reset count
DREA1:	LD	DE,-163
	ADD	HL,DE
	CALL	ADAHL		;address desired char
	LD	A,(HL)		;fetch it
DREA2:	CP	CNTLZ		;Zero set iff eof
	POP	DE
	POP	HL
	RET

DWRIT:	CALL	DWRTC	;write char to disk file
	JP	POP4		;restore and return
DWRTC:	LD	A,(HL)		;fetch count
	INC	(HL)		;update count
	PUSH	AF
	EX	DE,HL		;count pointer to DE
	LD	HL,-163
	ADD	HL,DE		;point to buffer base
	CALL	ADAHL		;add count+base = destination
	LD	(HL),C		;char to destination
	POP	AF
	RET	P		;return unless count is 80H
	XOR	A
	LD	(DE),A		;store new count = 0
	INC	HL		;point to fcb
	PUSH	HL		;save fcb address
	LD	DE,-128
	ADD	HL,DE
	EX	DE,HL
	CALL	STDMA		;set dma address to buffer
	POP	DE		;recover fcb address
	PUSH	DE		;and save again
	LD	C,DKWTF
	IF	C3885 AND NOT DEBUG
	CALL	BDOS1		;BDOS call with interrupts disabled
	ELSE
	CALL	BDOS
	ENDIF
	PUSH	AF
	CALL	RTDMA		;reset dma address
	POP	AF
	POP	DE		;fcb address to DE
	OR	A
	RET	Z		;successful write, return
	LD	HL,37		;otherwise disk is full
	ADD	HL,DE
	LD	(HL),0		;reset the file # to 0, now inactive
	LD	C,DKDLF
	IF	C3885 AND NOT DEBUG
	CALL	BDOS1		;BDOS call with interrupts disabled
	ELSE
	CALL	BDOS
	ENDIF
	ERROR	F, D, F		;fatal DF error

	ENDIF			;end of NOT RTPAK conditional

;@ <expr>
;GTATN gets @ followed by a number for sequential disk routines.
;A fatal DK error occurs if the <expr> is not in the range 0 to 255.
;Retn:	Carry	Set iff no @ found
;	Zero	Set iff <expr> is 0
;	A	Value of <expr>
GTATN:	LD	D,'@'
	CALL	GTD		;look for @
	RET	C		;not found
	CALL	GTEXP		;evaluate the <expr>
	LD	A,B
	OR	A
	JP	NZ,BFERR	;fatal BF error if not between 0 and 255
	OR	C		;value to A
	RET
BFERR:	ERROR	F, B, F		;fatal BF error

;GTSFN finds an OPEN sequential disk file.  A DK error occurs
;if a nonzero file # is given but no corresponding OPEN file exists.
;Retn:	Carry	Set iff no @ found
;	Zero	Set iff file @0 is specified
;	A	Mode of file (0 output, nonzero input)
;	BC	Pointer to count field of file entry
;	HL	Pointer to byte preceding file buffer
GTSFN:	CALL	GTATN		;look for @<expr>
	RET	C		;no @
	RET	Z		;@ 0
	IF	RTPAK
	JP	UFERR		;issue UF error if nonzero file # in RTPAK
	ELSE			;NOT RTPAK
GTSF0:	CALL	SFILS		;set up registers for search -- EOF entry point
GTSF1:	DEC	B
	JP	Z,BFERR		;not found, BF error
	CP	(HL)		;compare desired to actual
	JP	Z,GTSF2		;gotcha
	ADD	HL,DE		;else try next
	JP	GTSF1
GTSF2:	LD	B,H
	LD	C,L		;file pointer to BC
	ADD	HL,DE		;HL points below buffer
	OR	1		;Carry and Zero reset
	DEC	BC
	LD	A,(BC)		;fetch mode
	DEC	BC		;point to count with BC
	RET

SFILS:	LD	HL,FILES
	LD	B,(HL)		;max # files to B
	LD	HL,(FILET)
	LD	DE,-FILEN
	RET

	ENDIF			;end of NOT RTPAK conditional
	ENDIF			;end of SDISK conditional

;end of SDISK
	PAGE
;STACKS 5/23/79
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979 by Mark Williams Company, Chicago
;symbol table and control stack manipulation routines


;FNDTK finds the location of a token in the keyword table.
;Call:	A	character or token
;Retn:	Carry	Reset if character, set if token
;	A	Preserved if character, 0 if token
;	BC,DE	Preserved
;	HL	Preserved if character, address of table entry if token
	IF	NOT COMPL
FNDTK:	OR	A
	IF	KEY80
	JP	M,FNDT1		;command or function token
	CP	20H
	RET	NC		;printable char, return Carry reset
	CP	RWDTK
	CCF
	RET	NC		;<cr> or <bell>, return Carry reset
	LD	HL,RWDTA	;elese reserved word token
	SUB	(RWDTK-1) AND 0FFH;token bias
	JP	FNDT2
	ELSE			;not KEY80
	RET	P		;return Carry reset if positive
	ENDIF
FNDT1:	LD	HL,KEYTA
	ADD	A,NKEYS+1	;token bias
FNDT2:	DEC	A		;decement token count
	JP	NZ,FNDT3	;not there yet
	SCF			;else set Carry
	RET			;and return
FNDT3:	PUSH	AF		;save token count
FNDT4:	LD	A,(HL)		;fetch char
	INC	HL
	OR	A
	JP	P,FNDT4		;skip more chars in same keyword
	POP	AF		;restore token count
	JP	FNDT2		;and keep looking
	ENDIF

;STPSH builds a new symbol table entry.
;Call:	A	token
;	HL	entry length
;	(bufad)	symbol name
;Retn:	(symta)	(symta) - length
;	((symta))	length
;	((symta)+1)	token
;	((symta)+2...)	name
;Other bytes in the entry are zeroed
;	A	token
;	BC	preserved
;	DE	address of name
;	HL	address following name
STPSH:	PUSH	BC
	PUSH	AF		;save token
	EX	DE,HL		;length to DE
	LD	A,254
	CP	E		;Carry set iff (E) is 255
	SBC	A,A		;A is 255 if (E) is 255, 0 otherwise
	OR	D		;Zero set iff (DE) <= 254
	JP	Z,STPS1
	INC	DE
	INC	DE
STPS1:	PUSH	DE		;save length
	CALL	CPLDE		;- length to DE
	LD	HL,(SYMTA)
	ADD	HL,DE		;old - length = new symbol table address
	JP	NC,OMERR	;much too big, OM error
	EX	DE,HL
	LD	HL,(CSTKP)
	EX	DE,HL		;CSTKP to DE
	CALL	CMDHU		;compare to new SYMTA
	JP	NC,OMERR	;CSTKP >= new SYMTA, OM error
	LD	(SYMTA),HL	;store new SYMTA
	POP	DE		;restore length
	PUSH	DE		;and save
	PUSH	HL		;and save SYMTA
STPS2:	LD	(HL),0		;zero a byte
	INC	HL
	DEC	DE
	LD	A,D
	OR	E
	JP	NZ,STPS2	;zero more bytes
	POP	HL		;restore pointer
	POP	DE		;and length
	LD	A,D
	OR	A
	JP	Z,STPS3
	LD	(HL),255	;long entry
	INC	HL
	LD	(HL),D
	INC	HL
STPS3:	LD	(HL),E		;store length
	INC	HL
	POP	AF		;recover token
	PUSH	AF
	LD	(HL),A		;store token
	INC	HL
	PUSH	HL		;save name pointer
	CALL	CPYS0		;copy name from bufad
	POP	DE		;return name pointer in DE
	POP	AF		;restore token to A
	POP	BC
	RET
OMERR:	ERROR	F, O, M		;fatal OM error

;STNXT gets the address of the next symbol table entry.
;Call:	HL	address of current symbol table entry length byte
;Retn:	Carry	set iff no more entries
;	BC	preserved
;	DE	current entry type byte address
;	HL	next entry address
STNXT:	LD	A,(HL)		;fetch length byte
	OR	A
	SCF
	RET	Z		;return carry set if at end of table
	LD	D,H
	LD	E,L
	INC	DE		;point to type byte
	CP	255		;check if long entry
	JP	NZ,ADAHL	;no, so length + current = next and return
	EX	DE,HL		;current to DE, length byte addr to HL
	LD	A,(HL)
	INC	HL
	PUSH	HL		;save type byte addr - 1
	LD	L,(HL)
	LD	H,A		;length to HL
	ADD	HL,DE		;current + length = next
	POP	DE		;type byte addr to DE
	INC	DE
	RET

;STLKU looks up a symbol in the symbol table.
;Call:	(bufad)	symbol name string
;	(varty)	symbol type token
;Retn:	Carry	set iff not found, otherwise:
;	DE	entry type address
;	HL	address following name in entry
STLKU:	LD	A,(VARTY)
STLK0:	LD	HL,(SYMTA)
	LD	B,A		;desired type to B
STLK1:	CALL	STNXT		;address next entry
	RET	C		;return carry set iff not found
	LD	A,(DE)		;fetch entry type
	AND	1FH		;mask to type
	CP	B
	JP	NZ,STLK1	;not the right type, try next
	PUSH	HL		;save next
	PUSH	DE		;save type byte addr
	EX	DE,HL
	INC	HL		;point to name
	LD	DE,BUFAD
	CALL	CMPST		;compare to desired name
	POP	DE		;restore type addr to DE
	JP	Z,POP1		;matched, pop next to BC and retn Carry reset
	POP	HL		;else next to HL
	JP	STLK1		;and try next

;STZAP resets BREAK and FN entries in the symbol table.
;Retn:	BC	preserved
;	A,DE,HL	clobbered
STZAP:	LD	HL,(SYMTA)
STZA1:	CALL	STNXT
	IF	COMPL
	RET	C		;end of table, done if no line breaks to zap
	ELSE
	JP	C,UNBKL		;unbreak lines if not compl
	ENDIF
	LD	A,(DE)
	AND	1FH		;mask to type
	IF	NOT COMPL
	CP	BRKST
	JP	Z,STZA2		;break
	ENDIF
	CP	UFNST		;check if user-defined fn
	JP	NZ,STZA1	;neither FN nor break, try next
STZA2:	XOR	A
	LD	(DE),A		;store 0 type byte
	JP	STZA1

	IF	NOT COMPL
;UNBKL removes all line breakpoints.
UNBKL:
	IF	ROMSQ		;first loc to test to HL
	LD	HL,(SOURC)
	CALL	RTEST
	RET	NZ		;done if ROM
	ELSE
	LD	HL,SRCAD
	ENDIF
UNBL1:	LD	A,(HL)
	OR	A
	RET	Z		;done
	PUSH	HL
	CALL	UNBR1		;unbreak a line
	POP	HL
	CALL	ADAHL		;point to next line
	JP	UNBL1		;and keep going
	ENDIF

;CPUSH checks that sufficient free memory remains to build a control stack
;entry and if not issues an OM error.  Otherwise it pushes a token, (TEXTP) and
;(LNNUM) to the control stack, and updates the stack pointer.
;Call:	A	token (l.s. 5 bits give entry length)
;Retn:	A,BC	clobbered
;	DE	return text pointer
;	HL	(cstkp) - 4
;	(cstkp)	(cstkp) + (A4-A0)
;	((cstkp))	token
;	((cstkp)-1:(cstkp)-2)	line # address
;	((cstkp)-3:(cstkp)-4)	return text pointer
CPUSH:	LD	HL,(TEXTP)
	PUSH	HL
CPSH1:	LD	B,A		;save token
	LD	HL,(CSTKP)
CPSH2:	AND	1FH		;mask to length
	CALL	ADAHL
	JP	C,CPSH3		;new stacktop > 64K, OM error
	CALL	CSPST		;store new control stack pointer
	EX	DE,HL		;cstack pointer to DE
	LD	HL,(SYMTA)	;symbol table pointer to HL
	CALL	CMDHU		;compare
	JP	NC,CPSH3	;OM -- flush and continue
	LD	HL,(LNNUM)
	IF	NOT COMPL
	LD	A,H
	OR	L
	CALL	Z,ICSTD		;increment CSTACK direct count if direct
	ENDIF
	EX	DE,HL		;current line # address to DE
	LD	(HL),B		;token to control stack
	CALL	MVMDE		;return line # address to control stack
	POP	DE
	JP	MVMDE		;return text pointer to control stack & return
CPSH3:	CALL	CLEA2		;reset CSTACK pointer
	ERROR	N, O, M		;nonfatal OM error
	LD	A,B		;restore token
	JP	CPSH2		;try again

;CSPOP is used to pop information from the control stack for RETURNs from
;GOSUBs and interrupts, for CONTinues, and for NEXTs.
;If the entry was made from direct mode, the dmode count CSTKD is
;decremented and an ID error issued if < 0.
;Call:	HL	address of control stack entry type/length byte
;Retn:	(lnnum)	control stack entry line # bytes
;	(textp)	control stack entry return address
;	PSW,BC	preserved
;	DE	new textp
;	HL	(HL) - 5
CSPOP:
	IF	COMPL
	DEC	HL
	CALL	MVDEM		;line # to DE
	ELSE			;non COMPL version must update CSTKD
	PUSH	AF
	PUSH	HL		;save type byte addr
	DEC	HL
	CALL	MVDEM		;line # of entry to DE
	EX	(SP),HL		;save entry pointer, type byte addr to HL
	IF	NOT COMPL
	LD	A,D
	OR	E		;test if direct mode entry
	JP	NZ,CSPO1	;no -- restore and return
	CALL	DCSTD		;yes -- decrement CSTACK direct count
	LD	A,(HL)		;fetch type byte
	CP	CSFOR		;check if doing a NEXT
	CALL	Z,ICSTD		;undecrement count if so
	ENDIF
CSPO1:	POP	HL		;restore entry ptr
	POP	AF
	ENDIF
	EX	DE,HL
	LD	(LNNUM),HL	;store new lnnum
	EX	DE,HL
	CALL	MVDEM
	EX	DE,HL
	LD	(TEXTP),HL	;store new textp
	EX	DE,HL
	RET			;and continue from there

;CSDIG digs in the control stack for an entry with type matching B or C.
;Call:	B,C	desired type/length bytes
;Retn:	A	type/length byte found, 0 if none
;	BC,DE	preserved
;	HL	addr of type/length byte, eofad if not found
;	Carry	set iff not found
CSDIG:	LD	HL,(CSTKP)
CSDI1:	LD	A,(HL)		;fetch type/length byte
	CP	B
	RET	Z		;found
	CP	C
	RET	Z		;found
	AND	1FH		;mask to length
	SCF
	RET	Z		;not found
	CALL	SBAHL		;address next
	JP	CSDI1		;and try it

;CSRST resets the control stack after purging an entry.
;Call:	A	type/length byte of entry to be purged
;	HL	address of next entry in stack
;Retn:	BC	preserved
;	HL	new cstkp
CSRST:	PUSH	BC
	INC	HL		;point to destination
	PUSH	HL		;and save it
	AND	1FH		;mask A to length
	CALL	ADAHL		;destination + offset = source
	PUSH	HL		;saved
	EX	DE,HL
	CALL	CPLDE
	LD	HL,(CSTKP)
	ADD	HL,DE		;# of bytes to move -1 to HL
	INC	HL
	EX	DE,HL		;and then to DE
	POP	BC		;source to BC
	POP	HL		;destination to HL
	CALL	C,MOVED		;move rest  of stack
	POP	BC		;restore BC
	DEC	HL		;readdress cstkp
	JP	CSPST		;and reset it

;ICSTD increments the CSTACK direct count CSTKD.  DCSTD decrements CSTKD and
;issues an ID error if negative.  CSTKD counts how many CSTACK entries
;have been built from direct mode, and catches errors such as attempting to
;RETURN or NEXT when the GOSUB or FOR context has been lost.
;Status bits affected, all registers preserved.
	IF	NOT COMPL
ICSTD:	PUSH	HL
	LD	HL,CSTKD
	INC	(HL)		;increment cstack direct count
	POP	HL
	RET
DCSTD:	PUSH	HL
	LD	HL,CSTKD
	DEC	(HL)		;decrement cstack direct count
	POP	HL
	RET	P		;ok if nonnegative
	JP	IDERR		;fatal ID error if negative
	ENDIF


;end of STACKS
	PAGE
;STATES1 12/02/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;statement routines for statements ASSIGN through EXEC


;ASSIGN {LST# | PUN# | RDR# | CON#} <expr>
	IF	(NOT CAMAC) AND (NOT WILD)
;ASSIGN changes the value of the specified field of IOBYTE.
ASSIG:	CALL	GTCHA		;fetch token
	SUB	CONTK		;subtract CON# token bias
	JP	C,SNERR		;too small
	CP	4
	JP	NC,SNERR	;too big
	RLCA			;*2 bits  = shift count (0, 2, 4, 6)
	LD	E,A		;shift count to E
	CALL	GTEXP		;arg to BC
	LD	A,C
	AND	0FCH
	OR	B		;check if arg > 3
	CALL	NZ,FCERN	;yes, nonfatal FC error
	LD	A,3
	LD	B,A		;mask to B
	AND	C
	LD	C,A		;masked new bits to C1-0
	IF	NONST
	LD	A,E
	OR	A		;check if CON#
	JP	NZ,ASSI1	;no, just update IOBYTE
	LD	B,A		;0 to B
	LD	HL,JMPTA+60	;base of console status jump vector to HL
	ADD	HL,BC
	ADD	HL,BC
	ADD	HL,BC		;+3 bytes * desired CON#
	LD	(CSTAT+1),HL	;becomes new console status jump
	LD	B,3		;restore mask to B
	ENDIF
ASSI1:	CALL	LSHFT		;shift mask and bits to desired position
	LD	A,B
	CPL
	LD	HL,IOBYT
	AND	(HL)		;mask out old field
	OR	C		;OR in the new field
	LD	(HL),A		;store the new iobyte
	RET
	ENDIF

;AUTO [<line #> [, <line #>]]
	IF	EDITC
	IF	COMPL
AUTO	EQU	UFERR
	ELSE
AUTO:
	IF	ROMSQ
	CALL	ISSRC		;must be addressing working space
	ENDIF
	LD	HL,10
	PUSH	HL		;default increment = 10
	PUSH	HL		;default first line # = 10
	CALL	GTLNO		;look for <line #>
	JP	C,AUTO1		;no args, take defaults
	EX	DE,HL		;<line #> to HL
	EX	(SP),HL		;and replaces default <line #>
	CALL	GTCND		;look for comma
	JP	C,AUTO1		;no second arg
	CALL	GTLNO		;look for increment arg
	JP	C,SNERR		;not found
	EX	DE,HL		;increment to HL
	POP	DE
	EX	(SP),HL		;and replaces default incrment
	PUSH	DE
AUTO1:	CALL	IITST		;AUTO illegal indirect
;At AUTO2 the next desired line # and the increment are on the stack.
AUTO2:	POP	BC		;next line # to BC
	PUSH	BC
	CALL	WRTBU		;write the line #
	LD	D,B
	LD	E,C		;line # to DE
	CALL	FINDL		;look for it in current source text
	LD	A,' '
	JP	C,AUTO3		;write a space if no such line exists
	LD	A,'*'		;else write a *
AUTO3:	CALL	WRITC
	CALL	LNNU0		;reset LNNUM to 0 in case ^C typed
	CALL	GTLIN		;get line from user
	CALL	TKIZE		;tokenize it
	JP	Z,DMOD2		;return to DMODE if user types <cr>
	CALL	NC,LNNU0
	JP	NC,SNERR	;SN error if <line #> typed
	POP	HL
	PUSH	HL
	LD	(LNNUM),HL	;set LNNUM to desired line
	CALL	ADDLN		;add new line to source text
	POP	HL
	POP	DE
	ADD	HL,DE		;new line # is line # + increment
	JP	C,AUTO4		;OV error if > 65535
	PUSH	DE
	PUSH	HL
	JP	AUTO2		;else get next line
AUTO4:	CALL	LNNU0
	LD	A,CR
	LD	(NLNAD),A	;reset input buffer for error message
	CALL	IOVER		;issue OV error
	JP	DMOD2		;and return to direct mode
	ENDIF
	ELSE
AUTO	EQU	EXERR		;EX error in non-EDITC versions
	ENDIF

;BREAK {<var list> | <line #> [,<expr>] [;<var list>] [;$]}
;BREAK <var list> creates variable breaks by setting symbol table entry bits.
;BREAK <line #>... creates line breakpoints by setting the line break byte,
;and also building a symbol table line break entry if necessary.
	IF	COMPL
BREAK	EQU	UFERR		;UF error in COMPL version
	ELSE
BREAK:	CALL	GTLNO		;look for line #
	JP	C,BKVAR		;no line #, must be var break
	IF	ROMSQ
	CALL	ISROM		;line breaks only if running in RAM
	ENDIF
	CALL	FDLNO		;find the line
	INC	HL
	INC	HL
	INC	HL		;address break byte
	PUSH	HL		;save break byte addr
	CALL	GTCOM		;look for comma
	LD	BC,1		;default count = 1 to BC
	CALL	NC,GTEXP	;get count if comma
	PUSH	BC		;save count
	DEC	BC
	LD	A,B
	OR	C		;Zero set iff count = 1
	LD	A,1		;break byte value to A
	JP	Z,BRKL1
	OR	2		;bit 1 on iff count <> 1
;At BRKL1 the break byte addr and count are PUSHed, the break byte is in A.
BRKL1:	LD	E,A		;save the break byte
	LD	D,SEMIC
	CALL	GTD		;look for ;
	LD	(TXTP2),HL	;save varlist address
	JP	NZ,BRKL4	;no ; present
BRKL2:	PUSH	DE
	CALL	GTVAR		;look for var ref
	POP	DE
	JP	C,BRKL3		;none, must be $
	CALL	IDTST		;BREAK illegal direct if <var list> present
	LD	A,E
	OR	6		;set varlist bits in break byte
	LD	E,A
	CALL	GTCOM		;look for comma
	JP	NC,BRKL2	;more vars
	CALL	GTD		;look for ;
	JP	NZ,BRKL4
BRKL3:	LD	D,'$'
	CALL	GTDSN		;skip $
	LD	A,E
	OR	8		;set bit 3 to indicate break to DMODE
	LD	E,A
BRKL4:	LD	A,E		;break byte value to A
	POP	BC		;count to BC
	POP	HL		;restore break byte addr
	LD	(HL),A		;store break byte
	AND	6		;check if must build symbol table entry
	RET	Z		;no, done
;Now a symbol table line break entry is built.  The entry contains
;a length byte, type byte, three 'name' bytes with the encoded line #,
;two count bytes (how many passes until next break), two reset bytes (the
;value for resetting count when it reaches zero), and two varlist addr bytes.
	PUSH	BC		;save count
	DEC	HL
	DEC	HL		;HL contains line # addr
	CALL	BKNAM		;form break entry name in BUFAD
	LD	HL,11		;entry length = 11
	LD	A,BRKST		;token to A
	CALL	STPSH		;build the entry
	POP	DE		;count to DE
	LD	(HL),E
	INC	HL
	LD	(HL),D		;count to entry
	CALL	MOMDE		;reset to entry
	EX	DE,HL
	LD	HL,(TXTP2)
	EX	DE,HL		;varlist address to DE
	ENDIF
MOMDE:	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D		;varlist address to entry
	RET			;and return
	IF	NOT COMPL
;BKVAR sets type byte bits in symbol table entries to indicate variable breaks.
BKVAR:	CALL	FDVAR		;find variable name
	JP	C,SNERR		;no var
	LD	A,(DE)
	OR	80H		;set break bit in type byte
	LD	(DE),A
	CALL	GTCND		;look for comma
	JP	NC,BKVAR	;break another var
	RET
	ENDIF

;CALL <expr> [, {<var ref> | * <var name>}]*
CALCM:	LD	HL,NEXTC
	PUSH	HL		;push return address to scan to next statement
	CALL	GTEXP		;get location
	PUSH	BC
	RET			;branch to user routine

;CAMAC commands are in module CAMAC.

;CLEAR
;CLEAR <expr>		[in STRNG versions]
;CLEAR @ <expr>		[in CPM SDISK versions]
;DCLR0 is in module SDISK.
CLEAR:
	IF	STRNG
	CALL	DTST0		;check if delimiter follows
	JP	NC,CLEA1	;yes, keep same string space
	IF	CPM AND SDISK
	CALL	GTATN		;look for @ <expr>
	JP	NC,DCLR0	;change max number of disk files
	ENDIF
	CALL	GTEXP		;otherwise get argument
	LD	A,B
	OR	A
	JP	M,FCERF		;fatal FC error if negative string space given
	LD	D,B
	LD	E,C		;to DE
	CALL	CPLDE		;complement desired amount of string space
	LD	HL,(EOFAD)
	LD	BC,9
	ADD	HL,BC		;leave enough room to compute trivial exprs
	PUSH	HL		;save eof top pointer
	LD	HL,(STRT)	;top of string space to HL
	ADD	HL,DE		;new MEMT value to HL
	POP	DE		;eof pointer to DE
	CALL	CMDHU		;make sure sufficient space available
	JP	NC,OMERR	;no -- fatal OM error
CLE0A:	LD	(MEMT),HL	;yes -- store new MEMT value
	LD	(HL),0		;and initialize symbol table
	ENDIF
CLEA1:
	IF	NOT COMPL
	CALL	UNBKL		;unbreak line breaks
	ENDIF
	LD	HL,(MEMT)
	IF	STRNG
	LD	(STRPT),HL	;initialize string pointer
	LD	(STRP2),HL	;and string temp pointer
	ENDIF
	LD	(SYMTA),HL	;and symbol table
	IF	STRNG OR FLOAT	;reset default type buffer entries
	IF	FLOAT		;default token to B, buffer length 26 to C
	LD	BC,(SNGST SHL 8) OR 26
	ELSE
	LD	BC,(INTST SHL 8) OR 26
	ENDIF
	LD	HL,TYBUF	;default type buffer address to HL
	CALL	FILLM		;reset default type buffer
	ENDIF			;end of STRNG or FLOAT conditional
	IF	CAMAC AND C3908	;reset BKSET parameters if CAMAC on 3908
	LD	BC,7		;0 to B, 7 to C
	LD	HL,CMBLK
	CALL	FILLM		;reset BKSET parameters to 0
	ENDIF
	IF	PACKI
	CALL	PINIT		;reset Packard FIELD and data buffer
	LD	(PAONL),A	;and reset mode to OFFLINE
	ENDIF
CLEA2:	LD	HL,(EOFAD)
	JP	CSPST		;reset the control stack

;CONT
	IF	COMPL
CONT	EQU	UFERR		;UF error in COMPL version
	ELSE
CONT:	CALL	IITST		;CONT illegal indirect
	LD	HL,(CSTKP)
	LD	A,(HL)
	CP	CSBRK		;see if BREAK entry atop control stack
	JP	Z,CONT1		;yes -- pop it
	CP	CSLBK		;see if line break entry
	JP	NZ,CNERR	;no -- CN error
	CALL	CONT1		;pop entry
	POP	BC		;pop CONT return address
	JP	XSTAT		;continue at XSTAT, skipping break test
CONT1:	CALL	CSPOP		;yes -- pop it
	JP	CSPST		;reset control stack pointer and return
CNERR:	ERROR	F, C, N		;fatal CN error
	ENDIF

;DATA [<expr>] [,<expr>]*
;DATA is ignored when encountered, so the command dispatch table branches
;to GTDEL to scan to next command for DATA.

;DEF FN <var name> [(<var name> [, <var name>]* )] = <expr>
;DEF {INT | STR | SNG | CAMVAR} <letter> [- <letter>]
DEF:	CALL	GTCHA		;get following token
	CP	UDFNT
	JP	NZ,DEFVT	;not a user-def FN, must be var declaration
;DEF FN builds a symbol table entry for a user-defined function.  The entry
;contains a length byte, type token, name bytes, and two address bytes.
;The addr bytes contain the fn body addr if 0-ary, or bound var addr otherwise.
;The type token is UFNST if 0-ary and (UFNST or 20H) otherwise.
	CALL	IDTST		;DEF FN illegal direct
	CALL	GTNAM		;get fn name
	LD	HL,4
	CALL	ADAHL		;name length + overhead = entry length to HL
	PUSH	HL		;and saved
	LD	A,UFNST
	CALL	STLK0		;look up the fn name
	JP	NC,DDERR	;already defined -- fatal DD error
	LD	D,'('
	CALL	GTD		;look for (
	JP	C,DEF1		;0-ary fn
	EX	(SP),HL		;save bound var addr, entry length to HL
	LD	A,UFNST
	OR	20H		;set unary bit
	CALL	STPSH		;build symbol table entry
	PUSH	HL
DEF0:	CALL	FDVAR		;look for nonsubscripted variable
	JP	C,SNERR
	CALL	GTCOM		;look for comma
	JP	NC,DEF0		;comma must be followed by another bound var
	CALL	GTREQ		;skip ) =
	POP	HL
	JP	DEF2
DEF1:	CALL	GTEQU		;skip = token
	LD	A,UFNST		;token to A
	EX	(SP),HL		;save addr, get entry length
	CALL	STPSH		;build symbol table entry
DEF2:	POP	DE		;body address to DE
	LD	(HL),E
	INC	HL
	LD	(HL),D		;body address to entry
	JP	GTDEL		;scan function body and return

	IF	STRNG OR FLOAT
;DEFVT sets the default type for variables with given initial letter(s).
;The 26 byte buffer TYBUF contains the default variable types.
;DEFTY returns the type token in B corresponding to keyword token in A.
DEFTY:	LD	B,INTST
	CP	INTT
	RET	Z		;integer type
	IF	FLOAT
	LD	B,SNGST
	CP	SNGT
	RET	Z		;floating type
	ENDIF
	IF	STRNG
	LD	B,STRST
	CP	STRGT
	RET	Z		;string type
	ENDIF
	IF	CAMAC
	LD	B,CAMST
	CP	CAMT
	RET	Z
	ENDIF
	CALL	BAKUP		;else back up TEXTP
	JP	SNERR		;and issue SN error
DEFVT:	CALL	DEFTY		;desired type to B
	CALL	GTALP		;first letter to A
	JP	C,SNERR		;SN error if none
	LD	E,A		;and first saved in E
	LD	D,MINT
	CALL	GTD		;look for -
	LD	A,E		;default last = same as first
	JP	C,DEFV1		;no second letter specified
	CALL	GTALP		;else get second
	JP	C,SNERR
DEFV1:	SUB	E		;second - first
	JP	M,SNERR		;second precedes first
	INC	A		;# of entries to change
	LD	C,A		;count to C
	LD	D,0		;DE now has first letter in ASCII
	LD	HL,TYBUF-'A'
	ADD	HL,DE		;address first entry to change
	ELSE
DEFVT	EQU	SNERR		;issue SN error if integer version
	ENDIF
	IF	STRNG OR FLOAT OR ROM
;FILLM fills (C) bytes of memory starting at (HL) with (B).
FILLM:	LD	(HL),B		;change to desired value
	INC	HL
	DEC	C
	JP	NZ,FILLM	;and fill more
	RET
	ENDIF

;DELAY <expr> [ , <expr> [ , <expr> ]]
	IF	NOT CAMAC	;CAMAC DELAY is in module CAMAC
	IF	REALT		;hardware real time clock delay
;DELAY waits for the real time clock to tick the specified number of times.
;The arguments are assumed to be minutes, seconds and tenths of seconds.
;Typing any character aborts the DELAY.
;The implementation counts clock ticks rather than adding the arg to
;the current time and waiting until the resulting time.  The
;latter blows up if a user interrupt service routine renables
;(so the clock ticks) but lasts until after the specified time.
DELAY:	OR	A		;reset Carry for GTEXP
	CALL	DELA5		;minutes to BC
	PUSH	BC		;and saved
	CALL	DELA4		;seconds to BC
	PUSH	BC		;and saved
	CALL	DELA4		;tenths of seconds to BC
	LD	H,B
	LD	L,C		;tenths to HL
	ADD	HL,HL		;* 2 = 20ths to HL
	POP	DE		;seconds to DE
;at DELA1 minutes count is PUSHed, seconds count in DE, 20ths count in HL.
DELA1:	LD	A,(TIMEX)	;fetch low order clock count
	LD	B,A		;low order clock to B
DELA2:	LD	A,H
	OR	L
	JP	NZ,DELA3	;20ths count is nonzero, enter delay loop
	LD	HL,20		;reset 20ths count
	LD	A,D
	OR	E
	DEC	DE		;decrement seconds count
	JP	NZ,DELA1	;seconds count was nonzero, enter loop
	POP	BC		;minutes count to BC
	LD	A,B
	OR	C
	RET	Z		;minutes also zero, finished
	LD	DE,59		;reset seconds count
	DEC	BC
	PUSH	BC		;save updated minutes count
	JP	DELA1		;and reenter loop
DELA3:	CALL	REDYC		;look for console char
	JP	C,POP1		;char typed, pop minutes and abort delay
	LD	A,(TIMEX)	;fetch current low order clock
	CP	B		;check if clock has ticked
	JP	Z,DELA3		;no, keep waiting
	DEC	HL		;yes, decrement tick count
	JP	DELA1		;and check again
;DELA4 gets [, <expr>] argument to BC, 0 if omitted, OR error if negative.
DELA4:	LD	BC,0
	CALL	GTCND		;look for comma
DELA5:	CALL	NC,GTEXP	;get arg
	LD	A,B
	OR	A
	RET	P		;ok
	JP	FCER0		;negative arg, nonfatal FC error and return 0
	ELSE			;software real time clock delay
DELAY:	LD	HL,(TIMEX)
	CALL	DELA1		;delay minutes
	LD	HL,(TIMEX+2)
	CALL	DELA1		;delay seconds
	CALL	GTEXP		;get hundredths count
	LD	A,B
	OR	C
	RET	Z		;done if hundredths count is zero
	LD	D,B
	LD	E,C		;to DE
DELH1:	LD	HL,-100
	ADD	HL,DE		;carry reset iff hundredths count < 100
	JP	NC,DELH2	;delay hundredths
	EX	DE,HL		;hundredths=hundredths-100 to DE
	LD	HL,(TIMEX+2)	;seconds count to HL
	CALL	TIMER		;delay one second
	JP	DELH1		;and try again
DELH2:	LD	A,(TIMEX+4)	;minutes / 256 to A
	CALL	MULT0		;* hundredths count
	LD	B,H
	LD	C,L
	LD	DE,24
	CALL	DIVD0		;divide by 24 to put hundredth count in HL
	EX	DE,HL
	CALL	CPLD1
	EX	DE,HL		;complement it and fall through to TIMER
;TIMER is the basic timing loop shared by TIME and DELAY.  After a delay of
;15*256 cycles it increments the count in HL, looks for a console char, and
;continues.  Returns Carry set if char typed, reset if HL counts to 0.
TIMER:	CALL	REDYC		;look for char
	RET	C		;return carry set if char typed
	XOR	A
TIME1:	DEC	A
	JP	NZ,TIME1	;wait a while
	INC	HL		;increment the count
	LD	A,H
	OR	L
	JP	NZ,TIMER	;keep counting until count hits zero
	RET			;return carry reset if counted out
;DELA1 is called from DELAY to delay for <expr> minutes or seconds
;by executing TIMER (BC)*(HL) times.
DELA1:	CALL	GTEXP		;get the argument
DELA2:	LD	A,B
	OR	C
	JP	Z,DELA3		;count is zero -- done
	PUSH	HL
	CALL	TIMER
	POP	HL
	DEC	BC		;decrement the count
	JP	DELA2		;and keep waiting
DELA3:	LD	D,','
	CALL	GTD		;look for comma
	RET	NC		;comma -- continue with DELAY
	POP	HL		;else pop the DELA1 return
	RET			;and return from DELAY
	ENDIF			;end of NOT REALT conditional
	ENDIF			;end of NOT CAMAC conditional

;DELETE <line #> [, <line #>]
	IF	EDITC
	IF	COMPL
DELET	EQU	UFERR
	ELSE
DELET:
	IF	ROMSQ
	CALL	ISSRC		;must be addressing working space
	ENDIF
	CALL	GTLNO		;look for <line #>
	JP	C,SNERR		;SN error if none
	CALL	FINDL		;find the line
	PUSH	HL
	PUSH	AF
	CALL	GTCND		;look for comma
	JP	NC,DELE1	;found comma
	POP	AF
	JP	C,USERR		;US error if not found
	POP	HL		;location to HL
	PUSH	HL
	JP	DELE2
DELE1:	POP	AF
	CALL	GTLNO		;look for second <line #>
	JP	C,SNERR		;SN error if none
	CALL	FINDL		;find it
	JP	C,DELE3		;not found, HL points to next
DELE2:	LD	E,(HL)
	LD	D,0		;length to DE
	ADD	HL,DE		;HL points to next
DELE3:	POP	DE		;first line location to DE
	CALL	CMDHU		;compare
	RET	NC		;first loc >= second loc, ignore
	PUSH	HL		;save second loc
	PUSH	DE		;save first loc
	EX	DE,HL		;second loc to DE
	CALL	CPLDE		;complemented
	CALL	IITST		;DELETE illegal indirect
	LD	HL,(EOFAD)	;eof address to HL
	ADD	HL,DE
	INC	HL		;eof - second + 1 = byte count to HL
	EX	(SP),HL		;destination = first loc to HL
	POP	DE		;count to DE
	POP	BC		;source = second loc to BC
	CALL	MOVED		;block move remainder of program
	DEC	HL		;point to new last byte
	JP	NEW1		;reset stacks
	ENDIF
	ELSE
DELET	EQU	EXERR		;EX error in non-EDITC versions
	ENDIF

;DIM <var name> (<expr>[,<expr>]*) [,<var name> (<expr> [,<expr>]*)]*
DIM:	CALL	GTNAM		;look for name
DIM0:	JP	C,SNERR		;SN error if none
	PUSH	AF		;save symbol length
	LD	HL,BUFAD+MAXNL	;saving address to HL
	CALL	CPYS0		;copy var name to save it
	CALL	STLKU		;look it up
	JP	C,DIMS0
DDERR:	ERROR	F, D, D		;fatal DD error if defined already
DIMS0:	LD	D,'('
	CALL	GTDSN		;skip (
	POP	AF
	LD	L,A		;name length to L
	LD	A,(VARTY)
	LD	H,A		;type token to H
	LD	(SAVTP),HL	;and HL saved
	CALL	BYTSD		;bytes per entry to E, # dims so far to D
	PUSH	DE		;and saved
	LD	DE,1		;find # elements in DE
INONE	EQU	$-2		;address of integer 1 for FOR step default
	PUSH	DE
;DIMS1 is repeated for each dimension of an array.  Each dimension bound
;is PUSHed, as well as bytes per entry/#dims and #elements thus far.
DIMS1:	POP	DE		;# elements to DE
	POP	HL		;#dims to H, bytes per entry to L
	INC	H		;increment # dims count
	CALL	GTEXP		;get dim
	LD	A,B
	OR	A
	JP	M,FCERF		;fatal FC error if negative
	PUSH	BC		;and save it
	PUSH	HL		;save count
	INC	BC		;dim + 1 (to allow subscript 0)
	CALL	MULBD		;new # elements = BC * DE to HL
	JP	C,OMERR		;too many
	PUSH	HL		;save # elements
	LD	D,','
	CALL	GTD		;look for ,
	JP	NC,DIMS1	;get more dimensions
	LD	D,')'
	CALL	GTDSN		;skip )
	LD	DE,BUFAD+MAXNL
	LD	HL,BUFAD
	CALL	CPYST		;restore symbol name to BUFAD
;Now the new symbol table entry for the array is built, containing length
;byte, type byte, name, #dims, bounds (2 bytes * #dims) and elements.
	POP	DE		;restore # elements to DE
	POP	BC		;bytes per entry to C, # dims to B
	IF	CAMAC
	LD	HL,(SAVTP)
	LD	A,H		;fetch type token in case camvar
	CP	CAMST
	JP	NZ,DIM1A	;not a camvar
	LD	A,B
	CP	1		;make sure camvar is 1-d
	JP	NZ,SNERR	;SN error if not
	ENDIF
DIM1A:	LD	L,B
	LD	H,0		;now find entry length to build entry
	ADD	HL,HL		;# dims * 2 bytes per dim
	INC	HL		;+ length byte
	INC	HL		;+ type byte
	INC	HL		;+ #dims byte
	LD	A,C		;bytes per entry to A
DIMS2:	ADD	HL,DE
	JP	C,OMERR		;too big
	DEC	A
	JP	NZ,DIMS2	;# elements * bytes per entry
	EX	DE,HL		;length so far to DE
	LD	HL,(SAVTP)
	LD	A,H		;symbol type token to A
	LD	H,0		;HL now has name length
	ADD	HL,DE		;entry length in HL
	JP	C,OMERR
	CALL	STPSH		;build table entry
	LD	(HL),B		;# dims to table
	LD	C,B
	LD	B,0		;BC now has # dims
	ADD	HL,BC
	ADD	HL,BC
	INC	HL		;HL points past last dim
	IF	CAMAC
	CP	CAMST		;check if camvar
	JP	NZ,DIMS3	;no
	EX	(SP),HL		;component count to HL
	INC	HL		;actual count = dimension + 1
	LD	(CVCNT),HL	;and saved, in case DECLARE with values
	DEC	HL
	EX	(SP),HL		;restore count, recover location
	LD	(CVLOC),HL	;and save location
	ENDIF
DIMS3:	POP	DE		;dim to DE
	CALL	MVMDE		;and then to table
	DEC	C		;count down dims
	JP	NZ,DIMS3
	CALL	GTCND		;look for comma
	JP	NC,DIM		;dimension another
	RET

;DISABLE [<line #>]
	IF	NOT WILD
DSABL:	CALL	GTLNO		;line # to DE, carry set if none
	LD	HL,INTAD
	LD	A,(INTTC)
	JP	NC,DSAB2	;line # present
	LD	(TEMP),A	;save old # entries
	XOR	A
	LD	(INTTC),A	;set entry count to 0
	LD	(HL),A		;store table eof
DSAB1:	LD	A,(TEMP)
	OR	A		;check if any disabled
	RET	NZ
ENERR:	ERROR	F, E, N		;fatal EN error
DSAB2:	XOR	A
	LD	(TEMP),A	;set flag to tell if any disabled
DSAB3:	LD	A,(HL)
	OR	A		;check current entry type byte
	JP	Z,DSAB1		;eof
	PUSH	HL		;save current addr
	LD	BC,8
	ADD	HL,BC
	PUSH	HL		;save next addr
	DEC	HL
	LD	B,(HL)
	DEC	HL
	LD	C,(HL)		;ENABLE line # to BC
	CALL	CMBDU		;compare to desire line #
	JP	Z,DSAB4		;match -- purge it
	POP	HL
	POP	BC
	JP	DSAB3		;no match -- try next
DSAB4:	POP	BC		;next to BC -- source
	POP	HL		;current to HL -- destination
	PUSH	BC		;save next
	PUSH	DE		;save line #
	LD	D,B
	LD	E,C		;current to DE
	PUSH	HL		;save destination
	LD	HL,INTAD+INTTL	;last location + 1 to HL
	CALL	CPLDE		;- current to DE
	ADD	HL,DE		;count to HL
	EX	DE,HL		;then to DE
	POP	HL		;restore destination
	CALL	MOVED		;move remainder of table
	LD	HL,INTTC	;address table count
	LD	A,(HL)		;fetch count
	LD	(TEMP),A	;set flag to true (nonzero)
	DEC	(HL)		;update count
	POP	DE		;restore line #
	POP	HL		;next to HL
	JP	DSAB3		;keep trying
	ENDIF			;end of NOT WILD conditional

;EDIT [<line #>]
	IF	EDITC
	IF	COMPL
EDIT	EQU	UFERR
	ELSE
EDIT:
	IF	ROMSQ
	CALL	ISSRC		;must be addressing working space
	ENDIF
	CALL	GTLNO		;look for <line #>
	JP	NC,EDIT0
	LD	HL,(ERRLN)	;edit most recent error line if none
	EX	DE,HL		;to DE
EDIT0:	CALL	IITST		;EDIT illegal indirect
	CALL	FDLNO		;find the line
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;line number to BC
	INC	HL
	INC	HL
	PUSH	HL		;save pointer to first byte of line
	XOR	A
	CALL	CVTIS		;convert line number to string
	PUSH	AF		;save length
	CALL	BCDE		;string loc to BC, length to E
	LD	HL,NLNAD	;destination to HL
	CALL	MOVD0		;copy line number string to input buffer
	EX	DE,HL		;next input buffer location to DE
	POP	AF
	CPL			;-length-1
	ADD	A,NLMAX+4	;max # chars + 3 - length
	LD	C,A		;to C to avoid line overflow
	LD	A,' '
	POP	HL		;first char address to HL
	PUSH	HL
	CP	(HL)		;check if first char of line is <space>
	CALL	NZ,EDIT4	;add a space if not
EDIT2:	POP	HL		;line pointer to HL
	LD	A,(HL)		;fetch next char or token in line
	INC	HL
	PUSH	HL		;and save pointer to next
	CALL	FNDTK		;check if char or token
	JP	C,EDIT3		;token
	CALL	EDIT4		;store the char
	CP	CR		;check if cr
	JP	NZ,EDIT2	;no, continue
	LD	SP,STACK	;reset SP in case direct line results
	CALL	LEDIT		;edit the line
	CALL	TKIZE		;tokenize the line
	JP	C,XSTA1		;execute if no line number
	CALL	NZ,ADDLN	;add line to current source
	JP	DMOD2		;and return to OK prompt
EDIT3:	LD	A,(HL)		;fetch char of token
	AND	7FH		;mask off possible high bit
	CALL	EDIT4		;store the char
	LD	A,(HL)		;refetch
	INC	HL
	OR	A
	JP	P,EDIT3		;not end of token, get next char
	JP	EDIT2		;end of token, get next char of line
EDIT4:	LD	(DE),A		;store the char
	INC	DE		;point to next location
	DEC	C		;decrement remaining char count
	RET	NZ		;return if enough room
	LD	A,CR		;too little room in buffer, EX error
	LD	(NLNAD),A	;cr to input buffer
	JP	EXERR		;and issue EX error
	ENDIF
	ELSE
EDIT	EQU	EXERR		;EX error in non-EDITC versions
	ENDIF

;ENABLE <line #> , <byte expr> , <byte expr> [, <byte expr>] [,$]
	IF	NOT WILD
ENABL:	CALL	IDTST		;ENABLE illegal direct
	PUSH	BC		;save current line #
	CALL	GTLNO
	PUSH	DE		;save subroutine line #
	LD	D,','
	CALL	GTDSN		;skip comma
	CALL	IINFO		;get interrupt info
	PUSH	DE
	PUSH	BC		;and save it
	LD	HL,INTTC
	LD	A,(HL)		;# entries to A
	CP	INTTN		;compared to max
	JP	NC,ENERR	;too many -- EN error
	INC	(HL)		;store new # entries
	OR	A
	RLA
	RLA
	RLA			;*8 bytes per entry
	LD	HL,INTAD-1
	CALL	ADAHL		;+ address - 1 = address of new entry - 1
	LD	A,4
ENAB1:	POP	DE
	CALL	MOMDE		;two bytes to entry
	DEC	A		;four times
	JP	NZ,ENAB1
	INC	HL
	LD	(HL),0		;and new eof
	RET
	ENDIF			;end of NOT WILD conditional

;END
ENDCM:
	IF	SDISK AND (NOT RTPAK)
	CALL	CLOSN		;close any OPEN files
	ENDIF
	IF	CAMAC AND FALSE	;Northstar version
	CALL	CLOSE		;close any OPEN files
	ENDIF
ENDC1:
	IF	COMPL		;ERROR entry point
	JP	BOOT		;boot in COMPL version
	ELSE
	LD	A,CSBRK		;break token to A
	JP	STOP2		;save break info and return to dmode
	ENDIF

;EXEC [<expr> [,G] ]
	IF	ROMSQ
	IF	COMPL
EXEC	EQU	UFERR
	ELSE
EXEC:	CALL	IEVAL		;look for location
	LD	HL,SRCAD
	JP	C,EXEC1		;no loc, restore SOURC to SRCAD
	ENDIF			;end of NOT COMPL conditional
	IF	WILD
EXECW:	DEC	BC		;arg-1 should be 0-8 -- initial entry point
	LD	DE,9
	CALL	CMBDU
	JP	NC,ROERR	;RO error if arg was not 1-9
	LD	HL,WEXEC	;address base of EXEC buffer
	ADD	HL,BC
	ADD	HL,BC		;address selected EXEC buffer pointer
	LD	A,(HL)		;fetch low order address
	INC	HL
	LD	H,(HL)		;high order address to H
	LD	L,A		;and low order to L
	OR	H
	JP	Z,ROERR		;RO error if buffer entry is 0
	ENDIF			;end of WILD conditional
	IF	WILD OR NOT COMPL
	IF	NOT WILD
	LD	H,B
	LD	L,C		;location to HL
	ENDIF			;end of NOT WILD conditional
EXEC0:	LD	A,(HL)		;fetch first char of prog
	CP	CR
	JP	NZ,ROERR	;not a program, fatal RO error
	INC	HL		;else point to first length byte
EXEC1:	LD	(SOURC),HL	;reset SOURC
	IF	NOT COMPL
	CALL	GTCOM		;look for comma
	LD	HL,(EOFAD)	;EOF address to HL
	JP	C,DMODX		;no comma, reset stacks and return to DMODE
	CALL	NEW1		;reset control stack
	LD	D,'G'
	CALL	GTDSN		;skip G after comma
	LD	HL,(SOURC)	;new program address to HL
	ENDIF
	JP	BAKUP		;reset TEXTP and continue execution at new prog
	ENDIF			;end of NOT COMPL conditional
	ELSE
EXEC	EQU	EXERR		;EX error in non-ROMSQ versions
	ENDIF			;end of ROMSQ conditional


;end of STATES1
	PAGE
;STATES2 05/21/81
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
;statement routines for statements FOR through NULL


;FOR <var name> = <expr> TO <expr> [STEP <expr>]
FOR:	CALL	GTLHS		;get destination for ASIGN
	IF	STRNG
	CP	STRST
	JP	Z,SNERR		;SN error if FOR <string var>
	ENDIF
	LD	HL,INONE	;integer 1 addr to HL
	IF	FLOAT
	CP	SNGST
	JP	NZ,FOR1		;integer FOR
	LD	HL,FPONE	;floating 1. addr to HL
	ENDIF
;At FOR1 the FOR var addr is in LHSAD, the default incr pointer in HL.
;The CSTACK is examined for a previous FOR entry with the same variable,
;and the entry is flushed if found.
FOR1:	PUSH	HL		;save default incr pointer
	LD	BC,(CSFOR SHL 8) OR CSFOR
	LD	HL,(CSTKP)	;set BC, HL for CSDIG
FOR1A:	CALL	CSDI1		;look for old FOR entry
	JP	C,FOR2		;not found
	PUSH	HL		;save current entry addr
	LD	A,(HL)
	AND	1FH
	CALL	SBAHL		;address next CSTACK entry
	EX	(SP),HL		;save next addr, current addr to HL
	LD	DE,-5
	ADD	HL,DE		;address var addr bytes
	CALL	MVDEM		;fetch FOR entry var addr to DE
	LD	HL,(LHSAD)	;FOR var addr to HL
	CALL	CMDHU		;check if same variable
	POP	HL		;next entry addr to HL
	JP	NZ,FOR1A	;no match, try next
	LD	A,B		;match, entry type to A
	CALL	CSRST		;and purge the entry
;FOR2 builds a new CSTACK FOR entry.  The entry consists of a type/length byte
;(1 byte), line # address, return textp and variable address (2 bytes each),
;and bound and increment values (2 or 4 bytes each).  After CPUSH allocates
;space for the entry, the CSTACK pointer is reset to ignore the protoentry
;in case FOR aborts, e.g. with a SN error.  Another CPUSH completes the entry.
FOR2:	LD	A,B
	CALL	CPUSH		;allocate new CSTACK FOR entry
	EX	DE,HL
	IF	NOT COMPL
	CALL	LINBC
	CALL	Z,DCSTD		;unincrement CSTACK direct count if direct
	ENDIF
	LD	HL,(LHSAD)
	EX	DE,HL
	CALL	MVMDE		;variable addr to entry
	LD	A,2*FBYTS+1	;skip two values
	CALL	SBAHL		;address next CSTACK entry
	LD	(CSTKP),HL	;reset CSTACK in case SN error in FOR
	INC	HL		;address bottom of new FOR entry
	PUSH	HL		;and save pointer for bound/incr insertion
	CALL	LET1		;get initial value and assign to var
	LD	D,TOT
	CALL	GTDSN		;skip TO token
	CALL	EVALT		;get bound of desired type
	INC	HL		;point to bound value
	EX	(SP),HL		;FOR entry pointer to HL
	POP	BC		;bound pointer to BC
	CALL	MOVEB		;copy bound to entry
	EX	(SP),HL		;save entry addr for increment
	PUSH	HL		;and default incr
	LD	D,STEPT
	CALL	GTD		;look for STEP
	POP	HL		;default increment pointer to HL
	JP	C,FOR2A		;no STEP, take default value
	CALL	EVALT		;get increment value
	INC	HL		;and point to value
FOR2A:	EX	(SP),HL		;entry pointer to HL
	POP	BC		;incr pointer to BC
	IF	FOR0
	PUSH	HL		;save pointer to incr for FOR0 test
	ENDIF
	CALL	MOVEB		;copy increment to entry and return
	LD	A,CSFOR
	IF	NOT FOR0
	JP	CPUSH		;build the new CSTACK entry
	ELSE
	CALL	CPUSH
;must now check for vacuous condition (e.g. FOR I=1 TO 0) in FOR0 version
	LD	HL,(LHSAD)
	IF	FLOAT
	LD	A,(LHSTY)
	CP	SNGST
	IF	F9511
	CALL	Z,LOD95		;load floating value to 9511 stack
	ELSE
	CALL	Z,FLOAD		;load floating value to FACC
	ENDIF
	ENDIF
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;fetch integer value to BC
	POP	DE		;incr pointer to DE
	LD	HL,-FBYTS
	ADD	HL,DE		;bound pointer to HL
	CALL	BDTST		;test FOR condition
	RET	NC		;ok, just return
	LD	HL,(CSTKP)
	CALL	NEXT6		;purge the CSTACK entry just built
	CALL	EOS
	LD	B,NEXTT
	CALL	FNDST		;find matching NEXT
	JP	NC,NEXT7	;look for following comma, return or do another
	ERROR	F, F, R		;not found, fatal FR error
	ENDIF

;GOSUB <line #>
GOSUB:	CALL	GOTO		;find new textp and lnnum
GOSU1:	LD	A,CSGOS		;ON entry point
	PUSH	BC		;save return text pointer
	JP	CPSH1		;build control stack entry and return

;GOTO <line #>
;GOTO is called by GOSUB to read a line #, look for it and
;check for end of statement garbage.  Branches to US error if illegal
;or no such line #, otherwise:
;Retn:	A	clobbered
;	BC	return text pointer, i.e. delimiter address
;	DE	line #
;	HL	address of <cr> preceding desired line in text
;	(textp)	same as HL
GOTO:	CALL	GTLNO		;line # to DE
	JP	C,SNERR		;no line #
GOTO1:	CALL	EOS		;end of statement test -- IF entry point
GOTO2:	CALL	FDLNO		;find line # -- interrupt, ON entry point
	JP	BAKUP		;back up textp and return

;IF <expr> THEN {<line #> | <statement>}
IFCOM:	CALL	GTEXP		;evaluate the IF expression
	LD	D,THENT
	CALL	GTDSN		;skip THEN token
	LD	A,B
	OR	C
	JP	Z,REM		;false -- scan to cr and return
	CALL	GTLNO		;look for line #
	JP	C,XSTA2		;none -- execute <statement> THENpart
	JP	GOTO1		;GOTO line # and return

;INPUT [<quoted string>] [;] <var list>
;INPUT @<expr>, <var list>	[in SDISK versions]
;INPUT @ <var list>		[in PACKI versions]
;INPUT must scan two lines, the command line INPUT <varlist> and the line
;of data typed by the user.  The two text pointers are kept in TEXTP
;and TXTP2, and exchanged by FLIP.  The original <varlist> TEXTP
;is also PUSHed, to be available when REDOing.  If the data is of
;incorrect type or there are fewer data than variables, REDO.  If there are
;fewer variables than data, EXCESS IGNORED.
;DINP0 is in module SDISK.
;PAINP is in module PACKARD.
INPUT:	CALL	IDTST		;INPUT illegal direct mode
	IF	SDISK
	CALL	GTSFN		;look for disk file specification
	JP	NC,DINP0	;disk INPUT
	ENDIF			;end of SDISK conditional
	IF	PACKI
	LD	D,'@'
	CALL	GTD		;look for @
	JP	NC,PAINP	;found @, must be Packard INPUT @
	ENDIF
	XOR	A
	LD	(OMODE),A	;turn on output mode
	LD	D,'"'
	CALL	GTD		;look for quoted string
	CALL	NC,PRQUO	;print it if present
	LD	D,SEMIC
	CALL	GTD		;look for ; and ignore if present
;INPU1 sets up pointers, and is entry point for retries after REDO message.
INPU1:	PUSH	HL		;save textp to redo
	LD	(TXTP2),HL	;save textp to scan varlist
	LD	A,'?'
	CALL	WRITC		;write a ?
	CALL	WRTSP		;and a space
	LD	HL,(SAVTP)
	LD	(TEXTP),HL	;reset text pointer in case ^C typed
	CALL	GTLIN		;get input line
	CALL	FLIP		;to scan varlist
;INPU2 gets the next variable and checks its type (string or nonstring).
INPU2:	CALL	GTLHS		;get destination
	CALL	FLIP		;to scan data
	IF	STRNG
	CP	STRST
	JP	NZ,INPU3	;nonstring variable
	CALL	EVUNQ		;get string value, perhaps unquoted
	JP	C,INPU7		;no string, REDO
	JP	INPU4		;assign string value to destination
	ENDIF
;INPU3 gets a nonstring value.
INPU3:	CALL	GTLIT		;get value
	JP	C,INPU7		;REDO if none
	IF	STRNG
	CP	STRST		;check if string value
	JP	Z,INPU7		;REDO if so
	ENDIF
;INPU4 assigns a value to the destination variable.
INPU4:	CALL	ASIGV		;assign value to destination
	CALL	GTCND		;look for comma not followed by delimiter
	JP	C,INPU6		;no more data or bad item
	CALL	FLIP		;to scan varlist
	CALL	GTCOM		;look for comma
	JP	NC,INPU2	;continue with next var in varlist
	CALL	PRNTM		;else print EXCESS IGNORED
	DEFB	'EXCESS IGNORED', CR, LF OR 80H
;INPU5 is the exit from a successful INPUT.
INPU5:	POP	HL		;pop REDO pointer
	RET			;and done
INPU6:	CALL	DTST0		;check if delimiter
	JP	C,INPU7		;no, REDO
	CALL	FLIP		;else scan varlist
	CALL	GTCOM		;see if more vars
	JP	C,INPU5		;no, done
;INPU7 prints REDO message and retries after bad data.
INPU7:	CALL	PRNTM		;more vars than data, print REDO message
	DEFB	'RED', 'O' OR 80H
	POP	HL
	JP	INPU1		;reset varlist pointer and try again

;[LET] <var ref> = <expr>
LET0:	CALL	BAKUP		;back up textp to get current char again
	CALL	DTEST		;test if delimiter
	RET	NC		;null statement
LET:
	IF	CAMAC
	CALL	GTCAM		;look for camac variable
	JP	NC,LETCV	;perform camac LET
	ENDIF
	IF	WILD
	LD	D,WBUFT
	CALL	GTD
	JP	NC,WLETB	;BUFFER legal lhs in WILD version
	ENDIF
	CALL	GTLHS		;get destination for ASSGN
LET1:	CALL	GTEQU		;skip = token -- FOR entry point
	CALL	EVALS		;evaluate the rhs
	JP	ASIGN		;and assign rhs to lhs
;letcv is in module CAMAC

;LIST [<line #>] [, <line #>]
	IF	COMPL
LISTM	EQU	UFERR		;UF error in COMPL version
	ELSE
LISTM:	CALL	GTLNO		;min line # to DE, 0 if none
	CALL	FINDL		;look for it
	PUSH	HL		;save min line length byte address
	CALL	GTCOM		;skip the comma, if any
	CALL	GTLNO		;max line # to DE, 0 if none
	CALL	C,CPLD1		;complement to give default max = 0FFFFH
	CALL	EOS		;check for garbage
	LD	B,D
	LD	C,E		;max to BC
	POP	HL		;min length byte address to HL
LIST1:	LD	A,(HL)		;fetch length byte
	OR	A
	RET	Z		;eof -- done
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;line # of current line to DE
	CALL	CMBDU		;compare unsigned to max
	RET	C		;max < (DE) -- return
	DEC	HL		;point to line #
	CALL	CTEST		;look for break char
	CALL	PRNTL		;print the line
	CALL	WCRLF		;and crlf
	JP	LIST1		;and try next
	ENDIF			;end of NOT COMPL conditional

;LOAD is in section STATES4.

;MOVE {TO | FROM} <expr>
;MOVE performs a block move of a ROMSQ version user program TO or FROM RAM.
;The specified location must not overlap either BASIC or user RAM.
	IF	ROMSQ AND (NOT WILD)
	IF	COMPL
MOVE	EQU	UFERR
	ELSE
MOVE:	CALL	GTCHA
	PUSH	AF		;save TO | FROM token
	CALL	GTEXP		;get location
	IF	CAMAC		;RAM test only in segmented CAMAC versions
	LD	DE,RAMORG
	ELSE
	LD	DE,ROMORG	;base of BASIC to DE
	IF	ROM		;check if within BASIC in ROM versions
	LD	HL,EORAM+1	;top of BASIC + 1 to HL
	CALL	MVTST		;check if loc within BASIC
	LD	DE,RAMORG	;base of user RAM to DE
	ENDIF			;end of ROM conditional
	ENDIF			;end of NOT CAMAC conditional
	IF	CPM AND SDISK
	LD	HL,(FILET)	;top of RAM is (FILET) in CP/M SDISK versions
	ELSE
	IF	STRNG
	LD	HL,(STRT)	;top of RAM is (STRT) in STRNG versions
	ELSE
	LD	HL,(MEMT)	;top of RAM is (MEMT) otherwise
	ENDIF
	ENDIF
	INC	HL		;top of user RAM + 1 to HL
	LD	A,H
	OR	L
	CALL	NZ,MVTST	;check for loc within user RAM
	POP	AF		;restore token
	CP	TOT
	JP	NZ,MOVEF	;must be FROM
	PUSH	BC		;save destination
	LD	DE,SRCAD-2
	CALL	CPLDE		;2-SRCAD to DE
	LD	HL,(EOFAD)
	ADD	HL,DE		;last - first + 1 = length
	EX	DE,HL		;to DE
	POP	HL		;destination to HL
	PUSH	HL
	PUSH	DE		;save dest, length
MOVE1:	CALL	RTEST		;check if RAM
	JP	NZ,ROERR	;ROM, RO error
	INC	HL
	DEC	DE
	LD	A,D
	OR	E
	JP	NZ,MOVE1	;check next
	LD	BC,SRCAD-1	;source to BC
	POP	DE		;length to DE
	POP	HL		;destination to HL
	JP	MOVED		;block move and return
MOVEF:	CP	FROMT
	JP	NZ,SNERR	;neither TO nor FROM, SN error
	LD	A,(BC)		;fetch first prog char
	CP	CR
	JP	NZ,ROERR	;not a prog, RO error
	PUSH	BC
	PUSH	BC
	PUSH	BC
	LD	HL,(SOURC)
	EX	(SP),HL		;save SOURC value
	INC	HL		;point to first length byte
	LD	(SOURC),HL
	CALL	LAST		;last loc to BC
	POP	HL
	LD	(SOURC),HL	;restore SOURC
	POP	DE
	CALL	CPLDE		;-first to DE
	LD	HL,(SYMTA)
	EX	DE,HL		;-first to HL, SYMTA to DE
	ADD	HL,BC		;last-first=length-1 to HL
	PUSH	HL		;save length for block move
	LD	BC,SRCAD
	PUSH	BC		;save destination for block move
	ADD	HL,BC		;last needed + 1 to HL
	CALL	CMDHU
	JP	C,OMERR		;too big, OM error
	POP	HL		;destination
	POP	DE		;length
	POP	BC
	INC	BC		;source
	CALL	MOVED		;block move into working space
	DEC	HL		;point to new eof
	JP	NEW1		;reset stacks and EOFAD
;MVTST is called from MOVE to assure location specified does not overlap
;with XYBASIC or with user RAM.  Issues fatal RO error if min <= loc <= max.
;Call:	BC	specified location
;	DE	min
;	HL	max+1
MVTST:	CALL	CMBDU
	RET	C		;loc < min
	EX	DE,HL		;max+1 to DE
	CALL	CMBDU
	RET	NC		;loc >= max+1
	JP	ROERR		;else fatal RO error

	ENDIF			;end of NOT COMPL conditional
	ELSE
MOVE	EQU	EXERR		;EX error in non-ROMSQ versions
	ENDIF			;end of ROMSQ conditional

;NEW
	IF	COMPL
NEWCM	EQU	UFERR		;UF error in COMPL version
	ELSE
NEWCM:
	IF	ROMSQ
	CALL	ISSRC		;check if addressing working space
	ENDIF
	CALL	IITST		;NEW is illegal indirect
	IF	SDISK
	CALL	CLOSN		;close any OPEN files
	ENDIF
NEW:	CALL	CLEA1		;clear symbol table -- LOAD, init entry point
	XOR	A
	LD	(TRACE),A	;traceoff
	LD	(TRAP),A	;trapon
	LD	HL,SRCAD
	LD	(HL),A		;source text empty
NEW1:	PUSH	HL		;ADDLN, DMODX, MOVE FROM entry point
	CALL	STZAP		;reset BREAK and FN symbol table entries
	CALL	RSTOR		;restore the READ pointer
	IF	NOT WILD
	CALL	DISAB		;disable interrupts
	ENDIF
	POP	HL
	LD	(EOFAD),HL	;set eof address -- LOAD entry point
	ENDIF			;end of NOT COMPL conditional
CSPST:	LD	(CSTKP),HL	;clear control stack -- call to reset it
	LD	(ESTKP),HL	;reset expr stack pointer
	RET

;NEXT [<var name> [, <var name>]* ]
;First the most recent CSTACK FOR entry is found.
NEXT:	LD	BC,(CSFOR SHL 8) OR CSFOR
	CALL	CSDIG		;look for CSTACK FOR entry
	JP	C,NFERR		;not found -- fatal NF error
	PUSH	HL		;save FOR entry address
	LD	DE,-5
	ADD	HL,DE		;point to var address bytes
	LD	B,(HL)
	DEC	HL
	LD	C,(HL)		;fetch var addr to BC
	PUSH	HL		;and save var addr pointer
	LD	HL,(TEXTP)
	LD	(SAVTP),HL	;save TEXTP in case retry necessary
	PUSH	BC
	CALL	FDVAR		;look for var name after NEXT
	INC	HL
	POP	BC
	JP	C,NEXT1		;no name
;NEXT <var name> specified, so the FOR <var name> is compared to it.
	EX	DE,HL		;NEXT var addr DE, type addr HL
	CALL	CMBDU		;compare FOR and NEXT <var name>s
	JP	Z,NEXT3		;FOR and NEXT <var name>s match
;<var name>s do not match, so CSTACK FOR entry is poped.
	LD	HL,(SAVTP)
	LD	(TEXTP),HL	;restore textp to get var name again
	POP	HL
	POP	HL		;FOR entry address to HL
	LD	A,(HL)		;type/length byte to  A
	LD	B,A		;saved in B
	AND	1FH		;mask to length
	CALL	SBAHL		;address next entry
	LD	A,B		;type/length restored
	CALL	CSRST		;purge the FOR entry from CSTACK
	JP	NEXT		;and try again
;When no <var name> is specified after NEXT, the last CSTACK FOR entry
;<var name> is assumed.  The type byte must be found for correct tracing.
NEXT1:	LD	HL,(SYMTA)
NEXT2:	CALL	STNXT		;address next symbol table entry
	EX	DE,HL
	CALL	CMBDU		;compare to desired value addr
	EX	DE,HL
	JP	NC,NEXT2	;var addr >= next entry, try another
	EX	DE,HL		;type byte addr to HL
;At NEXT3 the desired <var name> is known.  The stack contains the FOR entry
;addr and the FOR entry var addr, BC contains the var addr, and HL
;contains the type byte pointer for the specified <var name>.
;The trace info [<line #>]<var name> is printed if desired.
NEXT3:
	IF	FLOAT
	LD	A,(HL)
	AND	1FH		;mask to type
	LD	(LHSTY),A	;save destination type
	ENDIF
	IF	NOT COMPL
	LD	A,(TRACE)
	OR	(HL)		;sign set iff tracing
	LD	(VTRAC),A	;set VTRAC for ASSGN
	INC	HL		;point to name
	JP	P,NEXT4		;no tracing desired
	CALL	BPRNT		;print trace line #
	CALL	PRTST		;print var name
	ENDIF
;At NEXT4 the bound & incr pointers are found in preparation for incrementing,
;and the old value is replace by value+increment.
NEXT4:	POP	HL		;FOR entry var addr pointer to HL
	LD	DE,-FBYTS
	ADD	HL,DE
	PUSH	HL		;save incr pointer
	PUSH	HL
	ADD	HL,DE
	EX	(SP),HL		;save bound pointer, incr pointer to HL
	PUSH	BC		;and save var addr
	IF	FLOAT
	LD	A,(LHSTY)
	CP	INTST
	JP	Z,NXT4I		;integer FOR
;Now floating value is replaced by old value plus increment.
	PUSH	BC
	IF	F9511
	CALL	LOD95		;incr to 9511 stack
	POP	HL
	CALL	LOD95		;var value to 9511 stack
	CALL	FADD		;add increment to var value
	LD	A,PTO95
	CALL	O9511		;copy stacktop
	CALL	FET95		;fetch result from 9511 stack
	ELSE
	EX	(SP),HL		;save incr address, var address to HL
	CALL	FLOAD
	POP	HL		;incr address to HL
	IF	FPBCD
	CALL	FADD		;add var value to increment
	ELSE
	CALL	FINCR		;instead of CALL FADD
	CALL	ETEST		;perform significance test
	ENDIF
	ENDIF
	POP	HL		;restore var addr
	IF	COMPL
	IF	F9511
	CALL	STO95		;result to var addr
	ELSE
	CALL	FSTOR		;result to var addr
	ENDIF
	ELSE			;NOT COMPL
	PUSH	HL
	IF	F9511
	CALL	STO95		;result to var addr
	ELSE
	CALL	FSTOR		;result to var addr
	ENDIF
	POP	HL		;restore var addr for tracing
	LD	B,SNGST		;type to B
	CALL	TRVAL		;print trace info if desired
	ENDIF
	JP	NEXT5
	ENDIF
;Integer value is replaced by old value plus increment.
NXT4I:	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;incr to BC
	POP	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;value to DE
	PUSH	HL
	CALL	IADD		;integer add incr+value
	CALL	C,IOVER		;overflow, nonfatal OV error
	POP	HL
	CALL	ASIGI		;assign and print trace info if desired
;At NEXT5 the bound is compared to the value to test for loop termination.
NEXT5:	POP	HL		;bound pointer to HL
	POP	DE		;incr pointer to DE
	CALL	BDTST		;test for completion condition
	POP	HL		;FOR entry addr to HL
	JP	NC,CSPOP	;don't exit loop -- get new text addr & return
NEXT6:
	IF	COMPL
	LD	DE,-(2*FBYTS+7)	;- entry length to DE
	ELSE
;Before purging the FOR-entry the CSTACK direct count must be updated.
	DEC	HL
	LD	A,(HL)
	DEC	HL
	OR	(HL)		;check line # of FOR
	CALL	Z,DCSTD		;decrement CSTKD if direct
	LD	DE,-(2*FBYTS+5)
	ENDIF
	ADD	HL,DE		;point to next entry
	LD	A,CSFOR
	CALL	CSRST		;reset stack pointer
NEXT7:	CALL	GTCND		;look for comma
	JP	NC,NEXT		;do another NEXT if comma
	RET
NFERR:	ERROR	F, N, F		;fatal NF error

;NULL <expr>
	IF	NOT WILD
NULL:	CALL	GTBEX		;get byte-value expr
	LD	A,C
	LD	(NULLS),A	;value to NULLS
	RET
	ENDIF			;end of NOT WILD conditional

;end of STATES2
	PAGE
;STATES3 12/05/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;statement routines for statements ON through WAIT


;ON <expr> {GOTO | GOSUB} <line #> [, <line #>]*
ON:	CALL	GTEXP		;value to BC
	CALL	GTCHA
	CP	GOTOT
	JP	Z,ONGOT
	CP	GSUBT
	JP	NZ,SNERR	;SN error if not GOTO or GOSUB
	SCF
ONGOT:	PUSH	AF		;carry set for GOSUB, reset for GOTO
	DEC	BC		;value - 1 to BC
	LD	A,B
	OR	A
	INC	BC
	CALL	NZ,ON3		;count negative or big
ON1:	CALL	GTLNO		;line # to DE
	DEC	C		;decrement count
	JP	Z,ON2		;do current line #
	CALL	GTCOM		;look for comma
	JP	NC,ON1		;keep going
	CALL	ONERR		;nonfatal ON error if line # list exhausted
ON2:	CALL	GTDEL		;scan to end of statement
	CALL	GOTO2		;set TEXTP and LNNUM
	POP	AF
	RET	NC		;done if GOTO
	JP	GOSU1		;else build GOSUB control stack entry
ON3:	LD	C,1
	JP	M,ONERR		;replace negative values by 1
	LD	C,255		;and positive by 255
ONERR:	ERROR	N, O, N		;nonfatal ON error
	RET			;and return

;OUT <expr>, <expr>
	IF	NOT WILD
PUT:	CALL	GTBEX		;get byte expression
	LD	A,C
	LD	(WPORT + 1),A	;set port #
	CALL	GTCBE		;get comma, byte expr
	LD	A,C
	JP	WPORT		;OUT it and return
	ENDIF			;end of NOT WILD conditional

	IF	EPSTN
;PLOT <expr> [, <expr>]*
PLOT:	LD	A,(COLUM)	;find current column
	PUSH	AF		;and save
PLOT1:	XOR	A
	LD	(COLUM),A	;clear column count
	CALL	GTBEX		;get byte valued expr
	LD	A,C
	CALL	WRITC		;write the char
	CALL	GTCOM		;look for comma
	JP	NC,PLOT1	;more
	POP	AF
	LD	(COLUM),A	;restore column count
	RET
	ENDIF

;POKE <expr>, <expr>
	IF	NOT WILD
POKE:	CALL	GTEXP
	PUSH	BC		;save location
	CALL	GTCBE		;get comma, byte expr
	LD	A,C
	POP	BC
	LD	(BC),A		;store data in location
	RET
	ENDIF			;end of NOT WILD conditional

;{PRINT | ?} [@<expr>] [[<print item>] {, | ;}]* [<print item>]
;<print item> ::= [UNS | TAB | SPC] <expr> | <string> | <camvar name>
;PRINT first PUSHes a return to itself, so the print routines may be CALLed
;and simply RETurn.  The routines for comma and semicolon check for following
;delimiter, so a delimiter found after any other item produces a crlf.
;DPRIN is in module SDISK.
;WILD PRINT is in module WILD, and calls PRIN0.
	IF	NOT WILD
PRINT:
	IF	SDISK
	CALL	GTSFN		;look for file number
	JP	NC,DPRIN	;PRINT to file
	ENDIF
	ENDIF
PRIN0:	LD	BC,PRIN0
	PUSH	BC		;push common return to print more
	CALL	GTCHO		;look at next char
	CP	'"'		;look for quoted string first to avoid eval
	JP	Z,PRQU0		;quoted string
	IF	CAMAC
	CP	DRIVT
	JP	Z,PRDRI		;print DRIVER
	CALL	GTCAM		;look for camvar name
	JP	NC,PRCAM	;print the camvar value
	ENDIF
	CALL	EVAL		;look for expression
	JP	NC,PRVAL	;expression found, print its value
	CALL	DTEST
	JP	Z,PRDEL		;delimiter, print crlf and exit
	IF	NOT WILD	;only one print item allowed in WILD versions
	CALL	READ1		;read the char
	CP	','
	JP	Z,PRCOM		;comma
	CP	SEMIC
	JP	Z,PRSEM		;semicolon
	CP	TABT
	JP	Z,PRTAB		;TAB
	IF	NOT CAMAC
	CP	SPCT
	JP	Z,PRSPC		;SPC
	ENDIF
	IF	NOT FLOAT	;UNS allowed as print fn in nonfloat versions
	CP	UNST
	JP	Z,PRUNS
	ENDIF
	IF	NOT STRNG	;CHR$ allowed as print fn in nonstring versions
	CP	CHRST
	JP	Z,PRCHR
	ENDIF
	ENDIF			;end of NOT WILD conditional
	JP	SNERR		;else SN error
;print delimiter
PRDEL:	POP	BC		;pop the PRINT return
	JP	WCRLF		;write crlf and exit
;print the value of an EVALuated expression
PRVAL:	CALL	FETC1		;fetch the value
	IFTYP	PRSNG,PRSTR	;branch if noninteger
PRINV:	LD	A,B
	OR	A		;check sign of integer value
	JP	P,PRIV1		;print unsigned if positive
	IF	WILD
	JP	WRTBS
	ELSE
	CALL	WRTBS		;otherwise write signed
	JP	WRTS0		;write trailing space and return
	ENDIF
PRIV1:	LD	A,' '		;leading space to A
	IF	WILD
	JP	WRTB1
	ELSE
	CALL	WRTB1		;write unsigned with leading space
	JP	WRTS0		;write trailing space and return
	ENDIF
	IF	NOT WILD
;comma, space to the next tab stop
PRCOM:	CALL	PRCO1		;do the comma
	;and fall through to PRSEM for delimiter test
;semicolon
PRSEM:	CALL	DTST0		;check if next char is delimiter
	RET	C		;nondelimiter, continue printing
	POP	BC		;else pop the PRINT return
	RET			;and exit from PRINT
PRCO1:	LD	HL,(COLUM)
	LD	A,L		;fetch current column
	OR	A
	RET	Z
	IF	FLOAT		;comma column width is 14 if floating
	LD	BC,14		;comma column width to BC
	LD	L,B		;0 to L
	JP	P,PRCO2		;column is < 128 currently
	LD	L,126		;else make L 14*9
	SUB	L		;and reduce column accordingly
PRCO2:	ADD	HL,BC		;add comma width
	SUB	C		;subtract comma width from column
	JP	P,PRCO2		;repeat until negative
	ELSE			;comma column width is 8 if nonfloating
	OR	7
	INC	A		;compute desired column
	LD	L,A		;save column in L
	ENDIF
	LD	A,H
	OR	A
	LD	A,L		;fetch desired column
	JP	Z,PRCO3		;width 0, suppress cr check
	CP	H		;compare to width
	JP	NC,WCRLF	;write crlf if >= width
PRCO3:	LD	C,A
	JP	PRTA1		;else tab to column desired
;UNS
	IF	NOT FLOAT
PRUNS:	CALL	GTEXP		;get argument
	JP	PRIV1
	ENDIF
;TAB
PRTAB:	CALL	PRTA0		;get arg mod width
PRTA1:	LD	A,(COLUM)
	CP	C
	RET	Z		;found desired column
	CALL	PRTA2		;else write spaces until there
	JP	PRTA1
PRTA2:	JP	C,WRTSP		;write a space if left of desired column
	JP	WCRLF		;else write a crlf
;PRTA0 evaluates <expr> mod width for TAB and SPC
PRTA0:	CALL	GTEXP		;get argument
	LD	A,(WIDTH)
	OR	A		;Zero set iff width 0
	LD	E,A
	LD	D,0
	PUSH	DE
	CALL	NZ,OPMOD	;evaluate arg mod width unless width 0
	POP	DE		;restore width to DE
	LD	A,B
	OR	A		;check if arg was negative
	CALL	M,IADD		;yes, add width to result to make positive
	RET
;SPC
	IF	NOT CAMAC
PRSPC:	CALL	PRTA0		;get arg mod width
	LD	A,C
	OR	A
PRSP1:	RET	Z		;done
	CALL	WRTSP		;else write a space
	DEC	C		;decrement space count
	JP	PRSP1		;and repeat
	ENDIF
	ENDIF			;end of NOT WILD condtional
;quoted string
PRQU0:	CALL	READ1		;read the "
PRQUO:	LD	D,H
	LD	E,L		;address of first char to DE
	CALL	GTCLQ		;scan to close quote or cr
	LD	A,L		;fetch last+1 address
	SUB	E		;last+1 - first = # chars
PRST0:	LD	C,A		;to C
	JP	PRSTR		;and print the string
	IF	NOT STRNG	;allow CHR$ as print fn
PRCHR:	CALL	GTBEX		;get byte-value expr
	LD	A,C
	JP	WRITC		;write value and return
	ENDIF
;floating point value
	IF	FLOAT
PRSNG:	CALL	FOUT		;convert FACC to string
	IF	WILD
	JP	PRSTL
	ELSE
	CALL	PRSTL		;write the string
	JP	WRTS0		;write trailing space and return
	ENDIF
	ENDIF
;PRCAM is in module CAMAC.

;RANDOMIZE <expr>
	IF	NOT WILD
RNDIZ:	CALL	GTEXP
	LD	H,B
	LD	L,C		;value to HL
	LD	(RANDX),HL	;and it becomes new seed
	RET
	ENDIF			;end of NOT WILD conditional

;READ <var list>
;READ must scan the command line READ <var list> and lines of DATA [<expr>,]*.
;The text pointers are kept in TEXTP and TXTP2 and exchanged by FLIP.
READ:	LD	HL,(RDPTR)
	LD	(TXTP2),HL	;READ pointer to TXTP2
READA:	CALL	GTLHS		;get destination for ASSGN
	IF	STRNG
	PUSH	AF		;save var type in string version
	ENDIF
	CALL	FLIP		;to scan data
	CALL	GTCND		;see if comma (in DATA <lit>,<lit>...) next
	CALL	C,READE		;no, find next DATA statement
	IF	STRNG
	POP	AF		;restore var type
	CP	STRST
	JP	NZ,READB	;not a string var
	CALL	EVUNQ		;string var, get value (possibly unquoted)
	JP	READD
	ENDIF
READB:	CALL	GTLIT		;look for value
	JP	C,READF		;no value found
READD:	CALL	ASIGV		;assign value to variable
	CALL	FLIP		;to scan varlist
	CALL	GTCOM		;look for comma
	JP	NC,READA	;read another
	LD	HL,(TXTP2)	;else recover new RDPTR
	LD	(RDPTR),HL	;and store it
	RET			;and done
;READE finds the next DATA statement.
;Issues nonfatal OD error and retries if no more DATA.
;Issues fatal SN error if SN error in DATA.
READE:	CALL	DTST0		;check if at delimiter
	JP	C,READF		;no -- SN error in DATA
	LD	B,DATAT
	CALL	FNDST		;find next DATA
	RET	NC		;OK if found
	ERROR	N, O, D		;nonfatal OD error
	CALL	RSTOR		;do a RESTORE
	LD	(TEXTP),HL
	JP	READE		;and try again
;READF issues fatal SN error for bad DATA items.
READF:	EX	DE,HL		;DATA textp to DE
	CALL	FNDLN		;find its line number
	LD	(LNNUM),HL	;reset line # for error message
	ERROR	F, S, N		;fatal SN error

;REM <unquoted string>
REM:	CALL	GTCHA
	CP	CR
	JP	NZ,REM		;scan to <cr>
	CALL	BAKUP		;back up text pointer
	INC	HL		;let HL point to next byte in case on-line
	RET

;RENUM [<line #> [, <line #> [, <line #>]]]
	IF	EDITC
	IF	COMPL
RENUM	EQU	UFERR
	ELSE
;RENU0 gets an optional comma followed by <line #>, default value from DE.
RENU0:	CALL	GTCND		;look for comma
	CALL	NC,GTLNO	;if comma look for <line #>
	EX	DE,HL		;to HL
	RET			;and return
;First RENUM must get arguments.
;RNOLD gets the old line # of first renumbered line,
;RNNEW gets the new line # of first renumbered line, and
;RNINC gets the renumbering increment.
RENUM:
	IF	ROMSQ
	CALL	ISSRC		;must be addressing working space
	ENDIF
	CALL	GTLNO		;look for <line #>
	JP	NC,RENU1	;<line #> given
	CALL	FINDL		;none given -- look for line 0
	SCF			;to skip following FDLNO
RENU1:	CALL	NC,FDLNO	;find the specified line #
	PUSH	HL		;save first renumbered line location
	CALL	MODEM		;line # of first renumbered line to DE
	PUSH	DE		;and saved
	EX	DE,HL
	LD	(RNOLD),HL	;and saved in RNOLD
	LD	DE,10		;default arg2 is 10
	CALL	RENU0		;get increment
	LD	A,H
	OR	L
	JP	Z,USERR		;fatal US error if 0 (e.g., RENUM 10,,)
	LD	(RNINC),HL	;increment saved in RNINC
	EX	(SP),HL		;save increment, first line line # to HL
	EX	DE,HL		;and then to DE as default arg3
	CALL	RENU0		;get destination <line #>
	LD	(RNNEW),HL	;and saved in RNNEW
	EX	DE,HL		;destination to DE
	CALL	IITST		;RENUM illegal indirect
;Now test if the specified args give too large a max <line #>.
	POP	BC		;increment to BC
	POP	HL		;location to HL
	PUSH	BC
	PUSH	DE
	PUSH	HL		;save args
	LD	A,(HL)		;fetch length
	CALL	ADAHL		;address second line
RENU2:	LD	A,(HL)		;fetch length
	OR	A
	JP	Z,RENU3		;eof
	CALL	ADAHL		;address next line
	EX	DE,HL
	ADD	HL,BC		;compute its eventual line #
	EX	DE,HL
	JP	NC,RENU2	;continue if no overflow
	JP	USERR		;too large, US error
;Now test if last line # before first is < new first.
RENU3:	LD	BC,0		;last line before first initially 0
	POP	DE		;first line # length byte address to DE
	LD	HL,SRCAD	;start at beginning of source text
RENU4:	CALL	CMDHU		;compare first to current
	JP	Z,RENU5		;matched, BC now has last
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;line number to BC
	DEC	HL
	DEC	HL
	LD	A,(HL)		;fetch length byte
	CALL	ADAHL		;address next
	JP	RENU4		;and try it
RENU5:	POP	DE		;new first line # to DE
	PUSH	DE		;and resave
	CALL	CMBDU		;compare to line # before first
	JP	NC,USERR	;US error if previous is larger
	LD	HL,(TEXTP)
	PUSH	HL		;save TEXTP
	CALL	LNREF		;change <line #> references in source text
	POP	HL
	LD	(TEXTP),HL
;Now change the actual <line #>s.
	LD	HL,(RNOLD)
	EX	DE,HL		;RNOLD to DE
	CALL	FINDL		;find (possibly new) location of first changed
	POP	DE		;RNNEW to DE
	POP	BC		;RNINC to BC
RENU6:	LD	A,(HL)		;fetch length of next line
	OR	A
	JP	Z,RENU7		;all line numbers changed
	PUSH	HL		;save current length byte address
	CALL	ADAHL		;address next line
	EX	(SP),HL		;save next, recover current
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D		;change the line number
	POP	HL		;next line length byte address to HL
	EX	DE,HL
	ADD	HL,BC
	EX	DE,HL		;update line number
	JP	RENU6		;and renumber more
;Check break bytes for flag indicating illegal <line #> in line.
RENU7:	LD	B,0		;clear bad line flag
	LD	HL,SRCAD	;begin at the beginning
RENU8:	LD	A,(HL)
	OR	A
	JP	Z,RENUX		;eof, done
	PUSH	HL		;save length byte loc
	INC	HL
	INC	HL		;skip line # bytes
	INC	HL		;and address break byte
	LD	A,(HL)		;fetch it
	OR	A		;check bit 7
	JP	P,RENU9		;ok if not set
	DEC	HL
	DEC	HL		;address line # byte
	CALL	PRNTL		;print the bad line
	CALL	WCRLF		;and crlf
	LD	B,255		;and set bad line flag
RENU9:	POP	HL
	LD	A,(HL)		;refetch length
	CALL	ADAHL		;address next line
	JP	RENU8		;and try next line
RENUX:	PUSH	BC		;save bad line flag
	CALL	ADDL3		;text may have moved, reset stacks
	POP	AF		;recover bad line flag
	OR	A
	RET	Z		;successful RENUM
	JP	USERR		;else US error message
	ENDIF
	ELSE
RENUM	EQU	EXERR		;EX error in non-EDITC versions
	ENDIF

;RESTORE [<line #>]
RESTR:	CALL	GTLNO		;look for line #
	JP	C,RSTOR		;none, take least
	CALL	FDLNO		;find the line
	JP	RSTO1		;and reset the read pointer
RSTOR:
	IF	ROMSQ
	LD	HL,(SOURC)
	ELSE
	LD	HL,SRCAD
	ENDIF
RSTO1:	DEC	HL		;point to <cr> preceding line
	LD	(RDPTR),HL	;let read pointer address <cr>
	RET

;RETURN
RETRN:	CALL	EOS		;end of statement test
	LD	BC,(CSGOS SHL 8) OR CSINT
	CALL	CSDIG		;look for gosub or interrupt cstack entry
	JP	C,RGERR		;not found -- RG error
	CALL	CSPOP		;pop cstack information
	CP	B		;zero set if gosub, reset interrupt
	JP	Z,CSRST		;GOSUB entry -- reset stack & return
	PUSH	AF
	CALL	MVDEM		;interrupt table byte addr to DE
	LD	A,(DE)
	OR	40H		;resume interrupt
	LD	(DE),A
	POP	AF
	JP	CSRST		;reset control stack and return
RGERR:	ERROR	F, R, G		;fatal RG error

;RUN [<line #>]
	IF	COMPL
RUN	EQU	UFERR		;UF error if COMPL version
	ELSE
RUN:
	IF	SDISK
	CALL	CLOSN		;close any OPEN files
	ENDIF
	IF	CAMAC AND FALSE	;Northstar version
	CALL	CLOSE		;close any OPEN files
	ENDIF
	CALL	GTLNO		;look for line #
	PUSH	AF
	PUSH	DE
	CALL	IITST		;RUN illegal indirect
	CALL	CLEA1		;clear CSTACK, symbol table, string space
	IF	NOT WILD
	CALL	DISAB		;disable interrupts
	ENDIF
	CALL	RSTOR		;restore READ pointer
	POP	DE
	POP	AF
	JP	NC,GOTO2	;line # specified, execute from there
	LD	(TEXTP),HL	;else point to <cr> before source text
	RET			;and execute from there
	ENDIF

;SAVE is in section STATES4.

;SCALL <expr> [, <integer var ref>]*
;SCALL loads BC, DE and HL with the values of the <integer var ref>s, if any,
;and branches to the <expr> address.  When the user routine RETurns,
;the values in BC, DE and HL are assigned to the <integer var ref>s.
SCALL:	CALL	GTEXP
	LD	HL,(TEXTP)
	LD	(SAVTP),HL	;save textp for rescan on return
	LD	HL,SRETN
	PUSH	HL		;return address to stack
	PUSH	BC		;branch address to stack
	LD	DE,3		;maximum parameter count to DE
SCAL1:	CALL	GTCND		;look for comma not followed by delimiter
	JP	C,SCAL2		;none, set up registers and branch to user
	CALL	GTIVA		;perform integer var ref
	JP	C,MCERR		;not a var ref
	PUSH	BC		;save parameter value
	DEC	E		;decrement parameter count
	JP	NZ,SCAL1	;get more parameters if not three already
	CALL	GTCND		;check if more parameters
	JP	C,SCAL2		;no more
	ERROR	N, M, C		;nonfatal MC error if too many
;At SCAL2, DE contains 3 - # parameters specified, and the parameter values
;are PUSHed.  By adding DE to the address POP3, the branch address
;is computed to POP 3, 2, 1 or 0 values before branching to the user routine.
SCAL2:	LD	HL,POP3
	ADD	HL,DE		;compute pop address
	JP	(HL)		;branch to it
;SRETN is the entry point from the user routine's RETurn.
SRETN:	PUSH	HL
	PUSH	DE
	PUSH	BC		;save registers
	LD	HL,(SAVTP)
	LD	(TEXTP),HL	;restore TEXTP
	LD	DE,0		;# of POPed registers to DE
SRET1:	CALL	GTCND		;look for comma
	JP	C,SCAL2		;done, POP extras and return
	INC	E		;increment POPed count
	LD	A,3
	CP	E
	JP	C,NEXTC		;too many, scan to end and return
	PUSH	DE
	CALL	GTLHS		;get destination
	INC	HL		;point to high order destination
	POP	DE
	POP	BC		;value to BC
	CALL	ASIGI		;assign integer value, traced
	JP	SRET1		;and  repeat

;SETTIME <expr> [, <expr>] [, <expr>]
	IF	REALT AND NOT CAMAC;SETTIME in REALT versions only
STTIM:	LD	HL,TIMEX+3	;HL addresses hour count
	LD	DE,24		;max # hours
	OR	A		;reset Carry
	CALL	STTI2		;get hours count and set clock
	LD	DE,60		;max # minutes or seconds
	CALL	STTI1		;get minutes count and set clock
	CALL	STTI1		;get seconds count and set clock
	DEC	HL
	LD	(HL),255 AND -20;reset 20ths count
	RET
STTI1:	DEC	HL		;point to next time component
	PUSH	HL
	CALL	GTCND		;look for comma
	POP	HL
	LD	BC,0		;default to 0 if unspecified
STTI2:	CALL	NC,GTEXP	;get desired count
	CALL	CMBDU		;compare to max
	CALL	NC,FCER0	;too big, nonfatal FC error and return 0
	LD	A,C		;fetch count
	SUB	E		;subtract bias
	LD	(HL),A		;and store to set clock
	RET
	ENDIF

;STOP
	IF	COMPL		;STOP boots in COMPL version
	IF	WILD
STOP	EQU	UFERR		;UF error in WILD RTPAK
	ELSE
STOP	EQU	BOOT
	ENDIF
	ELSE
STOP:	LD	A,CSBRK		;break token to A
STOP1:	PUSH	AF		;line break entry point
	CALL	LINBC		;line # to BC
	JP	Z,DMOD2		;direct mode -- do not save info
	CALL	PRTM0		;turn on OMODE, print BREAK message
	DEFB	CR, LF, 'BREAK AT LINE', ' ' OR 80H
	CALL	WRTBU		;print line # unsigned
	POP	AF
STOP2:	CALL	CPUSH		;break info to control stack -- END entry point
	JP	DMOD2		;and continue in DMODE
	ENDIF			;end of COMPL conditional

;TIME
	IF	(NOT CAMAC) AND (NOT REALT)
TIME:	LD	A,CNTLG
	CALL	WRITC		;ring a bell
	LD	HL,0
	CALL	READC		;get and ignore first char
	CALL	TIMER
	JP	NC,EXERR	;counted to 0 -- EX error
	CALL	CTEST		;read the char TIMER saw
	PUSH	HL		;save minute count
	LD	A,H
	LD	(TIMEX+4),A	;minute count / 256 to TIMEX+4
	LD	B,H
	LD	C,L
	LD	DE,60
	CALL	DIVD0		;min count / 60 = sec count to HL
	POP	DE
	CALL	CPLDE		;complement minute count
	EX	DE,HL
	LD	(TIMEX),HL	;complmented minute count to TIMEX
	CALL	CPLDE		;complement second count
	EX	DE,HL
	LD	(TIMEX+2),HL	;complemented second count to TIMEX+2
	RET
	ENDIF

;TRACE | UNTRACE
;TRAP | UNTRAP
	IF	COMPL
TCON	EQU	UFERR		;UF error if COMPL version
TCOFF	EQU	UFERR
TPON	EQU	UFERR
TPOFF	EQU	UFERR
	ELSE
TCON:	SCF
TCOFF:	SBC	A,A		;A gets 0 if no carry, 255 if carry
	LD	(TRACE),A
	RET
TPOFF:	SCF
TPON:	SBC	A,A
	LD	(TRAP),A
	RET
	ENDIF			;end of NOT COMPL conditional

;UNBREAK [<line #> | <var list>]
;UNBREAK removes all breakpoints.
;UNBREAK <line #> removes the breakpoint (if any) on the specified line.
;UNBREAK <var list> removes breakpoints on the specified variables.
	IF	COMPL
UNBRK	EQU	UFERR		;UF error if COMPL version
	ELSE
UNBRK:	CALL	GTLNO		;see if line # present
	JP	C,UNBR2		;no
;Remove breakpoint from line # in DE.
	IF	ROMSQ
	CALL	ISROM		;must be running in RAM
	ENDIF
	CALL	FDLNO		;find the line
;UNBR1 removes the breakpoint on line addressed by HL.
UNBR1:	INC	HL		;move pointer from length byte
	INC	HL		;   past line #
	INC	HL		;   to break byte
	LD	(HL),0		;and zero it
	RET
UNBR2:	CALL	DTEST		;see if var list present
	JP	C,UBVAR		;yes
	LD	HL,(SYMTA)	;no, unbreak all lines and variables
;UNBR3 removes all variable breakpoints.
UNBR3:	CALL	STNXT		;get next symbol table entry
	JP	C,UNBKL		;end of table -- unbreak lines and return
	LD	A,(DE)
	AND	7FH
	LD	(DE),A		;unbreak one entry
	JP	UNBR3
;UBVAR removes breakpoints on the specified <var list> variables.
UBVAR:	CALL	FDVAR		;find var ref
	JP	C,SNERR
	LD	A,(DE)
	AND	7FH
	LD	(DE),A		;unbreak it
	CALL	GTCND		;look for comma
	JP	NC,UBVAR	;unbreak another var
	RET
	ENDIF			;end of NOT COMPL conditional

;UNTRACE and UNTRAP are under TRACE and TRAP above.

;WAIT <byte expr> , <byte expr> [, <byte expr>] [,$]
	IF	NOT WILD
WAIT:	CALL	IINFO		;get interrupt info
	LD	A,C
	RLA
	RLA
	LD	C,A		;$ bit to C7
	LD	A,B		;port # to A
	CALL	RDP1		;read
	OR	E		;mask
	XOR	D		;compare
	JP	Z,WAIT1
	SCF			;carry set iff compare nonzero
WAIT1:	RRA			;A7 set iff compare nonzero
	XOR	C		;sign set iff keep waiting
	RET	P		;condition fulfilled -- return
	LD	HL,(SAVTP)
	LD	(TEXTP),HL	;reset text pointer to parse WAIT again
	RET
	ENDIF			;end of NOT WILD conditional


;end of STATES3
	PAGE
;STRINGS 11/1/79
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979 by Mark Williams Company, Chicago
;string routines and functions

	IF	STRNG

;String space consists of RAM from (MEMT)+1 to (STRT).  String variables are
;stored from (MEMT)+1 to (STRPT), and (STRPT)+1 to (STRP2) is used for
;temporary string storage.  The string temporaries at STEMP contain the
;addresses of ESTACK string entries, as the strings may move during garbage
;collection.

;ATEMP assigns the ESTACK location in HL to a string temporary.
;The temporary is freed when the string value is FETCHed.
;Retn:	A	clobbered
;	BCDEHL	preserved
ATEMP:	PUSH	DE
	EX	DE,HL		;location to DE
	LD	HL,STEMP	;temp base addr to HL
	LD	A,(HL)		;fetch # temps in use
	INC	A		;and bump
	CP	STMAX		;compare to # available
	JP	NC,STERR	;too many, fatal ST error
	LD	(HL),A		;store new # in use
	ADD	A,A		;# * 2 bytes per temp
	CALL	ADAHL		;+ base = bottom of new temp
	LD	(HL),D
	DEC	HL
	LD	(HL),E		;location to temp
	EX	DE,HL		;restore loc to HL
	POP	DE		;and restore DE
	RET
STERR:	ERROR	F, S, T		;fatal ST error

;SCOPY copies a new string to string temp space for GET$, CHR$, and STR$.
;Call:	C	string length
;	DE	string location
;Retn:	B	preserved
;	C	string length
;	DE	string location (in string space)
;	HL	top of string temp space used
;SCOP0 is called from concatenation (SADD) and assignment (SCOPV) to
;fetch the string value addressed by HL and then copy to string space.
SCOP0:	CALL	FETCS		;fetch string arg
SCOPY:	LD	A,C
	CALL	STFRE		;assure sufficient free space
	LD	A,C
	OR	A
	RET	Z		;null string, just return
	PUSH	BC		;save length
	CALL	BCDE		;length to E, location to BC
	INC	HL		;next available location to HL
	PUSH	HL		;save location
	CALL	MOVD0		;copy string to string space
	DEC	HL
	LD	(STRP2),HL	;new top of string temp space used
	POP	DE		;restore location
	POP	BC		;and length
	RET

;SCOPV copies the value addressed by HL to string space for string assignment.
SCOPV:	PUSH	HL
	INC	HL
	LD	A,(HL)		;fetch length
	LD	HL,(STRPT)
	LD	(STRP2),HL	;clear string temp spacce
	CALL	STFRE		;assure sufficient free space
	POP	HL		;restore value pointer
	PUSH	HL
	CALL	SCOP0		;fetch the value and copy to string space
	LD	(STRPT),HL	;and reset string space var pointer
	POP	HL		;restore the value pointer
	PUSH	HL
	INC	HL
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D		;new location to value entry
	POP	HL		;restore HL
	LD	A,(HL)		;and restore type
	RET

;STFRE assures that (A) bytes of string space is availfable.
;Garbage collection is performed if required, and an OS error if insufficient.
;Call:	A	amount of string space needed
;Retn:	BC,DE	preserved
;	HL	top of used string space (STRP2)
STFRE:	PUSH	BC
	PUSH	DE
	LD	C,A
	LD	B,0		;desired space to BC
	LD	HL,(STRT)
	EX	DE,HL		;top of string space to DE
	LD	HL,(STRP2)	;current used string space top to HL
	PUSH	HL		;and saved
	ADD	HL,BC		;current top + desired amount to HL
	CALL	NC,CMDHU	;compare top to needed
	JP	NC,POP3		;top >= needed, restore and return
	POP	HL
	PUSH	BC		;save desired
	CALL	GARBG		;garbage collect
	EX	DE,HL
	POP	BC
	PUSH	HL		;save used top
	ADD	HL,BC
	CALL	NC,CMDHU	;compare top to needed
	JP	NC,POP3		;ok after garbage collection
	ERROR	F, O, S		;fatal OS error

;GARBG is the string space garbage collector.  All strings referenced by
;string variables or temporaries are compacted to the base of string space.
;Retn:	DE	top of used string space (STRPT)
;	HL	top of string space (STRT)
GARBG:	LD	HL,(MEMT)
	INC	HL		;point to first byte of string space
	LD	(GCMIN),HL	;min value to accept
;First the string with the minimum location >= GCMIN is found.
;GCLST contains the least so far, and GCLOC the location of the least.
GARB1:	LD	HL,-1
	LD	(GCLST),HL	;string space loc of least string found
	LD	HL,(SYMTA)
	PUSH	HL
GARB2:	POP	DE		;set initial values for NXTST
	CALL	NXTST		;find next symbol table string var
	JP	C,GARB4		;no more string entries
	PUSH	DE
	PUSH	HL
	LD	D,B
	LD	E,C		;next string location to DE
	CALL	GCCMP		;compare to min and least
	POP	HL		;restore next entry pointer to HL
	JP	C,GARB2		;< min or >= least, try next
	EX	DE,HL
	LD	(GCLST),HL	;else current becomes new least
	EX	DE,HL
	LD	(GCLOC),HL	;and gcloc stores its address
	JP	GARB2		;and try next
;All strings checked, must check if least was found.
GARB4:	LD	HL,(GCLST)
	LD	A,H
	AND	L
	INC	A
	JP	Z,GARB5		;no least found, string var compacting done
;Move the least string to the top of available string space.
	LD	HL,(GCLOC)
	DEC	HL
	DEC	HL
	DEC	HL		;point to length byte
	CALL	TPMOV		;move string temps pointing within string
	CALL	STMOV		;move the string
	JP	GARB1		;and continue compacting
;String vars compacted, now compact the string temps.
GARB5:	LD	HL,(GCMIN)
	DEC	HL
	LD	(STRPT),HL	;store new string var pointer
	LD	HL,(STRT)
	LD	(GCLST),HL	;set GCLST for GCCMP
	LD	HL,STEMP
	LD	A,(HL)		;fetch # temps in use
GARB6:	DEC	A
	JP	M,GARB7		;all temps moved, garbage collection done
	PUSH	AF		;save # temps still to move
	CALL	MODEM		;fetch temp loc to DE
	PUSH	HL
	PUSH	DE		;save temp loc
	EX	DE,HL
	CALL	MODEM		;fetch loc of temporary to DE
	CALL	GCCMP		;compare to min and least
	POP	HL		;temp loc to HL
	CALL	NC,STMOV	;move temp to base of avail space
	POP	HL
	POP	AF
	JP	GARB6		;and look for more temps
GARB7:	LD	HL,(GCMIN)
	DEC	HL
	LD	(STRP2),HL	;store new top of string temp space
	EX	DE,HL
	LD	HL,(STRT)	;and return string space top in HL
	RET
GCCMP:	LD	HL,(GCMIN)
	CALL	CMDHU
	RET	C		;location < min, try next
	LD	HL,(GCLST)
	CALL	CMDHU
	CCF			;location >= least, try next
	RET

;STMOV moves a string during garbage collection.
;Call:	HL	pointer to string length byte
;	(GCMIN)	destination
;Retn:	(GCMIN)	next unused location in string space
STMOV:	LD	E,(HL)		;length to E
	INC	HL
	PUSH	HL		;save location address
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;location to BC
	LD	HL,(GCMIN)	;destination to HL
	PUSH	HL		;and saved
	CALL	MOVD0		;move string in string space
	LD	(GCMIN),HL	;and store new min
	POP	DE
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D		;and copy new loc to value
	RET

;TPMOV moves temporaries during garbage collection.
TPMOV:	LD	DE,STEMP
	LD	A,(DE)		;fetch # temps in use
TPMO1:	DEC	A
	RET	M		;no more temps to check
	PUSH	HL		;save string value location
	PUSH	HL
	EX	DE,HL
	CALL	MODEM		;fetch ESTACK location of temp to DE
	EX	(SP),HL		;save STEMP pointer, string value ptr to HL
	PUSH	AF		;save # temps still to check
	PUSH	HL		;and string value ptr
	EX	DE,HL		;ESTACK temp loc to HL
	CALL	MODEM		;fetch temp loc to DE
	EX	(SP),HL		;save string temp pointer, value ptr to HL
	PUSH	DE		;and save temp loc
	LD	C,(HL)		;length to C
	CALL	MODEM		;location to DE
	LD	B,0
	CALL	CPLDE		;- loc to DE
	POP	HL		;temp loc to HL
	ADD	HL,DE		;temp loc - source loc
	JP	NC,TPMO2	;temp loc < source
	EX	DE,HL		;offset to DE
	DEC	BC		;length - 1 to BC
	CALL	CMBDU
	JP	C,TPMO2		;length <= offset
	LD	HL,(GCMIN)
	ADD	HL,DE		;destination + offset = new loc
	EX	DE,HL		;to DE
	POP	HL
	LD	(HL),D
	DEC	HL
	LD	(HL),E		;and to temp
	PUSH	HL
TPMO2:	POP	HL
	POP	AF		;# temps still unchecked
	POP	DE		;temp pointer
	POP	HL		;value pointer
	JP	TPMO1		;and check the next temp

;NXTST is used during garbage collection to find locations of nonnull strings.
;Call:	DE	next symbol table entry addr (initially SYMTA)
;	HL	next length byte in current entry (initially SYMTA)
;Retn:	Carry	Set iff no more nonnull strings
;	A	length of next nonnull string
;	BC	location of string
;	DE	next entry addr
;	HL	next length byte
NXTST:	CALL	CMDHU
	JP	NZ,NXTS3	;more in current entry
NXTS1:	CALL	STNXT		;address next symbol table entry
	RET	C		;no more
	LD	A,(DE)		;fetch type byte
	AND	1FH		;mask to type
	CP	STRST
	JP	NZ,NXTS1	;not a string
	EX	DE,HL		;next entry addr to DE
NXTS2:	INC	HL		;point to next name byte
	OR	(HL)
	JP	P,NXTS2		;scan past name
	INC	HL		;point to # dims
	LD	C,(HL)		;# dims to C
	LD	B,0
	INC	HL
	ADD	HL,BC
	ADD	HL,BC		;point to first length byte
NXTS3:	LD	A,(HL)		;fetch length
	CALL	MOBCM		;fetch location to BC
	INC	HL		;point to next
	OR	A
	RET	NZ		;return unless null
	JP	NXTST		;else try next

;EVUNQ gets a string value for READ or INPUT.  If the next item scanned
;EVALuates to a string value, its value is passed.  Otherwise the item is
;considered to be an unquoted string starting at the first nonblank and
;delimited by the next comma or cr, and a pointer to it is returned.
;Retn:	Carry	Set iff next nonblank char is delimiter
;	C, DE	length, location of string
EVUNQ:	CALL	GTCHA		;fetch first nonblank
	CP	'"'
	JP	Z,GTLIS		;quoted string literal
	CALL	BAKUP		;let HL and TEXTP point to first
	CALL	DTST1
	CCF
	RET	C		;first nonblank is delimiter, return Carry
	LD	D,H
	LD	E,L		;first nonblank loc to DE
EVUN1:	CP	','
	JP	Z,GTLS1		;done if next is comma
	CALL	DTST1
	JP	NC,GTLS1	;or if next is cr or '
	CALL	READ1		;else read the current
	LD	A,(HL)		;and fetch next
	JP	EVUN1		;and continue scanning

;CMSTR compares two strings.
;Call:	B	length of string 2
;	C	length of string 1
;	DE	location of string 1
;	HL	location of string 2
;Retn:	Carry	Set iff string 1 < string 2
;	Zero	Set iff string 1 = string 2
CMSTR:	LD	A,C
	OR	A
	JP	Z,CMST1		;end of string 1
	LD	A,B
	OR	A
	JP	Z,CMST2		;end of string 2
	LD	A,(DE)		;else fetch string 1 char
	CP	(HL)		;compare to string 2
	RET	NZ		;unequal
	DEC	B
	DEC	C		;decrement lengths
	INC	DE
	INC	HL		;increment pointers
	JP	CMSTR		;and continue checking
CMST1:	CP	B
	RET
CMST2:	OR	1		;clear Carry and Zero
	RET

;SIARG is called by LEFT$, RIGHT$ and MID$ to manipulate arguments.
;Call:	BC,DE	arg1 (string), arg2 (integer) pointers
;Retn:	A	arg2, 0 if < 0 and 255 if > 255 (with nonfatal FC error)
;	C, DE	string length and location
;SIAR0 is called by INST3 and MID3 to fetch integer arg 0 <= arg <= 255.
SIAR0:	CALL	CNVBI		;force to integer and fetch
	LD	H,B
	LD	L,C
	JP	SIAR1		;force 0 <= arg <= 255 to A
SIARG:	PUSH	DE		;save integer arg2
	CALL	FETBC		;fetch string arg1 to C, DE
	JP	NC,TMERR	;fatal TM error if nonstring
	POP	HL		;arg2 to HL
SIAR1:	LD	A,H		;MID3 entry point
	OR	A
	LD	A,L		;lsbyte of arg2 to A
	RET	Z		;done if 0 <= arg2 <= 255
	CALL	FCERN		;else issue nonfatal FC error
	LD	A,H
	OR	A
	LD	A,0
	RET	M		;and return 0 if < 0
	DEC	A		;else return 255
	RET


;string functions follow

;Concatenation (+): <string> x <string> --> <string>
SADD:	LD	A,B
	OR	A
	JP	Z,SADD3		;string 2 null, return s1
	LD	A,C
	OR	A
	JP	Z,SADD2		;string 1 null, return s2
	ADD	A,B		;else find length of concatenation
	JP	NC,SADD1	;not too long
	ERROR	N, L, S		;issue nonfatal LS error
	LD	A,C
	CPL
	LD	B,A		;useable length of s2 = 255 - length of s1
	ADD	A,C		;length of concatenation to A
SADD1:	PUSH	AF		;save length
	LD	HL,STEMP
	INC	(HL)
	INC	(HL)		;reassign string temporaries
	CALL	STFRE		;assure sufficient space available
	LD	HL,(ESTKP)
	INC	HL		;address s1 ESTACK entry
	PUSH	HL
	CALL	SCOP0		;fetch and copy to string space
	POP	HL
	PUSH	DE		;save location of copied s1
	LD	DE,VBYTS+2
	ADD	HL,DE		;address s2 ESTACK entry
	CALL	SCOP0		;fetch and copy to string space
	POP	DE		;result location to DE
	POP	AF
	LD	C,A		;result length to C
	LD	A,STRST		;result type to A
	RET
SADD2:	LD	C,B		;length of s2 to C
	EX	DE,HL		;and loc to DE
SADD3:	LD	A,STRST
	RET

;INSTR: [<integer> x] <string> x <string> --> <integer>
INSTR:	LD	HL,1		;default arg0 value to HL
INST0:	PUSH	HL		;save first to test -- INST3 entry point
	DEC	HL
	PUSH	HL		;save first-1
	CALL	AMBOP		;fetch matching args
	JP	NC,TMERR	;nonstrings
	EX	(SP),HL		;save s1 location, first-1 to HL
	EX	DE,HL
	ADD	HL,DE		;s2 loc + first - 1 = s2 remaining loc to HL
	LD	A,C
	LD	C,B
	SUB	E		;s2 length + first - 1 = s2 remaining length
	POP	DE
	JP	C,INST2		;s2 too short, return 0
	JP	Z,INST2		;s2 rem null, return 0
	LD	B,A		;s2 rem len to B
;At INST1 B=s2 rem len, C=s1 len, DE=s1 loc, HL=s2 rem loc, stack=result
INST1:	LD	A,B
	CP	C
	JP	C,INST2		;remaining part of s2 too short, return 0
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	B,C		;set lengths equal for string compare
	CALL	CMSTR		;compare s1 to LEFT$(rem s2,LEN(s1))
	POP	HL
	POP	DE
	POP	BC
	JP	Z,POP1		;matched, pop result to BC and return
	DEC	B		;else decr s2 rem len
	INC	HL		;and incr s2 rem loc
	EX	(SP),HL
	INC	HL		;and incr proto result
	EX	(SP),HL
	JP	INST1		;and try again
INST2:	POP	BC
	LD	BC,0
	RET
;INST3 executes ternary INSTR.
INST3:	PUSH	DE		;save arg2
	PUSH	HL		;and arg3
	CALL	SIAR0		;force 0 <= arg3 <= 255 to A
	LD	L,A
	LD	H,0		;arg3 to HL
	OR	A
	CALL	Z,INXH		;fudge value 0 to 1
	POP	DE
	POP	BC		;restore args
	CALL	INST0		;perform INSTR
	LD	A,INTST		;and return type integer
	RET

;BIN$:	<integer> --> <string>
BINFN:	LD	HL,(16 SHL 8) OR 1;16 digits, 1 bit each
	JP	HEXF0

;HEX$:	<integer> --> <string>
HEXFN:	LD	HL,(4 SHL 8) OR 4;4 digits, 4 bits each
;HEXF0 is called by BIN$ and OCT$ to convert to string.
;	BC	integer value to convert
;	H	max digit count
;	L	nummber of bits per digit
HEXF0:	LD	DE,BUFAD+1	;destination to DE
	PUSH	BC		;save arg
	LD	B,H		;remaining digit count to B
	LD	H,0		;to suppress leading 0s
HEXF1:	LD	C,L		;shift count to C -- OCT$ entry point
	EX	(SP),HL		;save status & count, get value
	XOR	A		;build result digit in A
HEXF2:	ADD	HL,HL		;shift arg left
	RLA			;Carry to A0
	DEC	C
	JP	NZ,HEXF2	;shift more bits
	ADD	A,90H		;90H, ..., 99H, 9AH, ..., 9FH
	DAA			;90H, ..., 99H, 00H+C,...,05H+C
	ADC	A,40H		;D0H, ..., D9H, 41H, ..., 46H
	DAA			;30H, ..., 39H, 41H, ..., 46H
	LD	(DE),A		;store ASCII digit
	INC	DE
	DEC	B
	JP	Z,HEXF4		;done
	EX	(SP),HL		;save value, get status
	SUB	'0'		;Zero set iff digit is 0
	OR	H		;Zero set iff leading 0
	LD	H,A		;save leading 0 status
	JP	NZ,HEXF1	;not a leading 0, do not suppress
	DEC	DE		;suppress it
	JP	HEXF1
HEXF4:	POP	BC		;discard saved status
	LD	HL,BUFAD
	LD	(HL),' '	;store first char = <space>
	EX	DE,HL		;first loc to DE, last+1 to HL
	LD	A,L
	SUB	E		;compute length
	LD	C,A		;length to C
	JP	SCOPY		;copy to string space and return

;OCT$:	<integer> --> <string>
OCTFN:	LD	H,B
	LD	L,C		;arg to HL
	ADD	HL,HL		;shift left one bit, Carry iff leading 1
	LD	B,H
	LD	C,L		;shifted arg to BC
	LD	HL,(5 SHL 8) OR 3;5 digits, 3 bits each
	JP	NC,HEXF0	;high bit 0, so just do as in HEX$
	LD	DE,BUFAD+1
	LD	A,'1'
	LD	(DE),A		;store leading ASCII 1
	INC	DE
	PUSH	BC		;save arg
	LD	B,H		;repeat count to B
	JP	HEXF1		;leave H nonzero to retain 0s

;STR$: {<integer> | <floating>} --> <string>
STRS:
	IF	FLOAT		;<floating> --> <string>
	CALL	FOUT		;convert floating value to string
	ELSE			;<integer> --> <string>
	LD	A,B
	OR	A
	LD	A,0
	JP	P,STRS1		;convert to string with no leading char if +
	CALL	IUMIN		;else negate the arg
	LD	A,'-'
STRS1:	CALL	CVTIS		;convert integer to string
	ENDIF
	JP	SCOPY		;copy to string space and return

;VAL: <string> --> {<integer> | <floating>}
VAL:	CALL	FETBC		;fetch the arg
	INC	C		;bump length
	JP	NZ,VAL1
	DEC	C		;length was 255, unincrement
VAL1:	CALL	SCOPY		;make new copy with extra char
	LD	(HL),CR		;last char is cr
	EX	DE,HL		;location to HL
	LD	(TXTP2),HL	;and to TXTP2 for FLIP
	CALL	FLIP		;let TEXTP scan the string
	CALL	GTLIT		;look for a literal
	PUSH	AF
	PUSH	BC
	PUSH	DE		;and save result of GTLIT
	CALL	GTCHA		;get first char after literal
	CALL	FLIP		;restore TEXTP
	LD	H,A		;first char after lit to H
	POP	DE
	POP	BC
	POP	AF		;recover result of GTLIT
	LD	L,A
	LD	A,H
	CP	CR		;check if next after lit was cr
	LD	A,L
	JP	NZ,FCER0	;FC error if not
	CP	INTST		;check if type integer
	RET	Z		;yes, return
	IF	FLOAT
	CP	SNGST
	JP	NZ,FCER0	;not floating nor integer, FC error
	LD	HL,TEMP
	LD	E,(HL)		;restore saved value for A to E if floating
	RET
	ENDIF

;ASC: <string> --> <integer>
ASC:	CALL	LEN		;fetch string arg, 0 to B
	LD	A,C		;length to A
	OR	A		;check length
	JP	Z,FCER0		;null, nonfatal FC error and return 0
	LD	A,(DE)		;else fetch character
	LD	C,A
	RET

;LEN: <string> --> <integer>
LEN:	CALL	FETBC		;fetch string arg
	LD	B,0		;return length in BC
	RET

;CHR$: <integer> --> <string>
CHRS:	CALL	ISBYT		;arg must be byte expr
	LD	A,C		;value to A
CHRS1:	LD	DE,TEMP
	LD	(DE),A		;save in TEMP
	LD	C,1		;length is 1
	JP	SCOPY		;and copy to string space

;LEFT$: <string> x <integer> --> <string>
LEFTS:	CALL	SIARG		;args to A, CDE
LEFT1:	CP	C
	RET	NC		;arg >= length, return unchanged
	LD	C,A		;else arg becomes new length
	RET

;RIGHT$: <string> x <integer> --> <string>
RIGHT:	CALL	SIARG
RIGH1:	CP	C
	RET	NC		;arg >= length, return unchanged
	DEC	C
	INC	DE		;else chop off head char
	JP	RIGH1		;and try again

;MID$: <string> x <integer> [x <integer>] --> <string>
MIDS:	LD	A,255		;default arg3 value to A
MID0:	PUSH	AF		;MID3 entry point
	CALL	SIARG
	POP	HL		;arg3 to H
	OR	A
	JP	Z,MID2		;arg2 is 0, just do LEFT$
	INC	C
	DEC	DE		;add bogus head char
MID1:	INC	DE
	DEC	C		;lop off head
	RET	Z		;return if null
	DEC	A		;and decrease arg2
	JP	NZ,MID1
MID2:	LD	A,H
	JP	LEFT1		;and do a LEFT$ with arg3
MID3:	PUSH	BC		;save arg1
	LD	B,D
	LD	C,E		;arg2 to BC
	CALL	CNVBI		;convert to integer and fetch
	PUSH	BC		;and save arg2
	LD	B,H
	LD	C,L
	CALL	SIAR0		;force 0 <= arg3 <= 255 to A
	POP	DE		;arg2 value to DE
	POP	BC		;and arg1 addr to BC
	CALL	MID0		;do the MID$
	LD	A,STRST		;and return type string
	RET

	IF	REALT
;TIME$: --> <string>
;TIME$ returns the current time as string "hh:mm:ss".
TIMED:	LD	DE,TIMEX+3	;DE addresses hours count
	LD	HL,BUFAD	;HL addresses string being built
	PUSH	HL		;save for result
	DI			;disable so clock does not tick during fetch
	LD	A,(DE)		;fetch hours-24
	ADD	A,24		;hours
	CALL	TIME1		;convert hours, fetch minutes
	CALL	TIME1		;convert minutes, fetch seconds
	EI			;all fetched, renable
	CALL	TIME1		;convert seconds
	POP	DE		;recover string address
TIME0:	LD	C,8		;length = 8 for hh:mm:ss
	JP	SCOPY		;copy to string space and return
;TIME1 adds two ASCII decimal digits and a colon to result string.
;Call:	A	desired value (hours, minutes or seconds)
;	DE	count location
;	HL	string destination
;Retn:	A	next count (from (DE)-1)
;	DE	decremented
;	HL	next location = HL + 3
TIME1:	LD	(HL),'0'	;store tens digit
TIME2:	CP	10
	JP	C,TIME3		;tens digit is now correct
	INC	(HL)		;else bump tens digit
	SUB	10		;and subtract from count
	JP	TIME2		;and try again
TIME3:	ADD	A,'0'		;make remainder ASCII
	INC	HL
	LD	(HL),A		;and add to string
	INC	HL
	LD	(HL),':'	;and add colon
	INC	HL		;point to next available
	DEC	DE
	LD	A,(DE)		;fetch next count
	ADD	A,60		;add negative bias
	RET
	ENDIF			;end of REALT conditional


	ENDIF			;end of STRNG conditional


;end of STRINGS
	PAGE
;TABLES 01/12/81
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
;tables


;symbol table type token EQUates
INTST	EQU	1		;integer variable
SNGST	EQU	2		;single precision floating point variable
STRST	EQU	3		;string variable
UFNST	EQU	4		;user-defined function
BRKST	EQU	5		;break entry
CAMST	EQU	6		;camac variable

;control stack token EQUates
CSGOS	EQU	25H		;gosub
CSFOR	EQU	47H+2*FBYTS	;for
CSBRK	EQU	65H		;break (and stop)
CSINT	EQU	87H		;interrupt
CSLBK	EQU	0A5H		;line break

;expr stack type byte EQUates
TMASK	EQU	0F0H		;type mask
PMASK	EQU	00FH		;precedence mask
;first characters
ISDEL	EQU	10H		;delimiter
ISLP	EQU	20H		;left parenthesis
ISRP	EQU	30H		;right parenthesis
ISCOM	EQU	40H		;comma
;then 0-ary and user-defined functions
ISFN0	EQU	50H		;0-ary function
ISUFN	EQU	60H		;user-defined function
;then ops and fns, op1 first
ISOP1	EQU	70H		;unary op
ISOP2	EQU	80H		;binary op
ISFN1	EQU	90H		;unary function
ISFN2	EQU	0A0H		;binary function

;branch addresses for command execution, in order of table position
CMDTA:	DEFW	LET
	DEFW	IFCOM
	DEFW	FOR
	DEFW	NEXT
	DEFW	GOTO
	DEFW	GOSUB
	DEFW	PRINT
	DEFW	INPUT
	DEFW	READ
	DEFW	RETRN
	DEFW	DEF
	DEFW	DIM
	DEFW	GTDEL
	DEFW	RESTR
	DEFW	STOP
	DEFW	ENDCM
	IF	NOT WILD
	DEFW	NULL
	ENDIF
	DEFW	CALCM
	DEFW	SCALL
	IF	NOT WILD
	DEFW	PUT
	DEFW	POKE
	DEFW	WAIT
	ENDIF
	DEFW	TCOFF
	DEFW	TCON
	DEFW	TPOFF
	DEFW	TPON
	DEFW	BREAK
	DEFW	UNBRK
	IF	NOT WILD
	DEFW	ENABL
	DEFW	DSABL
	DEFW	RNDIZ
	ENDIF
	DEFW	REM
	DEFW	DELAY
	DEFW	SAVE
	DEFW	LOAD
	DEFW	LISTM
	DEFW	CLEAR
	DEFW	NEWCM
	DEFW	RUN
	DEFW	CONT
	IF	NOT CAMAC
	DEFW	AUTO
	DEFW	DELET
	DEFW	EDIT
	DEFW	RENUM
	ENDIF
	IF	NOT WILD
	DEFW	MOVE
	ENDIF
	DEFW	EXEC
	IF	EPSTN
	DEFW	PLOT
	ENDIF
	IF	SDISK AND NOT C3885
	DEFW	OPEN
	DEFW	CLOSE
	DEFW	LINPT
	DEFW	MARGN
	IF	BENDX
	DEFW	BMSOS
	DEFW	BNAME
	DEFW	BZAP
	ELSE
	DEFW	DIRCM
	DEFW	SCRAT
	ENDIF
	ENDIF
	IF	BENDX
	DEFW	BFILS
	ENDIF
	IF	CAMAC
	DEFW	CAMCD
	DEFW	DECLR
	DEFW	DRIVR
	DEFW	XENAB
	DEFW	RSTAT
	DEFW	CAMCL
	DEFW	CINIT
	DEFW	CINHI
	DEFW	LOOPC
	DEFW	BYPAS
	DEFW	ONLIN
	DEFW	PULSE
	DEFW	OPEN
	DEFW	CLOSE
	IF	NOT C3885
	DEFW	CREAT
	ENDIF
	DEFW	LAMPA
	DEFW	BKSET
	DEFW	BLOCK
	DEFW	CENAB
	DEFW	CDSAB
	DEFW	STTIM
	ELSE
	IF	WILD
	DEFW	WGBUF
	ELSE
	DEFW	ASSIG
	ENDIF
	IF	REALT
	DEFW	STTIM
	ELSE
	DEFW	TIME
	ENDIF
	ENDIF
	IF	PACKI
	DEFW	ONLIN
	DEFW	OFLIN
	DEFW	FIELD
	ENDIF
	DEFW	ON		;must follow ONLINE

;type / precedence bytes for functions and ops
;ms four bits type, ls four bits precedence
TYPTA:	DEFB	ISUFN		;fn
	DEFB	ISOP1 + 6	;not
	DEFB	ISOP2 + 8, ISOP2 + 8;+, -
	DEFB	ISOP2 + 9, ISOP2 + 9;*, /
	IF	FLOAT
	DEFB	ISOP2 + 9, ISOP2 + 10;\, ^
	ENDIF
	DEFB	ISOP2 + 7, ISOP2 + 7, ISOP2 + 7, ISOP2 + 7, ISOP2 + 7
	DEFB	ISOP2 + 7, ISOP2 + 7, ISOP2 + 7;relations
	DEFB	ISOP2 + 5, ISOP2 + 4, ISOP2 + 4;and, xor, or
	DEFB	ISOP2 + 9	;mod
	IF	NOT WILD
	DEFB	ISOP2 + 11	;join
	ENDIF
	DEFB	ISFN0, ISFN0	;get, fre
	IF	NOT WILD
	IF	FLOAT
	DEFB	ISFN1+2		;rnd
	ELSE
	DEFB	ISFN0
	ENDIF
	ENDIF
	IF	WILD
	DEFB	ISFN0		;buffer
	ELSE
	IF	NOT CAMAC
	DEFB	ISFN0		;pos
	ENDIF
	DEFB	ISFN0, ISFN0	;first, last
	ENDIF
	IF	PACKI
	DEFB	ISFN0		;flag
	ENDIF
	IF	SDISK AND NOT C3885
	DEFB	ISFN1+2		;eof
	ENDIF
	IF	FLOAT
	IF	NOT WILD
	DEFB	ISFN1 + 2	;UNS
	ENDIF
	DEFB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2, ISFN1 + 2
	DEFB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2;unary functions
	IF	NOT CAMAC
	DEFB	ISFN1 + 2	;ATN
	ENDIF
	ENDIF
	IF	STRNG
	DEFB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2, ISFN1 + 2
	DEFB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2, ISFN1 + 2
	DEFB	ISFN2 + 2, ISFN2 + 2, ISFN2 + 2, ISFN2 + 2
	ENDIF
	IF	CAMAC
	DEFB	ISFN0, ISFN0
	IF	C3885
	DEFB	ISFN1 + 2
	ELSE
	DEFB	ISFN0
	ENDIF
	ELSE
	IF	NOT WILD
	DEFB	ISFN0		;iobyte
	ENDIF
	IF	REALT
	DEFB	ISFN0		;time$
	DEFB	ISFN1 + 2	;time
	ENDIF
	ENDIF
	DEFB	ISFN1 + 2, ISFN1 + 2
	IF	NOT WILD
	DEFB	ISFN1 + 2, ISFN1 + 2
	DEFB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2;unary functions
	DEFB	ISFN2 + 2, ISFN2 + 2, ISFN2 + 2, ISFN2 + 2, ISFN2 + 2
	DEFB	ISFN2 + 2, ISFN2 + 2;binary functions
	DEFB	ISFN1 + 2	;in
	ENDIF

;argument and result type information table for fns and ops
;FN is a macro building a five-byte table entry for a function.
;The first byte gives the type of arg2.
;The second byte gives the type of arg1.
;The third and fourth bytes give the function address.
;The fifth byte gives the type of the result.
;Unused arguments are indicated by 0, ambiguous entries by AMBST.
;E.g.:	fn	sgn, ambst, 0, intst
;indicates that the routine to compute SGN is at location SGN, the first arg
;ambiguous (integer or float), no second arg, and the result integer.
AMBST	EQU	0
FN	MACRO	ADDR, A1TYP, A2TYP, RTYPE
	DEFB	A2TYP, A1TYP
	DEFW	ADDR
	DEFB	RTYPE
	ENDM
;NB unary minus first, in place of fn
FUNTA:	FN	AUMIN, AMBST, 0, AMBST
	FN	OPNOT, INTST, 0, INTST
	FN	AADD, AMBST, AMBST, AMBST
	FN	ASUB, AMBST, AMBST, AMBST
	FN	AMUL, AMBST, AMBST, AMBST
	IF	FLOAT
	FN	FDIVD, SNGST, SNGST, SNGST	;floating
	FN	IDIVD, INTST, INTST, INTST	;integer
	FN	FATOX, SNGST, SNGST, SNGST
	ELSE
	FN	IDIVD, INTST, INTST, INTST	; is integer divide if nonfloating
	ENDIF
	FN	LEQ, AMBST, AMBST, INTST
	FN	LEQ, AMBST, AMBST, INTST
	FN	GEQ, AMBST, AMBST, INTST
	FN	GEQ, AMBST, AMBST, INTST
	FN	NEQ, AMBST, AMBST, INTST
	FN	EQUAL, AMBST, AMBST, INTST
	FN	LTHAN, AMBST, AMBST, INTST
	FN	GTHAN, AMBST, AMBST, INTST
	FN	OPAND, INTST, INTST, INTST
	FN	OPXOR, INTST, INTST, INTST
	FN	OPOR, INTST, INTST, INTST
	FN	OPMOD, INTST, INTST, INTST
	IF	NOT WILD
	FN	JOIN, INTST, INTST, INTST
	ENDIF
	FN	GET, 0, 0, AMBST
	FN	FREFN, 0, 0, INTST
	IF	NOT WILD
	IF	FLOAT
	FN	RND, SNGST, 0, SNGST
	ELSE
	FN	RND, 0, 0, INTST
	ENDIF
	ENDIF
	IF	WILD
	FN	WBUFF, 0, 0, STRST
	ELSE
	IF	NOT CAMAC
	FN	POS, 0, 0, INTST
	ENDIF
	FN	FIRST, 0, 0, INTST
	FN	LAST, 0, 0, INTST
	ENDIF
	IF	PACKI
	FN	FLAG, 0, 0, INTST
	ENDIF
	IF	SDISK AND NOT C3885
	FN	EOFFN, INTST, 0, INTST
	ENDIF
	IF	FLOAT
	IF	NOT WILD
	FN	UNSFN, INTST, 0, SNGST
	ENDIF
	IF	F9511
	FN	INT, SNGST, 0, SNGST
	ELSE
	FN	INT, SNGST, 0, AMBST
	ENDIF
	FN	FSQR, SNGST, 0, SNGST
	FN	FEXP, SNGST, 0, SNGST
	FN	FLN, SNGST, 0, SNGST
	FN	FSIN, SNGST, 0, SNGST
	FN	FCOS, SNGST, 0, SNGST
	FN	FTAN, SNGST, 0, SNGST
	IF	NOT CAMAC
	FN	FATAN, SNGST, 0, SNGST
	ENDIF
	ENDIF
	IF	STRNG
	FN	BINFN, INTST, 0, STRST
	FN	HEXFN, INTST, 0, STRST
	FN	OCTFN, INTST, 0, STRST
	FN	CHRS, INTST, 0, STRST
	IF	FLOAT
	FN	STRS, SNGST, 0, STRST
	ELSE
	FN	STRS, INTST, 0, STRST
	ENDIF
	FN	ASC, STRST, 0, INTST
	FN	LEN, STRST, 0, INTST
	FN	VAL, STRST, 0, AMBST
	FN	LEFTS, STRST, INTST, STRST
	FN	RIGHT, STRST, INTST, STRST
	FN	MIDS, STRST, INTST, STRST
	FN	INSTR, AMBST, STRST, INTST
	ENDIF
	IF	CAMAC
	FN	CAMQF, 0, 0, INTST
	FN	TIMED, 0, 0, STRST
	IF	C3885
	FN	EOFFN, INTST, 0, INTST
	ELSE
	FN	TYPFN, 0, 0, INTST
	ENDIF
	ELSE
	IF	NOT WILD
	FN	IOBYF, 0, 0, INTST
	ENDIF
	IF	REALT
	FN	TIMED, 0, 0, STRST;TIME$
	FN	TIME, INTST, 0, INTST;TIME
	ENDIF
	ENDIF
	FN	SGN, AMBST, 0, INTST
	FN	AABS, AMBST, 0, AMBST
	IF	NOT WILD
	FN	MSBYT, INTST, 0, INTST
	FN	LSBYT, INTST, 0, INTST
	FN	BCD, INTST, 0, INTST
	FN	BIN, INTST, 0, INTST
	FN	PEEK, INTST, 0, INTST
	FN	ROTAT, INTST, INTST, INTST
	FN	TEST, INTST, INTST, INTST
	FN	SENSE, INTST, INTST, INTST
	FN	RSHFT, INTST, INTST, INTST
	FN	LSHFT, INTST, INTST, INTST
	FN	RESET, INTST, INTST, INTST
	FN	SETFN, INTST, INTST, INTST
	FN	IMPM, INTST, 0, INTST
	ENDIF

;keyword table EQUates
NCMDS	EQU	(TYPTA-CMDTA)/2	;number of commands
NFUNS	EQU	FUNTA-TYPTA	;number of functions
NRWDS	DEFL	3		;number of reserved words
	IF	NOT WILD
NRWDS	DEFL	NRWDS+1
	IF	NOT CAMAC
NRWDS	DEFL	NRWDS+5
	ENDIF
	ENDIF
	IF	FLOAT
NRWDS	DEFL	NRWDS+1
	ELSE
NRWDS	DEFL	NRWDS+1
	IF	STRNG
NRWDS	DEFL	NRWDS+1
	ENDIF
	ENDIF
	IF	STRNG
NRWDS	DEFL	NRWDS+1
	ELSE
NRWDS	DEFL	NRWDS+1
	ENDIF
	IF	NOT WILD
NRWDS	DEFL	NRWDS+1
	ENDIF
	IF	KEY80
NKEYS	EQU	NCMDS+NFUNS	;number of keywords
	ELSE
NKEYS	EQU	NCMDS+NFUNS+NRWDS
	ENDIF

;keyword table
;Adding or deleting a keyword always requires changing the KEYword table.
;In addition, adding a command requires changing the branch table at CMDTA.
;Adding a fn/op requires changing the type/prec table at TYPTA and the arg/resu
;table at FUNTA.  Adding a reserved word requires changing the NRWDS EQUates.

;KEY is a macro to define keyword table entries and corresponding token values.
KEY	MACRO	F, L, TVAL
	IF	NOT NUL TVAL
TVAL	EQU	TOKEN		;;equate token value if desired
	ENDIF
TOKEN	DEFL	TOKEN+1		;;increment token value
	IF	WILD OR NOT COMPL
	DEFB	'&F', '&L' OR 80H;;keyword
	ENDIF
	ENDM
KEYSP	MACRO	F, L, TVAL
	IF	NOT NUL TVAL
TVAL	EQU	TOKEN		;;equate token value if desired
	ENDIF
TOKEN	DEFL	TOKEN+1		;;increment token value
	IF	WILD OR NOT COMPL
	DEFB	&F, &L OR 80H;;keyword
	ENDIF
	ENDM
;NOKEY is a macro to leave holes in table for commands not included in
;a non-ROMSQ or non-EDITC version, for token compatibility.
NOKEY	MACRO	N
	IF	WILD OR NOT COMPL
	REPT	N
	DEFB	0FFH		;;token is <rubout> or 80H
	ENDM
	ENDIF
TOKEN	DEFL	TOKEN+N
	ENDM
TOKEN	DEFL	-NKEYS AND 0FFH	;first token value

;commands
KEYTA:	KEY	LE, T, CMDTK
	KEY	I, F
	KEY	FO, R, FORT
	KEY	NEX, T, NEXTT
	KEY	GOT, O, GOTOT
	KEY	GOSU, B, GSUBT
	KEY	PRIN, T, PRNTT
	KEY	INPU, T
	KEY	REA, D
	KEY	RETUR, N
	KEY	DE, F
	KEY	DI, M
	KEY	DAT, A, DATAT
	KEY	RESTOR, E, RSTRT
	KEY	STO, P
	KEY	EN, D
	IF	NOT WILD
	KEY	NUL, L
	ENDIF
	KEY	CAL, L
	KEY	SCAL, L
	IF	NOT WILD
	KEY	OU, T
	KEY	POK, E
	KEY	WAI, T
	ENDIF
	KEY	UNTRAC, E
	KEY	TRAC, E
	KEY	UNTRA, P
	KEY	TRA, P
	KEY	BREA, K, BRKT
	KEY	UNBREA, K, UNBKT
	IF	NOT WILD
	KEY	ENABL, E, ENABT
	KEY	DISABL, E, DSABT
	KEY	RANDOMIZ, E
	ENDIF
	KEY	RE, M, REMT
	KEY	DELA, Y
	KEY	SAV, E
	KEY	LOA, D
	KEY	LIS, T, LISTT
	KEY	CLEA, R
	KEY	NE, W
	KEY	RU, N, RUNT
	KEY	CON, T
	IF	NOT CAMAC
	IF	EDITC
	KEY	AUT, O
	KEY	DELET, E
	KEY	EDI, T
	KEY	RENU, M
	ELSE
	NOKEY	4
	ENDIF
	ENDIF
	IF	ROMSQ
	IF	NOT WILD
	KEY	MOV, E
	ENDIF
	KEY	EXE, C
	ELSE
	NOKEY	2
	ENDIF
	IF	EPSTN
	KEY	PLO, T
	ENDIF
	IF	SDISK AND NOT C3885
	KEY	OPE, N
	KEY	CLOS, E
	KEY	LINPU, T
	KEY	MARGI, N
	IF	BENDX
	KEY	MSO, S
	KEY	NAM, E
	KEY	ZA, P
	ELSE
	KEY	DI, R
	KEY	SCRATC, H
	ENDIF
	ENDIF
	IF	BENDX
	KEY	FILE, S
	ENDIF
	IF	CAMAC
	KEY	CAMA, C
	KEY	DECLAR, E
	KEY	DRIVE, R, DRIVT
	KEY	XENABL, E
	KEY	RSTATU, S
	KEY	CAMCL, R
	KEY	INI, T
	KEY	INHIBI, T
	KEY	LOOPCO, L
	KEY	BYPAS, S
	KEY	ONLIN, E
	KEY	PULS, E
	KEY	OPE, N
	KEY	CLOS, E
	IF	NOT C3885
	KEY	CREAT, E
	ENDIF
	KEY	LAMPA, T
	KEY	BKSE, T
	KEY	BLOC, K
	KEY	ENA, B
	KEY	DISA, B
	KEY	SETTIM, E
	ELSE
	IF	WILD
	KEY	GETBU, F
	ELSE
	KEY	ASSIG, N
	ENDIF
	IF	REALT
	KEY	SETTIM, E
	ELSE
	KEY	TIM, E
	ENDIF
	ENDIF
	IF	PACKI
	KEY	ONLIN, E
	KEY	OFFLIN, E
	KEY	FIEL, D
	ENDIF
	KEY	O, N

;functions and ops
	KEY	F, N, UDFNT
	KEY	NO, T
	KEY	, +, PLUST
	KEY	, -, MINT
	KEY	, *, MULTT
	KEY	, /
	IF	FLOAT
	KEY	, \
	KEY	, ^
	ENDIF
	KEYSP	'<','='
	KEYSP	'=', '<'
	KEYSP	'=', '>'
	KEYSP	'>', '='
	KEYSP	'<', '>'
	KEYSP	'', '=', EQULT
	KEYSP	'', '<'
	KEYSP	'', '>'
	KEY	AN, D
	KEY	XO, R
	KEY	O, R
	KEY	MO, D
	IF	NOT WILD
	KEY	JOI, N
	ENDIF
	KEY	GE, T
	KEY	FR, E
	IF	NOT WILD
	KEY	RN, D
	ENDIF
	IF	WILD
	KEY	BUFFE, R, WBUFT
	ELSE
	IF	NOT CAMAC
	KEY	PO, S
	ENDIF
	IF	ROMSQ
	KEY	FIRS, T
	KEY	LAS, T
	ELSE
	NOKEY	2
	ENDIF
	ENDIF
	IF	PACKI
	KEY	FLA, G
	ENDIF
	IF	SDISK AND NOT C3885
	KEY	EO, F
	ENDIF
	IF	FLOAT
	IF	NOT WILD
	KEY	UN, S
	ENDIF
	KEY	IN, T, INTT
	KEY	SQ, R
	KEY	EX, P
	KEY	LO, G
	KEY	SI, N
	KEY	CO, S
	KEY	TA, N
	IF	NOT CAMAC
	KEY	AT, N
	ENDIF
	ENDIF
	IF	STRNG
	KEY	BIN, $
	KEY	HEX, $
	KEY	OCT, $
	KEY	CHR, $
	KEY	STR, $
	KEY	AS, C
	KEY	LE, N
	KEY	VA, L
	KEY	LEFT, $
	KEY	RIGHT, $
	KEY	MID, $, MIDST
	KEY	INST, R, INSTT
	ENDIF
	IF	CAMAC
	KEY	CA, M, CAMT
	KEY	TIME, $
	IF	C3885
	KEY	EO, F
	ELSE
	KEY	TY, P
	ENDIF
	ELSE
	IF	NOT WILD
	KEY	IOBYT, E
	ENDIF
	IF	REALT
	KEY	TIME, $
	KEY	TIM, E
	ENDIF
	ENDIF
	KEY	SG, N
	KEY	AB, S
	IF	NOT WILD
	KEY	MSBYT, E
	KEY	LSBYT, E
	KEY	BC, D
	KEY	BI, N
	KEY	PEE, K
	KEY	ROTAT, E
	KEY	TES, T
	KEY	SENS, E
	KEY	RSHIF, T
	KEY	LSHIF, T
	KEY	RESE, T
	KEY	SE, T
	KEY	I, N
	ENDIF

;reserved words and PRINT functions
	IF	KEY80
RWDTK	EQU	0EH		;first reserved word token
TOKEN	DEFL	RWDTK
	ENDIF
RWDTA:	KEY	THE, N, THENT
	KEY	T, O, TOT
	KEY	STE, P, STEPT
	IF	NOT WILD
	KEY	TA, B, TABT
	IF	NOT CAMAC	;no devices in CAMAC version
	KEY	SP, C, SPCT
	KEY	CON, #, CONTK
	KEY	RDR, #
	KEY	PUN, #
	KEY	LST, #
	ENDIF
	ENDIF
	IF	FLOAT
	KEY	SN, G, SNGT	;for DEF SNG
	ELSE
	KEY	UN, S, UNST	;UNS is print fn if nonfloating
	IF	STRNG
	KEY	IN, T, INTT	;for DEF INT
	ENDIF
	ENDIF
	IF	STRNG
	KEY	ST, R, STRGT	;for DEF STR
	ELSE
	KEY	CHR, $, CHRST	;CHR$ is print fn if nonstring
	ENDIF
	IF	NOT WILD
	IF	ROMSQ
	KEY	FRO, M, FROMT	;for MOVE FROM
	ELSE
	NOKEY	1
	ENDIF
	ENDIF

;end of keyword table

;table of keywords after which <line #>s may occur, for RENUM
	IF	EDITC AND NOT COMPL
KLNTA:	DEFB	GOTOT, GSUBT, THENT, RUNT, RSTRT
	DEFB	LISTT, BRKT, UNBKT
	IF	NOT WILD
	DEFB	ENABT, DSABT
	ENDIF
KLNCT	EQU	$-KLNTA
	ENDIF

;copyright message
;not in module INITIAL to prevent overlaying
MWCMA:	DEFB	'COPYRIGHT 1978, 1979, 1980, 1981'
	IF	EPSTN
	DEFB	13H
	ENDIF
	DEFB	' BY MARK WILLIAMS COMPANY, CHICAGO'
	IF	EPSTN
	DEFB	12H, CR, LF, LF, 'PREPARED FOR ', 16H
	DEFB	'EPSTEIN & BERGHORN', 12H, ', NORTHBROOK IL', CR, LF
	ENDIF
	DEFB	CR, LF OR 80H

;end of TABLES
	PAGE
;TOKENIZE 10/22/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;tokenization and line editing

	IF	(NOT WILD) OR (NOT RTPAK);WILD RTPAK uses GTLIN in WILD
;GTLIN gets a line of source text from the user and sets TEXTP.
;Uses:	B	temp storage
;	C	unused
;	D	LS byte of first text address
;	E	LS byte of max text address
;	HL	text address
;Chars are read with READC and inserted starting at NLNAD, except:
;	<rubout>	deletes last character
;	<control-R>	retypes current line
;	<control-U>	starts over
;	<control-H>	deletes last char, echoes <cntl-h> to backspace cursor
;	<cr>		echoes <lf> and returns
;	<control-G>	accepted
;	other <control>s	ignored (ASCII 0-1FH)
;Chars typed when buffer is full echo <control-G> and are ignored.
	IF	NOT WILD
GTLI0:
	IF	EPSTN
	CALL	WRITC		;echo the ^K
	ELSE
	CALL	ECHOC		;echo ^U
	CALL	WCRLF		;write crlf after ^U
	ENDIF
	IF	EDITC
	LD	A,CR
	LD	(NLNAD),A	;clobber old buffer contents in case ^E
	ENDIF
	ENDIF			;end of NOT WILD conditional
GTLIN:	LD	DE,NLNAD+NLMAX	;lsbyte of max address to E
	LD	HL,NLNAD	;first text byte address to HL
	LD	D,L		;lsbyte of text address to D
	IF	EDITC
	CALL	READC		;check first char in case ^E
	CP	CNTLE
	IF	WILD
	JP	NZ,GTLI2
	ELSE
	JP	NZ,GTL1D	;first char not ^E
	ENDIF
	JP	LEDIT		;enter line editor
	ENDIF
GTLI1:	CALL	READC		;get a character
	IF	NOT WILD
GTL1D:	CP	RBOUT
	JP	NZ,GTLI2
	IF	EPSTN
	CALL	WRITC		;echo the <rub> in Epstein version
	ENDIF
	LD	A,L		;rubout
	CP	D
	JP	Z,GTLI1		;start over if line is empty
	IF	EPSTN
	DEC	HL
	JP	GTLI1		;back up pointer and get next
	ELSE
	LD	A,'/'
	CALL	WRITC		;echo slash first
GTL1A:	DEC	HL
	LD	A,(HL)		;get previous char
	CALL	WRITC		;and echo it
GTL1B:	CALL	READC		;read another from console
	CP	RBOUT		;see if still rubbing out
	JP	NZ,GTL1C	;no, echo end slash and continue
	LD	A,L
	CP	D
	JP	Z,GTL1B		;at start of line
	JP	GTL1A
GTL1C:	LD	B,A		;save new char
	LD	A,'\'
	CALL	WRITC		;write end slash
	LD	A,B		;restore new char
	ENDIF			;end of NOT EPSTN conditional
	ENDIF			;end of NOT WILD conditional
GTLI2:	LD	(HL),A		;insert the char
	CP	CR
	JP	Z,GTLI5		;echo lf and return
	IF	NOT WILD
	CP	CNTLU
	JP	Z,GTLI0		;crlf and start over if ^U
	ENDIF
	IF	NOT EPSTN
	IF	(NOT WILD) OR (NOT RTPAK)
	CP	CNTLH
	JP	Z,GTLI7		;backspace if control-h
	ENDIF
	IF	EDITC
	CP	CNTLE
	JP	Z,GTLI8		;edit already typed line if ^E
	ENDIF
	IF	NOT WILD
	CP	CNTLR
	CALL	Z,ECHOC		;echo ^R
	JP	Z,GTLI6		;retype line if ^R
	ENDIF
	CP	CNTLG
	CALL	Z,ECHOC		;echo ^G
	JP	Z,GTLI3		;accept bell
	CP	20H
	JP	C,GTLI1		;ignore 0H - 1FH (controls)
	ENDIF
GTLI3:	LD	A,L
	CP	E		;check for line overflow
	LD	A,(HL)		;restore char to A
	CALL	Z,GTLI4		;replace with bell if line too long
	IF	EPSTN
	CP	ESCAP
	CALL	Z,GTLI6		;echo escape as $ in Epstein version
	ENDIF
	CALL	WRITC		;echo char
	INC	HL		;bump insertion pointer
	JP	GTLI1		;and get next
GTLI4:	LD	A,CNTLG		;replace char with bell
	DEC	HL		;leave pointer unchanged
	RET
GTLI5:
	IF	NOT COMPL
	XOR	A
	LD	(CSTKD),A	;clear control stack direct count
	ENDIF
	LD	HL,NLNAD
	LD	(TEXTP),HL	;reset text pointer
	JP	WCRLF		;echo crlf and return
	IF	EPSTN
GTLI6:	LD	A,'$'
	RET
	ELSE
	IF	NOT WILD
GTLI6:	CALL	WCRLF
	PUSH	DE		;save DE
	LD	DE,NLNAD	;first addr to DE
	LD	A,L
	SUB	E		;last+1 - first = # chars to A
	CALL	PRST0		;and print the line
	POP	DE		;restore DE
	JP	GTLI1		;and wait for next char
	ENDIF
	IF	(NOT WILD) OR (NOT RTPAK)
GTLI7:	LD	A,L
	CP	D
	JP	Z,GTLI1		;ignore if at start of line
	LD	A,CNTLH		;restore the ^H
	CALL	WRITC		;and echo the ^H to backspace
	DEC	HL		;decrement position
	JP	GTLI1
	ENDIF
	IF	EDITC
GTLI8:	CALL	WCRLF		;write crlf to get to new line
	LD	(HL),CR		;store cr
	JP	LEDIT		;line edit the line
	ENDIF
	ENDIF			;end of NOT EPSTN conditional

;ECHOC echoes meaningful control chars as ^char.
;Call:	A	control char value in ASCII
;Retn:	PSW,A,BC,DE,HL	preserved
ECHOC:	PUSH	AF
	LD	A,'^'
	CALL	WRITC		;write ^
	POP	AF		;restore control char value
	PUSH	AF		;and resave
	ADD	A,40H		;add ASCII bias
	CALL	WRITC		;write the char
	POP	AF		;restore status bits and A
	RET
	ENDIF			;end of NOT WILD and NOT RTPAK conditional

	IF	EDITC
;LEDIT does the work of line editing.
;Uses:	B	Chars left of cursor, initially 0
;	C	Max # of chars to add without overflowing buffer
;	HL	Cursor position, initially NLNAD
;	NLNAD	Line currently being edited
;	TLNAD	Original contents of line (in case ^U typed)
;Retn:	NLNAD	contains edited line
;	TEXTP	reset to NLNAD
;	CSTKD	reset to 0
;	GCHAR	reset to 0
;	TLNAD	clobbered
;	Registers	clobbered
LEDIT:	LD	HL,NLNAD	;input buffer address to HL
	LD	(TEXTP),HL	;reset TEXTP
	LD	DE,TLNAD	;tokenization buffer address to DE
LEDT0:	LD	BC,NLMAX+3	;0 to B, NLMAX+3 to C
LEDT1:	LD	A,(HL)		;fetch char from input buffer
	LD	(DE),A		;and save in tokenization buffer
	DEC	C		;decrement remaining char count
	INC	DE
	INC	HL
	SUB	CR		;check if at cr
	JP	NZ,LEDT1	;no, keep copying
	LD	(CSTKD),A	;clear CSTACK direct count
	LD	(GCHAR),A	;clear GCHAR
	LD	HL,NLNAD	;input buffer address to HL
	CALL	LEDI6		;type line
LEDT2:	CALL	READC		;get command character
LEDT3:	CP	CR
	JP	Z,LED11		;done if <cr>
	CP	CNTLU
	JP	Z,LED10		;^U
	PUSH	HL
	LD	HL,LEDT2
	EX	(SP),HL		;push LEDT2 to allow RETurn from routines
	CP	RBOUT
	JP	Z,LEDI1		;<rubout>
	CP	20H
	JP	NC,LEDI0	;printable char
	CP	CNTLD
	JP	Z,LEDI2		;^D
	CP	CNTLF
	JP	Z,LEDI3		;^F
	CP	CNTLG
	JP	Z,LEDI0		;^G, treat as printable
	CP	CNTLH
	JP	Z,LEDI4		;^H
	CP	CNTLK
	JP	Z,LEDI5		;^K
	CP	CNTLL
	JP	Z,LEDI6		;^L
	CP	CNTLN
	JP	Z,LEDI7		;^N
	CP	CNTLR
	JP	Z,LEDI8		;^R
	CP	CNTLT
	JP	Z,LEDI9		;^T
	RET			;ignore any other chars

;printable char or ^G is inserted.
LEDI0:	DEC	C		;decrement char count
	JP	Z,LED0B		;too many chars
	LD	D,(HL)		;char right of cursor to D
	LD	(HL),A		;insert new char
	CALL	LED9A		;incr chars left of cursor and echo char
	PUSH	HL		;and save
LED0A:	LD	A,D		;fetch saved char
	LD	D,(HL)		;save next char
	LD	(HL),A		;store current char
	INC	HL
	CP	CR
	JP	NZ,LED0A
	POP	HL		;restore cursor loc
	RET
LED0B:	INC	C		;undecrement count
LED0C:	LD	A,CNTLG
	JP	WRITC		;and write a bell

;<rubout> erases the char left of cursor, echoing it within slashes.
LEDI1:	LD	A,B
	OR	A
	RET	Z		;ignore if already at left margin
	LD	A,'/'
	CALL	WRITC		;write initial /
LED1A:	DEC	HL
	LD	A,(HL)
	CALL	LED4A		;write deleted char and move remainder of line
	CALL	READC		;read next char
	CP	RBOUT
	JP	NZ,LED1B	;no additional <rubout>s
	LD	A,B
	OR	A
	JP	NZ,LED1A	;<rubout> another
LED1B:	LD	D,A		;save next char
	LD	A,'\'
	CALL	WRITC		;write the end \
	LD	A,D		;restore next char
	POP	DE		;pop the return to LEDIT
	JP	LEDT3		;and return to LEDT1 instead

;^D deletes the char right of cursor.
LEDI2:	LD	A,(HL)		;fetch char right of cursor
	CP	CR
	RET	Z		;leave unchanged if at end of line
	INC	C		;one more char is now available
	PUSH	HL		;save cursor location
	LD	D,H
	LD	E,L
LED2A:	INC	HL
	LD	A,(HL)		;fetch next char
	LD	(DE),A		;and store
	INC	DE
	CP	CR
	JP	NZ,LED2A	;continue until cr
	POP	HL		;restore cursor
	RET

;^F <char> searches for next occurence of <char>.
LEDI3:	CALL	READC		;get search character
	LD	(GCHAR),A	;and save
LED3A:	LD	D,A		;search char to D
	PUSH	HL		;save cursor position
LED3B:	LD	A,(HL)		;fetch next char
	INC	HL
	CP	CR		;check if at cr
	JP	Z,LED3D		;not found
	CP	D		;check for match
	JP	NZ,LED3B
	EX	DE,HL		;match location to DE
	POP	HL		;restore current loc
LED3C:	CALL	CMDHU		;compare current to desired
	RET	Z
	LD	A,(HL)
	CALL	LED9A		;move right and print
	JP	LED3C
LED3D:	POP	HL		;recover cursor location
	JP	LED0C		;beep and continue

;^H deletes char left of cursor and echoes ^H.
LEDI4:	LD	A,B
	OR	A
	RET	Z		;no chars left of cursor
	DEC	HL
	LD	A,CNTLH
LED4A:	CALL	WRITC		;echo the ^H
	DEC	B		;decrement chars left of cursor
	JP	LEDI2		;move remainder of chars

;^K kills the chars right of the cursor.
LEDI5:	LD	A,(HL)		;fetch next
	CP	CR
	RET	Z		;done if at cr
	CALL	LEDI2		;else delete a char
	JP	LEDI5		;and repeat

;^L prints remainder of line and moves cursor to left.
LEDI6:	LD	A,(HL)
	INC	HL
	CALL	WRITC		;write next char
	CP	CR
	JP	NZ,LEDI6	;not at <cr> yet
	LD	HL,NLNAD	;cursor at left of line
	LD	B,0		;0 chars left of cursor
	JP	WLF		;write <lf> after <cr>

;^N gets next occurence of ^F <char>.
LEDI7:	LD	A,(GCHAR)	;get previous ^F character
	JP	LED3A		;and continue as for ^F

;^R retypes the line, leaving cursor unchanged.
LEDI8:	LD	D,H
	LD	E,L		;cursor position to DE
	CALL	LEDI6		;type remainder of line
	JP	LED3C

;^T moves the cursor one char right.
LEDI9:	LD	A,(HL)		;fetch next
	CP	CR
	RET	Z		;done if no chars right of cursor
LED9A:	INC	HL
	INC	B		;increment chars to left count
	JP	WRITC		;echo char and return

;^U restores the original contents of the buffer and retries.
LED10:	CALL	WCRLF		;write crlf
	LD	HL,TLNAD	;tokenization buffer address to HL
	LD	DE,NLNAD	;input buffer address to DE
	JP	LEDT0		;and continue as above

;<cr> resets GCHAR, prints the edited line and exits from line editor.
LED11:	XOR	A
	LD	(GCHAR),A	;reset GET character
	JP	LEDI6		;print line and return

	ENDIF			;end of EDITC conditional

	IF	WILD OR NOT COMPL
;TKIZE tokenizes a line of text and computes its length.
;Call:	(newln)	address of first text byte
;Uses:	BC	address of next tokenized text line byte
;	HL	address of next untokenized text line byte
;Retn:	A,BC,DE	clobbered
;	HL	address of first tokenized text line byte (i.e. (newln))
;	(textp)	ditto
;	(lnnum)	line #, 0 if none
;	(lnlen)	length of tokenized line + overhead, 0 to delete
;			(i.e. if line consists of [<line #>] <cr>)
;	Carry	set iff no line # and line not <cr>
;	Zero	set if <cr>
;The tokenized line is identical to the original line, EXCEPT:
;(1)  The line # (if any) and spaces preceding it are removed, and
;(2)  Instances of keywords not inside " " or following # are replaced
;	by the correponding tokens.
;0 is stored in the byte after <cr> as a pseudo-eof for direct mode execution.
TKIZE:
	IF	NOT (WILD AND RTPAK)
	CALL	LNNU0
	ENDIF
	LD	HL,NLNAD	;store text address in HL
	LD	BC,TLNAD	;tokenized line address to BC
	PUSH	BC		;save for exit
	CALL	GTDEC		;look for decimal line #
	JP	C,TKIZ0		;none
	LD	A,D
	OR	E
	JP	Z,SNERR		;SN error if zero or too big
TKIZ0:	PUSH	AF		;carry set iff no line #
	EX	DE,HL
	LD	(LNNUM),HL	;line # to lnnum
	EX	DE,HL
	LD	A,(HL)		;next text char to A
	SUB	CR		;compare with sui (to use zero)
	JP	NZ,TKIZ1
	INC	HL		;delete line by letting length = 0
	LD	(HL),A		;store pseudo-eof
	LD	(LNLEN),A
	POP	AF
	LD	A,D
	OR	E		;carry reset, zero set iff <cr>
	JP	STTP1		;set textp and return
TKIZ1:	CALL	TKIZB		;tokenize body of input line
	XOR	A
	LD	(BC),A		;pseudo-eof for direct mode exec
	LD	HL,TLNAD
	LD	A,L		;lsbyte of first address to A
	CPL			;- first text address - 1
	ADD	A,C		;+ last address + 1 = actual length - 1
	ADD	A,5		;+ line overhead + 1 = length
	LD	(LNLEN),A	;store tokenized line length
	POP	AF		;carry set iff no line #
	JP	NC,STTP1
	DEC	HL
	LD	(SAVTP),HL	;initialize savtp for direct mode commands
STTP1:	POP	HL		;return first text byte addr in HL
	LD	(TEXTP),HL	;initialize text pointer
	RET

COPYP:	LD	A,PRNTT	;substitute PRINT token for ?
TKIZA:	LD	(BC),A
	INC	BC
	INC	HL
	LD	D,':'
	CP	DATAT
	JP	Z,TKZA2		;do not tokenize DATA
	CP	REMT
	IF	WILD AND RTPAK	;suppress comments in WILD RTPAK tokenization
	JP	Z,WREM
	CP	''''
	JP	NZ,TKIZB
WREM:	LD	A,CR
	LD	(BC),A
	INC	BC
	RET
	ELSE
	JP	Z,TKZA1		;or REMarks (for ?)
	CP	''''
	JP	NZ,TKIZB	;or on-line comments
	ENDIF			;end of NOT (WILD AND RTPAK) conditional
TKZA1:	LD	D,CR
TKZA2:	CALL	CPYD1		;copy without tokenizing
TKIZB:	CALL	COPYS		;copy spaces
	CP	'"'
	CALL	Z,COPYQ		;copy to close quote
	CP	'#'
	JP	Z,COPYH		;watch for keywords after #
	CP	CR
	JP	Z,COPYA		;finished if cr -- copy and return
	CP	'?'
	JP	Z,COPYP		;? abbreviation for PRINT
	PUSH	BC		;save tokenized text pointer
	LD	C,-NKEYS AND 0FFH;table length to C
	LD	DE,KEYTA	;table address to DE
	CALL	TLKUP		;perform table lookup
	IF	KEY80
	JP	NC,TKIZC	;found it
	LD	C,-NRWDS AND 0FFH
	LD	DE,RWDTA
	CALL	TLKUP		;check for reserved word
	JP	C,TKIZC		;not a keyword nor a reserved word
	ADD	A,RWDTK+NRWDS	;use tokens starting at RWDTK
	ENDIF
TKIZC:	POP	BC		;restore text pointer
	JP	TKIZA		;copy A and keep tokenizing


;Tokenizer routines.
;COPYA copies one char from A through BC.
;COPYS copies successive spaces (if any) from M through BC.
;COPYQ copies " from A through BC, then copies from M through BC until
;	" (inclusive, incl. trailing spaces) or until <cr> (exclusive).
;COPYH copies hex digits, so e.g. #DEF and #BIN tokenize correctly.
;Call:	BC	address of next available destination
;	HL	address of next available char (i.e. source)
;Retn:	A	char copied for COPY1,COPYA
;		first char not copied for COPYS, COPYQ
;	BC	next available destination address
;	DE	preserved
;	HL	next available source address

COPYA:	LD	(BC),A	;store through BC
	INC	BC
	INC	HL
	RET

COPYQ:	LD	D,A
COPYD:	LD	(BC),A
	INC	BC
	INC	HL		;copy current character
CPYD1:	LD	A,(HL)
	CP	CR
	RET	Z		;return without copying if cr
	CP	D
	JP	NZ,COPYD	;keep copying if neither (D) nor cr
COPS0:	LD	(BC),A
	INC	BC
COPS1:	INC	HL
COPYS:	LD	A,(HL)
	CP	' '
	RET	NZ		;return at first non-space
	IF	WILD AND RTPAK
	JP	COPS1		;suppress spaces in WILD RTPAK tokenization
	ELSE
	JP	COPS0
	ENDIF

COPYH:	LD	(BC),A
	INC	BC
	INC	HL		;copy char and spaces
	LD	A,(HL)
	CALL	LDTST		;test if letter or digit
	JP	NC,CPYH1	;yes
	SUB	20H		;convert from possible lower case
	CALL	LDTST
	JP	C,TKIZB		;not a letter or digit
CPYH1:	CP	'F'+1
	JP	NC,TKIZB	;letter but not legit hex digit
	JP	COPYH		;ok, copy it

;TLKUP performs table lookup for the tokenizer.
;Call:	C	- number of table entries
;	DE	address of first table byte
;	HL	address of first text byte
;Retn:	Carry	set if not found
;	A	token (position of matched word from table bottom) if found,
;			first text byte if not
;	B	preserved
;	C	token if found, zero if not
;	DE	address of first text byte if found,
;			of first byte following table if not
;	HL	address of last matched text byte if found,
;			of first text byte (i.e. unchanged) if not
TLKUP:	PUSH	HL		;save text pointer
TLKU0:	LD	A,(HL)		;fetch text char
	SUB	20H		;convert lower case to upper
	CP	'A'
	JP	C,TLKU1		;char  < 'a'
	CP	'Z'+1
	JP	NC,TLKU1	;char > 'z'
	LD	(HL),A		;store converted char
TLKU1:	LD	A,(DE)		;table byte to A
	CP	(HL)		;compare to text byte
	JP	NZ,TLKU2
	INC	DE		;matched -- try next byte
	INC	HL
	JP	TLKU0
TLKU2:	AND	7FH		;reset sign bit of table byte
	CP	(HL)		;compare again
	JP	NZ,TLKU3	;failed -- no match
	LD	A,C		;match -- return token in A, Carry reset
	POP	DE		;unstack the saved pointer
	RET
TLKU3:	LD	A,(DE)		;failed
	INC	DE
	AND	80H		;look at sign bit
	JP	Z,TLKU3		;keep looking for end of entry
	POP	HL		;restore text pointer
	INC	C		;increment count
	JP	NZ,TLKUP	;try next table entry
	LD	A,(HL)		;return text char if no match
	SCF			;return Carry on failure
	RET
	ENDIF			;end of WILD OR NOT COMPL conditional

	IF	NOT COMPL
;ADDL adds a tokenized line to source text.
;Call:	(lnnum)	line #
;	(lnlen)	line length, 0 to delete
;	(newln)	address of first byte of new line
;	(eofad)	end of source file address
;If line # is already in text, the old line is replaced with the new.
;If not, the new line is simply inserted.
;Branches out if memory full, i.e. if source top overlaps symbol table bottom.
;Clobbers all registers.
ADDLN:
	IF	ROMSQ
	LD	DE,SRCAD
	LD	HL,(SOURC)
	CALL	CMDHU		;Zero set iff addressing working space
	CALL	NZ,LNNU0	;not in working space, reset LNNUM to 0
	JP	NZ,ROERR	;and issue fatal RO error
	ENDIF
	LD	HL,(LNNUM)
	EX	DE,HL		;line # to DE
	CALL	FINDL		;look for it
	PUSH	HL		;save pointer for line insertion later
	LD	BC,0		;length of old line to BC
	JP	C,ADDL0		;0 if no such line,
	LD	C,(HL)		;  else length from pointer
ADDL0:	ADD	HL,BC		;address of next  line = old + length to HL
	LD	(TEMP),HL	;save it for old > new case below
	EX	DE,HL
	CALL	CPLDE		;- next line address to DE
	LD	HL,(EOFAD)	;end of file address to HL
	INC	HL
	ADD	HL,DE		;eof - next line + 1 = count to HL
	EX	DE,HL		;count to DE for block move
	LD	A,(LNLEN)	;new line length to A, 0 to delete
	SUB	C		;new - old = offset
	LD	C,A		;offset to c
	JP	C,ADDL4		;old > new
	JP	Z,ADDL2		;old = new, so just insert it
;block move text below longer new line
	PUSH	DE		;old < new
	LD	HL,(SYMTA)
	LD	DE,-9
	ADD	HL,DE		;leave enough room to compute trivial exprs
	EX	DE,HL		;symbol table address to DE
	LD	HL,(EOFAD)
	PUSH	HL
	ADD	HL,BC		;HL gets eofad + offset = destination
	LD	B,H
	LD	C,L
	CALL	CMBDU		;compare destination to symbol table addr
	CALL	NC,LNNU0	;out of memory -- reset LNNUM to 0
	JP	NC,OMERR	;and issue fatal OM error
	LD	(EOFAD),HL	;reset EOF address
	POP	BC		;BC gets old eof address = source
	POP	DE		;restore count
ADDL1:	LD	A,(BC)		;fetch byte from BC
	LD	(HL),A		;store through HL
	DEC	BC
	DEC	HL
	DEC	DE
	LD	A,D
	OR	E
	JP	NZ,ADDL1	;move more bytes
;insert current line into source
ADDL2:	POP	DE		;recover insertion address
	LD	A,(LNLEN)
	OR	A
	JP	Z,ADDL3		;done if length = 0
	LD	(DE),A		;else store length
	SUB	4		;length - overhead = length to move
	LD	BC,TLNAD	;source address to BC
	LD	HL,(LNNUM)
	IF	EDITC
	LD	(ERRLN),HL	;set ERRLN
	ENDIF
	EX	DE,HL		;insertion addr to HL, lnnum to DE
	CALL	MOMDE		;store line #
	INC	HL
	LD	(HL),0		;store zero break byte
	INC	HL		;HL now has destination
	LD	E,A		;actual length to E for insertion
	CALL	MOVD0		;copy new line into text
;reset stacks and return
ADDL3:	LD	HL,(EOFAD)	;eof address to HL
	JP	NEW1		;reset stacks and return
;block move text below shorter new line
ADDL4:	LD	HL,(TEMP)	;recover next text line address
	PUSH	HL
	DEC	B		;B becomes 255, since offset in BC is < 0
	ADD	HL,BC		;HL gets next + offset = destination
	POP	BC		;BC gets next = source
	CALL	MOVED		;move text down in memory
	DEC	HL
	LD	(EOFAD),HL	;reset EOF address
	JP	ADDL2		;and insert current line

;LNNU0 resets LNNUM to 0.
LNNU0:	LD	HL,0
	LD	(LNNUM),HL
	RET

	ENDIF			;end of NOT COMPL conditional

;MOVED performs block move of memory Down.
;Call:	BC	source address
;	DE	count (# of bytes to move)
;	HL	destination address
;Retn:	A	clobbered
;	BC	address of last source byte + 1
;	DE	zero
;	HL	address of last destination byte + 1
;MOVEB moves 2 or 4 bytes with MOVED.
MOVEB:
	IF	FLOAT		;byte count to DE
	LD	E,VBYTS-1
	ELSE
	LD	E,2
	ENDIF			;and fall through to MOVD0
MOVD0:	LD	D,0
MOVED:	LD	A,(BC)		;BC contains source
	LD	(HL),A		;HL contains destination
	INC	BC
	INC	HL
	DEC	DE		;DE contains count
	LD	A,D
	OR	E		;test if (DE) = 0
	JP	NZ,MOVED
	RET

;FINDL finds line with given line # in user source text.
;Call:	DE	desired line #
;Retn:	A	clobbered
;	BC	value of HL when called
;	DE	preserved, i.e. desired line #
;	HL	address of a user source line length byte, namely:
;			Success, length byte of desired line # in source
;			Failure, length byte of first greater line #, or EOF
;	Carry	set iff not found
;	Zero	set if found or if at end of table
FINDL:	PUSH	HL
	IF	ROMSQ
	LD	HL,(SOURC)
	ELSE
	LD	HL,SRCAD	;search from start
	ENDIF
FNDL1:	LD	A,(HL)		;length byte to A
	OR	A
	JP	Z,FNDL2		;not found if at end of table
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;source line # to BC
	DEC	HL
	DEC	HL		;point to length byte again
	CALL	CMBDU		;compare to desired line #
	JP	Z,FNDL3		;equal -- success
	JP	NC,FNDL2	;greater -- failure
	LD	C,(HL)		;less, keep trying -- length to BC
	LD	B,0
	ADD	HL,BC		;let HL point to address of next entry
	JP	FNDL1
FNDL2:	SCF			;failure -- return with carry set
FNDL3:	POP	BC		;return old HL in BC
	RET

;FDLNO does a FINDL, issues fatal US error if not found.
FDLNO:	CALL	FINDL
	RET	NC
	JP	USERR

;end of TOKENIZE
	PAGE
;XMATH 06/09/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;floating point extended function package


	IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)


;8080 FLOATING POINT POLYNOMIAL EXPANDER - FPOLY
;  THIS ROUTINE EVALUATES A POLYNOMIAL OF THE FORM
;F(X) = A(0) + A(1)*X^(1*(K+J)) + A(2)*X^(2*(K+J))
;		+ A(2)*X^(2*(K+J)) + ...
; WHERE
;	A(0) IS AN INITIAL SUM VALUE IN THE
;	     THE FLOATING POINT ACCUMULATOR
;	A(N) IS A TERM CONSTANT FROM A LIST, THE
;	     ADDRESS OF WHICH IS SUPPLIED IN HL
; AND K AND J ARE INTEGER VALUES SIMULATED BY
; A SUPPLIED VALUE FOR THE INITIAL POWER TERM, AND
; A SUPPLIED VALUE FOR THE POWER TERM TO BE
; MULTIPLIED BY AFTER EACH TERM CALCULATION.
;    THE EVALUATION IS TERMINATED BY ONE OF TWO EVENTS.
;	1. IF THE SUPPLIED SIGNIFICANCE STOP VALUE
;	   IS EVER LESS THAN THE SIGNIFICANCE INDEX
;	   RETURNED BY THE FLOATING POINT ADD ROUTINE
;	   (INDICATING THE TERM WOULD NOT AFFECT THE RESULT)
;OR
;	2. A TERM CONSTANT WITH AN EXPONENT OF ZERO
;	   IS ENCOUNTERED.
;
;DETAILED CALLING SEQUENCE ...
;
;	LXI	H,INPWR		;ADDRESS OF POWER LIST
;	PUSH	H		;ON STACK
;	LXI	H,KLIST		;ADDRESS OF CONSTANT LIST
;	CALL	FPOLY
	;	...		;RETURN HERE WITH F(X) INFACC
;
;INPWR:	DS	4		;INITIAL POWER OF X
;	DS	4		;TERM POWER MULTIPLIER
;
;	...
;
;KLIST:	DB	-1		;SIGNIFICANCE STOP VALUE
;	DW	K,K		;TERM CONSTANT A(1)
;	DW	K,K		;TERM CONSTANT A(2)
;	...
;	DW	K,K		;TERM CONSTANT A(N)
;	DB	0		;TERMINATOR
;
;   A SIGNIFICANCE STOP VALUE OF -1 WILL CAUSE THE
;ROUTINE TO UNCONDITIONALLY CALCULATE ALL TERMS IN
;THE LIST.  A VALUE OF 16 IS USED IN THE SIN/COS
;ROUTINE WITH NO EFFECT ON THE ACCURACY.
;  SEE THE DESCRIPTION OF THE INDEX IN THE MATH PACKAGE WRITEUP.

FPOLY:	LD	DE,SIG	;MOVE ARGS OVER
	LD	A,(HL)		;GET SIG
	LD	(DE),A		;AND SAVE
	INC	HL
	LD	(VECT),HL	;SAVE TERM TABLE ADDRESS
	POP	HL		;POP OFF RETURN ADDRESS
	EX	(SP),HL		;AND EXCHANGE WITH ARGUMENT
	LD	C,8
FPOL0:	LD	A,(HL)
	INC	HL
	INC	DE
	LD	(DE),A
	DEC	C
	JP	NZ,FPOL0
	CALL	FTEST		;RESTORE
	LD	HL,FPSUM	;AND SAVE
	PUSH	HL
	CALL	FSTOR		; SUM
	LD	HL,FPTXN
	CALL	FLOAD		;GET CURRENT POWER
FPOL1:	LD	HL,(VECT)	;AND CURRENT TERM
	CALL	FMUL		;A(N)*X^(N+K)
	POP	HL
	PUSH	HL
	CALL	FADD		;ADD IT IN
	PUSH	AF
	LD	A,(SIG)
	CP	E		;CHECK FOR NO SIGNIFICANCE
	JP	C,FPOL2
	POP	AF
	POP	HL
	PUSH	HL
	CALL	FSTOR
	LD	HL,(VECT)
	LD	DE,4
	ADD	HL,DE
	LD	(VECT),HL
	LD	A,(HL)
	AND	A
	POP	HL
	JP	Z,FLOAD
	PUSH	HL
	LD	HL,FPTXN
	PUSH	HL
	CALL	FLOAD
	LD	HL,FPTXN+4
	CALL	FMUL
	POP	HL
	CALL	FSTOR
	JP	FPOL1

FPOL2:	POP	AF
	POP	HL
	RET


;8080 INTEGER/FRACTIONAL PART - FINT
;	CALL FINT	;ARGUMENT IN FAC
;	...
;RETURNS WITH SIGNED INTEGER PART IN HL
;	   AND SIGNED FRACIONAL PART IN FAC
;
;OVERFLOW CONDITIONS SET IF
;  -32767 > VALUE > 32767

FINT:	CALL	FTEST		;SET UP ABCD TO FAC
	LD	E,A		;SAVE EXP
	LD	A,B		;GET M0
	AND	80H		;AND ISOLATE SIGN BIT
	LD	(FINSN),A	;SAVE SIGN
	LD	A,E		;GET EXPONENT
	CP	129		;AND CHECK RANGE
	JP	NC,FINT0	;NOT TOO SMALL
	LD	HL,0		;VALUE .LT. 1.0
	RET
FINT0:	CP	144		;SEE IF TOO LARGE
	JP	C,FINT2		;VALUE IS IN RANGE
	LD	A,(FINSN)	;OVERFLOW
	RLCA			;SET HL
	LD	HL,7FFFH	;TO +/-
	JP	NC,$+4		; FULL SCALE
	INC	HL
	PUSH	HL
	CALL	FTEST		;RESTORE ABCD
	POP	HL		;AND
	SCF			;SET OFLOW AND
	RET			;EXIT

;SET UP MANTISSA FOR SHIFTING AND CLEAR INTEGER
FINT2:	EX	DE,HL		;D->H
	PUSH	BC		;MOV BC
	POP	DE		;TO DE
	SUB	80H		;MAKE SHIFT COUNT
	LD	C,A		;INTO C
	LD	B,H		;MOVE M2
	LD	A,D		;SET
	OR	80H		;MANTISSA
	LD	D,A		; B23
	LD	HL,0		;CLEAR INTEGER
;MANTISSA (M0,M1,M2) IN DEB, INTEGER (I0,I1) IN HL
;SHIFT  H  L  D  E  B   LEFT 'C' BITS
;      I0,I1,M0,M1,M2
FINT3:	ADD	HL,HL		;I0,I1 LEFT
	EX	DE,HL
	ADD	HL,HL		;M0,M1 LEFT INTO CY
	JP	NC,$+4
	INC	DE		;CY PROPAGATE INTO I0,I1
	EX	DE,HL
	XOR	A		;CLEAR A & CY
	ADD	A,B		;GET M2
	RLA			;LEFT B7->CY, 0->B0
	LD	B,A		; AND RESTORE
	JP	NC,$+4
	INC	DE		;CY PROPAGATE INTO M0,M1
	DEC	C		;DECREMENT EXP
	JP	NZ,FINT3	;AND CONTINUE
	EX	DE,HL		;I0,I1 <-> M0',M1'
;CHECK NEW MANTISSA (M0',M1',M2') FOR ZERO
	OR	H		;CHECK
	OR	L		;MN'
	JP	Z,FINT6		;MN' IS ZERO
;NORMALISE NEW MANTISSA IN HLB
; DECREMENTING EXPONENT IN C
FINT4:	LD	A,H		;GET M0'
	RLCA			;CHECK HIGH ORDER BIT B23
	JP	C,FINT5		;NORMALIZATION COMPLETE
	ADD	HL,HL		;SHIFT M0',M1' LEFT
	LD	A,B		;GET M2'
	RLA			;M2' LEFT B7->CY, 0->B0
	LD	B,A		;RESTORE
	JP	NC,$+4		;NO DATA
	INC	HL		;PROPAGATE BIT
	DEC	C		;DECREMENT EXPONENT
	JP	FINT4		;AND CONTINUE
;PREPARE FRACTIONAL PART FOR STORAGE
FINT5:	LD	A,H		;GET M0'
	AND	127		;KILL B23
	LD	H,A		;(SIGN)
	LD	A,(FINSN)	;GET SIGN OF INPUT
	OR	H		;AND MOVE TO B23
	LD	H,L		;SWAP FOR
	LD	L,A		;SHLD LATER
	LD	A,C		;GET EXPONENT
	ADD	A,80H		;AND BIAS UP
;STORE FRACIONAL PART FOR RE-LOAD
FINT6:	LD	(FINFP),A	;STORE EXP
	LD	(FINFP+1),HL	;STORE M0',M1'
	LD	A,B		;GET M2'
	LD	(FINFP+3),A	;AND STORE
;TRANSFER SIGN TO INTEGER
	LD	A,(FINSN)	;GET SIGN
	RLCA
	JP	NC,FINT7	;POSITIVE
	LD	A,D		;NEGATE
	CPL			;INTEGER
	LD	D,A		; BY
	LD	A,E		;  COMPLEMENTING
	CPL			;   AND
	LD	E,A		;    ADDING
	INC	DE		;     ONE
FINT7:	PUSH	DE		;SAVE INTEGER
	LD	HL,FINFP	;RE-LOAD
	CALL	FLOAD		;FRACTION TO FAC
	POP	HL		;RESTORE INTEGER
	RET			;AND EXIT


;FSQR - 8080 FLOATING POINT SQUARE ROOT
;METHOD:	APPROXIMATION FOLLOWED BY THREE
;		NEWTON ITERATIONS
;
; SQUARE ROOT (X)
;
;LET X=2^(2B)*F WHEN .25<=F<1
;THEN SQR(X)=2^B*SQR(F)
;WHERE SQR(F)=P(I)   I=NUMBER OF ITERATION
;
; P(1)=A*F+B   AS A FIRST APPROXIMATION
;   WHERE A=.875, B=.27863 WHEN .25<=F<.5
;    OR
;	   A=.578125, B=.421875 WHEN .5<=F<1
;AND THEN
;	P(I+1)=(P(I)+F/P(I))/2
;  AND P(4) IS FINAL RESULT FOR SQR(F)
;
;CALLING SEQUENCE WITH 8008/8080 MATH PACKAGE
;	CALL	FSQR		;SQR(FPAC) -> FPAC
;
;NEGATIVE INPUTS WILL BE TREATED AS POSITIVE AFTER CALLING FCERN
FSQR:	CALL	FTEST		;RESTORE
	RET	Z		;ZERO
	CALL	M,FCERN		;NEGATIVE ERROR
	CALL	M,FABS		;SET FLAG AND USE ABS VALUE
	LD	HL,FPTXX	;AND SAVE
	CALL	FSTOR		;X
	LD	E,80H		;CALCULATE
	RRCA			;EXPONENT
	JP	NC,$+4		; FOR
	DEC	E		;  F
	LD	A,E		;AND
	LD	HL,FPTF		;STORE
	CALL	FSTOR		; F
	RRCA			;DECIDE
	LD	HL,FPTA1
	JP	NC,$+6		;WHICH
	LD	HL,FPTA2	; A AND B
	PUSH	HL		;    TO USE
	CALL	FLOAD		; AND FETCH A
	LD	HL,FPTF		;CALCULATE
	CALL	FMUL		;AF
	POP	HL		; AND
	INC	HL		;  THEN
	INC	HL		;   GET
	INC	HL		;    B
	INC	HL
	CALL	FADD		;AF+B
	LD	HL,FPTP		;AND
	PUSH	HL
	CALL	FSTOR		; SAVE P1
	CALL	NEWTN		;THREE
	CALL	NEWTN		;NEWTON
	CALL	NEWTN		; ITERATIONS
	LD	H,A		;SAVE RESULT EXPONENT
	LD	A,(FPTXX)	;CALCULATE
	SUB	127		;EXPONENT
	RRA			; FOR
	ADD	A,H		;  RESULT
	POP	HL
	LD	(HL),A		;AND SET IT
	JP	FLOAD		;LOAD RESULT

NEWTN:	LD	HL,FPTF	;GET
	CALL	FLOAD		;F
	LD	HL,FPTP
	PUSH	HL
	CALL	FDIV		;F/P
	POP	HL
	PUSH	HL
	CALL	FADD		;F/P+P
	DEC	A		;(F/P+P)/2
	POP	HL		;AND
	JP	FSTOR		; SAVE P(I+1)


FPTA1:	DEFB	80H,60H,0,0;.875
	DEFB	7FH,0EH,0A8H,98H;.27863

FPTA2:	DEFB	80H,14H,0,0;.578125
	DEFB	7FH,58H,0,0	;.421875


;********* END - FSQR *********


;8080 FLOATING POINT EXPONENTIAL - FEXP
;	CALL	FEXP		;E^(FAC) -> FAC
;
; **** INTERNAL OVER/UNDERFLOW WILL OCCUR FOR INPUT
;	VALUES GREATER THAN LN(2^127)/(LOGBASE2(E)).
;	OR APPROXIMATELY
;	      -61 < VALUE < 61
;
; IF OVERFLOW OCCURS THEN 'ERROR' WILL BE CALLED AND
; FAC WILL BE SET TO FULL SCALE VALUE.
;
;METHOD:
; POLYNOMIAL APPROXIMATION
;TO FIND E^X THE FOLLOWING IDENTITY IS USED.
;TO REDUCE THE RANGE, WE LET
;	X LOG2 E = N + D + Z
;WHERE ...
;	N IS THE INTEGRAL PORTION OF THE REAL NUMBER,
;	D IS A DISCRETE FRACTION (1/8, 3/8, 5/8, OR
;	  7/8) OF THE REAL NUMBER (FRAC PART), AND
;	Z IS THE REMAINDER WHICH IS IN THE RANGE
;	  -1/8 <= Z <= 1/8
; THUS,
;		E^X = 2^N * 2^D * 2^Z
;AND IT IS NECCESSARY TO ONLY APPROXIMATE 2^Z FOR
;-1/8 <= Z <= 1/8 BY USING THE POLYNOMIAL F(Z).
;
; F(Z) = A0 + A1*Z + A2*Z^2 + A3*Z^3 + A4*Z^4 +
;				A5*Z^5
;WHERE ...
;	A0 = 1.0
;	A1 = .69314718057
;	A2 = .24022648580
;	A3 = .055504105406
;	A4 = .0096217398747
;	A5 = .0013337729375
;
FEXP:	CALL	FTEST		;SET ABCD TO FAC
	LD	A,B		;GET SIGN
	LD	(FPSGN),A	;AND SAVE
	CALL	FABS		;TAKE ABS VALUE
	LD	HL,LOG2E	;X=X*LOG2(E)
	CALL	FMUL
	CALL	FINT		;INTEGER TO HL, FRAC IN FAC
	PUSH	HL		;SAVE INTEGER
	LD	HL,FPTX		;AND
	CALL	FSTOR		; FRACTION
	POP	HL		;RESTORE INTEGER
	LD	A,H		;TO CHECK RANGE
	AND	A
	JP	Z,FEXP1		;CAN'T BE > 256

FEXP0:	LD	A,(FPSGN);NUMBER TOO LARGE
	RLCA			;SO RETURN
	JP	C,FZRO		; 0 OR FULL SCALE
	JP	FOVER		;NONFATAL OV ERROR, TAKE MAX AND RETURN
FEXP1:	LD	A,L		;CHECK N
	CP	127		;LARGEST THAT WILL FIT
	JP	NC,FEXP0	;E^88 = 1.7 E+38
	LD	(FPTN),A	;SAVE INT PART N
;SELECT VALUE FOR 'D'
	LD	A,(FPTX)	;GET EXPONENT OF FRAC
	LD	DE,4
	LD	HL,FPTDF
	CP	127
	JP	C,FEXP5		;FRAC < .25
	ADD	HL,DE		;FPTDF+4 TO HL
	JP	Z,FEXP5		;.25 <= FRAC < .5
	ADD	HL,DE		;FPTDF+8 TO HL
	LD	A,(FPTX+1)	;GET M0
	RLCA			;SHIFT B6
	RLCA			;TO CARRY
	JP	NC,FEXP5	;.5 <= FRAC < .75
	ADD	HL,DE		;.75 <= FRAC < 1, FPTDF+12 TO HL
FEXP5:	PUSH	HL		;HL POINTS TO SELECTED D
	LD	HL,FPTX		;X TO FAC
	CALL	FLOAD
	POP	HL		;ADDRESS OF D
	PUSH	HL		;SAVED AGAIN
	CALL	FSUB		;CALCULATE Z
	LD	E,A		;AND
	LD	A,(FPSGN)	; TRANSFER
	RLCA			;  SIGN
	LD	A,E		;   TO Z
	CALL	C,FCHS
	LD	HL,FPTZ0	;SAVE Z
	PUSH	HL		;PUSH FOR FPOLY
	CALL	FSTOR		; IN
	LD	HL,FPTZ1	;  POLY
	CALL	FSTOR		;   TABLE
	LD	HL,FPONE	;GET TERM
	CALL	FLOAD		;A0 = 1.0
	LD	HL,EXPLY	; AND DO THE
	CALL	FPOLY		;  POLYNOMIAL F(Z)
	POP	HL		;SELECT
	LD	DE,16		;SIGNED
	EX	DE,HL		; VALUE
	LD	A,(FPSGN)	;  FOR
	RLCA			;   2^D
	JP	NC,$+4
	ADD	HL,HL		;2^-D TABLE
	ADD	HL,DE		;HL HAS ADDRESS
	PUSH	HL		;OF 2^D
	CALL	FTEST		;RESTORE
	POP	HL		;AND CALCULATE
	CALL	FMUL		;2^D * F(Z)
;NOW MULTIPLY BY 2^N
	LD	E,A		;SAVE EXP
	LD	A,(FPSGN)	;AND
	RLCA			;TRANSFER
	LD	A,(FPTN)	;SIGN
	JP	NC,$+5		; TO N
	CPL
	INC	A		;NEGATE N
	ADD	A,E		;RESULT = 2^N * 2^D * F(Z)
	LD	HL,FPTZ1	;STORE TEMP
	PUSH	HL
	CALL	FSTOR		;FOR RELOAD
	POP	HL		; TO
	JP	FLOAD		;  EXIT WITH FAC = E^X


;D TEST VALUES AND 2^D TABLES
FPTDF:	DEFW	7EH,0		;.125
	DEFW	407FH,0		;.375
	DEFW	2080H,0		;.625
	DEFW	6080H,0		;.875

;2^D FOR PLUS D VALUES
	DEFW	0B81H,0C295H	;2^(1/8)
	DEFW	2581H,0D7FEH	;2^(3/8)
	DEFW	4581H,2A67H	;2^(5/8)
	DEFW	6A81H,0C7C0H	;2^(7/8)

;2^D FOR MINUS D VALUES
	DEFW	6A80H,0C7C0H	;2^(-1/8)
	DEFW	4580H,2A67H	;2^(-3/8)
	DEFW	2580H,0D7FEH	;2^(-5/8)
	DEFW	0B80H,0C295H	;2^(-7/8)

;MISC. CONSTANTS
LOG2E:	DEFW	3881H,3BAAH	;LOG2(E) 1.442695041
FPMAX:	DEFW	7FFFH,-1	;POS FULL SCALE


EXPLY:	DEFB	-1	;POLY TABLE

	DEFW	3180H,1872H	;A1 .69314718057
	DEFW	757EH,0EFFDH	;A2 .24022648580
	DEFW	637CH,4658H	;A3 .055504105406
	DEFW	1D7AH,81A4H	;A4 .0096217398747
	DEFW	2E77H,0FED1H	;A5 .0013337729375

	DEFB	0		;TABLE TERMINATOR

;****** END - FEXP ******


;8080 FLOATING POINT NATURAL LOGARITHM - FLN
;  THIS ROUTINE CALCULATES THE NATURAL LOGARITHM
;OF THE NUMBER IN THE FLOATING POINT ACCUMULATOR.
;
;	LN(FAC) -> FAC
;
;METHOD - POLYNOMIAL APPROXIMATION
;
; GIVEN A NORMALISED REAL NUMBER
;	X = 2^K * F
;WHERE THE RANGE OF F IS .5 <= F < 1, AND J AND G
;ARE FOUND SUCH THAT X = 2^J * G WHERE
;(SQR(2)/2) <= G < SQR(2).  THIS IS DONE BY SETTING
;J=K-1, G=2*F IF F < SQR(2)/2 AND J=K, G=F OTHER-
;WISE.
;
; THUS:
;	LN(X) = J * LN(2) + LN(G)
;
;   THE APPROXIMATION FOR LN(G), WHERE
;SQR(2)/2 <= G < SQR(2), IS BASED ON THE SERIES
; LN((V+X)/(V-X) = 2((X/V) + (X^3/(3*V^3)) +
;			(X^5/(5*V^5)) + ... )
;WHICH CONVERGES FOR (-V<X<V).
;
;   WITH THE TRANSFORMATION
;     X = V((G-1)/(G+1)), V = (SQR(2)+1)^2
;SO THAT -1 <= X < 1 FOR SQR(2)/2  <= G < SQR(2).
;
; SUBSTITUTING
;	LN(G) = 2(Z + Z^3/3 + Z^5/5 + ... )
; WHERE  Z = X/V = (G-1)/G+1).
;
;  THE APPROXIMATION USED IS G(Z) FOR LN(G)/Z IN
;THE RANGE SQR(2)/2 <= G < SQR(2).
; THUS THE REQUIRED CALCULATION IS
;	LN(X) = J * LN(2) + Z * G(Z)
;  G(Z) = B0 + B2*Z^2 + B4*Z^4 + B6*Z^6 + B8*Z^8
;WHERE
;	B0 = 2.0
;	B2 = .666666564181
;	B4 = .400018840613
;	B6 = .28453572660
;	B8 = .125

FLN:	CALL	FTEST		;RESTORE
	CALL	M,FCERN
	JP	Z,FCERN		;FC ERROR AND RETURN IF ZERO
	CALL	M,FABS		;MAKE INPUT POSITIVE AFTER ERROR
	LD	(FLNK),A	;SAVE EXPONENT
	LD	A,80H		;SAVE
	LD	HL,FLNF		;FRACTIONAL
	PUSH	HL
	CALL	FSTOR		; PART
	POP	HL		;RELOAD
	PUSH	HL		; AND RESAVE
	CALL	FLOAD		;  TO FACC
	LD	HL,FLNR2	;CHECK RANGE
	CALL	FSUB		;NEG IF F < SQR(2)/2
	POP	HL		;POINT TO F
	JP	P,FLNA		;JMP IF F >= SQR(2)/2
	DEC	HL		;POINT TO K
	DEC	(HL)		;J = K-1
	INC	HL		;BACK TO F
	INC	(HL)		;G = 2 * F
FLNA:	CALL	FLOAD		;GET G
	LD	HL,FPONE	;GET 1.0
	CALL	FADD		;G+1
	LD	HL,FLNZI	;AND
	PUSH	HL
	CALL	FSTOR		; SAVE
	LD	HL,FLNM2	;GET -2.0
	CALL	FADD		;G-1
	POP	HL
	PUSH	HL
	CALL	FDIV		;(G-1)/(G+1)
	LD	HL,FLNF		;SAVE
	PUSH	HL
	CALL	FSTOR		;Z
	POP	HL
	CALL	FMUL		;Z^2
	POP	HL
	PUSH	HL		;SAVE FOR FPOLY
	CALL	FSTOR		;SAVE
	LD	HL,FLNZ2	;SAVE
	CALL	FSTOR		;TERM POWER
	CALL	FZRO		;CLEAR SUM
	LD	HL,FLNPL	;AND
	CALL	FPOLY		; CALC POLYNOMIAL
	LD	HL,FLNM2	;ADD
	CALL	FSUB		;2.0
	LD	HL,FLNF		;AND
	PUSH	HL
	CALL	FMUL		;Z*G(Z)
	POP	HL
	PUSH	HL
	CALL	FSTOR		;Z*G(Z)
;FLOAT J, CALCULATE J * LN(2)
	LD	A,(FLNK)	;GET J
	SUB	80H		;UN-BIAS EXP
	LD	E,32		;SET INTEGER SCALING
	LD	D,A		;INTEGER TO I3
	LD	BC,-1		;INTEGER
	LD	A,-1		;NEGATIVE
	JP	M,$+5		;GO FLOAT
	INC	BC		;INTEGER
	INC	A		;NEGATIVE
	CALL	FFLOT		;FLOAT J
	LD	HL,FLNL2
	CALL	FMUL		;J*LN(2)
	POP	HL
	JP	FADD		;Z*G(Z)


FLNR2:	DEFW	3580H,0F304H;SQR(2)/2
FLNL2:	DEFW	3180H,1872H	;LN(2)
FLNM2:	DEFW	8082H,0		;-2.0

FLNPL:	DEFB	16	;SIG INDEX STOPPER
	DEFW	2A80H,0A9AAH	;B2 .666666564181
	DEFW	4C7FH,45CFH	;B4 .400018840613
	DEFW	117FH,0ABAEH	;B6 .28453572660
	DEFW	7EH,0		;B8 .125

	DEFB	0		;TERMINATOR

;******* END - FLN ******


;8080 FLOATING POINT SIN/COS ROUTINE - FSIN, FCOS
;  THIS ROUTINE WILL CALCULATE THE SINE OR COSINE
;OF THE ANGLE IN THE FLOATING POINT ACCUMULATOR.
;
;  THE ANGLE MUST BE IN RADIANS AND MAY HAVE ANY
;MAGNITUDE.
;
;	SIN(FAC) -> FAC
;	COS(FAC) -> FAC
;
;METHOD:
;	POLYNOMIAL APPROXIMATION
;
;   GIVEN A REAL NUMBER, X, N, AND Y ARE DEFINED
;SUCH THAT
;	X/(2*PI) = N + Y
;WHERE N IS AN INTEGER AND 0 <= Y < 1.
;THUS, X = 2*PI*N + 2*PI*Y, AND THE IDENTITIES ARE
;  SIN(X) = SIN(2*PI*Y) AND COS(X) = COS(2*PI*Y)
;
;THE POLYNOMIAL APPROXIMATION, F(Z), FOR THE
;FUNCTION SIN(2*PI*Z)/Z IS USED WHERE
;-.25 <= Z < .25.
;
;   THE PROPERTIES OF SINES AND COSINES ARE USED TO
;COMPUTE THESE FUNCTIONS AS FOLLOWS:
;
;	COS(2*PI*Y) = F(Z)
;WHERE
;	Z = .25-Y IN THE RANGE 0 <= Y < .5
;	Z = Y-.75 IN THE RANGE .5 <= Y < 1
;
;	SIN(2*PI*Y) = F(Z)
;WHERE
;	Z = Y IN THE RANGE 0 <=Y < .25
;	Z = .5-Y IN THE RANGE .25 <= Y < .75
;	Z = Y-1 IN THE RANGE .75 <= Y < 1
;
; F(Z) = A1*Z + A2*Z^3 + A3*Z^5 + A4*Z^7 + A5*Z^9
;WHERE
;	A1 = 6.2831853
;	A2 = -41.341681
;	A3 = 81.602481
;	A4 = -76.581285
;	A5 = 39.760722

FSIN:	DEFB	3EH		;(MVI A,0AFH) FN CODE FOR SIN
FCOS:	XOR	A		;0 FN CODE FOR COS
	LD	(FSCFX),A	;SAVE FUNCTION CODE
	CALL	FTEST		;RESTORE
	LD	A,B		;GET M0
	AND	80H		;STRIP OFF
	LD	(FSCSG),A	; AND SAVE
	CALL	FABS		;GET ABS(FAC)
	LD	HL,F2PI
	CALL	FDIV		;X/(2*PI)
	CP	129
	CALL	NC,FINT		;Y >= 1, GET FRACTIONAL PART
	LD	E,A		;SAVE EXPONENT
	LD	A,(FSCFX)	;CHECK
	RLCA			;FUNCTION CODE
	LD	A,E		;RESTORE EXPONENT
	JP	C,FSC3		;FUNCTION IS SIN
	CP	80H
	JP	C,FSC2		;Y < .5
	LD	HL,FSC75	;Y - .75
	JP	FSC6
FSC2:	CALL	FCHS		;-Y
	LD	HL,FSC25	;.25-Y
	JP	FSC4A
FSC3:	CP	127		;Y < .25 ?
	JP	C,FSC7		;YES, GO DO POLY
	CP	80H
	JP	C,FSC4		;Y < .5
	LD	E,A		;SAVE EXP
	LD	A,B		;CHECK
	RLCA			;B22
	RLCA			; FOR
	LD	A,E		;  .75, RESTORE EXPONENT
	JP	C,FSC5		;Y >= .75
FSC4:	CALL	FCHS		;Y < .75 SO -Y
	LD	HL,FSC50
FSC4A:	CALL	FADD		;.5-Y
	JP	FSC7
FSC5:	LD	HL,FPONE
FSC6:	CALL	FSUB		;Y-1
FSC7:	LD	HL,FSCZ		;SAVE
	PUSH	HL
	CALL	FSTOR		;Z
	POP	HL
	PUSH	HL		;SAVE FOR FPOLY
	CALL	FMUL		;Z^2
	LD	HL,FSCZ2
	CALL	FSTOR		;SAVE Z^2
	CALL	FZRO		;ZERO SUM
	LD	HL,FSCPL	;AND
	CALL	FPOLY		; DO POLY
	LD	E,A		;SAVE EXP
	LD	A,(FSCFX)	;AND CHECK
	RLCA			; FUNCTION
	LD	A,E		;RESTORE EXPONENT
	RET	NC		;AND EXIT IF COS FUNCTION
	LD	A,(FSCSG)	;GET INPUT SIGN
FSC8:	RLCA			;TO CY -- FATN ENTRY POINT
	LD	A,E		;RESTORE EXPONENT
	RET	NC		;RETURN IF INPUT +
	JP	FCHS		;ELSE CHANGE RESULT SIGN


FPI:	DEFW	4982H,0DB0FH;PI
FHPI:	DEFW	4981H,0DB0FH	;PI/2
FSC75:	DEFW	4080H,0		;.75
FSC25:	DEFW	7FH,0		;.25
FSC50:	DEFW	80H,0		;.5

FSCPL:	DEFB	16	;SIN/COS POLY SIG STOPPER
F2PI:	DEFW	4983H,0DB0FH	;A1 PI*2
	DEFW	0A586H,0E25DH	;A2 -41.341681
	DEFW	2387H,7834H	;A3 81.602481
	DEFW	9987H,9E29H	;A4 -76.581285
	DEFW	1F86H,0FB0AH	;A5 39.760722
	DEFB	0		;TERMINATOR


;****** END - FSIN/FCOS ******


;8080 FLOATING POINT REAL BASE TO REAL EXPONENT
;		FAX
;  THIS ROUTINE RAISES A REAL NUMBER TO A REAL POWER.
;	***** NOTE *****
;  BECAUSE OF OVERFLOW CONDITIONS IN THE ROUTINE
;FLN, THE FOLLOWING LIMITS ARE PLACED ON THE
;INPUTS TO FAX:
;
;	A > 0
;AND
;	ABS(X*LN(A)) < 50.0
;
;CALLING SEQUENCE ...
;	LXI H,X		;ADDRESS OF X
;	CALL FAX	;FAC ^ X  ->  FAC
;
;METHOD
;If X is a positive integer < 256, iterated multiplication is used.
;Otherwise the identity  A^X = E^(X*LN(A)) is used.

FATOX:	EX	DE,HL
	INC	HL		;ARG2 POINTER TO HL
FAX:	PUSH	HL
	CALL	FTEST		;load registers
	LD	HL,FTMPA
	CALL	FSTOR		;save A in FTMPA
	POP	HL
	PUSH	HL
	CALL	FLOAD		;get X to FACC
	CALL	FINT		;check if X is integer
	PUSH	AF
	PUSH	HL		;save integer part
	LD	HL,FTMPA
	CALL	FLOAD		;restore A to FACC
	POP	DE		;integer part to DE
	POP	AF
	POP	HL		;X pointer to HL
	OR	D		;Zero set iff A positive integer < 256
	JP	NZ,FAX2		;raise to real power
	INC	E
	PUSH	DE		;save the integer power+1
	LD	HL,FPONE	;initialize result to 1.0
	CALL	FLOAD
FAX1:	POP	DE
	DEC	E		;decrement multiply count
	JP	Z,FTEST		;done, set registers and return
	PUSH	DE
	LD	HL,FTMPA
	CALL	FMUL		;multiply result by A
	JP	FAX1		;and continue multiplying
FAX2:	PUSH	HL		;raising to real, large or negative power
	CALL	FLN		;LN(A)
	POP	HL
	CALL	FMUL		;X*LN(A)
	JP	FEXP		;E^(X*LN(A))


	IF	FALSE
;8080 FLOATING POINT COMMON LOGARITHM - FLOG
;  THIS ROUTINE CALCULATES THE COMMON OR BASE 10
;LOGARITHM OF THE NUMBER IN THE FLOATING POINT
;ACCUMULATOR.
;
;	LOG(FAC) -> FAC
;
;METHOD
;	 THE FOLLOWING IDENTITY IS USED.
;
;	LOG(X) = LN(X)/LN(10)

FLOG:	CALL	FLN		;LN(ABS(X))
	LD	HL,FLGTI	;1/LN(10)
	JP	FMUL		;LN(X)/LN(10)


;8080 FLOATING POINT ANTILOG - FALOG
;
; THIS ROUTINE CALCULATES THE BASE 10 ANTILOG OF
;THE NUMBER IN THE FLOATING POINT ACCUMULATOR.
;
;	ALOG(FAC) -> FAC
;
;METHOD
;	 THE FOLLOWING IDENTITY IS USED
;	10^X = E^(X*LN(10))

FALOG:	CALL	FTEST	;RESTORE
	LD	HL,FLOGT	;LN(10)
	CALL	FMUL		;X*LN(10)
	JP	FEXP		;E^(X*LN(10))


;8080 DEGREE>RADIAN AND RADIAN>DEGREE - FCDR, FCRD
; THESE ROUTINES CONVERT THE NUMBER IN THE FLOATING
;POINT ACCUMULATOR FROM DEGREES TO RADIANS (FCDR)
;OR FROM RADIANS TO DEGREES (FCRD).
;
;	FAC;DEGREES -> FAC;RADIANS
;	FAC;RADIANS -> FAC;DEGREES
;
;METHOD
;	 THE FOLLOWING IDENTITIES ARE USED.
;
;	X;RADIANS = X;DEGREES * PI/180
;	X;DEGREES = X;RADIANS * 180/PI

FCDR:	CALL	FTEST		;RESTORE
	LD	HL,FXDR
	JP	FMUL		;X*PI/180

FCRD:	CALL	FTEST		;RESTORE
	LD	HL,FXRD
	JP	FMUL		;X*180/PI

	ENDIF

;8080 FLOATING POINT TANGENT - FTAN
;   THIS ROUTINE CALCULATES THE TANGENT OF THE ANGLE
;IN THE FLOATING POINT ACCUMULATOR.
;   THE ANGLE MUST BE EXPRESSED IN RADIANS.
;
;	TAN(FAC) -> FAC
;
;METHOD
;	 THE FOLLOWING IDENTITY IS USED.
;
;	TAN(X) = SIN(X)/COS(X)
;
;	***** NOTE *****
; FOR VALUES OF X CLOSE TO 0 OR CLOSE TO A MULTIPLE
;OF 2*PI, EITHER THE SIN OR COS OF X WILL BE CLOSE
;TO UNITY.  THIS CONDITION WILL AFFECT THE ACCURACY
;USING THE IDENTITY ABOVE AND IT IS SUGGESTED
;THAT OTHER METHODS BE USED TO COMPUTE THE FUNCTION
;TAN(X) IF THIS INACCURACY CAN NOT BE TOLERATED.

FTAN:	CALL	FTEST		;RESTORE
	RET	Z
	LD	HL,FTMPA
	PUSH	HL
	CALL	FSTOR		;SAVE X
	CALL	FCOS		;COS(X)
	LD	HL,FTMPB
	CALL	FSTOR		;SAVE COS(X)
	POP	HL
	CALL	FLOAD		;GET X
	CALL	FSIN		;SIN(X)
	LD	HL,FTMPB
	JP	FDIV		;SIN(X)/COS(X)


	IF	FALSE
FLGTI:	DEFW	5E7FH,0D95BH	;1/LN(10)
FLOGT:	DEFW	1382H,8E5DH	;LN(10)

FXDR:	DEFW	0E7BH,35FAH	;PI/180
FXRD:	DEFW	6586H,0E12EH	;180/PI
	ENDIF


;****** END -FAX, FLOG, FALOG, FCDR, FCRD, FTAN *****


	IF	NOT CAMAC
;8080 FLOATING POINT ARCTANGENT - FATAN
;   THIS ROUTINE CALCULATES THE ARCTANGENT OF THE
;NUMBER IN THE FLOATING POINT ACCUMULATOR.
;
;	ATAN(FAC) -> FAC
;
;METHOD
;	 POLYNOMIAL APPROXIMATION
;
;   THIS ROUTINE IS BUILT AROUND A POLYNOMIAL, F(X),
;THAT APPROXIMATES ATAN(Z) IN THE RANGE
;-.25 <= Z <= .25.  THE ATAN(Z) FOR VALUES OF Z
;OUTSIDE THIS RANGE IS FOUND BY USING THE FOLLOWING
;IDENTITIES:
;	      ATAN(-Z) = -ATAN(Z)
;AND
;	ATAN(Z) = A(K) + ATAN((Z-B(K))/(Z*B(K)+1))
;WHERE
;	A(K) = K*PI/7, B(K) = TAN(A(K))
;AND K IS DETERMINED SO THAT
;TAN((2*K-1)*PI/14) <= ABS(Z) <= TAN((2*K+1)*PI/14)
;WITH K = 1, 2, OR 3.
;
;  HAVING DETERMINED THE VALUE OF K APPROPRIATE
;TO Z, THE TRANSFORMATION
;	X = (Z-B(K))/(Z*B(K)+1)
;PUTS X IN THE RANGE -TAN(PI/14) < X < TAN(PI/14).
;THE POLYNOMIAL WORKS OVER A SLIGHTLY LARGER RANGE
;TO ALLOW DETERMINATION OF K USING THE VALUES
;	K=0  IF ABS(Z) < .25
;	K=1  IF .25 < ABS(Z) < .75
;	K=2  IF .75 < ABS(Z) < 2
;	K=3  IF ABS(Z) > 2
;THEN
;	ATAN(Z) = A(K) + F(X)   IF Z >= 0
;	ATAN(Z) = -A(K) - F(X)  IF Z < 0
;F(X) = X*(1 - Q1*X^2 + Q2*X^4 - Q3*X^6)
;WHERE
;	Q1 = .333329573
;	Q2 = .199641035
;	Q3 = .131779888

FATAN:	CALL	FTEST	;RESTORE
	RET	Z
	LD	E,A		;SAVE EXPONENT
	LD	A,B		;GET M0
	AND	80H		;ISOLATE SIGN, B23
	LD	(FATSG),A	;AND SAVE
	CALL	FABS
	LD	E,A		;SAVE EXP
	LD	HL,FATK
	LD	(HL),0		;K=0
	CP	127
	JP	Z,FAT4		;.25 <= Z < .5, SO K=1
	JP	C,FAT7		;Z < .25, SO K=0 AND DO F(X), X=Z
	LD	(HL),2
	CP	129
	JP	Z,FAT6		;.75 <= Z < 1, K=2
	JP	NC,FAT4		;Z > 2, K=3
	LD	A,B
	RLCA
	RLCA			;CHECK 1/4 BIT
	DEC	(HL)
	JP	NC,FAT6		;.5 <= Z <.75, K=1
FAT4:	INC	(HL)
FAT6:	LD	A,(HL)		;FETCH K
	PUSH	AF		;SAVE K
	LD	A,E		;GET EXPONENT
	LD	HL,FATZX	;SAVE
	CALL	FSTOR		;Z
	POP	AF		;GET K
	DEC	A		;K-1
	ADD	A,A		;(K-1)*2
	ADD	A,A		;(K-1)*4
	ADD	A,A		;(K-1)*8
	LD	HL,FATC1	;START OF TABLE
	LD	E,A		;CALCULATE
	LD	D,0		;ADDRESS
	ADD	HL,DE		; OF A(K)
	PUSH	HL		;AND SAVE IT
	LD	DE,4
	ADD	HL,DE		;ADDRESS OF B(K)
	PUSH	HL		;SAVED ALSO
	CALL	FLOAD		;GET B(K)
	LD	HL,FATZX
	PUSH	HL
	CALL	FMUL		;Z*B(K)
	LD	HL,FPONE
	CALL	FADD		;Z*B(K)+1
	LD	HL,FATXM
	CALL	FSTOR		;SAVE Z*B(K)+1
	POP	HL
	CALL	FLOAD		;GET Z
	POP	HL		;ADDRESS OF B(K)
	CALL	FSUB		;Z-B(K)
	LD	HL,FATXM
	CALL	FDIV		;(Z-B(K))/(Z*B(K)+1)
FAT7:	LD	HL,FATZX
	PUSH	HL
	CALL	FSTOR		;SAVE X
	POP	HL
	CALL	FMUL		;X^2
	LD	HL,FATXM
	PUSH	HL		;SAVE FOR FPOLY
	CALL	FSTOR		;SAVE INITIAL POWER
	LD	HL,FATX2	;SAVE TERM POWER MULTIPLIER
	CALL	FSTOR
	LD	HL,FPONE
	CALL	FLOAD		;INITIALISE SUM
	LD	HL,FATPL
	CALL	FPOLY		;F(X)
	LD	HL,FATZX
	CALL	FMUL		;X*F(X)
	LD	E,A		;SAVE EXPONENT
	LD	A,(FATK)	;GET K
	AND	A		;SEE IF 0
	LD	A,E		;RESTORE EXPONENT
	JP	Z,FAT8		;K=0, NO A(K)
	POP	HL		;ADDRESS OF A(K)
	CALL	FADD		;A(K)+F(X)
FAT8:	LD	E,A		;SAVE EXP
	LD	A,(FATSG)	;GET INPUT SIGN
	JP	FSC8		;EXIT AS FOR SIN AND COS

FATC1:	DEFW	657FH,0FAC8H;A(1) PI/7 .4487989506
	DEFW	767FH,0F390H	;B(1) TAN(A(1)) .4815746188
	DEFW	6580H,0FAC8H	;A(2) 2*PI/7 .8975979011
	DEFW	2081H,0C681H	;B(2) TAN(A(2)) 1.253960337
	DEFW	2C81H,0BB56H	;A(3) 3*PI/7 1.346396852
	DEFW	0C83H,7F33H	;B(3) TAN(A(3)) 4.381286272

FATPL:	DEFB	-1	;ATAN POLY TABLE
	DEFW	0AA7FH,2DAAH	;Q1  -.333329573
	DEFW	4C7EH,0B36EH	;Q2  .199641035
	DEFW	867EH,4FF1H	;Q3  -.131779888
	DEFB	0		;TERMINATOR


;****** END - FATAN ******
	ENDIF			;end of NOT CAMAC contditional


	IF	FALSE
;8080 FLOATING POINT INVERSE SIN/COS - FASIN, FACOS
;   THESE ROUTINES CALCULATE THE INVERSE
;SINE AND COSINE OF A NUMBER IN THE FLOATING
;POINT ACCUMULATOR.
;   THE RESULTANT ANGLE IS IN RADIANS.
;
;	ASIN(FAC) -> FAC
;	ACOS(FAC) -> FAC
;
;METHOD
;	  THE FOLLOWING IDENTITIES ARE USED
;
;	ASIN(X) = ATAN(X/SQR(1-X^2))
;	ACOS(X) = ATAN(SQR(1-X^2)/X)
;AND
;	ASIN(-X) = -ASIN(X)
;	ACOS(-X) = ACOS(X) + PI

FASIN:	CALL	FTEST	;RESTORE
	CP	129
	JP	C,FAS4		;ABS(X) < 1
	JP	Z,FAS1		;ABS(X) MAY = 1

FAS0:	CALL	FTEST
	JP	FCERN
FAS1:	LD	E,A		;SAVE EXP
	LD	A,B		;CHECK
	AND	127		;FOR
	JP	Z,FAS3		; UNITY
FAS2:	LD	A,E		;RESTORE EXP
	JP	FAS0		;ERROR ABS(X) > 1
FAS3:	ADD	A,C
	JP	NZ,FAS2		;> 1
	ADD	A,D		;CHECK M3
	JP	NZ,FAS2		;> 1
	LD	A,B		;X = +- 1
FSETP:	PUSH	AF		;SAVE SIGN
	LD	HL,FHPI
	CALL	FLOAD		;GET PI/2
	LD	E,A		;SAVE EXP
	POP	AF		;GET SIGN
	JP	FSC8		;EXIT AS FOR SIN AND COS

FAS4:	CALL	FR1X2		;SQR(1-X^2)
	LD	HL,FASCT
	CALL	FSTOR		;SAVE
	LD	HL,FASCX
	CALL	FLOAD		;GET X
	LD	HL,FASCT
	CALL	FDIV		;X/SQR(1-X^2)
	JP	FATAN		;ATAN(X/SQR(1-X^2))


FACOS:	CALL	FTEST	;RESTORE
	AND	A		;SET FLAGS
	JP	Z,FSETP		;X=0, SET PI/2
	CP	129
	JP	C,FAC1		;ABS(X) < 1 CONTINUE
	LD	E,A		;SAVE EXP
FAC0:	LD	A,E		;RESTORE EXPONENT
	SCF			;SET ERROR FLAG
	JP	NZ,FCERN	;AND RET IF ABS(X) > 1
	LD	A,B		;CHECK
	AND	127		;FOR
	JP	NZ,FAC0		; X
	ADD	A,C		;  =
	JP	NZ,FAC0		;   1
	ADD	A,D
	JP	NZ,FAC0		;> 1
	JP	FZRO		;X=1 SO RETURN 0
FAC1:	CALL	FR1X2		;SQR(1-X^2)
	LD	HL,FASCX
	CALL	FDIV		;SQR(1-X^2)/X
	CALL	FATAN		;ATAN(SQR(-1X^2))
	RET	P		;LEAVE IF +
	LD	HL,FPI
	JP	FADD		;ADD PI

;ROUTINE TO CALCULATE SQR(1-X^2)

FR1X2:	LD	HL,FASCX
	CALL	FSTOR		;SAVE X
	LD	HL,FASCX
	CALL	FMUL		;X^2
	CALL	FCHS		;-X^2
	LD	HL,FPONE
	CALL	FADD		;1-X^2
	JP	FSQR		;SQR(1-X^2)


;****** END - FASIN, FACOS ******
	ENDIF


	ENDIF			;end of FLOAT conditional

;****** END - XMATH PACKAGE ******

;end of XMATH
	PAGE
;RAM 05/20/81
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
;RAM storage for non-ROM versions

	IF	NOT ROM
; $-MACRO:;suppress DZ macro expansion on printouts

PATCH:	DZ	30	;patch area

	IF	ASM80
	DSEG			;relocatable data segment
	ENDIF

RAMORG:	;first RAM storage location

;first the version-dependent RAM locations

	IF	NONST AND NOT CAMAC
IOBYT:	DZ	1		;I/O byte in first RAM location
CSTAT:	JP	JMPTA+60	;console status impure code
	IF	NOT COMPL
HEADR:	DEFB	STBYT,TYBYT, '         XYB'
	ENDIF
	ENDIF

	IF	CPM		;impure code section for console & LST i/o
CSTAT:	JP	0		;console status
CONIN:	JP	0		;console in
CNOUT:	JP	0		;console out
LOUT:	JP	0		;list out
	IF	AMD
POUT:	JP	0		;punch out
RDRIN:	JP	0		;reader in
HEADR:	DEFB	STBYT, TYBYT, '        XYB';serial SAVE/LOAD header
	ENDIF
SPTR:	DZ	2		;dump buffer pointer
	IF	SDISK
	IF	BENDX
BFILP:	DZ	1
BFBLK:	DZ	9		;Bendix SDISK file block
	ELSE			;CP/M SDISK
FILES:	DEFB	3
FILEP:	DZ	2
FILET:	DZ	2
	ENDIF
	ENDIF
	IF	DEBUG
AMODE:	DZ	1		;1 if dumping to disk, 0 otherwise
	ENDIF
	ENDIF			;end of CPM conditional

	IF	ISIS2
FNAME:	DZ	16		;file name

OPBLK:	DEFW	AFT	;open parameter block
	DEFW	FNAME		;file name address
	DZ	2		;access mode
	DZ	2		;no line editing
	DEFW	ESTAT		;error status

WRBLK:	DZ	2	;write parameter block aft
	DZ	2		;address of buffer
	DZ	2		;count
	DEFW	ESTAT		;error status

RDBLK:	DZ	2	;read parameter block aft
	DZ	2		;address
	DZ	2		;count
	DEFW	TEMP		;actual
	DEFW	ESTAT		;error status

CLBLK:	;close parameter block
AFT:	DZ	2		;aft
EXBLK:	DEFW	ESTAT		;exit parameter block

ESTAT:	DZ	2	;error status
	DEFW	ESTAT		;error status addr for error param block
TEMP2:	DZ	1		;one-byte buffer for ASCII save and load chars
	ENDIF			;end of ISIS2 conditional

;RAM locations which must have nonzero values in ROM version
	IF	NOT COMPL
DMODC:	JP	INIT		;^C branch point, changed to JMP DMOD0
	ENDIF
RPORT:	IN	A,(0)		;impure code for port reading
	RET
WPORT:	OUT	(0),A		;impure code for port writing
	RET
	IF	ROMSQ
SOURC:	DEFW	SRCAD		;source text starting address in ROMSQ version
	ENDIF
	IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)
;IMPURE MULTIPLY SUBROUTINE
MULX4:	ADD	A,0		;ADD OPERAND 3RD FRACTION
	LD	E,A		;4TH PARTIAL PRODUCT
	LD	A,D		;3RD PARTIAL PRODUCT
	ADC	A,0		;ADD OPERAND 2ND FRACTION
	LD	D,A		;3RD PARTIAL PRODUCT
	LD	A,C		;2ND PARTIAL PRODUCT
	ADC	A,0		;ADD OPERAND 1ST FRACTION
	RET			;TO ROM CODE
;IMPURE DIVIDE SUBROUTINE
DIVX5:	SUB	0		;SUBTRACT DIVISOR 4TH FRACTION
	LD	A,L		;REMAINDER 3RD FRACTION
	SBC	A,0		;SUBTRACT DIVISOR 3RD FRACTION
	LD	L,A		;REMAINDER 3RD FRACTION
	LD	A,H		;REMAINDER 2ND FRACTION
	SBC	A,0		;SUBTRACT DIVISOR 2ND FRACTION
	LD	H,A		;REMAINDER 2ND FRACTION
	LD	A,E		;REMAINDER 1ST FRACTION
	SBC	A,0		;SUBTRACT DIVISOR 1ST FRACTION
	LD	E,A		;REMAINDER 1ST FRACTION
	LD	A,0		;REMAINDER 4TH FRACTION
	RET			;TO ROM CODE
DIVX6:	ADD	A,0		;ADD DIVISOR 3RD FRACTION
	LD	L,A		;REMAINDER 3RD FRACTION
	LD	A,H		;REMAINDER 2ND FRACTION
	ADC	A,0		;ADD DIVISOR 2ND FRACTION
	LD	H,A		;REMAINDER 2ND FRACTION
	LD	A,E		;REMAINDER 1ST FRACTION
	ADC	A,0		;ADD DIVISOR 1ST FRACTION
	LD	E,A		;REMAINDER 1ST FRACTION
	LD	A,0		;REMAINDER 4TH FRACTION
	RET			;TO ROM CODE
	ENDIF

	IF	CAMAC		;impure routines for CAMAC command execution
;CSETC changes the IN or OUT ports according to the desired crate
CAMWR:	LD	A,(HL)		;write data
	OUT	(0),A
	INC	HL
	LD	A,(HL)
	OUT	(1),A
	INC	HL
	LD	A,(HL)
	OUT	(2),A
	RET
CAMFN:	LD	A,(HL)		;perform function
	OUT	(3),A
	INC	HL
	LD	A,(HL)
	OUT	(4),A
	INC	HL
	LD	A,(HL)
	OUT	(5),A
	RET
CAMRD:	IN	A,(6)		;read data
	LD	(HL),A
	INC	HL
	IN	A,(7)
	LD	(HL),A
	INC	HL
	IN	A,(8)
	LD	(HL),A
	RET
TIMEX:	DEFB	255 AND -120, 255 AND -60, 255 AND -24
	ELSE			;NOT CAMAC
	IF	REALT		;SBC 80/20 version uses real time clock
TIMEX:	DEFB	255 AND -20, 255 AND -60, 255 AND -60, 255 AND -24
	ELSE			;valiues for software real time clock
TIMEX:	DEFW	TIMEM		;TIME count for minutes, complemented
	DEFW	TIMEN		;TIME count for seconds, complemented
	DEFB	TIMEH		;TIME count for hundredths
	ENDIF
	ENDIF

COLUM:	DZ	1	;current column position on printline
WIDTH:	DEFB	255		;terminal width -- NB must follow COLUM

;locations which must be zeroed in ROM version
LNNUM:	DZ	2		;line number (address) of current line
	IF	NOT COMPL
	IF	EDITC
ERRLN:	DZ	2		;line number (address) of most recent error
	ENDIF
TRAP:	DZ	1		;trap mode -- 0 trapon, m1 trapoff
TRACE:	DZ	1		;trace mode -- 0 traceoff, m1 traceon
INLHS:	DZ	1		;m1 if getting LHS -- NB must follow TRACE
VTRAC:	DZ	1		;minus iff tracing -- NB must follow INLHS
	ENDIF
	IF	CAMAC
CMDAT:	DZ	3		;data D1, D2, D3 for read or write
CMCRA:	DZ	1		;crate C -- must follow D3
CMSLO:	DZ	1		;slot N -- must follow C
	DZ	1		;subaddress A -- must follow N
CMFNC:	DZ	1		;fn code F -- must follow A
SCRTE:	DZ	1		;serial driver crate -- must follow F
SDRVR:	DZ	1		;serial driver slot -- must follow serial crate
CAMQR:	DZ	1		;Q response
CAMXR:	DZ	3		;X, O, I responses -- must follow CAMQR
	IF	C3908
CMBLK:	DZ	7		;BKSET data
	ENDIF
CVCNT:	DZ	2		;camvar component count
CVLOC:	DZ	2		;camvar value location
XNABL:	DZ	1		;X response check enable
IMODE:	DZ	1		;interrupt mode, 0 if EI, 255 if DI
FMODE:	DZ	1
	ENDIF
	IF	NOT WILD
LMODE:	DZ	1		;LST mode
	ENDIF
	IF	PACKI
PAONL:	DZ	1		;ONLINE
	ENDIF
OMODE:	DZ	1		;output suppress mode
	IF	NOT WILD
INTTC:	DZ	1		;number of entries currently in interrupt table
INTAD:	DZ	INTTL		;interrupt table
RANDX:	DZ	2		;pseudorandom number generator seed
NULLS:	DZ	1		;number of nulls printed after crlf
	ENDIF			;end of NOT WILD conditional
GCHAR:	DZ	1		;last console char read for GET
	IF	STRNG		;string ram
STEMP:	DZ	1		;number of string temporaries in use

;locations which may come up randomly in ROM version
	DZ	2*STMAX		;string temporaries, 2 bytes each
STRT:	DZ	2		;top of string space address
STRPT:	DZ	2
STRP2:	DZ	2		;string space pointers
GCMIN:	DZ	2
GCLST:	DZ	2
GCLOC:	DZ	2		;garbage collection temp storage
	ENDIF			;end of string ram
	IF	EDITC AND (NOT COMPL)
	IF	STRNG
RNNEW	EQU	GCMIN
RNINC	EQU	GCLST
RNOLD	EQU	GCLOC		;RENUM and garbage collection share temps
	ELSE
RNNEW:	DZ	2
RNINC:	DZ	2
RNOLD:	DZ	2
	ENDIF
	ENDIF
	IF	CAMAC AND NONST AND (NOT RTPAK);Northstar DOS RAM
DUNIT:	DZ	1		;disk unit
FNAME:	DZ	9		;file name
DRBUF:	DZ	256		;buffer
NXTAD:	DZ	2
NXTBL:	DZ	2
LSTBL:	DZ	2
LSTFL:	DZ	2
	ENDIF
	IF	PACKI
PAIGN:	DZ	1		;IGNORE byte
PACNT:	DZ	1		;count of chars in current line
PAMOD:	DZ	1		;MODE byte -- 0 waiting, 1 storing, 2 insignif
PAFNO:	DZ	1		;current/next field #
PAFBP:	DZ	2		;field buffer pointer
PAFLD:	DZ	PAFCT		;FIELD data buffer
PADAT:	DZ	PADCT		;data buffer
PADP0:	DZ	2		;FLAG of next record pointer
PADP1:	DZ	2		;first data pointer
PADP2:	DZ	2		;last+1 data pointer
PADP3:	DZ	2		;FLAG of most recent record pointer
	ENDIF
	IF	FLOAT
ARGAD:	DZ	2		;address of arg for amb op retry
	IF	F9511
FPTMP:	DZ	3		;temporaries for 9511 FIN and FOUT
	ELSE			;NOT F9511
	IF	FPBCD		;BCD floating point RAM
FACC:	DZ	6		;FLOATING POINT ACCUMULATOR
ACALT:	DZ	6		;ALTERNATE ACCUMULATOR
HOLD1:	DZ	6		;FLOATING POINT MULTIPLY BUFFERS
HOLD2:	DZ	6
HOLD3:	DZ	6
HOLD4:	DZ	6
FTEMP:	DZ	6		;FLOATING POINT WORK AREAS
FTMP1:	DZ	6
FTMP2:	DZ	6
FTMP3:	DZ	6
FTMP4:	DZ	6
EXP1:	DZ	1		;EXPONENT WORK AREAS
EXP2:	DZ	1
EXP3:	DZ	1
EXP4:	DZ	1
SIGN:	DZ	1		;SIGN WORK AREAS
SIGN1:	DZ	1
FLEN:	DZ	1		;LENGTH OF SUBTRACT FIELD
RSLT:	DZ	2		;ADDRESS STORAGE
	ELSE
;RAM LOCATIONS USED BY THE BINARY FLOATING POINT SYSTEM
PREX:	DZ	1		;PREVIOUS EXPONENT
ACCE:	DZ	1		;ACC EXPONENT
ACCS:	DZ	1		;ACC SIGN
ACC1:	DZ	1		;ACC 1ST FRACTION
ACC2:	DZ	1		;ACC 2ND FRACTION
ACC3:	DZ	1		;ACC 3RD FRACTION
SFLAG:	DZ	1		;SUBTRACTION FLAG
ADRL:	DZ	2		;ADDR OF CHARACTER STRING WORD ADDRESS
TMP1:	DZ	1		;TEMPORARY STORAGE
TMP2:	DZ	1		;    "        "
TMP3:	DZ	1		;    "        "
VALE:	DZ	4		;VALUE EXPONENT
TMP4:	DZ	1		;TEMPORARY STORAGE
;and then the XMATH RAM
SIG:	DZ	1		;SIG INDEX FROM CALLER
FPTXN:	DZ	8		;RUNNING POWER AND POWER MULTIPLIER
FPSUM:	DZ	4		;RUNNING TERM SUM
VECT:	DZ	2		;ADDRESS OF CURRENT TERM
FINSN:	DZ	1		;B7 = INPUT SIGN B6-B0 = 0
FINFP:	DZ	4		;FRACTIONAL PART
FPTXX:	DZ	4
FPTF:	DZ	4
FPTP:	DZ	4
FPTX:	DZ	4		;TEMP STORAGE
FPTN:	DZ	1		;N
FPSGN:	DZ	1		;INPUT SIGN
FPTZ0:	DZ	4		;INITIAL POWER OF Z
FPTZ1:	DZ	4		;TERM POWER MULTIPLIER (Z1=Z)
FLNZI:	DZ	4		;INITIAL POWER
FLNZ2:	DZ	4		;POWER TERM MULTIPLIER
FLNK:	DZ	1		;K,J
FLNF:	DZ	4		;F,G,X,G(Z) -- NB must follow FLNK
FSCFX:	DZ	1		;0AFH FOR SIN, 0 FOR COS
FSCSG:	DZ	1		;0 IF INPUT +, 80H IF -
FSCZ:	DZ	4		;Z
FSCZ2:	DZ	4		;Z^2
FTMPA:	DZ	4		;TEMP STORAGE
FTMPB:	DZ	4		; ----"-----
	IF	NOT CAMAC	;no ATN in CAMAC versions
FATZX:	DZ	4		;Z,X
FATXM:	DZ	4		;INITIAL POWER OF X
FATX2:	DZ	4		;TERM POWER MULIPLIER
FATSG:	DZ	1		;INPUT SIGN
FATK:	DZ	1		;K
	ENDIF			;end of NOT CAMAC conditional
	ENDIF			;end of NOT FPBCD conditional
	ENDIF			;end of NOT F9511 conditional
	ENDIF			;end of FLOAT conditional

;stack space
	IF	ASM80
	STKLN	STAKL
	ELSE
	DZ	STAKL
STACK:	DEFS	0
	ENDIF

VARTY:	DZ	1	;type of last var name scanned
	IF	STRNG OR FLOAT	;default variable type buffer
TYBUF:	DZ	26
	ENDIF
TEMP:	DZ	2		;all-purpose temp storage
TXTP2:	DZ	2		;secondary textp for READ, INPUT
SAVTP:	DZ	2		;textp save
LHSTY:	DZ	1		;lhs variable type
LHSAD:	DZ	2		;lhs variable address
CSTKP:	DZ	2		;control stack pointer
ESTKP:	DZ	2		;expression stack pointer
SYMTA:	DZ	2		;starting address of symbol table
BUFAD:	DZ	MAXNL+MAXNL	;buffer for number-string conversion, var names
	DEFB	':'		;colon precedes tokenized input buffer
TLNAD:
	IF	EDITC		;tokenization buffer seperate in EDITC version
	DEFB	CR
	DZ	NLMAX+2		;NLMAX chars + space + cr  + eof
	ENDIF
NLNAD:	DEFB	CR		;first byte of input buffer
	IF	(SDISK OR (CAMAC AND NONST)) AND (NOT RTPAK)
	DZ	255		;input buffer is used by LINPUT too
	ELSE
	DZ	NLMAX+2		;NLMAX chars + space + cr + eof
	ENDIF
	IF	NOT COMPL
LNLEN:	DZ	1		;length of current input line
CSTKD:	DZ	1		;control stack direct count
TRACL:	DZ	1		;line traced -- 0 no, m1 yes
	ENDIF
TEXTP:	DZ	2		;current text line pointer
RDPTR:	DZ	2		;READ text pointer
EOFAD:	DZ	2		;ending address of user source text
MEMT:	DZ	2		;top of memory address
	DEFB	CR		;cr precedes source text
SRCAD:	DZ	1		;source text

; $*MACRO:;resume macro expansion hex printing
	ENDIF			;end of NOT ROM conditional

;end of RAM
	PAGE
;ROM 12/12/80
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
;RAM EQUates for ROM version

	IF	ROM

	IF	COMPL AND NOT RTPAK
PATCH:	DZ	30		;compiler patch area
	ENDIF

;values  for block move into nonzero RAM locations
NZRAM:
	IF	CAMAC		;impure routines for CAMAC command execution
	LD	A,(HL)		;CAMWR, write data
	OUT	(0),A
	INC	HL
	LD	A,(HL)
	OUT	(1),A
	INC	HL
	LD	A,(HL)
	OUT	(2),A
	RET
	LD	A,(HL)		;CAMFN, perform function
	OUT	(3),A
	INC	HL
	LD	A,(HL)
	OUT	(4),A
	INC	HL
	LD	A,(HL)
	OUT	(5),A
	RET
	IN	A,(6)		;CAMRD, read data
	LD	(HL),A
	INC	HL
	IN	A,(7)
	LD	(HL),A
	INC	HL
	IN	A,(8)
	LD	(HL),A
	RET
	DEFB	255 AND -120, 255 AND -60, 255 AND -24;TIMEX
	ELSE
	IF	NOT WILD
	DEFB	0		;IOBYT in first RAM location
	JP	JMPTA+60	;CSTAT, console status
	ENDIF
	IF	REALT		;TIMEX, time counts
	DEFB	255 AND -20, 255 AND -60, 255 AND -60, 255 AND -24
	ELSE
	DEFW	TIMEM
	DEFW	TIMEN
	DEFB	TIMEH
	ENDIF
	ENDIF
	IN	A,(0)		;RPORT
	RET
	OUT	(0),A		;WPORT
	RET
	IF	BENDX AND SDISK
	JP	0		;BRCHA
	ENDIF
	IF	ROMSQ
	DEFW	SRCAD		;SOURC
	ENDIF
	IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)
;impure code for FMULT and FDIV routines
;MULX4, RAM MULTIPLY SUBROUTINE
	ADD	A,0		;ADD OPERAND 3RD FRACTION
	LD	E,A		;4TH PARTIAL PRODUCT
	LD	A,D		;3RD PARTIAL PRODUCT
	ADC	A,0		;ADD OPERAND 2ND FRACTION
	LD	D,A		;3RD PARTIAL PRODUCT
	LD	A,C		;2ND PARTIAL PRODUCT
	ADC	A,0		;ADD OPERAND 1ST FRACTION
	RET			;TO ROM CODE
;DIVX5, RAM DIVIDE SUBROUTINE
	SUB	0		;SUBTRACT DIVISOR 4TH FRACTION
	LD	A,L		;REMAINDER 3RD FRACTION
	SBC	A,0		;SUBTRACT DIVISOR 3RD FRACTION
	LD	L,A		;REMAINDER 3RD FRACTION
	LD	A,H		;REMAINDER 2ND FRACTION
	SBC	A,0		;SUBTRACT DIVISOR 2ND FRACTION
	LD	H,A		;REMAINDER 2ND FRACTION
	LD	A,E		;REMAINDER 1ST FRACTION
	SBC	A,0		;SUBTRACT DIVISOR 1ST FRACTION
	LD	E,A		;REMAINDER 1ST FRACTION
	LD	A,0		;REMAINDER 4TH FRACTION
	RET			;TO ROM CODE
;DIVX6, RAM DIVIDE SUBROUTINE
	ADD	A,0		;ADD DIVISOR 3RD FRACTION
	LD	L,A		;REMAINDER 3RD FRACTION
	LD	A,H		;REMAINDER 2ND FRACTION
	ADC	A,0		;ADD DIVISOR 2ND FRACTION
	LD	H,A		;REMAINDER 2ND FRACTION
	LD	A,E		;REMAINDER 1ST FRACTION
	ADC	A,0		;ADD DIVISOR 1ST FRACTION
	LD	E,A		;REMAINDER 1ST FRACTION
	LD	A,0		;REMAINDER 4TH FRACTION
	RET			;TO ROM CODE
	ENDIF
	IF	COMPL AND NOT RTPAK;compiler values
	DEFW	ROMEND		;TEXTP
	DEFW	ROMEND		;RDPTR
	DEFW	RAMEND+1	;EOFAD
	DEFB	0		;COLUM
	DEFB	0		;WIDTH
	DEFW	0		;MEMT
ROMEND:	DEFB	CR		;cr precedes source text
SRCAD	EQU	ROMEND+1	;source text location
	ELSE			;RTPAK OR NOT COMPL
	IF	NOT RTPAK
	JP	INIT		;DMODC
	IF	(NOT EPSTN) AND (NOT CAMAC) AND (NOT BENDX);HEADR
	IF	NOT GENMC
	DEFB	STBYT,TYBYT,'        XYB'
	ELSE
	DEFB	CR, LF, '''', '        .BAS', CR, LF OR 80H
	ENDIF
	ENDIF
	ENDIF			;end of NOT RTPAK conditional
	DEFB	0		;COLUM
	DEFB	255		;WIDTH
	ENDIF
NZLEN	EQU	$-NZRAM		;number of nonzero bytes to block move


;ram location EQUates
	IF	ASM80
	DSEG			;start of relocatable data segment
	ELSE
SAVPC	EQU	$		;save ROM PC location
	ORG	RAMORG		;and reset PC to start of RAM
	ENDIF

;first locations which must get nonzero values by block move
	IF	CAMAC
CAMWR:	DEFS	12
CAMFN:	DEFS	12
CAMRD:	DEFS	12
TIMEX:	DEFS	3
	ELSE			;not CAMAC
	IF	NOT WILD
IOBYT:	DEFS	1
CSTAT:	DEFS	3
	ENDIF
	IF	REALT
TIMEX:	DEFS	4
	ELSE
TIMEX:	DEFS	5
	ENDIF
	ENDIF			;end of NOT CAMAC conditional
RPORT:	DEFS	3
WPORT:	DEFS	3
	IF	BENDX AND SDISK
BRCHA:	DEFS	3
	ENDIF
	IF	ROMSQ
SOURC:	DEFS	2
	ENDIF
	IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)
MULX4:	DEFS	11
DIVX5:	DEFS	17
DIVX6:	DEFS	14
	ENDIF
	IF	COMPL AND NOT RTPAK
TEXTP:	DEFS	2
RDPTR:	DEFS	2
EOFAD:	DEFS	2
COLUM:	DEFS	1
WIDTH:	DEFS	1
MEMT:	DEFS	2
	ELSE
	IF	NOT RTPAK
DMODC:	DEFS	3
	IF	NOT (EPSTN OR CAMAC OR BENDX)
HEADR:	DEFS	HEADL
	ENDIF
	ENDIF
COLUM:	DEFS	1
WIDTH:	DEFS	1
	ENDIF

;next the locations which must be zeroed
LNNUM:	DEFS	2
	IF	NOT COMPL
	IF	EDITC
ERRLN:	DEFS	2
	ENDIF
TRAP:	DEFS	1
TRACE:	DEFS	1
INLHS:	DEFS	1
VTRAC:	DEFS	1
	ENDIF
	IF	CAMAC
CMDAT:	DEFS	3
CMCRA:	DEFS	1
CMSLO:	DEFS	2
CMFNC:	DEFS	1
SCRTE:	DEFS	1
SDRVR:	DEFS	1
CAMQR:	DEFS	1
CAMXR:	DEFS	3
	IF	C3908
CMBLK:	DEFS	7
	ENDIF
CVCNT:	DEFS	2
CVLOC:	DEFS	2
XNABL:	DEFS	1
IMODE:	DEFS	1
FMODE:	DEFS	1
	ENDIF
	IF	BENDX AND SDISK
BWTCT:	DEFS	3
BREOF:	DEFS	2
BFILP:	DEFS	1
BFBLK:	DEFS	9
	ENDIF
	IF	NOT WILD
LMODE:	DEFS	1
	ENDIF
	IF	PACKI
PAONL:	DEFS	1
	ENDIF
OMODE:	DEFS	1
	IF	NOT WILD
INTTC:	DEFS	1
INTAD:	DEFS	INTTL
RANDX:	DEFS	2
NULLS:	DEFS	1
	ENDIF
GCHAR:	DEFS	1
	IF	STRNG
STEMP:	DEFS	1
	ENDIF
ZLEN	EQU	$-LNNUM		;number of bytes to zero

;followed by locations which may come up randomly
	IF	STRNG
	DEFS	STMAX+STMAX
STRT:	DEFS	2
STRPT:	DEFS	2
STRP2:	DEFS	2
GCMIN:	DEFS	2
GCLST:	DEFS	2
GCLOC:	DEFS	2
	ENDIF
	IF	EDITC AND (NOT COMPL)
	IF	STRNG
RNNEW	EQU	GCMIN
RNINC	EQU	GCLST
RNOLD	EQU	GCLOC
	ELSE
RNNEW:	DEFS	2
RNINC:	DEFS	2
RNOLD:	DEFS	2
	ENDIF
	ENDIF
	IF	BENDX
	IF	SDISK
BFNAM:	DEFS	15
BFNA2:	DEFS	15
	ELSE
BFNAM:	DEFS	11
	ENDIF
BMEPS:	DEFS	3
	ENDIF
	IF	WILD AND RTPAK	;WTOKE temp storage
WMEMT:	DEFS	2
WEOF:	DEFS	2
WLAST:	DEFS	2
WNEXT:	DEFS	2
	ENDIF
	IF	CAMAC AND NONST AND (NOT RTPAK);Northstar DOS
DUNIT:	DEFS	1
FNAME:	DEFS	9
DRBUF:	DEFS	256
NXTAD:	DEFS	2
NXTBL:	DEFS	2
LSTBL:	DEFS	2
LSTFL:	DEFS	1
	ENDIF
	IF	PACKI
PAIGN:	DEFS	1
PACNT:	DEFS	1
PAMOD:	DEFS	1
PAFNO:	DEFS	1
PAFBP:	DEFS	2
PAFLD:	DEFS	PAFCT
PADAT:	DEFS	PADCT
PADP0:	DEFS	2
PADP1:	DEFS	2
PADP2:	DEFS	2
PADP3:	DEFS	2
	ENDIF
	IF	FLOAT		;floating point system RAM
ARGAD:	DEFS	2
	IF	F9511
FPTMP:	DEFS	3
	ELSE
	IF	FPBCD
FACC:	DEFS	6		;FLOATING POINT ACCUMULATOR
ACALT:	DEFS	6		;ALTERNATE ACCUMULATOR
HOLD1:	DEFS	6		;FLOATING POINT MULTIPLY BUFFERS
HOLD2:	DEFS	6
HOLD3:	DEFS	6
HOLD4:	DEFS	6
FTEMP:	DEFS	6		;FLOATING POINT WORK AREAS
FTMP1:	DEFS	6
FTMP2:	DEFS	6
FTMP3:	DEFS	6
FTMP4:	DEFS	6
EXP1:	DEFS	1		;EXPONENT WORK AREAS
EXP2:	DEFS	1
EXP3:	DEFS	1
EXP4:	DEFS	1
SIGN:	DEFS	1		;SIGN WORK AREAS
SIGN1:	DEFS	1
FLEN:	DEFS	1		;LENGTH OF SUBTRACT FIELD
RSLT:	DEFS	2		;ADDRESS STORAGE
	ELSE
;first the FMATH RAM
PREX:	DEFS	1
ACCE:	DEFS	1
ACCS:	DEFS	1
ACC1:	DEFS	1
ACC2:	DEFS	1
ACC3:	DEFS	1
SFLAG:	DEFS	1
ADRL:	DEFS	2
TMP1:	DEFS	1
TMP2:	DEFS	1
TMP3:	DEFS	1
VALE:	DEFS	4
TMP4:	DEFS	1
;and then the XMATH RAM
SIG:	DEFS	1
FPTXN:	DEFS	8
FPSUM:	DEFS	4
VECT:	DEFS	2
FINSN:	DEFS	1
FINFP:	DEFS	4
FPTXX:	DEFS	4
FPTF:	DEFS	4
FPTP:	DEFS	4
FPTX:	DEFS	4
FPTN:	DEFS	1
FPSGN:	DEFS	1
FPTZ0:	DEFS	4
FPTZ1:	DEFS	4
FLNZI:	DEFS	4
FLNZ2:	DEFS	4
FLNK:	DEFS	1
FLNF:	DEFS	4
FSCFX:	DEFS	1
FSCSG:	DEFS	1
FSCZ:	DEFS	4
FSCZ2:	DEFS	4
FTMPA:	DEFS	4
FTMPB:	DEFS	4
	IF	NOT CAMAC
FATZX:	DEFS	4
FATXM:	DEFS	4
FATX2:	DEFS	4
FATSG:	DEFS	1
FATK:	DEFS	1
	ENDIF
	ENDIF
	ENDIF
	ENDIF

	IF	ASM80
	STKLN	STAKL
	ELSE
	DEFS	STAKL
STACK:	DEFS	0
	ENDIF

VARTY:	DEFS	1
	IF	STRNG OR FLOAT
TYBUF:	DEFS	26
	ENDIF
TEMP:	DEFS	2
TXTP2:	DEFS	2
SAVTP:	DEFS	2
LHSTY:	DEFS	1
LHSAD:	DEFS	2
CSTKP:	DEFS	2
ESTKP:	DEFS	2
SYMTA:	DEFS	2
BUFAD:	DEFS	MAXNL+MAXNL
	DEFS	1
	IF	EDITC
TLNAD:	DEFS	NLMAX+3
	ELSE
TLNAD:	DEFS	0
	ENDIF
	IF	(SDISK OR (CAMAC AND NONST)) AND (NOT RTPAK)
NLNAD:	DEFS	256
	ELSE
NLNAD:	DEFS	NLMAX+3
	ENDIF
	IF	COMPL AND NOT RTPAK
RAMEND	EQU	$
	ELSE
	IF	WILD OR NOT RTPAK
LNLEN:	DEFS	1
	ENDIF
	IF	NOT RTPAK
CSTKD:	DEFS	1
TRACL:	DEFS	1
	ENDIF
TEXTP:	DEFS	2
RDPTR:	DEFS	2
EOFAD:	DEFS	2
MEMT:	DEFS	2
	DEFS	1
SRCAD	EQU	$
	ENDIF

	IF	NOT ASM80
	ORG	SAVPC		;restore previous ROM PC
	ENDIF

	ENDIF			;end of ROM conditional

;end of ROM
	PAGE
;INITIAL 05/20/81
;XYBASIC Interpreter Source Module
;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
;initialization dialog


	IF	ASM80
	CSEG			;relocatable code segment
	ENDIF

;XYBASIC performs a JMP INIT from ROMORG on initial entry.
;The user program source and working space overlay the code
;in this module after initialization in RAM versions.

INIT:	LD	SP,STACK	;initialize SP

;save A on entry in Wild version
	IF	WILD
	PUSH	AF
	ENDIF

;set up RAM locations if ROM version
	IF	ROM
	LD	BC,NZRAM	;source address to BC
	LD	DE,NZLEN	;byte count to DE
	LD	HL,RAMORG	;destination address to HL
	CALL	MOVED		;block move nonzero bytes to RAM
	LD	BC,ZLEN		;0 to B, bytes to zero to C
	CALL	FILLM		;fill RAM locations with 0
	LD	A,':'
	LD	HL,TLNAD-1
	LD	(HL),A		;colon precedes tokenized input buffer
	INC	HL
	LD	A,CR
	LD	(HL),A		;cr to tokenized input buffer
	IF	EDITC
	LD	(NLNAD),A	;and cr to input buffer in EDITC version
	ENDIF
	LD	(SRCAD-1),A	;cr precedes source text
	ENDIF			;end of ROM conditional

;initialize runtime package pointers
	IF	RTPAK		;initialize souce text pointers
	LD	HL,SRCAD
	LD	(HL),0		;source text empty
	LD	(EOFAD),HL	;initialize EOFAD
	CALL	CSPST		;reset CSTACK and ESTACK
	ENDIF			;end of RTPAK conditional

;set up i/o jmp vector if CP/M version
	IF	CPM
	LD	HL,(CPMBA+1)	;3E03H + base
	LD	DE,3
	ADD	HL,DE		;3E06H + base
	LD	(CSTAT+1),HL	;store to allow console status not via BDOS
	ADD	HL,DE		;3E09H + base
	LD	(CONIN+1),HL	;store to allow console reading without echo
	ADD	HL,DE		;3E0CH + base
	LD	(CNOUT+1),HL	;store to allow console writing
	ADD	HL,DE		;3E0FH + base
	LD	(LOUT+1),HL	;store to allow list device writing
	IF	AMD		;also define PUN and RDR in AMD version
	ADD	HL,DE
	LD	(POUT+1),HL	;3E12H + base is PUN out
	ADD	HL,DE
	LD	(RDRIN+1),HL	;3E15H + base is RDR in
	ENDIF			;end of AMD conditional
	ENDIF			;end of CPM conditional

;initialize the real time clock for REALT version
	IF	REALT
	LD	A,0C3H
	LD	(10H),A		;JMP to RST 2
	LD	HL,CLOCK
	LD	(11H),HL	;so RST 2 does a JMP CLOCK
	EI			;enable interrupts so clock runs
	ENDIF

;initialize the real time clock for CAMAC version
	IF	CAMAC
	LD	HL,101H
	LD	(SCRTE),HL	;set serial crate and driver to 1
	IF	C3885 AND NOT DEBUG;clock initialization for 3885
;initialize RST 7.5 at 3CH to JMP CLOCK
	LD	A,0C3H
	LD	(3CH),A		;JMP to 3CH
	LD	HL,CLOCK
	LD	(3DH),HL	;CLOCK to 3DH
;initialize counter mode and set interrupt mask
	LD	A,74H
	OUT	(0BH),A		;set counter 1 to mode 2
	LD	BC,800
	LD	A,C
	OUT	(9),A
	LD	A,B
	OUT	(9),A		;initialize counter
	LD	A,0BH
	SIM			;set interrupt mask
	EI
	ENDIF
;clock initialization in old NONST version
	IF	NONST AND (NOT RTPAK) AND FALSE
	LD	A,0C3H
	LD	(1008H),A	;JMP to 1008H
	LD	HL,CLOCK
	LD	(1009H),HL	;CLOCK to 1009H so interrupts will JMP CLOCK
	LD	A,255
	OUT	(4),A
	LD	A,0A6H
	OUT	(11),A
	OUT	(19),A
	LD	A,18H
	OUT	(2),A
	EI
	ENDIF
	ENDIF

;Packard Instruments version initialization
	IF	PACKI AND NOT DEBUG
	LD	A,5
	LD	(NULLS),A	;initialize NULLS for TI Silent 700
	RIM			;read interrupt mask
	AND	4
	OR	8		;set
	SIM			;reset interrupt mask
	EI			;enable interrupts
	ENDIF

;print initial message
	IF	NOT (WILD AND RTPAK)
	CALL	PRNTM
	IF	EPSTN
	DEFB	0FH, 13H
	ENDIF
	DEFB	CR, LF
	IF	COMPL
	IF	RTPAK
	DEFB	'RUNTIME '
	ELSE
	DEFB	'COMPILED '
	ENDIF
	ENDIF
	IF	(NOT STRNG) AND (NOT FLOAT)
	DEFB	'INTEGER '
	ENDIF
	IF	AMD
	DEFB	'AMD '
	ENDIF
	IF	BENDX
	DEFB	'BENDIX '
	ENDIF
	IF	PACKI
	DEFB	'PACKARD INSTRUMENTS '
	ENDIF
	IF	WILD
	DEFB	'WILD '
	ENDIF
	DEFB	'XYBASIC '
	IF	EPSTN
	DEFB	12H
	ENDIF
	IF	CPM AND (NOT CAMAC)
	DEFB	'CP/M '
	ENDIF
	IF	ISIS2
	DEFB	'ISIS-II '
	ENDIF
	IF	SDISK AND (NOT CAMAC)
	DEFB	'DISK '
	ENDIF
	IF	EDITC
	DEFB	'EDIT '
	ENDIF
	DEFB	'REV ', VERSN/10000+'0', '.'
	IF	((VERSN/1000) MOD 10) NE 0
	DEFB	(VERSN/1000) MOD 10 + '0'
	ENDIF
	DEFB	(VERSN/100) MOD 10 +'0'
	IF	(VERSN MOD 100) NE 0
	DEFB	'.'
	IF	((VERSN/10) MOD 10) NE 0
	DEFB	(VERSN/10) MOD 10 + '0'
	ENDIF
	DEFB	VERSN MOD 10+'0'
	ENDIF
	IF	DEBUG
	DEFB	'D'
	ENDIF
	DEFB	CR, LF OR 80H

;print copyright message unless CAMAC version
	IF	NOT CAMAC
	LD	HL,MWCMA
	CALL	PRTST		;print copyright message
	ENDIF
	ENDIF			;end of NOT (WILD AND RTPAK) conditional

;if compiler, find top of memory and execute program directly
	IF	COMPL AND NOT RTPAK
	LD	HL,(MEMT)	;passed memt value to HL
	LD	A,H
	OR	L		;Zero set iff default to found value
	CALL	Z,EOMEM		;take default value
	IF	STRNG
	LD	(STRT),HL	;store top of string space
	DEC	H		;leave 100H bytes of string space
	ENDIF
	LD	(MEMT),HL
	LD	(HL),0		;initialize symbol table
	CALL	CLEA1		;initialize
	LD	(HL),0		;initialize cstack
	JP	NEXTS		;and execute the program
	ELSE			;(not COMPL) or RTPAK

;check default width if ROMSQ or CP/M version
	IF	ROMSQ AND NOT WILD
	LD	A,(DFLTW)	;default width to A
	OR	A
	JP	NZ,INIT2	;take specified width
	ENDIF
	IF	CPM AND NOT COMPL
	LD	A,(FCBAD+1)
	CP	' '		;check if filename specified on command line
	LD	A,72
	JP	NZ,INIT2	;yes, default width to 72
	ENDIF

;prompt for width
	IF	WILD AND RTPAK
	LD	A,255
	LD	(WIDTH),A
	ELSE
INIT1:	LD	DE,1		;terminal width min  = 1
	CALL	INITP		;print message, get width
	DEFB	'WIDTH?', ' ' OR 80H
	JP	C,INIT1		;illegal value
	LD	A,NLMAX		;default width to A
	JP	Z,INIT2		;take default value
	LD	A,H
	OR	A
	JP	NZ,INIT1	;too big -- try again
	LD	A,L
INIT2:	LD	(WIDTH),A
	ENDIF			;end of NOT (WILD AND RTPAK) conditional

INIT3:
	IF	ROM	;min memtop value to DE
	LD	DE,SRCAD+DBYTS
	ELSE
	LD	DE,EORAM+DBYTS
	ENDIF

;check default memtop value if ROMSQ or CP/M version
	IF	ROMSQ AND NOT WILD
	LD	HL,(DFLTM)	;default end of memory to HL
	CALL	CMDHU
	JP	C,INIT4		;check specified value
	LD	A,H
	OR	L		;Zero set iff default to max
	JP	Z,INIT5		;take max value
	ENDIF
	IF	CPM AND NOT COMPL
	LD	A,(FCBAD+1)
	CP	' '
	JP	NZ,INIT5	;take max
	ENDIF

;prompt for end of memory
	IF	WILD AND RTPAK
	LD	HL,(WEOM)
	CALL	CMDHU		;compare to least
	JP	C,INIT6		;take given value
	ELSE
	CALL	INITP		;print message, get mem top
	DEFB	'END OF MEMORY?', ' ' OR 80H
	JP	C,INIT3		;bad value, retry
	JP	Z,INIT5		;take default value
INIT4:	CALL	RTEST		;test if specified location is RAM
	JP	NZ,INIT3	;not RAM, retry
	JP	INIT6		;else take specified location
	ENDIF			;end of NOT (WILD AND RTPAK) conditional
INIT5:	CALL	EOMEM		;find default end of memory

;initialize RAM pointers
INIT6:	XOR	A
	IF	SDISK AND CPM AND (NOT RTPAK)
	LD	(FILET),HL	;store end of file space
	LD	(HL),A		;initialize first default file area
	LD	DE,-FILEN
	ADD	HL,DE
	LD	(HL),A		;initialize second default file area
	ADD	HL,DE
	ENDIF
	IF	STRNG
	LD	(STRT),HL	;store top of string space
	DEC	H		;leave 100H bytes of string space
	ENDIF
	LD	(HL),A		;initialize symbol table
	LD	(MEMT),HL
	IF	RTPAK
	CALL	CLEA1		;initialize
	ELSE			;NOT RTPAK
	CALL	NEW		;initialize source, interrupt
	IF	BENDX AND NOT DEBUG
	LD	HL,DMOD2
	LD	(BRSAD),HL	;reset reentry address to DMODE
	ENDIF
	LD	HL,STOP
	LD	(DMODC+1),HL	;change ^C branch from JMP INIT to JMP STOP
	ENDIF
	IF	NOT ROM
	LD	HL,DMOD2
	LD	(START+1),HL	;change JMP INIT to JMP DMOD2 to allow reentry
	ENDIF

;load program if specified on CP/M command line
	IF	CPM AND NOT COMPL
	LD	A,(FCBAD+1)
	CP	' '		;check if filename specified on command line
	JP	Z,INIT7		;no
	LD	HL,FCBFT
	LD	(HL),'X'
	INC	HL
	LD	(HL),'Y'
	INC	HL
	LD	(HL),'B'	;reset filetype to .XYB
	CALL	LOADZ		;reset LNNUM and TEXTP in case not found
	CALL	CDKOP		;open the file
	LD	HL,NEXTS
	PUSH	HL		;push normal statement return for RUN
	LD	B,1		;set B for ,R to RUN after loading
	JP	LOD0B		;and load it
	ENDIF

;print BYTES FREE message
	IF	NOT (WILD AND RTPAK)
INIT7:	CALL	FRE		;free memory bytes to BC
	CALL	WRTBU		;write (BC) unsigned
	CALL	PRNTM		;print BYTES FREE message
	DEFB	' BYTES FREE', CR, LF OR 80H
	ENDIF			;end of NOT (WILD AND RTPAK) conditional

;Wild version default program execution
	IF	WILD
	POP	AF		;recover initial A value
	IF	NOT RTPAK
	OR	A
	JP	Z,DMODE		;0 gets direct mode in development version
	ENDIF
	LD	C,A
	LD	B,0		;desired program # to BC
	CALL	EXECW		;find selected program
	LD	HL,(SOURC)
	DEC	HL
	LD	(TEXTP),HL	;reset TEXTP to selected program
	JP	NEXTS		;and execute it
	ELSE			;NOT WILD

;begin at direct mode or execute specified program
	IF	ROMSQ
	LD	HL,(DFLTA)	;default prog address to HL
	IF	RTPAK		;runtime version
	LD	A,(HL)		;fetch first char
	CP	CR
	JP	Z,INIT8		;first char is cr, continue as below
	CALL	PRNTM		;else print error message
	DEFB	'PROGRAM NOT FOUND', CR, LF OR 80H
	JP	BOOT		;and exit
INIT8:	LD	(RDPTR),HL	;initialize the DATA pointer
	INC	HL
	LD	(SOURC),HL	;set SOURC to program address
	ELSE
	LD	A,H
	OR	L
	JP	Z,DMODE		;none specified
	CALL	EXEC0		;reset SOURC to specified address
	LD	HL,(SOURC)
	ENDIF
	DEC	HL
	LD	(TEXTP),HL	;reset TEXTP to program
	JP	NEXTS		;and execute from there
	ELSE			;not ROMSQ
	JP	DMODE
	ENDIF
	ENDIF			;end of NOT WILD conditional

	IF	NOT (WILD AND RTPAK)
;INITP prompts the user and gets a value for WIDTH or END OF MEMORY.
;Call:	DE			min value -1
;	Location after CALL	message to print
;Retn:	Carry			set iff value bad
;	Zero, no Carry		if <cr> typed
;	no Zero, no Carry	value ok,  returned in HL
INITP:	POP	HL		;message address to HL
	CALL	PRTST		;print message
	PUSH	HL		;save return addr
	PUSH	DE		;save min value -1
	CALL	GTLIN		;get a line from console
	CALL	GTDEC		;and get decimal value to DE
	EX	DE,HL		;value typed to HL
	POP	DE		;min -1 to DE
	JP	C,INIP1		;no digit -- check for <cr>
	SCF
	RET	Z		;too big, return Carry
	CALL	CMDHU
	CCF			;Carry set iff min >= value typed
	RET
INIP1:	CP	CR
	RET	Z		;<cr>, return Zero and no Carry
	IF	CAMAC
	LD	HL,MWCMA
	CALL	PRTST		;print copyright message in CAMAC version
	ENDIF
	SCF
	RET			;return Carry
	ENDIF			;end of NOT (WILD AND RTPAK) conditional

	ENDIF			;end of NOT COMPL OR RTPAK conditional

;EOMEM gets default end of RAM to HL.
EOMEM:
	IF	CPM		;fetch end of memory from BDOS
	LD	HL,(BDOS+1)
	DEC	HL
	ENDIF
	IF	ISIS2
	CALL	MECHK		;top of memory to AB
	LD	H,B
	LD	L,A		;then to HL
	ENDIF
	IF	NONST		;search for end of RAM
	IF	COMPL		;first loc to test to HL
	LD	HL,(EOFAD)
	ELSE
	IF	ROM
	LD	HL,SRCAD
	ELSE
	LD	HL,EORAM
	ENDIF
	ENDIF
EOME1:	INC	HL
	LD	A,H
	OR	L
	JP	Z,EOME2		;quit if at 64K boundary
	CALL	RTEST		;check if RAM at location
	JP	Z,EOME1		;RAM, try next
EOME2:	DEC	HL		;top of memory to HL
	ENDIF
EORAM:	RET

	IF	ROM AND (RTPAK OR NOT COMPL)
PATCH	EQU	EORAM+1		;patch area for ROM versions
	ENDIF

	END			;end of XYBASIC source

;end of INITIAL

