   1:			
   2:				.Z80
   3:				ASEG
   4:			
   5:				TITLE	'XYBASIC	REV 2.14.00	05/27/81'
   6:			
   7:			;VERSION 05/18/81
   8:			;XYBASIC Interpreter Source Module
   9:			;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
  10:			;version EQUates
  11:			
  12:	FFFF          	TRUE	EQU	-1
  13:	0000          	FALSE	EQU	0
  15:			
  16:			;version selection switches
  17:	5398          	VERSN	EQU	21400		;current version number
  18:	FFFF          	CPM	EQU	TRUE		;iff CP/M version
  19:	0000          	NONST	EQU	FALSE		;iff nonstandard (Custom I/O) version
  20:	0000          	ISIS2	EQU	FALSE		;iff ISIS-II version
  21:			
  22:			;conditional assembly switches
  23:	FFFF          	STRNG	EQU	TRUE		;iff string version
  24:	FFFF          	FLOAT	EQU	TRUE		;iff floating point version
  25:	0000          	ROM	EQU	NONST		;iff ROM version (NONST only)
  26:	0000          	ROMSQ	EQU	FALSE		;iff ROMSQ version
  27:	0000          	COMPL	EQU	FALSE		;iff COMPILER version (NONST ROM only)
  28:	0000          	RTPAK	EQU	FALSE		;iff RUNTIME version (ROMSQ COMPL only)
  29:	FFFF          	EDITC	EQU	TRUE		;iff editing commands AUTO, DELETE, EDIT, RENUM
  30:	FFFF          	SDISK	EQU	TRUE		;iff sequential disk version (CP/M STRNG only)
  31:	0000          	F9511	EQU	FALSE		;iff 9511 floating point chip version
  32:	0000          	FPBCD	EQU	FALSE		;iff BCD floating point, 10 digit mantissa
  33:	0000          	REALT	EQU	FALSE		;iff SBC 80/20 real time clock
  34:	FFFF          	FOR0	EQU	TRUE		;iff e.g. FOR I = 1 TO 0 never entered
  35:	0000          	ASM80	EQU	FALSE		;iff assembling under ASM80
  36:	FFFF          	KEY80	EQU	TRUE		;iff more than 80H keywords
  37:	0000          	DEBUG	EQU	FALSE		;iff debugging
  38:				;CPM and DEBUG: ^B gets SID, ^X echoes to disk
  39:				;ISIS2 and DEBUG: ^B gets monitor
  40:				;NONST:  DEBUG has no effect
  41:				;PACKI and DEBUG: 8251 initialization skipped
  42:			
  43:			;customized versions
  44:	0000          	AMD	EQU	FALSE		;iff AMD
  45:	0000          	BENDX	EQU	FALSE		;iff Bendix (STRNG NONST only)
  46:	0000          	CAMAC	EQU	FALSE		;iff KineticSystems (STRNG, NONST or CP/M only)
  47:	0000          	C3908	EQU	FALSE		;iff CAMAC version for 3908, false iff 3909
  48:	0000          	C3885	EQU	FALSE		;iff CP/M SDISK CAMAC version for 3885
  49:	0000          	EPSTN	EQU	FALSE		;iff Epstein (NONST only)
  50:	0000          	GENMC	EQU	FALSE		;iff General Microwave (NONST only)
  51:	0000          	PACKI	EQU	FALSE		;iff Packard Instruments
  52:	0000          	WILD	EQU	FALSE		;iff Wild Heerbrugg
  53:			
  54:			;location
  55:	0000          		IF	ASM80
  58:				ELSE
  59:	0100          	ROMORG	EQU	00100H		;first ROM location
  60:	0000          		IF	ROM
  62:				ENDIF
  63:				ENDIF
  64:	0100          		ORG	ROMORG
  65:			
  66:			;global EQUates
  67:	0008          	MAXNL	EQU	8		;max var name length(>=7 for string conversion)
  68:	0008          	INTTN	EQU	8		;max # of interrupt table entries (< 32)
  69:	0041          	INTTL	EQU	INTTN * 8 + 1	;int table length = n 8-byte entries + eof
  70:	64B5          	RANDA	EQU	64B5H		;pseudorandom number generator multiplier
  71:	3A73          	RANDC	EQU	3A73H		;pseudorandom number generator constant
  72:	0080          	STAKL	EQU	80H		;stack length
  73:	0019          	STAKM	EQU	25		;max stack use without recursion by GTEXP
  74:	0003          	VBYTS	DEFL	3		;bytes per ESTACK value entry if integer only
  75:	000A          	DBYTS	DEFL	10		;bytes needed for string space and file areas
  76:	0050          	NLMAX	EQU	80		;input buffer length
  77:	FFFF          		IF	STRNG
  78:	0004          	STMAX	EQU	4		;number of string temporaries
  79:	0004          	VBYTS	DEFL	4		;bytes per value entry if string
  80:	010A          	DBYTS	DEFL	DBYTS+100H	;100H bytes for string space
  81:				ENDIF
  82:	FFFF          		IF	FLOAT
  83:	0000          		IF	FPBCD		;BCD floating point
  86:				ELSE			;binary floating point
  87:	0005          	VBYTS	DEFL	5		;bytes per value entry if floating
  88:	0004          	FBYTS	EQU	4		;bytes per FOR-entry value
  89:	0013          	SINDX	EQU	19		;# significant binary places
  90:				ENDIF
  91:				ELSE			;not floating point version
  93:				ENDIF
  94:			
  95:			;ASCII character equivalents
  96:	0002          	CNTLB	EQU	02H
  97:	0004          	CNTLD	EQU	04H
  98:	0005          	CNTLE	EQU	05H
  99:	0006          	CNTLF	EQU	06H
 100:	0007          	CNTLG	EQU	07H
 101:	0008          	CNTLH	EQU	08H
 102:	000A          	LF	EQU	0AH
 103:	000B          	CNTLK	EQU	0BH
 104:	000C          	CNTLL	EQU	0CH
 105:	000D          	CR	EQU	0DH
 106:	000E          	CNTLN	EQU	0EH
 107:	000F          	CNTLO	EQU	0FH
 108:	0011          	CNTLQ	EQU	11H
 109:	0012          	CNTLR	EQU	12H
 110:	0013          	CNTLS	EQU	13H
 111:	0014          	CNTLT	EQU	14H
 112:	0018          	CNTLX	EQU	18H
 113:	0019          	CNTLY	EQU	19H
 114:	001A          	CNTLZ	EQU	1AH
 115:	003B          	SEMIC	EQU	3BH
 116:	FFFF          		IF	NOT EPSTN
 117:	0003          	CNTLC	EQU	03H
 118:	0010          	CNTLP	EQU	10H
 119:	0015          	CNTLU	EQU	15H
 120:	007F          	RBOUT	EQU	7FH
 121:				ELSE			;Epstein version control chars
 127:				ENDIF
 128:			
 129:			;information passed to compiler
 130:	0000          		IF	COMPL AND NOT RTPAK
 134:				ENDIF
 135:			
 136:	0100  C3D03F  	START:	JP	INIT	;start initialization dialog
 137:	0103  C32604  		JP	GTPAR		;to get parameters for CALL
 138:			
 139:			;nonstandard system EQUates
 140:	0000          		IF	NONST AND NOT CAMAC
 169:				ENDIF			;end of NONST conditional
 170:			
 171:			;CP/M EQUates
 172:	FFFF          		IF	CPM
 173:	0000          	CPMBA	EQU	0H		;CP/M base address
 174:	0003          	IOBYT	EQU	CPMBA+3H	;io byte address
 175:	0005          	BDOS	EQU	CPMBA+5H	;DOS entry point
 176:	005C          	FCBAD	EQU	CPMBA+5CH	;default file control block address
 177:	005D          	FCBFN	EQU	FCBAD + 1	;file name address
 178:	0065          	FCBFT	EQU	FCBAD + 9	;file type address
 179:	007C          	FCBCR	EQU	FCBAD + 32	;current record number
 180:	0080          	DMAAD	EQU	CPMBA+80H	;default DMA address
 181:	000F          	DKOPF	EQU	15		;disk open function
 182:	0010          	DKCLF	EQU	16		;close
 183:	0013          	DKDLF	EQU	19		;delete
 184:	0014          	DKRDF	EQU	20		;read
 185:	0015          	DKWTF	EQU	21		;write
 186:	0016          	DKMKF	EQU	22		;make
 187:	001A          	DKDMF	EQU	26		;set DMA address function
 188:	8C13          	TIMEM	EQU	8C13H		;TIME counts
 189:	FE12          	TIMEN	EQU	0FE12H
 190:	0073          	TIMEH	EQU	73H
 191:	0000          		IF	AMD		;serial SAVE/LOAD for AMD version
 195:				ENDIF
 196:	FFFF          		IF	SDISK
 197:	00A6          	FILEN	EQU	166		;number of bytes per sequential access file
 198:	0256          	DBYTS	DEFL	DBYTS+2*FILEN	;number of bytes needed
 199:				ENDIF
 200:	0000          		IF	DEBUG
 202:				ELSE
 203:	0000          	BOOT	EQU	CPMBA		;^B gets CP/M if not debugging
 204:				ENDIF
 205:				ENDIF			;end of CPM conditional
 206:			
 207:			;ISIS-II EQUates
 208:	0000          		IF	ISIS2
 226:				ENDIF			;end of ISIS2 conditional
 227:			
 228:			;CAMAC RTPAK i/o JMP vector
 229:	0000          		IF	CAMAC AND NONST AND TRUE
 237:				ENDIF
 238:			
 239:			;Wild version EQUates
 240:	0000          		IF	WILD
 250:				ENDIF
 251:			
 252:			;ROMSQ version default value bytes
 253:	0000          		IF	ROMSQ AND NOT WILD
 257:				ENDIF
 258:			
 259:			;CAMAC version boot and conditional interrupt enable on reentry
 260:	0000          		IF	CAMAC AND NONST AND (NOT TRUE )
 265:				ENDIF
 266:			
 267:			;Packard Instruments version XYBASIC reentry and interrupt entry point
 268:	0000          		IF	PACKI
 271:				ENDIF
 272:			
 273:			;real-time clock version clock tick routine entry point
 274:	0000          		IF	REALT
 277:				ENDIF
 278:			
 279:			;IFTYP is a macro to simplify coding of conditional type branches.
 280:			IFTYP	MACRO	FADDR,SADDR
 281:				IF	FLOAT
 282:				JP	NZ,FADDR	;;branch to floating routine
 283:				ENDIF
 284:				IF	STRNG
 285:				JP	C,SADDR		;;branch to string routine
 286:				ENDIF			;;else fall through to integer routine
 287:				ENDM
 288:			
 289:			;PUSH3 (and PUSH4) is a macro to save BC, DE, HL (and PSW) on routine entry.
 290:			;The corresponding exit is JMP POP3 (POP4), defined in INOUT.
 291:			PUSH3	MACRO
 292:				PUSH	BC
 293:				PUSH	DE
 294:				PUSH	HL
 295:				ENDM
 296:			PUSH4	MACRO
 297:				PUSH3
 298:				PUSH	AF
 299:				ENDM
 300:			
 301:			;DZ is a macro to fill blocks of RAM with 0 (used like DS).
 302:			DZ	MACRO	N
 303:				REPT	N
 304:				DEFB	0
 305:				ENDM
 306:				ENDM
 307:			
 308:			;RIM and SIM are 8085 opcodes to read and set interrupt mask.
 309:			RIM	MACRO
 310:				DEFB	20H
 311:				ENDM
 312:			SIM	MACRO
 313:				DEFB	30H
 314:				ENDM
 315:			
 316:			;ERROR is a macro to define error calls.
 317:			;TYP may be F, N or C for fatal, nonfatal, or continue scanning.
 318:			;M1 and M2 are the error message, M2 being the last byte.
 319:			ERROR	MACRO	TYP, M1, M2
 320:				CALL	ERRO&TYP	;;call ERROF, ERRON or ERROC
 321:				DEFB	'&M1', '&M2' OR 80H;;error message
 322:				ENDM
 323:			
 324:			
 325:			;end of VERSION
 327:			;AUX 11/19/80
 328:			;XYBASIC Interpreter Source Module
 329:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
 330:			;statement auxilliary routines
 331:			
 332:			;general purpose routines used in statement execution
 333:			
 334:			;LINBC gets current line # in BC.
 335:			;Call:	(LNNUM)	current line # address, 0 if direct
 336:			;Retn:	A	clobbered
 337:			;	BC	if (LNNUM) = 0 then 0 else ((LNNUM))
 338:			;	DE	preserved
 339:			;	HL	if (LNNUM) = 0 then 0 else (LNNUM) + 1
 340:			;	Zero	set iff (LNNUM) = 0
 341:	0106  2AE23C  	LINBC:	LD	HL,(LNNUM)
 342:	0109  7C      	LINB1:	LD	A,H
 343:	010A  B5      		OR	L
 344:	010B  CA1201  		JP	Z,LINB2		;line # is 0, i.e. direct
 345:	010E  4E      		LD	C,(HL)
 346:	010F  23      		INC	HL
 347:	0110  46      		LD	B,(HL)		;line # to BC
 348:	0111  C9      		RET
 349:	0112  47      	LINB2:	LD	B,A
 350:	0113  4F      		LD	C,A		;0 to BC
 351:	0114  C9      		RET
 352:			
 353:			;IDTST issues a fatal ID error if current statement is direct, i.e. (LNNUM)=0.
 354:			;IITST performs EOS test, then issues fatal II error if current is indirect.
 355:	0000          		IF	COMPL
 357:				ELSE
 358:	0115  CD0601  	IDTST:	CALL	LINBC		;zero set iff direct
 359:	0118  C0      		RET	NZ
 360:	0119          	IDERR:	ERROR	F, I, D		;fatal ID error
 361:	011E  CD3101  	IITST:	CALL	EOS
 362:	0121  CD0601  		CALL	LINBC		;zero set iff direct
 363:	0124  C8      		RET	Z		;ok if direct
 364:	0125          		ERROR	F, I, I		;issue fatal II error
 365:				ENDIF			;end of NOT COMPL conditional
 366:			
 367:			;RTEST returns Zero set iff location HL is RAM.
 368:	012A  7E      	RTEST:	LD	A,(HL)		;fetch byte
 369:	012B  2F      		CPL
 370:	012C  77      		LD	(HL),A		;store complement
 371:	012D  BE      		CP	(HL)		;compare to stored value
 372:	012E  2F      		CPL
 373:	012F  77      		LD	(HL),A		;restore value
 374:	0130  C9      		RET
 375:			
 376:	0000          		IF	ROMSQ AND NOT COMPL
 391:				ENDIF			;end of ROMSQ AND NOT COMPL conditional
 392:			
 393:			;EOS checks for garbage on end of statement, and is called by routines which
 394:			;alter normal control flow (GOTO, GOSUB, RETURN, etc.).
 395:			;Falls through to syntax error if next nonspace char is not :, ' or <cr>.
 396:			;Retn:	A	next nonspace char
 397:			;	BC,DE	preserved
 398:			;	HL	address of next nonspace char (i.e. of :, ' or <cr>)
 399:	0131  CD3F01  	EOS:	CALL	DTST0
 400:	0134  D0      		RET	NC		;ok if next is delimiter
 401:	0135          	SNERR:	ERROR	C, S, N		;issue SN error and scan to next
 402:	013A          	EXERR:	ERROR	F, E, X		;fatal EX error
 403:			
 404:	0000          		IF	COMPL
 406:				ENDIF
 407:			
 408:			;DTEST tests whether A contains a delimiter.
 409:			;Retn:	Carry	reset iff (A) = :, ' or <cr>
 410:			;	Registers	preserved
 411:	013F  CD6818  	DTST0:	CALL	GTCHO
 412:	0142  FE3A    	DTEST:	CP	':'
 413:	0144  C8      		RET	Z
 414:	0145  FE0D    	DTST1:	CP	CR
 415:	0147  C8      		RET	Z
 416:	FFFF          		IF	RTPAK OR NOT COMPL;comments already purged if compiled
 417:	0148  FE27    		CP	''''
 418:	014A  C8      		RET	Z
 419:				ENDIF
 420:	014B  37      		SCF
 421:	014C  C9      		RET
 422:			
 423:			;GTLHS gets a destination variable reference.  It calls GTVAR with
 424:			;INLHS true (to indicate tracing may be desired) and stores the
 425:			;destination returned in LHSAD for ASSGN to perform assignment.
 426:	014D          	GTLHS:
 427:	FFFF          		IF	NOT COMPL
 428:	014D  3EFF    		LD	A,255
 429:	014F  32E83C  		LD	(INLHS),A	;set INLHS to true
 430:				ENDIF
 431:	0152  CDA31A  		CALL	GTVAR		;perform variable reference
 432:	0155  DA3501  		JP	C,SNERR		;no variable name
 433:	0158  32563E  		LD	(LHSTY),A	;save type
 434:	015B  22573E  		LD	(LHSAD),HL	;save destination
 435:	FFFF          		IF	NOT COMPL
 436:	015E  47      		LD	B,A		;save type
 437:	015F  AF      		XOR	A
 438:	0160  32E83C  		LD	(INLHS),A	;reset INLHS to false
 439:	0163  78      		LD	A,B		;restore type
 440:				ENDIF
 441:	0164  C9      		RET
 442:			
 443:			;ASIGN is CALLed by FOR, NEXT, LET, READ, INPUT to change a variable's value.
 444:			;The value addressed by HL is assigned to the destination LHSAD.
 445:			;Trace information is printed if (VTRAC) is negative.
 446:	0165  CDA609  	ASIGV:	CALL	ESVAL		;value to ESTACK
 447:	0168  2A5B3E  		LD	HL,(ESTKP)
 448:	016B  23      		INC	HL		;point to value
 449:	016C  3A563E  	ASIGN:	LD	A,(LHSTY)	;desired type to A
 450:	016F  CDCB0B  		CALL	CNVRT		;convert value to desired type
 451:	FFFF          		IF	STRNG
 452:	0172  FE03    		CP	STRST
 453:	0174  CC612C  		CALL	Z,SCOPV		;copy to string space if type string
 454:				ENDIF
 455:	0177  CDAC01  		CALL	BYTSD		;# bytes in value to DE
 456:	017A  23      		INC	HL		;point to value
 457:	017B  44      		LD	B,H
 458:	017C  4D      		LD	C,L		;value source to BC
 459:	017D  2A573E  		LD	HL,(LHSAD)	;destination to HL
 460:	0000          		IF	COMPL
 462:				ELSE
 463:	0180  F5      		PUSH	AF		;save type
 464:	0181  C5      		PUSH	BC		;and save value location
 465:	0182  CD3637  		CALL	MOVED		;value to destination
 466:	0185  E1      		POP	HL		;value location to HL
 467:	0186  C1      		POP	BC		;value type to B
 468:				;and fall through to TRVAL
 469:			;TRVAL prints variable value if tracing is desired.
 470:			;Call:	VTRAC	bit 7 set iff tracing desired
 471:			;	B	value type
 472:			;	HL	value location
 473:	0187  3AE93C  	TRVAL:	LD	A,(VTRAC)
 474:	018A  B7      		OR	A
 475:	018B  F0      		RET	P		;done if not tracing
 476:	018C  3E3D    	TRVA1:	LD	A,'='		;BTEST entry point
 477:	018E  CD1F16  		CALL	WRITC		;write the =
 478:	0191  2B      		DEC	HL		;point to type
 479:	0192  78      		LD	A,B		;fetch type
 480:	FFFF          		IF	STRNG
 481:	0193  FE03    		CP	STRST
 482:	0195  C2F528  		JP	NZ,PRVAL	;print nonstring value
 483:	0198  EB      		EX	DE,HL
 484:	0199  21323D  		LD	HL,STEMP
 485:	019C  34      		INC	(HL)		;increment STEMP count before fetching string
 486:	019D  EB      		EX	DE,HL
 487:				ENDIF
 488:	019E  C3F528  		JP	PRVAL		;print the value and return
 489:				ENDIF			;end of NOT COMPL conditional
 490:			
 491:			;ASIGI performs traced integer assignment for NEXT and SCALL value return.
 492:	01A1  70      	ASIGI:	LD	(HL),B
 493:	01A2  2B      		DEC	HL
 494:	01A3  71      		LD	(HL),C		;value to destination
 495:	FFFF          		IF	NOT COMPL
 496:	01A4  C5      		PUSH	BC
 497:	01A5  0601    		LD	B,INTST
 498:	01A7  CD8701  		CALL	TRVAL		;print trace info if desired
 499:	01AA  C1      		POP	BC
 500:				ENDIF
 501:	01AB  C9      		RET
 502:			
 503:			;BYTSD returns with the number of bytes in an value in DE.
 504:	01AC  110400  	BYTSD:	LD	DE,VBYTS-1
 505:	FFFF          		IF	FLOAT
 506:	01AF  FE02    		CP	SNGST
 507:	01B1  C8      		RET	Z		;return 4 if floating
 508:	0000          		IF	FPBCD
 510:				ELSE
 511:	01B2  1B      		DEC	DE
 512:				ENDIF
 513:				ENDIF
 514:	FFFF          		IF	STRNG
 515:	01B3  FE03    		CP	STRST
 516:	01B5  C8      		RET	Z		;return 3 if string
 517:				ENDIF
 518:	FFFF          		IF	FLOAT OR STRNG
 519:	01B6  1B      		DEC	DE
 520:				ENDIF
 521:	01B7  C9      		RET			;return 2 if integer
 522:			
 523:			;FETCH fetches a value addressed by HL and returns its type in the status bits.
 524:			;Call:	HL	pointer to type
 525:			;Retn:	A	type token
 526:			;	BC	value if integer, Carry reset and Zero set
 527:			;	C,DE	length, location if string, Carry set and Zero set
 528:			;	FACC	value if floating, Carry reset and Zero reset
 529:			;FETBC does a FETCH of arg in BC.
 530:	01B8  60      	FETBC:	LD	H,B
 531:	01B9  69      		LD	L,C
 532:	01BA  7E      	FETCH:	LD	A,(HL)		;fetch the type token
 533:	01BB          	FETC1:
 534:	FFFF          		IF	FLOAT
 535:	01BB  FE02    		CP	SNGST
 536:	01BD  CAE101  		JP	Z,FETCF		;fetch floating
 537:				ENDIF
 538:	FFFF          		IF	STRNG
 539:	01C0  FE03    		CP	STRST
 540:	01C2  CAD201  		JP	Z,FETCS		;fetch string
 541:				ENDIF
 542:	01C5  FE01    	FETCI:	CP	INTST
 543:	01C7  C23A01  		JP	NZ,EXERR
 544:	FFFF          		IF	FLOAT
 545:	01CA  22473D  		LD	(ARGAD),HL	;save location for retry of ambiguous op
 546:				ENDIF
 547:	01CD  23      	MOBCM:	INC	HL		;Zero is set, Carry reset
 548:	01CE  4E      		LD	C,(HL)
 549:	01CF  23      		INC	HL
 550:	01D0  46      		LD	B,(HL)		;fetch integer to BC
 551:	01D1  C9      		RET
 552:	FFFF          		IF	STRNG
 553:	01D2  23      	FETCS:	INC	HL
 554:	01D3  4E      		LD	C,(HL)		;length to C
 555:	01D4  CDF801  		CALL	MODEM		;location to DE
 556:	01D7  21323D  		LD	HL,STEMP
 557:	01DA  35      		DEC	(HL)		;decrement # string temps in use
 558:	01DB  FA3A01  		JP	M,EXERR		;EX error if negative
 559:	01DE  AF      		XOR	A		;Zero is set
 560:	01DF  37      		SCF			;and Carry set also
 561:	01E0  C9      		RET
 562:				ENDIF
 563:	FFFF          		IF	FLOAT
 564:	0000          		IF	F9511		;9511 version fetches to 9511 stack
 574:				ELSE			;NOT F9511
 575:	01E1          	FETCF:	PUSH3			;save registers
 576:	01E4  23      		INC	HL		;point to value
 577:	01E5  CDDD0E  		CALL	FLOAD		;load value to FACC
 578:	01E8  3E02    		LD	A,SNGST		;return type in A
 579:	01EA  B7      		OR	A		;Carry reset, Zero reset
 580:	01EB  C39309  		JP	POP3		;restore registers and return
 581:				ENDIF
 582:				ENDIF
 583:			
 584:			;MVDEM returns (M):(M-1) in DE, (HL)-2 in HL
 585:			;BC, PSW preserved
 586:	01EE  56      	MVDEM:	LD	D,(HL)
 587:	01EF  2B      		DEC	HL
 588:	01F0  5E      		LD	E,(HL)
 589:	01F1  2B      		DEC	HL
 590:	01F2  C9      		RET
 591:			
 592:			;MVMDE moves (DE) to (M-1):(M-2), returns (HL)-2 in HL
 593:	01F3  2B      	MVMDE:	DEC	HL
 594:	01F4  72      		LD	(HL),D
 595:	01F5  2B      		DEC	HL
 596:	01F6  73      		LD	(HL),E
 597:	01F7  C9      		RET
 598:			
 599:			;MODEM moveds (M+2):(M+1) to DE, returns (HL)+2 in HL.
 600:	01F8  23      	MODEM:	INC	HL
 601:	01F9  5E      		LD	E,(HL)
 602:	01FA  23      		INC	HL
 603:	01FB  56      		LD	D,(HL)
 604:	01FC  C9      		RET
 605:			
 606:			;ISBYT checks whether (B) = 0.  If so, it returns.
 607:			;If not, a nonfatal BY error is issued and B is set to 0.
 608:			;A clobbered, B forced to 0, other registers preserved.
 609:	01FD  78      	ISBYT:	LD	A,B
 610:	01FE  B7      		OR	A		;clear carry, set zero iff (B) = 0
 611:	01FF  C8      		RET	Z
 612:	0200  0600    		LD	B,0		;force (B) to 0
 613:	0202          		ERROR	N, B, Y		;nonfatal BYte error
 614:	0207  C9      		RET			;and return
 615:			
 616:			;CPLDE replaces (DE) with its two's complement.
 617:			;CPLD1 replaces (DE) with its one's complement.
 618:			;Retn:	A	clobbered
 619:			;	BC,HL	preserved
 620:			;	DE	two's complemented
 621:			;	Carry	set iff (DE) = 8000H, i.e. overflow
 622:	0208  1B      	CPLDE:	DEC	DE
 623:	0209  7B      	CPLD1:	LD	A,E		;entry point to one's complement DE --
 624:	020A  2F      		CPL			;   NB carry set if called with 7FFFH
 625:	020B  5F      		LD	E,A
 626:	020C  7A      		LD	A,D
 627:	020D  2F      		CPL
 628:	020E  57      		LD	D,A
 629:	020F  EE80    		XOR	80H
 630:	0211  B3      		OR	E		;zero set iff (DE) = 8000H
 631:	0212  C0      		RET	NZ
 632:	0213  3F      		CCF			;set carry if overflow
 633:	0214  C9      		RET
 634:			
 635:			;ADAHL adds (A) + (HL), leaves result in HL and sets carry on overflow.
 636:	0215  85      	ADAHL:	ADD	A,L
 637:	0216  6F      		LD	L,A
 638:	0217  D0      		RET	NC		;done if no carry
 639:	0218  24      		INC	H		;else inc high order
 640:	0219  C8      		RET	Z		;return with carry set iff overflow
 641:	021A  3F      		CCF
 642:	021B  C9      		RET
 643:			
 644:			;SBAHL subtracts (HL) - (A), leaves result in HL and sets carry on underflow.
 645:	021C  95      	SBAHL:	SUB	L		;(A) - (L) to A, carry set iff L > A
 646:	021D  2F      		CPL			;L - A - 1
 647:	021E  6F      		LD	L,A
 648:	021F  23      		INC	HL		;L - A
 649:	0220  D8      		RET	C
 650:	0221  25      		DEC	H
 651:	0222  C9      		RET
 652:			
 653:			;CMBDU compares (BC) to (DE) as 16 bit unsigned integers.
 654:			;Retn:	A	clobbered
 655:			;	BC,DE,HL	unchanged
 656:			;	Zero	set iff (BC) = (DE)
 657:			;	Carry	set iff (BC) < (DE)
 658:	0223  78      	CMBDU:	LD	A,B
 659:	0224  BA      		CP	D		;carry set iff (B) < (D)
 660:	0225  C0      		RET	NZ		;finished unless (B) = (D)
 661:	0226  79      		LD	A,C		;(B) = (D), so compare (C) to (E)
 662:	0227  BB      		CP	E
 663:	0228  C9      		RET
 664:			
 665:			;CMDHU same as CMBDU except DE::HL
 666:	0229  7A      	CMDHU:	LD	A,D
 667:	022A  BC      		CP	H
 668:	022B  C0      		RET	NZ
 669:	022C  7B      		LD	A,E
 670:	022D  BD      		CP	L
 671:	022E  C9      		RET
 672:			
 673:			;CMBDS compares (BC) to (DE) as 16 bit signed (two's complement) integers.
 674:			;Retn:	same as CMBDU above.
 675:	022F  78      	CMBDS:	LD	A,B
 676:	0230  AA      		XOR	D		;sign set iff signs agree
 677:	0231  F22302  		JP	P,CMBDU		;unsigned compare works when signs agree
 678:	0234  78      		LD	A,B		;signs disagree, sign of B gives result
 679:	0235  17      		RLA			;NB zero is reset from xra above
 680:	0236  C9      		RET
 681:			
 682:			;FLIP is called by READ and INPUT to exchange text pointers in TEXTP and TXTP2.
 683:			;Clobbers DE, preserves PSW, leaves TEXTP in HL.
 684:	0237  2A523E  	FLIP:	LD	HL,(TXTP2)
 685:	023A  EB      		EX	DE,HL		;TXTP2 to DE
 686:	023B  2AC63F  		LD	HL,(TEXTP)
 687:	023E  22523E  		LD	(TXTP2),HL	;TEXTP to TXTP2
 688:	0241  EB      		EX	DE,HL
 689:	0242  22C63F  		LD	(TEXTP),HL	;TXTP2 to TEXTP
 690:	0245  C9      		RET
 691:			
 692:			;DMODX is a common exit for various versions of LOAD and EXEC.
 693:			;First the control and expr stacks are reset.  Then execution continues
 694:			;if the command was direct, and XYBASIC returns to DMODE if indirect
 695:			;(since the source program has been changed by the EXEC or LOAD).
 696:			;Call:	HL	eof address of new program
 697:	FFFF          		IF	NOT COMPL
 698:	0246  CD7B27  	DMODX:	CALL	NEW1		;reset stacks
 699:	0249  CD0601  		CALL	LINBC		;Zero set iff direct
 700:	024C  C8      		RET	Z		;continue normally if direct
 701:	024D  C33D07  		JP	DMOD2		;otherwise to DMODE
 702:				ENDIF
 703:			
 704:			;BDTST is called from FOR and NEXT to test FOR-loop termination.
 705:			;Call:	BC or FACC	new FOR-variable value (integer or floating)
 706:			;	DE	increment pointer
 707:			;	HL	bound pointer
 708:			;	LHSTY	FOR-variable type
 709:			;Retn:	Carry	Set iff exit condition satisfied, i.e. value>bound and inr>=0
 710:			;			or value<bound and inr<0
 711:	0250  13      	BDTST:	INC	DE		;point to second incr byte
 712:	FFFF          		IF	FLOAT
 713:	0251  3A563E  		LD	A,(LHSTY)
 714:	0254  FE02    		CP	SNGST
 715:	0256  C26402  		JP	NZ,BDTS1	;integer type
 716:	0259  D5      		PUSH	DE
 717:	0000          		IF	F9511
 720:				ELSE
 721:	025A  CD1513  		CALL	CMPFL		;do floating compare
 722:				ENDIF
 723:	025D  D1      		POP	DE
 724:	025E  C8      		RET	Z		;value=bound, return Carry reset
 725:	0000          		IF	F9511 OR FPBCD
 727:				ENDIF
 728:	025F  1A      		LD	A,(DE)
 729:	0260  07      		RLCA			;incr sign to Carry
 730:	0261  F8      		RET	M		;value<bound, return incr sign as result
 731:	0262  3F      		CCF			;value>bound, return complemented incr sign
 732:	0263  C9      		RET
 733:				ENDIF
 734:	0264  1A      	BDTS1:	LD	A,(DE)
 735:	0265  5E      		LD	E,(HL)
 736:	0266  23      		INC	HL
 737:	0267  56      		LD	D,(HL)		;integer bound to DE
 738:	0268  07      		RLCA
 739:	0269  D42314  		CALL	NC,BCDE		;exchange value and bound if incr>=0
 740:	026C  C32F02  		JP	CMBDS		;and CMBDS returns desired Carry status
 741:			
 742:			;FNDST is called from FOR and READ to scan through a program for
 743:			;the matching NEXT or next DATA statement.
 744:			;Call:	(textp)	text address at which scanning is to begin
 745:			;	B	token to be matched (NEXT or DATA)
 746:			;		(1) Found				(2) Notfound
 747:			;Retn:	A	token					0
 748:			;	B	preserved				preserved
 749:			;	C,DE	clobbered				clobbered
 750:			;	HL	address of next unparsed text char	eof address
 751:			;	Carry	reset					set
 752:			;	(textp)	ditto					eof address - 1
 753:	026F  CD3F01  	FNDS0:	CALL	DTST0		;check if at delimiter
 754:	0272  3F      		CCF
 755:	0273  D0      		RET	NC		;return carry reset if not
 756:				;else empty DATA, fall through to retry
 757:	0274  0E01    	FNDST:	LD	C,1		;initialize FOR count
 758:	0276  110400  		LD	DE,4		;to skip bytes after <cr>
 759:	0279  CD5A18  	FNDS1:	CALL	GTCHA		;get next char
 760:	027C  B8      		CP	B
 761:	027D  CAA802  		JP	Z,FNDS3		;found one
 762:	0280  FE3A    		CP	':'
 763:	0282  CA7902  		JP	Z,FNDS1		;multiple statements -- look at next
 764:	FFFF          		IF	RTPAK OR NOT COMPL;comments purged if compiled
 765:	0285  FE27    		CP	''''
 766:	0287  CCF129  		CALL	Z,REM		;on-line comment -- scan to <cr>
 767:				ENDIF
 768:	028A  FE0D    		CP	CR
 769:	028C  CA9C02  		JP	Z,FNDS2		;cr
 770:	028F  FE8A    		CP	FORT
 771:	0291  CC9A02  		CALL	Z,INRC		;increment FOR-count if FOR
 772:	0294  CDB718  		CALL	GTDEL		;scan to delimiter
 773:	0297  C37902  		JP	FNDS1		;keep trying
 774:	029A  0C      	INRC:	INC	C
 775:	029B  C9      		RET
 776:	029C  7E      	FNDS2:	LD	A,(HL)		;fetch next line length byte
 777:	029D  B7      		OR	A		;check for end of file
 778:	029E  CA9318  		JP	Z,BKUPC		;return carry set if failed
 779:	02A1  19      		ADD	HL,DE		;point to next text byte
 780:	02A2  22C63F  		LD	(TEXTP),HL	;store new pointer
 781:	02A5  C37902  		JP	FNDS1		;and keep looking
 782:	02A8  FE94    	FNDS3:	CP	DATAT
 783:	02AA  CA6F02  		JP	Z,FNDS0		;done if DATA
 784:	02AD  CD2D1A  	FNDS4:	CALL	GTNAM		;look for var name after NEXT
 785:	02B0  0D      		DEC	C		;decrement count
 786:	02B1  D2B902  		JP	NC,FNDS5
 787:	02B4  3F      		CCF			;clear carry in case found
 788:	02B5  C8      		RET	Z		;done if NEXT and FOR count is 0
 789:	02B6  C37902  		JP	FNDS1		;and keep looking
 790:	02B9  C8      	FNDS5:	RET	Z		;return if counted to 0
 791:	02BA  CD7C18  		CALL	GTCOM		;look for comma after <var name>
 792:	02BD  DA7902  		JP	C,FNDS1		;none
 793:	02C0  C3AD02  		JP	FNDS4		;else look for more
 794:			
 795:			;FNDLN finds the line # address of the line which DE points into.
 796:			;Used by READ for DATA syntax errors.
 797:			;Call:	DE	pointer into text
 798:			;Retn:	BC,DE	preserved
 799:			;	HL	line # address of desired text line
 800:	02C3          	FNDLN:
 801:	FFFF          		IF	NOT ROMSQ
 802:	02C3  21CF3F  		LD	HL,SRCAD
 803:				ELSE
 805:				ENDIF
 806:	02C6  22503E  	FNLN1:	LD	(TEMP),HL	;save length byte address
 807:	02C9  7E      		LD	A,(HL)		;fetch length
 808:	02CA  CD1502  		CALL	ADAHL		;address next line
 809:	02CD  CD2902  		CALL	CMDHU		;compare to desired pointer
 810:	02D0  D2C602  		JP	NC,FNLN1	;keep looking
 811:	02D3  2A503E  		LD	HL,(TEMP)	;restore length byte addr
 812:	02D6  23      		INC	HL		;point to line #
 813:	02D7  C9      		RET
 814:			
 815:	0000          		IF	REALT
 843:				ENDIF
 844:			
 845:	FFFF          		IF	EDITC AND (NOT COMPL)
 846:			;LNREF changes all occurrences of <line #>s in source text for RENUM.
 847:	02D8  21CF3F  	LNREF:	LD	HL,SRCAD	;begin at the beginning
 848:			;process next line of source text
 849:	02DB  7E      	LNRE1:	LD	A,(HL)		;fetch length byte
 850:	02DC  B7      		OR	A
 851:	02DD  C8      		RET	Z		;eof, done
 852:	02DE  E5      		PUSH	HL
 853:	02DF  23      		INC	HL
 854:	02E0  23      		INC	HL
 855:	02E1  23      		INC	HL
 856:	02E2  23      		INC	HL		;address first text byte
 857:			;process next byte of source text
 858:	02E3  7E      	LNRE2:	LD	A,(HL)		;fetch a text byte
 859:	02E4  23      		INC	HL
 860:	02E5  FE0D    		CP	CR		;check if end of line
 861:	02E7  CAF403  		JP	Z,LNRE5		;yes
 862:	02EA  FE27    		CP	''''
 863:	02EC  CAED03  		JP	Z,LNRE4		;on-line comment, scan to <cr>
 864:	02EF  FEA7    		CP	REMT
 865:	02F1  CAED03  		JP	Z,LNRE4		;REM, scan to <cr>
 866:	FFFF          		IF	KEY80
 867:	02F4  FE20    		CP	20H
 868:	02F6  DAFE02  		JP	C,LNRE3		;reserved word token, check it
 869:				ENDIF
 870:	02F9  FE80    		CP	80H
 871:	02FB  DAE302  		JP	C,LNRE2		;not a token, try next
 872:			;found a <token>, check if <line #> can and does follow
 873:	02FE  CDFC03  	LNRE3:	CALL	KLTST		;test if token can have <line #> following
 874:	0301  DAE302  		JP	C,LNRE2		;no, try next
 875:	0304  32523E  		LD	(TXTP2),A	;save token in TXTP2 in case ON list or LIST
 876:	0307  22C63F  		LD	(TEXTP),HL	;set TEXTP to scan possible <line #>
 877:	030A  CD6818  	LNR3J:	CALL	GTCHO		;skip spaces, if any
 878:	030D  E5      		PUSH	HL		;save HL pointing to first nonspace
 879:	030E  CD4D19  		CALL	GTLNO		;look for <line #>
 880:	0311  E3      		EX	(SP),HL		;restore HL
 881:	0312  C1      		POP	BC		;first nondigit location to BC
 882:	0313  DAE302  		JP	C,LNRE2		;not a <line #>, try next byte
 883:			;found a <line #>
 884:	0316  E5      		PUSH	HL		;save first for insertion of new line #
 885:	0317  EB      		EX	DE,HL
 886:	0318  CD0802  		CALL	CPLDE		;- first
 887:	031B  EB      		EX	DE,HL
 888:	031C  09      		ADD	HL,BC		;last + 1 - first = <line #> length to HL
 889:	031D  E5      		PUSH	HL		;save length
 890:	031E  CD4137  		CALL	FINDL		;look for <line #>
 891:	0321  DA6503  		JP	C,LNR3C		;not found, flag the line
 892:	0324  E5      		PUSH	HL		;save location
 893:	0325  2A453D  		LD	HL,(RNOLD)
 894:	0328  EB      		EX	DE,HL
 895:	0329  CD4137  		CALL	FINDL		;find location of first renumbered line
 896:	032C  D1      		POP	DE		;location of desired line to DE
 897:	032D  CD2902  		CALL	CMDHU
 898:	0330  DA7103  		JP	C,LNR3D		;before renumbered lines, unchanged
 899:	0333  E5      		PUSH	HL		;save first loc
 900:	0334  2A433D  		LD	HL,(RNINC)
 901:	0337  44      		LD	B,H
 902:	0338  4D      		LD	C,L		;increment to BC
 903:	0339  2A413D  		LD	HL,(RNNEW)	;first destination line # to HL
 904:	033C  CA4C03  		JP	Z,LNR3B		;matched, take first line #
 905:			;compute new <line #> corresponding to old <line #>
 906:	033F  E3      	LNR3A:	EX	(SP),HL		;first line loc to HL
 907:	0340  7E      		LD	A,(HL)
 908:	0341  CD1502  		CALL	ADAHL		;address next line
 909:	0344  CD2902  		CALL	CMDHU		;compare to desired line #
 910:	0347  E3      		EX	(SP),HL
 911:	0348  09      		ADD	HL,BC		;compute new line #
 912:	0349  C23F03  		JP	NZ,LNR3A	;no match, try next
 913:			;convert new <line #> to string and compare to length of old
 914:	034C  D1      	LNR3B:	POP	DE		;discard saved location
 915:	034D  44      		LD	B,H
 916:	034E  4D      		LD	C,L		;new line # to BC
 917:	034F  AF      		XOR	A
 918:	0350  CD3A17  		CALL	CVTIS		;and converted to string, no leading char
 919:	0353  CD2314  		CALL	BCDE		;location to BC, length to E
 920:	0356  E1      		POP	HL		;length of old line # to L
 921:	0357  95      		SUB	L		;new length - old length
 922:	0358  E1      		POP	HL		;old line # loc to HL
 923:	0359  FA7603  		JP	M,LNR3E		;old line # longer
 924:	035C  C2A303  		JP	NZ,LNR3F	;old line # shorter
 925:	035F  CD3437  		CALL	MOVD0		;move new line # to replace old
 926:	0362  C3CF03  		JP	LNR3H		;and keep scanning
 927:			;old <line #> not found, flag bit 7 of line break byte
 928:	0365  E1      	LNR3C:	POP	HL		;discard saved length
 929:	0366  E1      		POP	HL		;and discard saved first loc
 930:	0367  E1      		POP	HL		;length byte addr to HL
 931:	0368  E5      		PUSH	HL		;and resaved
 932:	0369  23      		INC	HL
 933:	036A  23      		INC	HL
 934:	036B  23      		INC	HL		;address break byte
 935:	036C  3680    		LD	(HL),80H	;set bit 7 to indicate line # not found
 936:	036E  C3CF03  		JP	LNR3H		;and keep scanning
 937:			;old <line #> precedes renumbered lines, leave unchanged
 938:	0371  E1      	LNR3D:	POP	HL		;discard saved length
 939:	0372  E1      		POP	HL		;and discard saved first loc
 940:	0373  C3CF03  		JP	LNR3H		;and keep scanning
 941:			;old <line #> longer than new <line #>
 942:	0376  F5      	LNR3E:	PUSH	AF		;save offset
 943:	0377  CD3437  		CALL	MOVD0		;copy new line # to old place
 944:	037A  22C63F  		LD	(TEXTP),HL	;and set new TEXTP
 945:	037D  EB      		EX	DE,HL		;new destination to DE
 946:	037E  F1      		POP	AF		;restore offset
 947:	037F  E1      		POP	HL		;line length pointer to HL
 948:	0380  F5      		PUSH	AF
 949:	0381  86      		ADD	A,(HL)		;add offset
 950:	0382  77      		LD	(HL),A		;and store new line length
 951:	0383  F1      		POP	AF
 952:	0384  E5      		PUSH	HL		;resave line length pointer
 953:	0385  2F      		CPL
 954:	0386  3C      		INC	A		;complement offset
 955:	0387  EB      		EX	DE,HL		;restore destination to HL
 956:	0388  E5      		PUSH	HL		;save destination
 957:	0389  CD1502  		CALL	ADAHL		;+offset = source
 958:	038C  E5      		PUSH	HL
 959:	038D  EB      		EX	DE,HL
 960:	038E  CD0802  		CALL	CPLDE		;-source
 961:	0391  2ACA3F  		LD	HL,(EOFAD)
 962:	0394  23      		INC	HL
 963:	0395  19      		ADD	HL,DE		;count bytes to move
 964:	0396  EB      		EX	DE,HL		;to DE
 965:	0397  C1      		POP	BC
 966:	0398  E1      		POP	HL
 967:	0399  CD3637  		CALL	MOVED		;block move the remaining text
 968:	039C  2B      		DEC	HL
 969:	039D  22CA3F  		LD	(EOFAD),HL	;store new eof
 970:	03A0  C3CF03  		JP	LNR3H		;and keep scanning
 971:			;old <line #> shorter than new
 972:	03A3  F5      	LNR3F:	PUSH	AF
 973:	03A4  C5      		PUSH	BC
 974:	03A5  D5      		PUSH	DE
 975:	03A6  E5      		PUSH	HL		;save all
 976:	03A7  EB      		EX	DE,HL		;first old line # byte addr to DE
 977:	03A8  2ACA3F  		LD	HL,(EOFAD)
 978:	03AB  44      		LD	B,H
 979:	03AC  4D      		LD	C,L		;end of file to BC
 980:	03AD  CD1502  		CALL	ADAHL		;offset + eof = new eof
 981:	03B0  22CA3F  		LD	(EOFAD),HL	;store new eof
 982:	03B3  0A      	LNR3G:	LD	A,(BC)		;fetch a text byte
 983:	03B4  77      		LD	(HL),A		;and store in new location
 984:	03B5  0B      		DEC	BC
 985:	03B6  2B      		DEC	HL
 986:	03B7  7B      		LD	A,E
 987:	03B8  B9      		CP	C
 988:	03B9  C2B303  		JP	NZ,LNR3G
 989:	03BC  7A      		LD	A,D
 990:	03BD  B8      		CP	B
 991:	03BE  C2B303  		JP	NZ,LNR3G	;copy more text bytes
 992:	03C1  E1      		POP	HL
 993:	03C2  D1      		POP	DE
 994:	03C3  C1      		POP	BC		;restore new line # info
 995:	03C4  CD3437  		CALL	MOVD0		;and copy line # into text
 996:	03C7  22C63F  		LD	(TEXTP),HL
 997:	03CA  F1      		POP	AF		;offset
 998:	03CB  E1      		POP	HL		;line length addr
 999:	03CC  86      		ADD	A,(HL)		;old length + offset
1000:	03CD  77      		LD	(HL),A		;gives new length
1001:	03CE  E5      		PUSH	HL
1002:	03CF  3A523E  	LNR3H:	LD	A,(TXTP2)	;recover token preceding <line #>
1003:	03D2  2AC63F  		LD	HL,(TEXTP)
1004:	03D5  FE8C    		CP	GOTOT
1005:	03D7  CAE403  		JP	Z,LNR3I		;GOTO
1006:	03DA  FE8D    		CP	GSUBT
1007:	03DC  CAE403  		JP	Z,LNR3I		;GOSUB
1008:	03DF  FEAB    		CP	LISTT
1009:	03E1  C2E302  		JP	NZ,LNRE2	;not GOTO, GOSUB nor LIST, keep scanning
1010:	03E4  CD7C18  	LNR3I:	CALL	GTCOM		;look for comma
1011:	03E7  DAE302  		JP	C,LNRE2		;none, keep scanning
1012:	03EA  C30A03  		JP	LNR3J		;look for next element in <line #> list
1013:			;scan to next <cr>
1014:	03ED  7E      	LNRE4:	LD	A,(HL)
1015:	03EE  23      		INC	HL
1016:	03EF  FE0D    		CP	CR
1017:	03F1  C2ED03  		JP	NZ,LNRE4
1018:			;end of source text line, try the next
1019:	03F4  E1      	LNRE5:	POP	HL		;length byte addr to HL
1020:	03F5  7E      		LD	A,(HL)
1021:	03F6  CD1502  		CALL	ADAHL		;address next line
1022:	03F9  C3DB02  		JP	LNRE1		;and try next line
1023:			
1024:			;KLTST tests if token in A may have <line #> following.
1025:			;Call:	A	Token
1026:			;Retn:	C	Clobbered
1027:			;	A,B,DE,HL	Preserved
1028:			;	Carry	Set iff not found
1029:	03FC  E5      	KLTST:	PUSH	HL
1030:	03FD  0E0A    		LD	C,KLNCT		;table count to C
1031:	03FF  215B33  		LD	HL,KLNTA	;table addr to HL
1032:	0402  BE      	KLTS1:	CP	(HL)		;compare token to table entry
1033:	0403  CA0C04  		JP	Z,KLTS2		;matched
1034:	0406  23      		INC	HL
1035:	0407  0D      		DEC	C
1036:	0408  C20204  		JP	NZ,KLTS1	;try next
1037:	040B  37      		SCF			;not found
1038:	040C  E1      	KLTS2:	POP	HL		;restore HL
1039:	040D  C9      		RET			;and return
1040:				ENDIF			;end of EDITC conditional
1041:			
1042:	FFFF          		IF	NOT COMPL
1043:			;BKNAM constructs a 3-byte symbol table 'name' at BUFAD for a line break.
1044:			;Byte 1 is H6-H0, byte 2 is L6-L0, both with bit 7 reset.
1045:			;Byte 3 has 1,H7,L7 in bits 7-5 and bits 4-0 reset.
1046:			;Call:	HL	desired break entry 'name' (i.e. line # addr)
1047:	040E  EB      	BKNAM:	EX	DE,HL		;desired line # addr to DE
1048:	040F  215F3E  		LD	HL,BUFAD
1049:	0412  7A      		LD	A,D
1050:	0413  E67F    		AND	7FH
1051:	0415  77      		LD	(HL),A		;byte 1 = D6-D0 to BUFAD
1052:	0416  23      		INC	HL
1053:	0417  7B      		LD	A,E
1054:	0418  E67F    		AND	7FH
1055:	041A  77      		LD	(HL),A		;byte 2 = E6-E0 to BUFAD+1
1056:	041B  23      		INC	HL
1057:	041C  7A      		LD	A,D
1058:	041D  17      		RLA			;D7 to Carry
1059:	041E  7B      		LD	A,E
1060:	041F  1F      		RRA			;D7, E7 to A7, A6
1061:	0420  37      		SCF
1062:	0421  1F      		RRA			;1, D7, E7 to A7-5
1063:	0422  E6E0    		AND	0E0H		;mask off A4-0
1064:	0424  77      		LD	(HL),A		;byte 3 to BUFAD+2
1065:	0425  C9      		RET
1066:				ENDIF			;end of NOT COMPL conditional
1067:			
1068:			;GTPAR gets a parameter from CALL command line.
1069:			;Parameters must be <var ref> or *<array var name>.
1070:			;Retn:	A	0 if no more params, 1 if integer, 2 if string, 3 if floating
1071:			;	B	bytes per entry
1072:			;	C	# dims
1073:			;	DE	address of first dimension
1074:			;	HL	address of first data item
1075:	0426  CD8518  	GTPAR:	CALL	GTCND		;look for comma not followed by delimiter
1076:	0429  3E00    		LD	A,0
1077:	042B  D8      		RET	C		;no more parameters, return 0
1078:	042C  16C3    		LD	D,MULTT
1079:	042E  CD8E18  		CALL	GTD		;look for *
1080:	0431  D24304  		JP	NC,GTPA1	;array passed
1081:	0434  CDA31A  		CALL	GTVAR		;else var ref
1082:	0437  010000  		LD	BC,0		;# dims = 0 to C
1083:	043A  C5      		PUSH	BC		;push 0 for DE
1084:	043B  D25104  		JP	NC,GTPA2	;and continue below
1085:	043E          	MCERR:	ERROR	F, M, C		;fatal MC error
1086:	0443  CD861A  	GTPA1:	CALL	FDVAR		;look for var name
1087:	0446  DA3E04  		JP	C,MCERR
1088:	0449  1A      		LD	A,(DE)		;fetch type
1089:	044A  4E      		LD	C,(HL)		;# dims to C
1090:	044B  0600    		LD	B,0		;to allow dad
1091:	044D  23      		INC	HL		;point to first dim byte
1092:	044E  E5      		PUSH	HL		;and save
1093:	044F  09      		ADD	HL,BC
1094:	0450  09      		ADD	HL,BC		;point to first data byte
1095:	0451  CDAC01  	GTPA2:	CALL	BYTSD		;bytes per entry to DE
1096:	0454  43      		LD	B,E		;and then to B
1097:	0455  D1      		POP	DE		;dim addr to DE
1098:	0456  78      		LD	A,B
1099:	0457  3D      		DEC	A		;A gets 1 for int, 2 string, 3 floating
1100:	0458  C9      		RET
1101:			
1102:			;DISAB disables all interrupts
1103:	FFFF          		IF	NOT WILD
1104:	0459  AF      	DISAB:	XOR	A
1105:	045A  32EC3C  		LD	(INTTC),A	;reset interrupt table count
1106:	045D  32ED3C  		LD	(INTAD),A	;clear interrupt table
1107:	0460  C9      		RET
1108:			
1109:			;<byte expr> , <byte expr> [, <byte expr>] [,$]
1110:			;IINFO gets interrupt information for ENABLE and WAIT.
1111:			;Four bytes corresponding to the first four bytes of an interrupt table
1112:			;entry are returned in BCDE (type, port, mask, value).
1113:	0461  CD9C0C  	IINFO:	CALL	GTBEX
1114:	0464  41      		LD	B,C		;port # to  B
1115:	0465  0EC0    		LD	C,0C0H		;type to C
1116:	0467  C5      		PUSH	BC		;and saved
1117:	0468  CD960C  		CALL	GTCBE
1118:	046B  51      		LD	D,C		;value to D
1119:	046C  1E00    		LD	E,0		;mask 0 for now
1120:	046E  CD7C18  		CALL	GTCOM
1121:	0471  DA9904  		JP	C,IINF3		;default mask 0, null $
1122:	0474  CD6818  		CALL	GTCHO
1123:	0477  FE24    		CP	'$'
1124:	0479  CA8604  		JP	Z,IINF1		;default mask 0, $
1125:	047C  CD9C0C  		CALL	GTBEX
1126:	047F  59      		LD	E,C		;mask to E
1127:	0480  CD7C18  		CALL	GTCOM
1128:	0483  DA9604  		JP	C,IINF2		;null $
1129:	0486  CD5A18  	IINF1:	CALL	GTCHA
1130:	0489  FE24    		CP	'$'
1131:	048B  C23501  		JP	NZ,SNERR
1132:	048E  7A      		LD	A,D
1133:	048F  2F      		CPL
1134:	0490  B3      		OR	E
1135:	0491  57      		LD	D,A		;value = NOT value OR mask (if $)
1136:	0492  C1      		POP	BC
1137:	0493  0EE0    		LD	C,0E0H		;set type $ bit
1138:	0495  C9      		RET
1139:	0496  7A      	IINF2:	LD	A,D
1140:	0497  B3      		OR	E
1141:	0498  57      		LD	D,A		;value = value OR mask (if null $)
1142:	0499  C1      	IINF3:	POP	BC
1143:	049A  C9      		RET
1144:				ENDIF			;end of NOT WILD conditional
1145:			
1146:			
1147:			;end of AUX
1149:			;CPM 5/21/81
1150:			;XYBASIC Interpreter Source Module
1151:			;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
1152:			;CP/M version SAVE and LOAD, including GTFIL
1153:			
1154:	FFFF          		IF	CPM		;CP/M versions
1155:			
1156:	0000          		IF	RTPAK		;UF error in Runtime Module version
1159:				ELSE
1160:			
1161:			;SAVE <filename> [,A]
1162:	049B  CDD917  	SAVE:	CALL	PRNTM		;print SAVING message
1163:	049E  53415649		DEFB	'SAVING', ' ' OR 80H
	      4E47A0
1164:	04A5  CD5206  		CALL	GTFIL		;read filename, initialize file control block
1165:	04A8  78      		LD	A,B
1166:	04A9  B7      		OR	A
1167:	04AA  C23501  		JP	NZ,SNERR	;SN error if ,R specified
1168:	04AD  79      		LD	A,C
1169:	0000          		IF	AMD
1172:				ENDIF
1173:	04AE  B7      		OR	A
1174:	04AF  F5      		PUSH	AF		;save ,A status
1175:	04B0  CDF904  		CALL	CDKMK		;delete old one, make new one
1176:	04B3  F1      		POP	AF		;restore ,A info
1177:	04B4  CA0D05  		JP	Z,SAVEA		;ASCII save
1178:	0000          		IF	AMD
1180:				ENDIF
1181:	04B7  CDEB04  		CALL	RTDMA		;reset DMA address just in case
1182:	0000          		IF	ROMSQ
1189:				ELSE
1190:	04BA  2ACA3F  		LD	HL,(EOFAD)	;eof address to HL
1191:	04BD  E5      		PUSH	HL		;save last
1192:	04BE  21CF3F  		LD	HL,SRCAD	;next source address to HL
1193:				ENDIF
1194:			;EOF address is stacked, next address to save is in HL
1195:	04C1  44      	SAVE1:	LD	B,H
1196:	04C2  4D      		LD	C,L		;next address to BC
1197:	04C3  118000  		LD	DE,80H
1198:	04C6  19      		ADD	HL,DE		;current + 80H = next to HL
1199:	04C7  E5      		PUSH	HL		;save next
1200:	04C8  218000  		LD	HL,DMAAD	;destination = default DMA address
1201:	04CB  CD3637  		CALL	MOVED		;move current block to default DMA address
1202:	04CE  CD0305  		CALL	CDKWT		;write the block
1203:	04D1  E1      		POP	HL		;next to HL
1204:	04D2  D1      		POP	DE		;EOF address to DE
1205:	04D3  D5      		PUSH	DE		;and saved again
1206:	04D4  CD2902  		CALL	CMDHU		;compare
1207:	04D7  D2C104  		JP	NC,SAVE1	;eof >= current -- keep going
1208:	04DA  D1      		POP	DE		;unstack saved EOF address
1209:	04DB  0E10    	CDKCL:	LD	C,DKCLF
1210:	04DD  CDF304  	CDKC1:	CALL	BDOSF		;close it
1211:	04E0  FEFF    		CP	255
1212:	04E2  C0      		RET	NZ		;done if closed successfully
1213:	04E3  CDEB04  	DKERR:	CALL	RTDMA		;reset DMA address after errors
1214:	04E6          		ERROR	F, D, K		;fatal DK error
1215:	04EB  118000  	RTDMA:	LD	DE,DMAAD	;default DMA address to DE
1216:	04EE  0E1A    	STDMA:	LD	C,DKDMF		;set DMA address to (DE)
1217:	0000          		IF	C3885 AND NOT DEBUG
1219:				ELSE
1220:	04F0  C30500  		JP	BDOS
1221:				ENDIF
1222:	04F3  115C00  	BDOSF:	LD	DE,FCBAD	;fcb address to DE
1223:	0000          		IF	C3885 AND NOT DEBUG
1231:				ELSE
1232:	04F6  C30500  		JP	BDOS		;just do it
1233:				ENDIF
1234:	04F9  0E13    	CDKMK:	LD	C,DKDLF
1235:	04FB  CDF304  		CALL	BDOSF		;delete old one
1236:	04FE  0E16    		LD	C,DKMKF
1237:	0500  C3DD04  		JP	CDKC1		;make new one
1238:	0503  0E15    	CDKWT:	LD	C,DKWTF
1239:	0505  CDF304  		CALL	BDOSF
1240:	0508  B7      		OR	A
1241:	0509  C8      		RET	Z
1242:	050A  C3E304  		JP	DKERR
1243:	050D          	SAVEA:
1244:	0000          		IF	AMD
1246:				ENDIF
1247:	050D  CDF405  		CALL	SPRST		;reset disk buffer pointer
1248:	0510  3AEB3C  		LD	A,(OMODE)
1249:	0513  F5      		PUSH	AF		;save output mode
1250:	0514  3E80    		LD	A,80H
1251:	0516  32EB3C  		LD	(OMODE),A	;80H to OMODE
1252:	0000          		IF	AMD
1256:				ENDIF
1257:	0000          		IF	ROMSQ
1259:				ELSE
1260:	0519  21CF3F  		LD	HL,SRCAD
1261:				ENDIF
1262:	051C  01FFFF  		LD	BC,-1
1263:	051F  CD4F27  		CALL	LIST1		;list the program to disk
1264:	0522  0E1A    	SAVA1:	LD	C,CNTLZ
1265:	0524  CDE605  		CALL	DKOUT		;end of file
1266:	0527  CD0305  		CALL	CDKWT		;write the last record
1267:	052A  F1      		POP	AF
1268:	052B  32EB3C  		LD	(OMODE),A	;restore omode
1269:	052E  C3DB04  		JP	CDKCL		;close file and return
1270:			
1271:	0000          		IF	AMD		;HEX or serial SAVE in AMD version
1382:				ENDIF			;end of AMD conditional
1383:			
1384:			;LOAD <filename> [,A] [,R]
1385:	0531          	LOAD:
1386:	0000          		IF	ROMSQ
1388:				ENDIF
1389:	0531  CDD917  		CALL	PRNTM		;print LOADING message
1390:	0534  4C4F4144		DEFB	'LOADING', ' ' OR 80H
	      494E47A0
1391:	0000          		IF	AMD
1394:				ENDIF
1395:	053C  CD5206  		CALL	GTFIL		;read file name, initialize FCB
1396:	0000          		IF	AMD
1400:				ENDIF
1401:	053F  C5      		PUSH	BC		;save ,A and ,R info
1402:	0540  0E0F    		LD	C,DKOPF
1403:	0542  CDF304  		CALL	BDOSF		;try to open it
1404:	0545  FEFF    		CP	255
1405:	0547  C25405  		JP	NZ,LOAD0	;successful open
1406:	054A  C1      		POP	BC
1407:	054B  0E00    		LD	C,0		;reset C to indicate ,A
1408:	054D  C5      		PUSH	BC		;and save
1409:	054E  CD8706  		CALL	GTFL4		;reset file type to .BAS
1410:	0551  CD9F05  		CALL	CDKOP		;and try to open .BAS file
1411:	0554  CD6D27  	LOAD0:	CALL	NEW		;clobber old program
1412:	0557  C1      		POP	BC
1413:	0558  79      		LD	A,C
1414:	0559  B7      		OR	A
1415:	055A  CA8305  		JP	Z,LOADA		;ASCII load
1416:	0000          		IF	AMD
1418:				ENDIF
1419:	055D  C5      	LOD0B:	PUSH	BC		;save ,R status -- initialization entry point
1420:	055E  2A5D3E  		LD	HL,(SYMTA)
1421:	0561  1181FF  		LD	DE,-7FH
1422:	0564  19      		ADD	HL,DE		;first bad dma address to HL
1423:	0000          		IF	AMD
1425:				ELSE
1426:	0565  11CF3F  		LD	DE,SRCAD
1427:				ENDIF
1428:	0568  CD2902  	LOAD1:	CALL	CMDHU		;compare to see how much space still available
1429:	056B  D2B905  		JP	NC,LOADX	;program too large -- OM error
1430:	056E  E5      		PUSH	HL		;save bad address
1431:	056F  D5      		PUSH	DE		;save destination
1432:	0570  CDEE04  		CALL	STDMA		;set DMA address
1433:	0573  CDAC05  		CALL	CDKRD		;read a record
1434:	0576  E1      		POP	HL
1435:	0577  D1      		POP	DE		;restore destination to HL, bad addr to DE
1436:	0578  CABF05  		JP	Z,LOAD2		;eof
1437:	057B  018000  		LD	BC,80H
1438:	057E  09      		ADD	HL,BC		;find next destination
1439:	057F  EB      		EX	DE,HL		;destination to DE, bad addr to HL
1440:	0580  C36805  		JP	LOAD1
1441:	0583  3AEB3C  	LOADA:	LD	A,(OMODE)
1442:	0586  4F      		LD	C,A
1443:	0587  C5      		PUSH	BC		;save OMODE and ,R status
1444:	0588  CD1F06  		CALL	DLOA1		;read a record, set buffer pointer
1445:	058B  3E7F    		LD	A,7FH
1446:	058D  32EB3C  		LD	(OMODE),A	;set OMODE for ASCII load
1447:	0590  CDB433  	LODA1:	CALL	GTLIN		;get a line
1448:	0593  CDA735  		CALL	TKIZE		;tokenize it
1449:	0596  DA9005  		JP	C,LODA1		;ignore if no line #
1450:	0599  C4A436  		CALL	NZ,ADDLN	;add to source
1451:	059C  C39005  		JP	LODA1		;and keep loading
1452:			
1453:	0000          		IF	AMD		;HEX or serial LOAD in AMD version
1558:				ENDIF			;end of AMD conditional
1559:			
1560:	059F  0E0F    	CDKOP:	LD	C,DKOPF
1561:	FFFF          		IF	SDISK
1562:	05A1  CDF304  		CALL	BDOSF
1563:	05A4  FEFF    		CP	255
1564:	05A6  C0      		RET	NZ		;successful open
1565:	05A7          		ERROR	F, F, N		;fatal FN error
1566:				ELSE
1568:				ENDIF
1569:	05AC  0E14    	CDKRD:	LD	C,DKRDF
1570:	05AE  CDF304  		CALL	BDOSF		;read a record
1571:	05B1  FE02    		CP	2
1572:	05B3  CAE304  		JP	Z,DKERR		;read error
1573:	05B6  FE01    		CP	1
1574:	05B8  C9      		RET			;Zero set iff eof
1575:	05B9  CD6D27  	LOADX:	CALL	NEW		;clobber bad fragment
1576:	05BC  C34320  		JP	OMERR		;and issue fatal OM error
1577:	05BF  CDEB04  	LOAD2:	CALL	RTDMA		;reset DMA address to default
1578:	05C2  11FFFF  		LD	DE,-1
1579:	05C5  CD4137  		CALL	FINDL		;find bottom of source text
1580:	05C8  7E      		LD	A,(HL)
1581:	05C9  CD1502  		CALL	ADAHL
1582:	05CC  F1      		POP	AF		;recover ,R status
1583:	05CD  B7      		OR	A
1584:	05CE  CA4602  		JP	Z,DMODX		;no ,R specified, so reset stacks as usual
1585:	05D1  CD7B27  		CALL	NEW1		;set new eof, cstack, estack
1586:				;and fall through to LOADR to run
1587:	05D4  CDDA05  	LOADR:	CALL	LOADZ		;reset LNNUM and TEXTP
1588:	05D7  C3022B  		JP	RUN		;and RUN the program
1589:	05DA  CD2B37  	LOADZ:	CALL	LNNU0		;reset LNNUM to 0
1590:	05DD  21C33E  		LD	HL,NLNAD
1591:	05E0  22C63F  		LD	(TEXTP),HL	;reset TEXTP to input buffer
1592:	05E3  360D    		LD	(HL),CR		;and <cr> to input buffer
1593:	05E5  C9      		RET
1594:			
1595:	0000          		IF	DEBUG
1621:				ENDIF			;end of ^d conditional
1622:			
1623:			;write char to disk file for ASCII SAVE and PRINT @foo
1624:	05E6  2AA13C  	DKOUT:	LD	HL,(SPTR)	;write one char to buffer
1625:	05E9  71      		LD	(HL),C
1626:	05EA  23      		INC	HL
1627:	05EB  22A13C  		LD	(SPTR),HL	;update pointer
1628:	05EE  7C      		LD	A,H
1629:	05EF  B7      		OR	A
1630:	05F0  C8      		RET	Z		;buffer not full -- done
1631:	05F1  CD0305  		CALL	CDKWT		;write a record
1632:	05F4  218000  	SPRST:	LD	HL,80H
1633:	05F7  22A13C  		LD	(SPTR),HL	;reset SPTR to base of buffer
1634:	05FA  C9      		RET
1635:			
1636:			;read char from disk for ASCII LOAD and [L]INPUT @foo
1637:	05FB  2AA13C  	DLOAD:	LD	HL,(SPTR)	;buffer pointer to HL
1638:	05FE  7C      		LD	A,H
1639:	05FF  B7      		OR	A
1640:	0600  C41F06  		CALL	NZ,DLOA1	;read another record
1641:	0603  7E      		LD	A,(HL)		;fetch next char
1642:	0604  E67F    		AND	7FH		;remove parity bit
1643:	0606  23      		INC	HL
1644:	0607  22A13C  		LD	(SPTR),HL	;move up pointer
1645:	060A  FE1A    		CP	CNTLZ
1646:	060C  C29309  		JP	NZ,POP3		;return unless eof
1647:	060F  31313E  		LD	SP,STACK-4	;OMODE and NEXTS return pushed
1648:	0612  C1      		POP	BC		;recover ,R status and OMODE
1649:	0613  79      		LD	A,C
1650:	0614  32EB3C  		LD	(OMODE),A	;recover OMODE
1651:	0617  78      		LD	A,B
1652:	0618  B7      		OR	A
1653:	0619  CA3D07  		JP	Z,DMOD2		;return to direct mode if no ,R
1654:	061C  C3D405  		JP	LOADR		;else RUN the program
1655:	061F  CDAC05  	DLOA1:	CALL	CDKRD		;read a record
1656:	0622  CDF405  		CALL	SPRST		;reset pointer
1657:	0625  C0      		RET	NZ		;return unless eof
1658:	0626  361A    		LD	(HL),CNTLZ
1659:	0628  C9      		RET
1660:			
1661:			;GTFIL gets <filename> [,A] [,R] and initializes a file control block to
1662:			;<filename>.XYB or <filename>.BAS.  The name may consist of a letter followed
1663:			;by adjacent printable chars, and is padded by spaces to 8 chars.
1664:			;The message addressed by HL is printed (SAVING or LOADING), and
1665:			;the filename is echoed.
1666:			;Retn:	B	0 if no ,R specified, 1 if ,R
1667:			;	C	0 if .BAS (,A), 1 if .XYB (no ,A)
1668:			;In AMD version, filetype is .HEX and C is 0FFH if ,H specified.
1669:			;In AMD version, C is 2 if ,S specified.
1670:	0629  00202020	BLKFN:	DEFB	0, '           ', 0, 0, 0, 0, 80H;blank filename
	      20202020
	      20202020
	      00000000
	      80
1671:	063A  3F3F3F3F	AMBFN:	DEFB	'???????????', 0, 0, 0, 0, 80H;ambiguous filename
	      3F3F3F3F
	      3F3F3F00
	      00000080
1672:	064A  58594280	XYBFT:	DEFB	'XYB', 80H
1673:	064E  42415380	BASFT:	DEFB	'BAS', 80H
1674:	0000          		IF	AMD
1676:				ENDIF
1677:	0652  CD9606  	GTFIL:	CALL	GTFNM		;get unambiguous filename
1678:	0655  115D00  		LD	DE,FCBAD+1
1679:	0658  0E08    		LD	C,8
1680:	065A  CD2F17  		CALL	PRSTR		;echo it
1681:	065D  CD7516  		CALL	WCRLF		;and write crlf
1682:	0660  CD7C18  		CALL	GTCOM		;look for comma
1683:	0663  010100  		LD	BC,1		;0 to B, 1 to C
1684:	0666  DA7F06  		JP	C,GTFL2		;no comma, filetype is .XYB
1685:	0669  1641    		LD	D,'A'
1686:	066B  CD8E18  		CALL	GTD		;look for A
1687:	0000          		IF	AMD
1699:				ELSE			;not AMD
1700:	066E  DA7806  		JP	C,GTFL1		;no A, must be R after comma
1701:				ENDIF
1702:	0671  48      	GTFL0:	LD	C,B		;0 to C to indicate .BAS filetype
1703:	0672  CD7C18  	GTF0A:	CALL	GTCOM		;look for ,R
1704:	0675  DA7F06  		JP	C,GTFL2		;none
1705:	0678  1652    	GTFL1:	LD	D,'R'
1706:	067A  CDA618  		CALL	GTDSN		;skip ,R
1707:	067D  0601    		LD	B,1		;1 to B to indicate ,R
1708:	067F  114A06  	GTFL2:	LD	DE,XYBFT
1709:	0682  79      		LD	A,C
1710:	0683  B7      		OR	A
1711:	0000          		IF	AMD
1716:				ELSE
1717:	0684  C28A06  		JP	NZ,GTFL5
1718:				ENDIF
1719:	0687  114E06  	GTFL4:	LD	DE,BASFT	;filetype .BAS -- LOAD entry point
1720:	068A  C5      	GTFL5:	PUSH	BC		;save status
1721:	068B  216500  		LD	HL,FCBFT
1722:	068E  CDA21B  		CALL	CPYST		;copy filetype to FCB
1723:	0691  2B      		DEC	HL
1724:	0692  3600    		LD	(HL),0		;reset last char
1725:	0694  C1      		POP	BC		;restore status
1726:	0695  C9      		RET			;and return
1727:			
1728:			;GTFNM gets an unambiguous filename.
1729:	0696  CDAA06  	GTFNM:	CALL	GTAFN		;get ambiguous filename
1730:	0699  215D00  		LD	HL,FCBAD+1	;first char location to HL
1731:	069C  0E0B    		LD	C,11		;char count to C
1732:	069E  3E3F    		LD	A,'?'		;? to A
1733:	06A0  BE      	GTFN0:	CP	(HL)		;check if filename char is ?
1734:	06A1  CA3501  		JP	Z,SNERR		;yes, SN error
1735:	06A4  23      		INC	HL
1736:	06A5  0D      		DEC	C
1737:	06A6  C2A006  		JP	NZ,GTFN0	;try next char
1738:	06A9  C9      		RET
1739:			
1740:			;GTAFN gets an ambiguous filename and initializes the default FCB.
1741:			;Leading spaces are removed and lower case is converted to UPPER.
1742:	06AA  112906  	GTAFN:	LD	DE,BLKFN
1743:	06AD  215C00  		LD	HL,FCBAD
1744:	06B0  E5      		PUSH	HL
1745:	06B1  CDA21B  		CALL	CPYST		;copy blank filename to fcb
1746:	06B4  AF      		XOR	A
1747:	06B5  327C00  		LD	(FCBCR),A	;reset current record field to 0
1748:	FFFF          		IF	STRNG
1749:	06B8  CD770C  		CALL	EVALS		;look for filename
1750:	06BB  CDBA01  		CALL	FETCH
1751:	06BE  D23501  		JP	NC,SNERR	;nonstring filename
1752:				ELSE			;parse string ad hoc if nonstring version
1767:				ENDIF
1768:	06C1  E1      		POP	HL		;restore fcb address to HL
1769:	06C2  79      		LD	A,C
1770:	06C3  B7      		OR	A
1771:	06C4  CA0907  		JP	Z,GTAF5		;null file name, take @:*.*
1772:	06C7  1A      	GTAF0:	LD	A,(DE)
1773:	06C8  FE20    		CP	' '
1774:	06CA  C2D506  		JP	NZ,GTAF1	;no more leading spaces
1775:	06CD  13      		INC	DE
1776:	06CE  0D      		DEC	C		;remove a leading space
1777:	06CF  CA0907  		JP	Z,GTAF5		;no chars after spaces, take @:*.*
1778:	06D2  C3C706  		JP	GTAF0		;and try next
1779:	06D5  0D      	GTAF1:	DEC	C
1780:	06D6  CAF306  		JP	Z,GTAF2		;one-char filename, skip : check
1781:	06D9  13      		INC	DE
1782:	06DA  1A      		LD	A,(DE)		;fetch second character
1783:	06DB  1B      		DEC	DE
1784:	06DC  FE3A    		CP	':'
1785:	06DE  C2F306  		JP	NZ,GTAF2	;no disk specified
1786:	06E1  1A      		LD	A,(DE)		;fetch disk name
1787:	06E2  D640    		SUB	'@'		;subtract ASCII bias
1788:	06E4  DA3501  		JP	C,SNERR
1789:	06E7  E61F    		AND	1FH		;convert lower to upper
1790:	06E9  FE05    		CP	5
1791:	06EB  D23501  		JP	NC,SNERR
1792:	06EE  77      		LD	(HL),A		;store disk number in fcb
1793:	06EF  13      		INC	DE
1794:	06F0  13      		INC	DE		;point to char after :
1795:	06F1  0D      		DEC	C
1796:	06F2  0D      		DEC	C		;and update char count
1797:	06F3  0C      	GTAF2:	INC	C		;correct char count in C
1798:	06F4  CA0907  		JP	Z,GTAF5		;no more chars, take *.*
1799:	06F7  23      		INC	HL		;point to first filename char destination
1800:	06F8  0608    		LD	B,8		;max # filename chars to B
1801:	06FA  CD1207  	GTAF3:	CALL	FCHAR		;process filename char
1802:	06FD  05      		DEC	B
1803:	06FE  FA0307  		JP	M,GTAF4		;skip it
1804:	0701  77      		LD	(HL),A
1805:	0702  23      		INC	HL		;store it
1806:	0703  13      	GTAF4:	INC	DE
1807:	0704  0D      		DEC	C
1808:	0705  C8      		RET	Z		;done
1809:	0706  C3FA06  		JP	GTAF3		;else process next
1810:	0709  113A06  	GTAF5:	LD	DE,AMBFN
1811:	070C  215D00  		LD	HL,FCBAD+1
1812:	070F  C3A21B  		JP	CPYST		;copy *.* to fcb
1813:			
1814:	0712  1A      	FCHAR:	LD	A,(DE)	;fetch the char
1815:	0713  E67F    		AND	7FH		;remove parity
1816:	0715  FE23    		CP	'"'+1
1817:	0717  DA3501  		JP	C,SNERR		;space, quote, exclam, controls not allowed
1818:	071A  FE2A    		CP	'*'
1819:	071C  CA2A07  		JP	Z,FCHA1		;expand * to ???...
1820:	071F  FE2E    		CP	'.'
1821:	0721  CA3407  		JP	Z,FCHA2		;filetype follows
1822:	0724  FE60    		CP	60H
1823:	0726  D8      		RET	C		;printable char
1824:	0727  D620    		SUB	20H		;convert lower to upper
1825:	0729  C9      		RET
1826:	072A  05      	FCHA1:	DEC	B
1827:	072B  FA3607  		JP	M,FCHA3
1828:	072E  363F    		LD	(HL),'?'	;store a ?
1829:	0730  23      		INC	HL
1830:	0731  C32A07  		JP	FCHA1
1831:	0734  0603    	FCHA2:	LD	B,3		;filetype char count
1832:	0736  E1      	FCHA3:	POP	HL		;pop FCHAR return
1833:	0737  216500  		LD	HL,FCBFT	;filetype address to HL
1834:	073A  C30307  		JP	GTAF4
1835:			
1836:	0000          		IF	AMD		;routines for HEX LOADing and SAVEing
1921:				ENDIF			;end of AMD conditional
1922:				ENDIF			;end of NOT RTPAK conditional
1923:				ENDIF			;end of CPM conditional
1924:			
1925:			
1926:			;end of CPM
1928:			;DRIVER 10/22/80
1929:			;XYBASIC Interpreter Source Module
1930:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
1931:			;interpreter driver
1932:			
1933:			
1934:			;The interpreter driver has several entry points.
1935:			;DMOD2, after errors, resets SP and falls through to...
1936:			;DMODE, after execution, prints OK prompt, then...
1937:			;DMOD3 is the driver itself.  Gets a line of user text, tokenizes it and
1938:			;either executes it (no line #) or adds it to source text, then gets another.
1939:			
1940:	0000          		IF	COMPL		;return to DMODE boots in COMPL version
1944:				ELSE
1945:	073D  31353E  	DMOD2:	LD	SP,STACK	;reset SP
1946:	0740  CDCF17  	DMODE:	CALL	PRTM0		;print OK message
1947:	0000          		IF	EPSTN
1949:				ELSE
1950:	0743  0D0A4F4B		DEFB	CR, LF, 'OK', CR, LF OR 80H
	      0D8A
1951:				ENDIF
1952:	0749  AF      		XOR	A
1953:	074A  32313D  		LD	(GCHAR),A	;clear GET character
1954:	074D  32C53F  		LD	(TRACL),A	;clear tracing status
1955:	FFFF          		IF	STRNG
1956:	0750  32323D  		LD	(STEMP),A	;clear # string temps in use
1957:				ENDIF
1958:	0753  CD2B37  	DMOD3:	CALL	LNNU0		;reset LNNUM to 0 in case ^C typed
1959:	0756  CDB433  		CALL	GTLIN		;get a line from user
1960:	0759  CDA735  		CALL	TKIZE		;tokenize it
1961:	075C  DABC07  		JP	C,XSTA1		;execute it if no line #
1962:	075F  C4A436  		CALL	NZ,ADDLN	;else add to source text unless <cr>
1963:	0762  C35307  		JP	DMOD3		;and get another line
1964:				ENDIF			;end of COMPL conditional
1965:			
1966:			;NEXTC scans to next command, resets SP and falls through to NEXTS.
1967:	0765  2A593E  	NEXTC:	LD	HL,(CSTKP)
1968:	0768  225B3E  		LD	(ESTKP),HL	;reset ESTACK in case error within expr
1969:	076B  CDB718  		CALL	GTDEL		;scan to delimiter
1970:	076E  31353E  		LD	SP,STACK	;reset SP and fall through to NEXTS
1971:			
1972:			;NEXTS is branched to with TEXTP pointing to a delimiter (: ' <cr>), else it
1973:			;issues a SN error.  Performs break char and interrupt tests.
1974:			;Returns to DMOD1 if at eof.  Moves TEXTP to first char
1975:			;of next statement, updates LNNUM and performs break test.  Then falls through
1976:			;to XSTAT for statement execution.
1977:	0771          	NEXTS:
1978:	0000          		IF	CAMAC AND NONST AND (NOT RTPAK)
1982:				ELSE
1983:	0771  CD953C  		CALL	CSTAT		;test console for break char
1984:	0774  0F      		RRCA
1985:	0775  DCD516  		CALL	C,CTST0		;read char if present
1986:				ENDIF
1987:	FFFF          		IF	NOT WILD
1988:	0778  3AED3C  		LD	A,(INTAD)
1989:	077B  07      		RLCA			;test whether interrupt table empty
1990:	077C  DC7D08  		CALL	C,ITEST		;no, check if interrupt occurs
1991:				ENDIF
1992:	077F  2AC63F  		LD	HL,(TEXTP)
1993:	0782  22543E  		LD	(SAVTP),HL	;save textp
1994:	0785  7E      		LD	A,(HL)		;inline CALL GTCH1 to get next char
1995:	0786  23      		INC	HL
1996:	0787  FE20    		CP	' '
1997:	0789  CA8507  		JP	Z,$-4
1998:	078C  22C63F  		LD	(TEXTP),HL
1999:	078F  FE3A    		CP	':'
2000:	0791  CAB207  		JP	Z,XSTAT		;another statement on same line
2001:	FFFF          		IF	RTPAK OR NOT COMPL;comments are removed if compiled
2002:	0794  FE27    		CP	''''
2003:	0796  CCF129  		CALL	Z,REM		;on-line comment
2004:				ENDIF
2005:	0799  FE0D    		CP	CR
2006:	079B  C23501  		JP	NZ,SNERR	;syntax error -- garbage after statement
2007:	079E  7E      		LD	A,(HL)		;fetch length byte of next line
2008:	079F  B7      		OR	A
2009:	07A0  CA4007  		JP	Z,DMODE		;end of source text
2010:	07A3  23      		INC	HL
2011:	07A4  22E23C  		LD	(LNNUM),HL	;save line number address
2012:	07A7  23      		INC	HL
2013:	07A8  23      		INC	HL
2014:	07A9  7E      		LD	A,(HL)		;fetch break byte
2015:	07AA  23      		INC	HL		;point to first text byte
2016:	07AB  22C63F  		LD	(TEXTP),HL	;set text pointer
2017:	FFFF          		IF	NOT COMPL
2018:	07AE  1F      		RRA			;NB carry was reset above!
2019:	07AF  DCE807  		CALL	C,BTEST		;test for break if bit 0 was set
2020:			
2021:			;XSTAT is branched to with TEXTP pointing to first char of a statement.
2022:			;Performs trace mode test, then falls through to XSTA1 for
2023:			;actual statement execution.
2024:			;XSTA1 is entry point from direct mode, to avoid trace checks.
2025:			;XSTA2 is entry point for THENpart of an IF statement.
2026:	07B2  3AE73C  	XSTAT:	LD	A,(TRACE)
2027:	07B5  32C53F  		LD	(TRACL),A	;set tracing status of current statement
2028:	07B8  B7      		OR	A
2029:	07B9  C45C08  		CALL	NZ,TPRNT	;print trace line # if traceon
2030:				ENDIF			;skip trace tests in COMPL version
2031:	07BC  017107  	XSTA1:	LD	BC,NEXTS
2032:	0000          		IF	COMPL
2034:				ENDIF
2035:	07BF  C5      		PUSH	BC		;stack normal return address to allow RET
2036:	07C0  2AC63F  	XSTA2:	LD	HL,(TEXTP)	;inline CALL GTCHA follows to get next token
2037:	07C3  7E      		LD	A,(HL)
2038:	07C4  23      		INC	HL
2039:	07C5  FE20    		CP	' '
2040:	07C7  CAC307  		JP	Z,$-4
2041:	07CA  22C63F  		LD	(TEXTP),HL
2042:	07CD  B7      		OR	A
2043:	07CE  F22627  		JP	P,LET0		;not token, must be LET or null statement
2044:	0000          		IF	WILD
2047:				ENDIF
2048:	07D1  D688    		SUB	CMDTK		;subtract min token value
2049:	07D3  DA3501  		JP	C,SNERR		;too small, not a command token
2050:	07D6  FE37    		CP	NCMDS		;compare to number of commands
2051:	07D8  D23501  		JP	NC,SNERR	;too big
2052:	07DB  21812F  		LD	HL,CMDTA	;command branch table address to HL
2053:	07DE  87      		ADD	A,A		; * 2 bytes per entry
2054:	07DF  4F      		LD	C,A
2055:	07E0  0600    		LD	B,0
2056:	07E2  09      		ADD	HL,BC		;add offset to base address
2057:	07E3  7E      		LD	A,(HL)		;low order address to A, temporarily
2058:	07E4  23      		INC	HL
2059:	07E5  66      		LD	H,(HL)		;high order addr to H
2060:	07E6  6F      		LD	L,A		;low order addr to L
2061:	07E7  E9      		JP	(HL)		;branch to address
2062:			
2063:			;BTEST checks for line breakpoints.
2064:			;Called before XSTAT, so TRACL is not yet reinitialized.
2065:			;Call:	A	line break byte, RARed once.
2066:	FFFF          		IF	NOT COMPL
2067:	07E8  B7      	BTEST:	OR	A		;test further if more bits set
2068:	07E9  21BC07  		LD	HL,XSTA1	;replace XSTAT return addr with XSTA1 to
2069:	07EC  E3      		EX	(SP),HL		;	avoid resetting TRACL on return
2070:	07ED  CA5C08  		JP	Z,TPRNT		;print break line and return if only bit 0 set
2071:	07F0  0F      		RRCA			;bit 1 of break byte to carry
2072:	07F1  D24708  		JP	NC,BTST2	;no count or variables, check for DMODE break
2073:	07F4  F5      		PUSH	AF		;save break byte, rotated twice
2074:			;Now the symbol table entry containing line break info must be found.
2075:	07F5  2AE23C  		LD	HL,(LNNUM)
2076:	07F8  CD0E04  		CALL	BKNAM		;break entry 'name' to BUFAD
2077:	07FB  3E05    		LD	A,BRKST
2078:	07FD  CD6120  		CALL	STLK0		;look up break entry
2079:	0800  DA3A01  		JP	C,EXERR		;not found -- EX error
2080:			;Next the count (# times before next break) is fetched.
2081:	0803  5E      		LD	E,(HL)
2082:	0804  23      		INC	HL
2083:	0805  56      		LD	D,(HL)		;count to DE
2084:	0806  1B      		DEC	DE		;decrement count
2085:	0807  7A      		LD	A,D
2086:	0808  B3      		OR	E
2087:	0809  C24F08  		JP	NZ,BTST3	;nonzero -- return
2088:			;Counted to zero, so reset count to original value and print break info.
2089:	080C  44      		LD	B,H
2090:	080D  4D      		LD	C,L
2091:	080E  0B      		DEC	BC		;BC points to count
2092:	080F  23      		INC	HL		;HL points to reset
2093:	0810  7E      		LD	A,(HL)
2094:	0811  02      		LD	(BC),A
2095:	0812  03      		INC	BC
2096:	0813  23      		INC	HL
2097:	0814  7E      		LD	A,(HL)
2098:	0815  02      		LD	(BC),A		;copy reset to count
2099:	0816  CD5C08  		CALL	TPRNT		;print break [<line #>]
2100:	0819  F1      		POP	AF		;restore break byte
2101:	081A  0F      		RRCA			;bit 2 of break byte to Carry
2102:	081B  D24608  		JP	NC,BTST1	;skip var printing
2103:			;The break specified a <var list>, so variable values must be printed.
2104:	081E  F5      		PUSH	AF		;save break byte, RRCed 3 times
2105:	081F  23      		INC	HL		;point to var list addr
2106:	0820  7E      		LD	A,(HL)
2107:	0821  23      		INC	HL
2108:	0822  66      		LD	H,(HL)
2109:	0823  6F      		LD	L,A		;varlist address to HL
2110:	0824  22523E  		LD	(TXTP2),HL
2111:	0827  CD3702  		CALL	FLIP		;scan var list
2112:	082A  21E73C  		LD	HL,TRACE
2113:	082D  7E      		LD	A,(HL)
2114:	082E  F5      		PUSH	AF		;save TRACE
2115:	082F  36FF    		LD	(HL),255	;and set TRACE to true
2116:	0831  CD4D01  	BTST0:	CALL	GTLHS		;get var ref
2117:	0834  47      		LD	B,A		;save type
2118:	0835  CD8C01  		CALL	TRVA1		;print = value
2119:	0838  CD7C18  		CALL	GTCOM		;look for another
2120:	083B  D23108  		JP	NC,BTST0	;print more vars
2121:	083E  F1      		POP	AF
2122:	083F  32E73C  		LD	(TRACE),A	;restore trace
2123:	0842  CD3702  		CALL	FLIP		;restore textp
2124:	0845  F1      		POP	AF
2125:			;BTEST returns or breaks to DMODE, depending on whether BREAK specified $.
2126:	0846  07      	BTST1:	RLCA
2127:	0847  E602    	BTST2:	AND	2		;test bit 3 (after two rotates)
2128:	0849  C8      		RET	Z		;no $ -- continue
2129:	084A  3EA5    		LD	A,CSLBK		;line break entry token to A
2130:	084C  C3792B  		JP	STOP1		;$
2131:	084F  72      	BTST3:	LD	(HL),D
2132:	0850  2B      		DEC	HL
2133:	0851  73      		LD	(HL),E		;new value to count
2134:	0852  F1      		POP	AF		;restore break byte
2135:	0853  E1      		POP	HL		;POP the RETurn to XSTA1
2136:	0854  C3B207  		JP	XSTAT		;and return to XSTAT for TRACL initialization
2137:			
2138:			;BPRNT prints <tab>[<line #>] if not TRACL, and is called by NEXT and TRSET.
2139:			;TPRNT prints <tab>[<line #>] and sets TRACL to TRUE.
2140:			;Both preserve BC,DE,HL and clobber A.
2141:	0857  3AC53F  	BPRNT:	LD	A,(TRACL)
2142:	085A  B7      		OR	A
2143:	085B  C0      		RET	NZ		;suppress break printout if traced
2144:	085C          	TPRNT:	PUSH3
2145:	085F  CD7516  		CALL	WCRLF		;write crlf
2146:	0862  3E5B    		LD	A,'['
2147:	0864  CD1F16  		CALL	WRITC		;write [
2148:	0867  2AE23C  		LD	HL,(LNNUM)	;line number address to HL
2149:	086A  CD8D17  		CALL	PRNTL		;print the line
2150:	086D  3E5D    		LD	A,']'		;write ]
2151:	086F  CD1F16  		CALL	WRITC
2152:	0000          		IF	WILD
2154:				ELSE
2155:	0872  CD1A29  		CALL	PRCO1		;tab to next tab stop
2156:				ENDIF
2157:	0875  3EFF    		LD	A,255
2158:	0877  32C53F  		LD	(TRACL),A	;set TRACL to indicate line traced already
2159:	087A  C39309  		JP	POP3
2160:			
2161:				ENDIF			;end of NOT COMPL conditional
2162:			
2163:			;ITEST determines whether interrupt occurs and then returns or interrupts.
2164:			;If no interrupt:
2165:			;Retn:	A,BC,DE	clobbered
2166:			;	HL	address of interrupt table eof
2167:			;If interrupt occurs, ITEST's return address is POPed, a normal statement
2168:			;return address is PUSHed, and a GOSUB to the appropriate line # is executed.
2169:	FFFF          		IF	NOT WILD
2170:	087D  21ED3C  	ITEST:	LD	HL,INTAD	;first byte address to HL
2171:	0880  07      	ITST1:	RLCA			;test enable/suspend bit
2172:	0881  D29A08  		JP	NC,ITST3	;suspended -- look for more
2173:	0884  4F      		LD	C,A		;save $ bit in sign bit of C
2174:	0885  54      		LD	D,H
2175:	0886  5D      		LD	E,L		;save first byte address in DE
2176:	0887  23      		INC	HL		;point to port # byte
2177:	0888  7E      		LD	A,(HL)
2178:	0889  CD3712  		CALL	RDP1		;read the port
2179:	088C  23      		INC	HL		;point to mask byte
2180:	088D  B6      		OR	(HL)
2181:	088E  23      		INC	HL		;point to value byte
2182:	088F  AE      		XOR	(HL)		;compare & clear carry
2183:	0890  CA9408  		JP	Z,ITST2
2184:	0893  37      		SCF			;carry set iff compare not zero
2185:	0894  1F      	ITST2:	RRA			;carry to sign bit of A
2186:	0895  A9      		XOR	C		;sign bit set iff no interrupt
2187:	0896  F2A408  		JP	P,ITST4		;interrupt occurs
2188:	0899  EB      		EX	DE,HL		;restore first byte address to HL
2189:	089A  110800  	ITST3:	LD	DE,8
2190:	089D  19      		ADD	HL,DE		;address next entry
2191:	089E  7E      		LD	A,(HL)		;first byte of table entry to A
2192:	089F  07      		RLCA			;test on/off bit
2193:	08A0  D0      		RET	NC		;no more table entries -- return
2194:	08A1  C38008  		JP	ITST1		;and check it
2195:	08A4  CD0601  	ITST4:	CALL	LINBC		;zero set iff direct mode
2196:	08A7  C8      		RET	Z		;no interrupts from direct mode
2197:	08A8  EB      		EX	DE,HL		;restore first byte address to HL
2198:	08A9  E3      		EX	(SP),HL		;pop ITEST return, push first byte address
2199:	08AA  3E87    		LD	A,CSINT
2200:	08AC  CDAE20  		CALL	CPUSH		;token, textp, lnnum to control stack
2201:	08AF  D1      		POP	DE
2202:	08B0  CDF301  		CALL	MVMDE
2203:	08B3  EB      		EX	DE,HL		;  and to HL
2204:	08B4  7E      		LD	A,(HL)		;fetch first byte
2205:	08B5  E6BF    		AND	0BFH		;suspend interrupt entry
2206:	08B7  77      		LD	(HL),A
2207:	08B8  110700  		LD	DE,7
2208:	08BB  19      		ADD	HL,DE		;address byte 8 of entry
2209:	08BC  CDEE01  		CALL	MVDEM
2210:	08BF  E5      		PUSH	HL		;save entry ptr
2211:	08C0  CD4137  		CALL	FINDL		;look for ENABLE line # address
2212:	08C3  DAC424  		JP	C,ENERR		;none, EN error
2213:	08C6  23      		INC	HL		;point to line # byte
2214:	08C7  E3      		EX	(SP),HL		;push ENABLE line # address, recover ptr
2215:	08C8  CDEE01  		CALL	MVDEM		;desired interrupt routine line # to DE
2216:	08CB  217107  		LD	HL,NEXTS
2217:	08CE  E3      		EX	(SP),HL		;pop ENABLE line # address, push return addr
2218:	08CF  22E23C  		LD	(LNNUM),HL	;set lnnum in case line not found
2219:	08D2  C37826  		JP	GOTO2		;find line #, continue from there
2220:				ENDIF			;end of NOT WILD conditional
2221:			
2222:			
2223:			;end of DRIVER
2225:			;EVAL 06/10/80
2226:			;XYBASIC Interpreter Source Module
2227:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
2228:			;expression evaluator
2229:			
2230:			;EVAL evaluates an expression.
2231:			;Space above the control stack is used as a working stack, called the
2232:			;E(xpression)STACK.  Each expression component already scanned is stored on
2233:			;the ESTACK as a byte identifier specifying its type (e.g. delimiter, paren,
2234:			;unary op) and precedence.  Fns and ops have an addtional byte containing
2235:			;the fn id.  Values are stored as a type byte followed by value bytes.  String
2236:			;values saved in the ESTACK are addressed by string temporaries, for access
2237:			;during garbage collection.
2238:			;Many types of errors may occur during EVAL.
2239:			;SN error occurs if an expression is illformed.
2240:			;OM error occurs if ESTACK overflows the available space.
2241:			;TM error occurs if arguments are of wrong type.
2242:			;FC, OV, BY and similar errors can occur during fn/op execution.
2243:			;EX errors should never occur, and indicate something is wrong.
2244:			;Retn:	Carry	Set iff no <expr> found, i.e. first char parsed is bad
2245:			;	A	type token of result, preserved if Carry
2246:			;	BC, DE	preserved
2247:			;	HL	pointer to type (followed by value bytes), preserved if Carry
2248:			
2249:	08D5          	EVAL:	PUSH4			;save all in case failure
2250:	08D9  0E11    		LD	C,ISDEL+1	;delimiter type/prec to C
2251:			
2252:			;EVAL0 saves the token in C on the ESTACK.  If it is a fn or op,
2253:			;the id in B is also ESTACKed.
2254:	08DB  79      	EVAL0:	LD	A,C		;fetch type/prec
2255:	08DC  FE70    		CP	ISOP1
2256:	08DE  DAE708  		JP	C,EVA0A		;not a fn/op, just ESTACK type/prec
2257:	08E1  48      		LD	C,B		;else id to C
2258:	08E2  47      		LD	B,A		;save type/prec in B
2259:	08E3  CD550C  		CALL	ESPSH		;ESTACK the id
2260:	08E6  48      		LD	C,B		;restore type/prec to C
2261:	08E7  CD550C  	EVA0A:	CALL	ESPSH		;ESTACK the type/prec
2262:			
2263:			;EVAL1 is the 'expecting value' state
2264:			;The next item parsed must be a literal, variable reference or 0-ary fn
2265:			;(evaluated and ESTACKed, then expecting op), or else a fn name, ( or
2266:			;unary op (ESTACKed, then expecting value).  Any other acts as delimiter.
2267:	08EA  2AC63F  	EVAL1:	LD	HL,(TEXTP)
2268:	08ED  7E      	EVA1A:	LD	A,(HL)		;fetch next text char
2269:	08EE  23      		INC	HL
2270:	08EF  FE20    		CP	' '
2271:	08F1  CAED08  		JP	Z,EVA1A		;try next if space
2272:	08F4  FE40    		CP	40H
2273:	08F6  DACE09  		JP	C,EVLIP		;0-3FH, must be literal or (
2274:	08F9  B7      		OR	A
2275:	08FA  F2E409  		JP	P,EVVAR		;40-7FH, must be var ref
2276:	08FD  CD3B0C  		CALL	GTTYP		;type to A, id info to BC
2277:	0900  DA9709  		JP	C,EVALX		;not a fn or op
2278:	0903  22C63F  		LD	(TEXTP),HL	;read the fn or op
2279:	0906  FE70    		CP	ISOP1
2280:	0908  DA490A  		JP	C,EVFN0		; 0-ary or user-defined function
2281:	090B  CADB08  		JP	Z,EVAL0		;ESTACK unary op
2282:	090E  FE80    		CP	ISOP2
2283:	0910  CA0B0A  		JP	Z,EVOPU		;binary op must be unary + or -
2284:	0913  1628    	EVA1B:	LD	D,'('		;otherwise must be a function id
2285:	0915  CDA618  		CALL	GTDSN		;so skip ( after fn
2286:	0918  C3DB08  		JP	EVAL0		;ESTACK type/prec and id and expect value
2287:			
2288:			;EVAL2 pushes a value (type token and value bytes) to ESTACK.
2289:	091B  CDA609  	EVAL2:	CALL	ESVAL		;value to ESTACK
2290:			
2291:			;EVAL3 is the 'expecting op' state.
2292:			;The next item parsed should be a comma [fn(expr,expr)] or
2293:			;binary op [expr op expr] or ) [fn(expr) or fn(expr,expr) or (expr)].
2294:			;Any other is treated as a delimiter.
2295:	091E  2A5B3E  	EVAL3:	LD	HL,(ESTKP)
2296:	0921  7E      		LD	A,(HL)
2297:	0922  E6F0    		AND	TMASK
2298:	0924  57      		LD	D,A		;previous type to D
2299:	0925  7E      		LD	A,(HL)
2300:	0926  E60F    		AND	PMASK
2301:	0928  3C      		INC	A
2302:	0929  5F      		LD	E,A		;previous precedence + 1 to E
2303:	092A  010500  		LD	BC,VBYTS
2304:	092D  09      		ADD	HL,BC		;address new ESTACK top
2305:	092E  225B3E  		LD	(ESTKP),HL	;and update the pointer
2306:	0931  CD6818  		CALL	GTCHO		;look at next item
2307:	0934  CD3B0C  		CALL	GTTYP		;find its type
2308:	0937  DC2B0A  		CALL	C,EVARP		;not an op, must be ) or comma or delimiter
2309:	093A  FE80    		CP	ISOP2		;check if binary op
2310:	093C  C24C09  		JP	NZ,EVAL4	;no, must be delimiter -- reduce
2311:			;Compare precedences of current and previous op and reduce when appropriate.
2312:	093F  79      		LD	A,C		;fetch current type/prec
2313:	0940  E60F    		AND	PMASK
2314:	0942  BB      		CP	E		;compare current to previous+1
2315:	0943  DA4C09  		JP	C,EVAL4		;reduce
2316:	0946  CD5A18  		CALL	GTCHA		;else read current
2317:	0949  C3DB08  		JP	EVAL0		;and stack the info bytes
2318:			
2319:			;At EVAL4 previous .>=. current precedence, so the stacktop is reduced
2320:	094C  2A5B3E  	EVAL4:	LD	HL,(ESTKP)
2321:	094F  01FCFF  		LD	BC,-VBYTS+1
2322:	0952  09      		ADD	HL,BC		;address value on ESTACK
2323:	0953  7A      		LD	A,D		;fetch previous type
2324:	0954  FE10    		CP	ISDEL
2325:	0956  CA8A09  		JP	Z,EVAL5		;delimiter, done
2326:	0959  FE70    		CP	ISOP1
2327:	095B  CA6E0B  		JP	Z,EVOP1		;unary op
2328:	095E  FE80    		CP	ISOP2
2329:	0960  CA760B  		JP	Z,EVOP2		;binary op
2330:	0963  E5      		PUSH	HL		;otherwise current char must be )
2331:	0964  CD5A18  		CALL	GTCHA		;so read it
2332:	0967  FE29    		CP	')'
2333:	0969  C23501  		JP	NZ,SNERR
2334:	096C  E1      		POP	HL		;and restore value pointer
2335:	096D  7A      		LD	A,D		;restore previous type
2336:	096E  FE40    		CP	ISCOM
2337:	0970  CA610B  		JP	Z,EVFN2		;comma -- do a binary function
2338:	0973  FE20    		CP	ISLP
2339:	0975  CA1F0A  		JP	Z,EVPAR		;( <expr> ) becomes <expr>
2340:	0978  FE90    		CP	ISFN1
2341:	097A  CA6E0B  		JP	Z,EVFN1		;unary function
2342:	097D  FE60    		CP	ISUFN
2343:	097F  CA920A  		JP	Z,EVUF1		;unary user-defined function
2344:	0982  FEA0    		CP	ISFN2
2345:	0984  CA3501  		JP	Z,SNERR		;binary fn with one arg
2346:	0987  C33A01  		JP	EXERR		;else fatal EX error -- something wrong
2347:			
2348:			;EVAL5 is the exit from a successful EVAL.
2349:	098A  D1      	EVAL5:	POP	DE		;discard saved PSW value
2350:	098B  D1      		POP	DE		;and also saved HL value
2351:	098C  E5      		PUSH	HL		;save return value for HL
2352:	098D  7E      		LD	A,(HL)		;fetch result type
2353:	098E  2B      		DEC	HL		;NB carry is reset from CPI ISDEL
2354:	098F  2B      		DEC	HL		;HL points to location before delimiter
2355:	0990  225B3E  	EVAL6:	LD	(ESTKP),HL	;reset ESTACK past delimiter
2356:	0993  E1      	POP3:	POP	HL		;value to HL
2357:	0994  D1      		POP	DE
2358:	0995  C1      	POP1:	POP	BC		;restore registers
2359:	0996  C9      		RET			;and done
2360:			
2361:			;EVALX is the abnormal exit from EVAL.  If ESTACK contains only the
2362:			;initial delimiter, returns with Carry.  Otherwise issues SN error.
2363:	0997  2A5B3E  	EVALX:	LD	HL,(ESTKP)
2364:	099A  7E      		LD	A,(HL)		;fetch top ESTACK item
2365:	099B  FE11    		CP	ISDEL+1		;compare to delimiter type/prec
2366:	099D  C23501  		JP	NZ,SNERR	;ESTACK nonempty, SN error
2367:	09A0  2B      		DEC	HL		;else point past delimiter
2368:	09A1  F1      		POP	AF		;restore A
2369:	09A2  37      		SCF			;set Carry
2370:	09A3  C39009  		JP	EVAL6		;restore and return
2371:			
2372:			
2373:			;ESVAL pushes a value to the ESTACK.
2374:			;Entry:	A	type token
2375:			;	BC	value if integer
2376:			;	C,DE	value if string
2377:			;	(TEMP),BCD	value if floating
2378:	09A6  2A5B3E  	ESVAL:	LD	HL,(ESTKP)
2379:	09A9  23      		INC	HL
2380:	09AA  77      		LD	(HL),A		;store type token
2381:	09AB  23      		INC	HL		;point to first value byte
2382:	FFFF          		IF	FLOAT
2383:	09AC  FE02    		CP	SNGST
2384:	09AE  C2B709  		JP	NZ,ESVL1	;not floating
2385:	09B1  3A503E  		LD	A,(TEMP)	;recover value for A
2386:	0000          		IF	F9511
2388:				ELSE
2389:	09B4  C3B00E  		JP	FSTOR		;store floating value on ESTACK and return
2390:				ENDIF
2391:				ENDIF
2392:	09B7          	ESVL1:
2393:	FFFF          		IF	STRNG
2394:	09B7  FE03    		CP	STRST
2395:	09B9  C2C509  		JP	NZ,ESVL2	;not string
2396:	09BC  CD2B2C  		CALL	ATEMP		;assign ESTACK location to string temp
2397:	09BF  71      		LD	(HL),C		;length to ESTACK
2398:	09C0  23      		INC	HL
2399:	09C1  73      		LD	(HL),E
2400:	09C2  23      		INC	HL
2401:	09C3  72      		LD	(HL),D		;location to ESTACK
2402:	09C4  C9      		RET
2403:				ENDIF
2404:	09C5  FE01    	ESVL2:	CP	INTST
2405:	09C7  C23A01  		JP	NZ,EXERR	;not integer
2406:	09CA  71      		LD	(HL),C
2407:	09CB  23      		INC	HL
2408:	09CC  70      		LD	(HL),B		;integer value to ESTACK
2409:	09CD  C9      		RET
2410:			
2411:			;EVLIP looks for ( and stacks if present, else falls through to...
2412:			;EVLIT evaluates a literal, jumps to EVALX if none.
2413:	09CE  FE28    	EVLIP:	CP	'('
2414:	09D0  C2DB09  		JP	NZ,EVLIT	;not (, must be literal
2415:	09D3  22C63F  		LD	(TEXTP),HL	;read the (
2416:	09D6  0E22    		LD	C,ISLP+2	;type/prec to C
2417:	09D8  C3DB08  		JP	EVAL0		;( to ESTACK and expect value next
2418:	09DB  CD5B19  	EVLIT:	CALL	GTLT1		;get literal
2419:	09DE  DA9709  		JP	C,EVALX		;exit if not found
2420:	09E1  C31B09  		JP	EVAL2		;and ESTACK it
2421:			
2422:			;EVVAR evaluates a variable reference.
2423:	09E4  CDA31A  	EVVAR:	CALL	GTVAR		;perform variable reference
2424:	09E7  DA9709  		JP	C,EVALX		;no var
2425:	FFFF          		IF	STRNG
2426:	09EA  FE03    		CP	STRST		;check if type string
2427:	09EC  C2FB09  		JP	NZ,EVVA0	;nonstring
2428:	09EF  EB      		EX	DE,HL
2429:	09F0  2A5B3E  		LD	HL,(ESTKP)
2430:	09F3  23      		INC	HL
2431:	09F4  23      		INC	HL		;point to value destination
2432:	09F5  CD2B2C  		CALL	ATEMP		;assign string temporary
2433:	09F8  EB      		EX	DE,HL		;restore value location
2434:	09F9  3E03    		LD	A,STRST		;and restore type token
2435:				ENDIF
2436:	09FB  44      	EVVA0:	LD	B,H		;EVFN0 entry point
2437:	09FC  4D      		LD	C,L		;source to BC
2438:	09FD  2A5B3E  	EVVA1:	LD	HL,(ESTKP)	;EVPAR entry point
2439:	0A00  23      		INC	HL
2440:	0A01  77      		LD	(HL),A		;ESTACK the type
2441:	0A02  23      		INC	HL		;value destination to HL
2442:	0A03  1E04    		LD	E,VBYTS-1	;byte count to E
2443:	0A05  CD3437  		CALL	MOVD0		;move value to ESTACK
2444:	0A08  C31E09  		JP	EVAL3		;and expect op
2445:			
2446:			;EVOPU deals with unary + and -.
2447:	0A0B  78      	EVOPU:	LD	A,B		;refetch id
2448:	0A0C  FE02    		CP	PLUST-UDFNT
2449:	0A0E  CAEA08  		JP	Z,EVAL1		;ignore unary plus
2450:	0A11  017C00  		LD	BC,ISOP1+12	;id=0 to B, type/prec to C for unary minus
2451:	0A14  FE03    		CP	MINT-UDFNT
2452:	0A16  CADB08  		JP	Z,EVAL0		;stack unary minus
2453:	0A19  CD6B18  		CALL	BAKUP		;else unread the binary op
2454:	0A1C  C39709  		JP	EVALX		;and exit
2455:			
2456:			;EVPAR reduces (<expr>) to <expr>.
2457:	0A1F  7E      	EVPAR:	LD	A,(HL)		;type to A
2458:	0A20  E5      		PUSH	HL
2459:	0A21  2B      		DEC	HL		;address (
2460:	0A22  2B      		DEC	HL		;address previous
2461:	0A23  225B3E  		LD	(ESTKP),HL	;reset ESTACK
2462:	0A26  C1      		POP	BC
2463:	0A27  03      		INC	BC		;value location to BC
2464:	0A28  C3FD09  		JP	EVVA1		;and move down the value
2465:			
2466:			;EVARP deals with ) or comma in expecting op state, loading C with type/prec.
2467:			;The previous item must be checked because of cases like DIM A (2,3).
2468:	0A2B  7A      	EVARP:	LD	A,D		;fetch previous type
2469:	0A2C  FE10    		CP	ISDEL
2470:	0A2E  CA460A  		JP	Z,EVAR1		;previous was delim, treat current as delim
2471:	0A31  78      		LD	A,B		;refetch current
2472:	0A32  0E32    		LD	C,ISRP+2	;right paren type/prec to C
2473:	0A34  FE29    		CP	')'
2474:	0A36  C8      		RET	Z
2475:	0A37  0E43    		LD	C,ISCOM+3	;comma type/prec to C
2476:	0A39  FE2C    		CP	','
2477:	0A3B  C2460A  		JP	NZ,EVAR1	;treat others as delimiters
2478:	0A3E  3E40    		LD	A,ISCOM		;comma type to A
2479:	0A40  BA      		CP	D		;compare to previous type
2480:	0A41  3E80    		LD	A,ISOP2		;for compare on return
2481:	0A43  C0      		RET	NZ		;return unless currant and previous both comma
2482:	0A44  1D      		DEC	E		;to allow successive commas for ternary fns
2483:	0A45  C9      		RET
2484:	0A46  0E10    	EVAR1:	LD	C,ISDEL		;treat any other as delimiter
2485:	0A48  C9      		RET
2486:			
2487:			;EVFN0 evaluates a 0-ary function and evaluates (if 0-ary)
2488:			;or ESTACKs (if N-ary) a user-defined function.
2489:	0A49  FE50    	EVFN0:	CP	ISFN0
2490:	0A4B  78      		LD	A,B		;fn id to A
2491:	0A4C  CA850B  		JP	Z,EXCUT		;execute 0-ary function
2492:			;The current item is a user-defined function call.
2493:	0A4F  CD2D1A  		CALL	GTNAM		;get function name
2494:	0A52  2B      		DEC	HL
2495:	0A53  E5      		PUSH	HL		;save TEXTP
2496:	0A54  3E04    		LD	A,UFNST
2497:	0A56  CD6120  		CALL	STLK0		;look up the fn name
2498:	0A59  DA3501  		JP	C,SNERR		;not found
2499:	0A5C  3A353E  		LD	A,(VARTY)
2500:	0A5F  4F      		LD	C,A		;save desired result type in C
2501:	0A60  1A      		LD	A,(DE)		;fetch type
2502:	0A61  E6E0    		AND	0E0H		;mask off type bytes
2503:	0A63  CA830A  		JP	Z,EXUF0		;execute 0-ary user-defined function
2504:	0A66  FE20    		CP	20H
2505:	0A68  C29213  		JP	NZ,FCERF	;not 0-ary or N-ary, must be active already
2506:			;N-ary user-definable function information is ESTACKed.
2507:	0A6B  C5      		PUSH	BC		;save desired result type
2508:	0A6C  E5      		PUSH	HL
2509:	0A6D  42      		LD	B,D
2510:	0A6E  4B      		LD	C,E		;type byte addr to BC
2511:	0A6F  CD510C  		CALL	EPSH2		;and ESTACKed
2512:	0A72  E1      		POP	HL
2513:	0A73  4E      		LD	C,(HL)
2514:	0A74  23      		INC	HL
2515:	0A75  46      		LD	B,(HL)		;bound var addr to BC
2516:	0A76  CD510C  		CALL	EPSH2		;and ESTACKed
2517:	0A79  C1      		POP	BC		;recover desired result type
2518:	0A7A  CD550C  		CALL	ESPSH		;and ESTACK it
2519:	0A7D  E1      		POP	HL		;pop TEXTP
2520:	0A7E  0E62    		LD	C,ISUFN+2	;type token to C
2521:	0A80  C31309  		JP	EVA1B		;skip ( and ESTACK type
2522:	0A83  7E      	EXUF0:	LD	A,(HL)
2523:	0A84  23      		INC	HL
2524:	0A85  66      		LD	H,(HL)
2525:	0A86  6F      		LD	L,A		;function body address to HL
2526:	0A87  22C63F  		LD	(TEXTP),HL	;reset TEXTP to scan fn body
2527:	0A8A  2A5D3E  		LD	HL,(SYMTA)
2528:	0A8D  E5      		PUSH	HL		;save SYMTA
2529:	0A8E  79      		LD	A,C		;desired result type to A
2530:	0A8F  C3F00A  		JP	EXUFN		;and execute the fn
2531:			
2532:			;EVUFN evaluates a user-defined function.
2533:	0A92  0601    	EVUF1:	LD	B,1		;number of args is in B
2534:	0A94  EB      	EVUFN:	EX	DE,HL		;bound var val addr to DE
2535:	0A95  2AC63F  		LD	HL,(TEXTP)
2536:	0A98  E5      		PUSH	HL		;save TEXTP
2537:	0A99  2A5D3E  		LD	HL,(SYMTA)
2538:	0A9C  E5      		PUSH	HL		;and SYMTA
2539:	0A9D  21F9FF  		LD	HL,-7
2540:	0AA0  19      		ADD	HL,DE
2541:	0AA1  225B3E  		LD	(ESTKP),HL	;reset ESTACK
2542:	0AA4  CDF801  		CALL	MODEM		;fetch type byte addr
2543:	0AA7  D5      		PUSH	DE		;and save it
2544:	0AA8  CDF801  		CALL	MODEM		;bound var addr to DE
2545:	0AAB  EB      		EX	DE,HL
2546:	0AAC  22C63F  		LD	(TEXTP),HL	;bound var addr to TEXTP
2547:	0AAF  EB      		EX	DE,HL
2548:	0AB0  23      		INC	HL
2549:	0AB1  7E      		LD	A,(HL)
2550:	0AB2  F5      		PUSH	AF		;save desired result type
2551:	0AB3  23      		INC	HL
2552:	0AB4  23      		INC	HL		;point to bound var value
2553:	0AB5  E5      	EVUF2:	PUSH	HL		;save value location
2554:	0AB6  C5      		PUSH	BC		;save # args left
2555:	0AB7  E5      		PUSH	HL		;and save value location
2556:	0AB8  CD2D1A  		CALL	GTNAM		;scan the bound var
2557:	0ABB  DA3A01  		JP	C,EXERR
2558:	0ABE  4F      		LD	C,A		;name length to C
2559:	0ABF  CD8F1A  		CALL	FDVA1		;and build a new symbol table entry for it
2560:	0AC2  23      		INC	HL		;point to value destination
2561:	0AC3  E3      		EX	(SP),HL		;save destination, bound var value loc to HL
2562:	0AC4  3A353E  		LD	A,(VARTY)	;bound var type
2563:	0AC7  CDCB0B  		CALL	CNVRT		;convert to desired type
2564:	FFFF          		IF	STRNG
2565:	0ACA  FE03    		CP	STRST
2566:	0ACC  CC612C  		CALL	Z,SCOPV		;free temp and copy to string space if string
2567:				ENDIF
2568:	0ACF  23      		INC	HL		;point to value
2569:	0AD0  E3      		EX	(SP),HL		;destination to HL
2570:	0AD1  C1      		POP	BC		;value loc to BC
2571:	0AD2  CDAC01  		CALL	BYTSD		;byte count to DE
2572:	0AD5  CD3637  		CALL	MOVED		;copy value to destination
2573:	0AD8  C1      		POP	BC		;arg count to B
2574:	0AD9  05      		DEC	B		;and decremented
2575:	0ADA  CAEA0A  		JP	Z,EVUF3		;no more args
2576:	0ADD  162C    		LD	D,','
2577:	0ADF  CDA618  		CALL	GTDSN		;skip comma
2578:	0AE2  E1      		POP	HL		;value location to HL
2579:	0AE3  110600  		LD	DE,VBYTS+1
2580:	0AE6  19      		ADD	HL,DE		;address next value
2581:	0AE7  C3B50A  		JP	EVUF2		;and repeat for next bound var
2582:	0AEA  E1      	EVUF3:	POP	HL		;pop saved value location
2583:	0AEB  CDAD18  		CALL	GTREQ		;skip ) = after last bound var
2584:	0AEE  F1      		POP	AF		;restore desired result type
2585:	0AEF  D1      		POP	DE		;type byte location to DE
2586:				;and execute the fn
2587:			;EXUFN executes a user-defined function.
2588:			;Entry:	A	desired result type
2589:			;	DE	symbol table FN entry type byte addr
2590:			;	Stacked	SYMTA and TEXTP values
2591:	0AF0  F5      	EXUFN:	PUSH	AF
2592:	0AF1  1A      		LD	A,(DE)		;refetch type byte
2593:	0AF2  F680    		OR	80H		;turn on active bit
2594:	0AF4  12      		LD	(DE),A		;and store
2595:	0AF5  EB      		EX	DE,HL
2596:	0AF6  11CE3D  		LD	DE,STACK+STAKM-STAKL
2597:	0AF9  CD0802  		CALL	CPLDE
2598:	0AFC  EB      		EX	DE,HL
2599:	0AFD  39      		ADD	HL,SP		;check for stack overflow
2600:	0AFE  D29213  		JP	NC,FCERF	;fatal FC error, recursion too deep
2601:	0B01  CDD508  		CALL	EVAL		;evaluate the fn body
2602:	0B04  F5      		PUSH	AF		;save Carry status
2603:	0B05  1A      		LD	A,(DE)
2604:	0B06  E67F    		AND	7FH
2605:	0B08  12      		LD	(DE),A		;reset active bit
2606:	0B09  F1      		POP	AF
2607:	0B0A  EB      		EX	DE,HL		;save result location in DE
2608:	0B0B  E1      		POP	HL
2609:	0B0C  7C      		LD	A,H		;desired result type to A
2610:	0B0D  E1      		POP	HL
2611:	0B0E  225D3E  		LD	(SYMTA),HL	;reset SYMTA
2612:	0B11  E1      		POP	HL
2613:	0B12  22C63F  		LD	(TEXTP),HL	;and reset TEXTP
2614:	0B15  DA9213  		JP	C,FCERF		;unsuccessful eval
2615:	0B18  EB      		EX	DE,HL		;recover result location
2616:	0B19  CDCB0B  		CALL	CNVRT		;convert result to desired type
2617:	0B1C  23      		INC	HL		;point to value
2618:	0B1D  C3FB09  		JP	EVVA0		;and ESTACK the result
2619:			
2620:			;EVCOM deals with ternary MID$ and INSTR and N-ary user-defined fns.
2621:	0B20  C1      	EVCOM:	POP	BC		;pop the saved arg address
2622:	0B21  0602    		LD	B,2		;# args seen thus far to B
2623:	0B23  23      	EVCO1:	INC	HL		;point to arg
2624:	0B24  FE62    		CP	ISUFN+2
2625:	0B26  CA940A  		JP	Z,EVUFN		;N-ary user-defined fn
2626:	FFFF          		IF	STRNG
2627:	0B29  FEA2    		CP	ISFN2+2
2628:	0B2B  CA390B  		JP	Z,EVFN3		;binary fn, must be ternary MID$ or INSTR
2629:				ENDIF
2630:	0B2E  FE43    		CP	ISCOM+3		;look for another comma
2631:	0B30  C23501  		JP	NZ,SNERR	;not found, something is wrong
2632:	0B33  04      		INC	B		;bump arg count
2633:	0B34  19      		ADD	HL,DE		;address next token of ESTACK
2634:	0B35  7E      		LD	A,(HL)		;and fetch it
2635:	0B36  C3230B  		JP	EVCO1		;and look for more
2636:			
2637:			;EVFN3 deals with the special cases ternary MID$ and ternary INSTR.
2638:			;Branches to routine IINST3 or MID3 with arg pointers to args 1,2,3
2639:			;in BC,DE,HL and return address to EVAL2 stacked.
2640:	FFFF          		IF	STRNG
2641:	0B39  78      	EVFN3:	LD	A,B
2642:	0B3A  D603    		SUB	3
2643:	0B3C  C23501  		JP	NZ,SNERR	;number of args must be 3
2644:	0B3F  E5      		PUSH	HL
2645:	0B40  2B      		DEC	HL
2646:	0B41  2B      		DEC	HL
2647:	0B42  7E      		LD	A,(HL)		;fetch fn id
2648:	0B43  2B      		DEC	HL
2649:	0B44  225B3E  		LD	(ESTKP),HL	;reset ESTACK
2650:	0B47  110600  		LD	DE,VBYTS+1
2651:	0B4A  211B09  		LD	HL,EVAL2
2652:	0B4D  E3      		EX	(SP),HL		;push return address, arg1 addr to HL
2653:	0B4E  E5      		PUSH	HL
2654:	0B4F  19      		ADD	HL,DE		;address arg2
2655:	0B50  E5      		PUSH	HL
2656:	0B51  19      		ADD	HL,DE		;address arg3
2657:	0B52  D1      		POP	DE
2658:	0B53  C1      		POP	BC
2659:	0B54  FE30    		CP	INSTT-UDFNT
2660:	0B56  CA7E2E  		JP	Z,INST3		;ternary INSTR
2661:	0B59  FE2F    		CP	MIDST-UDFNT
2662:	0B5B  CA6D2F  		JP	Z,MID3		;ternary MID$
2663:	0B5E  C33501  		JP	SNERR		;else SN error
2664:				ENDIF
2665:			
2666:			;EVOP1 evaluates a unary op.
2667:			;EVFN1 evaluates a unary function.
2668:			;EVFN2 evaluates a binary function.
2669:	0B61  E5      	EVFN2:	PUSH	HL		;save arg2 address
2670:	0B62  11F9FF  		LD	DE,-VBYTS-2
2671:	0B65  19      		ADD	HL,DE
2672:	0B66  7E      		LD	A,(HL)		;fetch type/prec byte
2673:	0B67  FEA2    		CP	ISFN2+2
2674:	0B69  C2200B  		JP	NZ,EVCOM	;must be ternary fn or N-ary user-defined fn
2675:	0B6C  23      		INC	HL		;point to arg1
2676:	0B6D  D1      		POP	DE		;arg2 address to DE
2677:	0B6E          	EVOP1:
2678:	0B6E  44      	EVFN1:	LD	B,H
2679:	0B6F  4D      		LD	C,L		;arg1 address to BC
2680:	0B70  2B      		DEC	HL		;to type
2681:	0B71  2B      		DEC	HL		;to id
2682:	0B72  7E      		LD	A,(HL)		;fn id to A
2683:	0B73  C3810B  		JP	EVOPA		;and execute it
2684:			
2685:			;EVOP2 evaluates a binary operator.
2686:	0B76  E5      	EVOP2:	PUSH	HL		;save arg2 address
2687:	0B77  2B      		DEC	HL
2688:	0B78  2B      		DEC	HL
2689:	0B79  7E      		LD	A,(HL)		;op id to A
2690:	0B7A  11FBFF  		LD	DE,-VBYTS
2691:	0B7D  19      		ADD	HL,DE
2692:	0B7E  D1      		POP	DE		;arg2 addr to DE
2693:	0B7F  44      		LD	B,H
2694:	0B80  4D      		LD	C,L		;arg1 addr to BC
2695:	0B81  2B      	EVOPA:	DEC	HL
2696:	0B82  225B3E  		LD	(ESTKP),HL	;reset ESTACK
2697:				;and fall through to EXCUT to execute
2698:			
2699:			;EXCUT executes a function or operator.
2700:			;Entry:	A	fn/op identifier
2701:			;	BC	pointer to arg1 (if any) in expr stack
2702:			;	DE	pointer to arg2 (if any) in expr stack
2703:			;Exit:	A	result token
2704:			;	BC	result if integer
2705:			;	C,DE	result if string
2706:			;	(FACC)	result if floating
2707:			;EXCUT fetches the desired arg types, fn/op address and result type from
2708:			;the fn/op type information table.  If the desired arg type is nonzero
2709:			;(zero means no arg or arg of ambiguous type), the desired and actual
2710:			;arg types are compared and conversion to the desired type performed if
2711:			;necessary.  If the desired arg type is integer, the
2712:			;pointer in BC or DE is replaced by the actual value of the arg.  If
2713:			;the desired arg1 type is floating, the value is loaded to FACC.  Otherwise
2714:			;EXCUT branches to the fn/op routine with the pointers in BC and DE intact.
2715:			;The result type is returned from the fn/op routine if type AMBST, otherwise
2716:			;the specified result type is taken as the actual result type.
2717:	0B85  2600    	EXCUT:	LD	H,0
2718:	0B87  6F      		LD	L,A		;id * 1
2719:	0B88  29      		ADD	HL,HL		;id * 2
2720:	0B89  29      		ADD	HL,HL		;id * 4
2721:	0B8A  CD1502  		CALL	ADAHL		;id * 5
2722:	0B8D  D5      		PUSH	DE
2723:	0B8E  113030  		LD	DE,FUNTA
2724:	0B91  19      		ADD	HL,DE		;+ base address = first info addr
2725:	0B92  D1      		POP	DE
2726:	0B93  7E      		LD	A,(HL)		;fetch arg2 desired type
2727:	0B94  B7      		OR	A
2728:	0B95  CAA10B  		JP	Z,EXCU1		;skip conversion
2729:	0B98  C5      		PUSH	BC		;save arg1 address
2730:	0B99  42      		LD	B,D
2731:	0B9A  4B      		LD	C,E		;arg2 addr to BC
2732:	0B9B  CD240C  		CALL	CNVTB		;convert arg2 to desire type
2733:	0B9E  50      		LD	D,B
2734:	0B9F  59      		LD	E,C		;and return to DE
2735:	0BA0  C1      		POP	BC		;restore arg1
2736:	0BA1  23      	EXCU1:	INC	HL
2737:	0BA2  7E      		LD	A,(HL)		;fetch arg1 desired type
2738:	0BA3  B7      		OR	A
2739:	0BA4  C4240C  		CALL	NZ,CNVTB	;convert arg1
2740:	0BA7  23      		INC	HL
2741:	0BA8  7E      		LD	A,(HL)
2742:	0BA9  23      		INC	HL
2743:	0BAA  E5      		PUSH	HL		;save info pointer
2744:	0BAB  66      		LD	H,(HL)
2745:	0BAC  6F      		LD	L,A		;fn/op address to HL
2746:	0BAD  E5      		PUSH	HL
2747:	0BAE  21B30B  		LD	HL,EXRET
2748:	0BB1  E3      		EX	(SP),HL		;return addr to stack, fn/op addr to HL
2749:	0BB2  E9      		JP	(HL)		;execute it
2750:	0BB3  E1      	EXRET:	POP	HL		;restore info pointer
2751:	0BB4  23      		INC	HL
2752:	0BB5  32503E  		LD	(TEMP),A	;save returned result type info
2753:	0BB8  7E      		LD	A,(HL)
2754:	0000          		IF	F9511
2757:				ENDIF
2758:	0BB9  B7      		OR	A
2759:	0BBA  C21B09  		JP	NZ,EVAL2	;return specified result type
2760:	0BBD  21503E  		LD	HL,TEMP
2761:	0BC0  7E      		LD	A,(HL)		;else pass returned result type
2762:	0BC1  73      		LD	(HL),E		;and save E in TEMP in case floating
2763:	0BC2  C31B09  		JP	EVAL2		;and ESTACK the result
2764:	0000          		IF	F9511
2769:				ENDIF
2770:			
2771:			;CNVRT converts between differing variable types.
2772:			;Call:	A	desired type token
2773:			;	HL	pointer to value to convert
2774:			;Retn:	A,BC,DE,HL	preserved, HL now pointing to converted value.
2775:			;A nonfatal TM error occurs if conversion is impossible.
2776:			;An EX error should never occur.
2777:			;EVALT does an EVALS, then converts result to type LHSTY.
2778:	0BC5  CD770C  	EVALT:	CALL	EVALS
2779:	0BC8  3A563E  		LD	A,(LHSTY)	;fetch desired type, fall through to...
2780:	0BCB  BE      	CNVRT:	CP	(HL)		;compare actual to desired type
2781:	0BCC  C8      		RET	Z		;actual = desired, done
2782:	0BCD  C5      		PUSH	BC
2783:	0BCE  D5      		PUSH	DE
2784:	0BCF  E5      		PUSH	HL		;save registers
2785:	0BD0  47      		LD	B,A		;save desired type in B
2786:	FFFF          		IF	STRNG
2787:	0BD1  FE03    		CP	STRST
2788:	0BD3  CA1D0C  		JP	Z,TMERR		;desired=string, actual=numeric
2789:	0BD6  7E      		LD	A,(HL)		;fetch actual
2790:	0BD7  FE03    		CP	STRST
2791:	0BD9  CA1D0C  		JP	Z,TMERR		;desired=numeric, actual=string
2792:	0BDC  78      		LD	A,B		;restore desired
2793:				ENDIF
2794:	FFFF          		IF	FLOAT
2795:	0BDD  FE01    		CP	INTST
2796:	0BDF  CA020C  		JP	Z,CNVFI		;convert floating to integer
2797:	0BE2  FE02    		CP	SNGST
2798:	0BE4  C23A01  		JP	NZ,EXERR
2799:			;Float an integer value
2800:	0BE7  7E      		LD	A,(HL)		;fetch actual
2801:	0BE8  FE01    		CP	INTST
2802:	0BEA  C23A01  		JP	NZ,EXERR	;must be integer
2803:	0BED  70      		LD	(HL),B		;store new type = floating
2804:	0BEE  23      		INC	HL
2805:	0000          		IF	F9511		;load integer value to 9511 stack
2818:				ELSE
2819:	0BEF  E5      		PUSH	HL
2820:	0BF0  4E      		LD	C,(HL)		;lsbyte of value to C
2821:	0BF1  23      		INC	HL
2822:	0BF2  46      		LD	B,(HL)		;msbyte to B
2823:	0000          		IF	FPBCD
2825:				ELSE
2826:	0BF3  110000  		LD	DE,0		;0 to DE
2827:	0BF6  3E10    		LD	A,16		;scale factor to A
2828:	0BF8  CD8411  		CALL	FLOT1		;float the value
2829:				ENDIF
2830:	0BFB  E1      		POP	HL
2831:	0BFC  CDB00E  		CALL	FSTOR		;and store the floated value
2832:	0BFF  C3180C  		JP	CNVRX		;restore registers and return as below
2833:				ENDIF
2834:			;CNVFI fixes a floating value.
2835:	0C02  7E      	CNVFI:	LD	A,(HL)		;fetch actual
2836:	0C03  FE02    		CP	SNGST
2837:	0C05  C23A01  		JP	NZ,EXERR	;actual must be floating
2838:	0C08  70      		LD	(HL),B		;store new actual type = integer
2839:	0C09  23      		INC	HL
2840:	0C0A  E5      		PUSH	HL		;save location
2841:	0000          		IF	F9511
2846:				ELSE
2847:	0C0B  CDDD0E  		CALL	FLOAD		;load value to FACC
2848:	0C0E  CDC814  		CALL	IINT		;convert to integer
2849:	0C11  DCEB19  		CALL	C,IOVER		;cannot fix, nonfatal OV error
2850:				ENDIF
2851:	0C14  E1      	CNVF1:	POP	HL		;restore value loc
2852:	0C15  71      		LD	(HL),C		;store lsbyte
2853:	0C16  23      		INC	HL
2854:	0C17  70      		LD	(HL),B		;store msbyte
2855:	0C18  E1      	CNVRX:	POP	HL		;restore location
2856:	0C19  7E      		LD	A,(HL)		;type to A
2857:	0C1A  D1      		POP	DE		;restore DE
2858:	0C1B  C1      		POP	BC		;and BC
2859:	0C1C  C9      		RET
2860:				ENDIF
2861:	0C1D          	TMERR:	ERROR	C, T, M		;issue TM error and scan on
2862:			
2863:			;CNVRB is called from EXCUT to perform type conversion on arguments.
2864:			;Call:	A	type token
2865:			;	BC	arg pointer
2866:			;Retn:	A,DE,HL	preserved
2867:			;	BC	arg pointer to converted type, or arg value if integer
2868:			;	FACC	arg value if floating
2869:	0C22  3E01    	CNVBI:	LD	A,INTST		;convert to integer
2870:	0C24  C5      	CNVTB:	PUSH	BC
2871:	0C25  E3      		EX	(SP),HL		;HL saved, pointer to HL
2872:	0C26  CDCB0B  		CALL	CNVRT		;do the conversion
2873:	0C29  FE01    		CP	INTST
2874:	0C2B  CA360C  		JP	Z,CNVB1		;integer, fetch it
2875:	FFFF          		IF	FLOAT
2876:	0C2E  FE02    		CP	SNGST
2877:	0C30  CCE101  		CALL	Z,FETCF		;floating, load the FACC
2878:				ENDIF
2879:	0C33  E3      		EX	(SP),HL		;pointer saved, HL restored
2880:	0C34  C1      		POP	BC		;pointer to BC
2881:	0C35  C9      		RET
2882:	0C36  CDC501  	CNVB1:	CALL	FETCI		;fetch integer value
2883:	0C39  E1      		POP	HL		;restore HL
2884:	0C3A  C9      		RET
2885:			
2886:			;GTTYP gets type and precedence info for a fn/op.
2887:			;Call:	A	token
2888:			;Retn:	A	token type (precedence masked off)
2889:			;	B	fn id (offset into function table), ISDEL if Carry
2890:			;	C	type/precedence byte
2891:			;	DE, HL	preserved
2892:			;	Carry	Set iff (A) not fn/op token
2893:	0C3B  47      	GTTYP:	LD	B,A		;char to B
2894:	0C3C  D6BF    		SUB	UDFNT		;subtract first fn/op token
2895:	0C3E  D8      		RET	C
2896:	0C3F  FE41    		CP	NFUNS		;compare to # of fns
2897:	0C41  3F      		CCF
2898:	0C42  D8      		RET	C
2899:	0C43  47      		LD	B,A		;id to B
2900:	0C44  E5      		PUSH	HL
2901:	0C45  21EF2F  		LD	HL,TYPTA
2902:	0C48  CD1502  		CALL	ADAHL		;addr type/prec byte
2903:	0C4B  4E      		LD	C,(HL)		;type/prec byte to C
2904:	0C4C  E1      		POP	HL
2905:	0C4D  79      		LD	A,C
2906:	0C4E  E6F0    		AND	TMASK		;type to A
2907:	0C50  C9      		RET
2908:			
2909:			;ESPSH pushes C to ESTACK and checks for OM error.
2910:			;Since a value will be ESTACKed next, ESPSH assures that
2911:			;at least VBYTS of space remain above the pushed token.
2912:	0C51  CD550C  	EPSH2:	CALL	ESPSH		;push one byte
2913:	0C54  48      		LD	C,B		;and fall through to push another
2914:	0C55  2A5D3E  	ESPSH:	LD	HL,(SYMTA)
2915:	0C58  11FAFF  		LD	DE,-VBYTS-1
2916:	0C5B  19      		ADD	HL,DE
2917:	0C5C  EB      		EX	DE,HL		;SYMTA - VBYTS - 1 to DE
2918:	0C5D  2A5B3E  		LD	HL,(ESTKP)
2919:	0C60  23      		INC	HL		;ESTKP + 1 to HL
2920:	0C61  CD2902  		CALL	CMDHU
2921:	0C64  DA6C0C  		JP	C,ESERR		;SYMTA <= ESTKP + VBYTS + 1
2922:	0C67  71      		LD	(HL),C		;store value
2923:	0C68  225B3E  		LD	(ESTKP),HL	;and update pointer
2924:	0C6B  C9      		RET
2925:	0C6C  2ACA3F  	ESERR:	LD	HL,(EOFAD)
2926:	0C6F  CD8927  		CALL	CSPST		;reset control stack
2927:	0C72          		ERROR	C, O, M		;issue OM error and scan to next
2928:			
2929:			;EVALS does an EVAL, issues SN error if no <expr> found.
2930:	0C77  CDD508  	EVALS:	CALL	EVAL
2931:	0C7A  D0      		RET	NC
2932:	0C7B  C33501  		JP	SNERR
2933:			
2934:			;IEVAL does an EVAL, converts result to integer and returns it in BC.
2935:	0C7E  E5      	IEVAL:	PUSH	HL
2936:	0C7F  CDD508  		CALL	EVAL
2937:	0C82  DA8D0C  		JP	C,IEVA1		;no expr
2938:	0C85  3E01    		LD	A,INTST
2939:	0C87  CDCB0B  		CALL	CNVRT		;convert to integer
2940:	0C8A  CDC501  		CALL	FETCI		;result integer to BC
2941:	0C8D  E1      	IEVA1:	POP	HL		;restore HL
2942:	0C8E  C9      		RET
2943:			
2944:			;GTEXP does an IEVAL, issues SN error if no <expr> found.
2945:	0C8F  CD7E0C  	GTEXP:	CALL	IEVAL
2946:	0C92  D0      		RET	NC
2947:	0C93  C33501  		JP	SNERR
2948:			
2949:			;GTBEX gets a byte-valued expression.
2950:			;GTCBE gets a comma followed by a byte-valued expression, branches to SN error
2951:			;if comma is not present.
2952:	0C96  CD7C18  	GTCBE:	CALL	GTCOM
2953:	0C99  DA3501  		JP	C,SNERR
2954:	0C9C  CD8F0C  	GTBEX:	CALL	GTEXP
2955:	0C9F  C3FD01  		JP	ISBYT
2956:			
2957:			
2958:			;end of EVAL
2960:			;FINOUT 10/10/80
2961:			;XYBASIC Interpreter Source Module
2962:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
2963:			;floating point input/output routines
2964:			
2965:	FFFF          		IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)
2966:			
2967:			;CONSTANTS
2968:	0CA2  81000000	FPONE:	DEFW	81H, 0		;FLOATING POINT 1.
2969:	0CA6  84200000	FPTEN:	DEFB	84H, 20H, 0, 0	;FLOATING POINT 10.
2970:	0CAA  6C0637BC	FPRND:	DEFB	6CH, 6H, 37H, 0BCH;FLOATING POINT ROUNDER .000 000 5
2971:			
2972:			
2973:			;FLOATING POINT INPUT
2974:	0CAE  5E      	FINP:	LD	E,(HL)		;1ST CHARACTER OF STRING
2975:	0CAF  CD9B0E  		CALL	SVAD		;SET CHARACTER ADDR,PNT FLG,EXP
2976:	0CB2  23      		INC	HL		;TO ADDR THE VALUE SIGN
2977:	0CB3  3680    		LD	(HL),80H	;SET VALUE SIGN POSITIVE
2978:	0CB5  214A3D  		LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
2979:	0CB8  72      		LD	(HL),D		;SET ACC TO ZERO
2980:	0CB9  3A503E  		LD	A,(TEMP)	;FETCH DESIRED VALUE SIGN
2981:	0CBC  B7      		OR	A
2982:	0CBD  7B      		LD	A,E		;1ST CHARACTER
2983:	0CBE  CAC50C  		JP	Z,INP2		;IF POSITIVE DESIRED
2984:	0CC1  21543D  		LD	HL,TMP3		;TO ADDR THE VALUE SIGN
2985:	0CC4  72      		LD	(HL),D		;SET VALUE SIGN NEGATIVE
2986:			;ANALYZE THE NEXT CHARACTER IN THE STRING
2987:	0CC5  0600    	INP2:	LD	B,0		;DIGIT 2ND WORD OR DECIMAL EXPONENT
2988:	0CC7  FE2E    		CP	'.'		;COMPARE TO DECIMAL POINT
2989:	0CC9  CA0E0D  		JP	Z,INP3		;IF DECIMAL POINT
2990:	0CCC  FE45    		CP	'E'		;COMPARE TO EXPONENTIATION SIGN
2991:	0CCE  CA1C0D  		JP	Z,INP4		;IF EXPONENTIATION
2992:	0CD1  FE65    		CP	'E'+20H
2993:	0CD3  CA1C0D  		JP	Z,INP4		;allow lower case e in case untokenized
2994:	0CD6  D630    		SUB	'0'		;SUBTRACT ASCII BIAS
2995:	0CD8  FE0A    		CP	0AH		;SET CARRY IF CHARACTER IS VALID DIGIT
2996:	0CDA  D2670D  		JP	NC,INP8		;IF CHARACTER IS NOT A VALID DIGIT
2997:	0CDD  32593D  		LD	(TMP4),A	;SAVE THE CURRENT DIGIT
2998:	0CE0  21A60C  		LD	HL,FPTEN	;TO ADDR FLOATING POINT 10
2999:	0CE3  CDFA0E  		CALL	FMUL		;MULTIPLY BY TEN
3000:	0CE6  21553D  		LD	HL,VALE		;TO ADDR THE VALUE
3001:	0CE9  CDB00E  		CALL	FSTOR		;STORE OLD VALUE TIMES 10
3002:	0CEC  23      		INC	HL		;TO ADDR THE CURRENT DIGIT
3003:	0CED  7E      		LD	A,(HL)		;CURRENT DIGIT
3004:	0CEE  0600    		LD	B,0		;CLEAR 2ND WORD OF DIGIT
3005:	0CF0  48      		LD	C,B		;CLEAR 3RD WORD OF DIGIT
3006:	0CF1  50      		LD	D,B		;CLEAR 4TH WORD OF DIGIT
3007:	0CF2  1E08    		LD	E,08		;INDICATE DIGIT IS IN REGISTER A
3008:	0CF4  CD7E11  		CALL	FFLOT		;CONVERT DIGIT TO FLOATING POINT
3009:	0CF7  21553D  		LD	HL,VALE		;TO ADDR THE VALUE
3010:	0CFA  CD470F  		CALL	FADD		;ADD OLD VALUE TIMES 10
3011:	0CFD  21533D  		LD	HL,TMP2		;TO ADDR THE DECIMAL POINT FLAG
3012:	0D00  7E      		LD	A,(HL)		;DECIMAL POINT FLAG
3013:	0D01  A7      		AND	A		;SET CONTROL BITS
3014:	0D02  CA070D  		JP	Z,INP1		;IF NO DECIMAL POINT ENCOUNTERED
3015:	0D05  2B      		DEC	HL		;TO ADDR THE INPUT EXPONENT
3016:	0D06  35      		DEC	(HL)		;DECREMENT THE INPUT EXPONENT
3017:	0D07  CDA60E  	INP1:	CALL	CHAD		;GET ADDR OF NEXT CHARACTER
3018:	0D0A  7E      		LD	A,(HL)		;NEXT CHAR
3019:	0D0B  C3C50C  		JP	INP2		;TO PROCESS NEXT CHARACTER
3020:	0D0E  21533D  	INP3:	LD	HL,TMP2		;TO ADDR THE DECIMAL POINT FLAG
3021:	0D11  AE      		XOR	(HL)		;ZERO IF FLAG SET
3022:	0D12  77      		LD	(HL),A		;SET DECIMAL POINT FLAG
3023:	0D13  C2070D  		JP	NZ,INP1		;IF FLAG NOT ALREADY SET
3024:	0D16  2A503D  		LD	HL,(ADRL)	;READDRESS THE INPUT STRING
3025:	0D19  C3670D  		JP	INP8		;IF 2ND DECIMAL POINT
3026:			
3027:			;PROCESS DECIMAL EXPONENT
3028:	0D1C  CDA60E  	INP4:	CALL	CHAD		;GET ADDR OF NEXT CHARACTER
3029:	0D1F  7E      		LD	A,(HL)		;NEXT CHARACTER OF STRING
3030:	0D20  1E00    		LD	E,0		;possible exponent sign (-) to E
3031:	0D22  FEC2    		CP	MINT		;COMPARE TO MINUS CHARACTER
3032:	0D24  CA370D  		JP	Z,INP5		;IF MINUS SIGN
3033:	0D27  FE2D    		CP	'-'
3034:	0D29  CA370D  		JP	Z,INP5		;allow untokenized minus
3035:	0D2C  5F      		LD	E,A		;else sign positive (nonzero) to E
3036:	0D2D  FEC1    		CP	PLUST		;COMPARE TO PLUS CHARACTER
3037:	0D2F  CA370D  		JP	Z,INP5		;plus
3038:	0D32  FE2B    		CP	'+'		;check for untoenized plus
3039:	0D34  C2390D  		JP	NZ,INP6		;IF NOT PLUS SIGN
3040:	0D37  23      	INP5:	INC	HL		;TO ADDR THE NEXT CHARACTER
3041:	0D38  7E      		LD	A,(HL)		;NEXT CHARACTER OF STRING
3042:	0D39  D630    	INP6:	SUB	'0'		;SUBTRACT ASCII BIAS
3043:	0D3B  CA370D  		JP	Z,INP5		;IGNORE LEADING ZERO ON EXPONENT
3044:	0D3E  0600    		LD	B,0		;POSSIBLE DECIMAL EXPONENT
3045:	0D40  FE0A    		CP	0AH		;SET CARRY IF A DECIMAL DIGIT
3046:	0D42  D2670D  		JP	NC,INP8		;IF NOT A DECIMAL DIGIT
3047:	0D45  47      		LD	B,A		;DECIMAL EXPONENT EQUAL DIGIT
3048:	0D46  23      		INC	HL		;TO ADDR THE NEXT CHARACTER
3049:	0D47  7E      		LD	A,(HL)		;NEXT CHARACTER OF STRING
3050:	0D48  D630    		SUB	'0'		;SUBTRACT ASCII BIAS
3051:	0D4A  FE0A    		CP	0AH		;SET CARRY IF A DECIMAL DIGIT
3052:	0D4C  D2600D  		JP	NC,INP7		;IF NOT A DECIMAL DIGIT
3053:	0D4F  23      		INC	HL		;ADDRESS NEXT CHAR
3054:	0D50  4F      		LD	C,A		;LSD OF DECIMAL EXPONENT
3055:	0D51  7E      		LD	A,(HL)		;FETCH NEXT
3056:	0D52  D630    		SUB	'0'		;SUBTRACT ASCII BIAS
3057:	0D54  FE0A    		CP	0AH
3058:	0D56  DA940D  		JP	C,INPOV		;THREE DIGITS, SCAN REMAINING AND RETURN 0 OR OV
3059:	0D59  78      		LD	A,B		;MSD OF DECIMAL EXPONENT
3060:			;FORM COMPLETE DECIMAL EXPONENT
3061:	0D5A  87      		ADD	A,A		;2*MSD
3062:	0D5B  87      		ADD	A,A		;4*MSD
3063:	0D5C  80      		ADD	A,B		;5*MSD
3064:	0D5D  87      		ADD	A,A		;10*MSD
3065:	0D5E  81      		ADD	A,C		;10*MSD + LSD
3066:	0D5F  47      		LD	B,A		;DECIMAL EXPONENT
3067:	0D60  7B      	INP7:	LD	A,E		;SIGN OF DECIMAL EXPONENT
3068:	0D61  A7      		AND	A		;SET CONTROL BITS
3069:	0D62  C2670D  		JP	NZ,INP8		;IF SIGN POSITIVE
3070:	0D65  90      		SUB	B		;COMPLEMENT DECIMAL EXPONENT
3071:	0D66  47      		LD	B,A		;DECIMAL EXPONENT
3072:	0D67  22C63F  	INP8:	LD	(TEXTP),HL
3073:	0D6A  21543D  		LD	HL,TMP3		;TO ADDR THE INPUT SIGN
3074:	0D6D  4E      		LD	C,(HL)		;INPUT SIGN
3075:	0D6E  214B3D  		LD	HL,ACCS		;TO ADDR THE ACC SIGN
3076:	0D71  71      		LD	(HL),C		;ACC SIGN
3077:	0D72  78      		LD	A,B		;DECIMAL EXPONENT
3078:			
3079:			;CONVERT DECIMAL EXPONENT TO BINARY
3080:	0D73  21523D  	INP9:	LD	HL,TMP1		;TO ADDR THE DECIMAL EXPONENT
3081:	0D76  86      		ADD	A,(HL)		;ADJUST DECIMAL EXPONENT
3082:	0D77  CAC90E  		JP	Z,FTEST		;IF DECIMAL EXPONENT IS ZERO
3083:	0D7A  77      		LD	(HL),A		;CURRENT DECIMAL EXPONENT
3084:	0D7B  21A60C  		LD	HL,FPTEN	;TO ADDR FLOATING POINT 10
3085:	0D7E  F2890D  		JP	P,INP10		;IF MULTIPLY REQUIRED
3086:	0D81  CD250F  		CALL	FDIV		;DIVIDE BY 10
3087:	0D84  3E01    		LD	A,1		;TO INCREMENT THE DECIMAL EXPONENT
3088:	0D86  C3730D  		JP	INP9		;TO TEST FOR COMPLETION
3089:	0D89  CDFA0E  	INP10:	CALL	FMUL		;MULTIPLY BY 10
3090:	0D8C  3EFF    		LD	A,-1		;TO DECREMENT THE DECIMAL EXPONENT
3091:	0D8E  D2730D  		JP	NC,INP9		;TO TEST FOR COMPLETION
3092:	0D91  C3390F  		JP	FOVER		;OV ERROR ON OVERFLOW AND RETURN FPMAX
3093:	0D94  23      	INPOV:	INC	HL
3094:	0D95  7E      		LD	A,(HL)
3095:	0D96  D630    		SUB	'0'
3096:	0D98  FE0A    		CP	0AH
3097:	0D9A  DA940D  		JP	C,INPOV		;SCAN REMAINING EXPONENT DIGITS
3098:	0D9D  22C63F  		LD	(TEXTP),HL	;RESET TEXTP TO FIRST NONDIGIT
3099:	0DA0  7B      		LD	A,E		;SIGN OF DECIMAL EXPONENT
3100:	0DA1  B7      		OR	A
3101:	0DA2  CAB80E  		JP	Z,FZRO		;LARGE NEGATIVE EXPONENT, RETURN 0.
3102:	0DA5  C3390F  		JP	FOVER		;POSITIVE, ISSUE FLOATING OVERFLOW ERROR
3103:			
3104:			
3105:			;FLOATING POINT OUTPUT
3106:			;The contents of the FACC is not preserved
3107:	0DA8  215E3E  	FOUT:	LD	HL,BUFAD-1	;USE BUFAD TO STORE CONVERTED VALUE
3108:	0DAB  CD9B0E  		CALL	SVAD		;SET CHARACTER ADDRESS, DIGIT COUNT, DECIMAL EXPONENT
3109:	0DAE  CDC90E  		CALL	FTEST		;LOAD ACC TO REGISTERS
3110:	0DB1  21553D  		LD	HL,VALE		;TO ADDR THE ACC SAVE AREA
3111:	0DB4  CDB00E  		CALL	FSTOR		;REGISTER STORE
3112:			
3113:			;OUTPUT SIGN CHARACTER
3114:	0DB7  CDA60E  		CALL	CHAD		;GET ADDR OF CHARACTER
3115:	0DBA  3620    		LD	(HL),' '	;STORE SPACE CHARACTER
3116:	0DBC  A7      		AND	A		;SET CONTROL BITS
3117:	0DBD  CAE30D  		JP	Z,OUT3		;IF ACC IS ZERO
3118:	0DC0  5F      		LD	E,A		;ACC EXPONENT
3119:	0DC1  78      		LD	A,B		;ACC SIGN AND 1ST FRACTION
3120:	0DC2  A7      		AND	A		;SET CONTROL BITS
3121:	0DC3  7B      		LD	A,E		;ACC EXPONENT
3122:	0DC4  F2C90D  		JP	P,OUT0		;IF ACC IS POSITIVE
3123:	0DC7  362D    		LD	(HL),'-'	;CHANGE SIGN TO MINUS
3124:			;CHECK IF ACCUMULATOR IN RANGE .01 TO 1 TO ALLOW .01
3125:	0DC9  FE7A    	OUT0:	CP	7AH		;COMPARE TO .01 EXPONENT
3126:	0DCB  DAD30D  		JP	C,OUT1		;TOO SMALL, SCALE NORMALLY
3127:	0DCE  FE81    		CP	81H
3128:	0DD0  DAF40D  		JP	C,OUT5		;SKIP SCALING IF BETWEEN .01 AND 1
3129:			;SCALE ACCUMULATOR TO 0.1 TO 1.0 RANGE
3130:	0DD3  FE7E    	OUT1:	CP	7EH		;COMPARE TO SMALL EXPONENT
3131:	0DD5  21A60C  	OUT2:	LD	HL,FPTEN	;TO ADDR FLOATING POINT 10
3132:	0DD8  DAEA0D  		JP	C,OUT4		;IF EXPONENT TOO SMALL
3133:	0DDB  FE81    		CP	81H		;COMPARE TO LARGE EXPONENT
3134:	0DDD  DAF40D  		JP	C,OUT5		;IF EXPONENT NOT TOO LARGE
3135:	0DE0  CD250F  		CALL	FDIV		;DIVIDE BY 10
3136:	0DE3  21533D  	OUT3:	LD	HL,TMP2		;TO ADDR THE DECIMAL EXPONENT
3137:	0DE6  34      		INC	(HL)		;INCREMENT DECIMAL EXPONENT
3138:	0DE7  C3D50D  		JP	OUT2		;TO TEST FOR SCALING COMPLETE
3139:	0DEA  CDFA0E  	OUT4:	CALL	FMUL		;MULTIPLY BY 10
3140:	0DED  21533D  		LD	HL,TMP2		;TO ADDR THE DECIMAL EXPONENT
3141:	0DF0  35      		DEC	(HL)		;DECREMENT DECIMAL EXPONENT
3142:	0DF1  C3D30D  		JP	OUT1		;TO TEST FOR SCALING COMPLETE
3143:			
3144:			;ROUND THE VALUE BY ADDING 0.000 000 5
3145:	0DF4  CDC10E  	OUT5:	CALL	FABS		;MAKE ACC POSITIVE
3146:	0DF7  21AA0C  		LD	HL,FPRND	;TO ADDR THE ROUNDER
3147:	0DFA  CD470F  		CALL	FADD		;ADD THE ROUNDER
3148:	0DFD  FE81    		CP	81H		;CHECK FOR OVERFLOW
3149:	0DFF  D2D50D  		JP	NC,OUT2		;IF EXPONENT TOO LARGE
3150:			
3151:			;SET DIGIT COUNTS
3152:	0E02  21533D  		LD	HL,TMP2		;TO ADDR THE DECIMAL EXPONENT
3153:	0E05  7E      		LD	A,(HL)		;DECIMAL EXPONENT
3154:	0E06  5F      		LD	E,A		;DIGITS BEFORE DECIMAL EXPONENT
3155:	0E07  FE07    		CP	7		;COMPARE TO LARGE EXPONENT
3156:	0E09  DA0E0E  		JP	C,OUT6		;IF EXPONENT IN RANGE
3157:	0E0C  1E01    		LD	E,1		;DIGITS BEFORE DECIMAL EXPONENT
3158:	0E0E  93      	OUT6:	SUB	E		;ADJUST DECIMAL EXPONENT
3159:	0E0F  77      		LD	(HL),A		;DECIMAL EXPONENT
3160:	0E10  3E06    		LD	A,6		;TOTAL NUMBER OF DIGITS
3161:	0E12  93      		SUB	E		;DIGITS AFTER DECIMAL POINT
3162:	0E13  23      		INC	HL		;TO ADDR THE 2ND DIGIT COUNT
3163:	0E14  77      		LD	(HL),A		;DIGITS AFTER DECIMAL POINT
3164:	0E15  1D      		DEC	E		;DECREMENT THE DIGIT COUNT
3165:	0E16  7B      		LD	A,E		;DIGITS BEFORE THE DECIMAL POINT
3166:			
3167:			;OUTPUT SIGNIFICANT DIGITS
3168:	0E17  21523D  	OUT7:	LD	HL,TMP1		;TO ADDR THE DIGIT COUNT
3169:	0E1A  86      		ADD	A,(HL)		;ADJUST THE DIGIT COUNT
3170:	0E1B  77      		LD	(HL),A		;NEW DIGIT COUNT
3171:	0E1C  FA3B0E  		JP	M,OUT8		;IF COUNT RUN OUT
3172:	0E1F  21A60C  		LD	HL,FPTEN	;TO ADDR FLOATING POINT 10
3173:	0E22  CDFA0E  		CALL	FMUL		;MULTIPLY BY 10
3174:	0E25  1E08    		LD	E,8		;TO PLACE DIGIT IN REGISTER 'A'
3175:	0E27  CD9411  		CALL	FFIX		;CONVERT TO FIXED FORMAT
3176:	0E2A  CDA60E  		CALL	CHAD		;GET CHARACTER ADDRESS
3177:	0E2D  C630    		ADD	A,'0'		;ADD ASCII BIAS
3178:	0E2F  77      		LD	(HL),A		;OUTPUT DECIMAL DIGIT
3179:	0E30  AF      		XOR	A		;CLEAR CURRENT DIGIT
3180:	0E31  1E08    		LD	E,8		;BINARY SCALING FACTOR
3181:	0E33  CD7E11  		CALL	FFLOT		;RESTORE VALUE MINUS DIGIT
3182:	0E36  3EFF    		LD	A,-1		;TO ADJUST THE DIGIT COUNT
3183:	0E38  C3170E  		JP	OUT7		;LOOP FOR NEXT DIGIT
3184:	0E3B  21543D  	OUT8:	LD	HL,TMP3		;TO ADDR 2ND DIGIT COUNT
3185:	0E3E  7E      		LD	A,(HL)		;DIGITS AFTER DECIMAL POINT
3186:	0E3F  36FF    		LD	(HL),-1		;SET 2ND COUNT NEGATIVE
3187:	0E41  A7      		AND	A		;SET CONTROL BITS
3188:	0E42  FA4D0E  		JP	M,OUT9		;IF 2ND COUNT RAN OUT
3189:	0E45  CDA60E  		CALL	CHAD		;CHARACTER ADDRESS ROUTINE
3190:	0E48  362E    		LD	(HL),'.'	;STORE DECIMAL POINT
3191:	0E4A  C3170E  		JP	OUT7		;LOOP FOR NEXT DIGIT
3192:	0E4D  2A503D  	OUT9:	LD	HL,(ADRL)	;ADDR THE LAST DIGIT STORED
3193:	0E50  7E      	OUT9A:	LD	A,(HL)		;FETCH IT
3194:	0E51  2B      		DEC	HL
3195:	0E52  FE30    		CP	'0'
3196:	0E54  CA500E  		JP	Z,OUT9A		;SUPPRESS TRAILING ZEROS
3197:	0E57  FE2E    		CP	'.'
3198:	0E59  CA5D0E  		JP	Z,OUT9B		;SUPPRESS TRAILING DECIMAL POINT
3199:	0E5C  23      		INC	HL		;READDRESS LAST DIGIT
3200:	0E5D  22503D  	OUT9B:	LD	(ADRL),HL	;STORE FUDGED POINTER
3201:	0E60  21533D  		LD	HL,TMP2		;ADDR THE DECIMAL EXPONENT
3202:	0E63  7E      		LD	A,(HL)
3203:	0E64  B7      		OR	A
3204:	0E65  CA950E  		JP	Z,OUT13		;IF DECIMAL EXPONENT IS ZERO
3205:			
3206:			;OUTPUT DECIMAL EXPONENT
3207:	0E68  062B    		LD	B,'+'		;PLUS SIGN
3208:	0E6A  F2720E  		JP	P,OUT10		;IF EXPONENT IS POSITIVE
3209:	0E6D  062D    		LD	B,'-'		;MINUS SIGN
3210:	0E6F  4F      		LD	C,A		;NEGATIVE EXPONENT
3211:	0E70  AF      		XOR	A		;ZERO
3212:	0E71  91      		SUB	C		;COMPLEMENT THE EXPONENT
3213:	0E72  0E2F    	OUT10:	LD	C,'0'-1		;EMBRYO ASCII TENS DIGIT
3214:	0E74  0C      	OUT11:	INC	C		;INCREMENT TENS DIGIT
3215:	0E75  D60A    		SUB	0AH		;REDUCE REMAINDER
3216:	0E77  D2740E  		JP	NC,OUT11	;IF MORE TENS
3217:	0E7A  C63A    		ADD	A,3AH		;RESTORE AND ADD ASCII BIAS
3218:	0E7C  57      		LD	D,A		;UNITS DIGIT
3219:	0E7D  3E45    		LD	A,'E'		;EXPONENT SIGN
3220:	0E7F  CDA60E  		CALL	CHAD		;GET CHARACTER ADDRESS
3221:	0E82  CDB00E  		CALL	FSTOR		;STORE LAST 4 CHARACTERS
3222:	0E85  23      	OUT12:	INC	HL		;LAST ADDR + 1
3223:	0E86  7D      		LD	A,L		;LAST + 1 TO A
3224:	0E87  F5      		PUSH	AF		;SAVE LAST+1
3225:	0E88  21553D  		LD	HL,VALE		;TO ADDR THE ACC SAVE AREA
3226:	0E8B  CDDD0E  		CALL	FLOAD		;RESTORE ACC
3227:	0E8E  F1      		POP	AF		;RESTORE LAST+1
3228:	0E8F  115F3E  		LD	DE,BUFAD	;FIRST TO DE
3229:	0E92  93      		SUB	E		;LAST+1 - FIRST = LENGTH TO A
3230:	0E93  4F      		LD	C,A		;AND TO C
3231:	0E94  C9      		RET
3232:			
3233:			;EXPONENT IS ZERO, DONE
3234:	0E95  2A503D  	OUT13:	LD	HL,(ADRL)	;ADDRESS OF LAST CHAR TO HL
3235:	0E98  C3850E  		JP	OUT12		;AND CONTINUE AS ABOVE
3236:			
3237:			;SAVE THE CHARACTER STRING ADDRESS
3238:	0E9B  7D      	SVAD:	LD	A,L		;CHARACTER STRING WORD
3239:	0E9C  44      		LD	B,H		;CHARACTER STRING BANK
3240:	0E9D  0E00    		LD	C,0		;INPUT EXPONENT OR DIGIT COUNT
3241:	0E9F  51      		LD	D,C		;DECIMAL POINT FLAG OR DECIMAL EXPONENT
3242:	0EA0  21503D  		LD	HL,ADRL		;TO ADDR THE CHARACTER STRING ADDRESS
3243:	0EA3  C3B00E  		JP	FSTOR		;STORE A, B, C, AND D AND RETURN THRU STR
3244:			
3245:			;OBTAIN THE ADDRESS OF THE NEXT CHARACTER
3246:	0EA6  2A503D  	CHAD:	LD	HL,(ADRL)	;TO ADDR THE CHARACTER STRING ADDRESS
3247:	0EA9  23      		INC	HL		;BUMP IT
3248:	0EAA  22503D  		LD	(ADRL),HL	;RESTORE IT
3249:	0EAD  C9      		RET			;RETURN TO CALLER
3250:			
3251:				ENDIF			;end of FLOAT conditional
3252:			
3253:			;end of FINOUT
3255:			;FMATH 06/09/80
3256:			;XYBASIC Interpreter Source Module
3257:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
3258:			;floating point math package
3259:			
3260:			
3261:	FFFF          		IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)
3262:			
3263:			;The floating point (FP) math package operates on normalized floating
3264:			;binary point numbers stored in four consecutive bytes of memory.
3265:			;Byte 1			Binary exponent E
3266:			;Byte 2 bit 7		Sign S
3267:			;Byte 2 bits 6-0	Mantissa msb M1
3268:			;Byte 3			Mantissa 2sb M2
3269:			;Byte 4			Mantissa lsb M3
3270:			;If E is 0, the value is 0 and bytes 2-4 are meaningless;  otherwise
3271:			;E represents the binary exponent with a bias of 80H.
3272:			;The sign bit S is 0 for positive, 1 for negative.
3273:			;The complete mantissa is M1-M3 with a hidden 1 replacing S in M1 bit 7
3274:			;and the binary point located left of M1.  Thus a nonzero value is
3275:			; S * [2^(E-80H)] * [(80H+M1) * (2^-8)] * [M2 * (2^-16)] * [M3 * (2^-24)].
3276:			
3277:			;The floating point accumulator (FACC) contains a floating point value
3278:			;unpacked into five consecutive bytes of RAM starting at ACCE.
3279:			;Byte 1 (ACCE)		Exponent E, biased as above
3280:			;Byte 2 (ACCS)		Sign, 0 if negative and 80H if positive
3281:			;Bytes 3-5 (ACC1-ACC3)	Mantissa with hidden 1 restored in ACC1
3282:			
3283:			;FLOATING POINT STORE
3284:	0EAE  73      	FSTR0:	LD	(HL),E		;STORE ZEROETH WORD
3285:	0EAF  23      		INC	HL		;TO ADDR THE 1ST WORD
3286:	0EB0  77      	FSTOR:	LD	(HL),A		;STORE 1ST WORD
3287:	0EB1  23      	FSTR1:	INC	HL		;TO ADDR THE 2ND WORD
3288:	0EB2  70      		LD	(HL),B		;STORE 2ND WORD
3289:	0EB3  23      		INC	HL		;TO ADDR THE 3RD WORD
3290:	0EB4  71      		LD	(HL),C		;STORE 3RD WORD
3291:	0EB5  23      		INC	HL		;TO ADDR THE 4TH WORD
3292:	0EB6  72      		LD	(HL),D		;STORE 4TH WORD
3293:	0EB7  C9      		RET			;RETURN TO CALLER
3294:			
3295:			;FLOATING POINT ZERO
3296:	0EB8  214A3D  	FZRO:	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
3297:	0EBB  AF      		XOR	A		;ZERO
3298:	0EBC  77      		LD	(HL),A		;CLEAR ACC EXPONENT
3299:	0EBD  C9      		RET			;RETURN TO CALLER
3300:			
3301:			;FLOATING POINT CHANGE SIGN
3302:	0EBE  3E80    	FCHS:	LD	A,80H		;MASK TO CHANGE ACC SIGN BIT
3303:	0EC0  06      		DEFB	6		;THIS MVI A, SAVES A JUMP
3304:				;AND CONTINUE AS IN FABS
3305:			
3306:			;FLOATING POINT ABSOLUTE VALUE
3307:	0EC1  AF      	FABS:	XOR	A		;NB MUST BE 1-BYTE INSTRUCTION
3308:	0EC2  214B3D  		LD	HL,ACCS		;TO ADDR THE ACC SIGN
3309:	0EC5  A6      		AND	(HL)		;COMPLIMENT OF SIGN
3310:	0EC6  EE80    		XOR	80H		;COMPLIMENT THE SIGN BIT
3311:	0EC8  77      		LD	(HL),A		;ACC SIGN
3312:			
3313:			;FLOATING POINT TEST
3314:	0EC9  214A3D  	FTEST:	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
3315:	0ECC  7E      		LD	A,(HL)		;ACC EXPONENT
3316:	0ECD  A7      		AND	A		;SET CONTROL BITS
3317:	0ECE  CAB80E  		JP	Z,FZRO		;IF ACC IS ZERO
3318:	0ED1  5F      		LD	E,A		;ACC EXPONENT
3319:	0ED2  23      		INC	HL		;TO ADDR THE ACC SIGN
3320:	0ED3  7E      		LD	A,(HL)		;ACC SIGN
3321:	0ED4  23      		INC	HL		;TO ADDR THE ACC 1ST FRACTION
3322:	0ED5  AE      		XOR	(HL)		;ACC SIGN AND 1ST FRACTION
3323:	0ED6  23      		INC	HL		;TO ADDR THE ACC 2ND FRACTION
3324:	0ED7  4E      		LD	C,(HL)		;ACC 2ND FRACTION
3325:	0ED8  23      		INC	HL		;TO ADDR THE ACC 3RD FRACTION
3326:	0ED9  56      		LD	D,(HL)		;ACC 3RD FRACTION
3327:	0EDA  C3EC0F  		JP	FADD8		;TO SET EXIT CONDITIONS
3328:			
3329:			;FLOATING POINT LOAD
3330:	0EDD  7E      	FLOAD:	LD	A,(HL)		;OPERAND EXPONENT
3331:	0EDE  A7      		AND	A		;SET CONTROL BITS
3332:	0EDF  CAB80E  		JP	Z,FZRO		;IF OPERAND IS ZERO
3333:	0EE2  5F      		LD	E,A		;OPERAND EXPONENT
3334:	0EE3  23      		INC	HL		;TO ADDR THE OPERAND SIGN AND 1ST FRACTION
3335:	0EE4  7E      		LD	A,(HL)		;OPERAND SIGN AND 1ST FRACTION
3336:	0EE5  23      		INC	HL		;TO ADDR THE OPERAND 2ND FRACTION
3337:	0EE6  4E      		LD	C,(HL)		;OPERAND 2ND FRACTION
3338:	0EE7  23      		INC	HL		;TO ADDR THE OPERAND 3RD FRACTION
3339:	0EE8  56      		LD	D,(HL)		;OPERAND 3RD FRACTION
3340:			
3341:			;STORE THE OPERAND IN THE ACCUMULATOR
3342:	0EE9  6F      		LD	L,A		;OPERAND SIGN AND 1ST FRACTION
3343:	0EEA  F680    		OR	80H		;ACC 1ST FRACTION
3344:	0EEC  47      		LD	B,A		;ACC 1ST FRACTION
3345:	0EED  AD      		XOR	L		;ACC SIGN
3346:	0EEE  214A3D  		LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
3347:	0EF1  CDAE0E  		CALL	FSTR0		;SET THE ACC
3348:	0EF4  A8      		XOR	B		;ACC SIGN AND 1ST FRACTION
3349:			
3350:			; SET CONTROL BITS AND EXIT
3351:			
3352:	0EF5  47      		LD	B,A		;ACC SIGN AND 1ST FRACTION
3353:	0EF6  F601    		OR	01		;SET SIGN BIT FOR EXIT
3354:	0EF8  7B      		LD	A,E		;ACC EXPONENT
3355:	0EF9  C9      		RET			;RETURN TO CALLER
3356:			
3357:			;FLOATING POINT MULTIPLY
3358:	0EFA  7E      	FMUL:	LD	A,(HL)		;OPERAND EXPONENT
3359:	0EFB  A7      		AND	A		;SET CONTROL BITS
3360:	0EFC  C40810  		CALL	NZ,MDEX		;READ OPERAND IF NOT ZERO
3361:	0EFF  CAB80E  		JP	Z,FZRO		;IF ZERO OR UNDERFLOW
3362:	0F02  DA390F  		JP	C,FOVER		;IF OVERFLOW
3363:	0F05  CDC110  		CALL	MULX		;FIXED POINT MULTIPLY
3364:			
3365:			;NORMALIZE IF NECESSARY
3366:	0F08  78      		LD	A,B		;1ST PRODUCT
3367:	0F09  A7      		AND	A		;SET CONTROL BITS
3368:	0F0A  FA180F  		JP	M,RNDA		;IF NO NORMALIZATION REQUIRED
3369:	0F0D  214A3D  		LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
3370:	0F10  7E      		LD	A,(HL)		;ACC EXPONENT
3371:	0F11  DE01    		SBC	A,01		;DECREMENT ACC EXPONENT
3372:	0F13  77      		LD	(HL),A		;ACC EXPONENT
3373:	0F14  C8      		RET	Z		;RETURN TO CALLER IF UNDERFLOW
3374:	0F15  CD2E10  		CALL	LSH		;LEFT SHIFT SUBROUTINE
3375:			
3376:			;ROUND IF NECESSARY
3377:	0F18  CDA310  	RNDA:	CALL	ROND		;ROUNDING SUBROUTINE
3378:	0F1B  DA390F  		JP	C,FOVER		;IF OVERFLOW
3379:	0F1E  47      		LD	B,A		;ACC SIGN AND 1ST FRACTION
3380:	0F1F  F601    		OR	01		;SET SIGN BIT
3381:	0F21  7B      		LD	A,E		;ACC EXPONENT
3382:	0F22  C9      		RET			;RETURN TO CALLER
3383:			
3384:			;FLOATING POINT DIVIDE
3385:	0F23  EB      	FDIVD:	EX	DE,HL		;XYBASIC ENTRY POINT
3386:	0F24  23      		INC	HL
3387:	0F25  AF      	FDIV:	XOR	A		;ZERO
3388:	0F26  96      		SUB	(HL)		;COMPLEMENT OF DIVISOR EXPONENT
3389:	0F27  FE01    		CP	01		;SET CARRY IF DIVISION BY ZERO
3390:	0F29  D40810  		CALL	NC,MDEX		;READ OPERAND IF NOT ZERO
3391:	0F2C  DA390F  		JP	C,FOVER		;IF OVERFLOW OR DIVISION BY ZERO
3392:	0F2F  CAB80E  		JP	Z,FZRO		;IF UNDERFLOW OR ZERO
3393:	0F32  4F      		LD	C,A		;DIVISOR 1ST FRACTION
3394:	0F33  CD0A11  		CALL	DIVX		;FIXED POINT DIVIDE
3395:	0F36  DA180F  		JP	C,RNDA		;IF NO OVERFLOW
3396:			;FLOATING OVERFLOW -- ISSUE NONFATAL OV ERROR AND RETURN MAX VALUE
3397:	0F39          	FOVER:	ERROR	N, O, V		;ISSUE NONFATAL OV ERROR
3398:	0F3E  21C039  		LD	HL,FPMAX	;MAX POSITIVE FP VALUE
3399:	0F41  C3DD0E  		JP	FLOAD		;TO ACC AND RETURN
3400:			
3401:			;FLOATING POINT SUBTRACT
3402:	0F44  3E80    	FSUB:	LD	A,80H		;MASK TO CHANGE OPERAND SIGN
3403:	0F46  06      		DEFB	6		;THIS MVI B, SAVES A JUMP
3404:				;CONTINUE AS IN FADD
3405:			
3406:			;FLOATING POINT ADD
3407:	0F47  AF      	FADD:	XOR	A		;NB MUST BE 1-BYTE INSTRUCTION
3408:			;LOAD THE OPERAND
3409:	0F48  5E      		LD	E,(HL)		;OPERAND EXPONENT
3410:	0F49  23      		INC	HL		;TO ADDR THE OPERAND SIGN, 1ST FRACTION
3411:	0F4A  AE      		XOR	(HL)		;OPERAND SIGN AND 1ST FRACTION
3412:	0F4B  47      		LD	B,A		;OPERAND SIGN AND 1ST FRACTION
3413:	0F4C  23      		INC	HL		;TO ADDR THE OPERAND 2ND FRACTION
3414:	0F4D  4E      		LD	C,(HL)		;OPERAND 2ND FRACTION
3415:	0F4E  23      		INC	HL		;TO ADDR THE OPERAND 3RD FRACTION
3416:	0F4F  56      		LD	D,(HL)		;OPERAND 3RD FRACTION
3417:			
3418:			;SAVE INITIAL EXPONENT
3419:	0F50  214A3D  		LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
3420:	0F53  7E      		LD	A,(HL)		;ACC EXPONENT
3421:	0F54  2B      		DEC	HL		;TO ADDR THE INITIAL EXPONENT
3422:	0F55  77      		LD	(HL),A		;INITIAL EXPONENT
3423:			
3424:			;CHECK FOR ZERO OPERAND
3425:	0F56  7B      		LD	A,E		;OPERAND EXPONENT
3426:	0F57  A7      		AND	A		;SET CONTROL BITS
3427:	0F58  CAC90E  		JP	Z,FTEST		;IF OPERAND IS ZERO
3428:			
3429:			;GENERATE SUBTRACT FLAG AND RESTORE SUPPRESSED FRACTION BIT
3430:	0F5B  68      		LD	L,B		;OPERAND SIGN AND 1ST FRACTION
3431:	0F5C  78      		LD	A,B		;OPERAND SIGN AND 1ST FRACTION
3432:	0F5D  F680    		OR	80H		;OPERAND 1ST FRACTION
3433:	0F5F  47      		LD	B,A		;OPERAND 1ST FRACTION
3434:	0F60  AD      		XOR	L		;OPERAND SIGN
3435:	0F61  214B3D  		LD	HL,ACCS		;TO ADDR THE ACC SIGN
3436:	0F64  AE      		XOR	(HL)		;SUBTRACTION FLAG
3437:	0F65  324F3D  		LD	(SFLAG),A	;SUBTRACTION FLAG
3438:			
3439:			;DETERMINE RELATIVE MAGNITUDES OF OPERAND AND ACCUMULATOR
3440:	0F68  2B      		DEC	HL		;TO ADDR THE ACC EXPONENT
3441:	0F69  7E      		LD	A,(HL)		;ACC EXPONENT
3442:	0F6A  A7      		AND	A		;SET CONTROL BITS
3443:	0F6B  CAF90F  		JP	Z,FADD9		;IF ACC IS ZERO
3444:	0F6E  93      		SUB	E		;DIFFERENCE OF EXPONENTS
3445:	0F6F  DA7D0F  		JP	C,FADD2		;IF ACC SMALLER THAN OPERAND
3446:			
3447:			;CHECK FOR INSIGNIFICANT OPERAND
3448:	0F72  FAC90E  		JP	M,FTEST		;IF OPERAND IS INSIGNIFICANT
3449:	0F75  FE19    		CP	19H		;COMPARE SHIFT COUNT TO 25
3450:	0F77  DA9D0F  		JP	C,FADD3		;POSITION THE OPERAND
3451:	0F7A  C3C90E  		JP	FTEST		;OPERAND IS INSIGNIFICANT
3452:			
3453:			;CHECK FOR INSIGNIFICANT ACCUMULATOR
3454:	0F7D  F2F90F  	FADD2:	JP	P,FADD9		;IF ACC IS INSIGNIFICANT
3455:	0F80  FEE7    		CP	0E7H		;COMPARE SHIFT COUNT TO -25
3456:	0F82  DAF90F  		JP	C,FADD9		;IF ACC IS INSIGNIFICANT
3457:	0F85  73      		LD	(HL),E		;OPERAND EXPONENT
3458:	0F86  5F      		LD	E,A		;SHIFT COUNT
3459:	0F87  3A4F3D  		LD	A,(SFLAG)	;SUBTRACT FLAG
3460:	0F8A  214B3D  		LD	HL,ACCS		;TO ADDR THE ACC SIGN
3461:	0F8D  AE      		XOR	(HL)		;OPERAND SIGN
3462:	0F8E  77      		LD	(HL),A		;ACC SIGN
3463:	0F8F  AF      		XOR	A		;ZERO
3464:	0F90  93      		SUB	E		;COMPLIMENT SHIFT COUNT
3465:			
3466:			;EXCHANGE ACCUMULATOR AND OPERAND
3467:	0F91  23      		INC	HL		;TO ADDR THE ACC 1ST FRACTION
3468:	0F92  5E      		LD	E,(HL)		;ACC 1ST FRACTION
3469:	0F93  70      		LD	(HL),B		;OPERAND 1ST FRACTION
3470:	0F94  43      		LD	B,E		;ACC 1ST FRACTION
3471:	0F95  23      		INC	HL		;TO ADDR THE ACC 2ND FRACTION
3472:	0F96  5E      		LD	E,(HL)		;ACC 2ND FRACTION
3473:	0F97  71      		LD	(HL),C		;OPERAND 2ND FRACTION
3474:	0F98  4B      		LD	C,E		;ACC 2ND FRACTION
3475:	0F99  23      		INC	HL		;TO ADDR THE ACC 3RD FRACTION
3476:	0F9A  5E      		LD	E,(HL)		;ACC 3RD FRACTION
3477:	0F9B  72      		LD	(HL),D		;OPERAND 3RD FRACTION
3478:	0F9C  53      		LD	D,E		;ACC 3RD FRACTION
3479:			
3480:			;POSITION THE OPERAND
3481:	0F9D  CD3B10  	FADD3:	CALL	RSH		;POSITION THE OPERAND
3482:	0FA0  3A4F3D  		LD	A,(SFLAG)	;SUBTRACT FLAG
3483:	0FA3  A7      		AND	A		;SET CONTROL BITS
3484:	0FA4  214E3D  		LD	HL,ACC3		;TO ADDR THE ACC 3RD FRACTION
3485:	0FA7  FACF0F  		JP	M,FADD5		;IF SUBTRACT REQUIRED
3486:			
3487:			;ADD ADDEND TO AUGEND
3488:	0FAA  7E      	FADD4:	LD	A,(HL)		;AUGEND 3RD FRACTION
3489:	0FAB  82      		ADD	A,D		;ADDEND 3RD FRACTION
3490:	0FAC  57      		LD	D,A		;SUM 3RD FRACTION
3491:	0FAD  2B      		DEC	HL		;TO ADDR THE AUGEND 2ND FRACTION
3492:	0FAE  7E      		LD	A,(HL)		;AUGEND 2ND FRACTION
3493:	0FAF  89      		ADC	A,C		;ADDEND 2ND FRACTION
3494:	0FB0  4F      		LD	C,A		;SUM 2ND FRACTION
3495:	0FB1  2B      		DEC	HL		;TO ADDR THE AUGEND 1ST FRACTION
3496:	0FB2  7E      		LD	A,(HL)		;AUGEND 1ST FRACTION
3497:	0FB3  88      		ADC	A,B		;ADDEND 1ST FRACTION
3498:	0FB4  47      		LD	B,A		;SUM 1ST FRACTION
3499:	0FB5  D2E60F  		JP	NC,FADD7	;IF NO CARRY FROM 1ST FRACTION
3500:			
3501:			;RIGHT SHIFT SUM TO NORMALIZED POSITION
3502:	0FB8  1F      		RRA			;RIGHT SHIFT SUM 1ST FRACTION
3503:	0FB9  47      		LD	B,A		;SUM 1ST FRACTION
3504:	0FBA  79      		LD	A,C		;SUM 2ND FRACTION
3505:	0FBB  1F      		RRA			;RIGHT SHIFT SUM 2ND FRACTION
3506:	0FBC  4F      		LD	C,A		;SUM 2ND FRACTION
3507:	0FBD  7A      		LD	A,D		;SUM 3RD FRACTION
3508:	0FBE  1F      		RRA			;RIGHT SHIFT SUM 3RD FRACTION
3509:	0FBF  57      		LD	D,A		;SUM 3RD FRACTION
3510:	0FC0  1F      		RRA			;4TH FRACTION = LOW BIT OF 3RD
3511:	0FC1  5F      		LD	E,A		;SUM 4TH FRACTION
3512:	0FC2  214A3D  		LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
3513:	0FC5  7E      		LD	A,(HL)		;ACC EXPONENT
3514:	0FC6  C601    		ADD	A,1		;INCREMENT THE ACC EXPONENT
3515:	0FC8  DA390F  		JP	C,FOVER		;IF OVERFLOW
3516:	0FCB  77      		LD	(HL),A		;ACC EXPONENT
3517:	0FCC  C3E60F  		JP	FADD7		;TO ROUND FRACTION
3518:			
3519:			;SUBTRACT SUBTRAHEND FROM MINUEND
3520:	0FCF  AF      	FADD5:	XOR	A		;MINUEND 4TH FRACTION IS ZERO
3521:	0FD0  93      		SUB	E		;SUBTRAHEND 4TH FRACTION
3522:	0FD1  5F      		LD	E,A		;DIFFERENCE 4TH FRACTION
3523:	0FD2  7E      		LD	A,(HL)		;MINUEND 3RD FRACTION
3524:	0FD3  9A      		SBC	A,D		;SUBTRAHEND 3RD FRACTION
3525:	0FD4  57      		LD	D,A		;DIFFERENCE 3RD FRACTION
3526:	0FD5  2B      		DEC	HL		;TO ADDR THE MINUEND 2ND FRACTION
3527:	0FD6  7E      		LD	A,(HL)		;MINUEND 2ND FRACTION
3528:	0FD7  99      		SBC	A,C		;SUBTRAHEND 2ND FRACTION
3529:	0FD8  4F      		LD	C,A		;DIFFERENCE 2ND FRACTION
3530:	0FD9  2B      		DEC	HL		;TO ADDR THE MINUEND 1ST FRACTION
3531:	0FDA  7E      		LD	A,(HL)		;MINUEND 1ST FRACTION
3532:	0FDB  98      		SBC	A,B		;SUBTRAHEND 1ST FRACTION
3533:	0FDC  47      		LD	B,A		;DIFFERENCE 1ST FRACTION
3534:	0FDD  DC6110  	FADD6:	CALL	C,COMP		;COMPLIMENT IF NEGATIVE
3535:	0FE0  F47410  		CALL	P,NORM		;NORMALIZE IF NECESSARY
3536:	0FE3  F2B80E  		JP	P,FZRO		;IF UNDERFLOW OR ZERO
3537:	0FE6  CDA310  	FADD7:	CALL	ROND		;ROUNDING
3538:	0FE9  DA390F  		JP	C,FOVER		;IF OVERFLOW
3539:	0FEC  47      	FADD8:	LD	B,A		;ACC SIGN AND 1ST FRACTION
3540:	0FED  21493D  		LD	HL,PREX		;TO ADDR THE PREVIOUS EXPONENT
3541:	0FF0  7B      		LD	A,E		;ACC EXPONENT
3542:	0FF1  96      		SUB	(HL)		;DIFFERENCE THE EXPONENTS
3543:	0FF2  6F      		LD	L,A		;DIFFERENCE IN EXPONENTS
3544:	0FF3  78      		LD	A,B		;ACC SIGN AND 1ST FRACTION
3545:	0FF4  F601    		OR	1		;SET SIGN BIT FOR EXIT
3546:	0FF6  7B      		LD	A,E		;ACC EXPONENT
3547:	0FF7  5D      		LD	E,L		;SIGNIFICANCE INDEX
3548:	0FF8  C9      		RET			;RETURN TO CALLER
3549:			
3550:			;LOAD THE ACCUMULATOR WITH THE OPERAND
3551:	0FF9  3A4F3D  	FADD9:	LD	A,(SFLAG)	;SUBTRACTION FLAG
3552:	0FFC  214B3D  		LD	HL,ACCS		;TO ADDR THE ACC SIGN
3553:	0FFF  AE      		XOR	(HL)		;OPERAND SIGN
3554:	1000  2B      		DEC	HL		;TO ADDR THE ACC EXPONENT
3555:	1001  CDAE0E  		CALL	FSTR0		;SET THE ACC
3556:	1004  A8      		XOR	B		;ACC SIGN AND 1ST FRACTION
3557:	1005  C3EC0F  		JP	FADD8		;JOIN EXIT CODE
3558:			
3559:			;READ THE OPERAND AND CHECK THE ACCUMULATOR EXPONENT
3560:	1008  47      	MDEX:	LD	B,A		;EXPONENT MODIFIER
3561:	1009  23      		INC	HL		;TO ADDR THE OPERAND SIGN AND 1ST FRACTION
3562:	100A  4E      		LD	C,(HL)		;OPERAND SIGN AND 1ST FRACTION
3563:	100B  23      		INC	HL		;TO ADDR OPERAND 2ND FRACTION
3564:	100C  56      		LD	D,(HL)		;OPERAND 2ND FRACTION
3565:	100D  23      		INC	HL		;TO ADDR OPERAND 3RD FRACTION
3566:	100E  5E      		LD	E,(HL)		;OPERAND 3RD FRACTION
3567:	100F  214A3D  		LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
3568:	1012  7E      		LD	A,(HL)		;ACC EXPONENT
3569:	1013  A7      		AND	A		;SET CONTROL BITS
3570:	1014  C8      		RET	Z		;RETURN IF ACC IS ZERO
3571:	1015  80      		ADD	A,B		;RESULT EXPONENT PLUS BIAS
3572:	1016  47      		LD	B,A		;RESULT EXPONENT PLUS BIAS
3573:	1017  1F      		RRA			;CARRY TO SIGN BIT
3574:	1018  A8      		XOR	B		;CARRY AND SIGN MUST DIFFER
3575:	1019  78      		LD	A,B		;RESULT EXPONENT PLUS BIAS
3576:	101A  0680    		LD	B,80H		;EXPONENT BIAS, SIGN MASK, MSB
3577:	101C  F22A10  		JP	P,OVUN		;IF OVERFLOW OR UNDERFLOW
3578:	101F  90      		SUB	B		;REMOVE EXCESS EXPONENT BIAS
3579:	1020  C8      		RET	Z		;RETURN IF UNDERFLOW
3580:	1021  77      		LD	(HL),A		;RESULT EXPONENT
3581:	1022  23      		INC	HL		;TO ADDR THE ACC SIGN
3582:	1023  7E      		LD	A,(HL)		;ACC SIGN
3583:	1024  A9      		XOR	C		;RESULT SIGN IN SIGN BIT
3584:	1025  A0      		AND	B		;RESULT SIGN
3585:	1026  77      		LD	(HL),A		;RESULT SIGN
3586:	1027  79      		LD	A,C		;OPERAND SIGN AND 1ST FRACTION
3587:	1028  B0      		OR	B		;OPERAND 1ST FRACTION
3588:	1029  C9      		RET			;RETURN TO CALLER
3589:	102A  07      	OVUN:	RLCA			;SET CARRY BIT IF OVERFLOW
3590:	102B  D8      		RET	C		;RETURN IF OVERFLOW
3591:	102C  AF      		XOR	A		;ZERO
3592:	102D  C9      		RET			;RETURN IF UNDERFLOW
3593:			
3594:			;LEFT SHIFT THE B, C, D, AND E REGISTERS ONE BIT
3595:	102E  7B      	LSH:	LD	A,E		;ORIGINAL CONTENTS OF E
3596:	102F  17      		RLA			;LEFT SHIFT E
3597:	1030  5F      		LD	E,A		;RESTORE TO E
3598:	1031  7A      		LD	A,D		;ORIGINAL CONTENTS OF D
3599:	1032  17      		RLA			;LEFT SHIFT D
3600:	1033  57      		LD	D,A		;RESTORE TO D
3601:	1034  79      		LD	A,C		;ORIGINAL CONTENTS OF C
3602:	1035  17      		RLA			;LEFT SHIFT C
3603:	1036  4F      		LD	C,A		;RESTORE TO C
3604:	1037  78      		LD	A,B		;ORIGINAL CONTENTS OF B
3605:	1038  8F      		ADC	A,A		;LEFT SHIFT B
3606:	1039  47      		LD	B,A		;RESTORE TO B
3607:	103A  C9      		RET			;RETURN TO CALLER
3608:			
3609:			;RIGHT SHIFT THE B, C, D, AND E REGISTERS
3610:			;BY THE SHIFT COUNT IN THE A REGISTER.
3611:			;              - OR -
3612:			;SHIFT OPERAND TO REGISTER INDICATED
3613:			;BY THE SHIFT COUNT(MODULO 8).
3614:	103B  1E00    	RSH:	LD	E,0		;OPERAND 4TH FRACTION IS ZERO
3615:	103D  2E08    		LD	L,08		;EACH REG IS 8 BITS OF SHIFT
3616:	103F  BD      	RSH1:	CP	L		;COMPARE SHIFT COUNT TO 8
3617:	1040  FA4C10  		JP	M,RSH2		;IF REQUIRED SHIFT IS < 8
3618:	1043  5A      		LD	E,D		;OPERAND 4TH FRACTION
3619:	1044  51      		LD	D,C		;OPERAND 3RD FRACTION
3620:	1045  48      		LD	C,B		;OPERAND 2ND FRACTION
3621:	1046  0600    		LD	B,0		;OPERAND 1ST FRACTION IS ZERO
3622:	1048  95      		SUB	L		;REDUCE SHIFT COUNT BY ONE REGISTER
3623:	1049  C23F10  		JP	NZ,RSH1		;IF MORE SHIFTS REQUIRED
3624:			
3625:			;SHIFT OPERAND RIGHT BY 'SHIFT COUNT' BITS
3626:	104C  A7      	RSH2:	AND	A		;SET CONTROL BITS
3627:	104D  C8      		RET	Z		;RETURN IF SHIFT COMPLETE
3628:	104E  6F      		LD	L,A		;SHIFT COUNT
3629:	104F  A7      	RSH3:	AND	A		;CLEAR CARRY BIT
3630:	1050  78      		LD	A,B		;OPERAND 1ST FRACTION
3631:	1051  1F      		RRA			;RIGHT SHIFT 1ST FRACTION
3632:	1052  47      		LD	B,A		;OPERAND 1ST FRACTION
3633:	1053  79      		LD	A,C		;OPERAND 2ND FRACTION
3634:	1054  1F      		RRA			;RIGHT SHIFT 2ND FRACTION
3635:	1055  4F      		LD	C,A		;OPERAND 2ND FRACTION
3636:	1056  7A      		LD	A,D		;OPERAND 3RD FRACTION
3637:	1057  1F      		RRA			;RIGHT SHIFT 3RD FRACTION
3638:	1058  57      		LD	D,A		;OPERAND 3RD FRACTION
3639:	1059  7B      		LD	A,E		;OPERAND 4TH FRACTION
3640:	105A  1F      		RRA			;RIGHT SHIFT 4TH FRACTION
3641:	105B  5F      		LD	E,A		;OPERAND 4TH FRACTION
3642:	105C  2D      		DEC	L		;DECREMENT SHIFT COUNT
3643:	105D  C24F10  		JP	NZ,RSH3		;IF MORE SHIFTS REQUIRED
3644:	1060  C9      		RET			;RETURN TO CALLER
3645:			
3646:			;COMPLIMENT THE B, C, D, AND E REGISTERS
3647:	1061  2B      	COMP:	DEC	HL		;TO ADDR THE ACC SIGN
3648:	1062  7E      		LD	A,(HL)		;ACC SIGN
3649:	1063  EE80    		XOR	80H		;CHANGE SIGN
3650:	1065  77      		LD	(HL),A		;ACC SIGN
3651:	1066  AF      	COMP1:	XOR	A		;ZERO -- FFIX ENTRY POINT
3652:	1067  6F      		LD	L,A		;ZERO
3653:	1068  93      		SUB	E		;COMPLIMENT 4TH FRACTION
3654:	1069  5F      		LD	E,A		;RESTORE TO E
3655:	106A  7D      		LD	A,L		;ZERO
3656:	106B  9A      		SBC	A,D		;COMPLIMENT 3RD FRACTION
3657:	106C  57      		LD	D,A		;RESTORE TO D
3658:	106D  7D      		LD	A,L		;ZERO
3659:	106E  99      		SBC	A,C		;COMPLIMENT 2ND FRACTION
3660:	106F  4F      		LD	C,A		;RESTORE TO C
3661:	1070  7D      		LD	A,L		;ZERO
3662:	1071  98      		SBC	A,B		;COMPLIMENT 1ST FRACTION
3663:	1072  47      		LD	B,A		;RESTORE TO B
3664:	1073  C9      		RET			;RETURN TO CALLER
3665:			
3666:			;NORMALIZE THE REGISTERS
3667:	1074  2E20    	NORM:	LD	L,20H		;MAXIMUM NORMALIZING SHIFT
3668:	1076  78      	NORM1:	LD	A,B		;1ST FRACTION
3669:	1077  A7      		AND	A		;SET CONTROL BITS
3670:	1078  C29410  		JP	NZ,NORM3	;IF 1ST FRACTION IS NON ZERO
3671:	107B  41      		LD	B,C		;1ST FRACTION
3672:	107C  4A      		LD	C,D		;2ND FRACTION
3673:	107D  53      		LD	D,E		;3RD FRACTION
3674:	107E  5F      		LD	E,A		;ZERO 4TH FRACTION
3675:	107F  7D      		LD	A,L		;NORMALIZING SHIFT COUNT
3676:	1080  D608    		SUB	08		;REDUCE SHIFT COUNT
3677:	1082  6F      		LD	L,A		;NORMALIZING SHIFT COUNT
3678:	1083  C27610  		JP	NZ,NORM1	;IF FRACTION NON ZERO
3679:	1086  C9      		RET			;IF FRACTION IS ZERO
3680:	1087  2D      	NORM2:	DEC	L		;DECREMENT SHIFT COUNT
3681:	1088  7B      		LD	A,E		;ORIGINAL CONTENTS OF E
3682:	1089  17      		RLA			;LEFT SHIFT E
3683:	108A  5F      		LD	E,A		;RESTORE TO E
3684:	108B  7A      		LD	A,D		;ORIGINAL CONTENTS OF D
3685:	108C  17      		RLA			;LEFT SHIFT D
3686:	108D  57      		LD	D,A		;RESTORE TO D
3687:	108E  79      		LD	A,C		;ORIGINAL CONTENTS OF C
3688:	108F  17      		RLA			;LEFT SHIFT C
3689:	1090  4F      		LD	C,A		;RESTORE TO C
3690:	1091  78      		LD	A,B		;ORIGINAL CONTENTS OF B
3691:	1092  8F      		ADC	A,A		;LEFT SHIFT B
3692:	1093  47      		LD	B,A		;RESTORE TO B
3693:	1094  F28710  	NORM3:	JP	P,NORM2		;IF NOT YET NORMALIZED
3694:	1097  7D      		LD	A,L		;NORMALIZING SHIFT COUNT
3695:	1098  D620    		SUB	20H		;REMOVE BIAS
3696:	109A  214A3D  		LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
3697:	109D  86      		ADD	A,(HL)		;ADJUST ACC EXPONENT
3698:	109E  77      		LD	(HL),A		;NEW ACC EXPONENT
3699:	109F  C8      		RET	Z		;RETURN IF ZERO EXPONENT
3700:	10A0  1F      		RRA			;BORROW BIT TO SIGN
3701:	10A1  A7      		AND	A		;SET SIGN TO INDICATE UNDERFLOW
3702:	10A2  C9      		RET			;RETURN TO CALLER
3703:			
3704:			;ROUND THE B, C, AND D REGISTERS
3705:	10A3  214A3D  	ROND:	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
3706:	10A6  7B      		LD	A,E		;4TH FRACTION
3707:	10A7  A7      		AND	A		;SET CONTROL BITS
3708:	10A8  5E      		LD	E,(HL)		;ACC EXPONENT
3709:	10A9  FCB310  		CALL	M,RNDR		;CALL 2ND LEVEL ROUNDER
3710:	10AC  D8      		RET	C		;RETURN IF OVERFLOW
3711:	10AD  78      		LD	A,B		;1ST FRACTION
3712:	10AE  23      		INC	HL		;TO ADDR THE ACC SIGN
3713:	10AF  AE      		XOR	(HL)		;ACC SIGN AND 1ST FRACTION
3714:	10B0  C3B10E  		JP	FSTR1		;RETURN THRU 'STORE' SUBROUTINE
3715:			
3716:			;SECOND LEVEL ROUNDER
3717:	10B3  14      	RNDR:	INC	D		;ROUND 3RD FRACTION
3718:	10B4  C0      		RET	NZ		;RETURN IF NO CARRY
3719:	10B5  0C      		INC	C		;CARRY TO 2ND FRACTION
3720:	10B6  C0      		RET	NZ		;RETURN IF NO CARRY
3721:	10B7  04      		INC	B		;CARRY TO 1ST FRACTION
3722:	10B8  C0      		RET	NZ		;RETURN IF NO CARRY
3723:	10B9  7B      		LD	A,E		;ACC EXPONENT
3724:	10BA  C601    		ADD	A,1		;INCREMENT ACC EXPONENT
3725:	10BC  5F      		LD	E,A		;NEW ACC EXPONENT
3726:	10BD  0680    		LD	B,80H		;NEW 1ST FRACTION
3727:	10BF  77      		LD	(HL),A		;NEW ACC EXPONENT
3728:	10C0  C9      		RET			;RETURN TO 1ST LEVEL ROUNDER
3729:			
3730:			;FIXED POINT MULTIPLY
3731:	10C1  21BA3C  	MULX:	LD	HL,MULX4+9	;TO ADDR THE 1ST MULTIPLICAND
3732:	10C4  77      		LD	(HL),A		;1ST MULTIPLICAND
3733:	10C5  21B63C  		LD	HL,MULX4+5	;TO ADDR THE 2ND MULTIPLICAND
3734:	10C8  72      		LD	(HL),D		;2ND MULTIPLICAND
3735:	10C9  21B23C  		LD	HL,MULX4+1	;TO ADDR THE 3RD MULTIPLICAND
3736:	10CC  73      		LD	(HL),E		;3RD MULTIPLICAND
3737:	10CD  AF      		XOR	A		;CLEAR 6TH PRODUCT
3738:	10CE  5F      		LD	E,A		;CLEAR 5TH PRODUCT
3739:	10CF  57      		LD	D,A		;CLEAR 4TH PRODUCT
3740:			
3741:			;MULTIPLY BY EACH ACCUMULATOR FRACTION IN TURN
3742:	10D0  214E3D  		LD	HL,ACC3		;TO ADDR THE 3RD FRACTION
3743:	10D3  CDE210  		CALL	MULX2		;MULTIPLY BY ACC 3RD FRACTION
3744:	10D6  214D3D  		LD	HL,ACC2		;TO ADDR THE 2ND FRACTION
3745:	10D9  CDDF10  		CALL	MULX1		;MULTIPLY BY ACC 2ND FRACTION
3746:	10DC  214C3D  		LD	HL,ACC1		;TO ADDR THE 1ST FRACTION
3747:			
3748:			;MULTIPLY BY ONE ACCUMULATOR WORD
3749:	10DF  7A      	MULX1:	LD	A,D		;5TH PARTIAL PRODUCT
3750:	10E0  59      		LD	E,C		;4TH PARTIAL PRODUCT
3751:	10E1  50      		LD	D,B		;3RD PARTIAL PRODUCT
3752:	10E2  46      	MULX2:	LD	B,(HL)		;MULTIPLIER
3753:	10E3  6F      		LD	L,A		;5TH PARTIAL PRODUCT
3754:	10E4  AF      		XOR	A		;ZERO
3755:	10E5  4F      		LD	C,A		;TO 2ND PARTIAL PRODUCT
3756:	10E6  90      		SUB	B		;SET CARRY BIT FOR EXIT FLAG
3757:	10E7  D2C211  		JP	NC,FFIX0	;MULTIPLY BY 0
3758:			
3759:			;LOOP FOR EACH BIT OF MULTIPLIER WORD
3760:	10EA  7D      	MULX3:	LD	A,L		;5TH PARTIAL PRODUCT, EXIT FLAG
3761:	10EB  8F      		ADC	A,A		;SHIFT EXIT FLAG OUT IF DONE
3762:	10EC  C8      		RET	Z		;EXIT IF MULTIPLICATION DONE
3763:	10ED  6F      		LD	L,A		;5TH PARTIAL PRODUCT, EXIT FLAG
3764:	10EE  7B      		LD	A,E		;4TH PARTIAL PRODUCT
3765:	10EF  17      		RLA			;SHIFT 4TH PARTIAL PRODUCT
3766:	10F0  5F      		LD	E,A		;4TH PARTIAL PRODUCT
3767:	10F1  7A      		LD	A,D		;3RD PARTIAL PRODUCT
3768:	10F2  17      		RLA			;SHIFT 3RD PARTIAL PRODUCT
3769:	10F3  57      		LD	D,A		;3RD PARTIAL PRODUCT
3770:	10F4  79      		LD	A,C		;2ND PARTIAL PRODUCT
3771:	10F5  17      		RLA			;SHIFT 2ND PARTIAL PRODUCT
3772:	10F6  4F      		LD	C,A		;2ND PARTIAL PRODUCT
3773:	10F7  78      		LD	A,B		;1ST PARTIAL PRODUCT AND MULTIPLIER
3774:	10F8  17      		RLA			;SHIFT THEM
3775:	10F9  47      		LD	B,A		;1ST PARTIAL PRODUCT AND MULTIPLIER
3776:	10FA  D2EA10  		JP	NC,MULX3	;IF NO ADDITION REQUIRED
3777:			
3778:			;ADD THE MULTIPLICAND TO THE PRODUCT IF THE MULTIPLIER BIT IS A ONE
3779:	10FD  7B      		LD	A,E		;4TH PARTIAL PRODUCT
3780:	10FE  CDB13C  		CALL	MULX4		;TO RAM CODE
3781:			
3782:			;COMPLETE ADDITION OF MULTIPLICAND
3783:	1101  4F      		LD	C,A		;2ND PARTIAL PRODUCT
3784:	1102  D2EA10  		JP	NC,MULX3	;IF NO CARRY TO 1ST PRODUCT
3785:	1105  04      		INC	B		;ADD CARRY TO 1ST PRODUCT
3786:	1106  A7      		AND	A		;CLEAR CARRY BIT
3787:	1107  C3EA10  		JP	MULX3
3788:			
3789:			;FIXED POINT DIVIDE
3790:			;
3791:			;SUBTRACT THE DIVISOR FROM THE ACCUMULATOR TO OBTAIN THE FIRST REMAINDER
3792:	110A  214E3D  	DIVX:	LD	HL,ACC3		;TO ADDR THE ACC 3RD FRACTION
3793:	110D  7E      		LD	A,(HL)		;ACC 3RD FRACTION
3794:	110E  93      		SUB	E		;DIVISOR 3RD FRACTION
3795:	110F  77      		LD	(HL),A		;REMAINDER 3RD FRACTION
3796:	1110  2B      		DEC	HL		;TO ADDR THE ACC 2ND FRACTION
3797:	1111  7E      		LD	A,(HL)		;ACC 2ND FRACTION
3798:	1112  9A      		SBC	A,D		;DIVISOR 2ND FRACTION
3799:	1113  77      		LD	(HL),A		;REMAINDER 2ND FRACTION
3800:	1114  2B      		DEC	HL		;TO ADDR THE ACC 1ST FRACTION
3801:	1115  7E      		LD	A,(HL)		;ACC 1ST FRACTION
3802:	1116  99      		SBC	A,C		;DIVISOR 1ST FRACTION
3803:	1117  77      		LD	(HL),A		;REMAINDER 1ST FRACTION
3804:			
3805:			;HALVE THE DIVISOR AND STORE FOR ADDITION OR SUBTRACTION
3806:	1118  79      		LD	A,C		;DIVISOR 1ST FRACTION
3807:	1119  17      		RLA			;SET CARRY BIT
3808:	111A  79      		LD	A,C		;DIVISOR 1ST FRACTION
3809:	111B  1F      		RRA			;HALF OF DIVISOR 1ST FRACTION
3810:	111C  32C83C  		LD	(DIVX5+12),A	;1ST SUBTRACT DIVISOR
3811:	111F  32D63C  		LD	(DIVX6+9),A	;1ST ADD DIVISOR
3812:	1122  7A      		LD	A,D		;DIVISOR 2ND FRACTION
3813:	1123  1F      		RRA			;HALF OF DIVISOR 2ND FRACTION
3814:	1124  32C43C  		LD	(DIVX5+8),A	;2ND SUBTRACT DIVISOR
3815:	1127  32D23C  		LD	(DIVX6+5),A	;2ND ADD DIVISOR
3816:	112A  7B      		LD	A,E		;DIVISOR 3RD FRACTION
3817:	112B  1F      		RRA			;HALF OF DIVISOR 3RD FRACTION
3818:	112C  32C03C  		LD	(DIVX5+4),A	;3RD SUBTRACT DIVISOR
3819:	112F  32CE3C  		LD	(DIVX6+1),A	;3RD ADD DIVISOR
3820:	1132  0600    		LD	B,0		;INIT QUOTIENT 1ST FRACTION
3821:	1134  78      		LD	A,B		;DIVISOR 4TH QUOTIENT IS ZERO
3822:	1135  1F      		RRA			;LOW BIT OF DIVISOR 3RD FRACTION
3823:	1136  32BD3C  		LD	(DIVX5+1),A	;4TH SUBTRACT DIVISOR
3824:	1139  32CB3C  		LD	(DIVX5+15),A	;4TH ADD DIVISOR
3825:	113C  32D93C  		LD	(DIVX6+12),A	;4TH ADD DIVISOR
3826:			
3827:			;LOAD FIRST REMAINDER AND CHECK SIGN
3828:	113F  214C3D  		LD	HL,ACC1		;TO ADDR THE REMAINDER 1ST FRACTION
3829:	1142  7E      		LD	A,(HL)		;REMAINDER 1ST FRACTION
3830:	1143  23      		INC	HL		;TO ADDR THE REMAINDER 2ND FRACTION
3831:	1144  56      		LD	D,(HL)		;REMAINDER 2ND FRACTION
3832:	1145  23      		INC	HL		;TO ADDR THE REMAINDER 3RD FRACTION
3833:	1146  5E      		LD	E,(HL)		;REMAINDER 3RD FRACTION
3834:	1147  A7      		AND	A		;SET CONTROL BITS
3835:	1148  FA7611  		JP	M,DIVX4		;IF REMAINDER IS NEGATIVE
3836:			
3837:			;ADJUST THE EXPONENT, POSITION THE REMAINDER, AND INITIALIZE THE QUOTIENT
3838:	114B  214A3D  		LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
3839:	114E  4E      		LD	C,(HL)		;QUOTIENT EXPONENT
3840:	114F  0C      		INC	C		;INCREMENT THE QUOTIENT EXPONENT
3841:	1150  C8      		RET	Z		;RETURN IF OVERFLOW
3842:	1151  71      		LD	(HL),C		;QUOTIENT EXPONENT
3843:	1152  6B      		LD	L,E		;REMAINDER 3RD FRACTION
3844:	1153  62      		LD	H,D		;REMAINDER 2ND FRACTION
3845:	1154  5F      		LD	E,A		;REMAINDER 1ST FRACTION
3846:	1155  1601    		LD	D,1		;INITIALIZE QUOTIENT 3RD FRACTION
3847:	1157  48      		LD	C,B		;INITIALIZE QUOTIENT 2ND FRACTION
3848:			
3849:			;SUBTRACT THE DIVISOR FROM THE REMAINDER IF IT IS POSITIVE
3850:	1158  AF      	DIVX1:	XOR	A		;REMAINDER 4TH FRACTION IS ZERO
3851:	1159  CDBC3C  		CALL	DIVX5		;CALL RAM CODE
3852:	115C  07      	DIVX2:	RLCA			;SHIFT REMAINDER 4TH FRACTION TO CARRY
3853:			
3854:			;SHIFT THE REMAINDER LEFT ONE BIT
3855:	115D  78      		LD	A,B		;QUOTIENT 1ST FRACTION
3856:	115E  17      		RLA			;MSB OF QUOTIENT TO CARRY
3857:	115F  D8      		RET	C		;IF DIVISION COMLPETE
3858:	1160  1F      		RRA			;REMAINDER 4TH FRACTION TO CARRY
3859:	1161  7D      		LD	A,L		;REMAINDER 3RD FRACTION
3860:	1162  17      		RLA			;LEFT SHIFT REMAINDER 3RD FRACTION
3861:	1163  6F      		LD	L,A		;REMAINDER 3RD FRACTION
3862:	1164  7C      		LD	A,H		;REMAINDER 2ND FRACTION
3863:	1165  17      		RLA			;LEFT SHIFT REMAINDER 2ND FRACTION
3864:	1166  67      		LD	H,A		;REMAINDER 2ND FRACTION
3865:	1167  CD2E10  		CALL	LSH		;LEFT SHIFT IT
3866:			
3867:			;BRANCH IF SUBTRACTION IS REQUIRED
3868:	116A  7A      		LD	A,D		;QUOTIENT 3RD FRACTION
3869:	116B  0F      		RRCA			;REMAINDER SIGN TO CARRY BIT
3870:	116C  DA5811  		JP	C,DIVX1		;SUBTRACT DIVISOR IF REMAINDER IS POSITIVE
3871:			
3872:			;ADD THE DIVISOR IF THE REMAINDER IS NEGATIVE
3873:	116F  7D      	DIVX3:	LD	A,L		;REMAINDER 3RD FRACTION
3874:	1170  CDCD3C  		CALL	DIVX6		;TO RAM CODE
3875:	1173  C35C11  		JP	DIVX2
3876:			
3877:			;POSITION THE REMAINDER AND INITIALIZE THE QUOTIENT
3878:	1176  6B      	DIVX4:	LD	L,E		;REMAINDER 3RD FRACTION
3879:	1177  62      		LD	H,D		;REMAINDER 2ND FRACTION
3880:	1178  5F      		LD	E,A		;REMAINDER 1ST FRACTION
3881:	1179  50      		LD	D,B		;INITIALIZE QUOTIENT 3RD FRACTION
3882:	117A  48      		LD	C,B		;INITIALIZE QUOTIENT 2ND FRACTION
3883:	117B  C36F11  		JP	DIVX3		;ADD DIVISOR IF REMAINDER IS NEGATIVE
3884:			
3885:			;FIXED POINT TO FLOATING POINT CONVERSION
3886:	117E  6B      	FFLOT:	LD	L,E		;INPUT EXPONENT
3887:	117F  5A      		LD	E,D		;4TH INPUT FRACTION
3888:	1180  51      		LD	D,C		;3RD INPUT FRACTION
3889:	1181  48      		LD	C,B		;2ND INPUT FRACTION
3890:	1182  47      		LD	B,A		;1ST INPUT FRACTION
3891:	1183  7D      		LD	A,L		;INPUT EXPONENT
3892:	1184  EE80    	FLOT1:	XOR	80H		;APPLY EXPONENT BIAS
3893:	1186  214A3D  		LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
3894:	1189  77      		LD	(HL),A		;ACC EXPONENT
3895:	118A  23      		INC	HL		;TO ADDR THE ACC SIGN
3896:	118B  3680    		LD	(HL),80H	;SET ACC SIGN POSITIVE
3897:	118D  23      		INC	HL		;TO ADDR THE ACC 1ST FRACTION
3898:	118E  78      		LD	A,B		;1ST INPUT FRACTION
3899:	118F  A7      		AND	A		;SET SIGN BIT
3900:	1190  17      		RLA			;INPUT SIGN TO CARRY
3901:	1191  C3DD0F  		JP	FADD6		;COMPLETE THE CONVERSION
3902:			
3903:			;FLOATING POINT TO FIXED POINT CONVERSION
3904:	1194  214A3D  	FFIX:	LD	HL,ACCE		;TO ADDR THE ACC EXPONENT
3905:	1197  7E      		LD	A,(HL)		;ACC EXPONENT
3906:	1198  A7      		AND	A		;SET CONTROL BITS
3907:	1199  CAC511  		JP	Z,FFIX1		;IF ACC IS ZERO
3908:	119C  7B      		LD	A,E		;INPUT EXPONENT
3909:	119D  C67F    		ADD	A,7FH		;APPLY BIAS-1
3910:	119F  96      		SUB	(HL)		;SHIFT COUNT - 1
3911:	11A0  DACA11  		JP	C,FFIX2		;check for -32768 if too large
3912:	11A3  FE1F    		CP	1FH		;COMPARE TO LARGE SHIFT
3913:	11A5  D2C511  		JP	NC,FFIX1	;IF ACC TOO SMALL
3914:	11A8  C601    		ADD	A,1		;SHIFT COUNT
3915:	11AA  214C3D  		LD	HL,ACC1		;TO ADDR THE ACC 1ST FRACTION
3916:	11AD  46      		LD	B,(HL)		;ACC 1ST FRACTION
3917:	11AE  23      		INC	HL		;TO ADDR THE ACC 2ND FRACTION
3918:	11AF  4E      		LD	C,(HL)		;ACC 2ND FRACTION
3919:	11B0  23      		INC	HL		;TO ADDR THE ACC 3RD FRACTION
3920:	11B1  56      		LD	D,(HL)		;ACC 3RD FRACTION
3921:	11B2  CD3B10  		CALL	RSH		;POSITION THE FRACTION
3922:	11B5  214B3D  		LD	HL,ACCS		;TO ADDR THE ACC SIGN
3923:	11B8  7E      		LD	A,(HL)		;ACC SIGN
3924:	11B9  A7      		AND	A		;SET CONTROL BITS
3925:	11BA  F46610  		CALL	P,COMP1		;COMPLIMENT FRACTION IF NEGATIVE
3926:	11BD  3E01    		LD	A,1		;NON-ZERO
3927:	11BF  B0      		OR	B		;SET CONTROL BITS FOR EXIT
3928:	11C0  78      		LD	A,B		;1ST RESULT
3929:	11C1  41      		LD	B,C		;2ND RESULT
3930:	11C2  4A      	FFIX0:	LD	C,D		;3RD RESULT  -- MULX2 ENTRY POINT
3931:	11C3  53      		LD	D,E		;4TH RESULT
3932:	11C4  C9      		RET			;RETURN TO CALLER
3933:	11C5  AF      	FFIX1:	XOR	A		;ZERO
3934:	11C6  47      		LD	B,A		;ZERO
3935:	11C7  4F      		LD	C,A		;ZERO
3936:	11C8  57      		LD	D,A		;ZERO
3937:	11C9  C9      		RET			;RETURN TO CALLER
3938:			;FIX2 checks for -32768 (90H, 0, 80H, 0, 0) in FACC, otherwise returns Carry.
3939:	11CA  7E      	FFIX2:	LD	A,(HL)
3940:	11CB  D690    		SUB	90H
3941:	11CD  23      		INC	HL
3942:	11CE  B6      		OR	(HL)
3943:	11CF  23      		INC	HL
3944:	11D0  4E      		LD	C,(HL)		;ACC1 to C
3945:	11D1  23      		INC	HL
3946:	11D2  B6      		OR	(HL)
3947:	11D3  23      		INC	HL
3948:	11D4  B6      		OR	(HL)
3949:	11D5  37      		SCF
3950:	11D6  C0      		RET	NZ		;ACCE <> 90H or ACCS, ACC2, ACC3 <> 0
3951:	11D7  47      		LD	B,A		;0 to B in case success
3952:	11D8  79      		LD	A,C
3953:	11D9  FE80    		CP	80H
3954:	11DB  C8      		RET	Z		;-32768, return 80H in A and 0 in B
3955:	11DC  37      		SCF
3956:	11DD  C9      		RET			;ACC1 <> 80H
3957:			
3958:			;floating point increment routine for fast NEXT code
3959:	11DE  7E      	FINCR:	LD	A,(HL)		;get argument exponent
3960:	11DF  FE81    		CP	81H		;does it have the exponent of a fp one?
3961:	11E1  C2470F  		JP	NZ,FADD		;nope - have to plow thru a fp add
3962:	11E4  E5      		PUSH	HL		;yup - test remainder of bytes
3963:	11E5  23      		INC	HL
3964:	11E6  7E      		LD	A,(HL)
3965:	11E7  23      		INC	HL
3966:	11E8  B6      		OR	(HL)
3967:	11E9  23      		INC	HL
3968:	11EA  B6      		OR	(HL)
3969:	11EB  E1      		POP	HL
3970:	11EC  C2470F  		JP	NZ,FADD		;not a fp one, have to use add
3971:	11EF  E5      		PUSH	HL
3972:	11F0  214A3D  		LD	HL,ACCE		;see if acc is easy to increment
3973:	11F3  7E      		LD	A,(HL)
3974:	11F4  B7      		OR	A		;is it zero?
3975:	11F5  CAFB11  		JP	Z,FINC1		;yes - hard to increment
3976:	11F8  3D      		DEC	A		;generate a carry if FACC is >=1 and
3977:	11F9  23      		INC	HL
3978:	11FA  86      		ADD	A,(HL)		;positive
3979:	11FB  E1      	FINC1:	POP	HL
3980:	11FC  D2470F  		JP	NC,FADD		;not easy to increment
3981:	11FF  3A4A3D  		LD	A,(ACCE)	;get current exponent
3982:	1202  1E00    		LD	E,0		;to defeat etest
3983:	1204  FE9A    		CP	25+81H		;will exponents differ by more than 23?
3984:	1206  D0      		RET	NC		;yes - no point in adding
3985:	1207  D681    		SUB	81H		;difference of exponents now in reg a
3986:	1209  010080  		LD	BC,8000H	;put mantissa of fp one into regs BCD
3987:	120C  51      		LD	D,C
3988:	120D  CA2D12  		JP	Z,FINC4
3989:	1210  5F      		LD	E,A		;save difference
3990:	1211  E607    		AND	7		;take difference mod 8
3991:	1213  6F      		LD	L,A		;bits to rotate the signifficant bit
3992:	1214  78      		LD	A,B		;fetch sig bit to rotate
3993:	1215  CA1D12  		JP	Z,FINC3		;bit in right pos, now pick right byte
3994:	1218  0F      	FINC2:	RRCA			;keep rotating until in right place
3995:	1219  2D      		DEC	L
3996:	121A  C21812  		JP	NZ,FINC2
3997:	121D  47      	FINC3:	LD	B,A		;assume bit belongs in 1st fraction
3998:	121E  7B      		LD	A,E		;test number of bits to see if it is so
3999:	121F  FE08    		CP	8		;set carry if it belongs here
4000:	1221  DA2D12  		JP	C,FINC4		;in which case, all is shifted
4001:	1224  48      		LD	C,B		;assume bit belongs in 2nd fraction
4002:	1225  45      		LD	B,L		;zero 1st fraction
4003:	1226  FE10    		CP	16		;set carry if it belongs in 2nd fraction
4004:	1228  DA2D12  		JP	C,FINC4
4005:	122B  51      		LD	D,C		;well, it must belong in 3rd fraction
4006:	122C  4D      		LD	C,L		;zero second fraction
4007:	122D  214E3D  	FINC4:	LD	HL,ACC3		;needed by add4
4008:	1230  C3AA0F  		JP	FADD4
4009:			
4010:			
4011:				ENDIF			;end of FLOAT conditional
4012:			
4013:			;end of FMATH
4015:			;FNSOPS 11/05/80
4016:			;XYBASIC Interpreter Source Module
4017:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
4018:			;arithmetic and control function and op routines
4019:			
4020:			;auxilliary functions called by fn / op routines
4021:			
4022:			;READP reads the port # given in C.
4023:	FFFF          		IF	NOT WILD
4024:	1233  CDFD01  	READP:	CALL	ISBYT
4025:	1236  79      		LD	A,C
4026:	1237  32AC3C  	RDP1:	LD	(RPORT+1),A	;set port #
4027:	123A  C3AB3C  		JP	RPORT		;read the port and return
4028:				ENDIF
4029:			
4030:			;STBIT sets bit # [(E) and (D)] of DE.
4031:			;Retn:	A,HL	clobbered
4032:			;	BC	preserved
4033:			;	DE	bit # [(E) and (D)] set, others reset
4034:	FFFF          		IF	NOT WILD
4035:	123D  160F    	STBT0:	LD	D,0FH
4036:	123F  7B      	STBIT:	LD	A,E
4037:	1240  A2      		AND	D		;(E) masked by (D) to A, carry reset
4038:	1241  110100  		LD	DE,1		;set bit 0 of DE
4039:	1244  C8      	STBI1:	RET	Z		;done if (A) = 0
4040:	1245  EB      		EX	DE,HL
4041:	1246  29      		ADD	HL,HL		;move bit left in HL
4042:	1247  EB      		EX	DE,HL
4043:	1248  3D      		DEC	A
4044:	1249  C34412  		JP	STBI1
4045:				ENDIF
4046:			
4047:			;SNFIX replaces (BC) and (DE) by their abs values, sets sign bit
4048:			;of TEMP iff exactly one of them was < 0.
4049:			;SNFX0 does SNFIX, returns Carry if (DE) = 0.
4050:	124C  7A      	SNFX0:	LD	A,D
4051:	124D  B3      		OR	E
4052:	124E  37      		SCF
4053:	124F  C8      		RET	Z		;return Carry if DE=0, else do SNFIX
4054:	1250  78      	SNFIX:	LD	A,B
4055:	1251  AA      		XOR	D		;desired sign to A7
4056:	1252  32503E  		LD	(TEMP),A	;and saved
4057:	1255  CD1A14  		CALL	IABS		;replace BC by abs(BC)
4058:	1258  D8      		RET	C
4059:	1259  7A      		LD	A,D
4060:	125A  B7      		OR	A
4061:	125B  FC0802  		CALL	M,CPLDE		;replace DE by -(DE) if negative
4062:	125E  C9      		RET
4063:			
4064:			;MULTY multiplies nonnegative integers in A and DE, leaves HL + product in HL.
4065:			;NB MULTY is used by RND to produce (HL) + (A) * (DE) mod 2 ^ 16 exactly, even
4066:			;on overflow, and is therefore more complicated than it would otherwise be.
4067:			;Call:	A	nonnegative multiplier
4068:			;	DE	nonnegative multiplicand
4069:			;Retn:	A	zero unless overflow
4070:			;	BC	preserved
4071:			;	DE	clobbered
4072:			;	HL	(HL) + (A) * (DE), mod 2 ^ 16 if overflow
4073:			;	Carry	set iff overflow
4074:			;MULBD multiplies unsigned values in BC and DE, returns result in HL.
4075:	125F  CD2302  	MULBD:	CALL	CMBDU
4076:	1262  D42314  		CALL	NC,BCDE		;force BC <= DE
4077:	1265  78      		LD	A,B
4078:	1266  B7      		OR	A
4079:	1267  37      		SCF
4080:	1268  C0      		RET	NZ		;overflow if both args >= 2 ^ 8
4081:	1269  79      		LD	A,C		;multiplier to A and fall though to MULT0
4082:	126A  210000  	MULT0:	LD	HL,0
4083:	126D  C5      	MULTY:	PUSH	BC
4084:	126E  0600    		LD	B,0		;keep track of overflow in B
4085:	1270  B7      	MULT1:	OR	A		;clear carry
4086:	1271  1F      		RRA			;get next bit of multiplier in carry
4087:	1272  D27912  		JP	NC,MULT2
4088:	1275  19      		ADD	HL,DE		;add multiplicand to partial product
4089:	1276  DCF719  		CALL	C,OVSET		;overflow
4090:	1279  B7      	MULT2:	OR	A
4091:	127A  CA8612  		JP	Z,MULT3		;done when no more bits on
4092:	127D  EB      		EX	DE,HL
4093:	127E  29      		ADD	HL,HL		;shift multiplicand left one
4094:	127F  EB      		EX	DE,HL
4095:	1280  DCF719  		CALL	C,OVSET		;overflow
4096:	1283  C37012  		JP	MULT1
4097:	1286  78      	MULT3:	LD	A,B
4098:	1287  C1      		POP	BC
4099:	1288  17      		RLA			;carry set iff overflow
4100:	1289  C9      		RET
4101:			
4102:			;DIVD0 does the work of division.
4103:			;Call:	BC	nonnegative dividend
4104:			;	DE	nonnegative nonzero divisor
4105:			;Retn:	DE	remainder
4106:			;	HL	quotient
4107:			;The dividend starts in HL and is shifted bit by bit into DE as quotient bits
4108:			;are shifted into HL.  At DIVD1, we have [0 bits : current dividend] in DE,
4109:			;[dividend bits : quotient bits] in HL.
4110:			;A tells us how many bits are left of : in the above description.
4111:	128A  60      	DIVD0:	LD	H,B
4112:	128B  69      		LD	L,C		;dividend to HL
4113:	128C  CD2014  		CALL	UMIND		;- divisor to BC
4114:	128F  110000  		LD	DE,0		;current dividend 0
4115:	1292  3E10    		LD	A,16		;count to A
4116:	1294  B7      		OR	A		;first quotient bit 0
4117:	1295  F5      	DIVD1:	PUSH	AF		;save quotient bit
4118:	1296  29      		ADD	HL,HL		;shift HL left
4119:	1297  F5      		PUSH	AF		;save high bit of dividend
4120:	1298  EB      		EX	DE,HL
4121:	1299  29      		ADD	HL,HL		;shift DE left
4122:	129A  F1      		POP	AF
4123:	129B  DCB312  		CALL	C,INXH		;add in dividend bit
4124:	129E  F1      		POP	AF
4125:	129F  D2A312  		JP	NC,DIVD3
4126:	12A2  13      		INC	DE		;add in quotient bit
4127:	12A3  E5      	DIVD3:	PUSH	HL		;save current dividend
4128:	12A4  09      		ADD	HL,BC		;try subtracting divisor
4129:	12A5  D2A912  		JP	NC,DIVD4	;too big, retain old one
4130:	12A8  E3      		EX	(SP),HL		;ok, keep new one
4131:	12A9  E1      	DIVD4:	POP	HL		;carry set iff subtraction worked
4132:	12AA  EB      		EX	DE,HL
4133:	12AB  3D      		DEC	A
4134:	12AC  C29512  		JP	NZ,DIVD1	;keep going
4135:	12AF  CE00    		ADC	A,0		;zero set iff carry reset
4136:	12B1  29      		ADD	HL,HL		;shift quotient one more time
4137:	12B2  C8      		RET	Z
4138:	12B3  23      	INXH:	INC	HL		;add in last quotient bit
4139:	12B4  C9      		RET
4140:			
4141:			;AMBOP is called during execution of an ambiguous binary op
4142:			;(namely + - * / and relations).  The args are forced to
4143:			;match and are fetched, and the type is returned in the status bits.
4144:			;In addition, the arg1 pointer is saved in TEMP2 for RETRY if integer.
4145:			;Call:	BC,DE	arg1, arg2 pointers
4146:			;Retn:	BC,DE	arg1, arg2 values if integer
4147:			;	CDE,BHL	arg1, arg2 values if string
4148:			;	FACC,HL	arg1 value, arg2 pointer if floating
4149:			;	Carry	set iff string
4150:			;	Zero	set iff integer
4151:	12B5  EB      	AMBOP:	EX	DE,HL		;arg2 addr to HL
4152:	12B6  0A      		LD	A,(BC)		;fetch arg1 type
4153:	12B7  BE      	AMBO1:	CP	(HL)		;RETRY entry point
4154:	12B8  C4DB12  		CALL	NZ,AMBTY	;force types to agree
4155:	12BB  C5      		PUSH	BC		;save arg1 pointer
4156:	12BC  CDBA01  		CALL	FETCH		;arg2 pointer to HL
4157:	12BF          		IFTYP	AMBOF, AMBOS	;branch if noninteger
4158:	12C5  E1      		POP	HL		;arg1 pointer to HL
4159:	12C6  C5      		PUSH	BC		;save arg2 value
4160:	12C7  CDBA01  		CALL	FETCH		;fetch arg1 value to BC
4161:	12CA  D1      		POP	DE		;arg2 value to DE
4162:	12CB  C9      		RET
4163:	FFFF          		IF	STRNG
4164:	12CC  E1      	AMBOS:	POP	HL		;arg1 pointer to HL
4165:	12CD  41      		LD	B,C		;arg2 length to B
4166:	12CE  D5      		PUSH	DE		;save arg2 loc
4167:	12CF  CDBA01  		CALL	FETCH		;arg1 to CDE
4168:	12D2  E1      		POP	HL		;arg2 loc to HL
4169:	12D3  C9      		RET
4170:				ENDIF
4171:	FFFF          		IF	FLOAT
4172:	12D4  E3      	AMBOF:	EX	(SP),HL		;save arg2 pointer, arg1 pointer to HL
4173:	12D5  CDBA01  		CALL	FETCH		;fetch arg1
4174:	12D8  E1      		POP	HL
4175:	12D9  23      		INC	HL		;point to arg2 value with HL
4176:	12DA  C9      		RET
4177:				ENDIF
4178:			;AMBTY forces both args to floating.
4179:	12DB          	AMBTY:
4180:	FFFF          		IF	FLOAT
4181:	12DB  CD8713  		CALL	CNVTF		;float arg2
4182:	12DE  C5      		PUSH	BC
4183:	12DF  E3      		EX	(SP),HL
4184:	12E0  CDCB0B  		CALL	CNVRT		;float arg1
4185:	12E3  E3      		EX	(SP),HL
4186:	12E4  C1      		POP	BC
4187:	12E5  C9      		RET
4188:				ELSE
4190:				ENDIF
4191:			
4192:			;CMPAR does the work of comparing two args for relation routines.
4193:			;Call:	BC, DE	arg pointers
4194:			;Retn:	BC	0
4195:			;	Carry, Zero	set as for CMBDS
4196:	12E6  CDB512  	CMPAR:	CALL	AMBOP		;fetch args, set status bits
4197:	12E9          		IFTYP	CMPAF, CMPAS	;branch if noninteger
4198:	12EF  CD2F02  		CALL	CMBDS		;compare integer arg1 to arg2, signed
4199:	12F2  010000  		LD	BC,0
4200:	12F5  C9      		RET
4201:	FFFF          		IF	STRNG
4202:	12F6  CDD22D  	CMPAS:	CALL	CMSTR		;compare string arg1 to arg2
4203:	12F9  010000  		LD	BC,0
4204:	12FC  C9      		RET
4205:				ENDIF
4206:	FFFF          		IF	FLOAT
4207:	12FD  CD1513  	CMPAF:	CALL	CMPFL		;perform floating compare
4208:	1300  010000  		LD	BC,0
4209:	1303  F0      		RET	P		;arg1 > arg2, return Carry reset
4210:	1304  C8      		RET	Z		;arg1 = arg2, return Zero set
4211:	1305  37      		SCF			;arg1 < arg2, return Carry set
4212:	1306  C9      		RET
4213:			
4214:			;ETEST tests the significance value in E.  If the result is
4215:			;insignificant it is replaced by a floating zero.
4216:	FFFF          		IF	(NOT F9511) AND (NOT FPBCD)
4217:	1307  67      	ETEST:	LD	H,A		;save A
4218:	1308  7B      		LD	A,E
4219:	1309  C680    		ADD	A,80H
4220:	130B  FE6D    		CP	(80H-SINDX) AND 255;compare to desired significance index
4221:	130D  7C      		LD	A,H		;restore A
4222:	130E  D0      		RET	NC		;result significant
4223:	130F  FE70    		CP	83H-SINDX	;compare exponent to see if small
4224:	1311  D0      		RET	NC		;not small, take computed value
4225:	1312  C3B80E  		JP	FZRO		;result insignificant, take 0. instead
4226:				ENDIF
4227:			
4228:			;CMPFL compares two FP numbers, returns Sign and Zero set as for FTEST.
4229:	0000          		IF	F9511
4243:				ELSE			;NOT F9511
4244:	0000          		IF	FPBCD
4249:				ELSE
4250:	1315  EB      	CMPFL:	EX	DE,HL		;arg2 exp address to DE
4251:	1316  214A3D  		LD	HL,ACCE		;arg1 (in FACC) exponent address to HL
4252:	1319  7E      		LD	A,(HL)
4253:	131A  B7      		OR	A		;Zero set iff exp(arg1) = 0
4254:	131B  1A      		LD	A,(DE)		;fetch exp(arg2)
4255:	131C  CA6D13  		JP	Z,CMPF5
4256:	131F  B7      		OR	A		;Zero set iff exp(arg2) = 0
4257:	1320  23      		INC	HL
4258:	1321  CA7113  		JP	Z,CMPF7
4259:	1324  13      		INC	DE
4260:	1325  1A      		LD	A,(DE)		;fetch sign(arg2)
4261:	1326  AE      		XOR	(HL)		;compare to sign(arg1)
4262:	1327  F27013  		JP	P,CMPF6		;signs not equal
4263:	132A  2B      		DEC	HL
4264:	132B  1B      		DEC	DE
4265:	132C  1A      		LD	A,(DE)		;fetch exp(arg2) again
4266:	132D  96      		SUB	(HL)		;compare to exp(arg1)
4267:	132E  C24E13  		JP	NZ,CMPF2	;exponents not equal
4268:	1331  23      		INC	HL
4269:	1332  23      		INC	HL
4270:	1333  13      		INC	DE
4271:	1334  1A      		LD	A,(DE)		;fetch mmsb(arg2)
4272:	1335  F680    		OR	80H		;restore hidden bit
4273:	1337  BE      		CP	(HL)		;compare to msb(arg1)
4274:	1338  C26513  		JP	NZ,CMPF4	;msb of fraction not equal
4275:	133B  23      		INC	HL
4276:	133C  13      		INC	DE
4277:	133D  1A      		LD	A,(DE)		;fetch byte2(arg2)
4278:	133E  BE      		CP	(HL)		;compare to byte2(arg1)
4279:	133F  C26513  		JP	NZ,CMPF4	;byte2 of fraction not equal
4280:	1342  1B      		DEC	DE
4281:	1343  1B      		DEC	DE		;readdress exp(arg2)
4282:	1344  EB      	CMPF1:	EX	DE,HL		;arg2 pointer to HL
4283:	1345  CD440F  		CALL	FSUB		;arg1-arg2
4284:	1348  CD0713  		CALL	ETEST		;check if almost 0
4285:	134B  C3C90E  		JP	FTEST		;set status bits and return
4286:	134E  3D      	CMPF2:	DEC	A
4287:	134F  CA5713  		JP	Z,CMPF3		;exponents differ by 1
4288:	1352  3C      		INC	A
4289:	1353  3C      		INC	A
4290:	1354  C26513  		JP	NZ,CMPF4	;exponents differ by more than 1
4291:	1357  23      	CMPF3:	INC	HL
4292:	1358  23      		INC	HL
4293:	1359  13      		INC	DE
4294:	135A  1A      		LD	A,(DE)		;fetch msb(arg2)
4295:	135B  AE      		XOR	(HL)		;msb(arg2) xor msb(arg1)
4296:	135C  1B      		DEC	DE
4297:	135D  3C      		INC	A		;Zero set if near exponent boundary
4298:	135E  CA4413  		JP	Z,CMPF1		;in which case do the subtraction
4299:	1361  2B      		DEC	HL
4300:	1362  2B      		DEC	HL
4301:	1363  1A      		LD	A,(DE)		;fetch exp(arg2)
4302:	1364  BE      		CP	(HL)		;Carry set if exp(arg2) < exp(arg1)
4303:	1365  1F      	CMPF4:	RRA			;Carry to A7
4304:	1366  214B3D  		LD	HL,ACCS		;address arg1 sign
4305:	1369  AE      		XOR	(HL)		;complement unless negative
4306:	136A  F601    		OR	1		;assure Zero reset
4307:	136C  C9      		RET
4308:	136D  B7      	CMPF5:	OR	A
4309:	136E  C8      		RET	Z		;both args 0, hence equal
4310:	136F  13      		INC	DE
4311:	1370  EB      	CMPF6:	EX	DE,HL		;sign(arg2) will give result
4312:	1371  7E      	CMPF7:	LD	A,(HL)
4313:	1372  EE80    		XOR	80H		;complemented sign(arg1) gives result
4314:	1374  F601    		OR	1		;assure Zero reset
4315:	1376  C9      		RET
4316:				ENDIF			;end of NOT FPBCD conditional
4317:				ENDIF			;end of NOT F9511 conditional
4318:			
4319:	1377  2A473D  	RETRY:	LD	HL,(ARGAD);arg1 pointer to HL
4320:	137A  44      		LD	B,H
4321:	137B  4D      		LD	C,L		;and then to BC
4322:	137C  210700  		LD	HL,VBYTS+2
4323:	137F  09      		ADD	HL,BC		;arg2 pointer to HL
4324:	1380  AF      		XOR	A		;to assure nonzero CMP at AMBO1
4325:	1381  C3B712  		JP	AMBO1		;convert to floating and refetch
4326:	1384  2A473D  	RTRY1:	LD	HL,(ARGAD)	;recover arg pointer
4327:	1387  3E02    	CNVTF:	LD	A,SNGST
4328:	1389  C3CB0B  		JP	CNVRT		;float it and return
4329:				ENDIF
4330:			
4331:	138C          	FCERN:	ERROR	N, F, C	;issue nonfatal FC error
4332:	1391  C9      		RET			;and return
4333:	1392          	FCERF:	ERROR	F, F, C		;fatal FC error
4334:			
4335:			
4336:			;routines for fn and op execution
4337:			
4338:			;ambiguous arithmetic ops
4339:			;AOP is a macro for executing ambiguous ops, namely + - * ABS and unary -.
4340:			;IOP, FOP and SOP are addresses of integer, floating and string routines.
4341:			;UNARY is a flag, TRUE if unary and FALSE if binary.
4342:			;SGNIF is a flag for significance checking, TRUE for + and -.
4343:			;FCERF is fatal FC error for string arg to arithmetic routine
4344:			AOP	MACRO	IOP,FOP,SOP,UNARY,SNGIF
4345:				LOCAL	EXFOP
4346:				IF	UNARY		;;first fetch args and set status bits
4347:				CALL	FETBC		;;fetch one arg from BC if unary
4348:				ELSE
4349:				CALL	AMBOP		;;fetch two agreeing args if binary
4350:				ENDIF
4351:				IFTYP	EXFOP, SOP	;;branch if noninteger
4352:				CALL	IOP		;;execute integer op
4353:				LD	A,INTST		;;return type integer
4354:				RET	NC		;;done unless overflow
4355:				IF	FLOAT
4356:				IF	UNARY
4357:				CALL	RTRY1		;;recover arg and float it
4358:				ELSE
4359:				CALL	RETRY		;;recover args and float them
4360:				ENDIF
4361:			EXFOP:	CALL	FOP		;;execute floating op
4362:				IF	F9511
4363:				CALL	FET95		;;fetch result if 9511 op
4364:				ELSE
4365:				IF	SNGIF AND NOT FPBCD
4366:				CALL	ETEST		;;test value in E for significance if SGNIF
4367:				ENDIF
4368:				ENDIF
4369:				LD	E,A		;;save A
4370:				LD	A,SNGST		;;return type floating
4371:				RET
4372:				ELSE
4373:				JP	IOVER		;;integer OV error if not floating version
4374:				ENDIF
4375:				ENDM
4376:			
4377:			;Addition(+): {<integer>|<floating>|<string>} x {<integer>|<floating>|<string>}
4378:			;	--> {<integer>|<floating>|<string>}
4379:	1397          	AADD:	AOP	IADD,FADD,SADD,FALSE,TRUE
4380:			
4381:			;Subtraction (-): {<integer>|<floating>} x {<integer>|<floating>}
4382:			;	--> {<integer>|<floating>}
4383:	13B3          	ASUB:	AOP	ISUB,FSUB,FCERF,FALSE,TRUE
4384:			
4385:			;Multiplication (*): {<integer>|<floating>} x {<integer>|<floating>}
4386:			;	--> {<integer>|<floating>}
4387:	13CF          	AMUL:	AOP	IMUL,FMUL,FCERF,FALSE,FALSE
4388:			
4389:			;Unary minus (-): {<integer> | <floating>} --> {<integer> | <floating>}
4390:	13E8          	AUMIN:	AOP	IUMIN,FCHS,FCERF,TRUE,FALSE
4391:			
4392:			;ABS: {<integer> | <floating>} --> {<integer> | <floating>}
4393:	1401          	AABS:	AOP	IABS,FABS,FCERF,TRUE,FALSE
4394:			
4395:			;Integer ABS, unary minus: <integer> --> <integer>
4396:			;IABS and IUMIN preserve DE and HL.
4397:	141A  78      	IABS:	LD	A,B
4398:	141B  B7      	IABS1:	OR	A		;sign set iff (BC) <0
4399:	141C  F0      		RET	P		;return if > 0, otherwise perform unary minus
4400:	141D  CD2314  	IUMIN:	CALL	BCDE		;arg to DE, DE to BC
4401:	1420  CD0802  	UMIND:	CALL	CPLDE		;complement it
4402:			;BCDE exchanges BC and DE.
4403:	1423  C5      	BCDE:	PUSH	BC
4404:	1424  42      		LD	B,D
4405:	1425  4B      		LD	C,E
4406:	1426  D1      		POP	DE
4407:	1427  C9      		RET
4408:			
4409:			;Integer addition and subtraction: <integer> x <integer> --> <integer>
4410:	1428  CD0802  	ISUB:	CALL	CPLDE		;complement and add
4411:	142B  D8      		RET	C
4412:	142C  7A      	IADD:	LD	A,D
4413:	142D  A8      		XOR	B		;sign (BC) xor sign (DE) to sign
4414:	142E  78      		LD	A,B		;sign of BC to A7 in case agree
4415:	142F  EB      		EX	DE,HL		;arg2 to HL
4416:	1430  09      		ADD	HL,BC
4417:	1431  44      		LD	B,H
4418:	1432  4D      		LD	C,L		;(BC) + (DE) to BC
4419:	1433  FA0F19  		JP	M,RETNC		;result ok if signs differ, return Carry reset
4420:	1436  A8      		XOR	B		;compare actual & desired result signs
4421:	1437  F0      		RET	P		;return if no overflow
4422:	1438  37      	STCR:	SCF
4423:	1439  C9      		RET
4424:			
4425:			;Integer multiplication: <integer> x <integer> --> <integer>
4426:	143A  CD5012  	IMUL:	CALL	SNFIX		;force BC, DE >= 0 and save desired result sign
4427:	143D  D8      		RET	C
4428:	143E  CD5F12  		CALL	MULBD		;BC * DE to HL
4429:	1441  D8      		RET	C
4430:	1442  44      	IMUL1:	LD	B,H		;divid entry point
4431:	1443  4D      		LD	C,L		;result to BC
4432:	1444  29      		ADD	HL,HL
4433:	1445  D8      		RET	C		;overflow if >= 2 ^ 15
4434:	1446  3A503E  		LD	A,(TEMP)
4435:	1449  C31B14  		JP	IABS1		;return according to desired sign
4436:			
4437:			;Integer division (\): <integer> x <integer> --> <integer>
4438:	144C  CD4C12  	IDIVD:	CALL	SNFX0		;force BC >= 0, DE > 0
4439:	144F  DAEB19  		JP	C,IOVER		;integer overflow if DE=0
4440:	1452  CD8A12  		CALL	DIVD0		;quotient to HL, remainder to DE
4441:	1455  C34214  		JP	IMUL1		;fix sign of result and return
4442:			
4443:			;MOD: <integer> x <integer> --> <integer>
4444:			;X mod Y = sign(X) * [abs(X) mod abs(Y)], so X = [(X/Y)*Y] + [X mod Y].
4445:	1458  60      	OPMOD:	LD	H,B		;save desired result sign in H
4446:	1459  CD4C12  		CALL	SNFX0		;force BC >= 0, DE > 0
4447:	145C  D8      		RET	C
4448:	145D  7C      		LD	A,H
4449:	145E  32503E  		LD	(TEMP),A	;desired result sign to TEMP
4450:	1461  CD8A12  		CALL	DIVD0		;remainder to DE
4451:	1464  EB      		EX	DE,HL		;result to HL
4452:	1465  C34214  		JP	IMUL1		;and return according to desired sign
4453:			
4454:			;Relations: {<integer>|<floating>|<string>} x {<integer>|<floating>|<string>}
4455:			;	--> <integer>
4456:			;Relations call CMPAR to set status bits and return 0 in BC.  The status
4457:			;bits are used to return if false (0), or decrement BC if true (-1).
4458:	1468  CDE612  	EQUAL:	CALL	CMPAR		;compare and zero BC
4459:	146B  C0      		RET	NZ		;false iff zero reset
4460:	146C  0B      		DEC	BC		;true
4461:	146D  C9      		RET
4462:	146E  CDE612  	NEQ:	CALL	CMPAR
4463:	1471  C8      		RET	Z		;false iff zero set
4464:	1472  0B      		DEC	BC
4465:	1473  C9      		RET
4466:	1474  CDE612  	LTHAN:	CALL	CMPAR
4467:	1477  D0      		RET	NC		;false iff carry reset
4468:	1478  0B      		DEC	BC
4469:	1479  C9      		RET
4470:	147A  CDE612  	GEQ:	CALL	CMPAR
4471:	147D  D8      		RET	C		;false iff carry set
4472:	147E  0B      		DEC	BC
4473:	147F  C9      		RET
4474:	1480  CDE612  	LEQ:	CALL	CMPAR
4475:	1483  DA8714  		JP	C,LEQ1
4476:	1486  C0      		RET	NZ		;false iff carry reset and zero reset
4477:	1487  0B      	LEQ1:	DEC	BC
4478:	1488  C9      		RET
4479:	1489  CDE612  	GTHAN:	CALL	CMPAR
4480:	148C  C8      		RET	Z		;false if zero set
4481:	148D  D8      		RET	C		;false if carry set
4482:	148E  0B      		DEC	BC
4483:	148F  C9      		RET
4484:			
4485:			;LOGOP is a macro to perform logical ops on B and D, and on C and E.
4486:			LOGOP	MACRO	LINST
4487:				LD	A,B
4488:				LINST	D		;;apply logical instruction to B and D
4489:				LD	B,A		;;and result to B
4490:				LD	A,C
4491:				LINST	E		;;apply logical instruction to C and E
4492:				LD	C,A		;;and result to C
4493:				RET
4494:				ENDM
4495:			
4496:			;NOT, XOR: <integer> --> <integer>
4497:	1490  11FFFF  	OPNOT:	LD	DE,-1		;not is xor with -1
4498:	1493          	OPXOR:	LOGOP	XRA
4499:			
4500:			;AND, RESET: <integer> x <integer> --> <integer>
4501:	FFFF          		IF	NOT WILD
4502:	149A  CD3D12  	RESET:	CALL	STBT0
4503:	149D  CD0902  		CALL	CPLD1		;reset bit #(E) mod 16 of DE, then AND
4504:				ENDIF
4505:	14A0          	OPAND:	LOGOP	ANA
4506:			
4507:			;OR, SET: <integer> x <integer> --> <integer>
4508:	FFFF          		IF	NOT WILD
4509:	14A7  CD3D12  	SETFN:	CALL	STBT0		;set bit #(E) mod 16 of DE, then OR
4510:				ENDIF
4511:	14AA          	OPOR:	LOGOP	ORA
4512:			
4513:			;JOIN: <integer> x <integer> --> <integer>
4514:	FFFF          		IF	NOT WILD
4515:	14B1  CDFD01  	JOIN:	CALL	ISBYT		;check (B) = 0
4516:	14B4  42      		LD	B,D
4517:	14B5  CDFD01  		CALL	ISBYT		;check (D) = 0
4518:	14B8  41      		LD	B,C
4519:	14B9  4B      		LD	C,E
4520:	14BA  C9      		RET
4521:				ENDIF
4522:			
4523:	FFFF          		IF	FLOAT AND NOT F9511
4524:			;INT: <floating> --> {<integer> | <floating>}
4525:	14BB          	INT:
4526:	0000          		IF	FPBCD
4529:				ENDIF
4530:	14BB  CDC814  		CALL	IINT		;try to convert to integer
4531:	14BE  3E01    		LD	A,INTST		;result type = integer
4532:	14C0  D0      		RET	NC		;return if successful conversion to integer
4533:	0000          		IF	FPBCD
4544:				ELSE			;NOT FPBCD
4545:	14C1  CDD814  		CALL	FLINT		;get integer part of floating value
4546:	14C4  5F      		LD	E,A
4547:				ENDIF			;end of NOT FPBCD conditional
4548:	14C5  3E02    	INT1:	LD	A,SNGST		;result type = floating
4549:	14C7  C9      		RET
4550:			
4551:			;IINT fixes a floating value to a two-byte integer value.
4552:	FFFF          		IF	NOT FPBCD	;IINT is same as FFIX in FPBCD version
4553:	14C8  1E10    	IINT:	LD	E,16
4554:	14CA  CD9411  		CALL	FFIX		;fix floating point value
4555:	14CD  D8      		RET	C		;cannot fix to integer, return Carry
4556:	14CE  48      		LD	C,B
4557:	14CF  47      		LD	B,A		;result to BC
4558:	14D0  C9      		RET
4559:				ENDIF			;end of NOT FPBCD conditional
4560:			
4561:			;UNS: <integer> --> <floating>
4562:	0000          		IF	FPBCD
4574:				ELSE			;NOT FPBCD
4575:	14D1  AF      	UNSFN:	XOR	A		;0 to A
4576:	14D2  111800  		LD	DE,24		;0 to D, 24 to E
4577:	14D5  C37E11  		JP	FFLOT		;float ABCD and return
4578:			
4579:	14D8  1E20    	FLINT:	LD	E,32
4580:	14DA  CD9411  		CALL	FFIX		;try fixing to 3-byte integer
4581:	14DD  1E20    		LD	E,32		;scale factor to E
4582:	14DF  D27E11  		JP	NC,FFLOT	;float the fixed value
4583:	14E2  C3C90E  		JP	FTEST		;fetch the floating value
4584:				ENDIF			;end of NOT FPBCD conditional
4585:				ENDIF
4586:			
4587:			;FIRST, LAST: --> <integer>
4588:	0000          		IF	ROMSQ AND (NOT WILD)
4594:				ELSE
4595:	013A          	FIRST	EQU	EXERR		;EX error in non-ROMSQ versions
4596:				ENDIF
4597:	0000          		IF	ROMSQ		;LAST must be defined in WILD versions
4603:				ELSE
4604:	013A          	LAST	EQU	EXERR
4605:				ENDIF
4606:			
4607:			;MSBYTE, LSBYTE: <integer> --> <integer>
4608:	FFFF          		IF	NOT WILD
4609:	14E5  48      	MSBYT:	LD	C,B		;move ms to ls byte
4610:	14E6  0600    	LSBYT:	LD	B,0		;zero ms byte
4611:	14E8  C9      		RET
4612:				ENDIF
4613:			
4614:			;BCD: <integer> --> <integer>
4615:	FFFF          		IF	NOT WILD
4616:	14E9  AF      	BCD:	XOR	A
4617:	14EA  CD3A17  		CALL	CVTIS		;convert integer to string, no leading char
4618:	14ED  FE05    		CP	5
4619:	14EF  D20615  		JP	NC,FCER0	;length >= 5, nonfatal FC error and return 0
4620:	14F2  210000  		LD	HL,0		;embryo value to HL
4621:	14F5  1A      	BCD1:	LD	A,(DE)		;fetch next char of string
4622:	14F6  13      		INC	DE		;and point to next
4623:	14F7  D630    		SUB	'0'		;subtract ASCII bias
4624:	14F9  29      		ADD	HL,HL
4625:	14FA  29      		ADD	HL,HL
4626:	14FB  29      		ADD	HL,HL
4627:	14FC  29      		ADD	HL,HL		;result left one nibble
4628:	14FD  B5      		OR	L
4629:	14FE  6F      		LD	L,A		;and new nibble ORed in
4630:	14FF  0D      		DEC	C		;count down length
4631:	1500  C2F514  		JP	NZ,BCD1		;more chars in string
4632:	1503  44      		LD	B,H
4633:	1504  4D      		LD	C,L		;result to BC
4634:	1505  C9      		RET
4635:				ENDIF			;end of NOT WILD conditional
4636:	1506  CD8C13  	FCER0:	CALL	FCERN		;issue nonfatal FC error
4637:	1509  010000  		LD	BC,0
4638:	150C  3E01    		LD	A,INTST		;and return integer 0 as result
4639:	150E  C9      		RET
4640:			
4641:			;BIN: <integer> --> <integer>
4642:	FFFF          		IF	NOT WILD
4643:	150F  210000  	BIN:	LD	HL,0		;embryo value to HL
4644:	1512  CD1C15  		CALL	BIN1		;sum high order byte
4645:	1515  41      		LD	B,C
4646:	1516  CD1C15  		CALL	BIN1		;sum low order byte
4647:	1519  44      		LD	B,H
4648:	151A  4D      		LD	C,L		;result to BC
4649:	151B  C9      		RET
4650:	151C  78      	BIN1:	LD	A,B
4651:	151D  1F      		RRA
4652:	151E  1F      		RRA
4653:	151F  1F      		RRA
4654:	1520  1F      		RRA			;ms four bits to A3-A0
4655:	1521  CD2515  		CALL	BIN2		;add to sum
4656:	1524  78      		LD	A,B		;ls four bits to A3-A0
4657:	1525  E60F    	BIN2:	AND	0FH		;mask off other bits
4658:	1527  FE0A    		CP	0AH
4659:	1529  D29213  		JP	NC,FCERF	;not a bcd digit, FC error
4660:	152C  54      		LD	D,H
4661:	152D  5D      		LD	E,L		;copy value to DE
4662:				ENDIF			;end of NOT WILD conditional
4663:			;HL10A replaces (HL) with 10*(HL)+(A), and is called by GTDEC.
4664:			;Call:	DE,HL	value to multiply by 10
4665:			;	A	value to add to product
4666:			;Retn:	BC	preserved
4667:			;	DE	clobbered
4668:			;	HL	result
4669:	152E  29      	HL10A:	ADD	HL,HL		; * 2
4670:	152F  29      		ADD	HL,HL		; * 4
4671:	1530  19      		ADD	HL,DE		; * 5
4672:	1531  29      		ADD	HL,HL		; * 10
4673:	1532  D8      		RET	C		;for GTDEC, never happens from BIN
4674:	1533  5F      		LD	E,A
4675:	1534  1600    		LD	D,0		;next value to DE
4676:	1536  19      		ADD	HL,DE		;and added also
4677:	1537  C9      		RET
4678:			
4679:			;GET, GET$: --> {<integer> | <string>}
4680:	1538  3A313D  	GET:	LD	A,(GCHAR)	;value for GET is in GCHAR
4681:	153B  4F      		LD	C,A
4682:	153C  AF      		XOR	A
4683:	153D  47      		LD	B,A		;value to BC
4684:	153E  32313D  		LD	(GCHAR),A	;clear GCHAR
4685:	FFFF          		IF	STRNG
4686:	1541  1624    		LD	D,'$'
4687:	1543  CD8E18  		CALL	GTD		;look for $
4688:	1546  3E01    		LD	A,INTST		;return type integer
4689:	1548  D8      		RET	C		;integer GET
4690:	1549  79      		LD	A,C		;else string GET$
4691:	154A  0E00    		LD	C,0
4692:	154C  B7      		OR	A		;Zero set iff no char in GET
4693:	154D  C43B2F  		CALL	NZ,CHRS1	;copy char to string space
4694:	1550  3E03    		LD	A,STRST		;and return type string
4695:	1552  C9      		RET
4696:				ELSE			;NOT STRNG
4699:				ENDIF
4700:			
4701:			;IOBYTE: --> <integer>
4702:	FFFF          		IF	(NOT CAMAC) AND (NOT WILD)
4703:	1553  3A0300  	IOBYF:	LD	A,(IOBYT)
4704:	1556  C35A15  		JP	PEEK1		;return IOBYTE value in BC
4705:				ENDIF
4706:			
4707:			;PEEK: <integer> --> <integer>
4708:	FFFF          		IF	NOT WILD
4709:	1559  0A      	PEEK:	LD	A,(BC)		;fetch the byte
4710:				ENDIF			;peek1 is needed for POS
4711:	155A  0600    	PEEK1:	LD	B,0		;zero the MSbyte
4712:	155C  4F      		LD	C,A		;return value in BC
4713:	155D  C9      		RET
4714:			
4715:			;POS: --> <integer>
4716:	FFFF          		IF	NOT CAMAC
4717:	155E  3AE03C  	POS:	LD	A,(COLUM)
4718:	1561  C35A15  		JP	PEEK1		;return current column in BC
4719:				ENDIF
4720:			
4721:			;TEST: <integer> x <integer> --> <integer>
4722:	FFFF          		IF	NOT WILD
4723:	1564  CD3D12  	TEST:	CALL	STBT0		;set bit # (E) mod 16 of DE
4724:	1567  CDA014  		CALL	OPAND		;AND with (BC) -- returns (C) in A
4725:	156A  B0      		OR	B		;zero set iff (BC) = 0
4726:	156B  010000  	TEST1:	LD	BC,0		;return 0 if zero set
4727:	156E  C8      		RET	Z
4728:	156F  03      		INC	BC		;return 1 if zero reset
4729:	1570  C9      		RET
4730:				ENDIF
4731:			
4732:			;SGN: {<integer> | <floating>} --> <integer>
4733:	1571  CDB801  	SGN:	CALL	FETBC		;fetch arg
4734:	1574          		IFTYP	FSGN,FCERF	;branch if noninteger
4735:	157A  78      		LD	A,B
4736:	157B  B1      		OR	C		;Zero set iff (BC)=0
4737:	157C  C8      		RET	Z		;and result is 0
4738:	157D  78      		LD	A,B
4739:	157E  F601    		OR	1		;Zero reset, minus set iff (BC) < 0
4740:	1580  01FFFF  	SGN1:	LD	BC,-1
4741:	1583  F8      		RET	M		;< 0, return -1
4742:	1584  03      		INC	BC
4743:	1585  C8      		RET	Z		;= 0, return 0
4744:	1586  03      		INC	BC
4745:	1587  C9      		RET			;else > 0, return 1
4746:	FFFF          		IF	FLOAT AND NOT F9511
4747:	1588  CDC90E  	FSGN:	CALL	FTEST		;set status bits
4748:	158B  C38015  		JP	SGN1		;and return as above
4749:				ENDIF
4750:			
4751:			;IN: <integer> --> <integer>
4752:	FFFF          		IF	NOT WILD
4753:	158E  CD3312  	IMPM:	CALL	READP		;read the port
4754:	1591  4F      		LD	C,A		;and return value read in BC
4755:	1592  C9      		RET
4756:				ENDIF
4757:			
4758:			;SENSE: <integer> x <integer> --> <integer>
4759:	FFFF          		IF	NOT WILD
4760:	1593  1607    	SENSE:	LD	D,7
4761:	1595  CD3F12  		CALL	STBIT		;set bit # (E) mod 8 of E
4762:	1598  CD3312  		CALL	READP		;read port
4763:	159B  A3      		AND	E
4764:	159C  C36B15  		JP	TEST1		;return zero iff bit reset
4765:				ENDIF
4766:			
4767:			;FRE, FRE$: --> <integer>
4768:	159F          	FREFN:
4769:	FFFF          		IF	STRNG
4770:	159F  1624    		LD	D,'$'
4771:	15A1  CD8E18  		CALL	GTD		;look for $
4772:	15A4  DAAD15  		JP	C,FRE		;not FRE$, just return FRE
4773:	15A7  CDA72C  		CALL	GARBG		;garbage collect to compact string space
4774:	15AA  C3B515  		JP	FRE1		;and continue as below
4775:				ENDIF
4776:	15AD  2A593E  	FRE:	LD	HL,(CSTKP)
4777:	15B0  EB      		EX	DE,HL		;address of control stack top to DE
4778:	15B1  13      		INC	DE		;CSTKP + 1
4779:	15B2  2A5D3E  		LD	HL,(SYMTA)	;symbol table address to HL
4780:	15B5  CD0802  	FRE1:	CALL	CPLDE		;- CSTKP - 1
4781:	15B8  19      	FRE2:	ADD	HL,DE		;top - [bottom + 1] = available
4782:	15B9  44      		LD	B,H		;NB 'subtraction', so carry reset iff borrow
4783:	15BA  4D      		LD	C,L		;result to BC
4784:	15BB  C9      		RET
4785:			
4786:			;LSHIFT: <integer> x <integer> --> <integer>
4787:	FFFF          		IF	NOT WILD
4788:	15BC  7B      	LSHFT:	LD	A,E		;shift (BC) left by (E) mod 16 places
4789:	15BD  E60F    		AND	0FH
4790:	15BF  50      		LD	D,B
4791:	15C0  59      		LD	E,C		;BC to DE for STBI1
4792:	15C1  CD4412  		CALL	STBI1		;shift (DE) left (A) bits
4793:	15C4  42      		LD	B,D
4794:	15C5  4B      		LD	C,E
4795:	15C6  C9      		RET
4796:				ENDIF
4797:			
4798:			;RSHIFT, ROTATE: <integer> x <integer> --> <integer>
4799:	FFFF          		IF	NOT WILD
4800:	15C7  1600    	RSHFT:	LD	D,0		;shift (BC) right by (E) mod 16 places
4801:	15C9  21      		DEFB	21H		;lxi h, to skip ensuing two bytes
4802:	15CA  1680    	ROTAT:	LD	D,80H		;rotate / shift (BC) right by (E) mod 16 places
4803:	15CC  7B      		LD	A,E		;entry point for rshft with (D) = 0
4804:	15CD  E60F    		AND	0FH		;mask E and clear carry
4805:	15CF  C8      		RET	Z		;done if zero
4806:	15D0  5F      		LD	E,A		;(E) mod 16 to E
4807:	15D1  78      	ROTA1:	LD	A,B
4808:	15D2  D2D615  		JP	NC,ROTA2
4809:	15D5  B2      		OR	D		;turn on high bit if rotating and carry
4810:	15D6  1F      	ROTA2:	RRA
4811:	15D7  47      		LD	B,A		;carry now has high bit for C
4812:	15D8  79      		LD	A,C
4813:	15D9  1F      		RRA			;carry now has high bit for B if rotating
4814:	15DA  4F      		LD	C,A
4815:	15DB  1D      		DEC	E
4816:	15DC  C2D115  		JP	NZ,ROTA1	;keep rotating
4817:	15DF  D0      		RET	NC		;done unless carry
4818:	15E0  78      		LD	A,B
4819:	15E1  B2      		OR	D		;turn on high bit if rotating
4820:	15E2  47      		LD	B,A
4821:	15E3  C9      		RET
4822:				ENDIF			;end of NOT WILD conditional
4823:			
4824:	0000          		IF	REALT
4843:				ENDIF
4844:			
4845:			;RND: --> <integer> [if nonFLOATing version]
4846:			;RND: <floating> --> <floating> [if FLOATing version]
4847:			;RND generates the next pseudorandom 16-bit integer
4848:			;	RANDX = (RANDA * RANDX + RANDC) mod 2 ^ 16, and returns the 15-bit
4849:			;	pseudorandom integer RANDX / 2.  Cf. Knuth Ch. 3, esp. pp. 155-6.
4850:	FFFF          		IF	NOT WILD
4851:	15E4          	RND:
4852:	FFFF          		IF	FLOAT
4853:	15E4  03      		INC	BC
4854:	15E5  C5      		PUSH	BC		;save pointer to arg
4855:	0000          		IF	F9511
4858:				ELSE
4859:	15E6  CDC90E  		CALL	FTEST
4860:				ENDIF
4861:	15E9  C2F015  		JP	NZ,RND1		;nonzero arg, take it for multiplier
4862:	15EC  21A20C  		LD	HL,FPONE	;zero arg, take 1 instead
4863:	15EF  E3      		EX	(SP),HL
4864:				ENDIF
4865:	15F0  2A2E3D  	RND1:	LD	HL,(RANDX)
4866:	15F3  E5      		PUSH	HL
4867:	15F4  EB      		EX	DE,HL		;(RANDX) to DE
4868:	15F5  3E64    		LD	A,RANDA SHR 8	;ms bits of RANDA to A
4869:	15F7  CD6A12  		CALL	MULT0		;ms(RANDA) * (RANDX) to HL
4870:	15FA  65      		LD	H,L
4871:	15FB  2E00    		LD	L,0		;and then * 2 ^ 8
4872:	15FD  11733A  		LD	DE,RANDC
4873:	1600  19      		ADD	HL,DE		; + RANDC
4874:	1601  D1      		POP	DE		;(RANDX) to DE again
4875:	1602  3EB5    		LD	A,RANDA AND 255	;ls bits of RANDA to A
4876:	1604  CD6D12  		CALL	MULTY		;(RANDA) * (RANDX) + RANDC to HL
4877:	1607  222E3D  		LD	(RANDX),HL	;and to RANDX
4878:	FFFF          		IF	FLOAT
4879:	0000          		IF	F9511
4898:				ELSE			;NOT F9511
4899:	160A  44      		LD	B,H
4900:	160B  4D      		LD	C,L		;value to BC
4901:	0000          		IF	FPBCD
4907:				ELSE			;NOT FPBCD
4908:	160C  110800  		LD	DE,8		;0 to D, scale factor = 8 to E
4909:	160F  7A      		LD	A,D		;0 to A
4910:	1610  CD7E11  		CALL	FFLOT		;float to random value in range [0,1)
4911:				ENDIF			;end of NOT FPBCD conditional
4912:	1613  E1      		POP	HL		;arg to HL
4913:	1614  C3FA0E  		JP	FMUL		;result = arg * rnd and return
4914:				ENDIF			;end of F9511 conditional
4915:				ELSE			;NOT FLOAT
4924:				ENDIF
4925:				ENDIF			;end of NOT WILD conditional
4926:			
4927:			
4928:			;end of FNSOPS
4930:			;FP9511 12/21/79
4931:			;XYBASIC Interpreter Source Module
4932:			;Copyright (C) 1979 by Mark Williams Company, Chicago
4933:			;floating point package for 9511 chip
4934:			
4935:	0000          		IF	FLOAT AND F9511
5677:				ENDIF
5678:			
5679:			;end of FP9511
5680:			;FPBCD 11/19/80
5681:			;XYBASIC Interpreter Source Module
5682:			;Copyright (C) 1980 by Mark Williams Company, Chicago
5683:			;BCD floating point package
5684:			
5685:			
5686:	0000          		IF	FLOAT AND FPBCD
7544:				ENDIF
7545:			
7546:			;end of module FPBCD
7547:			;INOUT 12/05/80
7548:			;XYBASIC Interpreter Source Module
7549:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
7550:			;input / output & error routines
7551:			
7552:			;WRITC writes a character from A.
7553:			;Call:	A	char to be written
7554:			;Retn:	A,BC,DE,HL	preserved
7555:			;The character is sent to the CON device if (OMODE) = 0.
7556:			;The char is also sent to the LST device if (LMODE) <> 0.
7557:			;The char is sent to the disk (in CP/M nonCOMPL version) if (AMODE) <> 0.
7558:			;COLUM gives the print column of the last char written (line of width WIDTH).
7559:			;A crlf is written if the current char causes COLUM > WIDTH.
7560:			;A linefeed is preceeded by (NULLS) nulls.
7561:	FFFF          		IF	NOT WILD
7562:			;WRTS0 is called by print routines to print trailing space after numbers.
7563:	1617  2AE03C  	WRTS0:	LD	HL,(COLUM)	;column to L, width to H
7564:	161A  7D      		LD	A,L
7565:	161B  BC      		CP	H
7566:	161C  C8      		RET	Z		;suppress trailing space if in last column
7567:				ENDIF
7568:	161D  3E20    	WRTSP:	LD	A,' '
7569:	161F          	WRITC:	PUSH4			;save registers
7570:	1623  4F      		LD	C,A		;char passed in C
7571:	1624  2AE03C  		LD	HL,(COLUM)	;width to H, column to L
7572:	1627  FE0D    		CP	CR
7573:	1629  C22E16  		JP	NZ,WRTC1
7574:	162C  2E00    		LD	L,0		;cr resets column count
7575:	162E          	WRTC1:
7576:	FFFF          		IF	NOT WILD
7577:	162E  FE0A    		CP	LF
7578:	1630  CC7F16  		CALL	Z,WNULS		;write nulls if linefeed
7579:				ENDIF
7580:	FFFF          		IF	NOT EPSTN
7581:	1633  FE08    		CP	CNTLH
7582:	1635  CC6616  		CALL	Z,DECRC		;decrement column if <control-h>
7583:				ENDIF
7584:	1638  FE20    		CP	20H
7585:	163A  D46C16  		CALL	NC,BUMPC	;bump column if printable
7586:	163D  22E03C  		LD	(COLUM),HL
7587:	FFFF          		IF	CPM AND SDISK AND (NOT RTPAK)
7588:	1640  2AA43C  		LD	HL,(FILEP)
7589:	1643  7C      		LD	A,H
7590:	1644  B5      		OR	L
7591:	1645  C2521F  		JP	NZ,DWRIT	;write char to disk file
7592:				ENDIF
7593:	0000          		IF	BENDX AND SDISK
7597:				ENDIF
7598:	1648  3AEB3C  		LD	A,(OMODE)
7599:	FFFF          		IF	(CPM OR ISIS2 OR GENMC OR (BENDX AND SDISK)) AND NOT COMPL
7600:	164B  FE80    		CP	80H		;check if doing ASCII save
7601:	164D  CAC116  		JP	Z,DSAVE
7602:				ENDIF
7603:	0000          		IF	WILD
7608:				ENDIF
7609:	1650  B7      	WRTC2:	OR	A		;check if output to be suppressed
7610:	FFFF          		IF	(NOT WILD) OR (NOT RTPAK);no CNOUT in WILD RTPAK
7611:	1651  C5      		PUSH	BC
7612:	1652  CC9B3C  		CALL	Z,CNOUT
7613:	1655  C1      		POP	BC
7614:				ENDIF
7615:	FFFF          		IF	(CPM OR ISIS2 OR GENMC) AND NOT COMPL
7616:	1656  FE7F    		CP	7FH		;check if doing ASCII LOAD
7617:	1658  CA6216  		JP	Z,POP4		;ignore remaining checks if so
7618:				ENDIF
7619:	0000          		IF	CPM AND DEBUG AND NOT COMPL
7625:				ENDIF
7626:	FFFF          		IF	NOT WILD
7627:	165B  3AEA3C  		LD	A,(LMODE)
7628:	165E  B7      		OR	A		;check LST write mode
7629:	165F  C49E3C  		CALL	NZ,LOUT
7630:				ENDIF
7631:	1662  F1      	POP4:	POP	AF		;common restore and returns
7632:	1663  C39309  		JP	POP3
7633:	1666  2D      	DECRC:	DEC	L		;decrement column count for backspace
7634:	1667  F0      		RET	P		;done unless was column 0
7635:	1668  2C      		INC	L		;undecrement
7636:	1669  C37A16  		JP	WLF		;write linefeed and return
7637:	166C  7D      	BUMPC:	LD	A,L
7638:	166D  2C      		INC	L		;increment column
7639:	166E  BC      		CP	H
7640:	166F  D8      		RET	C		;column < width -- ok
7641:	1670  7C      		LD	A,H		;fetch width
7642:	1671  B7      		OR	A
7643:	1672  C8      		RET	Z		;suppress automatic crlfs if width is 0
7644:	1673  2E01    		LD	L,1		;column >= width -- write crlf and return
7645:	0000          		IF	EPSTN
7649:				ENDIF
7650:	1675  3E0D    	WCRLF:	LD	A,CR
7651:	1677  CD1F16  		CALL	WRITC
7652:	167A  3E0A    	WLF:	LD	A,LF
7653:	167C  C31F16  		JP	WRITC
7654:	FFFF          		IF	NOT WILD
7655:	167F  3A303D  	WNULS:	LD	A,(NULLS)	;fetch null count
7656:	1682  47      		LD	B,A		;save in B
7657:	1683  04      		INC	B
7658:	1684  AF      		XOR	A		;null char to A
7659:	1685  05      	WNUL1:	DEC	B
7660:	1686  C8      		RET	Z		;done
7661:	1687  CD1F16  		CALL	WRITC		;write a null
7662:	168A  C38516  		JP	WNUL1		;and test for more
7663:				ENDIF
7664:			
7665:			;READC reads one char from the console.
7666:			;The parity bit (i.e. bit 7) is reset.
7667:			;The user is returned to direct mode if the char is <cntl-c>.
7668:			;The system is booted if the char is <cntl-b>.
7669:			;The LST mode is toggled if  the char is <cntl-p>.
7670:			;Retn:	A	char read, masked by 7FH
7671:			;	BC,DE,HL	preserved
7672:	168D          	READC:	PUSH3			;save registers
7673:	FFFF          		IF	(CPM OR ISIS2 OR GENMC OR (BENDX AND SDISK)) AND NOT COMPL
7674:	1690  3AEB3C  		LD	A,(OMODE)
7675:	1693  FE7F    		CP	7FH		;check if ASCII load
7676:	1695  CAFB05  		JP	Z,DLOAD		;yes
7677:				ENDIF
7678:	1698  CD983C  		CALL	CONIN		;read the console
7679:	169B  E67F    		AND	7FH		;mask off parity
7680:	FFFF          		IF	(NOT WILD) OR (NOT RTPAK);no ^B, ^C in Wild RTPAK
7681:	169D  FE02    		CP	CNTLB
7682:	169F  CC6234  		CALL	Z,ECHOC
7683:	0000          		IF	DEBUG
7685:				ELSE
7686:	0000          		IF	CAMAC AND CPM
7688:				ENDIF
7689:	16A2  CA0000  		JP	Z,BOOT		;jmp monitor if not debug and control-B
7690:				ENDIF
7691:	16A5  FE03    		CP	CNTLC
7692:	16A7  CC6234  		CALL	Z,ECHOC
7693:	16AA  CAA83C  		JP	Z,DMODC		;break to direct mode if control-c
7694:				ENDIF
7695:	0000          		IF	CPM AND DEBUG AND NOT COMPL
7698:				ENDIF
7699:	FFFF          		IF	NOT WILD	;no LST device
7700:	16AD  FE10    		CP	CNTLP
7701:	16AF  C29309  		JP	NZ,POP3
7702:	16B2  CD6234  		CALL	ECHOC
7703:	16B5  3AEA3C  		LD	A,(LMODE)	;toggle LST mode if control-p
7704:	16B8  2F      		CPL
7705:	16B9  32EA3C  		LD	(LMODE),A
7706:	16BC  3E10    		LD	A,CNTLP		;restore char to A
7707:				ENDIF
7708:	16BE  C39309  		JP	POP3
7709:			
7710:	FFFF          		IF	(CPM OR ISIS2 OR GENMC) AND NOT COMPL
7711:	16C1  CDE605  	DSAVE:	CALL	DKOUT		;write char to disk file
7712:	16C4  C36216  		JP	POP4		;restore and return
7713:				ENDIF
7714:			
7715:			;REDYC determines whether char is ready at console.
7716:			;Retn:	Carry	set iff char ready
7717:	16C7          	REDYC:	PUSH3			;save registers
7718:	16CA  CD953C  		CALL	CSTAT
7719:	16CD  0F      		RRCA
7720:	16CE  C39309  		JP	POP3		;restore and return
7721:			
7722:			;CTEST looks for character at console, and READCs it if present.
7723:			;All chars are ignored except the following:
7724:			;	<cntl-b>	reboots (from READC)
7725:			;	<cntl-c>	breaks (branch to dmode, with message)
7726:			;	<cntl-o>	toggles CONsole output mode
7727:			;	<cntl-p>	toggles LST mode (from READC)
7728:			;	<cntl-s>	suspends interpreter execution until either
7729:			;				<cntl-x> (reboot) or <cntl-q> (resume)
7730:			;Retn:	A	clobbered
7731:			;	BC,DE,HL	preserved
7732:	16D1  CDC716  	CTEST:	CALL	REDYC		;check if char ready
7733:	16D4  D0      		RET	NC		;no char ready
7734:	16D5  CD8D16  	CTST0:	CALL	READC		;ready, so read the char -- driver entry point
7735:	FFFF          		IF	(NOT WILD) OR (NOT RTPAK)
7736:	16D8  FE0F    		CP	CNTLO
7737:	16DA  CC6234  		CALL	Z,ECHOC
7738:	16DD  CAF516  		JP	Z,CTST1		;toggle output mode if cntl-o and return
7739:				ENDIF
7740:	FFFF          		IF	NOT WILD
7741:	16E0  FE13    		CP	CNTLS
7742:	16E2  CAE916  		JP	Z,CTST2		;wait for cntl-q if cntl-s
7743:				ENDIF
7744:	16E5  32313D  		LD	(GCHAR),A	;else save it for GET
7745:	16E8  C9      		RET
7746:	FFFF          		IF	NOT WILD
7747:	16E9  CD8D16  	CTST2:	CALL	READC
7748:	16EC  FE11    		CP	CNTLQ		;check if cntl-q
7749:	16EE  C8      		RET	Z		;return if so
7750:	16EF  FE13    		CP	CNTLS
7751:	16F1  C8      		RET	Z		;return if cntl-s toggled also
7752:	16F2  C3E916  		JP	CTST2		;else wait
7753:				ENDIF
7754:	FFFF          		IF	(NOT WILD) OR (NOT RTPAK)
7755:	16F5  3AEB3C  	CTST1:	LD	A,(OMODE)
7756:	16F8  2F      		CPL			;toggle omode
7757:	16F9  32EB3C  		LD	(OMODE),A
7758:	16FC  C37516  		JP	WCRLF		;echo crlf and return
7759:				ENDIF
7760:			
7761:			;WRTBS prints (BC) as a signed decimal number, with leading '-' if negative.
7762:			;WRTBU prints (BC) as an unsigned decimal number.
7763:			;The current column & width are checked to avoid breaking the number with crlf.
7764:			;WRTB1 is an entry point from PRINT, to print nonnegatives with leading space.
7765:			;Call:	BC	integer
7766:			;Retn:	A	clobbered
7767:			;	BC,DE,HL	preserved
7768:	16FF  78      	WRTBS:	LD	A,B
7769:	1700  B7      		OR	A
7770:	1701  F20D17  		JP	P,WRTBU		;write unsigned if positive
7771:	1704  C5      		PUSH	BC		;else save BC
7772:	1705  CD1D14  		CALL	IUMIN		;negate BC (NB -32768 is OK)
7773:	1708  3E2D    		LD	A,'-'		;leading minus sign
7774:	170A  C30F17  		JP	WRTB2		;and write
7775:	170D  AF      	WRTBU:	XOR	A		;no leading char
7776:	170E  C5      	WRTB1:	PUSH	BC		;save BC
7777:	170F  D5      	WRTB2:	PUSH	DE
7778:	1710  E5      		PUSH	HL		;and DE, HL
7779:	1711  CD3A17  		CALL	CVTIS		;convert integer to string
7780:	1714  CD1A17  		CALL	PRSTL		;print string on one line
7781:	1717  C39309  		JP	POP3
7782:			
7783:			;PRSTR prints the string addressed by C,DE.
7784:			;PRSTL tries to print the string addressed by C,DE without crlf.
7785:	171A  2AE03C  	PRSTL:	LD	HL,(COLUM)	;width to H, column to L
7786:	171D  7C      		LD	A,H		;fetch width
7787:	171E  B7      		OR	A
7788:	171F  CA2F17  		JP	Z,PRSTR		;just print the string if width is 0
7789:	1722  79      		LD	A,C		;length to A
7790:	1723  85      		ADD	A,L		;column + length = last column needed
7791:	1724  3F      		CCF			;carry reset iff > 255
7792:	1725  D22C17  		JP	NC,PRSL1	;much too long, write crlf first
7793:	1728  BC      		CP	H		;carry reset iff last needed >= width
7794:	1729  CA2F17  		JP	Z,PRSTR		;just fits
7795:	172C  D47516  	PRSL1:	CALL	NC,WCRLF	;write crlf if too long for current printline
7796:	172F  0C      	PRSTR:	INC	C		;length+1
7797:	1730  0D      	PRST1:	DEC	C		;decrement length
7798:	1731  C8      		RET	Z		;done
7799:	1732  1A      		LD	A,(DE)		;fetch next string char
7800:	1733  CD1F16  		CALL	WRITC		;print it
7801:	1736  13      		INC	DE
7802:	1737  C33017  		JP	PRST1		;and write more
7803:			
7804:			;CVTIS converts the integer in BC to a string of ASCII decimal digits.
7805:			;The result is loaded into the buffer at BUFAD.
7806:			;Call:	A	leading char (ASCII space or minus sign, 0 for none)
7807:			;	BC	unsigned integer value
7808:			;Retn:	A,C	length of string result
7809:			;	DE	location of string result, i.e. BUFAD
7810:			;	B,HL	clobbered
7811:	173A  60      	CVTIS:	LD	H,B
7812:	173B  69      		LD	L,C		;value to HL
7813:	173C  015F3E  		LD	BC,BUFAD	;destination to BC
7814:	173F  C5      		PUSH	BC		;and saved
7815:	1740  B7      		OR	A
7816:	1741  CA4717  		JP	Z,CVIS1		;no leading char desired
7817:	1744  02      		LD	(BC),A		;store leading char
7818:	1745  03      		INC	BC		;and point to next available location
7819:	1746  AF      		XOR	A		;clear A for mod10
7820:	1747  11F0D8  	CVIS1:	LD	DE,-10000
7821:	174A  CD6817  		CALL	MOD10
7822:	174D  1118FC  		LD	DE,-1000
7823:	1750  CD6817  		CALL	MOD10
7824:	1753  119CFF  		LD	DE,-100
7825:	1756  CD6817  		CALL	MOD10
7826:	1759  11F6FF  		LD	DE,-10
7827:	175C  CD6817  		CALL	MOD10
7828:	175F  7D      		LD	A,L		;units digit to A
7829:	1760  CD7B17  		CALL	MOD1B		;and to string
7830:	1763  D1      		POP	DE		;location to DE
7831:	1764  79      		LD	A,C		;last+1 to A
7832:	1765  93      		SUB	E		;last+1 - first = length
7833:	1766  4F      		LD	C,A		;and length to C
7834:	1767  C9      		RET
7835:			
7836:			;MOD10 adds the decimal digit n = (HL) div -(DE) to the string at (BC)
7837:			;and leaves HL with (HL) + n * (DE).  Zeros suppressed if (A) = 0 when called.
7838:	1768  C5      	MOD10:	PUSH	BC
7839:	1769  06FF    		LD	B,255
7840:	176B  22503E  	MOD1A:	LD	(TEMP),HL
7841:	176E  04      		INC	B
7842:	176F  19      		ADD	HL,DE
7843:	1770  DA6B17  		JP	C,MOD1A
7844:	1773  2A503E  		LD	HL,(TEMP)	;remainder to HL
7845:	1776  50      		LD	D,B		;result to D, temporarily
7846:	1777  C1      		POP	BC		;restore BC
7847:	1778  B2      		OR	D		;zero set iff (A) > 0 or (D) > 0
7848:	1779  C8      		RET	Z
7849:	177A  7A      		LD	A,D		;result to A
7850:	177B  C630    	MOD1B:	ADD	A,'0'		;entry point for final digit
7851:	177D  02      		LD	(BC),A		;add ASCII digit to string
7852:	177E  03      		INC	BC
7853:	177F  C9      		RET
7854:			
7855:	FFFF          		IF	NOT COMPL
7856:			;PRNTL prints line # (as unsigned decimal, suppressed if zero) and space
7857:			;and a line of user source text, expanding tokens as necessary.
7858:			;Call:	HL	address of line #
7859:			;Retn:	A,DE	clobbered
7860:			;	BC	preserved
7861:			;	HL	address following last text byte, i.e. after <cr>
7862:			;PRTL0 prints line with <linefeed> if (DE) matches location.
7863:			;PRTLC prints line with <linefeed> at TEXTP.
7864:	1780  2AC63F  	PRTLC:	LD	HL,(TEXTP)
7865:	1783  EB      		EX	DE,HL		;current TEXTP to DE
7866:	1784  2AE23C  		LD	HL,(LNNUM)	;current LNNUM to HL
7867:	1787  CD9017  		CALL	PRTL0		;print the line
7868:	178A  C37516  		JP	WCRLF		;and crlf
7869:	178D  110000  	PRNTL:	LD	DE,0		;print without linefeed
7870:	1790  C5      	PRTL0:	PUSH	BC
7871:	1791  CD0901  		CALL	LINB1		;line # to BC
7872:	1794  CAB617  		JP	Z,PRTL3		;zero, i.e. direct mode
7873:	1797  CD0D17  		CALL	WRTBU		;write the line #
7874:	179A  23      		INC	HL		;past break byte
7875:	179B  23      		INC	HL		;to first text byte
7876:	179C  3E20    		LD	A,' '
7877:	179E  BE      		CP	(HL)		;check if first char is space
7878:	179F  C41D16  		CALL	NZ,WRTSP	;write a space if not
7879:	17A2  C1      	PRTL1:	POP	BC		;restore BC
7880:	17A3  CD2902  	PRTL2:	CALL	CMDHU		;compare to text pointer
7881:	17A6  CC7A16  		CALL	Z,WLF		;write linefeed if equal
7882:	17A9  7E      		LD	A,(HL)		;fetch next byte from text
7883:	17AA  23      		INC	HL
7884:	17AB  FE0D    		CP	CR
7885:	17AD  C8      		RET	Z		;cr, done
7886:	17AE  E5      		PUSH	HL
7887:	17AF  CDBC17  		CALL	PRTCH		;print char or token
7888:	17B2  E1      		POP	HL
7889:	17B3  C3A317  		JP	PRTL2
7890:	17B6  21703E  	PRTL3:	LD	HL,TLNAD
7891:	17B9  C3A217  		JP	PRTL1
7892:			
7893:			;PRTCH prints a char or token.
7894:			;Call:	A	char or token
7895:	17BC  CDCE1F  	PRTCH:	CALL	FNDTK		;look up the token
7896:	17BF  D21F16  		JP	NC,WRITC	;char, just print it
7897:				ENDIF			;else fall through to PRTST to print token
7898:			
7899:			;PRTST prints a string with successive calls to WRITC.
7900:			;Call:	HL	address of string's first text char
7901:			;Retn:	A	clobbered
7902:			;	BC,DE	preserved
7903:			;	HL	address following string's last text char
7904:	17C2  7E      	PRTST:	LD	A,(HL)		;fetch a byte to print
7905:	17C3  E67F    		AND	7FH		;mask off end of entry bit
7906:	17C5  CD1F16  		CALL	WRITC		;print it
7907:	17C8  7E      		LD	A,(HL)		;check end of entry byte again
7908:	17C9  B7      		OR	A
7909:	17CA  23      		INC	HL		;move up pointer
7910:	17CB  F2C217  		JP	P,PRTST		;keep printing
7911:	17CE  C9      		RET			;end of entry, done
7912:			
7913:			;PRNTM prints the message which directly follows the CALL PRNTM.
7914:			;PRTM0 turns on OMODE and then prints message with PRNTM.
7915:	17CF  AF      	PRTM0:	XOR	A
7916:	17D0  32EB3C  		LD	(OMODE),A	;turn on output mode
7917:	FFFF          		IF	CPM AND SDISK	;reset file pointer
7918:	17D3  210000  		LD	HL,0
7919:	17D6  22A43C  		LD	(FILEP),HL
7920:				ENDIF
7921:	0000          		IF	BENDX AND SDISK
7923:				ENDIF
7924:	17D9  E1      	PRNTM:	POP	HL		;address following CALL to HL
7925:	17DA  CDC217  		CALL	PRTST		;print the message
7926:	17DD  E9      		JP	(HL)		;and return to the next address
7927:			
7928:	0000          		IF	WILD		;error handling
7944:				ELSE			;NOT WILD
7945:			;ERROF, ERRON and ERROC are error routine entry points for Fatal,
7946:			;Nonfatal and Continue errors.  In each case the
7947:			;error routine is invoked with the ERROR macro, e.g. with
7948:			;	ERROR	F, X, Y
7949:			;issuing a fatal XY error with the code
7950:			;	call	errof
7951:			;	db	'X', 'Y' or 80H
7952:			;The error message following the call is printed, followed by the
7953:			;user source line # (if any) and user source line.
7954:			;If TRAP, any error terminates execution and returns the user to DMODE, with
7955:			;a CONTinue entry on the CSTACK to allow continuation at the next command.
7956:			;If UNTRAP:
7957:			;Fatal errors return to DMODE, as if TRAP.
7958:			;Nonfatal errors continue execution with all registers preserved.
7959:			;Continue errors continue execution with the next source text command.
7960:	17DE  E3      	ERROF:	EX	(SP),HL		;message address to HL, HL to stack
7961:	17DF  F5      		PUSH	AF		;PSW to stack
7962:	17E0  37      		SCF			;Carry set for fatal
7963:	17E1  C3EE17  		JP	ERRO0
7964:	17E4  E3      	ERROC:	EX	(SP),HL
7965:	17E5  F5      		PUSH	AF
7966:	17E6  AF      		XOR	A		;Carry reset, Zero set for Continue
7967:	17E7  C3EE17  		JP	ERRO0
7968:	17EA  E3      	ERRON:	EX	(SP),HL
7969:	17EB  F5      		PUSH	AF
7970:	17EC  F601    		OR	1		;Carry reset, Zero reset for nonfatal
7971:	17EE  D5      	ERRO0:	PUSH	DE		;save DE
7972:	17EF  EB      		EX	DE,HL		;message address to DE
7973:	FFFF          		IF	CPM AND SDISK AND (NOT RTPAK)
7974:	17F0  2AA43C  		LD	HL,(FILEP)
7975:				ENDIF
7976:	0000          		IF	BENDX AND SDISK
7979:				ENDIF
7980:	17F3  E5      		PUSH	HL		;save current BFILP
7981:	17F4  F5      		PUSH	AF		;save error type
7982:	17F5  CDCF17  		CALL	PRTM0		;turn on OMODE, print CRLF
7983:	17F8  0D8A    		DEFB	CR, LF OR 80H
7984:	17FA  EB      		EX	DE,HL		;message address to HL
7985:	17FB  CDC217  		CALL	PRTST		;print message
7986:	17FE  F1      		POP	AF
7987:	17FF  E5      		PUSH	HL		;save return address in case nonfatal
7988:	1800  F5      		PUSH	AF		;and save error type again
7989:	1801  CDD917  		CALL	PRNTM		;print ERROR message
7990:	0000          		IF	COMPL
7997:				ELSE
7998:	1804  20455252		DEFB	' ERROR:', ' ' OR 80H
	      4F523AA0
7999:	180C  CD8017  		CALL	PRTLC		;print the line
8000:	FFFF          		IF	EDITC
8001:	180F  C5      		PUSH	BC
8002:	1810  CD0601  		CALL	LINBC		;line number to BC
8003:	1813  CA1B18  		JP	Z,ERRO1		;skip resetting ERRLN if 0
8004:	1816  60      		LD	H,B
8005:	1817  69      		LD	L,C		;then to HL
8006:	1818  22E43C  		LD	(ERRLN),HL	;and save for EDIT
8007:	181B  C1      	ERRO1:	POP	BC		;restore BC
8008:				ENDIF
8009:	181C  3AE63C  		LD	A,(TRAP)	;0 trap, 255 untrap
8010:	181F  B7      		OR	A
8011:	1820  CA3718  		JP	Z,ERRO2		;TRAP, so scan to next and go to DMODE
8012:				ENDIF
8013:	1823  F1      		POP	AF		;recover error type
8014:	1824  DA3718  		JP	C,ERRO2		;fatal, to DMODE as if TRAP
8015:	1827  CA6507  		JP	Z,NEXTC		;continue with next command
8016:	182A  D1      		POP	DE		;return address to DE
8017:	FFFF          		IF	CPM AND SDISK AND (NOT RTPAK)
8018:	182B  E1      		POP	HL
8019:	182C  22A43C  		LD	(FILEP),HL	;restore FILEP
8020:				ENDIF
8021:	0000          		IF	BENDX AND SDISK
8024:				ENDIF
8025:	182F  CDD116  		CALL	CTEST		;test for console break char
8026:	1832  EB      		EX	DE,HL		;return address to HL
8027:	1833  D1      		POP	DE		;restore DE
8028:	1834  F1      		POP	AF		;restore psw
8029:	1835  E3      		EX	(SP),HL		;restore HL, return address to stack
8030:	1836  C9      		RET
8031:	0000          		IF	CAMAC
8033:				ELSE
8034:			;Fatal errors:  build control stack entry, scan to delimiter, and goto DMODE.
8035:	1837  CD0601  	ERRO2:	CALL	LINBC		;LNNUM to HL, Zero set iff direct
8036:	183A  CA3D07  		JP	Z,DMOD2		;error from DMODE, skip entry building
8037:	183D  2B      		DEC	HL		;address length byte of current line
8038:	183E  E5      		PUSH	HL		;and save
8039:	183F  5E      		LD	E,(HL)
8040:	1840  1600    		LD	D,0		;length of current line to DE
8041:	1842  19      		ADD	HL,DE		;address of following line
8042:	1843  EB      		EX	DE,HL		;to DE
8043:	1844  2AC63F  		LD	HL,(TEXTP)
8044:	1847  CD2902  		CALL	CMDHU		;check if within current text line
8045:	184A  DA3D07  		JP	C,DMOD2		;after current line, skip entry building
8046:	184D  D1      		POP	DE
8047:	184E  CD2902  		CALL	CMDHU
8048:	1851  D23D07  		JP	NC,DMOD2	;before current line, skip entry building
8049:	1854  CDB718  		CALL	GTDEL		;else scan to delimiter
8050:	1857  C3B025  		JP	ENDC1		;build break entry and go to DMODE
8051:				ENDIF			;end of NOT CAMAC conditional
8052:				ENDIF			;end of NOT WILD condtional
8053:			
8054:			
8055:			;end of INOUT
8057:			;ISIS2 05/21/81
8058:			;XYBASIC Interpreter Source Module
8059:			;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
8060:			;statement routines for ISIS-II version SAVE and LOAD, plus GTFIL
8061:			
8062:	0000          		IF	ISIS2		;ISIS-II versions
8486:				ENDIF			;end of ISIS2 conditional
8487:			
8488:			
8489:			;end of ISIS2
8491:			;NONST 08/06/80
8492:			;XYBASIC Interpreter Source Module
8493:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
8494:			;routines for nonstandard version SAVE and LOAD, plus GTFIL
8495:			;includes custom EPSTN and GENMC versions
8496:			
8497:			
8498:	0000          		IF	NONST		;NONST versions
8947:				ENDIF			;end of NONST conditional
8948:			
8949:			
8950:			;end of NONST
8952:			;PARSING 8/26/79
8953:			;XYBASIC Interpreter Source Module
8954:			;Copyright (C) 1978, 1979 by Mark Williams Company, Chicago
8955:			;parsing routines
8956:			
8957:			;Register use for all parsing routines, except as noted.
8958:			;Call:	(textp)	address of next text char
8959:			;Retn:	A	clobbered
8960:			;	BC,DE	preserved
8961:			;	HL	address of next unparsed char
8962:			;	(textp)	ditto
8963:			;	Carry	set iff failure
8964:			
8965:			;GTCHA fetches the next nonspace character.
8966:	185A  2AC63F  	GTCHA:	LD	HL,(TEXTP)
8967:	185D  7E      	GTCH1:	LD	A,(HL)		;fetch character
8968:	185E  23      		INC	HL		;point to next
8969:	185F  FE20    		CP	' '
8970:	1861  CA5D18  		JP	Z,GTCH1		;try again if space
8971:	1864  22C63F  		LD	(TEXTP),HL	;store new text pointer
8972:	1867  C9      		RET
8973:			
8974:			;GTCHO looks ahead to the next nonspace char.
8975:	1868  CD5A18  	GTCHO:	CALL	GTCHA
8976:	186B  2B      	BAKUP:	DEC	HL		;back up textp
8977:	186C  22C63F  		LD	(TEXTP),HL
8978:	186F  C9      		RET
8979:			
8980:			;GTALP fetches the next char if alphabetic, returns Carry if not.
8981:	1870  CD6818  	GTALP:	CALL	GTCHO
8982:	1873  CDF918  		CALL	ISALP
8983:	1876  D8      		RET	C		;not a letter
8984:	1877  23      	READ1:	INC	HL
8985:	1878  22C63F  		LD	(TEXTP),HL	;else read it
8986:	187B  C9      		RET
8987:			
8988:			;GTCOM gets a comma.
8989:	187C  CD5A18  	GTCOM:	CALL	GTCHA
8990:	187F  FE2C    		CP	','
8991:	1881  C8      		RET	Z
8992:	1882  C39318  		JP	BKUPC		;back up textp and return Carry
8993:			
8994:			;GTCND gets a comma not followed by a delimiter.
8995:	1885  CD7C18  	GTCND:	CALL	GTCOM
8996:	1888  D8      		RET	C		;no comma
8997:	1889  CD3F01  		CALL	DTST0		;look for delimiter
8998:	188C  3F      		CCF			;carry set iff delimiter follows comma
8999:	188D  C9      		RET
9000:			
9001:			;GTD returns carry reset and moves up textp if next char matches (D), else
9002:			;returns carry set and leaves (textp) unchanged.
9003:			;GTDSN gets a char which must match (D), else SN error is issued.
9004:			;GTDTR does a GTDSN and echoes the char if trace print is desired.
9005:	188E  CD5A18  	GTD:	CALL	GTCHA
9006:	1891  BA      		CP	D
9007:	1892  C8      		RET	Z
9008:	1893  37      	BKUPC:	SCF			;return carry set if no match
9009:	1894  C36B18  		JP	BAKUP		;back up textp and return
9010:	FFFF          		IF	NOT COMPL
9011:	1897  3AE83C  	GTDTR:	LD	A,(INLHS)
9012:	189A  B7      		OR	A
9013:	189B  CAA618  		JP	Z,GTDSN		;do not echo unless INLHS
9014:	189E  3AE93C  		LD	A,(VTRAC)
9015:	18A1  17      		RLA			;carry set iff trace print desired
9016:	18A2  7A      		LD	A,D
9017:	18A3  DC1F16  		CALL	C,WRITC		;write it if so
9018:				ENDIF			;and fall through to GTDSN
9019:	18A6  CD8E18  	GTDSN:	CALL	GTD
9020:	18A9  D0      		RET	NC
9021:	18AA  C33501  		JP	SNERR
9022:	0000          		IF	COMPL
9024:				ENDIF
9025:	18AD  1629    	GTREQ:	LD	D,')'
9026:	18AF  CDA618  		CALL	GTDSN		;skip ) and fall through to skip =
9027:	18B2  16CC    	GTEQU:	LD	D,EQULT
9028:	18B4  C3A618  		JP	GTDSN		;skip = token
9029:			
9030:			;GTDEL scans text until delimiter is found.
9031:	18B7  CD3F01  	GTDEL:	CALL	DTST0		;test if current is delimiter
9032:	18BA  D0      		RET	NC		;delimiter, done
9033:	18BB  CD7718  		CALL	READ1		;no, read the current
9034:	18BE  FE22    		CP	'"'
9035:	18C0  CCC618  		CALL	Z,GTCLQ		;watch for quoted strings
9036:	18C3  C3B718  		JP	GTDEL		;and try the next
9037:			
9038:			;GTCLQ scans to close quote or <cr>.
9039:			;Call:	HL	next char addr
9040:			;Retn:	HL	addr of " or cr
9041:			;	textp	reset
9042:	18C6  7E      	GTCLQ:	LD	A,(HL)		;fetch next
9043:	18C7  FE0D    		CP	CR
9044:	18C9  C8      		RET	Z		;done if cr
9045:	18CA  CD7718  		CALL	READ1		;else read it
9046:	18CD  FE22    		CP	'"'
9047:	18CF  C2C618  		JP	NZ,GTCLQ	;and keep reading if not close "
9048:	18D2  2B      		DEC	HL		;point to "
9049:	18D3  C9      		RET
9050:			
9051:			;ISDIG presrves A and returns Carry set iff (A) is not ASCII digit.
9052:	18D4  FE30    	ISDIG:	CP	'0'
9053:	18D6  D8      		RET	C		;too small
9054:	18D7  FE3A    		CP	'9'+1
9055:	18D9  3F      		CCF
9056:	18DA  C9      		RET
9057:			
9058:			;ISHEX converts an ASCII hex digit to binary.
9059:			;Both upper and lower case alphabetic characters are allowed.
9060:			;Call:	A	character
9061:			;Retn:	Carry	set iff not a hex digit
9062:			;	A	binary value if Carry reset, clobbered if Carry
9063:			;	BCDEHL	preseved
9064:	18DB  D630    	ISHEX:	SUB	'0'		;subtract bias
9065:	18DD  FE37    		CP	'G'+20H-'0'
9066:	18DF  3F      		CCF
9067:	18E0  D8      		RET	C		;return Carry set if < '0' or > 'f'
9068:	18E1  FE0A    		CP	10
9069:	18E3  3F      		CCF			;Carry reset for '0' to '9'
9070:	18E4  D0      		RET	NC		;decimal digit
9071:	18E5  E61F    		AND	1FH		;mask to convert lower case to upper
9072:	18E7  D611    		SUB	'A'-'0'		;'A' becomes 0, 'B' becomes 1...
9073:	18E9  FE06    		CP	6
9074:	18EB  3F      		CCF
9075:	18EC  D8      		RET	C		;return Carry if not legal hex digit
9076:	18ED  C60A    		ADD	A,10		;'A' becomes 10, 'B' becomes 11...
9077:	18EF  C9      		RET
9078:			
9079:			;GTILD gets the next letter or digit without skipping spaces, and is
9080:			;called by GTNAM and GTFIL to build a variable or file name.
9081:			;Call:	HL	address of next char to parse
9082:			;Retn:	A	next char
9083:			;	BC,DE	preserved
9084:			;	HL	incremented
9085:			;	(textp)	value of HL when called
9086:			;	Carry	set iff next not letter or digit
9087:	18F0  7E      	GTILD:	LD	A,(HL)
9088:	18F1  22C63F  		LD	(TEXTP),HL	;leave textp set for failure
9089:	18F4  23      		INC	HL
9090:	18F5  CDD418  	LDTST:	CALL	ISDIG
9091:	18F8  D0      		RET	NC		;digit
9092:	18F9  FE41    	ISALP:	CP	'A'
9093:	18FB  D8      		RET	C		;neither
9094:	18FC  FE5B    		CP	'Z'+1
9095:	18FE  3F      		CCF			;carry iff not letter
9096:	18FF  C9      		RET
9097:			
9098:			;GTDEC scans an unsigned decimal integer and returns its value.
9099:			;An unsigned decimal integer is a string of decimal digits.
9100:			;The digit count (not including leading 0s) is used for overflow detection.
9101:			;1-4 digits indicates no overflow.
9102:			;6+ digits indicates overflow.
9103:			;5 digits indicates overflow iff (value of 4 digits)*10 > 65535 or
9104:			;	(value of 4 digits)*10 + (value of digit 5) > 65535.
9105:			;	Note that 9999*5 is always < 65535.
9106:			;Retn:	Carry	set iff no decimmal digit
9107:			;	Zero	set if overflow, i.e. integer > 65535
9108:			;	A	clobbered
9109:			;	BC	preserved
9110:			;	DE	integer value 0 <= n <= 65535 if Carry and Zero reset
9111:			;	DE	0 if Carry or Zero
9112:			;	HL	address of next nondigit
9113:			;GTDE0 is called from GTDEC to scan through leading 0s.
9114:	1900  23      	GTDE0:	INC	HL
9115:	1901  22C63F  		LD	(TEXTP),HL	;read leading 0
9116:	1904  7E      		LD	A,(HL)		;fetch next char
9117:	1905  D630    		SUB	'0'
9118:	1907  CA0019  		JP	Z,GTDE0		;another leading 0
9119:	190A  FE0A    		CP	10		;carry set iff decimal digit
9120:	190C  DA2519  		JP	C,GTDE1		;digit follows leading 0s
9121:	190F  B7      	RETNC:	OR	A		;nondigit, return C,Z reset and result 0
9122:	1910  C9      		RET
9123:	1911  110000  	GTDEC:	LD	DE,0		;default value to DE
9124:	1914  CD6818  		CALL	GTCHO		;next char to A, textp to HL
9125:	1917  D630    		SUB	'0'		;subtract ASCII bias
9126:	1919  CA0019  		JP	Z,GTDE0		;strip off leading 0s
9127:	191C  FE0A    		CP	10
9128:	191E  DA2519  		JP	C,GTDE1		;digit
9129:	1921  7E      		LD	A,(HL)		;refetch next
9130:	1922  B7      		OR	A		;clear Zero
9131:	1923  37      		SCF			;and set Carry
9132:	1924  C9      		RET
9133:	1925  5F      	GTDE1:	LD	E,A		;first digit value to DE
9134:	1926  C5      		PUSH	BC		;save BC
9135:	1927  06FA    		LD	B,-6 AND 255	;-(max # digits + 1) to B
9136:	1929  04      	GTDE2:	INC	B		;# digits read - max # - 1
9137:	192A  23      		INC	HL
9138:	192B  7E      		LD	A,(HL)		;fetch next char
9139:	192C  D630    		SUB	'0'		;subtract ASCII bias
9140:	192E  FE0A    		CP	10
9141:	1930  D24219  		JP	NC,GTDE3	;nondigit, done
9142:	1933  E5      		PUSH	HL		;save textp
9143:	1934  62      		LD	H,D
9144:	1935  6B      		LD	L,E		;copy value to HL
9145:	1936  CD2E15  		CALL	HL10A		;10 * old value + current digit = new value
9146:	1939  EB      		EX	DE,HL		;to DE
9147:	193A  E1      		POP	HL		;restore textp
9148:	193B  D22919  		JP	NC,GTDE2	;get next if no overflow
9149:	193E  04      		INC	B		;bump digit count to assure > 5 on overflow
9150:	193F  C32919  		JP	GTDE2		;and get next char
9151:	1942  22C63F  	GTDE3:	LD	(TEXTP),HL	;update textp
9152:	1945  78      		LD	A,B		;fetch digit count - max - 1
9153:	1946  C1      		POP	BC		;restore BC
9154:	1947  B7      		OR	A
9155:	1948  F8      		RET	M		;count <= max #, return both C and Z reset
9156:	1949  AF      		XOR	A		;overflow, return C reset and Z set
9157:	194A  57      		LD	D,A
9158:	194B  5F      		LD	E,A		;and 0 in DE
9159:	194C  C9      		RET
9160:			
9161:			;GTLNO returns a legal line # in DE, using GTDEC.
9162:			;Brances to fatal US error if GTDEC returns overflow or 0.
9163:			;Otherwise 	(1) nonexistent or 	(2) 0 < n < 2 ^ 16.
9164:			;Retn:	A	next non-space char	clobbered
9165:			;	BC	preserved		preserved
9166:			;	DE	0			n
9167:			;	HL	addr of next nondigit	address of next nondigit
9168:			;	Carry	set			reset
9169:	194D  CD1119  	GTLNO:	CALL	GTDEC		;look for decimal integer
9170:	1950  D8      		RET	C		;none, return Carry
9171:	1951  7A      		LD	A,D
9172:	1952  B3      		OR	E
9173:	1953  C0      		RET	NZ		;legal line #, return Carry reset
9174:	1954          	USERR:	ERROR	F, U, S		;fatal US error -- illegal line #
9175:			
9176:			;GTLIT gets a literal, and is called by EVAL, READ, INPUT and VAL.
9177:			;The literal may be preceeded by optional spaces and untokenized + and - signs.
9178:			;Call:	HL	(textp)
9179:			;Retn:	Carry	set iff no literal found
9180:			;	A	type token
9181:			;	BC	value if integer
9182:			;	C,DE	value if string
9183:			;	(TEMP)BCD	value if floating
9184:	1959  7E      	GTLIT:	LD	A,(HL)		;fetch next
9185:	195A  23      		INC	HL		;and point to following
9186:	195B  F5      	GTLT1:	PUSH	AF
9187:	195C  AF      		XOR	A
9188:	195D  32503E  		LD	(TEMP),A	;sign = positive
9189:	1960  F1      		POP	AF
9190:	1961  CDD418  	GTLT2:	CALL	ISDIG		;check if char is digit
9191:	1964  D2F919  		JP	NC,GTLID
9192:	FFFF          		IF	FLOAT
9193:	1967  FE2E    		CP	'.'
9194:	1969  CA221A  		JP	Z,GTLIF		;get floating literal
9195:				ENDIF
9196:	196C  22C63F  		LD	(TEXTP),HL	;else read the char
9197:	FFFF          		IF	STRNG
9198:	196F  FE22    		CP	'"'
9199:	1971  CA9E19  		JP	Z,GTLIS		;get string literal
9200:				ENDIF
9201:	1974  010001  		LD	BC,INTST SHL 8	;overflow flag to B, 0 to C
9202:	1977  51      		LD	D,C
9203:	1978  59      		LD	E,C		;embryo value 0 to DE
9204:	1979  FE23    		CP	'#'
9205:	197B  CAC119  		JP	Z,GTLIH		;get hex literal
9206:	197E  FE26    		CP	'&'
9207:	1980  CAAA19  		JP	Z,GTLIB		;get binary literal
9208:	1983  FE20    		CP	' '
9209:	1985  CA9919  		JP	Z,GTLT3		;leading space -- ignore
9210:	1988  FE2B    		CP	'+'
9211:	198A  CA9919  		JP	Z,GTLT3		;unary +
9212:	198D  FE2D    		CP	'-'		;check for unary -
9213:	198F  C29318  		JP	NZ,BKUPC	;else back up TEXTP and return Carry
9214:	1992  3A503E  		LD	A,(TEMP)	;unary minus -- complement sign
9215:	1995  2F      		CPL
9216:	1996  32503E  		LD	(TEMP),A
9217:	1999  7E      	GTLT3:	LD	A,(HL)
9218:	199A  23      		INC	HL		;point to next
9219:	199B  C36119  		JP	GTLT2		;and keep looking
9220:			;get a string literal, i.e. quoted string
9221:	FFFF          		IF	STRNG
9222:	199E  E5      	GTLIS:	PUSH	HL		;save string location
9223:	199F  CDC618  		CALL	GTCLQ		;scan to close " or cr
9224:	19A2  D1      		POP	DE		;location to DE
9225:	19A3  7D      	GTLS1:	LD	A,L		;last+1 -- EVUNQ entry point
9226:	19A4  93      		SUB	E		;last+1-first = length
9227:	19A5  4F      		LD	C,A		;to C
9228:	19A6  3E03    		LD	A,STRST		;type = string
9229:	19A8  B7      		OR	A		;return Carry reset
9230:	19A9  C9      		RET
9231:				ENDIF
9232:			;get binary integer literal
9233:	19AA  EB      	GTLIB:	EX	DE,HL		;textp to DE, value to HL
9234:	19AB  1A      	GTLB1:	LD	A,(DE)		;fetch char
9235:	19AC  D630    		SUB	'0'		;subtract ASCII bias
9236:	19AE  FE02    		CP	2
9237:	19B0  D2DC19  		JP	NC,OVTST	;not a binary digit, done
9238:	19B3  13      		INC	DE
9239:	19B4  0C      		INC	C		;bump count
9240:	19B5  29      		ADD	HL,HL		;shift value left one bit
9241:	19B6  DCF719  		CALL	C,OVSET		;set overflow flag
9242:	19B9  1F      		RRA			;current digit to Carry
9243:	19BA  D2AB19  		JP	NC,GTLB1	;try next
9244:	19BD  23      		INC	HL		;add current digit to value
9245:	19BE  C3AB19  		JP	GTLB1		;and try next
9246:			;get hex integer literal
9247:	19C1  EB      	GTLIH:	EX	DE,HL		;textp to DE, value to HL
9248:	19C2  1A      	GTLH1:	LD	A,(DE)		;fetch next
9249:	19C3  CDDB18  		CALL	ISHEX
9250:	19C6  DADC19  		JP	C,OVTST		;not a hex digit, done
9251:	19C9  13      		INC	DE
9252:	19CA  0C      		INC	C		;bump count
9253:	19CB  F5      		PUSH	AF
9254:	19CC  7C      		LD	A,H
9255:	19CD  E6F0    		AND	0F0H		;Zero reset if overflow will occur
9256:	19CF  C4F719  		CALL	NZ,OVSET	;set overflow flag
9257:	19D2  F1      		POP	AF		;restore current nibble
9258:	19D3  29      		ADD	HL,HL
9259:	19D4  29      		ADD	HL,HL
9260:	19D5  29      		ADD	HL,HL
9261:	19D6  29      		ADD	HL,HL		;value left four bits
9262:	19D7  B5      		OR	L
9263:	19D8  6F      		LD	L,A		;add in current nibble
9264:	19D9  C3C219  		JP	GTLH1
9265:			;common exit for binary and hex integer literals
9266:	19DC  EB      	OVTST:	EX	DE,HL		;textp to HL
9267:	19DD  22C63F  		LD	(TEXTP),HL	;and reset
9268:	19E0  79      		LD	A,C		;digit count to A
9269:	19E1  B7      		OR	A
9270:	19E2  CA9318  		JP	Z,BKUPC		;no digits after # or &, return Carry
9271:	19E5  78      		LD	A,B		;fetch result type
9272:	19E6  42      		LD	B,D
9273:	19E7  4B      		LD	C,E		;result to DE
9274:	19E8  FE01    		CP	INTST
9275:	19EA  C8      		RET	Z		;return type integer if no overflow
9276:			;issue nonfatal OV error and return max integer value in BC
9277:	19EB          	IOVER:	ERROR	N, O, V		;else issue nonfatal OV error
9278:	19F0  01FF7F  		LD	BC,7FFFH	;max positive value to BC
9279:	19F3  3E01    		LD	A,INTST		;result is integer
9280:	19F5  B7      		OR	A		;carry reset
9281:	19F6  C9      		RET
9282:	19F7  05      	OVSET:	DEC	B
9283:	19F8  C9      		RET
9284:			;get numeric literal with first char digit
9285:	19F9  E5      	GTLID:	PUSH	HL		;save textp
9286:	19FA  CD1119  		CALL	GTDEC		;get decimal number
9287:	19FD  7E      		LD	A,(HL)		;fetch next char
9288:	19FE  E1      		POP	HL		;old textp to HL
9289:	FFFF          		IF	FLOAT
9290:	19FF  CA221A  		JP	Z,GTLIF		;get floating literal if too big
9291:	1A02  FE2E    		CP	'.'
9292:	1A04  CA221A  		JP	Z,GTLIF		;or if next is .
9293:	1A07  FE45    		CP	'E'
9294:	1A09  CA221A  		JP	Z,GTLIF		;or if next is E
9295:	1A0C  FE65    		CP	'E'+20H
9296:	1A0E  CA221A  		JP	Z,GTLIF		;also allow lower case e in case untokenized
9297:	1A11  7A      		LD	A,D
9298:	1A12  B7      		OR	A
9299:	1A13  FA221A  		JP	M,GTLIF		;or if value is > 32767 but < 65536
9300:				ELSE
9302:				ENDIF
9303:	1A16  3A503E  		LD	A,(TEMP)	;fetch sign
9304:	1A19  B7      		OR	A
9305:	1A1A  C40802  		CALL	NZ,CPLDE	;complement value if negative desired
9306:	1A1D  42      		LD	B,D
9307:	1A1E  4B      		LD	C,E		;value to BC
9308:	1A1F  3E01    		LD	A,INTST
9309:	1A21  D0      		RET	NC		;return unless cannot complement
9310:	FFFF          		IF	FLOAT
9311:	1A22  2B      	GTLIF:	DEC	HL
9312:	1A23  CDAE0C  		CALL	FINP		;get floating literal
9313:	1A26  32503E  		LD	(TEMP),A	;save A
9314:	1A29  3E02    		LD	A,SNGST
9315:	1A2B  B7      		OR	A		;return Carry reset
9316:	1A2C  C9      		RET
9317:				ELSE
9319:				ENDIF
9320:			
9321:			;GTNAM gets a variable name into buffer at BUFAD, its type into VARTY,
9322:			;	and its length into A.
9323:			;A name is <letter> [<letter> | <digit>]* [$ | <exclam> | %] without spaces.
9324:			;After MAXNL characters, additional chars are scanned but ignored.
9325:			;The first letter determines the variable type according to TYBUF,
9326:			;	unless the trailing character $ | <exclam> | % is specified.
9327:			;Call:	(textp)	current text pointer
9328:			;Retn:	A	length of variable name
9329:			;	HL	address of first char after name
9330:			;	(bufad)	symbol name string
9331:			;	(varty)	variable type
9332:			;	Carry	set iff no name, i.e. first char not letter
9333:	1A2D  CD7018  	GTNAM:	CALL	GTALP		;get letter
9334:	1A30  D8      		RET	C
9335:	1A31  C5      		PUSH	BC
9336:	1A32  D5      		PUSH	DE
9337:	1A33  47      		LD	B,A		;save first char
9338:	FFFF          		IF	STRNG OR FLOAT	;must find var type if noninteger version
9339:	1A34  EB      		EX	DE,HL		;save HL in DE
9340:	1A35  21F53D  		LD	HL,TYBUF-'A'
9341:	1A38  CD1502  		CALL	ADAHL		;address default type byte
9342:	1A3B  7E      		LD	A,(HL)		;fetch it
9343:	1A3C  EB      		EX	DE,HL		;restore HL
9344:				ELSE
9346:				ENDIF
9347:	1A3D  32353E  		LD	(VARTY),A	;store type in VARTY
9348:	1A40  78      		LD	A,B		;restore char
9349:	1A41  015F3E  		LD	BC,BUFAD
9350:	1A44  1601    		LD	D,1		;char count to D
9351:	1A46  02      	GTNM1:	LD	(BC),A		;store a char
9352:	1A47  CDF018  	GTNM2:	CALL	GTILD		;get next char
9353:	1A4A  DA5A1A  		JP	C,GTNM3		;no more
9354:	1A4D  5F      		LD	E,A		;save new char
9355:	1A4E  7A      		LD	A,D
9356:	1A4F  FE08    		CP	MAXNL		;compare count to max name length
9357:	1A51  D2471A  		JP	NC,GTNM2	;count >= length, so don't insert
9358:	1A54  7B      		LD	A,E		;restore char
9359:	1A55  03      		INC	BC
9360:	1A56  14      		INC	D		;bump count and pointer
9361:	1A57  C3461A  		JP	GTNM1		;and insert
9362:	1A5A  FE25    	GTNM3:	CP	'%'
9363:	1A5C  CC711A  		CALL	Z,GTNM4		;type is integer
9364:	FFFF          		IF	FLOAT
9365:	1A5F  FE21    		CP	'!'
9366:	1A61  CC7C1A  		CALL	Z,GTNM6		;type is floating
9367:				ENDIF
9368:	FFFF          		IF	STRNG
9369:	1A64  FE24    		CP	'$'
9370:	1A66  CC811A  		CALL	Z,GTNM7		;type is string
9371:				ENDIF
9372:	0000          		IF	CAMAC
9375:				ENDIF
9376:	1A69  0A      		LD	A,(BC)
9377:	1A6A  F680    		OR	80H
9378:	1A6C  02      		LD	(BC),A		;end of string bit on
9379:	1A6D  7A      		LD	A,D
9380:	1A6E  D1      		POP	DE
9381:	1A6F  C1      		POP	BC
9382:	1A70  C9      		RET
9383:	1A71  3E01    	GTNM4:	LD	A,INTST		;integer token to A
9384:	1A73  22C63F  	GTNM5:	LD	(TEXTP),HL	;move textp past trailing char
9385:	1A76  23      		INC	HL
9386:	1A77  32353E  		LD	(VARTY),A	;reset VARTY to specified type
9387:	1A7A  AF      		XOR	A		;clear A for following compares
9388:	1A7B  C9      		RET
9389:	FFFF          		IF	FLOAT
9390:	1A7C  3E02    	GTNM6:	LD	A,SNGST		;single precision token to A
9391:	1A7E  C3731A  		JP	GTNM5
9392:				ENDIF
9393:	FFFF          		IF	STRNG
9394:	1A81  3E03    	GTNM7:	LD	A,STRST		;string token to A
9395:	1A83  C3731A  		JP	GTNM5
9396:				ENDIF
9397:	0000          		IF	CAMAC
9400:				ENDIF
9401:			
9402:			;FDVAR looks for variable name, returns carry set if none.
9403:			;If var not found in symbol table, assumes its type to be simple and
9404:			;builds a new symbol table entry for it.
9405:			;Retn:	DE	entry type address
9406:			;	HL	address following name in entry
9407:	1A86  CD2D1A  	FDVAR:	CALL	GTNAM
9408:	1A89  D8      		RET	C
9409:	1A8A  4F      		LD	C,A		;save length
9410:	1A8B  CD5E20  		CALL	STLKU		;look up symbol in symbol table
9411:	1A8E  D0      		RET	NC		;found it
9412:	1A8F  3A353E  	FDVA1:	LD	A,(VARTY)	;fetch var type -- unary user fn entry point
9413:	0000          		IF	CAMAC
9416:				ENDIF
9417:	1A92  CDAC01  		CALL	BYTSD		;# bytes per entry to DE
9418:	1A95  EB      		EX	DE,HL		;and to HL
9419:	1A96  0600    		LD	B,0		;length to BC
9420:	1A98  23      		INC	HL		;+length
9421:	1A99  23      		INC	HL		;+type
9422:	1A9A  23      		INC	HL		;+dims
9423:	1A9B  09      		ADD	HL,BC		;entry length to HL
9424:	1A9C  CDF71F  		CALL	STPSH		;build the entry
9425:	1A9F  1B      		DEC	DE		;DE points to type byte
9426:	1AA0  3600    		LD	(HL),0		;zero the dim byte
9427:	1AA2  C9      		RET
9428:			
9429:			;GTVAR performs a variable reference.
9430:			;Gets a variable name from text, returns with carry set if none.
9431:			;If variable name not found in symbol table, assumes its type to be simple
9432:			;and builds a new symbol table entry for it.
9433:			;Prints trace info if INLHS and either TRACE or variable break bit on,
9434:			;and sets VTRAC accordingly.
9435:			;Issues BS error if subscript out of bounds.
9436:			;Retn:	A	type token of referenced variable
9437:			;	DE	type byte address of referenced var
9438:			;	HL	address of referenced variable
9439:			;	Carry	set iff no name found
9440:			;	(vtrac)	bit 7 set iff trace desired
9441:	1AA3  CD861A  	GTVAR:	CALL	FDVAR
9442:	1AA6  D8      		RET	C		;no name found
9443:	FFFF          		IF	NOT COMPL
9444:	1AA7  3AE83C  		LD	A,(INLHS)
9445:	1AAA  B7      		OR	A
9446:	1AAB  C4561B  		CALL	NZ,TRSET	;set VTRAC if in lhs
9447:				ENDIF
9448:	1AAE  7E      		LD	A,(HL)		;fetch # dims
9449:	1AAF  4F      		LD	C,A		;and save in C
9450:	1AB0  23      		INC	HL
9451:	1AB1  B7      		OR	A		;zero set iff simple var
9452:	1AB2  3A353E  		LD	A,(VARTY)	;value to return to A
9453:	1AB5  C8      		RET	Z		;simple var
9454:	0000          		IF	CAMAC
9459:				ENDIF
9460:	1AB6  F5      		PUSH	AF		;save value to return
9461:	1AB7  D5      		PUSH	DE
9462:	1AB8  CDAC01  		CALL	BYTSD		;find bytes per entry
9463:	1ABB  43      		LD	B,E		;and save in B
9464:	1ABC  C5      		PUSH	BC		;save bytes per entry and # dims
9465:	1ABD  010100  		LD	BC,1		;product to BC
9466:	1AC0  110000  		LD	DE,0		;sum to DE
9467:	1AC3  D5      		PUSH	DE		;and saved
9468:	1AC4  1628    		LD	D,'('
9469:			;GTVA1 is executed for each subscript of the variable.  The stack contains
9470:			;the result type, type byte address, bytes per entry/# dimensions, and sum
9471:			;of subscripts thus far.  BC contains the product of bounds thus far, and
9472:			;HL points to the next bound.
9473:	1AC6  E5      	GTVA1:	PUSH	HL		;save pointer
9474:	1AC7  CD9718  		CALL	GTDTR		;skip (
9475:	1ACA  E1      		POP	HL		;restore pointer
9476:	1ACB  5E      		LD	E,(HL)
9477:	1ACC  23      		INC	HL
9478:	1ACD  56      		LD	D,(HL)		;next bound to DE
9479:	1ACE  23      		INC	HL		;point to next
9480:	1ACF  E3      		EX	(SP),HL		;save pointer, sum to HL
9481:	1AD0  C5      		PUSH	BC		;save product
9482:	1AD1  D5      		PUSH	DE		;save dim
9483:	1AD2  E5      		PUSH	HL		;save sum
9484:	1AD3  C5      		PUSH	BC		;save product
9485:	1AD4  CD041B  		CALL	GTSUB		;get subscript to BC
9486:	1AD7  D1      		POP	DE		;product to DE
9487:	1AD8  CD5F12  		CALL	MULBD		;subscript * product to HL
9488:	1ADB  D1      		POP	DE		;sum to DE
9489:	1ADC  19      		ADD	HL,DE		;new sum = sum + subscript * product to HL
9490:	1ADD  D1      		POP	DE		;bound to DE
9491:	1ADE  C1      		POP	BC		;product to BC
9492:	1ADF  13      		INC	DE		;bound+1
9493:	1AE0  E5      		PUSH	HL		;save sum
9494:	1AE1  CD5F12  		CALL	MULBD		;new product = product * (bound+1) to HL
9495:	1AE4  D1      		POP	DE		;sum to DE
9496:	1AE5  E3      		EX	(SP),HL		;product to stack, pointer to HL
9497:	1AE6  C1      		POP	BC		;product to BC
9498:	1AE7  E3      		EX	(SP),HL		;pointer to stack, counts to HL
9499:	1AE8  2D      		DEC	L		;decrement # dims count
9500:	1AE9  CAF31A  		JP	Z,GTVA2		;done
9501:	1AEC  E3      		EX	(SP),HL		;save counts, restore pointer
9502:	1AED  D5      		PUSH	DE		;save sum
9503:	1AEE  162C    		LD	D,','
9504:	1AF0  C3C61A  		JP	GTVA1		;and do some more dimensions
9505:	1AF3  7C      	GTVA2:	LD	A,H		;bytes per entry to A
9506:	1AF4  E1      		POP	HL		;pointer to HL
9507:	1AF5  19      	GTVA3:	ADD	HL,DE		;add sum once for each value byte
9508:	1AF6  3D      		DEC	A
9509:	1AF7  C2F51A  		JP	NZ,GTVA3	;pointer * sum = location
9510:	1AFA  E5      		PUSH	HL
9511:	1AFB  1629    		LD	D,')'
9512:	1AFD  CD9718  		CALL	GTDTR		;skip )
9513:	1B00  E1      		POP	HL
9514:	1B01  D1      		POP	DE		;restore type byte address
9515:	1B02  F1      		POP	AF		;and value to return
9516:	1B03  C9      		RET
9517:			
9518:			;GTSUB gets a subscript expression, issuing nonfatal BS error if out of bounds.
9519:			;The subscript value is printed if VTRAC is negative.
9520:			;Call:	DE	bound
9521:			;Retn:	BC	subscript, 0 <= (BC) <= (DE)
9522:	1B04          	GTSUB:
9523:	FFFF          		IF	NOT COMPL
9524:	1B04  3AE83C  		LD	A,(INLHS)
9525:	1B07  B7      		OR	A		;check if INLHS
9526:	1B08  FA2F1B  		JP	M,GTSU2		;yes -- fix so no extraneous tracing
9527:				ENDIF
9528:	1B0B  D5      	GTSU0:	PUSH	DE		;save bound
9529:	1B0C  11D83D  		LD	DE,STACK+STAKM+10-STAKL
9530:	1B0F  CD0802  		CALL	CPLDE
9531:	1B12  EB      		EX	DE,HL
9532:	1B13  39      		ADD	HL,SP		;number of bytes left to HL
9533:	1B14  D2431B  		JP	NC,BSERR	;fatal BS error if too little room left
9534:	1B17  CD8F0C  		CALL	GTEXP		;expr to BC
9535:	1B1A  110000  		LD	DE,0
9536:	1B1D  78      		LD	A,B
9537:	1B1E  B7      		OR	A		;check sign of subscript
9538:	1B1F  FC281B  		CALL	M,GTSU1		;negative
9539:	1B22  D1      		POP	DE		;restore bound
9540:	1B23  CD2F02  		CALL	CMBDS
9541:	1B26  D8      		RET	C		;< bound
9542:	1B27  C8      		RET	Z		;= bound
9543:	1B28  42      	GTSU1:	LD	B,D
9544:	1B29  4B      		LD	C,E		;replace expr with bound
9545:	1B2A          		ERROR	N, B, S		;nonfatal BS error and return
9546:	FFFF          		IF	NOT COMPL
9547:	1B2F  AF      	GTSU2:	XOR	A
9548:	1B30  32E83C  		LD	(INLHS),A	;reset INLHS
9549:	1B33  CD0B1B  		CALL	GTSU0		;get the subscript
9550:	1B36  3EFF    		LD	A,255
9551:	1B38  32E83C  		LD	(INLHS),A	;turn INLHS back on
9552:	1B3B  3AE93C  		LD	A,(VTRAC)
9553:	1B3E  B7      		OR	A
9554:	1B3F  F0      		RET	P
9555:	1B40  C30D17  		JP	WRTBU		;print subscript val if tracing
9556:				ENDIF
9557:	1B43          	BSERR:	ERROR	F, B, S		;fatal BS error
9558:			
9559:			;GTIVA is called from SCALL to perform an integer variable reference.
9560:			;Retn:	Carry	Set if not integer var ref
9561:			;	BC	value of integer var
9562:			;	DE	preserved
9563:	1B48  D5      	GTIVA:	PUSH	DE
9564:	1B49  CDA31A  		CALL	GTVAR		;look for var ref
9565:	1B4C  D1      		POP	DE
9566:	1B4D  D8      		RET	C		;not found
9567:	1B4E  4E      		LD	C,(HL)
9568:	1B4F  23      		INC	HL
9569:	1B50  46      		LD	B,(HL)		;value to BC
9570:	FFFF          		IF	STRNG OR FLOAT
9571:	1B51  FE01    		CP	INTST
9572:	1B53  C8      		RET	Z		;return Carry reset if integer
9573:	1B54  37      		SCF			;and Carry set if not
9574:				ENDIF
9575:	1B55  C9      		RET
9576:			
9577:	FFFF          		IF	NOT COMPL
9578:			;TRSET determines if trace printing is desired, setting VTRAC accordingly
9579:			;and echoing the variable name if so.
9580:			;A trailing type char is printed if the type is not the default type.
9581:			;Call:	DE	addr of var type byte
9582:			;Retn:	A	clobbered
9583:			;	BC,DE,HL	preserved
9584:			;	Carry	reset
9585:			;	(vtrac)	minus iff trace printing desired
9586:	1B56  E5      	TRSET:	PUSH	HL
9587:	1B57  2AE73C  		LD	HL,(TRACE)	;INLHS to H, TRACE to L
9588:	1B5A  1A      		LD	A,(DE)		;type byte to A -- A7 set iff var break
9589:	1B5B  B5      		OR	L		;minus iff var break or TRACE on
9590:	1B5C  A4      		AND	H		;minus iff tracing desired
9591:	1B5D  32E93C  		LD	(VTRAC),A
9592:	1B60  F2851B  		JP	P,TRST1		;done if not tracing
9593:	1B63  CD5708  		CALL	BPRNT		;echo line number if not done already
9594:	1B66  62      		LD	H,D
9595:	1B67  6B      		LD	L,E
9596:	1B68  23      		INC	HL		;name addr to HL
9597:	FFFF          		IF	STRNG OR FLOAT
9598:	1B69  E5      		PUSH	HL		;and saved
9599:	1B6A  CDC217  		CALL	PRTST		;print it
9600:	1B6D  E1      		POP	HL		;restore addr
9601:	1B6E  7E      		LD	A,(HL)		;refetch first char
9602:	1B6F  E67F    		AND	7FH		;mask off possible high bit
9603:	1B71  21F53D  		LD	HL,TYBUF-'A'
9604:	1B74  CD1502  		CALL	ADAHL		;address default type buffer location
9605:	1B77  1A      		LD	A,(DE)		;fetch type byte
9606:	1B78  E61F    		AND	1FH		;mask to type
9607:	1B7A  BE      		CP	(HL)		;compare to default
9608:	1B7B  CA851B  		JP	Z,TRST1		;same as default, no trailing char
9609:	1B7E  CD871B  		CALL	TYCHA		;type char to H
9610:	1B81  7C      		LD	A,H
9611:	1B82  CD1F16  		CALL	WRITC		;and printed
9612:				ELSE			;NOT STRNG and NOT FLOAT
9614:				ENDIF
9615:	1B85  E1      	TRST1:	POP	HL
9616:	1B86  C9      		RET
9617:			
9618:			;TYCHA returns type char in H for type in A.
9619:	FFFF          		IF	STRNG OR FLOAT
9620:	1B87          	TYCHA:
9621:	FFFF          		IF	STRNG
9622:	1B87  2624    		LD	H,'$'
9623:	1B89  FE03    		CP	STRST
9624:	1B8B  C8      		RET	Z		;string
9625:				ENDIF
9626:	FFFF          		IF	FLOAT
9627:	1B8C  2621    		LD	H,'!'
9628:	1B8E  FE02    		CP	SNGST
9629:	1B90  C8      		RET	Z		;floating
9630:				ENDIF
9631:	0000          		IF	CAMAC
9635:				ENDIF
9636:	1B91  2625    		LD	H,'%'
9637:	1B93  C9      		RET			;integer
9638:				ENDIF			;end of STRNG or FLOAT conditional
9639:				ENDIF			;end of NOT COMPL conditional
9640:			
9641:			;CMPST compares the strings at (DE) and M.  Zero set iff match.
9642:	1B94  1A      	CMPST:	LD	A,(DE)
9643:	1B95  BE      		CP	(HL)
9644:	1B96  13      		INC	DE
9645:	1B97  23      		INC	HL
9646:	1B98  C0      		RET	NZ		;return zero reset if no match
9647:	1B99  B7      		OR	A
9648:	1B9A  F2941B  		JP	P,CMPST		;keep comparing
9649:	1B9D  AF      		XOR	A		;match -- set zero and return
9650:	1B9E  C9      		RET
9651:			
9652:			;CPYST copies a string from (DE) to M.
9653:	1B9F  115F3E  	CPYS0:	LD	DE,BUFAD
9654:	1BA2  1A      	CPYST:	LD	A,(DE)
9655:	1BA3  77      		LD	(HL),A
9656:	1BA4  13      		INC	DE
9657:	1BA5  23      		INC	HL
9658:	1BA6  B7      		OR	A
9659:	1BA7  F2A21B  		JP	P,CPYST
9660:	1BAA  C9      		RET
9661:			
9662:			
9663:			;end of PARSING
9665:			;SDISK 1/12/81
9666:			;XYBASIC Interpreter Source Module
9667:			;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
9668:			;statement routines for CP/M SDISK version
9669:			
9670:			
9671:	FFFF          		IF	CPM AND SDISK
9672:			
9673:			;The sequential disk file block working space is located at the
9674:			;top of RAM, between (STRT) and (FILET).  Location FILES contains the
9675:			;number of file blocks currently allocated.
9676:			
9677:			;Each potential sequential disk file has a 166 byte file block, containing:
9678:			;1	File #, 0 if unused and nonzero if OPEN
9679:			;2	Mode, 0 for Output and nonzero for Input
9680:			;3	Count, 0-7FH indicating last position written/read in current buffer
9681:			;4	Column, initially 0, ignored for Input
9682:			;5	Width, initially 72, ignored for Input
9683:			;6-38	File control block (33 bytes)
9684:			;39-166	Buffer (128 bytes)
9685:			
9686:			
9687:	0000          		IF	RTPAK		;EQUates for C3885 RTPAK version
9694:				ELSE			;NOT RTPAK
9695:			
9696:			;CLEAR @<expr>
9697:	1BAB  3C      	DCLR0:	INC	A		;clear @0 means files=1, etc.
9698:	1BAC  CAA11F  		JP	Z,BFERR		;CLEAR @ 255 not allowed
9699:	1BAF  4F      		LD	C,A		;desired # files to C
9700:	1BB0  CD2B1C  		CALL	CLOSN		;close any open files
9701:	1BB3  3AA33C  		LD	A,(FILES)	;current #
9702:	1BB6  91      		SUB	C
9703:	1BB7  F2CF1B  		JP	P,DCLR2		;need fewer, so skip memory check
9704:	1BBA  115AFF  		LD	DE,-FILEN
9705:	1BBD  2A5D3E  		LD	HL,(SYMTA)
9706:	1BC0  19      	DCLR1:	ADD	HL,DE
9707:	1BC1  3C      		INC	A
9708:	1BC2  C2C01B  		JP	NZ,DCLR1	;leave room for additional file
9709:	1BC5  EB      		EX	DE,HL		;new symta to DE
9710:	1BC6  2ACA3F  		LD	HL,(EOFAD)
9711:	1BC9  CD2902  		CALL	CMDHU
9712:	1BCC  DA4320  		JP	C,OMERR		;not enough space, fatal OM error
9713:	1BCF  2A3B3D  	DCLR2:	LD	HL,(STRT)
9714:	1BD2  EB      		EX	DE,HL
9715:	1BD3  CD0802  		CALL	CPLDE		;- top of string space to DE
9716:	1BD6  2ACC3F  		LD	HL,(MEMT)
9717:	1BD9  19      		ADD	HL,DE		;-current amount of string space to HL
9718:	1BDA  E5      		PUSH	HL		;and saved
9719:	1BDB  79      		LD	A,C
9720:	1BDC  32A33C  		LD	(FILES),A	;save new file max
9721:	1BDF  2AA63C  		LD	HL,(FILET)	;top of file space to HL
9722:	1BE2  115AFF  		LD	DE,-FILEN	;space per file to DE
9723:	1BE5  3D      	DCLR3:	DEC	A
9724:	1BE6  CAEF1B  		JP	Z,DCLR4
9725:	1BE9  3600    		LD	(HL),0		;initialize empty file space
9726:	1BEB  19      		ADD	HL,DE
9727:	1BEC  C3E51B  		JP	DCLR3
9728:	1BEF  223B3D  	DCLR4:	LD	(STRT),HL	;store new top of string space
9729:	1BF2  D1      		POP	DE
9730:	1BF3  19      		ADD	HL,DE		;subtract string space needed
9731:	1BF4  C39B22  		JP	CLE0A		;and initialize symbol table, etc.
9732:			
9733:			;CLOSE [@<expr>, ...]
9734:	1BF7  CDA61F  	CLOSE:	CALL	GTSFN		;look for file #
9735:	1BFA  DA2B1C  		JP	C,CLOSN		;none, close all
9736:	1BFD  CAA11F  		JP	Z,BFERR		;DK error if @0 closed
9737:	1C00  60      		LD	H,B
9738:	1C01  69      		LD	L,C
9739:	1C02  B7      	CLOS1:	OR	A
9740:	1C03  C2171C  		JP	NZ,CLOSI	;close file open for input
9741:	1C06  7E      		LD	A,(HL)		;fetch count
9742:	1C07  D680    		SUB	80H
9743:	1C09  47      		LD	B,A		;eof count to B
9744:	1C0A  0E1A    		LD	C,CNTLZ
9745:	1C0C  C5      	CLOS2:	PUSH	BC
9746:	1C0D  E5      		PUSH	HL
9747:	1C0E  CD581F  		CALL	DWRTC		;write an eof
9748:	1C11  E1      		POP	HL
9749:	1C12  C1      		POP	BC
9750:	1C13  04      		INC	B
9751:	1C14  C20C1C  		JP	NZ,CLOS2	;write more eofs
9752:	1C17  23      	CLOSI:	INC	HL
9753:	1C18  23      		INC	HL		;point to file number
9754:	1C19  3600    		LD	(HL),0		;reset to 0
9755:	1C1B  11DBFF  		LD	DE,-37
9756:	1C1E  19      		ADD	HL,DE
9757:	1C1F  EB      		EX	DE,HL		;fcb address to DE
9758:	1C20  0E10    		LD	C,DKCLF
9759:	0000          		IF	C3885 AND NOT DEBUG
9761:				ELSE
9762:	1C22  CD0500  		CALL	BDOS
9763:				ENDIF
9764:	1C25  FEFF    		CP	255
9765:	1C27  C0      		RET	NZ
9766:	1C28  C3E304  		JP	DKERR		;close error
9767:	1C2B  CDC31F  	CLOSN:	CALL	SFILS
9768:	1C2E  05      	CLON1:	DEC	B
9769:	1C2F  C8      		RET	Z		;all closed
9770:	1C30  C5      		PUSH	BC
9771:	1C31  D5      		PUSH	DE
9772:	1C32  E5      		PUSH	HL		;save all
9773:	1C33  7E      		LD	A,(HL)		;fetch file number
9774:	1C34  B7      		OR	A
9775:	1C35  2B      		DEC	HL
9776:	1C36  7E      		LD	A,(HL)		;fetch type
9777:	1C37  2B      		DEC	HL		;point to count
9778:	1C38  C4021C  		CALL	NZ,CLOS1	;close a file
9779:	1C3B  E1      		POP	HL
9780:	1C3C  D1      		POP	DE
9781:	1C3D  C1      		POP	BC		;restore
9782:	1C3E  19      		ADD	HL,DE		;point to next
9783:	1C3F  C32E1C  		JP	CLON1		;and see if more to close
9784:			
9785:			;DIR [<ambiguous filename>]
9786:	FFFF          		IF	NOT C3885
9787:	1C42  CD0907  	DIRCM:	CALL	GTAF5		;set filename to *.*
9788:	1C45  AF      		XOR	A
9789:	1C46  325C00  		LD	(FCBAD),A	;set disk to @
9790:	1C49  327C00  		LD	(FCBCR),A
9791:	1C4C  CD3F01  		CALL	DTST0		;look for delimiter
9792:	1C4F  DCAA06  		CALL	C,GTAFN		;get desired ambiguous filename if present
9793:	1C52  0E11    		LD	C,17
9794:	1C54  CDD116  	DIRC1:	CALL	CTEST		;look for console break char
9795:	1C57  CD7516  		CALL	WCRLF		;write crlf
9796:	1C5A  CDF304  		CALL	BDOSF		;search for next occurrence of filename
9797:	1C5D  FEFF    		CP	255
9798:	1C5F  C8      		RET	Z		;no more
9799:	1C60  E603    		AND	3
9800:	1C62  0F      		RRCA
9801:	1C63  0F      		RRCA
9802:	1C64  0F      		RRCA
9803:	1C65  C681    		ADD	A,81H
9804:	1C67  5F      		LD	E,A
9805:	1C68  1600    		LD	D,0		;address of filename to DE
9806:	1C6A  0E08    		LD	C,8
9807:	1C6C  CD2F17  		CALL	PRSTR		;print the filename
9808:	1C6F  CD1D16  		CALL	WRTSP		;and print a space
9809:	1C72  0E03    		LD	C,3
9810:	1C74  CD2F17  		CALL	PRSTR		;and print filetype
9811:	1C77  0E12    		LD	C,18		;look for next
9812:	1C79  C3541C  		JP	DIRC1
9813:				ENDIF
9814:			
9815:			;INPUT @<expr>, <var list>
9816:	1C7C  F5      	DINP0:	PUSH	AF
9817:	1C7D  CD7C18  		CALL	GTCOM		;skip trailing comma
9818:	1C80  F1      		POP	AF
9819:	1C81  CAAE26  		JP	Z,INPU1		;INPUT @0, normal INPUT with no quoted string
9820:	1C84  B7      		OR	A
9821:	1C85  CA281D  		JP	Z,FMERR		;FM error if file open for Output
9822:	1C88  C5      		PUSH	BC		;save file count pointer
9823:	1C89  CD4D01  	DINP1:	CALL	GTLHS		;get destination
9824:	1C8C  E1      		POP	HL		;file count pointer to HL
9825:	1C8D  FE03    		CP	STRST
9826:	1C8F  F5      		PUSH	AF		;save type (Zero set iff string)
9827:	1C90  11C33E  		LD	DE,NLNAD	;input buffer address to DE
9828:	1C93  0E00    		LD	C,0		;char count to C
9829:	1C95  CD061F  	DINP2:	CALL	DREAD		;read a disk file char
9830:	1C98  FE21    		CP	' '+1
9831:	1C9A  DA951C  		JP	C,DINP2		;ignore leading spaces or control chars
9832:	1C9D  FE2C    		CP	','
9833:	1C9F  CA951C  		JP	Z,DINP2		;and ignore leading commas
9834:	1CA2  FE20    	DINP3:	CP	' '
9835:	1CA4  C2AE1C  		JP	NZ,DINP4	;next not space
9836:	1CA7  F1      		POP	AF
9837:	1CA8  F5      		PUSH	AF		;Zero set iff string
9838:	1CA9  3E20    		LD	A,' '
9839:	1CAB  C2CB1C  		JP	NZ,DINP6	;done if space and numeric
9840:	1CAE  FE2C    	DINP4:	CP	','
9841:	1CB0  CACB1C  		JP	Z,DINP6		;done if comma
9842:	1CB3  FE0D    		CP	CR
9843:	1CB5  CAC81C  		JP	Z,DINP5		;done if <cr>
9844:	1CB8  12      		LD	(DE),A		;else store the char
9845:	1CB9  13      		INC	DE
9846:	1CBA  0C      		INC	C		;bump the count
9847:	1CBB  CAFA1C  		JP	Z,DINP8		;256 chars
9848:	1CBE  CD131F  		CALL	DREA0		;else look at next char
9849:	1CC1  CACB1C  		JP	Z,DINP6		;done if eof
9850:	1CC4  34      		INC	(HL)		;else read it
9851:	1CC5  C3A21C  		JP	DINP3		;and repeat
9852:	1CC8  CDED1C  	DINP5:	CALL	DINLF		;ignore trailing <linefeed> if present
9853:	1CCB  F1      	DINP6:	POP	AF
9854:	1CCC  E5      		PUSH	HL
9855:	1CCD  21C33E  		LD	HL,NLNAD
9856:	1CD0  C2FF1C  		JP	NZ,DINP9	;numeric value
9857:	1CD3  EB      		EX	DE,HL		;location to DE
9858:	1CD4  3E03    		LD	A,STRST
9859:	1CD6  CD6501  	DINP7:	CALL	ASIGV		;assign value to destination
9860:	1CD9  CD8518  		CALL	GTCND		;look for comma and more vars
9861:	1CDC  D2891C  		JP	NC,DINP1
9862:	1CDF  E1      		POP	HL		;pop saved file count pointer
9863:	1CE0  CD131F  	DIN10:	CALL	DREA0		;look at first unread char
9864:	1CE3  C8      		RET	Z		;eof, done
9865:	1CE4  FE20    		CP	' '
9866:	1CE6  CAF61C  		JP	Z,DIN11		;ignore trailing spaces
9867:	1CE9  FE0D    		CP	CR
9868:	1CEB  C0      		RET	NZ		;done if next char not space or <cr>
9869:	1CEC  34      		INC	(HL)		;ignore the trailing <cr>
9870:			;DINLF ignores next character iff <linefeed>
9871:	1CED  CD131F  	DINLF:	CALL	DREA0		;look at next char
9872:	1CF0  C8      		RET	Z		;eof
9873:	1CF1  FE0A    		CP	LF
9874:	1CF3  C0      		RET	NZ		;not <lf>, return
9875:	1CF4  34      		INC	(HL)		;read the <lf>
9876:	1CF5  C9      		RET			;and return
9877:	1CF6  34      	DIN11:	INC	(HL)		;read the trailing space
9878:	1CF7  C3E01C  		JP	DIN10		;and look for more trailing spaces or <cr>
9879:	1CFA  35      	DINP8:	DEC	(HL)		;unread the 256th char
9880:	1CFB  0D      		DEC	C		;correct the count
9881:	1CFC  C3CB1C  		JP	DINP6		;and assign it
9882:	1CFF  3E0D    	DINP9:	LD	A,CR
9883:	1D01  12      		LD	(DE),A		;put <cr> after value
9884:	1D02  22523E  		LD	(TXTP2),HL
9885:	1D05  CD3702  		CALL	FLIP		;to read the input buffer
9886:	1D08  CD5919  		CALL	GTLIT		;evaluate the numeric value
9887:	1D0B  DA231D  		JP	C,FIERR		;bad value
9888:	1D0E  FE03    		CP	STRST
9889:	1D10  CA231D  		JP	Z,FIERR		;string value is also bad
9890:	1D13  D5      		PUSH	DE
9891:	1D14  F5      		PUSH	AF
9892:	1D15  CD3702  		CALL	FLIP		;to read as before
9893:	1D18  1A      		LD	A,(DE)		;fetch next char from input buffer
9894:	1D19  FE0D    		CP	CR
9895:	1D1B  C2231D  		JP	NZ,FIERR	;FI error if not <cr>, value is bad
9896:	1D1E  F1      		POP	AF
9897:	1D1F  D1      		POP	DE
9898:	1D20  C3D61C  		JP	DINP7		;else assign value to destination as above
9899:	1D23          	FIERR:	ERROR	F, F, I		;fatal FI error
9900:	1D28          	FMERR:	ERROR	F, F, M		;fatal FM error
9901:			
9902:			;LINPUT [@<expr>] <string var>
9903:	FFFF          		IF	NOT C3885
9904:	1D2D  CD1501  	LINPT:	CALL	IDTST		;LINPUT is illegal in direct mode
9905:	1D30  CDA61F  		CALL	GTSFN		;look for file #
9906:	1D33  F5      		PUSH	AF
9907:	1D34  C5      		PUSH	BC
9908:	1D35  CD7C18  		CALL	GTCOM		;skip comma, if any
9909:	1D38  CD4D01  		CALL	GTLHS		;get destination
9910:	1D3B  FE03    		CP	STRST
9911:	1D3D  C23501  		JP	NZ,SNERR	;must be string
9912:	1D40  E1      		POP	HL		;count pointer to HL
9913:	1D41  F1      		POP	AF
9914:	1D42  DA701D  		JP	C,LINP0
9915:	1D45  CA701D  		JP	Z,LINP0		;normal linput
9916:	1D48  B7      		OR	A
9917:	1D49  CA281D  		JP	Z,FMERR		;FM error if open for output
9918:	1D4C  11C33E  		LD	DE,NLNAD
9919:	1D4F  D5      		PUSH	DE		;save input buffer address
9920:	1D50  0E00    		LD	C,0
9921:	1D52  C3591D  		JP	LINF1
9922:	1D55  0C      	LINF0:	INC	C		;char count to C
9923:	1D56  CA6A1D  		JP	Z,LINF2		;256 chars read
9924:	1D59  CD061F  	LINF1:	CALL	DREAD		;read a disk char
9925:	1D5C  12      		LD	(DE),A		;store it
9926:	1D5D  13      		INC	DE
9927:	1D5E  FE0D    		CP	CR
9928:	1D60  C2551D  		JP	NZ,LINF0	;read another unless at cr
9929:	1D63  D1      		POP	DE		;location = input buffer to DE
9930:	1D64  CDED1C  		CALL	DINLF		;skip trailing <lf> if present
9931:	1D67  C38B1D  		JP	LINP2		;assign value to destination
9932:	1D6A  35      	LINF2:	DEC	(HL)		;unread the 256th char
9933:	1D6B  0D      		DEC	C		;correct the count
9934:	1D6C  D1      		POP	DE		;restore location
9935:	1D6D  C38B1D  		JP	LINP2		;assign value to desination
9936:			;LINPUT from the console
9937:	1D70  2AC63F  	LINP0:	LD	HL,(TEXTP)
9938:	1D73  E5      		PUSH	HL		;save textp
9939:	1D74  CDB433  		CALL	GTLIN		;get input line
9940:	1D77  E3      		EX	(SP),HL		;recover old textp
9941:	1D78  22C63F  		LD	(TEXTP),HL
9942:	1D7B  E1      		POP	HL
9943:	1D7C  54      		LD	D,H
9944:	1D7D  5D      		LD	E,L		;copy first char address to DE
9945:	1D7E  3E0D    		LD	A,CR
9946:	1D80  0E00    		LD	C,0		;char count to C
9947:	1D82  BE      	LINP1:	CP	(HL)
9948:	1D83  CA8B1D  		JP	Z,LINP2		;done if char is cr
9949:	1D86  0C      		INC	C
9950:	1D87  23      		INC	HL
9951:	1D88  C3821D  		JP	LINP1
9952:	1D8B  3E03    	LINP2:	LD	A,STRST
9953:	1D8D  C36501  		JP	ASIGV		;assign string value to destination
9954:				ENDIF
9955:			
9956:			;MARGIN [@<expr>,] <expr>
9957:	FFFF          		IF	NOT C3885
9958:	1D90  CDA61F  	MARGN:	CALL	GTSFN		;find file
9959:	1D93  DAA91D  		JP	C,MARG0		;none, change WIDTH
9960:	1D96  F5      		PUSH	AF		;save Zero status
9961:	1D97  C5      		PUSH	BC		;and pointer
9962:	1D98  162C    		LD	D,','
9963:	1D9A  CDA618  		CALL	GTDSN		;skip ,
9964:	1D9D  CD9C0C  		CALL	GTBEX		;get byte value
9965:	1DA0  E1      		POP	HL		;pointer to HL
9966:	1DA1  F1      		POP	AF		;restore Zero
9967:	1DA2  CAAC1D  		JP	Z,MARG1		;@0, change WIDTH
9968:	1DA5  2B      		DEC	HL
9969:	1DA6  2B      		DEC	HL		;point to file width field
9970:	1DA7  71      		LD	(HL),C		;and change it
9971:	1DA8  C9      		RET
9972:	1DA9  CD9C0C  	MARG0:	CALL	GTBEX		;get byte value
9973:	1DAC  79      	MARG1:	LD	A,C
9974:	1DAD  32E13C  		LD	(WIDTH),A	;value to WIDTH
9975:	1DB0  C9      		RET
9976:				ENDIF
9977:			
9978:			;OPEN {I | O | U} @<expr>, <filename>
9979:	1DB1  CD5A18  	OPEN:	CALL	GTCHA		;get desired mode
9980:	1DB4  F5      		PUSH	AF		;and save
9981:	1DB5  CD7C18  		CALL	GTCOM		;allow comma after mode
9982:	1DB8  CD911F  		CALL	GTATN		;get desired file number
9983:	1DBB  DAA11F  		JP	C,BFERR
9984:	1DBE  CAA11F  		JP	Z,BFERR		;0 not allowed
9985:	1DC1  CDC31F  		CALL	SFILS		;set up B, DE, HL for search
9986:	1DC4  48      		LD	C,B		;max # files to C also
9987:	1DC5  D5      		PUSH	DE
9988:	1DC6  E5      		PUSH	HL		;and save
9989:			;first check if number already associated with open file
9990:	1DC7  0D      	OPEN1:	DEC	C
9991:	1DC8  CAD31D  		JP	Z,OPEN2
9992:	1DCB  BE      		CP	(HL)
9993:	1DCC  CA9E1E  		JP	Z,FOERR		;desired number already open, FO error
9994:	1DCF  19      		ADD	HL,DE
9995:	1DD0  C3C71D  		JP	OPEN1		;else try next
9996:	1DD3  4F      	OPEN2:	LD	C,A		;desired number to C
9997:	1DD4  C5      		PUSH	BC
9998:	1DD5  162C    		LD	D,','
9999:	1DD7  CDA618  		CALL	GTDSN		;skip ,
10000:	1DDA  CD9606  		CALL	GTFNM		;get desired filename
10001:			;check if file of same name is already open
10002:	1DDD  C1      		POP	BC
10003:	1DDE  E1      		POP	HL
10004:	1DDF  E5      		PUSH	HL
10005:	1DE0  C5      		PUSH	BC
10006:	1DE1  05      	OPN2A:	DEC	B
10007:	1DE2  CA051E  		JP	Z,OPN2C		;checked all files, ok
10008:	1DE5  7E      		LD	A,(HL)		;fetch file #
10009:	1DE6  11DBFF  		LD	DE,-37
10010:	1DE9  19      		ADD	HL,DE		;address the file fcb
10011:	1DEA  B7      		OR	A
10012:	1DEB  CAFE1D  		JP	Z,OPN2B		;no file, skip the test
10013:	1DEE  C5      		PUSH	BC
10014:	1DEF  E5      		PUSH	HL
10015:	1DF0  115C00  		LD	DE,FCBAD
10016:	1DF3  010C0C  		LD	BC,(12 SHL 8) OR 12;count = 12 chars to B and C
10017:	1DF6  CDD22D  		CALL	CMSTR		;compare file fcb with new fcb
10018:	1DF9  CA9E1E  		JP	Z,FOERR		;already open, FO error
10019:	1DFC  E1      		POP	HL
10020:	1DFD  C1      		POP	BC
10021:	1DFE  117FFF  	OPN2B:	LD	DE,-129
10022:	1E01  19      		ADD	HL,DE		;address the next file #
10023:	1E02  C3E11D  		JP	OPN2A		;and test it
10024:	1E05  C1      	OPN2C:	POP	BC
10025:	1E06  E1      		POP	HL
10026:	1E07  D1      		POP	DE
10027:			;then check if space available for file
10028:	1E08  05      	OPEN3:	DEC	B
10029:	1E09  CAA31E  		JP	Z,OPERR		;all available file areas full
10030:	1E0C  7E      		LD	A,(HL)
10031:	1E0D  B7      		OR	A
10032:	1E0E  CA151E  		JP	Z,OPEN4		;available
10033:	1E11  19      		ADD	HL,DE
10034:	1E12  C3081E  		JP	OPEN3		;else try next
10035:	1E15  71      	OPEN4:	LD	(HL),C
10036:	1E16  2B      		DEC	HL
10037:	1E17  F1      		POP	AF		;recover desired mode
10038:	1E18  FE4F    		CP	'O'
10039:	1E1A  CA3F1E  		JP	Z,OPENO
10040:	1E1D  FE55    		CP	'U'
10041:	1E1F  CA5A1E  		JP	Z,OPENU
10042:			;else open for input
10043:	1E22  FE49    		CP	'I'
10044:	1E24  C23501  		JP	NZ,SNERR	;SN error if not I
10045:	1E27  23      		INC	HL
10046:	1E28  3600    		LD	(HL),0		;reset file # to 0 in case not found
10047:	1E2A  C5      		PUSH	BC
10048:	1E2B  E5      		PUSH	HL
10049:	1E2C  CD9F05  		CALL	CDKOP		;open the file
10050:	1E2F  E1      		POP	HL
10051:	1E30  C1      		POP	BC
10052:	1E31  71      		LD	(HL),C		;set the file #
10053:	1E32  2B      		DEC	HL
10054:	1E33  36FF    		LD	(HL),255	;mode = input
10055:	1E35  2B      		DEC	HL
10056:	1E36  367F    		LD	(HL),7FH	;count = 7FH so next read gets new buffer
10057:	1E38  11DDFF  		LD	DE,-35
10058:	1E3B  19      		ADD	HL,DE		;HL addresses file fcb
10059:	1E3C  C3511E  		JP	OPEN6
10060:			;open for output
10061:	1E3F  AF      	OPENO:	XOR	A
10062:	1E40  77      		LD	(HL),A		;mode = output
10063:	1E41  2B      		DEC	HL
10064:	1E42  77      		LD	(HL),A		;buffer address = 0
10065:	1E43  2B      		DEC	HL
10066:	1E44  77      		LD	(HL),A		;column = 0
10067:	1E45  2B      		DEC	HL
10068:	1E46  3648    		LD	(HL),72		;default width = 72
10069:	1E48  11DFFF  		LD	DE,-33
10070:	1E4B  19      		ADD	HL,DE		;HL addresses file fcb
10071:	1E4C  E5      		PUSH	HL
10072:	1E4D  CDF904  		CALL	CDKMK		;delete old, make new
10073:	1E50  E1      		POP	HL
10074:	1E51  015C00  	OPEN6:	LD	BC,FCBAD
10075:	1E54  112100  		LD	DE,33
10076:	1E57  C33637  		JP	MOVED		;copy default fcb to fcb and return
10077:			;open for update
10078:	1E5A  3600    	OPENU:	LD	(HL),0		;mode = output
10079:	1E5C  2B      		DEC	HL
10080:	1E5D  E5      		PUSH	HL		;save count address
10081:	1E5E  2B      		DEC	HL
10082:	1E5F  3648    		LD	(HL),72		;column = 72
10083:	1E61  2B      		DEC	HL
10084:	1E62  3648    		LD	(HL),72		;default width = 72
10085:	1E64  115FFF  		LD	DE,-161
10086:	1E67  19      		ADD	HL,DE		;address buffer base
10087:	1E68  E3      		EX	(SP),HL		;save
10088:	1E69  E5      		PUSH	HL		;and save count address
10089:	1E6A  CD9F05  		CALL	CDKOP		;open the file
10090:	1E6D  CDAC05  	OPNU1:	CALL	CDKRD		;read a record
10091:	1E70  3E00    		LD	A,0		;count zero in case eof
10092:	1E72  CA881E  		JP	Z,OPNU4		;eof
10093:	1E75  218000  		LD	HL,DMAAD	;default dma address to HL
10094:	1E78  3E1A    		LD	A,CNTLZ		;eof to A
10095:	1E7A  BE      	OPNU2:	CP	(HL)		;check if next char is eof
10096:	1E7B  CA851E  		JP	Z,OPNU3		;yup
10097:	1E7E  2C      		INC	L		;else try next
10098:	1E7F  C27A1E  		JP	NZ,OPNU2
10099:	1E82  C36D1E  		JP	OPNU1		;reading another buffer if necessary
10100:	1E85  7D      	OPNU3:	LD	A,L
10101:	1E86  D680    		SUB	80H		;compute the new count
10102:	1E88  E1      	OPNU4:	POP	HL
10103:	1E89  77      		LD	(HL),A		;store the new count
10104:	1E8A  E1      		POP	HL
10105:	1E8B  018000  		LD	BC,DMAAD
10106:	1E8E  118000  		LD	DE,80H
10107:	1E91  CD3637  		CALL	MOVED		;copy the buffer to file entry buffer
10108:	1E94  3A7C00  		LD	A,(FCBCR)
10109:	1E97  3D      		DEC	A
10110:	1E98  327C00  		LD	(FCBCR),A	;update the cr field to rewrite the same record
10111:	1E9B  C3511E  		JP	OPEN6		;and copy the fcb to the file entry
10112:	1E9E          	FOERR:	ERROR	F, F, O		;fatal FO error
10113:	1EA3          	OPERR:	ERROR	F, O, P		;fatal OP error
10114:			
10115:			;PRINT @<expr>, <print list>
10116:	1EA8  F5      	DPRIN:	PUSH	AF
10117:	1EA9  162C    		LD	D,','
10118:	1EAB  CD8E18  		CALL	GTD		;skip comma if present
10119:	1EAE  F1      		POP	AF
10120:	1EAF  CABF28  		JP	Z,PRIN0		;normal PRINT if @0
10121:	1EB2  B7      		OR	A
10122:	1EB3  C2281D  		JP	NZ,FMERR	;FM error if file is OPEN for input
10123:	1EB6  21303D  		LD	HL,NULLS
10124:	1EB9  7E      		LD	A,(HL)		;fetch current NULLS value
10125:	1EBA  F5      		PUSH	AF		;and save
10126:	1EBB  3600    		LD	(HL),0		;and reset to 0 for disk PRINT
10127:	1EBD  2AE03C  		LD	HL,(COLUM)
10128:	1EC0  E5      		PUSH	HL		;save current column and width
10129:	1EC1  60      		LD	H,B
10130:	1EC2  69      		LD	L,C
10131:	1EC3  22A43C  		LD	(FILEP),HL	;set file pointer so PRINT goes to file
10132:	1EC6  2B      		DEC	HL
10133:	1EC7  5E      		LD	E,(HL)		;column to E
10134:	1EC8  E5      		PUSH	HL
10135:	1EC9  2B      		DEC	HL
10136:	1ECA  56      		LD	D,(HL)		;width to D
10137:	1ECB  EB      		EX	DE,HL
10138:	1ECC  22E03C  		LD	(COLUM),HL	;set file column and width
10139:	1ECF  CDBF28  		CALL	PRIN0		;print the line
10140:	1ED2  3AE03C  		LD	A,(COLUM)
10141:	1ED5  E1      		POP	HL
10142:	1ED6  77      		LD	(HL),A		;reset file column
10143:	1ED7  E1      		POP	HL
10144:	1ED8  22E03C  		LD	(COLUM),HL	;restore column and width
10145:	1EDB  F1      		POP	AF		;recover original NULLS value
10146:	1EDC  32303D  		LD	(NULLS),A	;and restore it
10147:	1EDF  210000  		LD	HL,0
10148:	1EE2  22A43C  		LD	(FILEP),HL	;reset file pointer
10149:	1EE5  C9      		RET
10150:			
10151:			;SCRATCH [<ambiguous filename>]
10152:	FFFF          		IF	NOT C3885
10153:	1EE6  CDAA06  	SCRAT:	CALL	GTAFN		;get ambiguous filename
10154:	1EE9  0E13    		LD	C,DKDLF
10155:	1EEB  C3F304  		JP	BDOSF		;delete it
10156:				ENDIF
10157:			
10158:			
10159:			;functions
10160:			
10161:			;EOF: <integer> --> <integer>
10162:	1EEE  78      	EOFFN:	LD	A,B
10163:	1EEF  B7      		OR	A
10164:	1EF0  C2A11F  		JP	NZ,BFERR	;arg too large, cannot be file #
10165:	1EF3  79      		LD	A,C
10166:	1EF4  CDAB1F  		CALL	GTSF0		;find arg value
10167:	1EF7  B7      		OR	A
10168:	1EF8  CA281D  		JP	Z,FMERR		;FM error if open for output
10169:	1EFB  60      		LD	H,B
10170:	1EFC  69      		LD	L,C
10171:	1EFD  CD131F  	EOFF0:	CALL	DREA0		;look at next char
10172:	1F00  01FFFF  		LD	BC,-1
10173:	1F03  C8      		RET	Z		;eof, return -1
10174:	1F04  03      		INC	BC
10175:	1F05  C9      		RET			;no eof, return 0
10176:			
10177:			
10178:			;routines
10179:			
10180:			;DREAD reads a char from a disk file, issues DK error if char is EOF.
10181:	1F06  CD131F  	DREAD:	CALL	DREA0		;read a char
10182:	1F09  CA0E1F  		JP	Z,EFERR		;EF error if read through eof
10183:	1F0C  34      		INC	(HL)		;else read the char
10184:	1F0D  C9      		RET
10185:	1F0E          	EFERR:	ERROR	F, E, F		;fatal EF error
10186:			
10187:			;DREA0 looks at the next character from a disk file.
10188:			;Call:	HL	pointer to count of file entry
10189:			;Retn:	A	next character
10190:			;	BC,DE,HL	preserved
10191:			;	Zero	Set iff eof
10192:	1F13  E5      	DREA0:	PUSH	HL
10193:	1F14  D5      		PUSH	DE
10194:	1F15  7E      		LD	A,(HL)		;fetch count
10195:	1F16  3C      		INC	A		;and bump it
10196:	1F17  F2451F  		JP	P,DREA1		;ok unless 80H
10197:			;must read a new buffer of characters and reset count
10198:	1F1A  36FF    		LD	(HL),255	;reset count of last char read
10199:	1F1C  E5      		PUSH	HL
10200:	1F1D  C5      		PUSH	BC
10201:	1F1E  11DDFF  		LD	DE,-35
10202:	1F21  19      		ADD	HL,DE
10203:	1F22  E5      		PUSH	HL		;save fcb address
10204:	1F23  1180FF  		LD	DE,-128
10205:	1F26  19      		ADD	HL,DE		;address buffer
10206:	1F27  EB      		EX	DE,HL
10207:	1F28  CDEE04  		CALL	STDMA		;set dma address to buffer
10208:	1F2B  D1      		POP	DE
10209:	1F2C  0E14    		LD	C,DKRDF
10210:	0000          		IF	C3885 AND NOT DEBUG
10212:				ELSE
10213:	1F2E  CD0500  		CALL	BDOS
10214:				ENDIF
10215:	1F31  F5      		PUSH	AF		;save status
10216:	1F32  CDEB04  		CALL	RTDMA		;and reset the dma address to 80H
10217:	1F35  F1      		POP	AF		;restore status
10218:	1F36  C1      		POP	BC
10219:	1F37  E1      		POP	HL
10220:	1F38  FE02    		CP	2
10221:	1F3A  CAE304  		JP	Z,DKERR		;read error
10222:	1F3D  FE01    		CP	1
10223:	1F3F  3E1A    		LD	A,CNTLZ
10224:	1F41  CA4D1F  		JP	Z,DREA2		;return if eof
10225:	1F44  AF      		XOR	A		;reset count
10226:	1F45  115DFF  	DREA1:	LD	DE,-163
10227:	1F48  19      		ADD	HL,DE
10228:	1F49  CD1502  		CALL	ADAHL		;address desired char
10229:	1F4C  7E      		LD	A,(HL)		;fetch it
10230:	1F4D  FE1A    	DREA2:	CP	CNTLZ		;Zero set iff eof
10231:	1F4F  D1      		POP	DE
10232:	1F50  E1      		POP	HL
10233:	1F51  C9      		RET
10234:			
10235:	1F52  CD581F  	DWRIT:	CALL	DWRTC	;write char to disk file
10236:	1F55  C36216  		JP	POP4		;restore and return
10237:	1F58  7E      	DWRTC:	LD	A,(HL)		;fetch count
10238:	1F59  34      		INC	(HL)		;update count
10239:	1F5A  F5      		PUSH	AF
10240:	1F5B  EB      		EX	DE,HL		;count pointer to DE
10241:	1F5C  215DFF  		LD	HL,-163
10242:	1F5F  19      		ADD	HL,DE		;point to buffer base
10243:	1F60  CD1502  		CALL	ADAHL		;add count+base = destination
10244:	1F63  71      		LD	(HL),C		;char to destination
10245:	1F64  F1      		POP	AF
10246:	1F65  F0      		RET	P		;return unless count is 80H
10247:	1F66  AF      		XOR	A
10248:	1F67  12      		LD	(DE),A		;store new count = 0
10249:	1F68  23      		INC	HL		;point to fcb
10250:	1F69  E5      		PUSH	HL		;save fcb address
10251:	1F6A  1180FF  		LD	DE,-128
10252:	1F6D  19      		ADD	HL,DE
10253:	1F6E  EB      		EX	DE,HL
10254:	1F6F  CDEE04  		CALL	STDMA		;set dma address to buffer
10255:	1F72  D1      		POP	DE		;recover fcb address
10256:	1F73  D5      		PUSH	DE		;and save again
10257:	1F74  0E15    		LD	C,DKWTF
10258:	0000          		IF	C3885 AND NOT DEBUG
10260:				ELSE
10261:	1F76  CD0500  		CALL	BDOS
10262:				ENDIF
10263:	1F79  F5      		PUSH	AF
10264:	1F7A  CDEB04  		CALL	RTDMA		;reset dma address
10265:	1F7D  F1      		POP	AF
10266:	1F7E  D1      		POP	DE		;fcb address to DE
10267:	1F7F  B7      		OR	A
10268:	1F80  C8      		RET	Z		;successful write, return
10269:	1F81  212500  		LD	HL,37		;otherwise disk is full
10270:	1F84  19      		ADD	HL,DE
10271:	1F85  3600    		LD	(HL),0		;reset the file # to 0, now inactive
10272:	1F87  0E13    		LD	C,DKDLF
10273:	0000          		IF	C3885 AND NOT DEBUG
10275:				ELSE
10276:	1F89  CD0500  		CALL	BDOS
10277:				ENDIF
10278:	1F8C          		ERROR	F, D, F		;fatal DF error
10279:			
10280:				ENDIF			;end of NOT RTPAK conditional
10281:			
10282:			;@ <expr>
10283:			;GTATN gets @ followed by a number for sequential disk routines.
10284:			;A fatal DK error occurs if the <expr> is not in the range 0 to 255.
10285:			;Retn:	Carry	Set iff no @ found
10286:			;	Zero	Set iff <expr> is 0
10287:			;	A	Value of <expr>
10288:	1F91  1640    	GTATN:	LD	D,'@'
10289:	1F93  CD8E18  		CALL	GTD		;look for @
10290:	1F96  D8      		RET	C		;not found
10291:	1F97  CD8F0C  		CALL	GTEXP		;evaluate the <expr>
10292:	1F9A  78      		LD	A,B
10293:	1F9B  B7      		OR	A
10294:	1F9C  C2A11F  		JP	NZ,BFERR	;fatal BF error if not between 0 and 255
10295:	1F9F  B1      		OR	C		;value to A
10296:	1FA0  C9      		RET
10297:	1FA1          	BFERR:	ERROR	F, B, F		;fatal BF error
10298:			
10299:			;GTSFN finds an OPEN sequential disk file.  A DK error occurs
10300:			;if a nonzero file # is given but no corresponding OPEN file exists.
10301:			;Retn:	Carry	Set iff no @ found
10302:			;	Zero	Set iff file @0 is specified
10303:			;	A	Mode of file (0 output, nonzero input)
10304:			;	BC	Pointer to count field of file entry
10305:			;	HL	Pointer to byte preceding file buffer
10306:	1FA6  CD911F  	GTSFN:	CALL	GTATN		;look for @<expr>
10307:	1FA9  D8      		RET	C		;no @
10308:	1FAA  C8      		RET	Z		;@ 0
10309:	0000          		IF	RTPAK
10311:				ELSE			;NOT RTPAK
10312:	1FAB  CDC31F  	GTSF0:	CALL	SFILS		;set up registers for search -- EOF entry point
10313:	1FAE  05      	GTSF1:	DEC	B
10314:	1FAF  CAA11F  		JP	Z,BFERR		;not found, BF error
10315:	1FB2  BE      		CP	(HL)		;compare desired to actual
10316:	1FB3  CABA1F  		JP	Z,GTSF2		;gotcha
10317:	1FB6  19      		ADD	HL,DE		;else try next
10318:	1FB7  C3AE1F  		JP	GTSF1
10319:	1FBA  44      	GTSF2:	LD	B,H
10320:	1FBB  4D      		LD	C,L		;file pointer to BC
10321:	1FBC  19      		ADD	HL,DE		;HL points below buffer
10322:	1FBD  F601    		OR	1		;Carry and Zero reset
10323:	1FBF  0B      		DEC	BC
10324:	1FC0  0A      		LD	A,(BC)		;fetch mode
10325:	1FC1  0B      		DEC	BC		;point to count with BC
10326:	1FC2  C9      		RET
10327:			
10328:	1FC3  21A33C  	SFILS:	LD	HL,FILES
10329:	1FC6  46      		LD	B,(HL)		;max # files to B
10330:	1FC7  2AA63C  		LD	HL,(FILET)
10331:	1FCA  115AFF  		LD	DE,-FILEN
10332:	1FCD  C9      		RET
10333:			
10334:				ENDIF			;end of NOT RTPAK conditional
10335:				ENDIF			;end of SDISK conditional
10336:			
10337:			;end of SDISK
10339:			;STACKS 5/23/79
10340:			;XYBASIC Interpreter Source Module
10341:			;Copyright (C) 1978, 1979 by Mark Williams Company, Chicago
10342:			;symbol table and control stack manipulation routines
10343:			
10344:			
10345:			;FNDTK finds the location of a token in the keyword table.
10346:			;Call:	A	character or token
10347:			;Retn:	Carry	Reset if character, set if token
10348:			;	A	Preserved if character, 0 if token
10349:			;	BC,DE	Preserved
10350:			;	HL	Preserved if character, address of table entry if token
10351:	FFFF          		IF	NOT COMPL
10352:	1FCE  B7      	FNDTK:	OR	A
10353:	FFFF          		IF	KEY80
10354:	1FCF  FAE11F  		JP	M,FNDT1		;command or function token
10355:	1FD2  FE20    		CP	20H
10356:	1FD4  D0      		RET	NC		;printable char, return Carry reset
10357:	1FD5  FE0E    		CP	RWDTK
10358:	1FD7  3F      		CCF
10359:	1FD8  D0      		RET	NC		;<cr> or <bell>, return Carry reset
10360:	1FD9  213433  		LD	HL,RWDTA	;elese reserved word token
10361:	1FDC  D60D    		SUB	(RWDTK-1) AND 0FFH;token bias
10362:	1FDE  C3E61F  		JP	FNDT2
10363:				ELSE			;not KEY80
10365:				ENDIF
10366:	1FE1  217531  	FNDT1:	LD	HL,KEYTA
10367:	1FE4  C679    		ADD	A,NKEYS+1	;token bias
10368:	1FE6  3D      	FNDT2:	DEC	A		;decement token count
10369:	1FE7  C2EC1F  		JP	NZ,FNDT3	;not there yet
10370:	1FEA  37      		SCF			;else set Carry
10371:	1FEB  C9      		RET			;and return
10372:	1FEC  F5      	FNDT3:	PUSH	AF		;save token count
10373:	1FED  7E      	FNDT4:	LD	A,(HL)		;fetch char
10374:	1FEE  23      		INC	HL
10375:	1FEF  B7      		OR	A
10376:	1FF0  F2ED1F  		JP	P,FNDT4		;skip more chars in same keyword
10377:	1FF3  F1      		POP	AF		;restore token count
10378:	1FF4  C3E61F  		JP	FNDT2		;and keep looking
10379:				ENDIF
10380:			
10381:			;STPSH builds a new symbol table entry.
10382:			;Call:	A	token
10383:			;	HL	entry length
10384:			;	(bufad)	symbol name
10385:			;Retn:	(symta)	(symta) - length
10386:			;	((symta))	length
10387:			;	((symta)+1)	token
10388:			;	((symta)+2...)	name
10389:			;Other bytes in the entry are zeroed
10390:			;	A	token
10391:			;	BC	preserved
10392:			;	DE	address of name
10393:			;	HL	address following name
10394:	1FF7  C5      	STPSH:	PUSH	BC
10395:	1FF8  F5      		PUSH	AF		;save token
10396:	1FF9  EB      		EX	DE,HL		;length to DE
10397:	1FFA  3EFE    		LD	A,254
10398:	1FFC  BB      		CP	E		;Carry set iff (E) is 255
10399:	1FFD  9F      		SBC	A,A		;A is 255 if (E) is 255, 0 otherwise
10400:	1FFE  B2      		OR	D		;Zero set iff (DE) <= 254
10401:	1FFF  CA0420  		JP	Z,STPS1
10402:	2002  13      		INC	DE
10403:	2003  13      		INC	DE
10404:	2004  D5      	STPS1:	PUSH	DE		;save length
10405:	2005  CD0802  		CALL	CPLDE		;- length to DE
10406:	2008  2A5D3E  		LD	HL,(SYMTA)
10407:	200B  19      		ADD	HL,DE		;old - length = new symbol table address
10408:	200C  D24320  		JP	NC,OMERR	;much too big, OM error
10409:	200F  EB      		EX	DE,HL
10410:	2010  2A593E  		LD	HL,(CSTKP)
10411:	2013  EB      		EX	DE,HL		;CSTKP to DE
10412:	2014  CD2902  		CALL	CMDHU		;compare to new SYMTA
10413:	2017  D24320  		JP	NC,OMERR	;CSTKP >= new SYMTA, OM error
10414:	201A  225D3E  		LD	(SYMTA),HL	;store new SYMTA
10415:	201D  D1      		POP	DE		;restore length
10416:	201E  D5      		PUSH	DE		;and save
10417:	201F  E5      		PUSH	HL		;and save SYMTA
10418:	2020  3600    	STPS2:	LD	(HL),0		;zero a byte
10419:	2022  23      		INC	HL
10420:	2023  1B      		DEC	DE
10421:	2024  7A      		LD	A,D
10422:	2025  B3      		OR	E
10423:	2026  C22020  		JP	NZ,STPS2	;zero more bytes
10424:	2029  E1      		POP	HL		;restore pointer
10425:	202A  D1      		POP	DE		;and length
10426:	202B  7A      		LD	A,D
10427:	202C  B7      		OR	A
10428:	202D  CA3520  		JP	Z,STPS3
10429:	2030  36FF    		LD	(HL),255	;long entry
10430:	2032  23      		INC	HL
10431:	2033  72      		LD	(HL),D
10432:	2034  23      		INC	HL
10433:	2035  73      	STPS3:	LD	(HL),E		;store length
10434:	2036  23      		INC	HL
10435:	2037  F1      		POP	AF		;recover token
10436:	2038  F5      		PUSH	AF
10437:	2039  77      		LD	(HL),A		;store token
10438:	203A  23      		INC	HL
10439:	203B  E5      		PUSH	HL		;save name pointer
10440:	203C  CD9F1B  		CALL	CPYS0		;copy name from bufad
10441:	203F  D1      		POP	DE		;return name pointer in DE
10442:	2040  F1      		POP	AF		;restore token to A
10443:	2041  C1      		POP	BC
10444:	2042  C9      		RET
10445:	2043          	OMERR:	ERROR	F, O, M		;fatal OM error
10446:			
10447:			;STNXT gets the address of the next symbol table entry.
10448:			;Call:	HL	address of current symbol table entry length byte
10449:			;Retn:	Carry	set iff no more entries
10450:			;	BC	preserved
10451:			;	DE	current entry type byte address
10452:			;	HL	next entry address
10453:	2048  7E      	STNXT:	LD	A,(HL)		;fetch length byte
10454:	2049  B7      		OR	A
10455:	204A  37      		SCF
10456:	204B  C8      		RET	Z		;return carry set if at end of table
10457:	204C  54      		LD	D,H
10458:	204D  5D      		LD	E,L
10459:	204E  13      		INC	DE		;point to type byte
10460:	204F  FEFF    		CP	255		;check if long entry
10461:	2051  C21502  		JP	NZ,ADAHL	;no, so length + current = next and return
10462:	2054  EB      		EX	DE,HL		;current to DE, length byte addr to HL
10463:	2055  7E      		LD	A,(HL)
10464:	2056  23      		INC	HL
10465:	2057  E5      		PUSH	HL		;save type byte addr - 1
10466:	2058  6E      		LD	L,(HL)
10467:	2059  67      		LD	H,A		;length to HL
10468:	205A  19      		ADD	HL,DE		;current + length = next
10469:	205B  D1      		POP	DE		;type byte addr to DE
10470:	205C  13      		INC	DE
10471:	205D  C9      		RET
10472:			
10473:			;STLKU looks up a symbol in the symbol table.
10474:			;Call:	(bufad)	symbol name string
10475:			;	(varty)	symbol type token
10476:			;Retn:	Carry	set iff not found, otherwise:
10477:			;	DE	entry type address
10478:			;	HL	address following name in entry
10479:	205E  3A353E  	STLKU:	LD	A,(VARTY)
10480:	2061  2A5D3E  	STLK0:	LD	HL,(SYMTA)
10481:	2064  47      		LD	B,A		;desired type to B
10482:	2065  CD4820  	STLK1:	CALL	STNXT		;address next entry
10483:	2068  D8      		RET	C		;return carry set iff not found
10484:	2069  1A      		LD	A,(DE)		;fetch entry type
10485:	206A  E61F    		AND	1FH		;mask to type
10486:	206C  B8      		CP	B
10487:	206D  C26520  		JP	NZ,STLK1	;not the right type, try next
10488:	2070  E5      		PUSH	HL		;save next
10489:	2071  D5      		PUSH	DE		;save type byte addr
10490:	2072  EB      		EX	DE,HL
10491:	2073  23      		INC	HL		;point to name
10492:	2074  115F3E  		LD	DE,BUFAD
10493:	2077  CD941B  		CALL	CMPST		;compare to desired name
10494:	207A  D1      		POP	DE		;restore type addr to DE
10495:	207B  CA9509  		JP	Z,POP1		;matched, pop next to BC and retn Carry reset
10496:	207E  E1      		POP	HL		;else next to HL
10497:	207F  C36520  		JP	STLK1		;and try next
10498:			
10499:			;STZAP resets BREAK and FN entries in the symbol table.
10500:			;Retn:	BC	preserved
10501:			;	A,DE,HL	clobbered
10502:	2082  2A5D3E  	STZAP:	LD	HL,(SYMTA)
10503:	2085  CD4820  	STZA1:	CALL	STNXT
10504:	0000          		IF	COMPL
10506:				ELSE
10507:	2088  DA9D20  		JP	C,UNBKL		;unbreak lines if not compl
10508:				ENDIF
10509:	208B  1A      		LD	A,(DE)
10510:	208C  E61F    		AND	1FH		;mask to type
10511:	FFFF          		IF	NOT COMPL
10512:	208E  FE05    		CP	BRKST
10513:	2090  CA9820  		JP	Z,STZA2		;break
10514:				ENDIF
10515:	2093  FE04    		CP	UFNST		;check if user-defined fn
10516:	2095  C28520  		JP	NZ,STZA1	;neither FN nor break, try next
10517:	2098  AF      	STZA2:	XOR	A
10518:	2099  12      		LD	(DE),A		;store 0 type byte
10519:	209A  C38520  		JP	STZA1
10520:			
10521:	FFFF          		IF	NOT COMPL
10522:			;UNBKL removes all line breakpoints.
10523:	209D          	UNBKL:
10524:	0000          		IF	ROMSQ		;first loc to test to HL
10528:				ELSE
10529:	209D  21CF3F  		LD	HL,SRCAD
10530:				ENDIF
10531:	20A0  7E      	UNBL1:	LD	A,(HL)
10532:	20A1  B7      		OR	A
10533:	20A2  C8      		RET	Z		;done
10534:	20A3  E5      		PUSH	HL
10535:	20A4  CDE32B  		CALL	UNBR1		;unbreak a line
10536:	20A7  E1      		POP	HL
10537:	20A8  CD1502  		CALL	ADAHL		;point to next line
10538:	20AB  C3A020  		JP	UNBL1		;and keep going
10539:				ENDIF
10540:			
10541:			;CPUSH checks that sufficient free memory remains to build a control stack
10542:			;entry and if not issues an OM error.  Otherwise it pushes a token, (TEXTP) and
10543:			;(LNNUM) to the control stack, and updates the stack pointer.
10544:			;Call:	A	token (l.s. 5 bits give entry length)
10545:			;Retn:	A,BC	clobbered
10546:			;	DE	return text pointer
10547:			;	HL	(cstkp) - 4
10548:			;	(cstkp)	(cstkp) + (A4-A0)
10549:			;	((cstkp))	token
10550:			;	((cstkp)-1:(cstkp)-2)	line # address
10551:			;	((cstkp)-3:(cstkp)-4)	return text pointer
10552:	20AE  2AC63F  	CPUSH:	LD	HL,(TEXTP)
10553:	20B1  E5      		PUSH	HL
10554:	20B2  47      	CPSH1:	LD	B,A		;save token
10555:	20B3  2A593E  		LD	HL,(CSTKP)
10556:	20B6  E61F    	CPSH2:	AND	1FH		;mask to length
10557:	20B8  CD1502  		CALL	ADAHL
10558:	20BB  DADC20  		JP	C,CPSH3		;new stacktop > 64K, OM error
10559:	20BE  CD8927  		CALL	CSPST		;store new control stack pointer
10560:	20C1  EB      		EX	DE,HL		;cstack pointer to DE
10561:	20C2  2A5D3E  		LD	HL,(SYMTA)	;symbol table pointer to HL
10562:	20C5  CD2902  		CALL	CMDHU		;compare
10563:	20C8  D2DC20  		JP	NC,CPSH3	;OM -- flush and continue
10564:	20CB  2AE23C  		LD	HL,(LNNUM)
10565:	FFFF          		IF	NOT COMPL
10566:	20CE  7C      		LD	A,H
10567:	20CF  B5      		OR	L
10568:	20D0  CC3C21  		CALL	Z,ICSTD		;increment CSTACK direct count if direct
10569:				ENDIF
10570:	20D3  EB      		EX	DE,HL		;current line # address to DE
10571:	20D4  70      		LD	(HL),B		;token to control stack
10572:	20D5  CDF301  		CALL	MVMDE		;return line # address to control stack
10573:	20D8  D1      		POP	DE
10574:	20D9  C3F301  		JP	MVMDE		;return text pointer to control stack & return
10575:	20DC  CDB822  	CPSH3:	CALL	CLEA2		;reset CSTACK pointer
10576:	20DF          		ERROR	N, O, M		;nonfatal OM error
10577:	20E4  78      		LD	A,B		;restore token
10578:	20E5  C3B620  		JP	CPSH2		;try again
10579:			
10580:			;CSPOP is used to pop information from the control stack for RETURNs from
10581:			;GOSUBs and interrupts, for CONTinues, and for NEXTs.
10582:			;If the entry was made from direct mode, the dmode count CSTKD is
10583:			;decremented and an ID error issued if < 0.
10584:			;Call:	HL	address of control stack entry type/length byte
10585:			;Retn:	(lnnum)	control stack entry line # bytes
10586:			;	(textp)	control stack entry return address
10587:			;	PSW,BC	preserved
10588:			;	DE	new textp
10589:			;	HL	(HL) - 5
10590:	20E8          	CSPOP:
10591:	0000          		IF	COMPL
10594:				ELSE			;non COMPL version must update CSTKD
10595:	20E8  F5      		PUSH	AF
10596:	20E9  E5      		PUSH	HL		;save type byte addr
10597:	20EA  2B      		DEC	HL
10598:	20EB  CDEE01  		CALL	MVDEM		;line # of entry to DE
10599:	20EE  E3      		EX	(SP),HL		;save entry pointer, type byte addr to HL
10600:	FFFF          		IF	NOT COMPL
10601:	20EF  7A      		LD	A,D
10602:	20F0  B3      		OR	E		;test if direct mode entry
10603:	20F1  C2FD20  		JP	NZ,CSPO1	;no -- restore and return
10604:	20F4  CD4321  		CALL	DCSTD		;yes -- decrement CSTACK direct count
10605:	20F7  7E      		LD	A,(HL)		;fetch type byte
10606:	20F8  FE4F    		CP	CSFOR		;check if doing a NEXT
10607:	20FA  CC3C21  		CALL	Z,ICSTD		;undecrement count if so
10608:				ENDIF
10609:	20FD  E1      	CSPO1:	POP	HL		;restore entry ptr
10610:	20FE  F1      		POP	AF
10611:				ENDIF
10612:	20FF  EB      		EX	DE,HL
10613:	2100  22E23C  		LD	(LNNUM),HL	;store new lnnum
10614:	2103  EB      		EX	DE,HL
10615:	2104  CDEE01  		CALL	MVDEM
10616:	2107  EB      		EX	DE,HL
10617:	2108  22C63F  		LD	(TEXTP),HL	;store new textp
10618:	210B  EB      		EX	DE,HL
10619:	210C  C9      		RET			;and continue from there
10620:			
10621:			;CSDIG digs in the control stack for an entry with type matching B or C.
10622:			;Call:	B,C	desired type/length bytes
10623:			;Retn:	A	type/length byte found, 0 if none
10624:			;	BC,DE	preserved
10625:			;	HL	addr of type/length byte, eofad if not found
10626:			;	Carry	set iff not found
10627:	210D  2A593E  	CSDIG:	LD	HL,(CSTKP)
10628:	2110  7E      	CSDI1:	LD	A,(HL)		;fetch type/length byte
10629:	2111  B8      		CP	B
10630:	2112  C8      		RET	Z		;found
10631:	2113  B9      		CP	C
10632:	2114  C8      		RET	Z		;found
10633:	2115  E61F    		AND	1FH		;mask to length
10634:	2117  37      		SCF
10635:	2118  C8      		RET	Z		;not found
10636:	2119  CD1C02  		CALL	SBAHL		;address next
10637:	211C  C31021  		JP	CSDI1		;and try it
10638:			
10639:			;CSRST resets the control stack after purging an entry.
10640:			;Call:	A	type/length byte of entry to be purged
10641:			;	HL	address of next entry in stack
10642:			;Retn:	BC	preserved
10643:			;	HL	new cstkp
10644:	211F  C5      	CSRST:	PUSH	BC
10645:	2120  23      		INC	HL		;point to destination
10646:	2121  E5      		PUSH	HL		;and save it
10647:	2122  E61F    		AND	1FH		;mask A to length
10648:	2124  CD1502  		CALL	ADAHL		;destination + offset = source
10649:	2127  E5      		PUSH	HL		;saved
10650:	2128  EB      		EX	DE,HL
10651:	2129  CD0802  		CALL	CPLDE
10652:	212C  2A593E  		LD	HL,(CSTKP)
10653:	212F  19      		ADD	HL,DE		;# of bytes to move -1 to HL
10654:	2130  23      		INC	HL
10655:	2131  EB      		EX	DE,HL		;and then to DE
10656:	2132  C1      		POP	BC		;source to BC
10657:	2133  E1      		POP	HL		;destination to HL
10658:	2134  DC3637  		CALL	C,MOVED		;move rest  of stack
10659:	2137  C1      		POP	BC		;restore BC
10660:	2138  2B      		DEC	HL		;readdress cstkp
10661:	2139  C38927  		JP	CSPST		;and reset it
10662:			
10663:			;ICSTD increments the CSTACK direct count CSTKD.  DCSTD decrements CSTKD and
10664:			;issues an ID error if negative.  CSTKD counts how many CSTACK entries
10665:			;have been built from direct mode, and catches errors such as attempting to
10666:			;RETURN or NEXT when the GOSUB or FOR context has been lost.
10667:			;Status bits affected, all registers preserved.
10668:	FFFF          		IF	NOT COMPL
10669:	213C  E5      	ICSTD:	PUSH	HL
10670:	213D  21C43F  		LD	HL,CSTKD
10671:	2140  34      		INC	(HL)		;increment cstack direct count
10672:	2141  E1      		POP	HL
10673:	2142  C9      		RET
10674:	2143  E5      	DCSTD:	PUSH	HL
10675:	2144  21C43F  		LD	HL,CSTKD
10676:	2147  35      		DEC	(HL)		;decrement cstack direct count
10677:	2148  E1      		POP	HL
10678:	2149  F0      		RET	P		;ok if nonnegative
10679:	214A  C31901  		JP	IDERR		;fatal ID error if negative
10680:				ENDIF
10681:			
10682:			
10683:			;end of STACKS
10685:			;STATES1 12/02/80
10686:			;XYBASIC Interpreter Source Module
10687:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
10688:			;statement routines for statements ASSIGN through EXEC
10689:			
10690:			
10691:			;ASSIGN {LST# | PUN# | RDR# | CON#} <expr>
10692:	FFFF          		IF	(NOT CAMAC) AND (NOT WILD)
10693:			;ASSIGN changes the value of the specified field of IOBYTE.
10694:	214D  CD5A18  	ASSIG:	CALL	GTCHA		;fetch token
10695:	2150  D613    		SUB	CONTK		;subtract CON# token bias
10696:	2152  DA3501  		JP	C,SNERR		;too small
10697:	2155  FE04    		CP	4
10698:	2157  D23501  		JP	NC,SNERR	;too big
10699:	215A  07      		RLCA			;*2 bits  = shift count (0, 2, 4, 6)
10700:	215B  5F      		LD	E,A		;shift count to E
10701:	215C  CD8F0C  		CALL	GTEXP		;arg to BC
10702:	215F  79      		LD	A,C
10703:	2160  E6FC    		AND	0FCH
10704:	2162  B0      		OR	B		;check if arg > 3
10705:	2163  C48C13  		CALL	NZ,FCERN	;yes, nonfatal FC error
10706:	2166  3E03    		LD	A,3
10707:	2168  47      		LD	B,A		;mask to B
10708:	2169  A1      		AND	C
10709:	216A  4F      		LD	C,A		;masked new bits to C1-0
10710:	0000          		IF	NONST
10721:				ENDIF
10722:	216B  CDBC15  	ASSI1:	CALL	LSHFT		;shift mask and bits to desired position
10723:	216E  78      		LD	A,B
10724:	216F  2F      		CPL
10725:	2170  210300  		LD	HL,IOBYT
10726:	2173  A6      		AND	(HL)		;mask out old field
10727:	2174  B1      		OR	C		;OR in the new field
10728:	2175  77      		LD	(HL),A		;store the new iobyte
10729:	2176  C9      		RET
10730:				ENDIF
10731:			
10732:			;AUTO [<line #> [, <line #>]]
10733:	FFFF          		IF	EDITC
10734:	0000          		IF	COMPL
10736:				ELSE
10737:	2177          	AUTO:
10738:	0000          		IF	ROMSQ
10740:				ENDIF
10741:	2177  210A00  		LD	HL,10
10742:	217A  E5      		PUSH	HL		;default increment = 10
10743:	217B  E5      		PUSH	HL		;default first line # = 10
10744:	217C  CD4D19  		CALL	GTLNO		;look for <line #>
10745:	217F  DA9421  		JP	C,AUTO1		;no args, take defaults
10746:	2182  EB      		EX	DE,HL		;<line #> to HL
10747:	2183  E3      		EX	(SP),HL		;and replaces default <line #>
10748:	2184  CD8518  		CALL	GTCND		;look for comma
10749:	2187  DA9421  		JP	C,AUTO1		;no second arg
10750:	218A  CD4D19  		CALL	GTLNO		;look for increment arg
10751:	218D  DA3501  		JP	C,SNERR		;not found
10752:	2190  EB      		EX	DE,HL		;increment to HL
10753:	2191  D1      		POP	DE
10754:	2192  E3      		EX	(SP),HL		;and replaces default incrment
10755:	2193  D5      		PUSH	DE
10756:	2194  CD1E01  	AUTO1:	CALL	IITST		;AUTO illegal indirect
10757:			;At AUTO2 the next desired line # and the increment are on the stack.
10758:	2197  C1      	AUTO2:	POP	BC		;next line # to BC
10759:	2198  C5      		PUSH	BC
10760:	2199  CD0D17  		CALL	WRTBU		;write the line #
10761:	219C  50      		LD	D,B
10762:	219D  59      		LD	E,C		;line # to DE
10763:	219E  CD4137  		CALL	FINDL		;look for it in current source text
10764:	21A1  3E20    		LD	A,' '
10765:	21A3  DAA821  		JP	C,AUTO3		;write a space if no such line exists
10766:	21A6  3E2A    		LD	A,'*'		;else write a *
10767:	21A8  CD1F16  	AUTO3:	CALL	WRITC
10768:	21AB  CD2B37  		CALL	LNNU0		;reset LNNUM to 0 in case ^C typed
10769:	21AE  CDB433  		CALL	GTLIN		;get line from user
10770:	21B1  CDA735  		CALL	TKIZE		;tokenize it
10771:	21B4  CA3D07  		JP	Z,DMOD2		;return to DMODE if user types <cr>
10772:	21B7  D42B37  		CALL	NC,LNNU0
10773:	21BA  D23501  		JP	NC,SNERR	;SN error if <line #> typed
10774:	21BD  E1      		POP	HL
10775:	21BE  E5      		PUSH	HL
10776:	21BF  22E23C  		LD	(LNNUM),HL	;set LNNUM to desired line
10777:	21C2  CDA436  		CALL	ADDLN		;add new line to source text
10778:	21C5  E1      		POP	HL
10779:	21C6  D1      		POP	DE
10780:	21C7  19      		ADD	HL,DE		;new line # is line # + increment
10781:	21C8  DAD021  		JP	C,AUTO4		;OV error if > 65535
10782:	21CB  D5      		PUSH	DE
10783:	21CC  E5      		PUSH	HL
10784:	21CD  C39721  		JP	AUTO2		;else get next line
10785:	21D0  CD2B37  	AUTO4:	CALL	LNNU0
10786:	21D3  3E0D    		LD	A,CR
10787:	21D5  32C33E  		LD	(NLNAD),A	;reset input buffer for error message
10788:	21D8  CDEB19  		CALL	IOVER		;issue OV error
10789:	21DB  C33D07  		JP	DMOD2		;and return to direct mode
10790:				ENDIF
10791:				ELSE
10793:				ENDIF
10794:			
10795:			;BREAK {<var list> | <line #> [,<expr>] [;<var list>] [;$]}
10796:			;BREAK <var list> creates variable breaks by setting symbol table entry bits.
10797:			;BREAK <line #>... creates line breakpoints by setting the line break byte,
10798:			;and also building a symbol table line break entry if necessary.
10799:	0000          		IF	COMPL
10801:				ELSE
10802:	21DE  CD4D19  	BREAK:	CALL	GTLNO		;look for line #
10803:	21E1  DA5522  		JP	C,BKVAR		;no line #, must be var break
10804:	0000          		IF	ROMSQ
10806:				ENDIF
10807:	21E4  CD6337  		CALL	FDLNO		;find the line
10808:	21E7  23      		INC	HL
10809:	21E8  23      		INC	HL
10810:	21E9  23      		INC	HL		;address break byte
10811:	21EA  E5      		PUSH	HL		;save break byte addr
10812:	21EB  CD7C18  		CALL	GTCOM		;look for comma
10813:	21EE  010100  		LD	BC,1		;default count = 1 to BC
10814:	21F1  D48F0C  		CALL	NC,GTEXP	;get count if comma
10815:	21F4  C5      		PUSH	BC		;save count
10816:	21F5  0B      		DEC	BC
10817:	21F6  78      		LD	A,B
10818:	21F7  B1      		OR	C		;Zero set iff count = 1
10819:	21F8  3E01    		LD	A,1		;break byte value to A
10820:	21FA  CAFF21  		JP	Z,BRKL1
10821:	21FD  F602    		OR	2		;bit 1 on iff count <> 1
10822:			;At BRKL1 the break byte addr and count are PUSHed, the break byte is in A.
10823:	21FF  5F      	BRKL1:	LD	E,A		;save the break byte
10824:	2200  163B    		LD	D,SEMIC
10825:	2202  CD8E18  		CALL	GTD		;look for ;
10826:	2205  22523E  		LD	(TXTP2),HL	;save varlist address
10827:	2208  C22F22  		JP	NZ,BRKL4	;no ; present
10828:	220B  D5      	BRKL2:	PUSH	DE
10829:	220C  CDA31A  		CALL	GTVAR		;look for var ref
10830:	220F  D1      		POP	DE
10831:	2210  DA2622  		JP	C,BRKL3		;none, must be $
10832:	2213  CD1501  		CALL	IDTST		;BREAK illegal direct if <var list> present
10833:	2216  7B      		LD	A,E
10834:	2217  F606    		OR	6		;set varlist bits in break byte
10835:	2219  5F      		LD	E,A
10836:	221A  CD7C18  		CALL	GTCOM		;look for comma
10837:	221D  D20B22  		JP	NC,BRKL2	;more vars
10838:	2220  CD8E18  		CALL	GTD		;look for ;
10839:	2223  C22F22  		JP	NZ,BRKL4
10840:	2226  1624    	BRKL3:	LD	D,'$'
10841:	2228  CDA618  		CALL	GTDSN		;skip $
10842:	222B  7B      		LD	A,E
10843:	222C  F608    		OR	8		;set bit 3 to indicate break to DMODE
10844:	222E  5F      		LD	E,A
10845:	222F  7B      	BRKL4:	LD	A,E		;break byte value to A
10846:	2230  C1      		POP	BC		;count to BC
10847:	2231  E1      		POP	HL		;restore break byte addr
10848:	2232  77      		LD	(HL),A		;store break byte
10849:	2233  E606    		AND	6		;check if must build symbol table entry
10850:	2235  C8      		RET	Z		;no, done
10851:			;Now a symbol table line break entry is built.  The entry contains
10852:			;a length byte, type byte, three 'name' bytes with the encoded line #,
10853:			;two count bytes (how many passes until next break), two reset bytes (the
10854:			;value for resetting count when it reaches zero), and two varlist addr bytes.
10855:	2236  C5      		PUSH	BC		;save count
10856:	2237  2B      		DEC	HL
10857:	2238  2B      		DEC	HL		;HL contains line # addr
10858:	2239  CD0E04  		CALL	BKNAM		;form break entry name in BUFAD
10859:	223C  210B00  		LD	HL,11		;entry length = 11
10860:	223F  3E05    		LD	A,BRKST		;token to A
10861:	2241  CDF71F  		CALL	STPSH		;build the entry
10862:	2244  D1      		POP	DE		;count to DE
10863:	2245  73      		LD	(HL),E
10864:	2246  23      		INC	HL
10865:	2247  72      		LD	(HL),D		;count to entry
10866:	2248  CD5022  		CALL	MOMDE		;reset to entry
10867:	224B  EB      		EX	DE,HL
10868:	224C  2A523E  		LD	HL,(TXTP2)
10869:	224F  EB      		EX	DE,HL		;varlist address to DE
10870:				ENDIF
10871:	2250  23      	MOMDE:	INC	HL
10872:	2251  73      		LD	(HL),E
10873:	2252  23      		INC	HL
10874:	2253  72      		LD	(HL),D		;varlist address to entry
10875:	2254  C9      		RET			;and return
10876:	FFFF          		IF	NOT COMPL
10877:			;BKVAR sets type byte bits in symbol table entries to indicate variable breaks.
10878:	2255  CD861A  	BKVAR:	CALL	FDVAR		;find variable name
10879:	2258  DA3501  		JP	C,SNERR		;no var
10880:	225B  1A      		LD	A,(DE)
10881:	225C  F680    		OR	80H		;set break bit in type byte
10882:	225E  12      		LD	(DE),A
10883:	225F  CD8518  		CALL	GTCND		;look for comma
10884:	2262  D25522  		JP	NC,BKVAR	;break another var
10885:	2265  C9      		RET
10886:				ENDIF
10887:			
10888:			;CALL <expr> [, {<var ref> | * <var name>}]*
10889:	2266  216507  	CALCM:	LD	HL,NEXTC
10890:	2269  E5      		PUSH	HL		;push return address to scan to next statement
10891:	226A  CD8F0C  		CALL	GTEXP		;get location
10892:	226D  C5      		PUSH	BC
10893:	226E  C9      		RET			;branch to user routine
10894:			
10895:			;CAMAC commands are in module CAMAC.
10896:			
10897:			;CLEAR
10898:			;CLEAR <expr>		[in STRNG versions]
10899:			;CLEAR @ <expr>		[in CPM SDISK versions]
10900:			;DCLR0 is in module SDISK.
10901:	226F          	CLEAR:
10902:	FFFF          		IF	STRNG
10903:	226F  CD3F01  		CALL	DTST0		;check if delimiter follows
10904:	2272  D2A022  		JP	NC,CLEA1	;yes, keep same string space
10905:	FFFF          		IF	CPM AND SDISK
10906:	2275  CD911F  		CALL	GTATN		;look for @ <expr>
10907:	2278  D2AB1B  		JP	NC,DCLR0	;change max number of disk files
10908:				ENDIF
10909:	227B  CD8F0C  		CALL	GTEXP		;otherwise get argument
10910:	227E  78      		LD	A,B
10911:	227F  B7      		OR	A
10912:	2280  FA9213  		JP	M,FCERF		;fatal FC error if negative string space given
10913:	2283  50      		LD	D,B
10914:	2284  59      		LD	E,C		;to DE
10915:	2285  CD0802  		CALL	CPLDE		;complement desired amount of string space
10916:	2288  2ACA3F  		LD	HL,(EOFAD)
10917:	228B  010900  		LD	BC,9
10918:	228E  09      		ADD	HL,BC		;leave enough room to compute trivial exprs
10919:	228F  E5      		PUSH	HL		;save eof top pointer
10920:	2290  2A3B3D  		LD	HL,(STRT)	;top of string space to HL
10921:	2293  19      		ADD	HL,DE		;new MEMT value to HL
10922:	2294  D1      		POP	DE		;eof pointer to DE
10923:	2295  CD2902  		CALL	CMDHU		;make sure sufficient space available
10924:	2298  D24320  		JP	NC,OMERR	;no -- fatal OM error
10925:	229B  22CC3F  	CLE0A:	LD	(MEMT),HL	;yes -- store new MEMT value
10926:	229E  3600    		LD	(HL),0		;and initialize symbol table
10927:				ENDIF
10928:	22A0          	CLEA1:
10929:	FFFF          		IF	NOT COMPL
10930:	22A0  CD9D20  		CALL	UNBKL		;unbreak line breaks
10931:				ENDIF
10932:	22A3  2ACC3F  		LD	HL,(MEMT)
10933:	FFFF          		IF	STRNG
10934:	22A6  223D3D  		LD	(STRPT),HL	;initialize string pointer
10935:	22A9  223F3D  		LD	(STRP2),HL	;and string temp pointer
10936:				ENDIF
10937:	22AC  225D3E  		LD	(SYMTA),HL	;and symbol table
10938:	FFFF          		IF	STRNG OR FLOAT	;reset default type buffer entries
10939:	FFFF          		IF	FLOAT		;default token to B, buffer length 26 to C
10940:	22AF  011A02  		LD	BC,(SNGST SHL 8) OR 26
10941:				ELSE
10943:				ENDIF
10944:	22B2  21363E  		LD	HL,TYBUF	;default type buffer address to HL
10945:	22B5  CD6C23  		CALL	FILLM		;reset default type buffer
10946:				ENDIF			;end of STRNG or FLOAT conditional
10947:	0000          		IF	CAMAC AND C3908	;reset BKSET parameters if CAMAC on 3908
10951:				ENDIF
10952:	0000          		IF	PACKI
10955:				ENDIF
10956:	22B8  2ACA3F  	CLEA2:	LD	HL,(EOFAD)
10957:	22BB  C38927  		JP	CSPST		;reset the control stack
10958:			
10959:			;CONT
10960:	0000          		IF	COMPL
10962:				ELSE
10963:	22BE  CD1E01  	CONT:	CALL	IITST		;CONT illegal indirect
10964:	22C1  2A593E  		LD	HL,(CSTKP)
10965:	22C4  7E      		LD	A,(HL)
10966:	22C5  FE65    		CP	CSBRK		;see if BREAK entry atop control stack
10967:	22C7  CAD622  		JP	Z,CONT1		;yes -- pop it
10968:	22CA  FEA5    		CP	CSLBK		;see if line break entry
10969:	22CC  C2DC22  		JP	NZ,CNERR	;no -- CN error
10970:	22CF  CDD622  		CALL	CONT1		;pop entry
10971:	22D2  C1      		POP	BC		;pop CONT return address
10972:	22D3  C3B207  		JP	XSTAT		;continue at XSTAT, skipping break test
10973:	22D6  CDE820  	CONT1:	CALL	CSPOP		;yes -- pop it
10974:	22D9  C38927  		JP	CSPST		;reset control stack pointer and return
10975:	22DC          	CNERR:	ERROR	F, C, N		;fatal CN error
10976:				ENDIF
10977:			
10978:			;DATA [<expr>] [,<expr>]*
10979:			;DATA is ignored when encountered, so the command dispatch table branches
10980:			;to GTDEL to scan to next command for DATA.
10981:			
10982:			;DEF FN <var name> [(<var name> [, <var name>]* )] = <expr>
10983:			;DEF {INT | STR | SNG | CAMVAR} <letter> [- <letter>]
10984:	22E1  CD5A18  	DEF:	CALL	GTCHA		;get following token
10985:	22E4  FEBF    		CP	UDFNT
10986:	22E6  C24723  		JP	NZ,DEFVT	;not a user-def FN, must be var declaration
10987:			;DEF FN builds a symbol table entry for a user-defined function.  The entry
10988:			;contains a length byte, type token, name bytes, and two address bytes.
10989:			;The addr bytes contain the fn body addr if 0-ary, or bound var addr otherwise.
10990:			;The type token is UFNST if 0-ary and (UFNST or 20H) otherwise.
10991:	22E9  CD1501  		CALL	IDTST		;DEF FN illegal direct
10992:	22EC  CD2D1A  		CALL	GTNAM		;get fn name
10993:	22EF  210400  		LD	HL,4
10994:	22F2  CD1502  		CALL	ADAHL		;name length + overhead = entry length to HL
10995:	22F5  E5      		PUSH	HL		;and saved
10996:	22F6  3E04    		LD	A,UFNST
10997:	22F8  CD6120  		CALL	STLK0		;look up the fn name
10998:	22FB  D22F24  		JP	NC,DDERR	;already defined -- fatal DD error
10999:	22FE  1628    		LD	D,'('
11000:	2300  CD8E18  		CALL	GTD		;look for (
11001:	2303  DA2223  		JP	C,DEF1		;0-ary fn
11002:	2306  E3      		EX	(SP),HL		;save bound var addr, entry length to HL
11003:	2307  3E04    		LD	A,UFNST
11004:	2309  F620    		OR	20H		;set unary bit
11005:	230B  CDF71F  		CALL	STPSH		;build symbol table entry
11006:	230E  E5      		PUSH	HL
11007:	230F  CD861A  	DEF0:	CALL	FDVAR		;look for nonsubscripted variable
11008:	2312  DA3501  		JP	C,SNERR
11009:	2315  CD7C18  		CALL	GTCOM		;look for comma
11010:	2318  D20F23  		JP	NC,DEF0		;comma must be followed by another bound var
11011:	231B  CDAD18  		CALL	GTREQ		;skip ) =
11012:	231E  E1      		POP	HL
11013:	231F  C32B23  		JP	DEF2
11014:	2322  CDB218  	DEF1:	CALL	GTEQU		;skip = token
11015:	2325  3E04    		LD	A,UFNST		;token to A
11016:	2327  E3      		EX	(SP),HL		;save addr, get entry length
11017:	2328  CDF71F  		CALL	STPSH		;build symbol table entry
11018:	232B  D1      	DEF2:	POP	DE		;body address to DE
11019:	232C  73      		LD	(HL),E
11020:	232D  23      		INC	HL
11021:	232E  72      		LD	(HL),D		;body address to entry
11022:	232F  C3B718  		JP	GTDEL		;scan function body and return
11023:			
11024:	FFFF          		IF	STRNG OR FLOAT
11025:			;DEFVT sets the default type for variables with given initial letter(s).
11026:			;The 26 byte buffer TYBUF contains the default variable types.
11027:			;DEFTY returns the type token in B corresponding to keyword token in A.
11028:	2332  0601    	DEFTY:	LD	B,INTST
11029:	2334  FEDC    		CP	INTT
11030:	2336  C8      		RET	Z		;integer type
11031:	FFFF          		IF	FLOAT
11032:	2337  0602    		LD	B,SNGST
11033:	2339  FE17    		CP	SNGT
11034:	233B  C8      		RET	Z		;floating type
11035:				ENDIF
11036:	FFFF          		IF	STRNG
11037:	233C  0603    		LD	B,STRST
11038:	233E  FE18    		CP	STRGT
11039:	2340  C8      		RET	Z		;string type
11040:				ENDIF
11041:	0000          		IF	CAMAC
11045:				ENDIF
11046:	2341  CD6B18  		CALL	BAKUP		;else back up TEXTP
11047:	2344  C33501  		JP	SNERR		;and issue SN error
11048:	2347  CD3223  	DEFVT:	CALL	DEFTY		;desired type to B
11049:	234A  CD7018  		CALL	GTALP		;first letter to A
11050:	234D  DA3501  		JP	C,SNERR		;SN error if none
11051:	2350  5F      		LD	E,A		;and first saved in E
11052:	2351  16C2    		LD	D,MINT
11053:	2353  CD8E18  		CALL	GTD		;look for -
11054:	2356  7B      		LD	A,E		;default last = same as first
11055:	2357  DA6023  		JP	C,DEFV1		;no second letter specified
11056:	235A  CD7018  		CALL	GTALP		;else get second
11057:	235D  DA3501  		JP	C,SNERR
11058:	2360  93      	DEFV1:	SUB	E		;second - first
11059:	2361  FA3501  		JP	M,SNERR		;second precedes first
11060:	2364  3C      		INC	A		;# of entries to change
11061:	2365  4F      		LD	C,A		;count to C
11062:	2366  1600    		LD	D,0		;DE now has first letter in ASCII
11063:	2368  21F53D  		LD	HL,TYBUF-'A'
11064:	236B  19      		ADD	HL,DE		;address first entry to change
11065:				ELSE
11067:				ENDIF
11068:	FFFF          		IF	STRNG OR FLOAT OR ROM
11069:			;FILLM fills (C) bytes of memory starting at (HL) with (B).
11070:	236C  70      	FILLM:	LD	(HL),B		;change to desired value
11071:	236D  23      		INC	HL
11072:	236E  0D      		DEC	C
11073:	236F  C26C23  		JP	NZ,FILLM	;and fill more
11074:	2372  C9      		RET
11075:				ENDIF
11076:			
11077:			;DELAY <expr> [ , <expr> [ , <expr> ]]
11078:	FFFF          		IF	NOT CAMAC	;CAMAC DELAY is in module CAMAC
11079:	0000          		IF	REALT		;hardware real time clock delay
11131:				ELSE			;software real time clock delay
11132:	2373  2ADB3C  	DELAY:	LD	HL,(TIMEX)
11133:	2376  CDBB23  		CALL	DELA1		;delay minutes
11134:	2379  2ADD3C  		LD	HL,(TIMEX+2)
11135:	237C  CDBB23  		CALL	DELA1		;delay seconds
11136:	237F  CD8F0C  		CALL	GTEXP		;get hundredths count
11137:	2382  78      		LD	A,B
11138:	2383  B1      		OR	C
11139:	2384  C8      		RET	Z		;done if hundredths count is zero
11140:	2385  50      		LD	D,B
11141:	2386  59      		LD	E,C		;to DE
11142:	2387  219CFF  	DELH1:	LD	HL,-100
11143:	238A  19      		ADD	HL,DE		;carry reset iff hundredths count < 100
11144:	238B  D29823  		JP	NC,DELH2	;delay hundredths
11145:	238E  EB      		EX	DE,HL		;hundredths=hundredths-100 to DE
11146:	238F  2ADD3C  		LD	HL,(TIMEX+2)	;seconds count to HL
11147:	2392  CDAB23  		CALL	TIMER		;delay one second
11148:	2395  C38723  		JP	DELH1		;and try again
11149:	2398  3ADF3C  	DELH2:	LD	A,(TIMEX+4)	;minutes / 256 to A
11150:	239B  CD6A12  		CALL	MULT0		;* hundredths count
11151:	239E  44      		LD	B,H
11152:	239F  4D      		LD	C,L
11153:	23A0  111800  		LD	DE,24
11154:	23A3  CD8A12  		CALL	DIVD0		;divide by 24 to put hundredth count in HL
11155:	23A6  EB      		EX	DE,HL
11156:	23A7  CD0902  		CALL	CPLD1
11157:	23AA  EB      		EX	DE,HL		;complement it and fall through to TIMER
11158:			;TIMER is the basic timing loop shared by TIME and DELAY.  After a delay of
11159:			;15*256 cycles it increments the count in HL, looks for a console char, and
11160:			;continues.  Returns Carry set if char typed, reset if HL counts to 0.
11161:	23AB  CDC716  	TIMER:	CALL	REDYC		;look for char
11162:	23AE  D8      		RET	C		;return carry set if char typed
11163:	23AF  AF      		XOR	A
11164:	23B0  3D      	TIME1:	DEC	A
11165:	23B1  C2B023  		JP	NZ,TIME1	;wait a while
11166:	23B4  23      		INC	HL		;increment the count
11167:	23B5  7C      		LD	A,H
11168:	23B6  B5      		OR	L
11169:	23B7  C2AB23  		JP	NZ,TIMER	;keep counting until count hits zero
11170:	23BA  C9      		RET			;return carry reset if counted out
11171:			;DELA1 is called from DELAY to delay for <expr> minutes or seconds
11172:			;by executing TIMER (BC)*(HL) times.
11173:	23BB  CD8F0C  	DELA1:	CALL	GTEXP		;get the argument
11174:	23BE  78      	DELA2:	LD	A,B
11175:	23BF  B1      		OR	C
11176:	23C0  CACC23  		JP	Z,DELA3		;count is zero -- done
11177:	23C3  E5      		PUSH	HL
11178:	23C4  CDAB23  		CALL	TIMER
11179:	23C7  E1      		POP	HL
11180:	23C8  0B      		DEC	BC		;decrement the count
11181:	23C9  C3BE23  		JP	DELA2		;and keep waiting
11182:	23CC  162C    	DELA3:	LD	D,','
11183:	23CE  CD8E18  		CALL	GTD		;look for comma
11184:	23D1  D0      		RET	NC		;comma -- continue with DELAY
11185:	23D2  E1      		POP	HL		;else pop the DELA1 return
11186:	23D3  C9      		RET			;and return from DELAY
11187:				ENDIF			;end of NOT REALT conditional
11188:				ENDIF			;end of NOT CAMAC conditional
11189:			
11190:			;DELETE <line #> [, <line #>]
11191:	FFFF          		IF	EDITC
11192:	0000          		IF	COMPL
11194:				ELSE
11195:	23D4          	DELET:
11196:	0000          		IF	ROMSQ
11198:				ENDIF
11199:	23D4  CD4D19  		CALL	GTLNO		;look for <line #>
11200:	23D7  DA3501  		JP	C,SNERR		;SN error if none
11201:	23DA  CD4137  		CALL	FINDL		;find the line
11202:	23DD  E5      		PUSH	HL
11203:	23DE  F5      		PUSH	AF
11204:	23DF  CD8518  		CALL	GTCND		;look for comma
11205:	23E2  D2EE23  		JP	NC,DELE1	;found comma
11206:	23E5  F1      		POP	AF
11207:	23E6  DA5419  		JP	C,USERR		;US error if not found
11208:	23E9  E1      		POP	HL		;location to HL
11209:	23EA  E5      		PUSH	HL
11210:	23EB  C3FB23  		JP	DELE2
11211:	23EE  F1      	DELE1:	POP	AF
11212:	23EF  CD4D19  		CALL	GTLNO		;look for second <line #>
11213:	23F2  DA3501  		JP	C,SNERR		;SN error if none
11214:	23F5  CD4137  		CALL	FINDL		;find it
11215:	23F8  DAFF23  		JP	C,DELE3		;not found, HL points to next
11216:	23FB  5E      	DELE2:	LD	E,(HL)
11217:	23FC  1600    		LD	D,0		;length to DE
11218:	23FE  19      		ADD	HL,DE		;HL points to next
11219:	23FF  D1      	DELE3:	POP	DE		;first line location to DE
11220:	2400  CD2902  		CALL	CMDHU		;compare
11221:	2403  D0      		RET	NC		;first loc >= second loc, ignore
11222:	2404  E5      		PUSH	HL		;save second loc
11223:	2405  D5      		PUSH	DE		;save first loc
11224:	2406  EB      		EX	DE,HL		;second loc to DE
11225:	2407  CD0802  		CALL	CPLDE		;complemented
11226:	240A  CD1E01  		CALL	IITST		;DELETE illegal indirect
11227:	240D  2ACA3F  		LD	HL,(EOFAD)	;eof address to HL
11228:	2410  19      		ADD	HL,DE
11229:	2411  23      		INC	HL		;eof - second + 1 = byte count to HL
11230:	2412  E3      		EX	(SP),HL		;destination = first loc to HL
11231:	2413  D1      		POP	DE		;count to DE
11232:	2414  C1      		POP	BC		;source = second loc to BC
11233:	2415  CD3637  		CALL	MOVED		;block move remainder of program
11234:	2418  2B      		DEC	HL		;point to new last byte
11235:	2419  C37B27  		JP	NEW1		;reset stacks
11236:				ENDIF
11237:				ELSE
11239:				ENDIF
11240:			
11241:			;DIM <var name> (<expr>[,<expr>]*) [,<var name> (<expr> [,<expr>]*)]*
11242:	241C  CD2D1A  	DIM:	CALL	GTNAM		;look for name
11243:	241F  DA3501  	DIM0:	JP	C,SNERR		;SN error if none
11244:	2422  F5      		PUSH	AF		;save symbol length
11245:	2423  21673E  		LD	HL,BUFAD+MAXNL	;saving address to HL
11246:	2426  CD9F1B  		CALL	CPYS0		;copy var name to save it
11247:	2429  CD5E20  		CALL	STLKU		;look it up
11248:	242C  DA3424  		JP	C,DIMS0
11249:	242F          	DDERR:	ERROR	F, D, D		;fatal DD error if defined already
11250:	2434  1628    	DIMS0:	LD	D,'('
11251:	2436  CDA618  		CALL	GTDSN		;skip (
11252:	2439  F1      		POP	AF
11253:	243A  6F      		LD	L,A		;name length to L
11254:	243B  3A353E  		LD	A,(VARTY)
11255:	243E  67      		LD	H,A		;type token to H
11256:	243F  22543E  		LD	(SAVTP),HL	;and HL saved
11257:	2442  CDAC01  		CALL	BYTSD		;bytes per entry to E, # dims so far to D
11258:	2445  D5      		PUSH	DE		;and saved
11259:	2446  110100  		LD	DE,1		;find # elements in DE
11260:	2447          	INONE	EQU	$-2		;address of integer 1 for FOR step default
11261:	2449  D5      		PUSH	DE
11262:			;DIMS1 is repeated for each dimension of an array.  Each dimension bound
11263:			;is PUSHed, as well as bytes per entry/#dims and #elements thus far.
11264:	244A  D1      	DIMS1:	POP	DE		;# elements to DE
11265:	244B  E1      		POP	HL		;#dims to H, bytes per entry to L
11266:	244C  24      		INC	H		;increment # dims count
11267:	244D  CD8F0C  		CALL	GTEXP		;get dim
11268:	2450  78      		LD	A,B
11269:	2451  B7      		OR	A
11270:	2452  FA9213  		JP	M,FCERF		;fatal FC error if negative
11271:	2455  C5      		PUSH	BC		;and save it
11272:	2456  E5      		PUSH	HL		;save count
11273:	2457  03      		INC	BC		;dim + 1 (to allow subscript 0)
11274:	2458  CD5F12  		CALL	MULBD		;new # elements = BC * DE to HL
11275:	245B  DA4320  		JP	C,OMERR		;too many
11276:	245E  E5      		PUSH	HL		;save # elements
11277:	245F  162C    		LD	D,','
11278:	2461  CD8E18  		CALL	GTD		;look for ,
11279:	2464  D24A24  		JP	NC,DIMS1	;get more dimensions
11280:	2467  1629    		LD	D,')'
11281:	2469  CDA618  		CALL	GTDSN		;skip )
11282:	246C  11673E  		LD	DE,BUFAD+MAXNL
11283:	246F  215F3E  		LD	HL,BUFAD
11284:	2472  CDA21B  		CALL	CPYST		;restore symbol name to BUFAD
11285:			;Now the new symbol table entry for the array is built, containing length
11286:			;byte, type byte, name, #dims, bounds (2 bytes * #dims) and elements.
11287:	2475  D1      		POP	DE		;restore # elements to DE
11288:	2476  C1      		POP	BC		;bytes per entry to C, # dims to B
11289:	0000          		IF	CAMAC
11297:				ENDIF
11298:	2477  68      	DIM1A:	LD	L,B
11299:	2478  2600    		LD	H,0		;now find entry length to build entry
11300:	247A  29      		ADD	HL,HL		;# dims * 2 bytes per dim
11301:	247B  23      		INC	HL		;+ length byte
11302:	247C  23      		INC	HL		;+ type byte
11303:	247D  23      		INC	HL		;+ #dims byte
11304:	247E  79      		LD	A,C		;bytes per entry to A
11305:	247F  19      	DIMS2:	ADD	HL,DE
11306:	2480  DA4320  		JP	C,OMERR		;too big
11307:	2483  3D      		DEC	A
11308:	2484  C27F24  		JP	NZ,DIMS2	;# elements * bytes per entry
11309:	2487  EB      		EX	DE,HL		;length so far to DE
11310:	2488  2A543E  		LD	HL,(SAVTP)
11311:	248B  7C      		LD	A,H		;symbol type token to A
11312:	248C  2600    		LD	H,0		;HL now has name length
11313:	248E  19      		ADD	HL,DE		;entry length in HL
11314:	248F  DA4320  		JP	C,OMERR
11315:	2492  CDF71F  		CALL	STPSH		;build table entry
11316:	2495  70      		LD	(HL),B		;# dims to table
11317:	2496  48      		LD	C,B
11318:	2497  0600    		LD	B,0		;BC now has # dims
11319:	2499  09      		ADD	HL,BC
11320:	249A  09      		ADD	HL,BC
11321:	249B  23      		INC	HL		;HL points past last dim
11322:	0000          		IF	CAMAC
11331:				ENDIF
11332:	249C  D1      	DIMS3:	POP	DE		;dim to DE
11333:	249D  CDF301  		CALL	MVMDE		;and then to table
11334:	24A0  0D      		DEC	C		;count down dims
11335:	24A1  C29C24  		JP	NZ,DIMS3
11336:	24A4  CD8518  		CALL	GTCND		;look for comma
11337:	24A7  D21C24  		JP	NC,DIM		;dimension another
11338:	24AA  C9      		RET
11339:			
11340:			;DISABLE [<line #>]
11341:	FFFF          		IF	NOT WILD
11342:	24AB  CD4D19  	DSABL:	CALL	GTLNO		;line # to DE, carry set if none
11343:	24AE  21ED3C  		LD	HL,INTAD
11344:	24B1  3AEC3C  		LD	A,(INTTC)
11345:	24B4  D2C924  		JP	NC,DSAB2	;line # present
11346:	24B7  32503E  		LD	(TEMP),A	;save old # entries
11347:	24BA  AF      		XOR	A
11348:	24BB  32EC3C  		LD	(INTTC),A	;set entry count to 0
11349:	24BE  77      		LD	(HL),A		;store table eof
11350:	24BF  3A503E  	DSAB1:	LD	A,(TEMP)
11351:	24C2  B7      		OR	A		;check if any disabled
11352:	24C3  C0      		RET	NZ
11353:	24C4          	ENERR:	ERROR	F, E, N		;fatal EN error
11354:	24C9  AF      	DSAB2:	XOR	A
11355:	24CA  32503E  		LD	(TEMP),A	;set flag to tell if any disabled
11356:	24CD  7E      	DSAB3:	LD	A,(HL)
11357:	24CE  B7      		OR	A		;check current entry type byte
11358:	24CF  CABF24  		JP	Z,DSAB1		;eof
11359:	24D2  E5      		PUSH	HL		;save current addr
11360:	24D3  010800  		LD	BC,8
11361:	24D6  09      		ADD	HL,BC
11362:	24D7  E5      		PUSH	HL		;save next addr
11363:	24D8  2B      		DEC	HL
11364:	24D9  46      		LD	B,(HL)
11365:	24DA  2B      		DEC	HL
11366:	24DB  4E      		LD	C,(HL)		;ENABLE line # to BC
11367:	24DC  CD2302  		CALL	CMBDU		;compare to desire line #
11368:	24DF  CAE724  		JP	Z,DSAB4		;match -- purge it
11369:	24E2  E1      		POP	HL
11370:	24E3  C1      		POP	BC
11371:	24E4  C3CD24  		JP	DSAB3		;no match -- try next
11372:	24E7  C1      	DSAB4:	POP	BC		;next to BC -- source
11373:	24E8  E1      		POP	HL		;current to HL -- destination
11374:	24E9  C5      		PUSH	BC		;save next
11375:	24EA  D5      		PUSH	DE		;save line #
11376:	24EB  50      		LD	D,B
11377:	24EC  59      		LD	E,C		;current to DE
11378:	24ED  E5      		PUSH	HL		;save destination
11379:	24EE  212E3D  		LD	HL,INTAD+INTTL	;last location + 1 to HL
11380:	24F1  CD0802  		CALL	CPLDE		;- current to DE
11381:	24F4  19      		ADD	HL,DE		;count to HL
11382:	24F5  EB      		EX	DE,HL		;then to DE
11383:	24F6  E1      		POP	HL		;restore destination
11384:	24F7  CD3637  		CALL	MOVED		;move remainder of table
11385:	24FA  21EC3C  		LD	HL,INTTC	;address table count
11386:	24FD  7E      		LD	A,(HL)		;fetch count
11387:	24FE  32503E  		LD	(TEMP),A	;set flag to true (nonzero)
11388:	2501  35      		DEC	(HL)		;update count
11389:	2502  D1      		POP	DE		;restore line #
11390:	2503  E1      		POP	HL		;next to HL
11391:	2504  C3CD24  		JP	DSAB3		;keep trying
11392:				ENDIF			;end of NOT WILD conditional
11393:			
11394:			;EDIT [<line #>]
11395:	FFFF          		IF	EDITC
11396:	0000          		IF	COMPL
11398:				ELSE
11399:	2507          	EDIT:
11400:	0000          		IF	ROMSQ
11402:				ENDIF
11403:	2507  CD4D19  		CALL	GTLNO		;look for <line #>
11404:	250A  D21125  		JP	NC,EDIT0
11405:	250D  2AE43C  		LD	HL,(ERRLN)	;edit most recent error line if none
11406:	2510  EB      		EX	DE,HL		;to DE
11407:	2511  CD1E01  	EDIT0:	CALL	IITST		;EDIT illegal indirect
11408:	2514  CD6337  		CALL	FDLNO		;find the line
11409:	2517  23      		INC	HL
11410:	2518  4E      		LD	C,(HL)
11411:	2519  23      		INC	HL
11412:	251A  46      		LD	B,(HL)		;line number to BC
11413:	251B  23      		INC	HL
11414:	251C  23      		INC	HL
11415:	251D  E5      		PUSH	HL		;save pointer to first byte of line
11416:	251E  AF      		XOR	A
11417:	251F  CD3A17  		CALL	CVTIS		;convert line number to string
11418:	2522  F5      		PUSH	AF		;save length
11419:	2523  CD2314  		CALL	BCDE		;string loc to BC, length to E
11420:	2526  21C33E  		LD	HL,NLNAD	;destination to HL
11421:	2529  CD3437  		CALL	MOVD0		;copy line number string to input buffer
11422:	252C  EB      		EX	DE,HL		;next input buffer location to DE
11423:	252D  F1      		POP	AF
11424:	252E  2F      		CPL			;-length-1
11425:	252F  C654    		ADD	A,NLMAX+4	;max # chars + 3 - length
11426:	2531  4F      		LD	C,A		;to C to avoid line overflow
11427:	2532  3E20    		LD	A,' '
11428:	2534  E1      		POP	HL		;first char address to HL
11429:	2535  E5      		PUSH	HL
11430:	2536  BE      		CP	(HL)		;check if first char of line is <space>
11431:	2537  C46D25  		CALL	NZ,EDIT4	;add a space if not
11432:	253A  E1      	EDIT2:	POP	HL		;line pointer to HL
11433:	253B  7E      		LD	A,(HL)		;fetch next char or token in line
11434:	253C  23      		INC	HL
11435:	253D  E5      		PUSH	HL		;and save pointer to next
11436:	253E  CDCE1F  		CALL	FNDTK		;check if char or token
11437:	2541  DA5E25  		JP	C,EDIT3		;token
11438:	2544  CD6D25  		CALL	EDIT4		;store the char
11439:	2547  FE0D    		CP	CR		;check if cr
11440:	2549  C23A25  		JP	NZ,EDIT2	;no, continue
11441:	254C  31353E  		LD	SP,STACK	;reset SP in case direct line results
11442:	254F  CD7134  		CALL	LEDIT		;edit the line
11443:	2552  CDA735  		CALL	TKIZE		;tokenize the line
11444:	2555  DABC07  		JP	C,XSTA1		;execute if no line number
11445:	2558  C4A436  		CALL	NZ,ADDLN	;add line to current source
11446:	255B  C33D07  		JP	DMOD2		;and return to OK prompt
11447:	255E  7E      	EDIT3:	LD	A,(HL)		;fetch char of token
11448:	255F  E67F    		AND	7FH		;mask off possible high bit
11449:	2561  CD6D25  		CALL	EDIT4		;store the char
11450:	2564  7E      		LD	A,(HL)		;refetch
11451:	2565  23      		INC	HL
11452:	2566  B7      		OR	A
11453:	2567  F25E25  		JP	P,EDIT3		;not end of token, get next char
11454:	256A  C33A25  		JP	EDIT2		;end of token, get next char of line
11455:	256D  12      	EDIT4:	LD	(DE),A		;store the char
11456:	256E  13      		INC	DE		;point to next location
11457:	256F  0D      		DEC	C		;decrement remaining char count
11458:	2570  C0      		RET	NZ		;return if enough room
11459:	2571  3E0D    		LD	A,CR		;too little room in buffer, EX error
11460:	2573  32C33E  		LD	(NLNAD),A	;cr to input buffer
11461:	2576  C33A01  		JP	EXERR		;and issue EX error
11462:				ENDIF
11463:				ELSE
11465:				ENDIF
11466:			
11467:			;ENABLE <line #> , <byte expr> , <byte expr> [, <byte expr>] [,$]
11468:	FFFF          		IF	NOT WILD
11469:	2579  CD1501  	ENABL:	CALL	IDTST		;ENABLE illegal direct
11470:	257C  C5      		PUSH	BC		;save current line #
11471:	257D  CD4D19  		CALL	GTLNO
11472:	2580  D5      		PUSH	DE		;save subroutine line #
11473:	2581  162C    		LD	D,','
11474:	2583  CDA618  		CALL	GTDSN		;skip comma
11475:	2586  CD6104  		CALL	IINFO		;get interrupt info
11476:	2589  D5      		PUSH	DE
11477:	258A  C5      		PUSH	BC		;and save it
11478:	258B  21EC3C  		LD	HL,INTTC
11479:	258E  7E      		LD	A,(HL)		;# entries to A
11480:	258F  FE08    		CP	INTTN		;compared to max
11481:	2591  D2C424  		JP	NC,ENERR	;too many -- EN error
11482:	2594  34      		INC	(HL)		;store new # entries
11483:	2595  B7      		OR	A
11484:	2596  17      		RLA
11485:	2597  17      		RLA
11486:	2598  17      		RLA			;*8 bytes per entry
11487:	2599  21EC3C  		LD	HL,INTAD-1
11488:	259C  CD1502  		CALL	ADAHL		;+ address - 1 = address of new entry - 1
11489:	259F  3E04    		LD	A,4
11490:	25A1  D1      	ENAB1:	POP	DE
11491:	25A2  CD5022  		CALL	MOMDE		;two bytes to entry
11492:	25A5  3D      		DEC	A		;four times
11493:	25A6  C2A125  		JP	NZ,ENAB1
11494:	25A9  23      		INC	HL
11495:	25AA  3600    		LD	(HL),0		;and new eof
11496:	25AC  C9      		RET
11497:				ENDIF			;end of NOT WILD conditional
11498:			
11499:			;END
11500:	25AD          	ENDCM:
11501:	FFFF          		IF	SDISK AND (NOT RTPAK)
11502:	25AD  CD2B1C  		CALL	CLOSN		;close any OPEN files
11503:				ENDIF
11504:	0000          		IF	CAMAC AND FALSE	;Northstar version
11506:				ENDIF
11507:	25B0          	ENDC1:
11508:	0000          		IF	COMPL		;ERROR entry point
11510:				ELSE
11511:	25B0  3E65    		LD	A,CSBRK		;break token to A
11512:	25B2  C3972B  		JP	STOP2		;save break info and return to dmode
11513:				ENDIF
11514:			
11515:			;EXEC [<expr> [,G] ]
11516:	0000          		IF	ROMSQ
11560:				ELSE
11561:	013A          	EXEC	EQU	EXERR		;EX error in non-ROMSQ versions
11562:				ENDIF			;end of ROMSQ conditional
11563:			
11564:			
11565:			;end of STATES1
11567:			;STATES2 05/21/81
11568:			;XYBASIC Interpreter Source Module
11569:			;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
11570:			;statement routines for statements FOR through NULL
11571:			
11572:			
11573:			;FOR <var name> = <expr> TO <expr> [STEP <expr>]
11574:	25B5  CD4D01  	FOR:	CALL	GTLHS		;get destination for ASIGN
11575:	FFFF          		IF	STRNG
11576:	25B8  FE03    		CP	STRST
11577:	25BA  CA3501  		JP	Z,SNERR		;SN error if FOR <string var>
11578:				ENDIF
11579:	25BD  214724  		LD	HL,INONE	;integer 1 addr to HL
11580:	FFFF          		IF	FLOAT
11581:	25C0  FE02    		CP	SNGST
11582:	25C2  C2C825  		JP	NZ,FOR1		;integer FOR
11583:	25C5  21A20C  		LD	HL,FPONE	;floating 1. addr to HL
11584:				ENDIF
11585:			;At FOR1 the FOR var addr is in LHSAD, the default incr pointer in HL.
11586:			;The CSTACK is examined for a previous FOR entry with the same variable,
11587:			;and the entry is flushed if found.
11588:	25C8  E5      	FOR1:	PUSH	HL		;save default incr pointer
11589:	25C9  014F4F  		LD	BC,(CSFOR SHL 8) OR CSFOR
11590:	25CC  2A593E  		LD	HL,(CSTKP)	;set BC, HL for CSDIG
11591:	25CF  CD1021  	FOR1A:	CALL	CSDI1		;look for old FOR entry
11592:	25D2  DAF225  		JP	C,FOR2		;not found
11593:	25D5  E5      		PUSH	HL		;save current entry addr
11594:	25D6  7E      		LD	A,(HL)
11595:	25D7  E61F    		AND	1FH
11596:	25D9  CD1C02  		CALL	SBAHL		;address next CSTACK entry
11597:	25DC  E3      		EX	(SP),HL		;save next addr, current addr to HL
11598:	25DD  11FBFF  		LD	DE,-5
11599:	25E0  19      		ADD	HL,DE		;address var addr bytes
11600:	25E1  CDEE01  		CALL	MVDEM		;fetch FOR entry var addr to DE
11601:	25E4  2A573E  		LD	HL,(LHSAD)	;FOR var addr to HL
11602:	25E7  CD2902  		CALL	CMDHU		;check if same variable
11603:	25EA  E1      		POP	HL		;next entry addr to HL
11604:	25EB  C2CF25  		JP	NZ,FOR1A	;no match, try next
11605:	25EE  78      		LD	A,B		;match, entry type to A
11606:	25EF  CD1F21  		CALL	CSRST		;and purge the entry
11607:			;FOR2 builds a new CSTACK FOR entry.  The entry consists of a type/length byte
11608:			;(1 byte), line # address, return textp and variable address (2 bytes each),
11609:			;and bound and increment values (2 or 4 bytes each).  After CPUSH allocates
11610:			;space for the entry, the CSTACK pointer is reset to ignore the protoentry
11611:			;in case FOR aborts, e.g. with a SN error.  Another CPUSH completes the entry.
11612:	25F2  78      	FOR2:	LD	A,B
11613:	25F3  CDAE20  		CALL	CPUSH		;allocate new CSTACK FOR entry
11614:	25F6  EB      		EX	DE,HL
11615:	FFFF          		IF	NOT COMPL
11616:	25F7  CD0601  		CALL	LINBC
11617:	25FA  CC4321  		CALL	Z,DCSTD		;unincrement CSTACK direct count if direct
11618:				ENDIF
11619:	25FD  2A573E  		LD	HL,(LHSAD)
11620:	2600  EB      		EX	DE,HL
11621:	2601  CDF301  		CALL	MVMDE		;variable addr to entry
11622:	2604  3E09    		LD	A,2*FBYTS+1	;skip two values
11623:	2606  CD1C02  		CALL	SBAHL		;address next CSTACK entry
11624:	2609  22593E  		LD	(CSTKP),HL	;reset CSTACK in case SN error in FOR
11625:	260C  23      		INC	HL		;address bottom of new FOR entry
11626:	260D  E5      		PUSH	HL		;and save pointer for bound/incr insertion
11627:	260E  CD3027  		CALL	LET1		;get initial value and assign to var
11628:	2611  160F    		LD	D,TOT
11629:	2613  CDA618  		CALL	GTDSN		;skip TO token
11630:	2616  CDC50B  		CALL	EVALT		;get bound of desired type
11631:	2619  23      		INC	HL		;point to bound value
11632:	261A  E3      		EX	(SP),HL		;FOR entry pointer to HL
11633:	261B  C1      		POP	BC		;bound pointer to BC
11634:	261C  CD3237  		CALL	MOVEB		;copy bound to entry
11635:	261F  E3      		EX	(SP),HL		;save entry addr for increment
11636:	2620  E5      		PUSH	HL		;and default incr
11637:	2621  1610    		LD	D,STEPT
11638:	2623  CD8E18  		CALL	GTD		;look for STEP
11639:	2626  E1      		POP	HL		;default increment pointer to HL
11640:	2627  DA2E26  		JP	C,FOR2A		;no STEP, take default value
11641:	262A  CDC50B  		CALL	EVALT		;get increment value
11642:	262D  23      		INC	HL		;and point to value
11643:	262E  E3      	FOR2A:	EX	(SP),HL		;entry pointer to HL
11644:	262F  C1      		POP	BC		;incr pointer to BC
11645:	FFFF          		IF	FOR0
11646:	2630  E5      		PUSH	HL		;save pointer to incr for FOR0 test
11647:				ENDIF
11648:	2631  CD3237  		CALL	MOVEB		;copy increment to entry and return
11649:	2634  3E4F    		LD	A,CSFOR
11650:	0000          		IF	NOT FOR0
11652:				ELSE
11653:	2636  CDAE20  		CALL	CPUSH
11654:			;must now check for vacuous condition (e.g. FOR I=1 TO 0) in FOR0 version
11655:	2639  2A573E  		LD	HL,(LHSAD)
11656:	FFFF          		IF	FLOAT
11657:	263C  3A563E  		LD	A,(LHSTY)
11658:	263F  FE02    		CP	SNGST
11659:	0000          		IF	F9511
11661:				ELSE
11662:	2641  CCDD0E  		CALL	Z,FLOAD		;load floating value to FACC
11663:				ENDIF
11664:				ENDIF
11665:	2644  4E      		LD	C,(HL)
11666:	2645  23      		INC	HL
11667:	2646  46      		LD	B,(HL)		;fetch integer value to BC
11668:	2647  D1      		POP	DE		;incr pointer to DE
11669:	2648  21FCFF  		LD	HL,-FBYTS
11670:	264B  19      		ADD	HL,DE		;bound pointer to HL
11671:	264C  CD5002  		CALL	BDTST		;test FOR condition
11672:	264F  D0      		RET	NC		;ok, just return
11673:	2650  2A593E  		LD	HL,(CSTKP)
11674:	2653  CD3B28  		CALL	NEXT6		;purge the CSTACK entry just built
11675:	2656  CD3101  		CALL	EOS
11676:	2659  068B    		LD	B,NEXTT
11677:	265B  CD7402  		CALL	FNDST		;find matching NEXT
11678:	265E  D24B28  		JP	NC,NEXT7	;look for following comma, return or do another
11679:	2661          		ERROR	F, F, R		;not found, fatal FR error
11680:				ENDIF
11681:			
11682:			;GOSUB <line #>
11683:	2666  CD6F26  	GOSUB:	CALL	GOTO		;find new textp and lnnum
11684:	2669  3E25    	GOSU1:	LD	A,CSGOS		;ON entry point
11685:	266B  C5      		PUSH	BC		;save return text pointer
11686:	266C  C3B220  		JP	CPSH1		;build control stack entry and return
11687:			
11688:			;GOTO <line #>
11689:			;GOTO is called by GOSUB to read a line #, look for it and
11690:			;check for end of statement garbage.  Branches to US error if illegal
11691:			;or no such line #, otherwise:
11692:			;Retn:	A	clobbered
11693:			;	BC	return text pointer, i.e. delimiter address
11694:			;	DE	line #
11695:			;	HL	address of <cr> preceding desired line in text
11696:			;	(textp)	same as HL
11697:	266F  CD4D19  	GOTO:	CALL	GTLNO		;line # to DE
11698:	2672  DA3501  		JP	C,SNERR		;no line #
11699:	2675  CD3101  	GOTO1:	CALL	EOS		;end of statement test -- IF entry point
11700:	2678  CD6337  	GOTO2:	CALL	FDLNO		;find line # -- interrupt, ON entry point
11701:	267B  C36B18  		JP	BAKUP		;back up textp and return
11702:			
11703:			;IF <expr> THEN {<line #> | <statement>}
11704:	267E  CD8F0C  	IFCOM:	CALL	GTEXP		;evaluate the IF expression
11705:	2681  160E    		LD	D,THENT
11706:	2683  CDA618  		CALL	GTDSN		;skip THEN token
11707:	2686  78      		LD	A,B
11708:	2687  B1      		OR	C
11709:	2688  CAF129  		JP	Z,REM		;false -- scan to cr and return
11710:	268B  CD4D19  		CALL	GTLNO		;look for line #
11711:	268E  DAC007  		JP	C,XSTA2		;none -- execute <statement> THENpart
11712:	2691  C37526  		JP	GOTO1		;GOTO line # and return
11713:			
11714:			;INPUT [<quoted string>] [;] <var list>
11715:			;INPUT @<expr>, <var list>	[in SDISK versions]
11716:			;INPUT @ <var list>		[in PACKI versions]
11717:			;INPUT must scan two lines, the command line INPUT <varlist> and the line
11718:			;of data typed by the user.  The two text pointers are kept in TEXTP
11719:			;and TXTP2, and exchanged by FLIP.  The original <varlist> TEXTP
11720:			;is also PUSHed, to be available when REDOing.  If the data is of
11721:			;incorrect type or there are fewer data than variables, REDO.  If there are
11722:			;fewer variables than data, EXCESS IGNORED.
11723:			;DINP0 is in module SDISK.
11724:			;PAINP is in module PACKARD.
11725:	2694  CD1501  	INPUT:	CALL	IDTST		;INPUT illegal direct mode
11726:	FFFF          		IF	SDISK
11727:	2697  CDA61F  		CALL	GTSFN		;look for disk file specification
11728:	269A  D27C1C  		JP	NC,DINP0	;disk INPUT
11729:				ENDIF			;end of SDISK conditional
11730:	0000          		IF	PACKI
11734:				ENDIF
11735:	269D  AF      		XOR	A
11736:	269E  32EB3C  		LD	(OMODE),A	;turn on output mode
11737:	26A1  1622    		LD	D,'"'
11738:	26A3  CD8E18  		CALL	GTD		;look for quoted string
11739:	26A6  D47629  		CALL	NC,PRQUO	;print it if present
11740:	26A9  163B    		LD	D,SEMIC
11741:	26AB  CD8E18  		CALL	GTD		;look for ; and ignore if present
11742:			;INPU1 sets up pointers, and is entry point for retries after REDO message.
11743:	26AE  E5      	INPU1:	PUSH	HL		;save textp to redo
11744:	26AF  22523E  		LD	(TXTP2),HL	;save textp to scan varlist
11745:	26B2  3E3F    		LD	A,'?'
11746:	26B4  CD1F16  		CALL	WRITC		;write a ?
11747:	26B7  CD1D16  		CALL	WRTSP		;and a space
11748:	26BA  2A543E  		LD	HL,(SAVTP)
11749:	26BD  22C63F  		LD	(TEXTP),HL	;reset text pointer in case ^C typed
11750:	26C0  CDB433  		CALL	GTLIN		;get input line
11751:	26C3  CD3702  		CALL	FLIP		;to scan varlist
11752:			;INPU2 gets the next variable and checks its type (string or nonstring).
11753:	26C6  CD4D01  	INPU2:	CALL	GTLHS		;get destination
11754:	26C9  CD3702  		CALL	FLIP		;to scan data
11755:	FFFF          		IF	STRNG
11756:	26CC  FE03    		CP	STRST
11757:	26CE  C2DA26  		JP	NZ,INPU3	;nonstring variable
11758:	26D1  CDAE2D  		CALL	EVUNQ		;get string value, perhaps unquoted
11759:	26D4  DA1B27  		JP	C,INPU7		;no string, REDO
11760:	26D7  C3E526  		JP	INPU4		;assign string value to destination
11761:				ENDIF
11762:			;INPU3 gets a nonstring value.
11763:	26DA  CD5919  	INPU3:	CALL	GTLIT		;get value
11764:	26DD  DA1B27  		JP	C,INPU7		;REDO if none
11765:	FFFF          		IF	STRNG
11766:	26E0  FE03    		CP	STRST		;check if string value
11767:	26E2  CA1B27  		JP	Z,INPU7		;REDO if so
11768:				ENDIF
11769:			;INPU4 assigns a value to the destination variable.
11770:	26E5  CD6501  	INPU4:	CALL	ASIGV		;assign value to destination
11771:	26E8  CD8518  		CALL	GTCND		;look for comma not followed by delimiter
11772:	26EB  DA0C27  		JP	C,INPU6		;no more data or bad item
11773:	26EE  CD3702  		CALL	FLIP		;to scan varlist
11774:	26F1  CD7C18  		CALL	GTCOM		;look for comma
11775:	26F4  D2C626  		JP	NC,INPU2	;continue with next var in varlist
11776:	26F7  CDD917  		CALL	PRNTM		;else print EXCESS IGNORED
11777:	26FA  45584345		DEFB	'EXCESS IGNORED', CR, LF OR 80H
	      53532049
	      474E4F52
	      45440D8A
11778:			;INPU5 is the exit from a successful INPUT.
11779:	270A  E1      	INPU5:	POP	HL		;pop REDO pointer
11780:	270B  C9      		RET			;and done
11781:	270C  CD3F01  	INPU6:	CALL	DTST0		;check if delimiter
11782:	270F  DA1B27  		JP	C,INPU7		;no, REDO
11783:	2712  CD3702  		CALL	FLIP		;else scan varlist
11784:	2715  CD7C18  		CALL	GTCOM		;see if more vars
11785:	2718  DA0A27  		JP	C,INPU5		;no, done
11786:			;INPU7 prints REDO message and retries after bad data.
11787:	271B  CDD917  	INPU7:	CALL	PRNTM		;more vars than data, print REDO message
11788:	271E  524544CF		DEFB	'RED', 'O' OR 80H
11789:	2722  E1      		POP	HL
11790:	2723  C3AE26  		JP	INPU1		;reset varlist pointer and try again
11791:			
11792:			;[LET] <var ref> = <expr>
11793:	2726  CD6B18  	LET0:	CALL	BAKUP		;back up textp to get current char again
11794:	2729  CD4201  		CALL	DTEST		;test if delimiter
11795:	272C  D0      		RET	NC		;null statement
11796:	272D          	LET:
11797:	0000          		IF	CAMAC
11800:				ENDIF
11801:	0000          		IF	WILD
11805:				ENDIF
11806:	272D  CD4D01  		CALL	GTLHS		;get destination for ASSGN
11807:	2730  CDB218  	LET1:	CALL	GTEQU		;skip = token -- FOR entry point
11808:	2733  CD770C  		CALL	EVALS		;evaluate the rhs
11809:	2736  C36C01  		JP	ASIGN		;and assign rhs to lhs
11810:			;letcv is in module CAMAC
11811:			
11812:			;LIST [<line #>] [, <line #>]
11813:	0000          		IF	COMPL
11815:				ELSE
11816:	2739  CD4D19  	LISTM:	CALL	GTLNO		;min line # to DE, 0 if none
11817:	273C  CD4137  		CALL	FINDL		;look for it
11818:	273F  E5      		PUSH	HL		;save min line length byte address
11819:	2740  CD7C18  		CALL	GTCOM		;skip the comma, if any
11820:	2743  CD4D19  		CALL	GTLNO		;max line # to DE, 0 if none
11821:	2746  DC0902  		CALL	C,CPLD1		;complement to give default max = 0FFFFH
11822:	2749  CD3101  		CALL	EOS		;check for garbage
11823:	274C  42      		LD	B,D
11824:	274D  4B      		LD	C,E		;max to BC
11825:	274E  E1      		POP	HL		;min length byte address to HL
11826:	274F  7E      	LIST1:	LD	A,(HL)		;fetch length byte
11827:	2750  B7      		OR	A
11828:	2751  C8      		RET	Z		;eof -- done
11829:	2752  23      		INC	HL
11830:	2753  5E      		LD	E,(HL)
11831:	2754  23      		INC	HL
11832:	2755  56      		LD	D,(HL)		;line # of current line to DE
11833:	2756  CD2302  		CALL	CMBDU		;compare unsigned to max
11834:	2759  D8      		RET	C		;max < (DE) -- return
11835:	275A  2B      		DEC	HL		;point to line #
11836:	275B  CDD116  		CALL	CTEST		;look for break char
11837:	275E  CD8D17  		CALL	PRNTL		;print the line
11838:	2761  CD7516  		CALL	WCRLF		;and crlf
11839:	2764  C34F27  		JP	LIST1		;and try next
11840:				ENDIF			;end of NOT COMPL conditional
11841:			
11842:			;LOAD is in section STATES4.
11843:			
11844:			;MOVE {TO | FROM} <expr>
11845:			;MOVE performs a block move of a ROMSQ version user program TO or FROM RAM.
11846:			;The specified location must not overlap either BASIC or user RAM.
11847:	0000          		IF	ROMSQ AND (NOT WILD)
11946:				ELSE
11947:	013A          	MOVE	EQU	EXERR		;EX error in non-ROMSQ versions
11948:				ENDIF			;end of ROMSQ conditional
11949:			
11950:			;NEW
11951:	0000          		IF	COMPL
11953:				ELSE
11954:	2767          	NEWCM:
11955:	0000          		IF	ROMSQ
11957:				ENDIF
11958:	2767  CD1E01  		CALL	IITST		;NEW is illegal indirect
11959:	FFFF          		IF	SDISK
11960:	276A  CD2B1C  		CALL	CLOSN		;close any OPEN files
11961:				ENDIF
11962:	276D  CDA022  	NEW:	CALL	CLEA1		;clear symbol table -- LOAD, init entry point
11963:	2770  AF      		XOR	A
11964:	2771  32E73C  		LD	(TRACE),A	;traceoff
11965:	2774  32E63C  		LD	(TRAP),A	;trapon
11966:	2777  21CF3F  		LD	HL,SRCAD
11967:	277A  77      		LD	(HL),A		;source text empty
11968:	277B  E5      	NEW1:	PUSH	HL		;ADDLN, DMODX, MOVE FROM entry point
11969:	277C  CD8220  		CALL	STZAP		;reset BREAK and FN symbol table entries
11970:	277F  CDD62A  		CALL	RSTOR		;restore the READ pointer
11971:	FFFF          		IF	NOT WILD
11972:	2782  CD5904  		CALL	DISAB		;disable interrupts
11973:				ENDIF
11974:	2785  E1      		POP	HL
11975:	2786  22CA3F  		LD	(EOFAD),HL	;set eof address -- LOAD entry point
11976:				ENDIF			;end of NOT COMPL conditional
11977:	2789  22593E  	CSPST:	LD	(CSTKP),HL	;clear control stack -- call to reset it
11978:	278C  225B3E  		LD	(ESTKP),HL	;reset expr stack pointer
11979:	278F  C9      		RET
11980:			
11981:			;NEXT [<var name> [, <var name>]* ]
11982:			;First the most recent CSTACK FOR entry is found.
11983:	2790  014F4F  	NEXT:	LD	BC,(CSFOR SHL 8) OR CSFOR
11984:	2793  CD0D21  		CALL	CSDIG		;look for CSTACK FOR entry
11985:	2796  DA5228  		JP	C,NFERR		;not found -- fatal NF error
11986:	2799  E5      		PUSH	HL		;save FOR entry address
11987:	279A  11FBFF  		LD	DE,-5
11988:	279D  19      		ADD	HL,DE		;point to var address bytes
11989:	279E  46      		LD	B,(HL)
11990:	279F  2B      		DEC	HL
11991:	27A0  4E      		LD	C,(HL)		;fetch var addr to BC
11992:	27A1  E5      		PUSH	HL		;and save var addr pointer
11993:	27A2  2AC63F  		LD	HL,(TEXTP)
11994:	27A5  22543E  		LD	(SAVTP),HL	;save TEXTP in case retry necessary
11995:	27A8  C5      		PUSH	BC
11996:	27A9  CD861A  		CALL	FDVAR		;look for var name after NEXT
11997:	27AC  23      		INC	HL
11998:	27AD  C1      		POP	BC
11999:	27AE  DACE27  		JP	C,NEXT1		;no name
12000:			;NEXT <var name> specified, so the FOR <var name> is compared to it.
12001:	27B1  EB      		EX	DE,HL		;NEXT var addr DE, type addr HL
12002:	27B2  CD2302  		CALL	CMBDU		;compare FOR and NEXT <var name>s
12003:	27B5  CADD27  		JP	Z,NEXT3		;FOR and NEXT <var name>s match
12004:			;<var name>s do not match, so CSTACK FOR entry is poped.
12005:	27B8  2A543E  		LD	HL,(SAVTP)
12006:	27BB  22C63F  		LD	(TEXTP),HL	;restore textp to get var name again
12007:	27BE  E1      		POP	HL
12008:	27BF  E1      		POP	HL		;FOR entry address to HL
12009:	27C0  7E      		LD	A,(HL)		;type/length byte to  A
12010:	27C1  47      		LD	B,A		;saved in B
12011:	27C2  E61F    		AND	1FH		;mask to length
12012:	27C4  CD1C02  		CALL	SBAHL		;address next entry
12013:	27C7  78      		LD	A,B		;type/length restored
12014:	27C8  CD1F21  		CALL	CSRST		;purge the FOR entry from CSTACK
12015:	27CB  C39027  		JP	NEXT		;and try again
12016:			;When no <var name> is specified after NEXT, the last CSTACK FOR entry
12017:			;<var name> is assumed.  The type byte must be found for correct tracing.
12018:	27CE  2A5D3E  	NEXT1:	LD	HL,(SYMTA)
12019:	27D1  CD4820  	NEXT2:	CALL	STNXT		;address next symbol table entry
12020:	27D4  EB      		EX	DE,HL
12021:	27D5  CD2302  		CALL	CMBDU		;compare to desired value addr
12022:	27D8  EB      		EX	DE,HL
12023:	27D9  D2D127  		JP	NC,NEXT2	;var addr >= next entry, try another
12024:	27DC  EB      		EX	DE,HL		;type byte addr to HL
12025:			;At NEXT3 the desired <var name> is known.  The stack contains the FOR entry
12026:			;addr and the FOR entry var addr, BC contains the var addr, and HL
12027:			;contains the type byte pointer for the specified <var name>.
12028:			;The trace info [<line #>]<var name> is printed if desired.
12029:	27DD          	NEXT3:
12030:	FFFF          		IF	FLOAT
12031:	27DD  7E      		LD	A,(HL)
12032:	27DE  E61F    		AND	1FH		;mask to type
12033:	27E0  32563E  		LD	(LHSTY),A	;save destination type
12034:				ENDIF
12035:	FFFF          		IF	NOT COMPL
12036:	27E3  3AE73C  		LD	A,(TRACE)
12037:	27E6  B6      		OR	(HL)		;sign set iff tracing
12038:	27E7  32E93C  		LD	(VTRAC),A	;set VTRAC for ASSGN
12039:	27EA  23      		INC	HL		;point to name
12040:	27EB  F2F427  		JP	P,NEXT4		;no tracing desired
12041:	27EE  CD5708  		CALL	BPRNT		;print trace line #
12042:	27F1  CDC217  		CALL	PRTST		;print var name
12043:				ENDIF
12044:			;At NEXT4 the bound & incr pointers are found in preparation for incrementing,
12045:			;and the old value is replace by value+increment.
12046:	27F4  E1      	NEXT4:	POP	HL		;FOR entry var addr pointer to HL
12047:	27F5  11FCFF  		LD	DE,-FBYTS
12048:	27F8  19      		ADD	HL,DE
12049:	27F9  E5      		PUSH	HL		;save incr pointer
12050:	27FA  E5      		PUSH	HL
12051:	27FB  19      		ADD	HL,DE
12052:	27FC  E3      		EX	(SP),HL		;save bound pointer, incr pointer to HL
12053:	27FD  C5      		PUSH	BC		;and save var addr
12054:	FFFF          		IF	FLOAT
12055:	27FE  3A563E  		LD	A,(LHSTY)
12056:	2801  FE01    		CP	INTST
12057:	2803  CA2028  		JP	Z,NXT4I		;integer FOR
12058:			;Now floating value is replaced by old value plus increment.
12059:	2806  C5      		PUSH	BC
12060:	0000          		IF	F9511
12068:				ELSE
12069:	2807  E3      		EX	(SP),HL		;save incr address, var address to HL
12070:	2808  CDDD0E  		CALL	FLOAD
12071:	280B  E1      		POP	HL		;incr address to HL
12072:	0000          		IF	FPBCD
12074:				ELSE
12075:	280C  CDDE11  		CALL	FINCR		;instead of CALL FADD
12076:	280F  CD0713  		CALL	ETEST		;perform significance test
12077:				ENDIF
12078:				ENDIF
12079:	2812  E1      		POP	HL		;restore var addr
12080:	0000          		IF	COMPL
12086:				ELSE			;NOT COMPL
12087:	2813  E5      		PUSH	HL
12088:	0000          		IF	F9511
12090:				ELSE
12091:	2814  CDB00E  		CALL	FSTOR		;result to var addr
12092:				ENDIF
12093:	2817  E1      		POP	HL		;restore var addr for tracing
12094:	2818  0602    		LD	B,SNGST		;type to B
12095:	281A  CD8701  		CALL	TRVAL		;print trace info if desired
12096:				ENDIF
12097:	281D  C33228  		JP	NEXT5
12098:				ENDIF
12099:			;Integer value is replaced by old value plus increment.
12100:	2820  4E      	NXT4I:	LD	C,(HL)
12101:	2821  23      		INC	HL
12102:	2822  46      		LD	B,(HL)		;incr to BC
12103:	2823  E1      		POP	HL
12104:	2824  5E      		LD	E,(HL)
12105:	2825  23      		INC	HL
12106:	2826  56      		LD	D,(HL)		;value to DE
12107:	2827  E5      		PUSH	HL
12108:	2828  CD2C14  		CALL	IADD		;integer add incr+value
12109:	282B  DCEB19  		CALL	C,IOVER		;overflow, nonfatal OV error
12110:	282E  E1      		POP	HL
12111:	282F  CDA101  		CALL	ASIGI		;assign and print trace info if desired
12112:			;At NEXT5 the bound is compared to the value to test for loop termination.
12113:	2832  E1      	NEXT5:	POP	HL		;bound pointer to HL
12114:	2833  D1      		POP	DE		;incr pointer to DE
12115:	2834  CD5002  		CALL	BDTST		;test for completion condition
12116:	2837  E1      		POP	HL		;FOR entry addr to HL
12117:	2838  D2E820  		JP	NC,CSPOP	;don't exit loop -- get new text addr & return
12118:	283B          	NEXT6:
12119:	0000          		IF	COMPL
12121:				ELSE
12122:			;Before purging the FOR-entry the CSTACK direct count must be updated.
12123:	283B  2B      		DEC	HL
12124:	283C  7E      		LD	A,(HL)
12125:	283D  2B      		DEC	HL
12126:	283E  B6      		OR	(HL)		;check line # of FOR
12127:	283F  CC4321  		CALL	Z,DCSTD		;decrement CSTKD if direct
12128:	2842  11F3FF  		LD	DE,-(2*FBYTS+5)
12129:				ENDIF
12130:	2845  19      		ADD	HL,DE		;point to next entry
12131:	2846  3E4F    		LD	A,CSFOR
12132:	2848  CD1F21  		CALL	CSRST		;reset stack pointer
12133:	284B  CD8518  	NEXT7:	CALL	GTCND		;look for comma
12134:	284E  D29027  		JP	NC,NEXT		;do another NEXT if comma
12135:	2851  C9      		RET
12136:	2852          	NFERR:	ERROR	F, N, F		;fatal NF error
12137:			
12138:			;NULL <expr>
12139:	FFFF          		IF	NOT WILD
12140:	2857  CD9C0C  	NULL:	CALL	GTBEX		;get byte-value expr
12141:	285A  79      		LD	A,C
12142:	285B  32303D  		LD	(NULLS),A	;value to NULLS
12143:	285E  C9      		RET
12144:				ENDIF			;end of NOT WILD conditional
12145:			
12146:			;end of STATES2
12148:			;STATES3 12/05/80
12149:			;XYBASIC Interpreter Source Module
12150:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
12151:			;statement routines for statements ON through WAIT
12152:			
12153:			
12154:			;ON <expr> {GOTO | GOSUB} <line #> [, <line #>]*
12155:	285F  CD8F0C  	ON:	CALL	GTEXP		;value to BC
12156:	2862  CD5A18  		CALL	GTCHA
12157:	2865  FE8C    		CP	GOTOT
12158:	2867  CA7028  		JP	Z,ONGOT
12159:	286A  FE8D    		CP	GSUBT
12160:	286C  C23501  		JP	NZ,SNERR	;SN error if not GOTO or GOSUB
12161:	286F  37      		SCF
12162:	2870  F5      	ONGOT:	PUSH	AF		;carry set for GOSUB, reset for GOTO
12163:	2871  0B      		DEC	BC		;value - 1 to BC
12164:	2872  78      		LD	A,B
12165:	2873  B7      		OR	A
12166:	2874  03      		INC	BC
12167:	2875  C49328  		CALL	NZ,ON3		;count negative or big
12168:	2878  CD4D19  	ON1:	CALL	GTLNO		;line # to DE
12169:	287B  0D      		DEC	C		;decrement count
12170:	287C  CA8828  		JP	Z,ON2		;do current line #
12171:	287F  CD7C18  		CALL	GTCOM		;look for comma
12172:	2882  D27828  		JP	NC,ON1		;keep going
12173:	2885  CD9A28  		CALL	ONERR		;nonfatal ON error if line # list exhausted
12174:	2888  CDB718  	ON2:	CALL	GTDEL		;scan to end of statement
12175:	288B  CD7826  		CALL	GOTO2		;set TEXTP and LNNUM
12176:	288E  F1      		POP	AF
12177:	288F  D0      		RET	NC		;done if GOTO
12178:	2890  C36926  		JP	GOSU1		;else build GOSUB control stack entry
12179:	2893  0E01    	ON3:	LD	C,1
12180:	2895  FA9A28  		JP	M,ONERR		;replace negative values by 1
12181:	2898  0EFF    		LD	C,255		;and positive by 255
12182:	289A          	ONERR:	ERROR	N, O, N		;nonfatal ON error
12183:	289F  C9      		RET			;and return
12184:			
12185:			;OUT <expr>, <expr>
12186:	FFFF          		IF	NOT WILD
12187:	28A0  CD9C0C  	PUT:	CALL	GTBEX		;get byte expression
12188:	28A3  79      		LD	A,C
12189:	28A4  32AF3C  		LD	(WPORT + 1),A	;set port #
12190:	28A7  CD960C  		CALL	GTCBE		;get comma, byte expr
12191:	28AA  79      		LD	A,C
12192:	28AB  C3AE3C  		JP	WPORT		;OUT it and return
12193:				ENDIF			;end of NOT WILD conditional
12194:			
12195:	0000          		IF	EPSTN
12209:				ENDIF
12210:			
12211:			;POKE <expr>, <expr>
12212:	FFFF          		IF	NOT WILD
12213:	28AE  CD8F0C  	POKE:	CALL	GTEXP
12214:	28B1  C5      		PUSH	BC		;save location
12215:	28B2  CD960C  		CALL	GTCBE		;get comma, byte expr
12216:	28B5  79      		LD	A,C
12217:	28B6  C1      		POP	BC
12218:	28B7  02      		LD	(BC),A		;store data in location
12219:	28B8  C9      		RET
12220:				ENDIF			;end of NOT WILD conditional
12221:			
12222:			;{PRINT | ?} [@<expr>] [[<print item>] {, | ;}]* [<print item>]
12223:			;<print item> ::= [UNS | TAB | SPC] <expr> | <string> | <camvar name>
12224:			;PRINT first PUSHes a return to itself, so the print routines may be CALLed
12225:			;and simply RETurn.  The routines for comma and semicolon check for following
12226:			;delimiter, so a delimiter found after any other item produces a crlf.
12227:			;DPRIN is in module SDISK.
12228:			;WILD PRINT is in module WILD, and calls PRIN0.
12229:	FFFF          		IF	NOT WILD
12230:	28B9          	PRINT:
12231:	FFFF          		IF	SDISK
12232:	28B9  CDA61F  		CALL	GTSFN		;look for file number
12233:	28BC  D2A81E  		JP	NC,DPRIN	;PRINT to file
12234:				ENDIF
12235:				ENDIF
12236:	28BF  01BF28  	PRIN0:	LD	BC,PRIN0
12237:	28C2  C5      		PUSH	BC		;push common return to print more
12238:	28C3  CD6818  		CALL	GTCHO		;look at next char
12239:	28C6  FE22    		CP	'"'		;look for quoted string first to avoid eval
12240:	28C8  CA7329  		JP	Z,PRQU0		;quoted string
12241:	0000          		IF	CAMAC
12246:				ENDIF
12247:	28CB  CDD508  		CALL	EVAL		;look for expression
12248:	28CE  D2F528  		JP	NC,PRVAL	;expression found, print its value
12249:	28D1  CD4201  		CALL	DTEST
12250:	28D4  CAF128  		JP	Z,PRDEL		;delimiter, print crlf and exit
12251:	FFFF          		IF	NOT WILD	;only one print item allowed in WILD versions
12252:	28D7  CD7718  		CALL	READ1		;read the char
12253:	28DA  FE2C    		CP	','
12254:	28DC  CA1129  		JP	Z,PRCOM		;comma
12255:	28DF  FE3B    		CP	SEMIC
12256:	28E1  CA1429  		JP	Z,PRSEM		;semicolon
12257:	28E4  FE11    		CP	TABT
12258:	28E6  CA3D29  		JP	Z,PRTAB		;TAB
12259:	FFFF          		IF	NOT CAMAC
12260:	28E9  FE12    		CP	SPCT
12261:	28EB  CA6629  		JP	Z,PRSPC		;SPC
12262:				ENDIF
12263:	0000          		IF	NOT FLOAT	;UNS allowed as print fn in nonfloat versions
12266:				ENDIF
12267:	0000          		IF	NOT STRNG	;CHR$ allowed as print fn in nonstring versions
12270:				ENDIF
12271:				ENDIF			;end of NOT WILD conditional
12272:	28EE  C33501  		JP	SNERR		;else SN error
12273:			;print delimiter
12274:	28F1  C1      	PRDEL:	POP	BC		;pop the PRINT return
12275:	28F2  C37516  		JP	WCRLF		;write crlf and exit
12276:			;print the value of an EVALuated expression
12277:	28F5  CDBB01  	PRVAL:	CALL	FETC1		;fetch the value
12278:	28F8          		IFTYP	PRSNG,PRSTR	;branch if noninteger
12279:	28FE  78      	PRINV:	LD	A,B
12280:	28FF  B7      		OR	A		;check sign of integer value
12281:	2900  F20929  		JP	P,PRIV1		;print unsigned if positive
12282:	0000          		IF	WILD
12284:				ELSE
12285:	2903  CDFF16  		CALL	WRTBS		;otherwise write signed
12286:	2906  C31716  		JP	WRTS0		;write trailing space and return
12287:				ENDIF
12288:	2909  3E20    	PRIV1:	LD	A,' '		;leading space to A
12289:	0000          		IF	WILD
12291:				ELSE
12292:	290B  CD0E17  		CALL	WRTB1		;write unsigned with leading space
12293:	290E  C31716  		JP	WRTS0		;write trailing space and return
12294:				ENDIF
12295:	FFFF          		IF	NOT WILD
12296:			;comma, space to the next tab stop
12297:	2911  CD1A29  	PRCOM:	CALL	PRCO1		;do the comma
12298:				;and fall through to PRSEM for delimiter test
12299:			;semicolon
12300:	2914  CD3F01  	PRSEM:	CALL	DTST0		;check if next char is delimiter
12301:	2917  D8      		RET	C		;nondelimiter, continue printing
12302:	2918  C1      		POP	BC		;else pop the PRINT return
12303:	2919  C9      		RET			;and exit from PRINT
12304:	291A  2AE03C  	PRCO1:	LD	HL,(COLUM)
12305:	291D  7D      		LD	A,L		;fetch current column
12306:	291E  B7      		OR	A
12307:	291F  C8      		RET	Z
12308:	FFFF          		IF	FLOAT		;comma column width is 14 if floating
12309:	2920  010E00  		LD	BC,14		;comma column width to BC
12310:	2923  68      		LD	L,B		;0 to L
12311:	2924  F22A29  		JP	P,PRCO2		;column is < 128 currently
12312:	2927  2E7E    		LD	L,126		;else make L 14*9
12313:	2929  95      		SUB	L		;and reduce column accordingly
12314:	292A  09      	PRCO2:	ADD	HL,BC		;add comma width
12315:	292B  91      		SUB	C		;subtract comma width from column
12316:	292C  F22A29  		JP	P,PRCO2		;repeat until negative
12317:				ELSE			;comma column width is 8 if nonfloating
12321:				ENDIF
12322:	292F  7C      		LD	A,H
12323:	2930  B7      		OR	A
12324:	2931  7D      		LD	A,L		;fetch desired column
12325:	2932  CA3929  		JP	Z,PRCO3		;width 0, suppress cr check
12326:	2935  BC      		CP	H		;compare to width
12327:	2936  D27516  		JP	NC,WCRLF	;write crlf if >= width
12328:	2939  4F      	PRCO3:	LD	C,A
12329:	293A  C34029  		JP	PRTA1		;else tab to column desired
12330:			;UNS
12331:	0000          		IF	NOT FLOAT
12334:				ENDIF
12335:			;TAB
12336:	293D  CD5129  	PRTAB:	CALL	PRTA0		;get arg mod width
12337:	2940  3AE03C  	PRTA1:	LD	A,(COLUM)
12338:	2943  B9      		CP	C
12339:	2944  C8      		RET	Z		;found desired column
12340:	2945  CD4B29  		CALL	PRTA2		;else write spaces until there
12341:	2948  C34029  		JP	PRTA1
12342:	294B  DA1D16  	PRTA2:	JP	C,WRTSP		;write a space if left of desired column
12343:	294E  C37516  		JP	WCRLF		;else write a crlf
12344:			;PRTA0 evaluates <expr> mod width for TAB and SPC
12345:	2951  CD8F0C  	PRTA0:	CALL	GTEXP		;get argument
12346:	2954  3AE13C  		LD	A,(WIDTH)
12347:	2957  B7      		OR	A		;Zero set iff width 0
12348:	2958  5F      		LD	E,A
12349:	2959  1600    		LD	D,0
12350:	295B  D5      		PUSH	DE
12351:	295C  C45814  		CALL	NZ,OPMOD	;evaluate arg mod width unless width 0
12352:	295F  D1      		POP	DE		;restore width to DE
12353:	2960  78      		LD	A,B
12354:	2961  B7      		OR	A		;check if arg was negative
12355:	2962  FC2C14  		CALL	M,IADD		;yes, add width to result to make positive
12356:	2965  C9      		RET
12357:			;SPC
12358:	FFFF          		IF	NOT CAMAC
12359:	2966  CD5129  	PRSPC:	CALL	PRTA0		;get arg mod width
12360:	2969  79      		LD	A,C
12361:	296A  B7      		OR	A
12362:	296B  C8      	PRSP1:	RET	Z		;done
12363:	296C  CD1D16  		CALL	WRTSP		;else write a space
12364:	296F  0D      		DEC	C		;decrement space count
12365:	2970  C36B29  		JP	PRSP1		;and repeat
12366:				ENDIF
12367:				ENDIF			;end of NOT WILD condtional
12368:			;quoted string
12369:	2973  CD7718  	PRQU0:	CALL	READ1		;read the "
12370:	2976  54      	PRQUO:	LD	D,H
12371:	2977  5D      		LD	E,L		;address of first char to DE
12372:	2978  CDC618  		CALL	GTCLQ		;scan to close quote or cr
12373:	297B  7D      		LD	A,L		;fetch last+1 address
12374:	297C  93      		SUB	E		;last+1 - first = # chars
12375:	297D  4F      	PRST0:	LD	C,A		;to C
12376:	297E  C32F17  		JP	PRSTR		;and print the string
12377:	0000          		IF	NOT STRNG	;allow CHR$ as print fn
12381:				ENDIF
12382:			;floating point value
12383:	FFFF          		IF	FLOAT
12384:	2981  CDA80D  	PRSNG:	CALL	FOUT		;convert FACC to string
12385:	0000          		IF	WILD
12387:				ELSE
12388:	2984  CD1A17  		CALL	PRSTL		;write the string
12389:	2987  C31716  		JP	WRTS0		;write trailing space and return
12390:				ENDIF
12391:				ENDIF
12392:			;PRCAM is in module CAMAC.
12393:			
12394:			;RANDOMIZE <expr>
12395:	FFFF          		IF	NOT WILD
12396:	298A  CD8F0C  	RNDIZ:	CALL	GTEXP
12397:	298D  60      		LD	H,B
12398:	298E  69      		LD	L,C		;value to HL
12399:	298F  222E3D  		LD	(RANDX),HL	;and it becomes new seed
12400:	2992  C9      		RET
12401:				ENDIF			;end of NOT WILD conditional
12402:			
12403:			;READ <var list>
12404:			;READ must scan the command line READ <var list> and lines of DATA [<expr>,]*.
12405:			;The text pointers are kept in TEXTP and TXTP2 and exchanged by FLIP.
12406:	2993  2AC83F  	READ:	LD	HL,(RDPTR)
12407:	2996  22523E  		LD	(TXTP2),HL	;READ pointer to TXTP2
12408:	2999  CD4D01  	READA:	CALL	GTLHS		;get destination for ASSGN
12409:	FFFF          		IF	STRNG
12410:	299C  F5      		PUSH	AF		;save var type in string version
12411:				ENDIF
12412:	299D  CD3702  		CALL	FLIP		;to scan data
12413:	29A0  CD8518  		CALL	GTCND		;see if comma (in DATA <lit>,<lit>...) next
12414:	29A3  DCCB29  		CALL	C,READE		;no, find next DATA statement
12415:	FFFF          		IF	STRNG
12416:	29A6  F1      		POP	AF		;restore var type
12417:	29A7  FE03    		CP	STRST
12418:	29A9  C2B229  		JP	NZ,READB	;not a string var
12419:	29AC  CDAE2D  		CALL	EVUNQ		;string var, get value (possibly unquoted)
12420:	29AF  C3B829  		JP	READD
12421:				ENDIF
12422:	29B2  CD5919  	READB:	CALL	GTLIT		;look for value
12423:	29B5  DAE529  		JP	C,READF		;no value found
12424:	29B8  CD6501  	READD:	CALL	ASIGV		;assign value to variable
12425:	29BB  CD3702  		CALL	FLIP		;to scan varlist
12426:	29BE  CD7C18  		CALL	GTCOM		;look for comma
12427:	29C1  D29929  		JP	NC,READA	;read another
12428:	29C4  2A523E  		LD	HL,(TXTP2)	;else recover new RDPTR
12429:	29C7  22C83F  		LD	(RDPTR),HL	;and store it
12430:	29CA  C9      		RET			;and done
12431:			;READE finds the next DATA statement.
12432:			;Issues nonfatal OD error and retries if no more DATA.
12433:			;Issues fatal SN error if SN error in DATA.
12434:	29CB  CD3F01  	READE:	CALL	DTST0		;check if at delimiter
12435:	29CE  DAE529  		JP	C,READF		;no -- SN error in DATA
12436:	29D1  0694    		LD	B,DATAT
12437:	29D3  CD7402  		CALL	FNDST		;find next DATA
12438:	29D6  D0      		RET	NC		;OK if found
12439:	29D7          		ERROR	N, O, D		;nonfatal OD error
12440:	29DC  CDD62A  		CALL	RSTOR		;do a RESTORE
12441:	29DF  22C63F  		LD	(TEXTP),HL
12442:	29E2  C3CB29  		JP	READE		;and try again
12443:			;READF issues fatal SN error for bad DATA items.
12444:	29E5  EB      	READF:	EX	DE,HL		;DATA textp to DE
12445:	29E6  CDC302  		CALL	FNDLN		;find its line number
12446:	29E9  22E23C  		LD	(LNNUM),HL	;reset line # for error message
12447:	29EC          		ERROR	F, S, N		;fatal SN error
12448:			
12449:			;REM <unquoted string>
12450:	29F1  CD5A18  	REM:	CALL	GTCHA
12451:	29F4  FE0D    		CP	CR
12452:	29F6  C2F129  		JP	NZ,REM		;scan to <cr>
12453:	29F9  CD6B18  		CALL	BAKUP		;back up text pointer
12454:	29FC  23      		INC	HL		;let HL point to next byte in case on-line
12455:	29FD  C9      		RET
12456:			
12457:			;RENUM [<line #> [, <line #> [, <line #>]]]
12458:	FFFF          		IF	EDITC
12459:	0000          		IF	COMPL
12461:				ELSE
12462:			;RENU0 gets an optional comma followed by <line #>, default value from DE.
12463:	29FE  CD8518  	RENU0:	CALL	GTCND		;look for comma
12464:	2A01  D44D19  		CALL	NC,GTLNO	;if comma look for <line #>
12465:	2A04  EB      		EX	DE,HL		;to HL
12466:	2A05  C9      		RET			;and return
12467:			;First RENUM must get arguments.
12468:			;RNOLD gets the old line # of first renumbered line,
12469:			;RNNEW gets the new line # of first renumbered line, and
12470:			;RNINC gets the renumbering increment.
12471:	2A06          	RENUM:
12472:	0000          		IF	ROMSQ
12474:				ENDIF
12475:	2A06  CD4D19  		CALL	GTLNO		;look for <line #>
12476:	2A09  D2102A  		JP	NC,RENU1	;<line #> given
12477:	2A0C  CD4137  		CALL	FINDL		;none given -- look for line 0
12478:	2A0F  37      		SCF			;to skip following FDLNO
12479:	2A10  D46337  	RENU1:	CALL	NC,FDLNO	;find the specified line #
12480:	2A13  E5      		PUSH	HL		;save first renumbered line location
12481:	2A14  CDF801  		CALL	MODEM		;line # of first renumbered line to DE
12482:	2A17  D5      		PUSH	DE		;and saved
12483:	2A18  EB      		EX	DE,HL
12484:	2A19  22453D  		LD	(RNOLD),HL	;and saved in RNOLD
12485:	2A1C  110A00  		LD	DE,10		;default arg2 is 10
12486:	2A1F  CDFE29  		CALL	RENU0		;get increment
12487:	2A22  7C      		LD	A,H
12488:	2A23  B5      		OR	L
12489:	2A24  CA5419  		JP	Z,USERR		;fatal US error if 0 (e.g., RENUM 10,,)
12490:	2A27  22433D  		LD	(RNINC),HL	;increment saved in RNINC
12491:	2A2A  E3      		EX	(SP),HL		;save increment, first line line # to HL
12492:	2A2B  EB      		EX	DE,HL		;and then to DE as default arg3
12493:	2A2C  CDFE29  		CALL	RENU0		;get destination <line #>
12494:	2A2F  22413D  		LD	(RNNEW),HL	;and saved in RNNEW
12495:	2A32  EB      		EX	DE,HL		;destination to DE
12496:	2A33  CD1E01  		CALL	IITST		;RENUM illegal indirect
12497:			;Now test if the specified args give too large a max <line #>.
12498:	2A36  C1      		POP	BC		;increment to BC
12499:	2A37  E1      		POP	HL		;location to HL
12500:	2A38  C5      		PUSH	BC
12501:	2A39  D5      		PUSH	DE
12502:	2A3A  E5      		PUSH	HL		;save args
12503:	2A3B  7E      		LD	A,(HL)		;fetch length
12504:	2A3C  CD1502  		CALL	ADAHL		;address second line
12505:	2A3F  7E      	RENU2:	LD	A,(HL)		;fetch length
12506:	2A40  B7      		OR	A
12507:	2A41  CA502A  		JP	Z,RENU3		;eof
12508:	2A44  CD1502  		CALL	ADAHL		;address next line
12509:	2A47  EB      		EX	DE,HL
12510:	2A48  09      		ADD	HL,BC		;compute its eventual line #
12511:	2A49  EB      		EX	DE,HL
12512:	2A4A  D23F2A  		JP	NC,RENU2	;continue if no overflow
12513:	2A4D  C35419  		JP	USERR		;too large, US error
12514:			;Now test if last line # before first is < new first.
12515:	2A50  010000  	RENU3:	LD	BC,0		;last line before first initially 0
12516:	2A53  D1      		POP	DE		;first line # length byte address to DE
12517:	2A54  21CF3F  		LD	HL,SRCAD	;start at beginning of source text
12518:	2A57  CD2902  	RENU4:	CALL	CMDHU		;compare first to current
12519:	2A5A  CA6A2A  		JP	Z,RENU5		;matched, BC now has last
12520:	2A5D  23      		INC	HL
12521:	2A5E  4E      		LD	C,(HL)
12522:	2A5F  23      		INC	HL
12523:	2A60  46      		LD	B,(HL)		;line number to BC
12524:	2A61  2B      		DEC	HL
12525:	2A62  2B      		DEC	HL
12526:	2A63  7E      		LD	A,(HL)		;fetch length byte
12527:	2A64  CD1502  		CALL	ADAHL		;address next
12528:	2A67  C3572A  		JP	RENU4		;and try it
12529:	2A6A  D1      	RENU5:	POP	DE		;new first line # to DE
12530:	2A6B  D5      		PUSH	DE		;and resave
12531:	2A6C  CD2302  		CALL	CMBDU		;compare to line # before first
12532:	2A6F  D25419  		JP	NC,USERR	;US error if previous is larger
12533:	2A72  2AC63F  		LD	HL,(TEXTP)
12534:	2A75  E5      		PUSH	HL		;save TEXTP
12535:	2A76  CDD802  		CALL	LNREF		;change <line #> references in source text
12536:	2A79  E1      		POP	HL
12537:	2A7A  22C63F  		LD	(TEXTP),HL
12538:			;Now change the actual <line #>s.
12539:	2A7D  2A453D  		LD	HL,(RNOLD)
12540:	2A80  EB      		EX	DE,HL		;RNOLD to DE
12541:	2A81  CD4137  		CALL	FINDL		;find (possibly new) location of first changed
12542:	2A84  D1      		POP	DE		;RNNEW to DE
12543:	2A85  C1      		POP	BC		;RNINC to BC
12544:	2A86  7E      	RENU6:	LD	A,(HL)		;fetch length of next line
12545:	2A87  B7      		OR	A
12546:	2A88  CA9B2A  		JP	Z,RENU7		;all line numbers changed
12547:	2A8B  E5      		PUSH	HL		;save current length byte address
12548:	2A8C  CD1502  		CALL	ADAHL		;address next line
12549:	2A8F  E3      		EX	(SP),HL		;save next, recover current
12550:	2A90  23      		INC	HL
12551:	2A91  73      		LD	(HL),E
12552:	2A92  23      		INC	HL
12553:	2A93  72      		LD	(HL),D		;change the line number
12554:	2A94  E1      		POP	HL		;next line length byte address to HL
12555:	2A95  EB      		EX	DE,HL
12556:	2A96  09      		ADD	HL,BC
12557:	2A97  EB      		EX	DE,HL		;update line number
12558:	2A98  C3862A  		JP	RENU6		;and renumber more
12559:			;Check break bytes for flag indicating illegal <line #> in line.
12560:	2A9B  0600    	RENU7:	LD	B,0		;clear bad line flag
12561:	2A9D  21CF3F  		LD	HL,SRCAD	;begin at the beginning
12562:	2AA0  7E      	RENU8:	LD	A,(HL)
12563:	2AA1  B7      		OR	A
12564:	2AA2  CAC02A  		JP	Z,RENUX		;eof, done
12565:	2AA5  E5      		PUSH	HL		;save length byte loc
12566:	2AA6  23      		INC	HL
12567:	2AA7  23      		INC	HL		;skip line # bytes
12568:	2AA8  23      		INC	HL		;and address break byte
12569:	2AA9  7E      		LD	A,(HL)		;fetch it
12570:	2AAA  B7      		OR	A		;check bit 7
12571:	2AAB  F2B82A  		JP	P,RENU9		;ok if not set
12572:	2AAE  2B      		DEC	HL
12573:	2AAF  2B      		DEC	HL		;address line # byte
12574:	2AB0  CD8D17  		CALL	PRNTL		;print the bad line
12575:	2AB3  CD7516  		CALL	WCRLF		;and crlf
12576:	2AB6  06FF    		LD	B,255		;and set bad line flag
12577:	2AB8  E1      	RENU9:	POP	HL
12578:	2AB9  7E      		LD	A,(HL)		;refetch length
12579:	2ABA  CD1502  		CALL	ADAHL		;address next line
12580:	2ABD  C3A02A  		JP	RENU8		;and try next line
12581:	2AC0  C5      	RENUX:	PUSH	BC		;save bad line flag
12582:	2AC1  CD1437  		CALL	ADDL3		;text may have moved, reset stacks
12583:	2AC4  F1      		POP	AF		;recover bad line flag
12584:	2AC5  B7      		OR	A
12585:	2AC6  C8      		RET	Z		;successful RENUM
12586:	2AC7  C35419  		JP	USERR		;else US error message
12587:				ENDIF
12588:				ELSE
12590:				ENDIF
12591:			
12592:			;RESTORE [<line #>]
12593:	2ACA  CD4D19  	RESTR:	CALL	GTLNO		;look for line #
12594:	2ACD  DAD62A  		JP	C,RSTOR		;none, take least
12595:	2AD0  CD6337  		CALL	FDLNO		;find the line
12596:	2AD3  C3D92A  		JP	RSTO1		;and reset the read pointer
12597:	2AD6          	RSTOR:
12598:	0000          		IF	ROMSQ
12600:				ELSE
12601:	2AD6  21CF3F  		LD	HL,SRCAD
12602:				ENDIF
12603:	2AD9  2B      	RSTO1:	DEC	HL		;point to <cr> preceding line
12604:	2ADA  22C83F  		LD	(RDPTR),HL	;let read pointer address <cr>
12605:	2ADD  C9      		RET
12606:			
12607:			;RETURN
12608:	2ADE  CD3101  	RETRN:	CALL	EOS		;end of statement test
12609:	2AE1  018725  		LD	BC,(CSGOS SHL 8) OR CSINT
12610:	2AE4  CD0D21  		CALL	CSDIG		;look for gosub or interrupt cstack entry
12611:	2AE7  DAFD2A  		JP	C,RGERR		;not found -- RG error
12612:	2AEA  CDE820  		CALL	CSPOP		;pop cstack information
12613:	2AED  B8      		CP	B		;zero set if gosub, reset interrupt
12614:	2AEE  CA1F21  		JP	Z,CSRST		;GOSUB entry -- reset stack & return
12615:	2AF1  F5      		PUSH	AF
12616:	2AF2  CDEE01  		CALL	MVDEM		;interrupt table byte addr to DE
12617:	2AF5  1A      		LD	A,(DE)
12618:	2AF6  F640    		OR	40H		;resume interrupt
12619:	2AF8  12      		LD	(DE),A
12620:	2AF9  F1      		POP	AF
12621:	2AFA  C31F21  		JP	CSRST		;reset control stack and return
12622:	2AFD          	RGERR:	ERROR	F, R, G		;fatal RG error
12623:			
12624:			;RUN [<line #>]
12625:	0000          		IF	COMPL
12627:				ELSE
12628:	2B02          	RUN:
12629:	FFFF          		IF	SDISK
12630:	2B02  CD2B1C  		CALL	CLOSN		;close any OPEN files
12631:				ENDIF
12632:	0000          		IF	CAMAC AND FALSE	;Northstar version
12634:				ENDIF
12635:	2B05  CD4D19  		CALL	GTLNO		;look for line #
12636:	2B08  F5      		PUSH	AF
12637:	2B09  D5      		PUSH	DE
12638:	2B0A  CD1E01  		CALL	IITST		;RUN illegal indirect
12639:	2B0D  CDA022  		CALL	CLEA1		;clear CSTACK, symbol table, string space
12640:	FFFF          		IF	NOT WILD
12641:	2B10  CD5904  		CALL	DISAB		;disable interrupts
12642:				ENDIF
12643:	2B13  CDD62A  		CALL	RSTOR		;restore READ pointer
12644:	2B16  D1      		POP	DE
12645:	2B17  F1      		POP	AF
12646:	2B18  D27826  		JP	NC,GOTO2	;line # specified, execute from there
12647:	2B1B  22C63F  		LD	(TEXTP),HL	;else point to <cr> before source text
12648:	2B1E  C9      		RET			;and execute from there
12649:				ENDIF
12650:			
12651:			;SAVE is in section STATES4.
12652:			
12653:			;SCALL <expr> [, <integer var ref>]*
12654:			;SCALL loads BC, DE and HL with the values of the <integer var ref>s, if any,
12655:			;and branches to the <expr> address.  When the user routine RETurns,
12656:			;the values in BC, DE and HL are assigned to the <integer var ref>s.
12657:	2B1F  CD8F0C  	SCALL:	CALL	GTEXP
12658:	2B22  2AC63F  		LD	HL,(TEXTP)
12659:	2B25  22543E  		LD	(SAVTP),HL	;save textp for rescan on return
12660:	2B28  21512B  		LD	HL,SRETN
12661:	2B2B  E5      		PUSH	HL		;return address to stack
12662:	2B2C  C5      		PUSH	BC		;branch address to stack
12663:	2B2D  110300  		LD	DE,3		;maximum parameter count to DE
12664:	2B30  CD8518  	SCAL1:	CALL	GTCND		;look for comma not followed by delimiter
12665:	2B33  DA4C2B  		JP	C,SCAL2		;none, set up registers and branch to user
12666:	2B36  CD481B  		CALL	GTIVA		;perform integer var ref
12667:	2B39  DA3E04  		JP	C,MCERR		;not a var ref
12668:	2B3C  C5      		PUSH	BC		;save parameter value
12669:	2B3D  1D      		DEC	E		;decrement parameter count
12670:	2B3E  C2302B  		JP	NZ,SCAL1	;get more parameters if not three already
12671:	2B41  CD8518  		CALL	GTCND		;check if more parameters
12672:	2B44  DA4C2B  		JP	C,SCAL2		;no more
12673:	2B47          		ERROR	N, M, C		;nonfatal MC error if too many
12674:			;At SCAL2, DE contains 3 - # parameters specified, and the parameter values
12675:			;are PUSHed.  By adding DE to the address POP3, the branch address
12676:			;is computed to POP 3, 2, 1 or 0 values before branching to the user routine.
12677:	2B4C  219309  	SCAL2:	LD	HL,POP3
12678:	2B4F  19      		ADD	HL,DE		;compute pop address
12679:	2B50  E9      		JP	(HL)		;branch to it
12680:			;SRETN is the entry point from the user routine's RETurn.
12681:	2B51  E5      	SRETN:	PUSH	HL
12682:	2B52  D5      		PUSH	DE
12683:	2B53  C5      		PUSH	BC		;save registers
12684:	2B54  2A543E  		LD	HL,(SAVTP)
12685:	2B57  22C63F  		LD	(TEXTP),HL	;restore TEXTP
12686:	2B5A  110000  		LD	DE,0		;# of POPed registers to DE
12687:	2B5D  CD8518  	SRET1:	CALL	GTCND		;look for comma
12688:	2B60  DA4C2B  		JP	C,SCAL2		;done, POP extras and return
12689:	2B63  1C      		INC	E		;increment POPed count
12690:	2B64  3E03    		LD	A,3
12691:	2B66  BB      		CP	E
12692:	2B67  DA6507  		JP	C,NEXTC		;too many, scan to end and return
12693:	2B6A  D5      		PUSH	DE
12694:	2B6B  CD4D01  		CALL	GTLHS		;get destination
12695:	2B6E  23      		INC	HL		;point to high order destination
12696:	2B6F  D1      		POP	DE
12697:	2B70  C1      		POP	BC		;value to BC
12698:	2B71  CDA101  		CALL	ASIGI		;assign integer value, traced
12699:	2B74  C35D2B  		JP	SRET1		;and  repeat
12700:			
12701:			;SETTIME <expr> [, <expr>] [, <expr>]
12702:	0000          		IF	REALT AND NOT CAMAC;SETTIME in REALT versions only
12725:				ENDIF
12726:			
12727:			;STOP
12728:	0000          		IF	COMPL		;STOP boots in COMPL version
12734:				ELSE
12735:	2B77  3E65    	STOP:	LD	A,CSBRK		;break token to A
12736:	2B79  F5      	STOP1:	PUSH	AF		;line break entry point
12737:	2B7A  CD0601  		CALL	LINBC		;line # to BC
12738:	2B7D  CA3D07  		JP	Z,DMOD2		;direct mode -- do not save info
12739:	2B80  CDCF17  		CALL	PRTM0		;turn on OMODE, print BREAK message
12740:	2B83  0D0A4252		DEFB	CR, LF, 'BREAK AT LINE', ' ' OR 80H
	      45414B20
	      4154204C
	      494E45A0
12741:	2B93  CD0D17  		CALL	WRTBU		;print line # unsigned
12742:	2B96  F1      		POP	AF
12743:	2B97  CDAE20  	STOP2:	CALL	CPUSH		;break info to control stack -- END entry point
12744:	2B9A  C33D07  		JP	DMOD2		;and continue in DMODE
12745:				ENDIF			;end of COMPL conditional
12746:			
12747:			;TIME
12748:	FFFF          		IF	(NOT CAMAC) AND (NOT REALT)
12749:	2B9D  3E07    	TIME:	LD	A,CNTLG
12750:	2B9F  CD1F16  		CALL	WRITC		;ring a bell
12751:	2BA2  210000  		LD	HL,0
12752:	2BA5  CD8D16  		CALL	READC		;get and ignore first char
12753:	2BA8  CDAB23  		CALL	TIMER
12754:	2BAB  D23A01  		JP	NC,EXERR	;counted to 0 -- EX error
12755:	2BAE  CDD116  		CALL	CTEST		;read the char TIMER saw
12756:	2BB1  E5      		PUSH	HL		;save minute count
12757:	2BB2  7C      		LD	A,H
12758:	2BB3  32DF3C  		LD	(TIMEX+4),A	;minute count / 256 to TIMEX+4
12759:	2BB6  44      		LD	B,H
12760:	2BB7  4D      		LD	C,L
12761:	2BB8  113C00  		LD	DE,60
12762:	2BBB  CD8A12  		CALL	DIVD0		;min count / 60 = sec count to HL
12763:	2BBE  D1      		POP	DE
12764:	2BBF  CD0802  		CALL	CPLDE		;complement minute count
12765:	2BC2  EB      		EX	DE,HL
12766:	2BC3  22DB3C  		LD	(TIMEX),HL	;complmented minute count to TIMEX
12767:	2BC6  CD0802  		CALL	CPLDE		;complement second count
12768:	2BC9  EB      		EX	DE,HL
12769:	2BCA  22DD3C  		LD	(TIMEX+2),HL	;complemented second count to TIMEX+2
12770:	2BCD  C9      		RET
12771:				ENDIF
12772:			
12773:			;TRACE | UNTRACE
12774:			;TRAP | UNTRAP
12775:	0000          		IF	COMPL
12780:				ELSE
12781:	2BCE  37      	TCON:	SCF
12782:	2BCF  9F      	TCOFF:	SBC	A,A		;A gets 0 if no carry, 255 if carry
12783:	2BD0  32E73C  		LD	(TRACE),A
12784:	2BD3  C9      		RET
12785:	2BD4  37      	TPOFF:	SCF
12786:	2BD5  9F      	TPON:	SBC	A,A
12787:	2BD6  32E63C  		LD	(TRAP),A
12788:	2BD9  C9      		RET
12789:				ENDIF			;end of NOT COMPL conditional
12790:			
12791:			;UNBREAK [<line #> | <var list>]
12792:			;UNBREAK removes all breakpoints.
12793:			;UNBREAK <line #> removes the breakpoint (if any) on the specified line.
12794:			;UNBREAK <var list> removes breakpoints on the specified variables.
12795:	0000          		IF	COMPL
12797:				ELSE
12798:	2BDA  CD4D19  	UNBRK:	CALL	GTLNO		;see if line # present
12799:	2BDD  DAE92B  		JP	C,UNBR2		;no
12800:			;Remove breakpoint from line # in DE.
12801:	0000          		IF	ROMSQ
12803:				ENDIF
12804:	2BE0  CD6337  		CALL	FDLNO		;find the line
12805:			;UNBR1 removes the breakpoint on line addressed by HL.
12806:	2BE3  23      	UNBR1:	INC	HL		;move pointer from length byte
12807:	2BE4  23      		INC	HL		;   past line #
12808:	2BE5  23      		INC	HL		;   to break byte
12809:	2BE6  3600    		LD	(HL),0		;and zero it
12810:	2BE8  C9      		RET
12811:	2BE9  CD4201  	UNBR2:	CALL	DTEST		;see if var list present
12812:	2BEC  DAFF2B  		JP	C,UBVAR		;yes
12813:	2BEF  2A5D3E  		LD	HL,(SYMTA)	;no, unbreak all lines and variables
12814:			;UNBR3 removes all variable breakpoints.
12815:	2BF2  CD4820  	UNBR3:	CALL	STNXT		;get next symbol table entry
12816:	2BF5  DA9D20  		JP	C,UNBKL		;end of table -- unbreak lines and return
12817:	2BF8  1A      		LD	A,(DE)
12818:	2BF9  E67F    		AND	7FH
12819:	2BFB  12      		LD	(DE),A		;unbreak one entry
12820:	2BFC  C3F22B  		JP	UNBR3
12821:			;UBVAR removes breakpoints on the specified <var list> variables.
12822:	2BFF  CD861A  	UBVAR:	CALL	FDVAR		;find var ref
12823:	2C02  DA3501  		JP	C,SNERR
12824:	2C05  1A      		LD	A,(DE)
12825:	2C06  E67F    		AND	7FH
12826:	2C08  12      		LD	(DE),A		;unbreak it
12827:	2C09  CD8518  		CALL	GTCND		;look for comma
12828:	2C0C  D2FF2B  		JP	NC,UBVAR	;unbreak another var
12829:	2C0F  C9      		RET
12830:				ENDIF			;end of NOT COMPL conditional
12831:			
12832:			;UNTRACE and UNTRAP are under TRACE and TRAP above.
12833:			
12834:			;WAIT <byte expr> , <byte expr> [, <byte expr>] [,$]
12835:	FFFF          		IF	NOT WILD
12836:	2C10  CD6104  	WAIT:	CALL	IINFO		;get interrupt info
12837:	2C13  79      		LD	A,C
12838:	2C14  17      		RLA
12839:	2C15  17      		RLA
12840:	2C16  4F      		LD	C,A		;$ bit to C7
12841:	2C17  78      		LD	A,B		;port # to A
12842:	2C18  CD3712  		CALL	RDP1		;read
12843:	2C1B  B3      		OR	E		;mask
12844:	2C1C  AA      		XOR	D		;compare
12845:	2C1D  CA212C  		JP	Z,WAIT1
12846:	2C20  37      		SCF			;carry set iff compare nonzero
12847:	2C21  1F      	WAIT1:	RRA			;A7 set iff compare nonzero
12848:	2C22  A9      		XOR	C		;sign set iff keep waiting
12849:	2C23  F0      		RET	P		;condition fulfilled -- return
12850:	2C24  2A543E  		LD	HL,(SAVTP)
12851:	2C27  22C63F  		LD	(TEXTP),HL	;reset text pointer to parse WAIT again
12852:	2C2A  C9      		RET
12853:				ENDIF			;end of NOT WILD conditional
12854:			
12855:			
12856:			;end of STATES3
12858:			;STRINGS 11/1/79
12859:			;XYBASIC Interpreter Source Module
12860:			;Copyright (C) 1978, 1979 by Mark Williams Company, Chicago
12861:			;string routines and functions
12862:			
12863:	FFFF          		IF	STRNG
12864:			
12865:			;String space consists of RAM from (MEMT)+1 to (STRT).  String variables are
12866:			;stored from (MEMT)+1 to (STRPT), and (STRPT)+1 to (STRP2) is used for
12867:			;temporary string storage.  The string temporaries at STEMP contain the
12868:			;addresses of ESTACK string entries, as the strings may move during garbage
12869:			;collection.
12870:			
12871:			;ATEMP assigns the ESTACK location in HL to a string temporary.
12872:			;The temporary is freed when the string value is FETCHed.
12873:			;Retn:	A	clobbered
12874:			;	BCDEHL	preserved
12875:	2C2B  D5      	ATEMP:	PUSH	DE
12876:	2C2C  EB      		EX	DE,HL		;location to DE
12877:	2C2D  21323D  		LD	HL,STEMP	;temp base addr to HL
12878:	2C30  7E      		LD	A,(HL)		;fetch # temps in use
12879:	2C31  3C      		INC	A		;and bump
12880:	2C32  FE04    		CP	STMAX		;compare to # available
12881:	2C34  D2422C  		JP	NC,STERR	;too many, fatal ST error
12882:	2C37  77      		LD	(HL),A		;store new # in use
12883:	2C38  87      		ADD	A,A		;# * 2 bytes per temp
12884:	2C39  CD1502  		CALL	ADAHL		;+ base = bottom of new temp
12885:	2C3C  72      		LD	(HL),D
12886:	2C3D  2B      		DEC	HL
12887:	2C3E  73      		LD	(HL),E		;location to temp
12888:	2C3F  EB      		EX	DE,HL		;restore loc to HL
12889:	2C40  D1      		POP	DE		;and restore DE
12890:	2C41  C9      		RET
12891:	2C42          	STERR:	ERROR	F, S, T		;fatal ST error
12892:			
12893:			;SCOPY copies a new string to string temp space for GET$, CHR$, and STR$.
12894:			;Call:	C	string length
12895:			;	DE	string location
12896:			;Retn:	B	preserved
12897:			;	C	string length
12898:			;	DE	string location (in string space)
12899:			;	HL	top of string temp space used
12900:			;SCOP0 is called from concatenation (SADD) and assignment (SCOPV) to
12901:			;fetch the string value addressed by HL and then copy to string space.
12902:	2C47  CDD201  	SCOP0:	CALL	FETCS		;fetch string arg
12903:	2C4A  79      	SCOPY:	LD	A,C
12904:	2C4B  CD7F2C  		CALL	STFRE		;assure sufficient free space
12905:	2C4E  79      		LD	A,C
12906:	2C4F  B7      		OR	A
12907:	2C50  C8      		RET	Z		;null string, just return
12908:	2C51  C5      		PUSH	BC		;save length
12909:	2C52  CD2314  		CALL	BCDE		;length to E, location to BC
12910:	2C55  23      		INC	HL		;next available location to HL
12911:	2C56  E5      		PUSH	HL		;save location
12912:	2C57  CD3437  		CALL	MOVD0		;copy string to string space
12913:	2C5A  2B      		DEC	HL
12914:	2C5B  223F3D  		LD	(STRP2),HL	;new top of string temp space used
12915:	2C5E  D1      		POP	DE		;restore location
12916:	2C5F  C1      		POP	BC		;and length
12917:	2C60  C9      		RET
12918:			
12919:			;SCOPV copies the value addressed by HL to string space for string assignment.
12920:	2C61  E5      	SCOPV:	PUSH	HL
12921:	2C62  23      		INC	HL
12922:	2C63  7E      		LD	A,(HL)		;fetch length
12923:	2C64  2A3D3D  		LD	HL,(STRPT)
12924:	2C67  223F3D  		LD	(STRP2),HL	;clear string temp spacce
12925:	2C6A  CD7F2C  		CALL	STFRE		;assure sufficient free space
12926:	2C6D  E1      		POP	HL		;restore value pointer
12927:	2C6E  E5      		PUSH	HL
12928:	2C6F  CD472C  		CALL	SCOP0		;fetch the value and copy to string space
12929:	2C72  223D3D  		LD	(STRPT),HL	;and reset string space var pointer
12930:	2C75  E1      		POP	HL		;restore the value pointer
12931:	2C76  E5      		PUSH	HL
12932:	2C77  23      		INC	HL
12933:	2C78  23      		INC	HL
12934:	2C79  73      		LD	(HL),E
12935:	2C7A  23      		INC	HL
12936:	2C7B  72      		LD	(HL),D		;new location to value entry
12937:	2C7C  E1      		POP	HL		;restore HL
12938:	2C7D  7E      		LD	A,(HL)		;and restore type
12939:	2C7E  C9      		RET
12940:			
12941:			;STFRE assures that (A) bytes of string space is availfable.
12942:			;Garbage collection is performed if required, and an OS error if insufficient.
12943:			;Call:	A	amount of string space needed
12944:			;Retn:	BC,DE	preserved
12945:			;	HL	top of used string space (STRP2)
12946:	2C7F  C5      	STFRE:	PUSH	BC
12947:	2C80  D5      		PUSH	DE
12948:	2C81  4F      		LD	C,A
12949:	2C82  0600    		LD	B,0		;desired space to BC
12950:	2C84  2A3B3D  		LD	HL,(STRT)
12951:	2C87  EB      		EX	DE,HL		;top of string space to DE
12952:	2C88  2A3F3D  		LD	HL,(STRP2)	;current used string space top to HL
12953:	2C8B  E5      		PUSH	HL		;and saved
12954:	2C8C  09      		ADD	HL,BC		;current top + desired amount to HL
12955:	2C8D  D42902  		CALL	NC,CMDHU	;compare top to needed
12956:	2C90  D29309  		JP	NC,POP3		;top >= needed, restore and return
12957:	2C93  E1      		POP	HL
12958:	2C94  C5      		PUSH	BC		;save desired
12959:	2C95  CDA72C  		CALL	GARBG		;garbage collect
12960:	2C98  EB      		EX	DE,HL
12961:	2C99  C1      		POP	BC
12962:	2C9A  E5      		PUSH	HL		;save used top
12963:	2C9B  09      		ADD	HL,BC
12964:	2C9C  D42902  		CALL	NC,CMDHU	;compare top to needed
12965:	2C9F  D29309  		JP	NC,POP3		;ok after garbage collection
12966:	2CA2          		ERROR	F, O, S		;fatal OS error
12967:			
12968:			;GARBG is the string space garbage collector.  All strings referenced by
12969:			;string variables or temporaries are compacted to the base of string space.
12970:			;Retn:	DE	top of used string space (STRPT)
12971:			;	HL	top of string space (STRT)
12972:	2CA7  2ACC3F  	GARBG:	LD	HL,(MEMT)
12973:	2CAA  23      		INC	HL		;point to first byte of string space
12974:	2CAB  22413D  		LD	(GCMIN),HL	;min value to accept
12975:			;First the string with the minimum location >= GCMIN is found.
12976:			;GCLST contains the least so far, and GCLOC the location of the least.
12977:	2CAE  21FFFF  	GARB1:	LD	HL,-1
12978:	2CB1  22433D  		LD	(GCLST),HL	;string space loc of least string found
12979:	2CB4  2A5D3E  		LD	HL,(SYMTA)
12980:	2CB7  E5      		PUSH	HL
12981:	2CB8  D1      	GARB2:	POP	DE		;set initial values for NXTST
12982:	2CB9  CD852D  		CALL	NXTST		;find next symbol table string var
12983:	2CBC  DAD52C  		JP	C,GARB4		;no more string entries
12984:	2CBF  D5      		PUSH	DE
12985:	2CC0  E5      		PUSH	HL
12986:	2CC1  50      		LD	D,B
12987:	2CC2  59      		LD	E,C		;next string location to DE
12988:	2CC3  CD242D  		CALL	GCCMP		;compare to min and least
12989:	2CC6  E1      		POP	HL		;restore next entry pointer to HL
12990:	2CC7  DAB82C  		JP	C,GARB2		;< min or >= least, try next
12991:	2CCA  EB      		EX	DE,HL
12992:	2CCB  22433D  		LD	(GCLST),HL	;else current becomes new least
12993:	2CCE  EB      		EX	DE,HL
12994:	2CCF  22453D  		LD	(GCLOC),HL	;and gcloc stores its address
12995:	2CD2  C3B82C  		JP	GARB2		;and try next
12996:			;All strings checked, must check if least was found.
12997:	2CD5  2A433D  	GARB4:	LD	HL,(GCLST)
12998:	2CD8  7C      		LD	A,H
12999:	2CD9  A5      		AND	L
13000:	2CDA  3C      		INC	A
13001:	2CDB  CAED2C  		JP	Z,GARB5		;no least found, string var compacting done
13002:			;Move the least string to the top of available string space.
13003:	2CDE  2A453D  		LD	HL,(GCLOC)
13004:	2CE1  2B      		DEC	HL
13005:	2CE2  2B      		DEC	HL
13006:	2CE3  2B      		DEC	HL		;point to length byte
13007:	2CE4  CD492D  		CALL	TPMOV		;move string temps pointing within string
13008:	2CE7  CD332D  		CALL	STMOV		;move the string
13009:	2CEA  C3AE2C  		JP	GARB1		;and continue compacting
13010:			;String vars compacted, now compact the string temps.
13011:	2CED  2A413D  	GARB5:	LD	HL,(GCMIN)
13012:	2CF0  2B      		DEC	HL
13013:	2CF1  223D3D  		LD	(STRPT),HL	;store new string var pointer
13014:	2CF4  2A3B3D  		LD	HL,(STRT)
13015:	2CF7  22433D  		LD	(GCLST),HL	;set GCLST for GCCMP
13016:	2CFA  21323D  		LD	HL,STEMP
13017:	2CFD  7E      		LD	A,(HL)		;fetch # temps in use
13018:	2CFE  3D      	GARB6:	DEC	A
13019:	2CFF  FA182D  		JP	M,GARB7		;all temps moved, garbage collection done
13020:	2D02  F5      		PUSH	AF		;save # temps still to move
13021:	2D03  CDF801  		CALL	MODEM		;fetch temp loc to DE
13022:	2D06  E5      		PUSH	HL
13023:	2D07  D5      		PUSH	DE		;save temp loc
13024:	2D08  EB      		EX	DE,HL
13025:	2D09  CDF801  		CALL	MODEM		;fetch loc of temporary to DE
13026:	2D0C  CD242D  		CALL	GCCMP		;compare to min and least
13027:	2D0F  E1      		POP	HL		;temp loc to HL
13028:	2D10  D4332D  		CALL	NC,STMOV	;move temp to base of avail space
13029:	2D13  E1      		POP	HL
13030:	2D14  F1      		POP	AF
13031:	2D15  C3FE2C  		JP	GARB6		;and look for more temps
13032:	2D18  2A413D  	GARB7:	LD	HL,(GCMIN)
13033:	2D1B  2B      		DEC	HL
13034:	2D1C  223F3D  		LD	(STRP2),HL	;store new top of string temp space
13035:	2D1F  EB      		EX	DE,HL
13036:	2D20  2A3B3D  		LD	HL,(STRT)	;and return string space top in HL
13037:	2D23  C9      		RET
13038:	2D24  2A413D  	GCCMP:	LD	HL,(GCMIN)
13039:	2D27  CD2902  		CALL	CMDHU
13040:	2D2A  D8      		RET	C		;location < min, try next
13041:	2D2B  2A433D  		LD	HL,(GCLST)
13042:	2D2E  CD2902  		CALL	CMDHU
13043:	2D31  3F      		CCF			;location >= least, try next
13044:	2D32  C9      		RET
13045:			
13046:			;STMOV moves a string during garbage collection.
13047:			;Call:	HL	pointer to string length byte
13048:			;	(GCMIN)	destination
13049:			;Retn:	(GCMIN)	next unused location in string space
13050:	2D33  5E      	STMOV:	LD	E,(HL)		;length to E
13051:	2D34  23      		INC	HL
13052:	2D35  E5      		PUSH	HL		;save location address
13053:	2D36  4E      		LD	C,(HL)
13054:	2D37  23      		INC	HL
13055:	2D38  46      		LD	B,(HL)		;location to BC
13056:	2D39  2A413D  		LD	HL,(GCMIN)	;destination to HL
13057:	2D3C  E5      		PUSH	HL		;and saved
13058:	2D3D  CD3437  		CALL	MOVD0		;move string in string space
13059:	2D40  22413D  		LD	(GCMIN),HL	;and store new min
13060:	2D43  D1      		POP	DE
13061:	2D44  E1      		POP	HL
13062:	2D45  73      		LD	(HL),E
13063:	2D46  23      		INC	HL
13064:	2D47  72      		LD	(HL),D		;and copy new loc to value
13065:	2D48  C9      		RET
13066:			
13067:			;TPMOV moves temporaries during garbage collection.
13068:	2D49  11323D  	TPMOV:	LD	DE,STEMP
13069:	2D4C  1A      		LD	A,(DE)		;fetch # temps in use
13070:	2D4D  3D      	TPMO1:	DEC	A
13071:	2D4E  F8      		RET	M		;no more temps to check
13072:	2D4F  E5      		PUSH	HL		;save string value location
13073:	2D50  E5      		PUSH	HL
13074:	2D51  EB      		EX	DE,HL
13075:	2D52  CDF801  		CALL	MODEM		;fetch ESTACK location of temp to DE
13076:	2D55  E3      		EX	(SP),HL		;save STEMP pointer, string value ptr to HL
13077:	2D56  F5      		PUSH	AF		;save # temps still to check
13078:	2D57  E5      		PUSH	HL		;and string value ptr
13079:	2D58  EB      		EX	DE,HL		;ESTACK temp loc to HL
13080:	2D59  CDF801  		CALL	MODEM		;fetch temp loc to DE
13081:	2D5C  E3      		EX	(SP),HL		;save string temp pointer, value ptr to HL
13082:	2D5D  D5      		PUSH	DE		;and save temp loc
13083:	2D5E  4E      		LD	C,(HL)		;length to C
13084:	2D5F  CDF801  		CALL	MODEM		;location to DE
13085:	2D62  0600    		LD	B,0
13086:	2D64  CD0802  		CALL	CPLDE		;- loc to DE
13087:	2D67  E1      		POP	HL		;temp loc to HL
13088:	2D68  19      		ADD	HL,DE		;temp loc - source loc
13089:	2D69  D27E2D  		JP	NC,TPMO2	;temp loc < source
13090:	2D6C  EB      		EX	DE,HL		;offset to DE
13091:	2D6D  0B      		DEC	BC		;length - 1 to BC
13092:	2D6E  CD2302  		CALL	CMBDU
13093:	2D71  DA7E2D  		JP	C,TPMO2		;length <= offset
13094:	2D74  2A413D  		LD	HL,(GCMIN)
13095:	2D77  19      		ADD	HL,DE		;destination + offset = new loc
13096:	2D78  EB      		EX	DE,HL		;to DE
13097:	2D79  E1      		POP	HL
13098:	2D7A  72      		LD	(HL),D
13099:	2D7B  2B      		DEC	HL
13100:	2D7C  73      		LD	(HL),E		;and to temp
13101:	2D7D  E5      		PUSH	HL
13102:	2D7E  E1      	TPMO2:	POP	HL
13103:	2D7F  F1      		POP	AF		;# temps still unchecked
13104:	2D80  D1      		POP	DE		;temp pointer
13105:	2D81  E1      		POP	HL		;value pointer
13106:	2D82  C34D2D  		JP	TPMO1		;and check the next temp
13107:			
13108:			;NXTST is used during garbage collection to find locations of nonnull strings.
13109:			;Call:	DE	next symbol table entry addr (initially SYMTA)
13110:			;	HL	next length byte in current entry (initially SYMTA)
13111:			;Retn:	Carry	Set iff no more nonnull strings
13112:			;	A	length of next nonnull string
13113:			;	BC	location of string
13114:			;	DE	next entry addr
13115:			;	HL	next length byte
13116:	2D85  CD2902  	NXTST:	CALL	CMDHU
13117:	2D88  C2A42D  		JP	NZ,NXTS3	;more in current entry
13118:	2D8B  CD4820  	NXTS1:	CALL	STNXT		;address next symbol table entry
13119:	2D8E  D8      		RET	C		;no more
13120:	2D8F  1A      		LD	A,(DE)		;fetch type byte
13121:	2D90  E61F    		AND	1FH		;mask to type
13122:	2D92  FE03    		CP	STRST
13123:	2D94  C28B2D  		JP	NZ,NXTS1	;not a string
13124:	2D97  EB      		EX	DE,HL		;next entry addr to DE
13125:	2D98  23      	NXTS2:	INC	HL		;point to next name byte
13126:	2D99  B6      		OR	(HL)
13127:	2D9A  F2982D  		JP	P,NXTS2		;scan past name
13128:	2D9D  23      		INC	HL		;point to # dims
13129:	2D9E  4E      		LD	C,(HL)		;# dims to C
13130:	2D9F  0600    		LD	B,0
13131:	2DA1  23      		INC	HL
13132:	2DA2  09      		ADD	HL,BC
13133:	2DA3  09      		ADD	HL,BC		;point to first length byte
13134:	2DA4  7E      	NXTS3:	LD	A,(HL)		;fetch length
13135:	2DA5  CDCD01  		CALL	MOBCM		;fetch location to BC
13136:	2DA8  23      		INC	HL		;point to next
13137:	2DA9  B7      		OR	A
13138:	2DAA  C0      		RET	NZ		;return unless null
13139:	2DAB  C3852D  		JP	NXTST		;else try next
13140:			
13141:			;EVUNQ gets a string value for READ or INPUT.  If the next item scanned
13142:			;EVALuates to a string value, its value is passed.  Otherwise the item is
13143:			;considered to be an unquoted string starting at the first nonblank and
13144:			;delimited by the next comma or cr, and a pointer to it is returned.
13145:			;Retn:	Carry	Set iff next nonblank char is delimiter
13146:			;	C, DE	length, location of string
13147:	2DAE  CD5A18  	EVUNQ:	CALL	GTCHA		;fetch first nonblank
13148:	2DB1  FE22    		CP	'"'
13149:	2DB3  CA9E19  		JP	Z,GTLIS		;quoted string literal
13150:	2DB6  CD6B18  		CALL	BAKUP		;let HL and TEXTP point to first
13151:	2DB9  CD4501  		CALL	DTST1
13152:	2DBC  3F      		CCF
13153:	2DBD  D8      		RET	C		;first nonblank is delimiter, return Carry
13154:	2DBE  54      		LD	D,H
13155:	2DBF  5D      		LD	E,L		;first nonblank loc to DE
13156:	2DC0  FE2C    	EVUN1:	CP	','
13157:	2DC2  CAA319  		JP	Z,GTLS1		;done if next is comma
13158:	2DC5  CD4501  		CALL	DTST1
13159:	2DC8  D2A319  		JP	NC,GTLS1	;or if next is cr or '
13160:	2DCB  CD7718  		CALL	READ1		;else read the current
13161:	2DCE  7E      		LD	A,(HL)		;and fetch next
13162:	2DCF  C3C02D  		JP	EVUN1		;and continue scanning
13163:			
13164:			;CMSTR compares two strings.
13165:			;Call:	B	length of string 2
13166:			;	C	length of string 1
13167:			;	DE	location of string 1
13168:			;	HL	location of string 2
13169:			;Retn:	Carry	Set iff string 1 < string 2
13170:			;	Zero	Set iff string 1 = string 2
13171:	2DD2  79      	CMSTR:	LD	A,C
13172:	2DD3  B7      		OR	A
13173:	2DD4  CAE62D  		JP	Z,CMST1		;end of string 1
13174:	2DD7  78      		LD	A,B
13175:	2DD8  B7      		OR	A
13176:	2DD9  CAE82D  		JP	Z,CMST2		;end of string 2
13177:	2DDC  1A      		LD	A,(DE)		;else fetch string 1 char
13178:	2DDD  BE      		CP	(HL)		;compare to string 2
13179:	2DDE  C0      		RET	NZ		;unequal
13180:	2DDF  05      		DEC	B
13181:	2DE0  0D      		DEC	C		;decrement lengths
13182:	2DE1  13      		INC	DE
13183:	2DE2  23      		INC	HL		;increment pointers
13184:	2DE3  C3D22D  		JP	CMSTR		;and continue checking
13185:	2DE6  B8      	CMST1:	CP	B
13186:	2DE7  C9      		RET
13187:	2DE8  F601    	CMST2:	OR	1		;clear Carry and Zero
13188:	2DEA  C9      		RET
13189:			
13190:			;SIARG is called by LEFT$, RIGHT$ and MID$ to manipulate arguments.
13191:			;Call:	BC,DE	arg1 (string), arg2 (integer) pointers
13192:			;Retn:	A	arg2, 0 if < 0 and 255 if > 255 (with nonfatal FC error)
13193:			;	C, DE	string length and location
13194:			;SIAR0 is called by INST3 and MID3 to fetch integer arg 0 <= arg <= 255.
13195:	2DEB  CD220C  	SIAR0:	CALL	CNVBI		;force to integer and fetch
13196:	2DEE  60      		LD	H,B
13197:	2DEF  69      		LD	L,C
13198:	2DF0  C3FB2D  		JP	SIAR1		;force 0 <= arg <= 255 to A
13199:	2DF3  D5      	SIARG:	PUSH	DE		;save integer arg2
13200:	2DF4  CDB801  		CALL	FETBC		;fetch string arg1 to C, DE
13201:	2DF7  D21D0C  		JP	NC,TMERR	;fatal TM error if nonstring
13202:	2DFA  E1      		POP	HL		;arg2 to HL
13203:	2DFB  7C      	SIAR1:	LD	A,H		;MID3 entry point
13204:	2DFC  B7      		OR	A
13205:	2DFD  7D      		LD	A,L		;lsbyte of arg2 to A
13206:	2DFE  C8      		RET	Z		;done if 0 <= arg2 <= 255
13207:	2DFF  CD8C13  		CALL	FCERN		;else issue nonfatal FC error
13208:	2E02  7C      		LD	A,H
13209:	2E03  B7      		OR	A
13210:	2E04  3E00    		LD	A,0
13211:	2E06  F8      		RET	M		;and return 0 if < 0
13212:	2E07  3D      		DEC	A		;else return 255
13213:	2E08  C9      		RET
13214:			
13215:			
13216:			;string functions follow
13217:			
13218:			;Concatenation (+): <string> x <string> --> <string>
13219:	2E09  78      	SADD:	LD	A,B
13220:	2E0A  B7      		OR	A
13221:	2E0B  CA422E  		JP	Z,SADD3		;string 2 null, return s1
13222:	2E0E  79      		LD	A,C
13223:	2E0F  B7      		OR	A
13224:	2E10  CA402E  		JP	Z,SADD2		;string 1 null, return s2
13225:	2E13  80      		ADD	A,B		;else find length of concatenation
13226:	2E14  D2202E  		JP	NC,SADD1	;not too long
13227:	2E17          		ERROR	N, L, S		;issue nonfatal LS error
13228:	2E1C  79      		LD	A,C
13229:	2E1D  2F      		CPL
13230:	2E1E  47      		LD	B,A		;useable length of s2 = 255 - length of s1
13231:	2E1F  81      		ADD	A,C		;length of concatenation to A
13232:	2E20  F5      	SADD1:	PUSH	AF		;save length
13233:	2E21  21323D  		LD	HL,STEMP
13234:	2E24  34      		INC	(HL)
13235:	2E25  34      		INC	(HL)		;reassign string temporaries
13236:	2E26  CD7F2C  		CALL	STFRE		;assure sufficient space available
13237:	2E29  2A5B3E  		LD	HL,(ESTKP)
13238:	2E2C  23      		INC	HL		;address s1 ESTACK entry
13239:	2E2D  E5      		PUSH	HL
13240:	2E2E  CD472C  		CALL	SCOP0		;fetch and copy to string space
13241:	2E31  E1      		POP	HL
13242:	2E32  D5      		PUSH	DE		;save location of copied s1
13243:	2E33  110700  		LD	DE,VBYTS+2
13244:	2E36  19      		ADD	HL,DE		;address s2 ESTACK entry
13245:	2E37  CD472C  		CALL	SCOP0		;fetch and copy to string space
13246:	2E3A  D1      		POP	DE		;result location to DE
13247:	2E3B  F1      		POP	AF
13248:	2E3C  4F      		LD	C,A		;result length to C
13249:	2E3D  3E03    		LD	A,STRST		;result type to A
13250:	2E3F  C9      		RET
13251:	2E40  48      	SADD2:	LD	C,B		;length of s2 to C
13252:	2E41  EB      		EX	DE,HL		;and loc to DE
13253:	2E42  3E03    	SADD3:	LD	A,STRST
13254:	2E44  C9      		RET
13255:			
13256:			;INSTR: [<integer> x] <string> x <string> --> <integer>
13257:	2E45  210100  	INSTR:	LD	HL,1		;default arg0 value to HL
13258:	2E48  E5      	INST0:	PUSH	HL		;save first to test -- INST3 entry point
13259:	2E49  2B      		DEC	HL
13260:	2E4A  E5      		PUSH	HL		;save first-1
13261:	2E4B  CDB512  		CALL	AMBOP		;fetch matching args
13262:	2E4E  D21D0C  		JP	NC,TMERR	;nonstrings
13263:	2E51  E3      		EX	(SP),HL		;save s1 location, first-1 to HL
13264:	2E52  EB      		EX	DE,HL
13265:	2E53  19      		ADD	HL,DE		;s2 loc + first - 1 = s2 remaining loc to HL
13266:	2E54  79      		LD	A,C
13267:	2E55  48      		LD	C,B
13268:	2E56  93      		SUB	E		;s2 length + first - 1 = s2 remaining length
13269:	2E57  D1      		POP	DE
13270:	2E58  DA792E  		JP	C,INST2		;s2 too short, return 0
13271:	2E5B  CA792E  		JP	Z,INST2		;s2 rem null, return 0
13272:	2E5E  47      		LD	B,A		;s2 rem len to B
13273:			;At INST1 B=s2 rem len, C=s1 len, DE=s1 loc, HL=s2 rem loc, stack=result
13274:	2E5F  78      	INST1:	LD	A,B
13275:	2E60  B9      		CP	C
13276:	2E61  DA792E  		JP	C,INST2		;remaining part of s2 too short, return 0
13277:	2E64  C5      		PUSH	BC
13278:	2E65  D5      		PUSH	DE
13279:	2E66  E5      		PUSH	HL
13280:	2E67  41      		LD	B,C		;set lengths equal for string compare
13281:	2E68  CDD22D  		CALL	CMSTR		;compare s1 to LEFT$(rem s2,LEN(s1))
13282:	2E6B  E1      		POP	HL
13283:	2E6C  D1      		POP	DE
13284:	2E6D  C1      		POP	BC
13285:	2E6E  CA9509  		JP	Z,POP1		;matched, pop result to BC and return
13286:	2E71  05      		DEC	B		;else decr s2 rem len
13287:	2E72  23      		INC	HL		;and incr s2 rem loc
13288:	2E73  E3      		EX	(SP),HL
13289:	2E74  23      		INC	HL		;and incr proto result
13290:	2E75  E3      		EX	(SP),HL
13291:	2E76  C35F2E  		JP	INST1		;and try again
13292:	2E79  C1      	INST2:	POP	BC
13293:	2E7A  010000  		LD	BC,0
13294:	2E7D  C9      		RET
13295:			;INST3 executes ternary INSTR.
13296:	2E7E  D5      	INST3:	PUSH	DE		;save arg2
13297:	2E7F  E5      		PUSH	HL		;and arg3
13298:	2E80  CDEB2D  		CALL	SIAR0		;force 0 <= arg3 <= 255 to A
13299:	2E83  6F      		LD	L,A
13300:	2E84  2600    		LD	H,0		;arg3 to HL
13301:	2E86  B7      		OR	A
13302:	2E87  CCB312  		CALL	Z,INXH		;fudge value 0 to 1
13303:	2E8A  D1      		POP	DE
13304:	2E8B  C1      		POP	BC		;restore args
13305:	2E8C  CD482E  		CALL	INST0		;perform INSTR
13306:	2E8F  3E01    		LD	A,INTST		;and return type integer
13307:	2E91  C9      		RET
13308:			
13309:			;BIN$:	<integer> --> <string>
13310:	2E92  210110  	BINFN:	LD	HL,(16 SHL 8) OR 1;16 digits, 1 bit each
13311:	2E95  C39B2E  		JP	HEXF0
13312:			
13313:			;HEX$:	<integer> --> <string>
13314:	2E98  210404  	HEXFN:	LD	HL,(4 SHL 8) OR 4;4 digits, 4 bits each
13315:			;HEXF0 is called by BIN$ and OCT$ to convert to string.
13316:			;	BC	integer value to convert
13317:			;	H	max digit count
13318:			;	L	nummber of bits per digit
13319:	2E9B  11603E  	HEXF0:	LD	DE,BUFAD+1	;destination to DE
13320:	2E9E  C5      		PUSH	BC		;save arg
13321:	2E9F  44      		LD	B,H		;remaining digit count to B
13322:	2EA0  2600    		LD	H,0		;to suppress leading 0s
13323:	2EA2  4D      	HEXF1:	LD	C,L		;shift count to C -- OCT$ entry point
13324:	2EA3  E3      		EX	(SP),HL		;save status & count, get value
13325:	2EA4  AF      		XOR	A		;build result digit in A
13326:	2EA5  29      	HEXF2:	ADD	HL,HL		;shift arg left
13327:	2EA6  17      		RLA			;Carry to A0
13328:	2EA7  0D      		DEC	C
13329:	2EA8  C2A52E  		JP	NZ,HEXF2	;shift more bits
13330:	2EAB  C690    		ADD	A,90H		;90H, ..., 99H, 9AH, ..., 9FH
13331:	2EAD  27      		DAA			;90H, ..., 99H, 00H+C,...,05H+C
13332:	2EAE  CE40    		ADC	A,40H		;D0H, ..., D9H, 41H, ..., 46H
13333:	2EB0  27      		DAA			;30H, ..., 39H, 41H, ..., 46H
13334:	2EB1  12      		LD	(DE),A		;store ASCII digit
13335:	2EB2  13      		INC	DE
13336:	2EB3  05      		DEC	B
13337:	2EB4  CAC32E  		JP	Z,HEXF4		;done
13338:	2EB7  E3      		EX	(SP),HL		;save value, get status
13339:	2EB8  D630    		SUB	'0'		;Zero set iff digit is 0
13340:	2EBA  B4      		OR	H		;Zero set iff leading 0
13341:	2EBB  67      		LD	H,A		;save leading 0 status
13342:	2EBC  C2A22E  		JP	NZ,HEXF1	;not a leading 0, do not suppress
13343:	2EBF  1B      		DEC	DE		;suppress it
13344:	2EC0  C3A22E  		JP	HEXF1
13345:	2EC3  C1      	HEXF4:	POP	BC		;discard saved status
13346:	2EC4  215F3E  		LD	HL,BUFAD
13347:	2EC7  3620    		LD	(HL),' '	;store first char = <space>
13348:	2EC9  EB      		EX	DE,HL		;first loc to DE, last+1 to HL
13349:	2ECA  7D      		LD	A,L
13350:	2ECB  93      		SUB	E		;compute length
13351:	2ECC  4F      		LD	C,A		;length to C
13352:	2ECD  C34A2C  		JP	SCOPY		;copy to string space and return
13353:			
13354:			;OCT$:	<integer> --> <string>
13355:	2ED0  60      	OCTFN:	LD	H,B
13356:	2ED1  69      		LD	L,C		;arg to HL
13357:	2ED2  29      		ADD	HL,HL		;shift left one bit, Carry iff leading 1
13358:	2ED3  44      		LD	B,H
13359:	2ED4  4D      		LD	C,L		;shifted arg to BC
13360:	2ED5  210305  		LD	HL,(5 SHL 8) OR 3;5 digits, 3 bits each
13361:	2ED8  D29B2E  		JP	NC,HEXF0	;high bit 0, so just do as in HEX$
13362:	2EDB  11603E  		LD	DE,BUFAD+1
13363:	2EDE  3E31    		LD	A,'1'
13364:	2EE0  12      		LD	(DE),A		;store leading ASCII 1
13365:	2EE1  13      		INC	DE
13366:	2EE2  C5      		PUSH	BC		;save arg
13367:	2EE3  44      		LD	B,H		;repeat count to B
13368:	2EE4  C3A22E  		JP	HEXF1		;leave H nonzero to retain 0s
13369:			
13370:			;STR$: {<integer> | <floating>} --> <string>
13371:	2EE7          	STRS:
13372:	FFFF          		IF	FLOAT		;<floating> --> <string>
13373:	2EE7  CDA80D  		CALL	FOUT		;convert floating value to string
13374:				ELSE			;<integer> --> <string>
13382:				ENDIF
13383:	2EEA  C34A2C  		JP	SCOPY		;copy to string space and return
13384:			
13385:			;VAL: <string> --> {<integer> | <floating>}
13386:	2EED  CDB801  	VAL:	CALL	FETBC		;fetch the arg
13387:	2EF0  0C      		INC	C		;bump length
13388:	2EF1  C2F52E  		JP	NZ,VAL1
13389:	2EF4  0D      		DEC	C		;length was 255, unincrement
13390:	2EF5  CD4A2C  	VAL1:	CALL	SCOPY		;make new copy with extra char
13391:	2EF8  360D    		LD	(HL),CR		;last char is cr
13392:	2EFA  EB      		EX	DE,HL		;location to HL
13393:	2EFB  22523E  		LD	(TXTP2),HL	;and to TXTP2 for FLIP
13394:	2EFE  CD3702  		CALL	FLIP		;let TEXTP scan the string
13395:	2F01  CD5919  		CALL	GTLIT		;look for a literal
13396:	2F04  F5      		PUSH	AF
13397:	2F05  C5      		PUSH	BC
13398:	2F06  D5      		PUSH	DE		;and save result of GTLIT
13399:	2F07  CD5A18  		CALL	GTCHA		;get first char after literal
13400:	2F0A  CD3702  		CALL	FLIP		;restore TEXTP
13401:	2F0D  67      		LD	H,A		;first char after lit to H
13402:	2F0E  D1      		POP	DE
13403:	2F0F  C1      		POP	BC
13404:	2F10  F1      		POP	AF		;recover result of GTLIT
13405:	2F11  6F      		LD	L,A
13406:	2F12  7C      		LD	A,H
13407:	2F13  FE0D    		CP	CR		;check if next after lit was cr
13408:	2F15  7D      		LD	A,L
13409:	2F16  C20615  		JP	NZ,FCER0	;FC error if not
13410:	2F19  FE01    		CP	INTST		;check if type integer
13411:	2F1B  C8      		RET	Z		;yes, return
13412:	FFFF          		IF	FLOAT
13413:	2F1C  FE02    		CP	SNGST
13414:	2F1E  C20615  		JP	NZ,FCER0	;not floating nor integer, FC error
13415:	2F21  21503E  		LD	HL,TEMP
13416:	2F24  5E      		LD	E,(HL)		;restore saved value for A to E if floating
13417:	2F25  C9      		RET
13418:				ENDIF
13419:			
13420:			;ASC: <string> --> <integer>
13421:	2F26  CD312F  	ASC:	CALL	LEN		;fetch string arg, 0 to B
13422:	2F29  79      		LD	A,C		;length to A
13423:	2F2A  B7      		OR	A		;check length
13424:	2F2B  CA0615  		JP	Z,FCER0		;null, nonfatal FC error and return 0
13425:	2F2E  1A      		LD	A,(DE)		;else fetch character
13426:	2F2F  4F      		LD	C,A
13427:	2F30  C9      		RET
13428:			
13429:			;LEN: <string> --> <integer>
13430:	2F31  CDB801  	LEN:	CALL	FETBC		;fetch string arg
13431:	2F34  0600    		LD	B,0		;return length in BC
13432:	2F36  C9      		RET
13433:			
13434:			;CHR$: <integer> --> <string>
13435:	2F37  CDFD01  	CHRS:	CALL	ISBYT		;arg must be byte expr
13436:	2F3A  79      		LD	A,C		;value to A
13437:	2F3B  11503E  	CHRS1:	LD	DE,TEMP
13438:	2F3E  12      		LD	(DE),A		;save in TEMP
13439:	2F3F  0E01    		LD	C,1		;length is 1
13440:	2F41  C34A2C  		JP	SCOPY		;and copy to string space
13441:			
13442:			;LEFT$: <string> x <integer> --> <string>
13443:	2F44  CDF32D  	LEFTS:	CALL	SIARG		;args to A, CDE
13444:	2F47  B9      	LEFT1:	CP	C
13445:	2F48  D0      		RET	NC		;arg >= length, return unchanged
13446:	2F49  4F      		LD	C,A		;else arg becomes new length
13447:	2F4A  C9      		RET
13448:			
13449:			;RIGHT$: <string> x <integer> --> <string>
13450:	2F4B  CDF32D  	RIGHT:	CALL	SIARG
13451:	2F4E  B9      	RIGH1:	CP	C
13452:	2F4F  D0      		RET	NC		;arg >= length, return unchanged
13453:	2F50  0D      		DEC	C
13454:	2F51  13      		INC	DE		;else chop off head char
13455:	2F52  C34E2F  		JP	RIGH1		;and try again
13456:			
13457:			;MID$: <string> x <integer> [x <integer>] --> <string>
13458:	2F55  3EFF    	MIDS:	LD	A,255		;default arg3 value to A
13459:	2F57  F5      	MID0:	PUSH	AF		;MID3 entry point
13460:	2F58  CDF32D  		CALL	SIARG
13461:	2F5B  E1      		POP	HL		;arg3 to H
13462:	2F5C  B7      		OR	A
13463:	2F5D  CA692F  		JP	Z,MID2		;arg2 is 0, just do LEFT$
13464:	2F60  0C      		INC	C
13465:	2F61  1B      		DEC	DE		;add bogus head char
13466:	2F62  13      	MID1:	INC	DE
13467:	2F63  0D      		DEC	C		;lop off head
13468:	2F64  C8      		RET	Z		;return if null
13469:	2F65  3D      		DEC	A		;and decrease arg2
13470:	2F66  C2622F  		JP	NZ,MID1
13471:	2F69  7C      	MID2:	LD	A,H
13472:	2F6A  C3472F  		JP	LEFT1		;and do a LEFT$ with arg3
13473:	2F6D  C5      	MID3:	PUSH	BC		;save arg1
13474:	2F6E  42      		LD	B,D
13475:	2F6F  4B      		LD	C,E		;arg2 to BC
13476:	2F70  CD220C  		CALL	CNVBI		;convert to integer and fetch
13477:	2F73  C5      		PUSH	BC		;and save arg2
13478:	2F74  44      		LD	B,H
13479:	2F75  4D      		LD	C,L
13480:	2F76  CDEB2D  		CALL	SIAR0		;force 0 <= arg3 <= 255 to A
13481:	2F79  D1      		POP	DE		;arg2 value to DE
13482:	2F7A  C1      		POP	BC		;and arg1 addr to BC
13483:	2F7B  CD572F  		CALL	MID0		;do the MID$
13484:	2F7E  3E03    		LD	A,STRST		;and return type string
13485:	2F80  C9      		RET
13486:			
13487:	0000          		IF	REALT
13526:				ENDIF			;end of REALT conditional
13527:			
13528:			
13529:				ENDIF			;end of STRNG conditional
13530:			
13531:			
13532:			;end of STRINGS
13534:			;TABLES 01/12/81
13535:			;XYBASIC Interpreter Source Module
13536:			;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
13537:			;tables
13538:			
13539:			
13540:			;symbol table type token EQUates
13541:	0001          	INTST	EQU	1		;integer variable
13542:	0002          	SNGST	EQU	2		;single precision floating point variable
13543:	0003          	STRST	EQU	3		;string variable
13544:	0004          	UFNST	EQU	4		;user-defined function
13545:	0005          	BRKST	EQU	5		;break entry
13546:	0006          	CAMST	EQU	6		;camac variable
13547:			
13548:			;control stack token EQUates
13549:	0025          	CSGOS	EQU	25H		;gosub
13550:	004F          	CSFOR	EQU	47H+2*FBYTS	;for
13551:	0065          	CSBRK	EQU	65H		;break (and stop)
13552:	0087          	CSINT	EQU	87H		;interrupt
13553:	00A5          	CSLBK	EQU	0A5H		;line break
13554:			
13555:			;expr stack type byte EQUates
13556:	00F0          	TMASK	EQU	0F0H		;type mask
13557:	000F          	PMASK	EQU	00FH		;precedence mask
13558:			;first characters
13559:	0010          	ISDEL	EQU	10H		;delimiter
13560:	0020          	ISLP	EQU	20H		;left parenthesis
13561:	0030          	ISRP	EQU	30H		;right parenthesis
13562:	0040          	ISCOM	EQU	40H		;comma
13563:			;then 0-ary and user-defined functions
13564:	0050          	ISFN0	EQU	50H		;0-ary function
13565:	0060          	ISUFN	EQU	60H		;user-defined function
13566:			;then ops and fns, op1 first
13567:	0070          	ISOP1	EQU	70H		;unary op
13568:	0080          	ISOP2	EQU	80H		;binary op
13569:	0090          	ISFN1	EQU	90H		;unary function
13570:	00A0          	ISFN2	EQU	0A0H		;binary function
13571:			
13572:			;branch addresses for command execution, in order of table position
13573:	2F81  2D27    	CMDTA:	DEFW	LET
13574:	2F83  7E26    		DEFW	IFCOM
13575:	2F85  B525    		DEFW	FOR
13576:	2F87  9027    		DEFW	NEXT
13577:	2F89  6F26    		DEFW	GOTO
13578:	2F8B  6626    		DEFW	GOSUB
13579:	2F8D  B928    		DEFW	PRINT
13580:	2F8F  9426    		DEFW	INPUT
13581:	2F91  9329    		DEFW	READ
13582:	2F93  DE2A    		DEFW	RETRN
13583:	2F95  E122    		DEFW	DEF
13584:	2F97  1C24    		DEFW	DIM
13585:	2F99  B718    		DEFW	GTDEL
13586:	2F9B  CA2A    		DEFW	RESTR
13587:	2F9D  772B    		DEFW	STOP
13588:	2F9F  AD25    		DEFW	ENDCM
13589:	FFFF          		IF	NOT WILD
13590:	2FA1  5728    		DEFW	NULL
13591:				ENDIF
13592:	2FA3  6622    		DEFW	CALCM
13593:	2FA5  1F2B    		DEFW	SCALL
13594:	FFFF          		IF	NOT WILD
13595:	2FA7  A028    		DEFW	PUT
13596:	2FA9  AE28    		DEFW	POKE
13597:	2FAB  102C    		DEFW	WAIT
13598:				ENDIF
13599:	2FAD  CF2B    		DEFW	TCOFF
13600:	2FAF  CE2B    		DEFW	TCON
13601:	2FB1  D42B    		DEFW	TPOFF
13602:	2FB3  D52B    		DEFW	TPON
13603:	2FB5  DE21    		DEFW	BREAK
13604:	2FB7  DA2B    		DEFW	UNBRK
13605:	FFFF          		IF	NOT WILD
13606:	2FB9  7925    		DEFW	ENABL
13607:	2FBB  AB24    		DEFW	DSABL
13608:	2FBD  8A29    		DEFW	RNDIZ
13609:				ENDIF
13610:	2FBF  F129    		DEFW	REM
13611:	2FC1  7323    		DEFW	DELAY
13612:	2FC3  9B04    		DEFW	SAVE
13613:	2FC5  3105    		DEFW	LOAD
13614:	2FC7  3927    		DEFW	LISTM
13615:	2FC9  6F22    		DEFW	CLEAR
13616:	2FCB  6727    		DEFW	NEWCM
13617:	2FCD  022B    		DEFW	RUN
13618:	2FCF  BE22    		DEFW	CONT
13619:	FFFF          		IF	NOT CAMAC
13620:	2FD1  7721    		DEFW	AUTO
13621:	2FD3  D423    		DEFW	DELET
13622:	2FD5  0725    		DEFW	EDIT
13623:	2FD7  062A    		DEFW	RENUM
13624:				ENDIF
13625:	FFFF          		IF	NOT WILD
13626:	2FD9  3A01    		DEFW	MOVE
13627:				ENDIF
13628:	2FDB  3A01    		DEFW	EXEC
13629:	0000          		IF	EPSTN
13631:				ENDIF
13632:	FFFF          		IF	SDISK AND NOT C3885
13633:	2FDD  B11D    		DEFW	OPEN
13634:	2FDF  F71B    		DEFW	CLOSE
13635:	2FE1  2D1D    		DEFW	LINPT
13636:	2FE3  901D    		DEFW	MARGN
13637:	0000          		IF	BENDX
13641:				ELSE
13642:	2FE5  421C    		DEFW	DIRCM
13643:	2FE7  E61E    		DEFW	SCRAT
13644:				ENDIF
13645:				ENDIF
13646:	0000          		IF	BENDX
13648:				ENDIF
13649:	0000          		IF	CAMAC
13673:				ELSE
13674:	0000          		IF	WILD
13676:				ELSE
13677:	2FE9  4D21    		DEFW	ASSIG
13678:				ENDIF
13679:	0000          		IF	REALT
13681:				ELSE
13682:	2FEB  9D2B    		DEFW	TIME
13683:				ENDIF
13684:				ENDIF
13685:	0000          		IF	PACKI
13689:				ENDIF
13690:	2FED  5F28    		DEFW	ON		;must follow ONLINE
13691:			
13692:			;type / precedence bytes for functions and ops
13693:			;ms four bits type, ls four bits precedence
13694:	2FEF  60      	TYPTA:	DEFB	ISUFN		;fn
13695:	2FF0  76      		DEFB	ISOP1 + 6	;not
13696:	2FF1  8888    		DEFB	ISOP2 + 8, ISOP2 + 8;+, -
13697:	2FF3  8989    		DEFB	ISOP2 + 9, ISOP2 + 9;*, /
13698:	FFFF          		IF	FLOAT
13699:	2FF5  898A    		DEFB	ISOP2 + 9, ISOP2 + 10;\, ^
13700:				ENDIF
13701:	2FF7  87878787		DEFB	ISOP2 + 7, ISOP2 + 7, ISOP2 + 7, ISOP2 + 7, ISOP2 + 7
	      87
13702:	2FFC  878787  		DEFB	ISOP2 + 7, ISOP2 + 7, ISOP2 + 7;relations
13703:	2FFF  858484  		DEFB	ISOP2 + 5, ISOP2 + 4, ISOP2 + 4;and, xor, or
13704:	3002  89      		DEFB	ISOP2 + 9	;mod
13705:	FFFF          		IF	NOT WILD
13706:	3003  8B      		DEFB	ISOP2 + 11	;join
13707:				ENDIF
13708:	3004  5050    		DEFB	ISFN0, ISFN0	;get, fre
13709:	FFFF          		IF	NOT WILD
13710:	FFFF          		IF	FLOAT
13711:	3006  92      		DEFB	ISFN1+2		;rnd
13712:				ELSE
13714:				ENDIF
13715:				ENDIF
13716:	0000          		IF	WILD
13718:				ELSE
13719:	FFFF          		IF	NOT CAMAC
13720:	3007  50      		DEFB	ISFN0		;pos
13721:				ENDIF
13722:	3008  5050    		DEFB	ISFN0, ISFN0	;first, last
13723:				ENDIF
13724:	0000          		IF	PACKI
13726:				ENDIF
13727:	FFFF          		IF	SDISK AND NOT C3885
13728:	300A  92      		DEFB	ISFN1+2		;eof
13729:				ENDIF
13730:	FFFF          		IF	FLOAT
13731:	FFFF          		IF	NOT WILD
13732:	300B  92      		DEFB	ISFN1 + 2	;UNS
13733:				ENDIF
13734:	300C  92929292		DEFB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2, ISFN1 + 2
13735:	3010  929292  		DEFB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2;unary functions
13736:	FFFF          		IF	NOT CAMAC
13737:	3013  92      		DEFB	ISFN1 + 2	;ATN
13738:				ENDIF
13739:				ENDIF
13740:	FFFF          		IF	STRNG
13741:	3014  92929292		DEFB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2, ISFN1 + 2
13742:	3018  92929292		DEFB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2, ISFN1 + 2
13743:	301C  A2A2A2A2		DEFB	ISFN2 + 2, ISFN2 + 2, ISFN2 + 2, ISFN2 + 2
13744:				ENDIF
13745:	0000          		IF	CAMAC
13752:				ELSE
13753:	FFFF          		IF	NOT WILD
13754:	3020  50      		DEFB	ISFN0		;iobyte
13755:				ENDIF
13756:	0000          		IF	REALT
13759:				ENDIF
13760:				ENDIF
13761:	3021  9292    		DEFB	ISFN1 + 2, ISFN1 + 2
13762:	FFFF          		IF	NOT WILD
13763:	3023  9292    		DEFB	ISFN1 + 2, ISFN1 + 2
13764:	3025  929292  		DEFB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2;unary functions
13765:	3028  A2A2A2A2		DEFB	ISFN2 + 2, ISFN2 + 2, ISFN2 + 2, ISFN2 + 2, ISFN2 + 2
	      A2
13766:	302D  A2A2    		DEFB	ISFN2 + 2, ISFN2 + 2;binary functions
13767:	302F  92      		DEFB	ISFN1 + 2	;in
13768:				ENDIF
13769:			
13770:			;argument and result type information table for fns and ops
13771:			;FN is a macro building a five-byte table entry for a function.
13772:			;The first byte gives the type of arg2.
13773:			;The second byte gives the type of arg1.
13774:			;The third and fourth bytes give the function address.
13775:			;The fifth byte gives the type of the result.
13776:			;Unused arguments are indicated by 0, ambiguous entries by AMBST.
13777:			;E.g.:	fn	sgn, ambst, 0, intst
13778:			;indicates that the routine to compute SGN is at location SGN, the first arg
13779:			;ambiguous (integer or float), no second arg, and the result integer.
13780:	0000          	AMBST	EQU	0
13781:			FN	MACRO	ADDR, A1TYP, A2TYP, RTYPE
13782:				DEFB	A2TYP, A1TYP
13783:				DEFW	ADDR
13784:				DEFB	RTYPE
13785:				ENDM
13786:			;NB unary minus first, in place of fn
13787:	3030          	FUNTA:	FN	AUMIN, AMBST, 0, AMBST
13788:	3035          		FN	OPNOT, INTST, 0, INTST
13789:	303A          		FN	AADD, AMBST, AMBST, AMBST
13790:	303F          		FN	ASUB, AMBST, AMBST, AMBST
13791:	3044          		FN	AMUL, AMBST, AMBST, AMBST
13792:	FFFF          		IF	FLOAT
13793:	3049          		FN	FDIVD, SNGST, SNGST, SNGST	;floating
13794:	304E          		FN	IDIVD, INTST, INTST, INTST	;integer
13795:	3053          		FN	FATOX, SNGST, SNGST, SNGST
13796:				ELSE
13798:				ENDIF
13799:	3058          		FN	LEQ, AMBST, AMBST, INTST
13800:	305D          		FN	LEQ, AMBST, AMBST, INTST
13801:	3062          		FN	GEQ, AMBST, AMBST, INTST
13802:	3067          		FN	GEQ, AMBST, AMBST, INTST
13803:	306C          		FN	NEQ, AMBST, AMBST, INTST
13804:	3071          		FN	EQUAL, AMBST, AMBST, INTST
13805:	3076          		FN	LTHAN, AMBST, AMBST, INTST
13806:	307B          		FN	GTHAN, AMBST, AMBST, INTST
13807:	3080          		FN	OPAND, INTST, INTST, INTST
13808:	3085          		FN	OPXOR, INTST, INTST, INTST
13809:	308A          		FN	OPOR, INTST, INTST, INTST
13810:	308F          		FN	OPMOD, INTST, INTST, INTST
13811:	FFFF          		IF	NOT WILD
13812:	3094          		FN	JOIN, INTST, INTST, INTST
13813:				ENDIF
13814:	3099          		FN	GET, 0, 0, AMBST
13815:	309E          		FN	FREFN, 0, 0, INTST
13816:	FFFF          		IF	NOT WILD
13817:	FFFF          		IF	FLOAT
13818:	30A3          		FN	RND, SNGST, 0, SNGST
13819:				ELSE
13821:				ENDIF
13822:				ENDIF
13823:	0000          		IF	WILD
13825:				ELSE
13826:	FFFF          		IF	NOT CAMAC
13827:	30A8          		FN	POS, 0, 0, INTST
13828:				ENDIF
13829:	30AD          		FN	FIRST, 0, 0, INTST
13830:	30B2          		FN	LAST, 0, 0, INTST
13831:				ENDIF
13832:	0000          		IF	PACKI
13834:				ENDIF
13835:	FFFF          		IF	SDISK AND NOT C3885
13836:	30B7          		FN	EOFFN, INTST, 0, INTST
13837:				ENDIF
13838:	FFFF          		IF	FLOAT
13839:	FFFF          		IF	NOT WILD
13840:	30BC          		FN	UNSFN, INTST, 0, SNGST
13841:				ENDIF
13842:	0000          		IF	F9511
13844:				ELSE
13845:	30C1          		FN	INT, SNGST, 0, AMBST
13846:				ENDIF
13847:	30C6          		FN	FSQR, SNGST, 0, SNGST
13848:	30CB          		FN	FEXP, SNGST, 0, SNGST
13849:	30D0          		FN	FLN, SNGST, 0, SNGST
13850:	30D5          		FN	FSIN, SNGST, 0, SNGST
13851:	30DA          		FN	FCOS, SNGST, 0, SNGST
13852:	30DF          		FN	FTAN, SNGST, 0, SNGST
13853:	FFFF          		IF	NOT CAMAC
13854:	30E4          		FN	FATAN, SNGST, 0, SNGST
13855:				ENDIF
13856:				ENDIF
13857:	FFFF          		IF	STRNG
13858:	30E9          		FN	BINFN, INTST, 0, STRST
13859:	30EE          		FN	HEXFN, INTST, 0, STRST
13860:	30F3          		FN	OCTFN, INTST, 0, STRST
13861:	30F8          		FN	CHRS, INTST, 0, STRST
13862:	FFFF          		IF	FLOAT
13863:	30FD          		FN	STRS, SNGST, 0, STRST
13864:				ELSE
13866:				ENDIF
13867:	3102          		FN	ASC, STRST, 0, INTST
13868:	3107          		FN	LEN, STRST, 0, INTST
13869:	310C          		FN	VAL, STRST, 0, AMBST
13870:	3111          		FN	LEFTS, STRST, INTST, STRST
13871:	3116          		FN	RIGHT, STRST, INTST, STRST
13872:	311B          		FN	MIDS, STRST, INTST, STRST
13873:	3120          		FN	INSTR, AMBST, STRST, INTST
13874:				ENDIF
13875:	0000          		IF	CAMAC
13883:				ELSE
13884:	FFFF          		IF	NOT WILD
13885:	3125          		FN	IOBYF, 0, 0, INTST
13886:				ENDIF
13887:	0000          		IF	REALT
13890:				ENDIF
13891:				ENDIF
13892:	312A          		FN	SGN, AMBST, 0, INTST
13893:	312F          		FN	AABS, AMBST, 0, AMBST
13894:	FFFF          		IF	NOT WILD
13895:	3134          		FN	MSBYT, INTST, 0, INTST
13896:	3139          		FN	LSBYT, INTST, 0, INTST
13897:	313E          		FN	BCD, INTST, 0, INTST
13898:	3143          		FN	BIN, INTST, 0, INTST
13899:	3148          		FN	PEEK, INTST, 0, INTST
13900:	314D          		FN	ROTAT, INTST, INTST, INTST
13901:	3152          		FN	TEST, INTST, INTST, INTST
13902:	3157          		FN	SENSE, INTST, INTST, INTST
13903:	315C          		FN	RSHFT, INTST, INTST, INTST
13904:	3161          		FN	LSHFT, INTST, INTST, INTST
13905:	3166          		FN	RESET, INTST, INTST, INTST
13906:	316B          		FN	SETFN, INTST, INTST, INTST
13907:	3170          		FN	IMPM, INTST, 0, INTST
13908:				ENDIF
13909:			
13910:			;keyword table EQUates
13911:	0037          	NCMDS	EQU	(TYPTA-CMDTA)/2	;number of commands
13912:	0041          	NFUNS	EQU	FUNTA-TYPTA	;number of functions
13913:	0003          	NRWDS	DEFL	3		;number of reserved words
13914:	FFFF          		IF	NOT WILD
13915:	0004          	NRWDS	DEFL	NRWDS+1
13916:	FFFF          		IF	NOT CAMAC
13917:	0009          	NRWDS	DEFL	NRWDS+5
13918:				ENDIF
13919:				ENDIF
13920:	FFFF          		IF	FLOAT
13921:	000A          	NRWDS	DEFL	NRWDS+1
13922:				ELSE
13927:				ENDIF
13928:	FFFF          		IF	STRNG
13929:	000B          	NRWDS	DEFL	NRWDS+1
13930:				ELSE
13932:				ENDIF
13933:	FFFF          		IF	NOT WILD
13934:	000C          	NRWDS	DEFL	NRWDS+1
13935:				ENDIF
13936:	FFFF          		IF	KEY80
13937:	0078          	NKEYS	EQU	NCMDS+NFUNS	;number of keywords
13938:				ELSE
13940:				ENDIF
13941:			
13942:			;keyword table
13943:			;Adding or deleting a keyword always requires changing the KEYword table.
13944:			;In addition, adding a command requires changing the branch table at CMDTA.
13945:			;Adding a fn/op requires changing the type/prec table at TYPTA and the arg/resu
13946:			;table at FUNTA.  Adding a reserved word requires changing the NRWDS EQUates.
13947:			
13948:			;KEY is a macro to define keyword table entries and corresponding token values.
13949:			KEY	MACRO	F, L, TVAL
13950:				IF	NOT NUL TVAL
13951:			TVAL	EQU	TOKEN		;;equate token value if desired
13952:				ENDIF
13953:			TOKEN	DEFL	TOKEN+1		;;increment token value
13954:				IF	WILD OR NOT COMPL
13955:				DEFB	'&F', '&L' OR 80H;;keyword
13956:				ENDIF
13957:				ENDM
13958:			KEYSP	MACRO	F, L, TVAL
13959:				IF	NOT NUL TVAL
13960:			TVAL	EQU	TOKEN		;;equate token value if desired
13961:				ENDIF
13962:			TOKEN	DEFL	TOKEN+1		;;increment token value
13963:				IF	WILD OR NOT COMPL
13964:				DEFB	&F, &L OR 80H;;keyword
13965:				ENDIF
13966:				ENDM
13967:			;NOKEY is a macro to leave holes in table for commands not included in
13968:			;a non-ROMSQ or non-EDITC version, for token compatibility.
13969:			NOKEY	MACRO	N
13970:				IF	WILD OR NOT COMPL
13971:				REPT	N
13972:				DEFB	0FFH		;;token is <rubout> or 80H
13973:				ENDM
13974:				ENDIF
13975:			TOKEN	DEFL	TOKEN+N
13976:				ENDM
13977:	0088          	TOKEN	DEFL	-NKEYS AND 0FFH	;first token value
13978:			
13979:			;commands
13980:	3175          	KEYTA:	KEY	LE, T, CMDTK
13981:	3178          		KEY	I, F
13982:	317A          		KEY	FO, R, FORT
13983:	317D          		KEY	NEX, T, NEXTT
13984:	3181          		KEY	GOT, O, GOTOT
13985:	3185          		KEY	GOSU, B, GSUBT
13986:	318A          		KEY	PRIN, T, PRNTT
13987:	318F          		KEY	INPU, T
13988:	3194          		KEY	REA, D
13989:	3198          		KEY	RETUR, N
13990:	319E          		KEY	DE, F
13991:	31A1          		KEY	DI, M
13992:	31A4          		KEY	DAT, A, DATAT
13993:	31A8          		KEY	RESTOR, E, RSTRT
13994:	31AF          		KEY	STO, P
13995:	31B3          		KEY	EN, D
13996:	FFFF          		IF	NOT WILD
13997:	31B6          		KEY	NUL, L
13998:				ENDIF
13999:	31BA          		KEY	CAL, L
14000:	31BE          		KEY	SCAL, L
14001:	FFFF          		IF	NOT WILD
14002:	31C3          		KEY	OU, T
14003:	31C6          		KEY	POK, E
14004:	31CA          		KEY	WAI, T
14005:				ENDIF
14006:	31CE          		KEY	UNTRAC, E
14007:	31D5          		KEY	TRAC, E
14008:	31DA          		KEY	UNTRA, P
14009:	31E0          		KEY	TRA, P
14010:	31E4          		KEY	BREA, K, BRKT
14011:	31E9          		KEY	UNBREA, K, UNBKT
14012:	FFFF          		IF	NOT WILD
14013:	31F0          		KEY	ENABL, E, ENABT
14014:	31F6          		KEY	DISABL, E, DSABT
14015:	31FD          		KEY	RANDOMIZ, E
14016:				ENDIF
14017:	3206          		KEY	RE, M, REMT
14018:	3209          		KEY	DELA, Y
14019:	320E          		KEY	SAV, E
14020:	3212          		KEY	LOA, D
14021:	3216          		KEY	LIS, T, LISTT
14022:	321A          		KEY	CLEA, R
14023:	321F          		KEY	NE, W
14024:	3222          		KEY	RU, N, RUNT
14025:	3225          		KEY	CON, T
14026:	FFFF          		IF	NOT CAMAC
14027:	FFFF          		IF	EDITC
14028:	3229          		KEY	AUT, O
14029:	322D          		KEY	DELET, E
14030:	3233          		KEY	EDI, T
14031:	3237          		KEY	RENU, M
14032:				ELSE
14034:				ENDIF
14035:				ENDIF
14036:	0000          		IF	ROMSQ
14041:				ELSE
14042:	323C          		NOKEY	2
14043:				ENDIF
14044:	0000          		IF	EPSTN
14046:				ENDIF
14047:	FFFF          		IF	SDISK AND NOT C3885
14048:	323E          		KEY	OPE, N
14049:	3242          		KEY	CLOS, E
14050:	3247          		KEY	LINPU, T
14051:	324D          		KEY	MARGI, N
14052:	0000          		IF	BENDX
14056:				ELSE
14057:	3253          		KEY	DI, R
14058:	3256          		KEY	SCRATC, H
14059:				ENDIF
14060:				ENDIF
14061:	0000          		IF	BENDX
14063:				ENDIF
14064:	0000          		IF	CAMAC
14088:				ELSE
14089:	0000          		IF	WILD
14091:				ELSE
14092:	325D          		KEY	ASSIG, N
14093:				ENDIF
14094:	0000          		IF	REALT
14096:				ELSE
14097:	3263          		KEY	TIM, E
14098:				ENDIF
14099:				ENDIF
14100:	0000          		IF	PACKI
14104:				ENDIF
14105:	3267          		KEY	O, N
14106:			
14107:			;functions and ops
14108:	3269          		KEY	F, N, UDFNT
14109:	326B          		KEY	NO, T
14110:	326E          		KEY	, +, PLUST
14111:	326F          		KEY	, -, MINT
14112:	3270          		KEY	, *, MULTT
14113:	3271          		KEY	, /
14114:	FFFF          		IF	FLOAT
14115:	3272          		KEY	, \
14116:	3273          		KEY	, ^
14117:				ENDIF
14118:	3274          		KEYSP	'<','='
14119:	3276          		KEYSP	'=', '<'
14120:	3278          		KEYSP	'=', '>'
14121:	327A          		KEYSP	'>', '='
14122:	327C          		KEYSP	'<', '>'
14123:	327E          		KEYSP	'', '=', EQULT
14124:	327F          		KEYSP	'', '<'
14125:	3280          		KEYSP	'', '>'
14126:	3281          		KEY	AN, D
14127:	3284          		KEY	XO, R
14128:	3287          		KEY	O, R
14129:	3289          		KEY	MO, D
14130:	FFFF          		IF	NOT WILD
14131:	328C          		KEY	JOI, N
14132:				ENDIF
14133:	3290          		KEY	GE, T
14134:	3293          		KEY	FR, E
14135:	FFFF          		IF	NOT WILD
14136:	3296          		KEY	RN, D
14137:				ENDIF
14138:	0000          		IF	WILD
14140:				ELSE
14141:	FFFF          		IF	NOT CAMAC
14142:	3299          		KEY	PO, S
14143:				ENDIF
14144:	0000          		IF	ROMSQ
14147:				ELSE
14148:	329C          		NOKEY	2
14149:				ENDIF
14150:				ENDIF
14151:	0000          		IF	PACKI
14153:				ENDIF
14154:	FFFF          		IF	SDISK AND NOT C3885
14155:	329E          		KEY	EO, F
14156:				ENDIF
14157:	FFFF          		IF	FLOAT
14158:	FFFF          		IF	NOT WILD
14159:	32A1          		KEY	UN, S
14160:				ENDIF
14161:	32A4          		KEY	IN, T, INTT
14162:	32A7          		KEY	SQ, R
14163:	32AA          		KEY	EX, P
14164:	32AD          		KEY	LO, G
14165:	32B0          		KEY	SI, N
14166:	32B3          		KEY	CO, S
14167:	32B6          		KEY	TA, N
14168:	FFFF          		IF	NOT CAMAC
14169:	32B9          		KEY	AT, N
14170:				ENDIF
14171:				ENDIF
14172:	FFFF          		IF	STRNG
14173:	32BC          		KEY	BIN, $
14174:	32C0          		KEY	HEX, $
14175:	32C4          		KEY	OCT, $
14176:	32C8          		KEY	CHR, $
14177:	32CC          		KEY	STR, $
14178:	32D0          		KEY	AS, C
14179:	32D3          		KEY	LE, N
14180:	32D6          		KEY	VA, L
14181:	32D9          		KEY	LEFT, $
14182:	32DE          		KEY	RIGHT, $
14183:	32E4          		KEY	MID, $, MIDST
14184:	32E8          		KEY	INST, R, INSTT
14185:				ENDIF
14186:	0000          		IF	CAMAC
14194:				ELSE
14195:	FFFF          		IF	NOT WILD
14196:	32ED          		KEY	IOBYT, E
14197:				ENDIF
14198:	0000          		IF	REALT
14201:				ENDIF
14202:				ENDIF
14203:	32F3          		KEY	SG, N
14204:	32F6          		KEY	AB, S
14205:	FFFF          		IF	NOT WILD
14206:	32F9          		KEY	MSBYT, E
14207:	32FF          		KEY	LSBYT, E
14208:	3305          		KEY	BC, D
14209:	3308          		KEY	BI, N
14210:	330B          		KEY	PEE, K
14211:	330F          		KEY	ROTAT, E
14212:	3315          		KEY	TES, T
14213:	3319          		KEY	SENS, E
14214:	331E          		KEY	RSHIF, T
14215:	3324          		KEY	LSHIF, T
14216:	332A          		KEY	RESE, T
14217:	332F          		KEY	SE, T
14218:	3332          		KEY	I, N
14219:				ENDIF
14220:			
14221:			;reserved words and PRINT functions
14222:	FFFF          		IF	KEY80
14223:	000E          	RWDTK	EQU	0EH		;first reserved word token
14224:	000E          	TOKEN	DEFL	RWDTK
14225:				ENDIF
14226:	3334          	RWDTA:	KEY	THE, N, THENT
14227:	3338          		KEY	T, O, TOT
14228:	333A          		KEY	STE, P, STEPT
14229:	FFFF          		IF	NOT WILD
14230:	333E          		KEY	TA, B, TABT
14231:	FFFF          		IF	NOT CAMAC	;no devices in CAMAC version
14232:	3341          		KEY	SP, C, SPCT
14233:	3344          		KEY	CON, #, CONTK
14234:	3348          		KEY	RDR, #
14235:	334C          		KEY	PUN, #
14236:	3350          		KEY	LST, #
14237:				ENDIF
14238:				ENDIF
14239:	FFFF          		IF	FLOAT
14240:	3354          		KEY	SN, G, SNGT	;for DEF SNG
14241:				ELSE
14246:				ENDIF
14247:	FFFF          		IF	STRNG
14248:	3357          		KEY	ST, R, STRGT	;for DEF STR
14249:				ELSE
14251:				ENDIF
14252:	FFFF          		IF	NOT WILD
14253:	0000          		IF	ROMSQ
14255:				ELSE
14256:	335A          		NOKEY	1
14257:				ENDIF
14258:				ENDIF
14259:			
14260:			;end of keyword table
14261:			
14262:			;table of keywords after which <line #>s may occur, for RENUM
14263:	FFFF          		IF	EDITC AND NOT COMPL
14264:	335B  8C8D0EAE	KLNTA:	DEFB	GOTOT, GSUBT, THENT, RUNT, RSTRT
	      95
14265:	3360  ABA2A3  		DEFB	LISTT, BRKT, UNBKT
14266:	FFFF          		IF	NOT WILD
14267:	3363  A4A5    		DEFB	ENABT, DSABT
14268:				ENDIF
14269:	000A          	KLNCT	EQU	$-KLNTA
14270:				ENDIF
14271:			
14272:			;copyright message
14273:			;not in module INITIAL to prevent overlaying
14274:	3365  434F5059	MWCMA:	DEFB	'COPYRIGHT 1978, 1979, 1980, 1981'
	      52494748
	      54203139
	      37382C20
	      31393739
	      2C203139
	      38302C20
	      31393831
14275:	0000          		IF	EPSTN
14277:				ENDIF
14278:	3385  20425920		DEFB	' BY MARK WILLIAMS COMPANY, CHICAGO'
	      4D41524B
	      2057494C
	      4C49414D
	      5320434F
	      4D50414E
	      592C2043
	      48494341
	      474F
14279:	0000          		IF	EPSTN
14282:				ENDIF
14283:	33A7  0D8A    		DEFB	CR, LF OR 80H
14284:			
14285:			;end of TABLES
14287:			;TOKENIZE 10/22/80
14288:			;XYBASIC Interpreter Source Module
14289:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
14290:			;tokenization and line editing
14291:			
14292:	FFFF          		IF	(NOT WILD) OR (NOT RTPAK);WILD RTPAK uses GTLIN in WILD
14293:			;GTLIN gets a line of source text from the user and sets TEXTP.
14294:			;Uses:	B	temp storage
14295:			;	C	unused
14296:			;	D	LS byte of first text address
14297:			;	E	LS byte of max text address
14298:			;	HL	text address
14299:			;Chars are read with READC and inserted starting at NLNAD, except:
14300:			;	<rubout>	deletes last character
14301:			;	<control-R>	retypes current line
14302:			;	<control-U>	starts over
14303:			;	<control-H>	deletes last char, echoes <cntl-h> to backspace cursor
14304:			;	<cr>		echoes <lf> and returns
14305:			;	<control-G>	accepted
14306:			;	other <control>s	ignored (ASCII 0-1FH)
14307:			;Chars typed when buffer is full echo <control-G> and are ignored.
14308:	FFFF          		IF	NOT WILD
14309:	33A9          	GTLI0:
14310:	0000          		IF	EPSTN
14312:				ELSE
14313:	33A9  CD6234  		CALL	ECHOC		;echo ^U
14314:	33AC  CD7516  		CALL	WCRLF		;write crlf after ^U
14315:				ENDIF
14316:	FFFF          		IF	EDITC
14317:	33AF  3E0D    		LD	A,CR
14318:	33B1  32C33E  		LD	(NLNAD),A	;clobber old buffer contents in case ^E
14319:				ENDIF
14320:				ENDIF			;end of NOT WILD conditional
14321:	33B4  11133F  	GTLIN:	LD	DE,NLNAD+NLMAX	;lsbyte of max address to E
14322:	33B7  21C33E  		LD	HL,NLNAD	;first text byte address to HL
14323:	33BA  55      		LD	D,L		;lsbyte of text address to D
14324:	FFFF          		IF	EDITC
14325:	33BB  CD8D16  		CALL	READC		;check first char in case ^E
14326:	33BE  FE05    		CP	CNTLE
14327:	0000          		IF	WILD
14329:				ELSE
14330:	33C0  C2C933  		JP	NZ,GTL1D	;first char not ^E
14331:				ENDIF
14332:	33C3  C37134  		JP	LEDIT		;enter line editor
14333:				ENDIF
14334:	33C6  CD8D16  	GTLI1:	CALL	READC		;get a character
14335:	FFFF          		IF	NOT WILD
14336:	33C9  FE7F    	GTL1D:	CP	RBOUT
14337:	33CB  C2F433  		JP	NZ,GTLI2
14338:	0000          		IF	EPSTN
14340:				ENDIF
14341:	33CE  7D      		LD	A,L		;rubout
14342:	33CF  BA      		CP	D
14343:	33D0  CAC633  		JP	Z,GTLI1		;start over if line is empty
14344:	0000          		IF	EPSTN
14347:				ELSE
14348:	33D3  3E2F    		LD	A,'/'
14349:	33D5  CD1F16  		CALL	WRITC		;echo slash first
14350:	33D8  2B      	GTL1A:	DEC	HL
14351:	33D9  7E      		LD	A,(HL)		;get previous char
14352:	33DA  CD1F16  		CALL	WRITC		;and echo it
14353:	33DD  CD8D16  	GTL1B:	CALL	READC		;read another from console
14354:	33E0  FE7F    		CP	RBOUT		;see if still rubbing out
14355:	33E2  C2ED33  		JP	NZ,GTL1C	;no, echo end slash and continue
14356:	33E5  7D      		LD	A,L
14357:	33E6  BA      		CP	D
14358:	33E7  CADD33  		JP	Z,GTL1B		;at start of line
14359:	33EA  C3D833  		JP	GTL1A
14360:	33ED  47      	GTL1C:	LD	B,A		;save new char
14361:	33EE  3E5C    		LD	A,'\'
14362:	33F0  CD1F16  		CALL	WRITC		;write end slash
14363:	33F3  78      		LD	A,B		;restore new char
14364:				ENDIF			;end of NOT EPSTN conditional
14365:				ENDIF			;end of NOT WILD conditional
14366:	33F4  77      	GTLI2:	LD	(HL),A		;insert the char
14367:	33F5  FE0D    		CP	CR
14368:	33F7  CA2F34  		JP	Z,GTLI5		;echo lf and return
14369:	FFFF          		IF	NOT WILD
14370:	33FA  FE15    		CP	CNTLU
14371:	33FC  CAA933  		JP	Z,GTLI0		;crlf and start over if ^U
14372:				ENDIF
14373:	FFFF          		IF	NOT EPSTN
14374:	FFFF          		IF	(NOT WILD) OR (NOT RTPAK)
14375:	33FF  FE08    		CP	CNTLH
14376:	3401  CA4C34  		JP	Z,GTLI7		;backspace if control-h
14377:				ENDIF
14378:	FFFF          		IF	EDITC
14379:	3404  FE05    		CP	CNTLE
14380:	3406  CA5A34  		JP	Z,GTLI8		;edit already typed line if ^E
14381:				ENDIF
14382:	FFFF          		IF	NOT WILD
14383:	3409  FE12    		CP	CNTLR
14384:	340B  CC6234  		CALL	Z,ECHOC		;echo ^R
14385:	340E  CA3C34  		JP	Z,GTLI6		;retype line if ^R
14386:				ENDIF
14387:	3411  FE07    		CP	CNTLG
14388:	3413  CC6234  		CALL	Z,ECHOC		;echo ^G
14389:	3416  CA1E34  		JP	Z,GTLI3		;accept bell
14390:	3419  FE20    		CP	20H
14391:	341B  DAC633  		JP	C,GTLI1		;ignore 0H - 1FH (controls)
14392:				ENDIF
14393:	341E  7D      	GTLI3:	LD	A,L
14394:	341F  BB      		CP	E		;check for line overflow
14395:	3420  7E      		LD	A,(HL)		;restore char to A
14396:	3421  CC2B34  		CALL	Z,GTLI4		;replace with bell if line too long
14397:	0000          		IF	EPSTN
14400:				ENDIF
14401:	3424  CD1F16  		CALL	WRITC		;echo char
14402:	3427  23      		INC	HL		;bump insertion pointer
14403:	3428  C3C633  		JP	GTLI1		;and get next
14404:	342B  3E07    	GTLI4:	LD	A,CNTLG		;replace char with bell
14405:	342D  2B      		DEC	HL		;leave pointer unchanged
14406:	342E  C9      		RET
14407:	342F          	GTLI5:
14408:	FFFF          		IF	NOT COMPL
14409:	342F  AF      		XOR	A
14410:	3430  32C43F  		LD	(CSTKD),A	;clear control stack direct count
14411:				ENDIF
14412:	3433  21C33E  		LD	HL,NLNAD
14413:	3436  22C63F  		LD	(TEXTP),HL	;reset text pointer
14414:	3439  C37516  		JP	WCRLF		;echo crlf and return
14415:	0000          		IF	EPSTN
14418:				ELSE
14419:	FFFF          		IF	NOT WILD
14420:	343C  CD7516  	GTLI6:	CALL	WCRLF
14421:	343F  D5      		PUSH	DE		;save DE
14422:	3440  11C33E  		LD	DE,NLNAD	;first addr to DE
14423:	3443  7D      		LD	A,L
14424:	3444  93      		SUB	E		;last+1 - first = # chars to A
14425:	3445  CD7D29  		CALL	PRST0		;and print the line
14426:	3448  D1      		POP	DE		;restore DE
14427:	3449  C3C633  		JP	GTLI1		;and wait for next char
14428:				ENDIF
14429:	FFFF          		IF	(NOT WILD) OR (NOT RTPAK)
14430:	344C  7D      	GTLI7:	LD	A,L
14431:	344D  BA      		CP	D
14432:	344E  CAC633  		JP	Z,GTLI1		;ignore if at start of line
14433:	3451  3E08    		LD	A,CNTLH		;restore the ^H
14434:	3453  CD1F16  		CALL	WRITC		;and echo the ^H to backspace
14435:	3456  2B      		DEC	HL		;decrement position
14436:	3457  C3C633  		JP	GTLI1
14437:				ENDIF
14438:	FFFF          		IF	EDITC
14439:	345A  CD7516  	GTLI8:	CALL	WCRLF		;write crlf to get to new line
14440:	345D  360D    		LD	(HL),CR		;store cr
14441:	345F  C37134  		JP	LEDIT		;line edit the line
14442:				ENDIF
14443:				ENDIF			;end of NOT EPSTN conditional
14444:			
14445:			;ECHOC echoes meaningful control chars as ^char.
14446:			;Call:	A	control char value in ASCII
14447:			;Retn:	PSW,A,BC,DE,HL	preserved
14448:	3462  F5      	ECHOC:	PUSH	AF
14449:	3463  3E5E    		LD	A,'^'
14450:	3465  CD1F16  		CALL	WRITC		;write ^
14451:	3468  F1      		POP	AF		;restore control char value
14452:	3469  F5      		PUSH	AF		;and resave
14453:	346A  C640    		ADD	A,40H		;add ASCII bias
14454:	346C  CD1F16  		CALL	WRITC		;write the char
14455:	346F  F1      		POP	AF		;restore status bits and A
14456:	3470  C9      		RET
14457:				ENDIF			;end of NOT WILD and NOT RTPAK conditional
14458:			
14459:	FFFF          		IF	EDITC
14460:			;LEDIT does the work of line editing.
14461:			;Uses:	B	Chars left of cursor, initially 0
14462:			;	C	Max # of chars to add without overflowing buffer
14463:			;	HL	Cursor position, initially NLNAD
14464:			;	NLNAD	Line currently being edited
14465:			;	TLNAD	Original contents of line (in case ^U typed)
14466:			;Retn:	NLNAD	contains edited line
14467:			;	TEXTP	reset to NLNAD
14468:			;	CSTKD	reset to 0
14469:			;	GCHAR	reset to 0
14470:			;	TLNAD	clobbered
14471:			;	Registers	clobbered
14472:	3471  21C33E  	LEDIT:	LD	HL,NLNAD	;input buffer address to HL
14473:	3474  22C63F  		LD	(TEXTP),HL	;reset TEXTP
14474:	3477  11703E  		LD	DE,TLNAD	;tokenization buffer address to DE
14475:	347A  015300  	LEDT0:	LD	BC,NLMAX+3	;0 to B, NLMAX+3 to C
14476:	347D  7E      	LEDT1:	LD	A,(HL)		;fetch char from input buffer
14477:	347E  12      		LD	(DE),A		;and save in tokenization buffer
14478:	347F  0D      		DEC	C		;decrement remaining char count
14479:	3480  13      		INC	DE
14480:	3481  23      		INC	HL
14481:	3482  D60D    		SUB	CR		;check if at cr
14482:	3484  C27D34  		JP	NZ,LEDT1	;no, keep copying
14483:	3487  32C43F  		LD	(CSTKD),A	;clear CSTACK direct count
14484:	348A  32313D  		LD	(GCHAR),A	;clear GCHAR
14485:	348D  21C33E  		LD	HL,NLNAD	;input buffer address to HL
14486:	3490  CD6B35  		CALL	LEDI6		;type line
14487:	3493  CD8D16  	LEDT2:	CALL	READC		;get command character
14488:	3496  FE0D    	LEDT3:	CP	CR
14489:	3498  CAA035  		JP	Z,LED11		;done if <cr>
14490:	349B  FE15    		CP	CNTLU
14491:	349D  CA9435  		JP	Z,LED10		;^U
14492:	34A0  E5      		PUSH	HL
14493:	34A1  219334  		LD	HL,LEDT2
14494:	34A4  E3      		EX	(SP),HL		;push LEDT2 to allow RETurn from routines
14495:	34A5  FE7F    		CP	RBOUT
14496:	34A7  CAF834  		JP	Z,LEDI1		;<rubout>
14497:	34AA  FE20    		CP	20H
14498:	34AC  D2DD34  		JP	NC,LEDI0	;printable char
14499:	34AF  FE04    		CP	CNTLD
14500:	34B1  CA1D35  		JP	Z,LEDI2		;^D
14501:	34B4  FE06    		CP	CNTLF
14502:	34B6  CA3035  		JP	Z,LEDI3		;^F
14503:	34B9  FE07    		CP	CNTLG
14504:	34BB  CADD34  		JP	Z,LEDI0		;^G, treat as printable
14505:	34BE  FE08    		CP	CNTLH
14506:	34C0  CA5435  		JP	Z,LEDI4		;^H
14507:	34C3  FE0B    		CP	CNTLK
14508:	34C5  CA6135  		JP	Z,LEDI5		;^K
14509:	34C8  FE0C    		CP	CNTLL
14510:	34CA  CA6B35  		JP	Z,LEDI6		;^L
14511:	34CD  FE0E    		CP	CNTLN
14512:	34CF  CA7D35  		JP	Z,LEDI7		;^N
14513:	34D2  FE12    		CP	CNTLR
14514:	34D4  CA8335  		JP	Z,LEDI8		;^R
14515:	34D7  FE14    		CP	CNTLT
14516:	34D9  CA8B35  		JP	Z,LEDI9		;^T
14517:	34DC  C9      		RET			;ignore any other chars
14518:			
14519:			;printable char or ^G is inserted.
14520:	34DD  0D      	LEDI0:	DEC	C		;decrement char count
14521:	34DE  CAF234  		JP	Z,LED0B		;too many chars
14522:	34E1  56      		LD	D,(HL)		;char right of cursor to D
14523:	34E2  77      		LD	(HL),A		;insert new char
14524:	34E3  CD8F35  		CALL	LED9A		;incr chars left of cursor and echo char
14525:	34E6  E5      		PUSH	HL		;and save
14526:	34E7  7A      	LED0A:	LD	A,D		;fetch saved char
14527:	34E8  56      		LD	D,(HL)		;save next char
14528:	34E9  77      		LD	(HL),A		;store current char
14529:	34EA  23      		INC	HL
14530:	34EB  FE0D    		CP	CR
14531:	34ED  C2E734  		JP	NZ,LED0A
14532:	34F0  E1      		POP	HL		;restore cursor loc
14533:	34F1  C9      		RET
14534:	34F2  0C      	LED0B:	INC	C		;undecrement count
14535:	34F3  3E07    	LED0C:	LD	A,CNTLG
14536:	34F5  C31F16  		JP	WRITC		;and write a bell
14537:			
14538:			;<rubout> erases the char left of cursor, echoing it within slashes.
14539:	34F8  78      	LEDI1:	LD	A,B
14540:	34F9  B7      		OR	A
14541:	34FA  C8      		RET	Z		;ignore if already at left margin
14542:	34FB  3E2F    		LD	A,'/'
14543:	34FD  CD1F16  		CALL	WRITC		;write initial /
14544:	3500  2B      	LED1A:	DEC	HL
14545:	3501  7E      		LD	A,(HL)
14546:	3502  CD5A35  		CALL	LED4A		;write deleted char and move remainder of line
14547:	3505  CD8D16  		CALL	READC		;read next char
14548:	3508  FE7F    		CP	RBOUT
14549:	350A  C21235  		JP	NZ,LED1B	;no additional <rubout>s
14550:	350D  78      		LD	A,B
14551:	350E  B7      		OR	A
14552:	350F  C20035  		JP	NZ,LED1A	;<rubout> another
14553:	3512  57      	LED1B:	LD	D,A		;save next char
14554:	3513  3E5C    		LD	A,'\'
14555:	3515  CD1F16  		CALL	WRITC		;write the end \
14556:	3518  7A      		LD	A,D		;restore next char
14557:	3519  D1      		POP	DE		;pop the return to LEDIT
14558:	351A  C39634  		JP	LEDT3		;and return to LEDT1 instead
14559:			
14560:			;^D deletes the char right of cursor.
14561:	351D  7E      	LEDI2:	LD	A,(HL)		;fetch char right of cursor
14562:	351E  FE0D    		CP	CR
14563:	3520  C8      		RET	Z		;leave unchanged if at end of line
14564:	3521  0C      		INC	C		;one more char is now available
14565:	3522  E5      		PUSH	HL		;save cursor location
14566:	3523  54      		LD	D,H
14567:	3524  5D      		LD	E,L
14568:	3525  23      	LED2A:	INC	HL
14569:	3526  7E      		LD	A,(HL)		;fetch next char
14570:	3527  12      		LD	(DE),A		;and store
14571:	3528  13      		INC	DE
14572:	3529  FE0D    		CP	CR
14573:	352B  C22535  		JP	NZ,LED2A	;continue until cr
14574:	352E  E1      		POP	HL		;restore cursor
14575:	352F  C9      		RET
14576:			
14577:			;^F <char> searches for next occurence of <char>.
14578:	3530  CD8D16  	LEDI3:	CALL	READC		;get search character
14579:	3533  32313D  		LD	(GCHAR),A	;and save
14580:	3536  57      	LED3A:	LD	D,A		;search char to D
14581:	3537  E5      		PUSH	HL		;save cursor position
14582:	3538  7E      	LED3B:	LD	A,(HL)		;fetch next char
14583:	3539  23      		INC	HL
14584:	353A  FE0D    		CP	CR		;check if at cr
14585:	353C  CA5035  		JP	Z,LED3D		;not found
14586:	353F  BA      		CP	D		;check for match
14587:	3540  C23835  		JP	NZ,LED3B
14588:	3543  EB      		EX	DE,HL		;match location to DE
14589:	3544  E1      		POP	HL		;restore current loc
14590:	3545  CD2902  	LED3C:	CALL	CMDHU		;compare current to desired
14591:	3548  C8      		RET	Z
14592:	3549  7E      		LD	A,(HL)
14593:	354A  CD8F35  		CALL	LED9A		;move right and print
14594:	354D  C34535  		JP	LED3C
14595:	3550  E1      	LED3D:	POP	HL		;recover cursor location
14596:	3551  C3F334  		JP	LED0C		;beep and continue
14597:			
14598:			;^H deletes char left of cursor and echoes ^H.
14599:	3554  78      	LEDI4:	LD	A,B
14600:	3555  B7      		OR	A
14601:	3556  C8      		RET	Z		;no chars left of cursor
14602:	3557  2B      		DEC	HL
14603:	3558  3E08    		LD	A,CNTLH
14604:	355A  CD1F16  	LED4A:	CALL	WRITC		;echo the ^H
14605:	355D  05      		DEC	B		;decrement chars left of cursor
14606:	355E  C31D35  		JP	LEDI2		;move remainder of chars
14607:			
14608:			;^K kills the chars right of the cursor.
14609:	3561  7E      	LEDI5:	LD	A,(HL)		;fetch next
14610:	3562  FE0D    		CP	CR
14611:	3564  C8      		RET	Z		;done if at cr
14612:	3565  CD1D35  		CALL	LEDI2		;else delete a char
14613:	3568  C36135  		JP	LEDI5		;and repeat
14614:			
14615:			;^L prints remainder of line and moves cursor to left.
14616:	356B  7E      	LEDI6:	LD	A,(HL)
14617:	356C  23      		INC	HL
14618:	356D  CD1F16  		CALL	WRITC		;write next char
14619:	3570  FE0D    		CP	CR
14620:	3572  C26B35  		JP	NZ,LEDI6	;not at <cr> yet
14621:	3575  21C33E  		LD	HL,NLNAD	;cursor at left of line
14622:	3578  0600    		LD	B,0		;0 chars left of cursor
14623:	357A  C37A16  		JP	WLF		;write <lf> after <cr>
14624:			
14625:			;^N gets next occurence of ^F <char>.
14626:	357D  3A313D  	LEDI7:	LD	A,(GCHAR)	;get previous ^F character
14627:	3580  C33635  		JP	LED3A		;and continue as for ^F
14628:			
14629:			;^R retypes the line, leaving cursor unchanged.
14630:	3583  54      	LEDI8:	LD	D,H
14631:	3584  5D      		LD	E,L		;cursor position to DE
14632:	3585  CD6B35  		CALL	LEDI6		;type remainder of line
14633:	3588  C34535  		JP	LED3C
14634:			
14635:			;^T moves the cursor one char right.
14636:	358B  7E      	LEDI9:	LD	A,(HL)		;fetch next
14637:	358C  FE0D    		CP	CR
14638:	358E  C8      		RET	Z		;done if no chars right of cursor
14639:	358F  23      	LED9A:	INC	HL
14640:	3590  04      		INC	B		;increment chars to left count
14641:	3591  C31F16  		JP	WRITC		;echo char and return
14642:			
14643:			;^U restores the original contents of the buffer and retries.
14644:	3594  CD7516  	LED10:	CALL	WCRLF		;write crlf
14645:	3597  21703E  		LD	HL,TLNAD	;tokenization buffer address to HL
14646:	359A  11C33E  		LD	DE,NLNAD	;input buffer address to DE
14647:	359D  C37A34  		JP	LEDT0		;and continue as above
14648:			
14649:			;<cr> resets GCHAR, prints the edited line and exits from line editor.
14650:	35A0  AF      	LED11:	XOR	A
14651:	35A1  32313D  		LD	(GCHAR),A	;reset GET character
14652:	35A4  C36B35  		JP	LEDI6		;print line and return
14653:			
14654:				ENDIF			;end of EDITC conditional
14655:			
14656:	FFFF          		IF	WILD OR NOT COMPL
14657:			;TKIZE tokenizes a line of text and computes its length.
14658:			;Call:	(newln)	address of first text byte
14659:			;Uses:	BC	address of next tokenized text line byte
14660:			;	HL	address of next untokenized text line byte
14661:			;Retn:	A,BC,DE	clobbered
14662:			;	HL	address of first tokenized text line byte (i.e. (newln))
14663:			;	(textp)	ditto
14664:			;	(lnnum)	line #, 0 if none
14665:			;	(lnlen)	length of tokenized line + overhead, 0 to delete
14666:			;			(i.e. if line consists of [<line #>] <cr>)
14667:			;	Carry	set iff no line # and line not <cr>
14668:			;	Zero	set if <cr>
14669:			;The tokenized line is identical to the original line, EXCEPT:
14670:			;(1)  The line # (if any) and spaces preceding it are removed, and
14671:			;(2)  Instances of keywords not inside " " or following # are replaced
14672:			;	by the correponding tokens.
14673:			;0 is stored in the byte after <cr> as a pseudo-eof for direct mode execution.
14674:	35A7          	TKIZE:
14675:	FFFF          		IF	NOT (WILD AND RTPAK)
14676:	35A7  CD2B37  		CALL	LNNU0
14677:				ENDIF
14678:	35AA  21C33E  		LD	HL,NLNAD	;store text address in HL
14679:	35AD  01703E  		LD	BC,TLNAD	;tokenized line address to BC
14680:	35B0  C5      		PUSH	BC		;save for exit
14681:	35B1  CD1119  		CALL	GTDEC		;look for decimal line #
14682:	35B4  DABC35  		JP	C,TKIZ0		;none
14683:	35B7  7A      		LD	A,D
14684:	35B8  B3      		OR	E
14685:	35B9  CA3501  		JP	Z,SNERR		;SN error if zero or too big
14686:	35BC  F5      	TKIZ0:	PUSH	AF		;carry set iff no line #
14687:	35BD  EB      		EX	DE,HL
14688:	35BE  22E23C  		LD	(LNNUM),HL	;line # to lnnum
14689:	35C1  EB      		EX	DE,HL
14690:	35C2  7E      		LD	A,(HL)		;next text char to A
14691:	35C3  D60D    		SUB	CR		;compare with sui (to use zero)
14692:	35C5  C2D335  		JP	NZ,TKIZ1
14693:	35C8  23      		INC	HL		;delete line by letting length = 0
14694:	35C9  77      		LD	(HL),A		;store pseudo-eof
14695:	35CA  32C33F  		LD	(LNLEN),A
14696:	35CD  F1      		POP	AF
14697:	35CE  7A      		LD	A,D
14698:	35CF  B3      		OR	E		;carry reset, zero set iff <cr>
14699:	35D0  C3EB35  		JP	STTP1		;set textp and return
14700:	35D3  CD0B36  	TKIZ1:	CALL	TKIZB		;tokenize body of input line
14701:	35D6  AF      		XOR	A
14702:	35D7  02      		LD	(BC),A		;pseudo-eof for direct mode exec
14703:	35D8  21703E  		LD	HL,TLNAD
14704:	35DB  7D      		LD	A,L		;lsbyte of first address to A
14705:	35DC  2F      		CPL			;- first text address - 1
14706:	35DD  81      		ADD	A,C		;+ last address + 1 = actual length - 1
14707:	35DE  C605    		ADD	A,5		;+ line overhead + 1 = length
14708:	35E0  32C33F  		LD	(LNLEN),A	;store tokenized line length
14709:	35E3  F1      		POP	AF		;carry set iff no line #
14710:	35E4  D2EB35  		JP	NC,STTP1
14711:	35E7  2B      		DEC	HL
14712:	35E8  22543E  		LD	(SAVTP),HL	;initialize savtp for direct mode commands
14713:	35EB  E1      	STTP1:	POP	HL		;return first text byte addr in HL
14714:	35EC  22C63F  		LD	(TEXTP),HL	;initialize text pointer
14715:	35EF  C9      		RET
14716:			
14717:	35F0  3E8E    	COPYP:	LD	A,PRNTT	;substitute PRINT token for ?
14718:	35F2  02      	TKIZA:	LD	(BC),A
14719:	35F3  03      		INC	BC
14720:	35F4  23      		INC	HL
14721:	35F5  163A    		LD	D,':'
14722:	35F7  FE94    		CP	DATAT
14723:	35F9  CA0836  		JP	Z,TKZA2		;do not tokenize DATA
14724:	35FC  FEA7    		CP	REMT
14725:	0000          		IF	WILD AND RTPAK	;suppress comments in WILD RTPAK tokenization
14733:				ELSE
14734:	35FE  CA0636  		JP	Z,TKZA1		;or REMarks (for ?)
14735:	3601  FE27    		CP	''''
14736:	3603  C20B36  		JP	NZ,TKIZB	;or on-line comments
14737:				ENDIF			;end of NOT (WILD AND RTPAK) conditional
14738:	3606  160D    	TKZA1:	LD	D,CR
14739:	3608  CD4736  	TKZA2:	CALL	CPYD1		;copy without tokenizing
14740:	360B  CD5236  	TKIZB:	CALL	COPYS		;copy spaces
14741:	360E  FE22    		CP	'"'
14742:	3610  CC4336  		CALL	Z,COPYQ		;copy to close quote
14743:	3613  FE23    		CP	'#'
14744:	3615  CA5936  		JP	Z,COPYH		;watch for keywords after #
14745:	3618  FE0D    		CP	CR
14746:	361A  CA3F36  		JP	Z,COPYA		;finished if cr -- copy and return
14747:	361D  FE3F    		CP	'?'
14748:	361F  CAF035  		JP	Z,COPYP		;? abbreviation for PRINT
14749:	3622  C5      		PUSH	BC		;save tokenized text pointer
14750:	3623  0E88    		LD	C,-NKEYS AND 0FFH;table length to C
14751:	3625  117531  		LD	DE,KEYTA	;table address to DE
14752:	3628  CD7336  		CALL	TLKUP		;perform table lookup
14753:	FFFF          		IF	KEY80
14754:	362B  D23B36  		JP	NC,TKIZC	;found it
14755:	362E  0EF4    		LD	C,-NRWDS AND 0FFH
14756:	3630  113433  		LD	DE,RWDTA
14757:	3633  CD7336  		CALL	TLKUP		;check for reserved word
14758:	3636  DA3B36  		JP	C,TKIZC		;not a keyword nor a reserved word
14759:	3639  C61A    		ADD	A,RWDTK+NRWDS	;use tokens starting at RWDTK
14760:				ENDIF
14761:	363B  C1      	TKIZC:	POP	BC		;restore text pointer
14762:	363C  C3F235  		JP	TKIZA		;copy A and keep tokenizing
14763:			
14764:			
14765:			;Tokenizer routines.
14766:			;COPYA copies one char from A through BC.
14767:			;COPYS copies successive spaces (if any) from M through BC.
14768:			;COPYQ copies " from A through BC, then copies from M through BC until
14769:			;	" (inclusive, incl. trailing spaces) or until <cr> (exclusive).
14770:			;COPYH copies hex digits, so e.g. #DEF and #BIN tokenize correctly.
14771:			;Call:	BC	address of next available destination
14772:			;	HL	address of next available char (i.e. source)
14773:			;Retn:	A	char copied for COPY1,COPYA
14774:			;		first char not copied for COPYS, COPYQ
14775:			;	BC	next available destination address
14776:			;	DE	preserved
14777:			;	HL	next available source address
14778:			
14779:	363F  02      	COPYA:	LD	(BC),A	;store through BC
14780:	3640  03      		INC	BC
14781:	3641  23      		INC	HL
14782:	3642  C9      		RET
14783:			
14784:	3643  57      	COPYQ:	LD	D,A
14785:	3644  02      	COPYD:	LD	(BC),A
14786:	3645  03      		INC	BC
14787:	3646  23      		INC	HL		;copy current character
14788:	3647  7E      	CPYD1:	LD	A,(HL)
14789:	3648  FE0D    		CP	CR
14790:	364A  C8      		RET	Z		;return without copying if cr
14791:	364B  BA      		CP	D
14792:	364C  C24436  		JP	NZ,COPYD	;keep copying if neither (D) nor cr
14793:	364F  02      	COPS0:	LD	(BC),A
14794:	3650  03      		INC	BC
14795:	3651  23      	COPS1:	INC	HL
14796:	3652  7E      	COPYS:	LD	A,(HL)
14797:	3653  FE20    		CP	' '
14798:	3655  C0      		RET	NZ		;return at first non-space
14799:	0000          		IF	WILD AND RTPAK
14801:				ELSE
14802:	3656  C34F36  		JP	COPS0
14803:				ENDIF
14804:			
14805:	3659  02      	COPYH:	LD	(BC),A
14806:	365A  03      		INC	BC
14807:	365B  23      		INC	HL		;copy char and spaces
14808:	365C  7E      		LD	A,(HL)
14809:	365D  CDF518  		CALL	LDTST		;test if letter or digit
14810:	3660  D26B36  		JP	NC,CPYH1	;yes
14811:	3663  D620    		SUB	20H		;convert from possible lower case
14812:	3665  CDF518  		CALL	LDTST
14813:	3668  DA0B36  		JP	C,TKIZB		;not a letter or digit
14814:	366B  FE47    	CPYH1:	CP	'F'+1
14815:	366D  D20B36  		JP	NC,TKIZB	;letter but not legit hex digit
14816:	3670  C35936  		JP	COPYH		;ok, copy it
14817:			
14818:			;TLKUP performs table lookup for the tokenizer.
14819:			;Call:	C	- number of table entries
14820:			;	DE	address of first table byte
14821:			;	HL	address of first text byte
14822:			;Retn:	Carry	set if not found
14823:			;	A	token (position of matched word from table bottom) if found,
14824:			;			first text byte if not
14825:			;	B	preserved
14826:			;	C	token if found, zero if not
14827:			;	DE	address of first text byte if found,
14828:			;			of first byte following table if not
14829:			;	HL	address of last matched text byte if found,
14830:			;			of first text byte (i.e. unchanged) if not
14831:	3673  E5      	TLKUP:	PUSH	HL		;save text pointer
14832:	3674  7E      	TLKU0:	LD	A,(HL)		;fetch text char
14833:	3675  D620    		SUB	20H		;convert lower case to upper
14834:	3677  FE41    		CP	'A'
14835:	3679  DA8236  		JP	C,TLKU1		;char  < 'a'
14836:	367C  FE5B    		CP	'Z'+1
14837:	367E  D28236  		JP	NC,TLKU1	;char > 'z'
14838:	3681  77      		LD	(HL),A		;store converted char
14839:	3682  1A      	TLKU1:	LD	A,(DE)		;table byte to A
14840:	3683  BE      		CP	(HL)		;compare to text byte
14841:	3684  C28C36  		JP	NZ,TLKU2
14842:	3687  13      		INC	DE		;matched -- try next byte
14843:	3688  23      		INC	HL
14844:	3689  C37436  		JP	TLKU0
14845:	368C  E67F    	TLKU2:	AND	7FH		;reset sign bit of table byte
14846:	368E  BE      		CP	(HL)		;compare again
14847:	368F  C29536  		JP	NZ,TLKU3	;failed -- no match
14848:	3692  79      		LD	A,C		;match -- return token in A, Carry reset
14849:	3693  D1      		POP	DE		;unstack the saved pointer
14850:	3694  C9      		RET
14851:	3695  1A      	TLKU3:	LD	A,(DE)		;failed
14852:	3696  13      		INC	DE
14853:	3697  E680    		AND	80H		;look at sign bit
14854:	3699  CA9536  		JP	Z,TLKU3		;keep looking for end of entry
14855:	369C  E1      		POP	HL		;restore text pointer
14856:	369D  0C      		INC	C		;increment count
14857:	369E  C27336  		JP	NZ,TLKUP	;try next table entry
14858:	36A1  7E      		LD	A,(HL)		;return text char if no match
14859:	36A2  37      		SCF			;return Carry on failure
14860:	36A3  C9      		RET
14861:				ENDIF			;end of WILD OR NOT COMPL conditional
14862:			
14863:	FFFF          		IF	NOT COMPL
14864:			;ADDL adds a tokenized line to source text.
14865:			;Call:	(lnnum)	line #
14866:			;	(lnlen)	line length, 0 to delete
14867:			;	(newln)	address of first byte of new line
14868:			;	(eofad)	end of source file address
14869:			;If line # is already in text, the old line is replaced with the new.
14870:			;If not, the new line is simply inserted.
14871:			;Branches out if memory full, i.e. if source top overlaps symbol table bottom.
14872:			;Clobbers all registers.
14873:	36A4          	ADDLN:
14874:	0000          		IF	ROMSQ
14880:				ENDIF
14881:	36A4  2AE23C  		LD	HL,(LNNUM)
14882:	36A7  EB      		EX	DE,HL		;line # to DE
14883:	36A8  CD4137  		CALL	FINDL		;look for it
14884:	36AB  E5      		PUSH	HL		;save pointer for line insertion later
14885:	36AC  010000  		LD	BC,0		;length of old line to BC
14886:	36AF  DAB336  		JP	C,ADDL0		;0 if no such line,
14887:	36B2  4E      		LD	C,(HL)		;  else length from pointer
14888:	36B3  09      	ADDL0:	ADD	HL,BC		;address of next  line = old + length to HL
14889:	36B4  22503E  		LD	(TEMP),HL	;save it for old > new case below
14890:	36B7  EB      		EX	DE,HL
14891:	36B8  CD0802  		CALL	CPLDE		;- next line address to DE
14892:	36BB  2ACA3F  		LD	HL,(EOFAD)	;end of file address to HL
14893:	36BE  23      		INC	HL
14894:	36BF  19      		ADD	HL,DE		;eof - next line + 1 = count to HL
14895:	36C0  EB      		EX	DE,HL		;count to DE for block move
14896:	36C1  3AC33F  		LD	A,(LNLEN)	;new line length to A, 0 to delete
14897:	36C4  91      		SUB	C		;new - old = offset
14898:	36C5  4F      		LD	C,A		;offset to c
14899:	36C6  DA1A37  		JP	C,ADDL4		;old > new
14900:	36C9  CAF436  		JP	Z,ADDL2		;old = new, so just insert it
14901:			;block move text below longer new line
14902:	36CC  D5      		PUSH	DE		;old < new
14903:	36CD  2A5D3E  		LD	HL,(SYMTA)
14904:	36D0  11F7FF  		LD	DE,-9
14905:	36D3  19      		ADD	HL,DE		;leave enough room to compute trivial exprs
14906:	36D4  EB      		EX	DE,HL		;symbol table address to DE
14907:	36D5  2ACA3F  		LD	HL,(EOFAD)
14908:	36D8  E5      		PUSH	HL
14909:	36D9  09      		ADD	HL,BC		;HL gets eofad + offset = destination
14910:	36DA  44      		LD	B,H
14911:	36DB  4D      		LD	C,L
14912:	36DC  CD2302  		CALL	CMBDU		;compare destination to symbol table addr
14913:	36DF  D42B37  		CALL	NC,LNNU0	;out of memory -- reset LNNUM to 0
14914:	36E2  D24320  		JP	NC,OMERR	;and issue fatal OM error
14915:	36E5  22CA3F  		LD	(EOFAD),HL	;reset EOF address
14916:	36E8  C1      		POP	BC		;BC gets old eof address = source
14917:	36E9  D1      		POP	DE		;restore count
14918:	36EA  0A      	ADDL1:	LD	A,(BC)		;fetch byte from BC
14919:	36EB  77      		LD	(HL),A		;store through HL
14920:	36EC  0B      		DEC	BC
14921:	36ED  2B      		DEC	HL
14922:	36EE  1B      		DEC	DE
14923:	36EF  7A      		LD	A,D
14924:	36F0  B3      		OR	E
14925:	36F1  C2EA36  		JP	NZ,ADDL1	;move more bytes
14926:			;insert current line into source
14927:	36F4  D1      	ADDL2:	POP	DE		;recover insertion address
14928:	36F5  3AC33F  		LD	A,(LNLEN)
14929:	36F8  B7      		OR	A
14930:	36F9  CA1437  		JP	Z,ADDL3		;done if length = 0
14931:	36FC  12      		LD	(DE),A		;else store length
14932:	36FD  D604    		SUB	4		;length - overhead = length to move
14933:	36FF  01703E  		LD	BC,TLNAD	;source address to BC
14934:	3702  2AE23C  		LD	HL,(LNNUM)
14935:	FFFF          		IF	EDITC
14936:	3705  22E43C  		LD	(ERRLN),HL	;set ERRLN
14937:				ENDIF
14938:	3708  EB      		EX	DE,HL		;insertion addr to HL, lnnum to DE
14939:	3709  CD5022  		CALL	MOMDE		;store line #
14940:	370C  23      		INC	HL
14941:	370D  3600    		LD	(HL),0		;store zero break byte
14942:	370F  23      		INC	HL		;HL now has destination
14943:	3710  5F      		LD	E,A		;actual length to E for insertion
14944:	3711  CD3437  		CALL	MOVD0		;copy new line into text
14945:			;reset stacks and return
14946:	3714  2ACA3F  	ADDL3:	LD	HL,(EOFAD)	;eof address to HL
14947:	3717  C37B27  		JP	NEW1		;reset stacks and return
14948:			;block move text below shorter new line
14949:	371A  2A503E  	ADDL4:	LD	HL,(TEMP)	;recover next text line address
14950:	371D  E5      		PUSH	HL
14951:	371E  05      		DEC	B		;B becomes 255, since offset in BC is < 0
14952:	371F  09      		ADD	HL,BC		;HL gets next + offset = destination
14953:	3720  C1      		POP	BC		;BC gets next = source
14954:	3721  CD3637  		CALL	MOVED		;move text down in memory
14955:	3724  2B      		DEC	HL
14956:	3725  22CA3F  		LD	(EOFAD),HL	;reset EOF address
14957:	3728  C3F436  		JP	ADDL2		;and insert current line
14958:			
14959:			;LNNU0 resets LNNUM to 0.
14960:	372B  210000  	LNNU0:	LD	HL,0
14961:	372E  22E23C  		LD	(LNNUM),HL
14962:	3731  C9      		RET
14963:			
14964:				ENDIF			;end of NOT COMPL conditional
14965:			
14966:			;MOVED performs block move of memory Down.
14967:			;Call:	BC	source address
14968:			;	DE	count (# of bytes to move)
14969:			;	HL	destination address
14970:			;Retn:	A	clobbered
14971:			;	BC	address of last source byte + 1
14972:			;	DE	zero
14973:			;	HL	address of last destination byte + 1
14974:			;MOVEB moves 2 or 4 bytes with MOVED.
14975:	3732          	MOVEB:
14976:	FFFF          		IF	FLOAT		;byte count to DE
14977:	3732  1E04    		LD	E,VBYTS-1
14978:				ELSE
14980:				ENDIF			;and fall through to MOVD0
14981:	3734  1600    	MOVD0:	LD	D,0
14982:	3736  0A      	MOVED:	LD	A,(BC)		;BC contains source
14983:	3737  77      		LD	(HL),A		;HL contains destination
14984:	3738  03      		INC	BC
14985:	3739  23      		INC	HL
14986:	373A  1B      		DEC	DE		;DE contains count
14987:	373B  7A      		LD	A,D
14988:	373C  B3      		OR	E		;test if (DE) = 0
14989:	373D  C23637  		JP	NZ,MOVED
14990:	3740  C9      		RET
14991:			
14992:			;FINDL finds line with given line # in user source text.
14993:			;Call:	DE	desired line #
14994:			;Retn:	A	clobbered
14995:			;	BC	value of HL when called
14996:			;	DE	preserved, i.e. desired line #
14997:			;	HL	address of a user source line length byte, namely:
14998:			;			Success, length byte of desired line # in source
14999:			;			Failure, length byte of first greater line #, or EOF
15000:			;	Carry	set iff not found
15001:			;	Zero	set if found or if at end of table
15002:	3741  E5      	FINDL:	PUSH	HL
15003:	0000          		IF	ROMSQ
15005:				ELSE
15006:	3742  21CF3F  		LD	HL,SRCAD	;search from start
15007:				ENDIF
15008:	3745  7E      	FNDL1:	LD	A,(HL)		;length byte to A
15009:	3746  B7      		OR	A
15010:	3747  CA6037  		JP	Z,FNDL2		;not found if at end of table
15011:	374A  23      		INC	HL
15012:	374B  4E      		LD	C,(HL)
15013:	374C  23      		INC	HL
15014:	374D  46      		LD	B,(HL)		;source line # to BC
15015:	374E  2B      		DEC	HL
15016:	374F  2B      		DEC	HL		;point to length byte again
15017:	3750  CD2302  		CALL	CMBDU		;compare to desired line #
15018:	3753  CA6137  		JP	Z,FNDL3		;equal -- success
15019:	3756  D26037  		JP	NC,FNDL2	;greater -- failure
15020:	3759  4E      		LD	C,(HL)		;less, keep trying -- length to BC
15021:	375A  0600    		LD	B,0
15022:	375C  09      		ADD	HL,BC		;let HL point to address of next entry
15023:	375D  C34537  		JP	FNDL1
15024:	3760  37      	FNDL2:	SCF			;failure -- return with carry set
15025:	3761  C1      	FNDL3:	POP	BC		;return old HL in BC
15026:	3762  C9      		RET
15027:			
15028:			;FDLNO does a FINDL, issues fatal US error if not found.
15029:	3763  CD4137  	FDLNO:	CALL	FINDL
15030:	3766  D0      		RET	NC
15031:	3767  C35419  		JP	USERR
15032:			
15033:			;end of TOKENIZE
15035:			;XMATH 06/09/80
15036:			;XYBASIC Interpreter Source Module
15037:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
15038:			;floating point extended function package
15039:			
15040:			
15041:	FFFF          		IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)
15042:			
15043:			
15044:			;8080 FLOATING POINT POLYNOMIAL EXPANDER - FPOLY
15045:			;  THIS ROUTINE EVALUATES A POLYNOMIAL OF THE FORM
15046:			;F(X) = A(0) + A(1)*X^(1*(K+J)) + A(2)*X^(2*(K+J))
15047:			;		+ A(2)*X^(2*(K+J)) + ...
15048:			; WHERE
15049:			;	A(0) IS AN INITIAL SUM VALUE IN THE
15050:			;	     THE FLOATING POINT ACCUMULATOR
15051:			;	A(N) IS A TERM CONSTANT FROM A LIST, THE
15052:			;	     ADDRESS OF WHICH IS SUPPLIED IN HL
15053:			; AND K AND J ARE INTEGER VALUES SIMULATED BY
15054:			; A SUPPLIED VALUE FOR THE INITIAL POWER TERM, AND
15055:			; A SUPPLIED VALUE FOR THE POWER TERM TO BE
15056:			; MULTIPLIED BY AFTER EACH TERM CALCULATION.
15057:			;    THE EVALUATION IS TERMINATED BY ONE OF TWO EVENTS.
15058:			;	1. IF THE SUPPLIED SIGNIFICANCE STOP VALUE
15059:			;	   IS EVER LESS THAN THE SIGNIFICANCE INDEX
15060:			;	   RETURNED BY THE FLOATING POINT ADD ROUTINE
15061:			;	   (INDICATING THE TERM WOULD NOT AFFECT THE RESULT)
15062:			;OR
15063:			;	2. A TERM CONSTANT WITH AN EXPONENT OF ZERO
15064:			;	   IS ENCOUNTERED.
15065:			;
15066:			;DETAILED CALLING SEQUENCE ...
15067:			;
15068:			;	LXI	H,INPWR		;ADDRESS OF POWER LIST
15069:			;	PUSH	H		;ON STACK
15070:			;	LXI	H,KLIST		;ADDRESS OF CONSTANT LIST
15071:			;	CALL	FPOLY
15072:				;	...		;RETURN HERE WITH F(X) INFACC
15073:			;
15074:			;INPWR:	DS	4		;INITIAL POWER OF X
15075:			;	DS	4		;TERM POWER MULTIPLIER
15076:			;
15077:			;	...
15078:			;
15079:			;KLIST:	DB	-1		;SIGNIFICANCE STOP VALUE
15080:			;	DW	K,K		;TERM CONSTANT A(1)
15081:			;	DW	K,K		;TERM CONSTANT A(2)
15082:			;	...
15083:			;	DW	K,K		;TERM CONSTANT A(N)
15084:			;	DB	0		;TERMINATOR
15085:			;
15086:			;   A SIGNIFICANCE STOP VALUE OF -1 WILL CAUSE THE
15087:			;ROUTINE TO UNCONDITIONALLY CALCULATE ALL TERMS IN
15088:			;THE LIST.  A VALUE OF 16 IS USED IN THE SIN/COS
15089:			;ROUTINE WITH NO EFFECT ON THE ACCURACY.
15090:			;  SEE THE DESCRIPTION OF THE INDEX IN THE MATH PACKAGE WRITEUP.
15091:			
15092:	376A  115A3D  	FPOLY:	LD	DE,SIG	;MOVE ARGS OVER
15093:	376D  7E      		LD	A,(HL)		;GET SIG
15094:	376E  12      		LD	(DE),A		;AND SAVE
15095:	376F  23      		INC	HL
15096:	3770  22673D  		LD	(VECT),HL	;SAVE TERM TABLE ADDRESS
15097:	3773  E1      		POP	HL		;POP OFF RETURN ADDRESS
15098:	3774  E3      		EX	(SP),HL		;AND EXCHANGE WITH ARGUMENT
15099:	3775  0E08    		LD	C,8
15100:	3777  7E      	FPOL0:	LD	A,(HL)
15101:	3778  23      		INC	HL
15102:	3779  13      		INC	DE
15103:	377A  12      		LD	(DE),A
15104:	377B  0D      		DEC	C
15105:	377C  C27737  		JP	NZ,FPOL0
15106:	377F  CDC90E  		CALL	FTEST		;RESTORE
15107:	3782  21633D  		LD	HL,FPSUM	;AND SAVE
15108:	3785  E5      		PUSH	HL
15109:	3786  CDB00E  		CALL	FSTOR		; SUM
15110:	3789  215B3D  		LD	HL,FPTXN
15111:	378C  CDDD0E  		CALL	FLOAD		;GET CURRENT POWER
15112:	378F  2A673D  	FPOL1:	LD	HL,(VECT)	;AND CURRENT TERM
15113:	3792  CDFA0E  		CALL	FMUL		;A(N)*X^(N+K)
15114:	3795  E1      		POP	HL
15115:	3796  E5      		PUSH	HL
15116:	3797  CD470F  		CALL	FADD		;ADD IT IN
15117:	379A  F5      		PUSH	AF
15118:	379B  3A5A3D  		LD	A,(SIG)
15119:	379E  BB      		CP	E		;CHECK FOR NO SIGNIFICANCE
15120:	379F  DACD37  		JP	C,FPOL2
15121:	37A2  F1      		POP	AF
15122:	37A3  E1      		POP	HL
15123:	37A4  E5      		PUSH	HL
15124:	37A5  CDB00E  		CALL	FSTOR
15125:	37A8  2A673D  		LD	HL,(VECT)
15126:	37AB  110400  		LD	DE,4
15127:	37AE  19      		ADD	HL,DE
15128:	37AF  22673D  		LD	(VECT),HL
15129:	37B2  7E      		LD	A,(HL)
15130:	37B3  A7      		AND	A
15131:	37B4  E1      		POP	HL
15132:	37B5  CADD0E  		JP	Z,FLOAD
15133:	37B8  E5      		PUSH	HL
15134:	37B9  215B3D  		LD	HL,FPTXN
15135:	37BC  E5      		PUSH	HL
15136:	37BD  CDDD0E  		CALL	FLOAD
15137:	37C0  215F3D  		LD	HL,FPTXN+4
15138:	37C3  CDFA0E  		CALL	FMUL
15139:	37C6  E1      		POP	HL
15140:	37C7  CDB00E  		CALL	FSTOR
15141:	37CA  C38F37  		JP	FPOL1
15142:			
15143:	37CD  F1      	FPOL2:	POP	AF
15144:	37CE  E1      		POP	HL
15145:	37CF  C9      		RET
15146:			
15147:			
15148:			;8080 INTEGER/FRACTIONAL PART - FINT
15149:			;	CALL FINT	;ARGUMENT IN FAC
15150:			;	...
15151:			;RETURNS WITH SIGNED INTEGER PART IN HL
15152:			;	   AND SIGNED FRACIONAL PART IN FAC
15153:			;
15154:			;OVERFLOW CONDITIONS SET IF
15155:			;  -32767 > VALUE > 32767
15156:			
15157:	37D0  CDC90E  	FINT:	CALL	FTEST		;SET UP ABCD TO FAC
15158:	37D3  5F      		LD	E,A		;SAVE EXP
15159:	37D4  78      		LD	A,B		;GET M0
15160:	37D5  E680    		AND	80H		;AND ISOLATE SIGN BIT
15161:	37D7  32693D  		LD	(FINSN),A	;SAVE SIGN
15162:	37DA  7B      		LD	A,E		;GET EXPONENT
15163:	37DB  FE81    		CP	129		;AND CHECK RANGE
15164:	37DD  D2E437  		JP	NC,FINT0	;NOT TOO SMALL
15165:	37E0  210000  		LD	HL,0		;VALUE .LT. 1.0
15166:	37E3  C9      		RET
15167:	37E4  FE90    	FINT0:	CP	144		;SEE IF TOO LARGE
15168:	37E6  DAFB37  		JP	C,FINT2		;VALUE IS IN RANGE
15169:	37E9  3A693D  		LD	A,(FINSN)	;OVERFLOW
15170:	37EC  07      		RLCA			;SET HL
15171:	37ED  21FF7F  		LD	HL,7FFFH	;TO +/-
15172:	37F0  D2F437  		JP	NC,$+4		; FULL SCALE
15173:	37F3  23      		INC	HL
15174:	37F4  E5      		PUSH	HL
15175:	37F5  CDC90E  		CALL	FTEST		;RESTORE ABCD
15176:	37F8  E1      		POP	HL		;AND
15177:	37F9  37      		SCF			;SET OFLOW AND
15178:	37FA  C9      		RET			;EXIT
15179:			
15180:			;SET UP MANTISSA FOR SHIFTING AND CLEAR INTEGER
15181:	37FB  EB      	FINT2:	EX	DE,HL		;D->H
15182:	37FC  C5      		PUSH	BC		;MOV BC
15183:	37FD  D1      		POP	DE		;TO DE
15184:	37FE  D680    		SUB	80H		;MAKE SHIFT COUNT
15185:	3800  4F      		LD	C,A		;INTO C
15186:	3801  44      		LD	B,H		;MOVE M2
15187:	3802  7A      		LD	A,D		;SET
15188:	3803  F680    		OR	80H		;MANTISSA
15189:	3805  57      		LD	D,A		; B23
15190:	3806  210000  		LD	HL,0		;CLEAR INTEGER
15191:			;MANTISSA (M0,M1,M2) IN DEB, INTEGER (I0,I1) IN HL
15192:			;SHIFT  H  L  D  E  B   LEFT 'C' BITS
15193:			;      I0,I1,M0,M1,M2
15194:	3809  29      	FINT3:	ADD	HL,HL		;I0,I1 LEFT
15195:	380A  EB      		EX	DE,HL
15196:	380B  29      		ADD	HL,HL		;M0,M1 LEFT INTO CY
15197:	380C  D21038  		JP	NC,$+4
15198:	380F  13      		INC	DE		;CY PROPAGATE INTO I0,I1
15199:	3810  EB      		EX	DE,HL
15200:	3811  AF      		XOR	A		;CLEAR A & CY
15201:	3812  80      		ADD	A,B		;GET M2
15202:	3813  17      		RLA			;LEFT B7->CY, 0->B0
15203:	3814  47      		LD	B,A		; AND RESTORE
15204:	3815  D21938  		JP	NC,$+4
15205:	3818  13      		INC	DE		;CY PROPAGATE INTO M0,M1
15206:	3819  0D      		DEC	C		;DECREMENT EXP
15207:	381A  C20938  		JP	NZ,FINT3	;AND CONTINUE
15208:	381D  EB      		EX	DE,HL		;I0,I1 <-> M0',M1'
15209:			;CHECK NEW MANTISSA (M0',M1',M2') FOR ZERO
15210:	381E  B4      		OR	H		;CHECK
15211:	381F  B5      		OR	L		;MN'
15212:	3820  CA4138  		JP	Z,FINT6		;MN' IS ZERO
15213:			;NORMALISE NEW MANTISSA IN HLB
15214:			; DECREMENTING EXPONENT IN C
15215:	3823  7C      	FINT4:	LD	A,H		;GET M0'
15216:	3824  07      		RLCA			;CHECK HIGH ORDER BIT B23
15217:	3825  DA3438  		JP	C,FINT5		;NORMALIZATION COMPLETE
15218:	3828  29      		ADD	HL,HL		;SHIFT M0',M1' LEFT
15219:	3829  78      		LD	A,B		;GET M2'
15220:	382A  17      		RLA			;M2' LEFT B7->CY, 0->B0
15221:	382B  47      		LD	B,A		;RESTORE
15222:	382C  D23038  		JP	NC,$+4		;NO DATA
15223:	382F  23      		INC	HL		;PROPAGATE BIT
15224:	3830  0D      		DEC	C		;DECREMENT EXPONENT
15225:	3831  C32338  		JP	FINT4		;AND CONTINUE
15226:			;PREPARE FRACTIONAL PART FOR STORAGE
15227:	3834  7C      	FINT5:	LD	A,H		;GET M0'
15228:	3835  E67F    		AND	127		;KILL B23
15229:	3837  67      		LD	H,A		;(SIGN)
15230:	3838  3A693D  		LD	A,(FINSN)	;GET SIGN OF INPUT
15231:	383B  B4      		OR	H		;AND MOVE TO B23
15232:	383C  65      		LD	H,L		;SWAP FOR
15233:	383D  6F      		LD	L,A		;SHLD LATER
15234:	383E  79      		LD	A,C		;GET EXPONENT
15235:	383F  C680    		ADD	A,80H		;AND BIAS UP
15236:			;STORE FRACIONAL PART FOR RE-LOAD
15237:	3841  326A3D  	FINT6:	LD	(FINFP),A	;STORE EXP
15238:	3844  226B3D  		LD	(FINFP+1),HL	;STORE M0',M1'
15239:	3847  78      		LD	A,B		;GET M2'
15240:	3848  326D3D  		LD	(FINFP+3),A	;AND STORE
15241:			;TRANSFER SIGN TO INTEGER
15242:	384B  3A693D  		LD	A,(FINSN)	;GET SIGN
15243:	384E  07      		RLCA
15244:	384F  D25938  		JP	NC,FINT7	;POSITIVE
15245:	3852  7A      		LD	A,D		;NEGATE
15246:	3853  2F      		CPL			;INTEGER
15247:	3854  57      		LD	D,A		; BY
15248:	3855  7B      		LD	A,E		;  COMPLEMENTING
15249:	3856  2F      		CPL			;   AND
15250:	3857  5F      		LD	E,A		;    ADDING
15251:	3858  13      		INC	DE		;     ONE
15252:	3859  D5      	FINT7:	PUSH	DE		;SAVE INTEGER
15253:	385A  216A3D  		LD	HL,FINFP	;RE-LOAD
15254:	385D  CDDD0E  		CALL	FLOAD		;FRACTION TO FAC
15255:	3860  E1      		POP	HL		;RESTORE INTEGER
15256:	3861  C9      		RET			;AND EXIT
15257:			
15258:			
15259:			;FSQR - 8080 FLOATING POINT SQUARE ROOT
15260:			;METHOD:	APPROXIMATION FOLLOWED BY THREE
15261:			;		NEWTON ITERATIONS
15262:			;
15263:			; SQUARE ROOT (X)
15264:			;
15265:			;LET X=2^(2B)*F WHEN .25<=F<1
15266:			;THEN SQR(X)=2^B*SQR(F)
15267:			;WHERE SQR(F)=P(I)   I=NUMBER OF ITERATION
15268:			;
15269:			; P(1)=A*F+B   AS A FIRST APPROXIMATION
15270:			;   WHERE A=.875, B=.27863 WHEN .25<=F<.5
15271:			;    OR
15272:			;	   A=.578125, B=.421875 WHEN .5<=F<1
15273:			;AND THEN
15274:			;	P(I+1)=(P(I)+F/P(I))/2
15275:			;  AND P(4) IS FINAL RESULT FOR SQR(F)
15276:			;
15277:			;CALLING SEQUENCE WITH 8008/8080 MATH PACKAGE
15278:			;	CALL	FSQR		;SQR(FPAC) -> FPAC
15279:			;
15280:			;NEGATIVE INPUTS WILL BE TREATED AS POSITIVE AFTER CALLING FCERN
15281:	3862  CDC90E  	FSQR:	CALL	FTEST		;RESTORE
15282:	3865  C8      		RET	Z		;ZERO
15283:	3866  FC8C13  		CALL	M,FCERN		;NEGATIVE ERROR
15284:	3869  FCC10E  		CALL	M,FABS		;SET FLAG AND USE ABS VALUE
15285:	386C  216E3D  		LD	HL,FPTXX	;AND SAVE
15286:	386F  CDB00E  		CALL	FSTOR		;X
15287:	3872  1E80    		LD	E,80H		;CALCULATE
15288:	3874  0F      		RRCA			;EXPONENT
15289:	3875  D27938  		JP	NC,$+4		; FOR
15290:	3878  1D      		DEC	E		;  F
15291:	3879  7B      		LD	A,E		;AND
15292:	387A  21723D  		LD	HL,FPTF		;STORE
15293:	387D  CDB00E  		CALL	FSTOR		; F
15294:	3880  0F      		RRCA			;DECIDE
15295:	3881  21D038  		LD	HL,FPTA1
15296:	3884  D28A38  		JP	NC,$+6		;WHICH
15297:	3887  21D838  		LD	HL,FPTA2	; A AND B
15298:	388A  E5      		PUSH	HL		;    TO USE
15299:	388B  CDDD0E  		CALL	FLOAD		; AND FETCH A
15300:	388E  21723D  		LD	HL,FPTF		;CALCULATE
15301:	3891  CDFA0E  		CALL	FMUL		;AF
15302:	3894  E1      		POP	HL		; AND
15303:	3895  23      		INC	HL		;  THEN
15304:	3896  23      		INC	HL		;   GET
15305:	3897  23      		INC	HL		;    B
15306:	3898  23      		INC	HL
15307:	3899  CD470F  		CALL	FADD		;AF+B
15308:	389C  21763D  		LD	HL,FPTP		;AND
15309:	389F  E5      		PUSH	HL
15310:	38A0  CDB00E  		CALL	FSTOR		; SAVE P1
15311:	38A3  CDB938  		CALL	NEWTN		;THREE
15312:	38A6  CDB938  		CALL	NEWTN		;NEWTON
15313:	38A9  CDB938  		CALL	NEWTN		; ITERATIONS
15314:	38AC  67      		LD	H,A		;SAVE RESULT EXPONENT
15315:	38AD  3A6E3D  		LD	A,(FPTXX)	;CALCULATE
15316:	38B0  D67F    		SUB	127		;EXPONENT
15317:	38B2  1F      		RRA			; FOR
15318:	38B3  84      		ADD	A,H		;  RESULT
15319:	38B4  E1      		POP	HL
15320:	38B5  77      		LD	(HL),A		;AND SET IT
15321:	38B6  C3DD0E  		JP	FLOAD		;LOAD RESULT
15322:			
15323:	38B9  21723D  	NEWTN:	LD	HL,FPTF	;GET
15324:	38BC  CDDD0E  		CALL	FLOAD		;F
15325:	38BF  21763D  		LD	HL,FPTP
15326:	38C2  E5      		PUSH	HL
15327:	38C3  CD250F  		CALL	FDIV		;F/P
15328:	38C6  E1      		POP	HL
15329:	38C7  E5      		PUSH	HL
15330:	38C8  CD470F  		CALL	FADD		;F/P+P
15331:	38CB  3D      		DEC	A		;(F/P+P)/2
15332:	38CC  E1      		POP	HL		;AND
15333:	38CD  C3B00E  		JP	FSTOR		; SAVE P(I+1)
15334:			
15335:			
15336:	38D0  80600000	FPTA1:	DEFB	80H,60H,0,0;.875
15337:	38D4  7F0EA898		DEFB	7FH,0EH,0A8H,98H;.27863
15338:			
15339:	38D8  80140000	FPTA2:	DEFB	80H,14H,0,0;.578125
15340:	38DC  7F580000		DEFB	7FH,58H,0,0	;.421875
15341:			
15342:			
15343:			;********* END - FSQR *********
15344:			
15345:			
15346:			;8080 FLOATING POINT EXPONENTIAL - FEXP
15347:			;	CALL	FEXP		;E^(FAC) -> FAC
15348:			;
15349:			; **** INTERNAL OVER/UNDERFLOW WILL OCCUR FOR INPUT
15350:			;	VALUES GREATER THAN LN(2^127)/(LOGBASE2(E)).
15351:			;	OR APPROXIMATELY
15352:			;	      -61 < VALUE < 61
15353:			;
15354:			; IF OVERFLOW OCCURS THEN 'ERROR' WILL BE CALLED AND
15355:			; FAC WILL BE SET TO FULL SCALE VALUE.
15356:			;
15357:			;METHOD:
15358:			; POLYNOMIAL APPROXIMATION
15359:			;TO FIND E^X THE FOLLOWING IDENTITY IS USED.
15360:			;TO REDUCE THE RANGE, WE LET
15361:			;	X LOG2 E = N + D + Z
15362:			;WHERE ...
15363:			;	N IS THE INTEGRAL PORTION OF THE REAL NUMBER,
15364:			;	D IS A DISCRETE FRACTION (1/8, 3/8, 5/8, OR
15365:			;	  7/8) OF THE REAL NUMBER (FRAC PART), AND
15366:			;	Z IS THE REMAINDER WHICH IS IN THE RANGE
15367:			;	  -1/8 <= Z <= 1/8
15368:			; THUS,
15369:			;		E^X = 2^N * 2^D * 2^Z
15370:			;AND IT IS NECCESSARY TO ONLY APPROXIMATE 2^Z FOR
15371:			;-1/8 <= Z <= 1/8 BY USING THE POLYNOMIAL F(Z).
15372:			;
15373:			; F(Z) = A0 + A1*Z + A2*Z^2 + A3*Z^3 + A4*Z^4 +
15374:			;				A5*Z^5
15375:			;WHERE ...
15376:			;	A0 = 1.0
15377:			;	A1 = .69314718057
15378:			;	A2 = .24022648580
15379:			;	A3 = .055504105406
15380:			;	A4 = .0096217398747
15381:			;	A5 = .0013337729375
15382:			;
15383:	38E0  CDC90E  	FEXP:	CALL	FTEST		;SET ABCD TO FAC
15384:	38E3  78      		LD	A,B		;GET SIGN
15385:	38E4  327F3D  		LD	(FPSGN),A	;AND SAVE
15386:	38E7  CDC10E  		CALL	FABS		;TAKE ABS VALUE
15387:	38EA  21BC39  		LD	HL,LOG2E	;X=X*LOG2(E)
15388:	38ED  CDFA0E  		CALL	FMUL
15389:	38F0  CDD037  		CALL	FINT		;INTEGER TO HL, FRAC IN FAC
15390:	38F3  E5      		PUSH	HL		;SAVE INTEGER
15391:	38F4  217A3D  		LD	HL,FPTX		;AND
15392:	38F7  CDB00E  		CALL	FSTOR		; FRACTION
15393:	38FA  E1      		POP	HL		;RESTORE INTEGER
15394:	38FB  7C      		LD	A,H		;TO CHECK RANGE
15395:	38FC  A7      		AND	A
15396:	38FD  CA0A39  		JP	Z,FEXP1		;CAN'T BE > 256
15397:			
15398:	3900  3A7F3D  	FEXP0:	LD	A,(FPSGN);NUMBER TOO LARGE
15399:	3903  07      		RLCA			;SO RETURN
15400:	3904  DAB80E  		JP	C,FZRO		; 0 OR FULL SCALE
15401:	3907  C3390F  		JP	FOVER		;NONFATAL OV ERROR, TAKE MAX AND RETURN
15402:	390A  7D      	FEXP1:	LD	A,L		;CHECK N
15403:	390B  FE7F    		CP	127		;LARGEST THAT WILL FIT
15404:	390D  D20039  		JP	NC,FEXP0	;E^88 = 1.7 E+38
15405:	3910  327E3D  		LD	(FPTN),A	;SAVE INT PART N
15406:			;SELECT VALUE FOR 'D'
15407:	3913  3A7A3D  		LD	A,(FPTX)	;GET EXPONENT OF FRAC
15408:	3916  110400  		LD	DE,4
15409:	3919  218C39  		LD	HL,FPTDF
15410:	391C  FE7F    		CP	127
15411:	391E  DA2F39  		JP	C,FEXP5		;FRAC < .25
15412:	3921  19      		ADD	HL,DE		;FPTDF+4 TO HL
15413:	3922  CA2F39  		JP	Z,FEXP5		;.25 <= FRAC < .5
15414:	3925  19      		ADD	HL,DE		;FPTDF+8 TO HL
15415:	3926  3A7B3D  		LD	A,(FPTX+1)	;GET M0
15416:	3929  07      		RLCA			;SHIFT B6
15417:	392A  07      		RLCA			;TO CARRY
15418:	392B  D22F39  		JP	NC,FEXP5	;.5 <= FRAC < .75
15419:	392E  19      		ADD	HL,DE		;.75 <= FRAC < 1, FPTDF+12 TO HL
15420:	392F  E5      	FEXP5:	PUSH	HL		;HL POINTS TO SELECTED D
15421:	3930  217A3D  		LD	HL,FPTX		;X TO FAC
15422:	3933  CDDD0E  		CALL	FLOAD
15423:	3936  E1      		POP	HL		;ADDRESS OF D
15424:	3937  E5      		PUSH	HL		;SAVED AGAIN
15425:	3938  CD440F  		CALL	FSUB		;CALCULATE Z
15426:	393B  5F      		LD	E,A		;AND
15427:	393C  3A7F3D  		LD	A,(FPSGN)	; TRANSFER
15428:	393F  07      		RLCA			;  SIGN
15429:	3940  7B      		LD	A,E		;   TO Z
15430:	3941  DCBE0E  		CALL	C,FCHS
15431:	3944  21803D  		LD	HL,FPTZ0	;SAVE Z
15432:	3947  E5      		PUSH	HL		;PUSH FOR FPOLY
15433:	3948  CDB00E  		CALL	FSTOR		; IN
15434:	394B  21843D  		LD	HL,FPTZ1	;  POLY
15435:	394E  CDB00E  		CALL	FSTOR		;   TABLE
15436:	3951  21A20C  		LD	HL,FPONE	;GET TERM
15437:	3954  CDDD0E  		CALL	FLOAD		;A0 = 1.0
15438:	3957  21C439  		LD	HL,EXPLY	; AND DO THE
15439:	395A  CD6A37  		CALL	FPOLY		;  POLYNOMIAL F(Z)
15440:	395D  E1      		POP	HL		;SELECT
15441:	395E  111000  		LD	DE,16		;SIGNED
15442:	3961  EB      		EX	DE,HL		; VALUE
15443:	3962  3A7F3D  		LD	A,(FPSGN)	;  FOR
15444:	3965  07      		RLCA			;   2^D
15445:	3966  D26A39  		JP	NC,$+4
15446:	3969  29      		ADD	HL,HL		;2^-D TABLE
15447:	396A  19      		ADD	HL,DE		;HL HAS ADDRESS
15448:	396B  E5      		PUSH	HL		;OF 2^D
15449:	396C  CDC90E  		CALL	FTEST		;RESTORE
15450:	396F  E1      		POP	HL		;AND CALCULATE
15451:	3970  CDFA0E  		CALL	FMUL		;2^D * F(Z)
15452:			;NOW MULTIPLY BY 2^N
15453:	3973  5F      		LD	E,A		;SAVE EXP
15454:	3974  3A7F3D  		LD	A,(FPSGN)	;AND
15455:	3977  07      		RLCA			;TRANSFER
15456:	3978  3A7E3D  		LD	A,(FPTN)	;SIGN
15457:	397B  D28039  		JP	NC,$+5		; TO N
15458:	397E  2F      		CPL
15459:	397F  3C      		INC	A		;NEGATE N
15460:	3980  83      		ADD	A,E		;RESULT = 2^N * 2^D * F(Z)
15461:	3981  21843D  		LD	HL,FPTZ1	;STORE TEMP
15462:	3984  E5      		PUSH	HL
15463:	3985  CDB00E  		CALL	FSTOR		;FOR RELOAD
15464:	3988  E1      		POP	HL		; TO
15465:	3989  C3DD0E  		JP	FLOAD		;  EXIT WITH FAC = E^X
15466:			
15467:			
15468:			;D TEST VALUES AND 2^D TABLES
15469:	398C  7E000000	FPTDF:	DEFW	7EH,0		;.125
15470:	3990  7F400000		DEFW	407FH,0		;.375
15471:	3994  80200000		DEFW	2080H,0		;.625
15472:	3998  80600000		DEFW	6080H,0		;.875
15473:			
15474:			;2^D FOR PLUS D VALUES
15475:	399C  810B95C2		DEFW	0B81H,0C295H	;2^(1/8)
15476:	39A0  8125FED7		DEFW	2581H,0D7FEH	;2^(3/8)
15477:	39A4  8145672A		DEFW	4581H,2A67H	;2^(5/8)
15478:	39A8  816AC0C7		DEFW	6A81H,0C7C0H	;2^(7/8)
15479:			
15480:			;2^D FOR MINUS D VALUES
15481:	39AC  806AC0C7		DEFW	6A80H,0C7C0H	;2^(-1/8)
15482:	39B0  8045672A		DEFW	4580H,2A67H	;2^(-3/8)
15483:	39B4  8025FED7		DEFW	2580H,0D7FEH	;2^(-5/8)
15484:	39B8  800B95C2		DEFW	0B80H,0C295H	;2^(-7/8)
15485:			
15486:			;MISC. CONSTANTS
15487:	39BC  8138AA3B	LOG2E:	DEFW	3881H,3BAAH	;LOG2(E) 1.442695041
15488:	39C0  FF7FFFFF	FPMAX:	DEFW	7FFFH,-1	;POS FULL SCALE
15489:			
15490:			
15491:	39C4  FF      	EXPLY:	DEFB	-1	;POLY TABLE
15492:			
15493:	39C5  80317218		DEFW	3180H,1872H	;A1 .69314718057
15494:	39C9  7E75FDEF		DEFW	757EH,0EFFDH	;A2 .24022648580
15495:	39CD  7C635846		DEFW	637CH,4658H	;A3 .055504105406
15496:	39D1  7A1DA481		DEFW	1D7AH,81A4H	;A4 .0096217398747
15497:	39D5  772ED1FE		DEFW	2E77H,0FED1H	;A5 .0013337729375
15498:			
15499:	39D9  00      		DEFB	0		;TABLE TERMINATOR
15500:			
15501:			;****** END - FEXP ******
15502:			
15503:			
15504:			;8080 FLOATING POINT NATURAL LOGARITHM - FLN
15505:			;  THIS ROUTINE CALCULATES THE NATURAL LOGARITHM
15506:			;OF THE NUMBER IN THE FLOATING POINT ACCUMULATOR.
15507:			;
15508:			;	LN(FAC) -> FAC
15509:			;
15510:			;METHOD - POLYNOMIAL APPROXIMATION
15511:			;
15512:			; GIVEN A NORMALISED REAL NUMBER
15513:			;	X = 2^K * F
15514:			;WHERE THE RANGE OF F IS .5 <= F < 1, AND J AND G
15515:			;ARE FOUND SUCH THAT X = 2^J * G WHERE
15516:			;(SQR(2)/2) <= G < SQR(2).  THIS IS DONE BY SETTING
15517:			;J=K-1, G=2*F IF F < SQR(2)/2 AND J=K, G=F OTHER-
15518:			;WISE.
15519:			;
15520:			; THUS:
15521:			;	LN(X) = J * LN(2) + LN(G)
15522:			;
15523:			;   THE APPROXIMATION FOR LN(G), WHERE
15524:			;SQR(2)/2 <= G < SQR(2), IS BASED ON THE SERIES
15525:			; LN((V+X)/(V-X) = 2((X/V) + (X^3/(3*V^3)) +
15526:			;			(X^5/(5*V^5)) + ... )
15527:			;WHICH CONVERGES FOR (-V<X<V).
15528:			;
15529:			;   WITH THE TRANSFORMATION
15530:			;     X = V((G-1)/(G+1)), V = (SQR(2)+1)^2
15531:			;SO THAT -1 <= X < 1 FOR SQR(2)/2  <= G < SQR(2).
15532:			;
15533:			; SUBSTITUTING
15534:			;	LN(G) = 2(Z + Z^3/3 + Z^5/5 + ... )
15535:			; WHERE  Z = X/V = (G-1)/G+1).
15536:			;
15537:			;  THE APPROXIMATION USED IS G(Z) FOR LN(G)/Z IN
15538:			;THE RANGE SQR(2)/2 <= G < SQR(2).
15539:			; THUS THE REQUIRED CALCULATION IS
15540:			;	LN(X) = J * LN(2) + Z * G(Z)
15541:			;  G(Z) = B0 + B2*Z^2 + B4*Z^4 + B6*Z^6 + B8*Z^8
15542:			;WHERE
15543:			;	B0 = 2.0
15544:			;	B2 = .666666564181
15545:			;	B4 = .400018840613
15546:			;	B6 = .28453572660
15547:			;	B8 = .125
15548:			
15549:	39DA  CDC90E  	FLN:	CALL	FTEST		;RESTORE
15550:	39DD  FC8C13  		CALL	M,FCERN
15551:	39E0  CA8C13  		JP	Z,FCERN		;FC ERROR AND RETURN IF ZERO
15552:	39E3  FCC10E  		CALL	M,FABS		;MAKE INPUT POSITIVE AFTER ERROR
15553:	39E6  32903D  		LD	(FLNK),A	;SAVE EXPONENT
15554:	39E9  3E80    		LD	A,80H		;SAVE
15555:	39EB  21913D  		LD	HL,FLNF		;FRACTIONAL
15556:	39EE  E5      		PUSH	HL
15557:	39EF  CDB00E  		CALL	FSTOR		; PART
15558:	39F2  E1      		POP	HL		;RELOAD
15559:	39F3  E5      		PUSH	HL		; AND RESAVE
15560:	39F4  CDDD0E  		CALL	FLOAD		;  TO FACC
15561:	39F7  21703A  		LD	HL,FLNR2	;CHECK RANGE
15562:	39FA  CD440F  		CALL	FSUB		;NEG IF F < SQR(2)/2
15563:	39FD  E1      		POP	HL		;POINT TO F
15564:	39FE  F2053A  		JP	P,FLNA		;JMP IF F >= SQR(2)/2
15565:	3A01  2B      		DEC	HL		;POINT TO K
15566:	3A02  35      		DEC	(HL)		;J = K-1
15567:	3A03  23      		INC	HL		;BACK TO F
15568:	3A04  34      		INC	(HL)		;G = 2 * F
15569:	3A05  CDDD0E  	FLNA:	CALL	FLOAD		;GET G
15570:	3A08  21A20C  		LD	HL,FPONE	;GET 1.0
15571:	3A0B  CD470F  		CALL	FADD		;G+1
15572:	3A0E  21883D  		LD	HL,FLNZI	;AND
15573:	3A11  E5      		PUSH	HL
15574:	3A12  CDB00E  		CALL	FSTOR		; SAVE
15575:	3A15  21783A  		LD	HL,FLNM2	;GET -2.0
15576:	3A18  CD470F  		CALL	FADD		;G-1
15577:	3A1B  E1      		POP	HL
15578:	3A1C  E5      		PUSH	HL
15579:	3A1D  CD250F  		CALL	FDIV		;(G-1)/(G+1)
15580:	3A20  21913D  		LD	HL,FLNF		;SAVE
15581:	3A23  E5      		PUSH	HL
15582:	3A24  CDB00E  		CALL	FSTOR		;Z
15583:	3A27  E1      		POP	HL
15584:	3A28  CDFA0E  		CALL	FMUL		;Z^2
15585:	3A2B  E1      		POP	HL
15586:	3A2C  E5      		PUSH	HL		;SAVE FOR FPOLY
15587:	3A2D  CDB00E  		CALL	FSTOR		;SAVE
15588:	3A30  218C3D  		LD	HL,FLNZ2	;SAVE
15589:	3A33  CDB00E  		CALL	FSTOR		;TERM POWER
15590:	3A36  CDB80E  		CALL	FZRO		;CLEAR SUM
15591:	3A39  217C3A  		LD	HL,FLNPL	;AND
15592:	3A3C  CD6A37  		CALL	FPOLY		; CALC POLYNOMIAL
15593:	3A3F  21783A  		LD	HL,FLNM2	;ADD
15594:	3A42  CD440F  		CALL	FSUB		;2.0
15595:	3A45  21913D  		LD	HL,FLNF		;AND
15596:	3A48  E5      		PUSH	HL
15597:	3A49  CDFA0E  		CALL	FMUL		;Z*G(Z)
15598:	3A4C  E1      		POP	HL
15599:	3A4D  E5      		PUSH	HL
15600:	3A4E  CDB00E  		CALL	FSTOR		;Z*G(Z)
15601:			;FLOAT J, CALCULATE J * LN(2)
15602:	3A51  3A903D  		LD	A,(FLNK)	;GET J
15603:	3A54  D680    		SUB	80H		;UN-BIAS EXP
15604:	3A56  1E20    		LD	E,32		;SET INTEGER SCALING
15605:	3A58  57      		LD	D,A		;INTEGER TO I3
15606:	3A59  01FFFF  		LD	BC,-1		;INTEGER
15607:	3A5C  3EFF    		LD	A,-1		;NEGATIVE
15608:	3A5E  FA633A  		JP	M,$+5		;GO FLOAT
15609:	3A61  03      		INC	BC		;INTEGER
15610:	3A62  3C      		INC	A		;NEGATIVE
15611:	3A63  CD7E11  		CALL	FFLOT		;FLOAT J
15612:	3A66  21743A  		LD	HL,FLNL2
15613:	3A69  CDFA0E  		CALL	FMUL		;J*LN(2)
15614:	3A6C  E1      		POP	HL
15615:	3A6D  C3470F  		JP	FADD		;Z*G(Z)
15616:			
15617:			
15618:	3A70  803504F3	FLNR2:	DEFW	3580H,0F304H;SQR(2)/2
15619:	3A74  80317218	FLNL2:	DEFW	3180H,1872H	;LN(2)
15620:	3A78  82800000	FLNM2:	DEFW	8082H,0		;-2.0
15621:			
15622:	3A7C  10      	FLNPL:	DEFB	16	;SIG INDEX STOPPER
15623:	3A7D  802AAAA9		DEFW	2A80H,0A9AAH	;B2 .666666564181
15624:	3A81  7F4CCF45		DEFW	4C7FH,45CFH	;B4 .400018840613
15625:	3A85  7F11AEAB		DEFW	117FH,0ABAEH	;B6 .28453572660
15626:	3A89  7E000000		DEFW	7EH,0		;B8 .125
15627:			
15628:	3A8D  00      		DEFB	0		;TERMINATOR
15629:			
15630:			;******* END - FLN ******
15631:			
15632:			
15633:			;8080 FLOATING POINT SIN/COS ROUTINE - FSIN, FCOS
15634:			;  THIS ROUTINE WILL CALCULATE THE SINE OR COSINE
15635:			;OF THE ANGLE IN THE FLOATING POINT ACCUMULATOR.
15636:			;
15637:			;  THE ANGLE MUST BE IN RADIANS AND MAY HAVE ANY
15638:			;MAGNITUDE.
15639:			;
15640:			;	SIN(FAC) -> FAC
15641:			;	COS(FAC) -> FAC
15642:			;
15643:			;METHOD:
15644:			;	POLYNOMIAL APPROXIMATION
15645:			;
15646:			;   GIVEN A REAL NUMBER, X, N, AND Y ARE DEFINED
15647:			;SUCH THAT
15648:			;	X/(2*PI) = N + Y
15649:			;WHERE N IS AN INTEGER AND 0 <= Y < 1.
15650:			;THUS, X = 2*PI*N + 2*PI*Y, AND THE IDENTITIES ARE
15651:			;  SIN(X) = SIN(2*PI*Y) AND COS(X) = COS(2*PI*Y)
15652:			;
15653:			;THE POLYNOMIAL APPROXIMATION, F(Z), FOR THE
15654:			;FUNCTION SIN(2*PI*Z)/Z IS USED WHERE
15655:			;-.25 <= Z < .25.
15656:			;
15657:			;   THE PROPERTIES OF SINES AND COSINES ARE USED TO
15658:			;COMPUTE THESE FUNCTIONS AS FOLLOWS:
15659:			;
15660:			;	COS(2*PI*Y) = F(Z)
15661:			;WHERE
15662:			;	Z = .25-Y IN THE RANGE 0 <= Y < .5
15663:			;	Z = Y-.75 IN THE RANGE .5 <= Y < 1
15664:			;
15665:			;	SIN(2*PI*Y) = F(Z)
15666:			;WHERE
15667:			;	Z = Y IN THE RANGE 0 <=Y < .25
15668:			;	Z = .5-Y IN THE RANGE .25 <= Y < .75
15669:			;	Z = Y-1 IN THE RANGE .75 <= Y < 1
15670:			;
15671:			; F(Z) = A1*Z + A2*Z^3 + A3*Z^5 + A4*Z^7 + A5*Z^9
15672:			;WHERE
15673:			;	A1 = 6.2831853
15674:			;	A2 = -41.341681
15675:			;	A3 = 81.602481
15676:			;	A4 = -76.581285
15677:			;	A5 = 39.760722
15678:			
15679:	3A8E  3E      	FSIN:	DEFB	3EH		;(MVI A,0AFH) FN CODE FOR SIN
15680:	3A8F  AF      	FCOS:	XOR	A		;0 FN CODE FOR COS
15681:	3A90  32953D  		LD	(FSCFX),A	;SAVE FUNCTION CODE
15682:	3A93  CDC90E  		CALL	FTEST		;RESTORE
15683:	3A96  78      		LD	A,B		;GET M0
15684:	3A97  E680    		AND	80H		;STRIP OFF
15685:	3A99  32963D  		LD	(FSCSG),A	; AND SAVE
15686:	3A9C  CDC10E  		CALL	FABS		;GET ABS(FAC)
15687:	3A9F  212B3B  		LD	HL,F2PI
15688:	3AA2  CD250F  		CALL	FDIV		;X/(2*PI)
15689:	3AA5  FE81    		CP	129
15690:	3AA7  D4D037  		CALL	NC,FINT		;Y >= 1, GET FRACTIONAL PART
15691:	3AAA  5F      		LD	E,A		;SAVE EXPONENT
15692:	3AAB  3A953D  		LD	A,(FSCFX)	;CHECK
15693:	3AAE  07      		RLCA			;FUNCTION CODE
15694:	3AAF  7B      		LD	A,E		;RESTORE EXPONENT
15695:	3AB0  DAC73A  		JP	C,FSC3		;FUNCTION IS SIN
15696:	3AB3  FE80    		CP	80H
15697:	3AB5  DABE3A  		JP	C,FSC2		;Y < .5
15698:	3AB8  211E3B  		LD	HL,FSC75	;Y - .75
15699:	3ABB  C3E83A  		JP	FSC6
15700:	3ABE  CDBE0E  	FSC2:	CALL	FCHS		;-Y
15701:	3AC1  21223B  		LD	HL,FSC25	;.25-Y
15702:	3AC4  C3DF3A  		JP	FSC4A
15703:	3AC7  FE7F    	FSC3:	CP	127		;Y < .25 ?
15704:	3AC9  DAEB3A  		JP	C,FSC7		;YES, GO DO POLY
15705:	3ACC  FE80    		CP	80H
15706:	3ACE  DAD93A  		JP	C,FSC4		;Y < .5
15707:	3AD1  5F      		LD	E,A		;SAVE EXP
15708:	3AD2  78      		LD	A,B		;CHECK
15709:	3AD3  07      		RLCA			;B22
15710:	3AD4  07      		RLCA			; FOR
15711:	3AD5  7B      		LD	A,E		;  .75, RESTORE EXPONENT
15712:	3AD6  DAE53A  		JP	C,FSC5		;Y >= .75
15713:	3AD9  CDBE0E  	FSC4:	CALL	FCHS		;Y < .75 SO -Y
15714:	3ADC  21263B  		LD	HL,FSC50
15715:	3ADF  CD470F  	FSC4A:	CALL	FADD		;.5-Y
15716:	3AE2  C3EB3A  		JP	FSC7
15717:	3AE5  21A20C  	FSC5:	LD	HL,FPONE
15718:	3AE8  CD440F  	FSC6:	CALL	FSUB		;Y-1
15719:	3AEB  21973D  	FSC7:	LD	HL,FSCZ		;SAVE
15720:	3AEE  E5      		PUSH	HL
15721:	3AEF  CDB00E  		CALL	FSTOR		;Z
15722:	3AF2  E1      		POP	HL
15723:	3AF3  E5      		PUSH	HL		;SAVE FOR FPOLY
15724:	3AF4  CDFA0E  		CALL	FMUL		;Z^2
15725:	3AF7  219B3D  		LD	HL,FSCZ2
15726:	3AFA  CDB00E  		CALL	FSTOR		;SAVE Z^2
15727:	3AFD  CDB80E  		CALL	FZRO		;ZERO SUM
15728:	3B00  212A3B  		LD	HL,FSCPL	;AND
15729:	3B03  CD6A37  		CALL	FPOLY		; DO POLY
15730:	3B06  5F      		LD	E,A		;SAVE EXP
15731:	3B07  3A953D  		LD	A,(FSCFX)	;AND CHECK
15732:	3B0A  07      		RLCA			; FUNCTION
15733:	3B0B  7B      		LD	A,E		;RESTORE EXPONENT
15734:	3B0C  D0      		RET	NC		;AND EXIT IF COS FUNCTION
15735:	3B0D  3A963D  		LD	A,(FSCSG)	;GET INPUT SIGN
15736:	3B10  07      	FSC8:	RLCA			;TO CY -- FATN ENTRY POINT
15737:	3B11  7B      		LD	A,E		;RESTORE EXPONENT
15738:	3B12  D0      		RET	NC		;RETURN IF INPUT +
15739:	3B13  C3BE0E  		JP	FCHS		;ELSE CHANGE RESULT SIGN
15740:			
15741:			
15742:	3B16  82490FDB	FPI:	DEFW	4982H,0DB0FH;PI
15743:	3B1A  81490FDB	FHPI:	DEFW	4981H,0DB0FH	;PI/2
15744:	3B1E  80400000	FSC75:	DEFW	4080H,0		;.75
15745:	3B22  7F000000	FSC25:	DEFW	7FH,0		;.25
15746:	3B26  80000000	FSC50:	DEFW	80H,0		;.5
15747:			
15748:	3B2A  10      	FSCPL:	DEFB	16	;SIN/COS POLY SIG STOPPER
15749:	3B2B  83490FDB	F2PI:	DEFW	4983H,0DB0FH	;A1 PI*2
15750:	3B2F  86A55DE2		DEFW	0A586H,0E25DH	;A2 -41.341681
15751:	3B33  87233478		DEFW	2387H,7834H	;A3 81.602481
15752:	3B37  8799299E		DEFW	9987H,9E29H	;A4 -76.581285
15753:	3B3B  861F0AFB		DEFW	1F86H,0FB0AH	;A5 39.760722
15754:	3B3F  00      		DEFB	0		;TERMINATOR
15755:			
15756:			
15757:			;****** END - FSIN/FCOS ******
15758:			
15759:			
15760:			;8080 FLOATING POINT REAL BASE TO REAL EXPONENT
15761:			;		FAX
15762:			;  THIS ROUTINE RAISES A REAL NUMBER TO A REAL POWER.
15763:			;	***** NOTE *****
15764:			;  BECAUSE OF OVERFLOW CONDITIONS IN THE ROUTINE
15765:			;FLN, THE FOLLOWING LIMITS ARE PLACED ON THE
15766:			;INPUTS TO FAX:
15767:			;
15768:			;	A > 0
15769:			;AND
15770:			;	ABS(X*LN(A)) < 50.0
15771:			;
15772:			;CALLING SEQUENCE ...
15773:			;	LXI H,X		;ADDRESS OF X
15774:			;	CALL FAX	;FAC ^ X  ->  FAC
15775:			;
15776:			;METHOD
15777:			;If X is a positive integer < 256, iterated multiplication is used.
15778:			;Otherwise the identity  A^X = E^(X*LN(A)) is used.
15779:			
15780:	3B40  EB      	FATOX:	EX	DE,HL
15781:	3B41  23      		INC	HL		;ARG2 POINTER TO HL
15782:	3B42  E5      	FAX:	PUSH	HL
15783:	3B43  CDC90E  		CALL	FTEST		;load registers
15784:	3B46  219F3D  		LD	HL,FTMPA
15785:	3B49  CDB00E  		CALL	FSTOR		;save A in FTMPA
15786:	3B4C  E1      		POP	HL
15787:	3B4D  E5      		PUSH	HL
15788:	3B4E  CDDD0E  		CALL	FLOAD		;get X to FACC
15789:	3B51  CDD037  		CALL	FINT		;check if X is integer
15790:	3B54  F5      		PUSH	AF
15791:	3B55  E5      		PUSH	HL		;save integer part
15792:	3B56  219F3D  		LD	HL,FTMPA
15793:	3B59  CDDD0E  		CALL	FLOAD		;restore A to FACC
15794:	3B5C  D1      		POP	DE		;integer part to DE
15795:	3B5D  F1      		POP	AF
15796:	3B5E  E1      		POP	HL		;X pointer to HL
15797:	3B5F  B2      		OR	D		;Zero set iff A positive integer < 256
15798:	3B60  C27A3B  		JP	NZ,FAX2		;raise to real power
15799:	3B63  1C      		INC	E
15800:	3B64  D5      		PUSH	DE		;save the integer power+1
15801:	3B65  21A20C  		LD	HL,FPONE	;initialize result to 1.0
15802:	3B68  CDDD0E  		CALL	FLOAD
15803:	3B6B  D1      	FAX1:	POP	DE
15804:	3B6C  1D      		DEC	E		;decrement multiply count
15805:	3B6D  CAC90E  		JP	Z,FTEST		;done, set registers and return
15806:	3B70  D5      		PUSH	DE
15807:	3B71  219F3D  		LD	HL,FTMPA
15808:	3B74  CDFA0E  		CALL	FMUL		;multiply result by A
15809:	3B77  C36B3B  		JP	FAX1		;and continue multiplying
15810:	3B7A  E5      	FAX2:	PUSH	HL		;raising to real, large or negative power
15811:	3B7B  CDDA39  		CALL	FLN		;LN(A)
15812:	3B7E  E1      		POP	HL
15813:	3B7F  CDFA0E  		CALL	FMUL		;X*LN(A)
15814:	3B82  C3E038  		JP	FEXP		;E^(X*LN(A))
15815:			
15816:			
15817:	0000          		IF	FALSE
15874:				ENDIF
15875:			
15876:			;8080 FLOATING POINT TANGENT - FTAN
15877:			;   THIS ROUTINE CALCULATES THE TANGENT OF THE ANGLE
15878:			;IN THE FLOATING POINT ACCUMULATOR.
15879:			;   THE ANGLE MUST BE EXPRESSED IN RADIANS.
15880:			;
15881:			;	TAN(FAC) -> FAC
15882:			;
15883:			;METHOD
15884:			;	 THE FOLLOWING IDENTITY IS USED.
15885:			;
15886:			;	TAN(X) = SIN(X)/COS(X)
15887:			;
15888:			;	***** NOTE *****
15889:			; FOR VALUES OF X CLOSE TO 0 OR CLOSE TO A MULTIPLE
15890:			;OF 2*PI, EITHER THE SIN OR COS OF X WILL BE CLOSE
15891:			;TO UNITY.  THIS CONDITION WILL AFFECT THE ACCURACY
15892:			;USING THE IDENTITY ABOVE AND IT IS SUGGESTED
15893:			;THAT OTHER METHODS BE USED TO COMPUTE THE FUNCTION
15894:			;TAN(X) IF THIS INACCURACY CAN NOT BE TOLERATED.
15895:			
15896:	3B85  CDC90E  	FTAN:	CALL	FTEST		;RESTORE
15897:	3B88  C8      		RET	Z
15898:	3B89  219F3D  		LD	HL,FTMPA
15899:	3B8C  E5      		PUSH	HL
15900:	3B8D  CDB00E  		CALL	FSTOR		;SAVE X
15901:	3B90  CD8F3A  		CALL	FCOS		;COS(X)
15902:	3B93  21A33D  		LD	HL,FTMPB
15903:	3B96  CDB00E  		CALL	FSTOR		;SAVE COS(X)
15904:	3B99  E1      		POP	HL
15905:	3B9A  CDDD0E  		CALL	FLOAD		;GET X
15906:	3B9D  CD8E3A  		CALL	FSIN		;SIN(X)
15907:	3BA0  21A33D  		LD	HL,FTMPB
15908:	3BA3  C3250F  		JP	FDIV		;SIN(X)/COS(X)
15909:			
15910:			
15911:	0000          		IF	FALSE
15917:				ENDIF
15918:			
15919:			
15920:			;****** END -FAX, FLOG, FALOG, FCDR, FCRD, FTAN *****
15921:			
15922:			
15923:	FFFF          		IF	NOT CAMAC
15924:			;8080 FLOATING POINT ARCTANGENT - FATAN
15925:			;   THIS ROUTINE CALCULATES THE ARCTANGENT OF THE
15926:			;NUMBER IN THE FLOATING POINT ACCUMULATOR.
15927:			;
15928:			;	ATAN(FAC) -> FAC
15929:			;
15930:			;METHOD
15931:			;	 POLYNOMIAL APPROXIMATION
15932:			;
15933:			;   THIS ROUTINE IS BUILT AROUND A POLYNOMIAL, F(X),
15934:			;THAT APPROXIMATES ATAN(Z) IN THE RANGE
15935:			;-.25 <= Z <= .25.  THE ATAN(Z) FOR VALUES OF Z
15936:			;OUTSIDE THIS RANGE IS FOUND BY USING THE FOLLOWING
15937:			;IDENTITIES:
15938:			;	      ATAN(-Z) = -ATAN(Z)
15939:			;AND
15940:			;	ATAN(Z) = A(K) + ATAN((Z-B(K))/(Z*B(K)+1))
15941:			;WHERE
15942:			;	A(K) = K*PI/7, B(K) = TAN(A(K))
15943:			;AND K IS DETERMINED SO THAT
15944:			;TAN((2*K-1)*PI/14) <= ABS(Z) <= TAN((2*K+1)*PI/14)
15945:			;WITH K = 1, 2, OR 3.
15946:			;
15947:			;  HAVING DETERMINED THE VALUE OF K APPROPRIATE
15948:			;TO Z, THE TRANSFORMATION
15949:			;	X = (Z-B(K))/(Z*B(K)+1)
15950:			;PUTS X IN THE RANGE -TAN(PI/14) < X < TAN(PI/14).
15951:			;THE POLYNOMIAL WORKS OVER A SLIGHTLY LARGER RANGE
15952:			;TO ALLOW DETERMINATION OF K USING THE VALUES
15953:			;	K=0  IF ABS(Z) < .25
15954:			;	K=1  IF .25 < ABS(Z) < .75
15955:			;	K=2  IF .75 < ABS(Z) < 2
15956:			;	K=3  IF ABS(Z) > 2
15957:			;THEN
15958:			;	ATAN(Z) = A(K) + F(X)   IF Z >= 0
15959:			;	ATAN(Z) = -A(K) - F(X)  IF Z < 0
15960:			;F(X) = X*(1 - Q1*X^2 + Q2*X^4 - Q3*X^6)
15961:			;WHERE
15962:			;	Q1 = .333329573
15963:			;	Q2 = .199641035
15964:			;	Q3 = .131779888
15965:			
15966:	3BA6  CDC90E  	FATAN:	CALL	FTEST	;RESTORE
15967:	3BA9  C8      		RET	Z
15968:	3BAA  5F      		LD	E,A		;SAVE EXPONENT
15969:	3BAB  78      		LD	A,B		;GET M0
15970:	3BAC  E680    		AND	80H		;ISOLATE SIGN, B23
15971:	3BAE  32B33D  		LD	(FATSG),A	;AND SAVE
15972:	3BB1  CDC10E  		CALL	FABS
15973:	3BB4  5F      		LD	E,A		;SAVE EXP
15974:	3BB5  21B43D  		LD	HL,FATK
15975:	3BB8  3600    		LD	(HL),0		;K=0
15976:	3BBA  FE7F    		CP	127
15977:	3BBC  CAD33B  		JP	Z,FAT4		;.25 <= Z < .5, SO K=1
15978:	3BBF  DA133C  		JP	C,FAT7		;Z < .25, SO K=0 AND DO F(X), X=Z
15979:	3BC2  3602    		LD	(HL),2
15980:	3BC4  FE81    		CP	129
15981:	3BC6  CAD43B  		JP	Z,FAT6		;.75 <= Z < 1, K=2
15982:	3BC9  D2D33B  		JP	NC,FAT4		;Z > 2, K=3
15983:	3BCC  78      		LD	A,B
15984:	3BCD  07      		RLCA
15985:	3BCE  07      		RLCA			;CHECK 1/4 BIT
15986:	3BCF  35      		DEC	(HL)
15987:	3BD0  D2D43B  		JP	NC,FAT6		;.5 <= Z <.75, K=1
15988:	3BD3  34      	FAT4:	INC	(HL)
15989:	3BD4  7E      	FAT6:	LD	A,(HL)		;FETCH K
15990:	3BD5  F5      		PUSH	AF		;SAVE K
15991:	3BD6  7B      		LD	A,E		;GET EXPONENT
15992:	3BD7  21A73D  		LD	HL,FATZX	;SAVE
15993:	3BDA  CDB00E  		CALL	FSTOR		;Z
15994:	3BDD  F1      		POP	AF		;GET K
15995:	3BDE  3D      		DEC	A		;K-1
15996:	3BDF  87      		ADD	A,A		;(K-1)*2
15997:	3BE0  87      		ADD	A,A		;(K-1)*4
15998:	3BE1  87      		ADD	A,A		;(K-1)*8
15999:	3BE2  21513C  		LD	HL,FATC1	;START OF TABLE
16000:	3BE5  5F      		LD	E,A		;CALCULATE
16001:	3BE6  1600    		LD	D,0		;ADDRESS
16002:	3BE8  19      		ADD	HL,DE		; OF A(K)
16003:	3BE9  E5      		PUSH	HL		;AND SAVE IT
16004:	3BEA  110400  		LD	DE,4
16005:	3BED  19      		ADD	HL,DE		;ADDRESS OF B(K)
16006:	3BEE  E5      		PUSH	HL		;SAVED ALSO
16007:	3BEF  CDDD0E  		CALL	FLOAD		;GET B(K)
16008:	3BF2  21A73D  		LD	HL,FATZX
16009:	3BF5  E5      		PUSH	HL
16010:	3BF6  CDFA0E  		CALL	FMUL		;Z*B(K)
16011:	3BF9  21A20C  		LD	HL,FPONE
16012:	3BFC  CD470F  		CALL	FADD		;Z*B(K)+1
16013:	3BFF  21AB3D  		LD	HL,FATXM
16014:	3C02  CDB00E  		CALL	FSTOR		;SAVE Z*B(K)+1
16015:	3C05  E1      		POP	HL
16016:	3C06  CDDD0E  		CALL	FLOAD		;GET Z
16017:	3C09  E1      		POP	HL		;ADDRESS OF B(K)
16018:	3C0A  CD440F  		CALL	FSUB		;Z-B(K)
16019:	3C0D  21AB3D  		LD	HL,FATXM
16020:	3C10  CD250F  		CALL	FDIV		;(Z-B(K))/(Z*B(K)+1)
16021:	3C13  21A73D  	FAT7:	LD	HL,FATZX
16022:	3C16  E5      		PUSH	HL
16023:	3C17  CDB00E  		CALL	FSTOR		;SAVE X
16024:	3C1A  E1      		POP	HL
16025:	3C1B  CDFA0E  		CALL	FMUL		;X^2
16026:	3C1E  21AB3D  		LD	HL,FATXM
16027:	3C21  E5      		PUSH	HL		;SAVE FOR FPOLY
16028:	3C22  CDB00E  		CALL	FSTOR		;SAVE INITIAL POWER
16029:	3C25  21AF3D  		LD	HL,FATX2	;SAVE TERM POWER MULTIPLIER
16030:	3C28  CDB00E  		CALL	FSTOR
16031:	3C2B  21A20C  		LD	HL,FPONE
16032:	3C2E  CDDD0E  		CALL	FLOAD		;INITIALISE SUM
16033:	3C31  21693C  		LD	HL,FATPL
16034:	3C34  CD6A37  		CALL	FPOLY		;F(X)
16035:	3C37  21A73D  		LD	HL,FATZX
16036:	3C3A  CDFA0E  		CALL	FMUL		;X*F(X)
16037:	3C3D  5F      		LD	E,A		;SAVE EXPONENT
16038:	3C3E  3AB43D  		LD	A,(FATK)	;GET K
16039:	3C41  A7      		AND	A		;SEE IF 0
16040:	3C42  7B      		LD	A,E		;RESTORE EXPONENT
16041:	3C43  CA4A3C  		JP	Z,FAT8		;K=0, NO A(K)
16042:	3C46  E1      		POP	HL		;ADDRESS OF A(K)
16043:	3C47  CD470F  		CALL	FADD		;A(K)+F(X)
16044:	3C4A  5F      	FAT8:	LD	E,A		;SAVE EXP
16045:	3C4B  3AB33D  		LD	A,(FATSG)	;GET INPUT SIGN
16046:	3C4E  C3103B  		JP	FSC8		;EXIT AS FOR SIN AND COS
16047:			
16048:	3C51  7F65C8FA	FATC1:	DEFW	657FH,0FAC8H;A(1) PI/7 .4487989506
16049:	3C55  7F7690F3		DEFW	767FH,0F390H	;B(1) TAN(A(1)) .4815746188
16050:	3C59  8065C8FA		DEFW	6580H,0FAC8H	;A(2) 2*PI/7 .8975979011
16051:	3C5D  812081C6		DEFW	2081H,0C681H	;B(2) TAN(A(2)) 1.253960337
16052:	3C61  812C56BB		DEFW	2C81H,0BB56H	;A(3) 3*PI/7 1.346396852
16053:	3C65  830C337F		DEFW	0C83H,7F33H	;B(3) TAN(A(3)) 4.381286272
16054:			
16055:	3C69  FF      	FATPL:	DEFB	-1	;ATAN POLY TABLE
16056:	3C6A  7FAAAA2D		DEFW	0AA7FH,2DAAH	;Q1  -.333329573
16057:	3C6E  7E4C6EB3		DEFW	4C7EH,0B36EH	;Q2  .199641035
16058:	3C72  7E86F14F		DEFW	867EH,4FF1H	;Q3  -.131779888
16059:	3C76  00      		DEFB	0		;TERMINATOR
16060:			
16061:			
16062:			;****** END - FATAN ******
16063:				ENDIF			;end of NOT CAMAC contditional
16064:			
16065:			
16066:	0000          		IF	FALSE
16158:				ENDIF
16159:			
16160:			
16161:				ENDIF			;end of FLOAT conditional
16162:			
16163:			;****** END - XMATH PACKAGE ******
16164:			
16165:			;end of XMATH
16167:			;RAM 05/20/81
16168:			;XYBASIC Interpreter Source Module
16169:			;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
16170:			;RAM storage for non-ROM versions
16171:			
16172:	FFFF          		IF	NOT ROM
16173:			; $-MACRO:;suppress DZ macro expansion on printouts
16174:			
16175:	3C77          	PATCH:	DZ	30	;patch area
16176:			
16177:	0000          		IF	ASM80
16179:				ENDIF
16180:			
16181:	3C95          	RAMORG:	;first RAM storage location
16182:			
16183:			;first the version-dependent RAM locations
16184:			
16185:	0000          		IF	NONST AND NOT CAMAC
16191:				ENDIF
16192:			
16193:	FFFF          		IF	CPM		;impure code section for console & LST i/o
16194:	3C95  C30000  	CSTAT:	JP	0		;console status
16195:	3C98  C30000  	CONIN:	JP	0		;console in
16196:	3C9B  C30000  	CNOUT:	JP	0		;console out
16197:	3C9E  C30000  	LOUT:	JP	0		;list out
16198:	0000          		IF	AMD
16202:				ENDIF
16203:	3CA1          	SPTR:	DZ	2		;dump buffer pointer
16204:	FFFF          		IF	SDISK
16205:	0000          		IF	BENDX
16208:				ELSE			;CP/M SDISK
16209:	3CA3  03      	FILES:	DEFB	3
16210:	3CA4          	FILEP:	DZ	2
16211:	3CA6          	FILET:	DZ	2
16212:				ENDIF
16213:				ENDIF
16214:	0000          		IF	DEBUG
16216:				ENDIF
16217:				ENDIF			;end of CPM conditional
16218:			
16219:	0000          		IF	ISIS2
16246:				ENDIF			;end of ISIS2 conditional
16247:			
16248:			;RAM locations which must have nonzero values in ROM version
16249:	FFFF          		IF	NOT COMPL
16250:	3CA8  C3D03F  	DMODC:	JP	INIT		;^C branch point, changed to JMP DMOD0
16251:				ENDIF
16252:	3CAB  DB00    	RPORT:	IN	A,(0)		;impure code for port reading
16253:	3CAD  C9      		RET
16254:	3CAE  D300    	WPORT:	OUT	(0),A		;impure code for port writing
16255:	3CB0  C9      		RET
16256:	0000          		IF	ROMSQ
16258:				ENDIF
16259:	FFFF          		IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)
16260:			;IMPURE MULTIPLY SUBROUTINE
16261:	3CB1  C600    	MULX4:	ADD	A,0		;ADD OPERAND 3RD FRACTION
16262:	3CB3  5F      		LD	E,A		;4TH PARTIAL PRODUCT
16263:	3CB4  7A      		LD	A,D		;3RD PARTIAL PRODUCT
16264:	3CB5  CE00    		ADC	A,0		;ADD OPERAND 2ND FRACTION
16265:	3CB7  57      		LD	D,A		;3RD PARTIAL PRODUCT
16266:	3CB8  79      		LD	A,C		;2ND PARTIAL PRODUCT
16267:	3CB9  CE00    		ADC	A,0		;ADD OPERAND 1ST FRACTION
16268:	3CBB  C9      		RET			;TO ROM CODE
16269:			;IMPURE DIVIDE SUBROUTINE
16270:	3CBC  D600    	DIVX5:	SUB	0		;SUBTRACT DIVISOR 4TH FRACTION
16271:	3CBE  7D      		LD	A,L		;REMAINDER 3RD FRACTION
16272:	3CBF  DE00    		SBC	A,0		;SUBTRACT DIVISOR 3RD FRACTION
16273:	3CC1  6F      		LD	L,A		;REMAINDER 3RD FRACTION
16274:	3CC2  7C      		LD	A,H		;REMAINDER 2ND FRACTION
16275:	3CC3  DE00    		SBC	A,0		;SUBTRACT DIVISOR 2ND FRACTION
16276:	3CC5  67      		LD	H,A		;REMAINDER 2ND FRACTION
16277:	3CC6  7B      		LD	A,E		;REMAINDER 1ST FRACTION
16278:	3CC7  DE00    		SBC	A,0		;SUBTRACT DIVISOR 1ST FRACTION
16279:	3CC9  5F      		LD	E,A		;REMAINDER 1ST FRACTION
16280:	3CCA  3E00    		LD	A,0		;REMAINDER 4TH FRACTION
16281:	3CCC  C9      		RET			;TO ROM CODE
16282:	3CCD  C600    	DIVX6:	ADD	A,0		;ADD DIVISOR 3RD FRACTION
16283:	3CCF  6F      		LD	L,A		;REMAINDER 3RD FRACTION
16284:	3CD0  7C      		LD	A,H		;REMAINDER 2ND FRACTION
16285:	3CD1  CE00    		ADC	A,0		;ADD DIVISOR 2ND FRACTION
16286:	3CD3  67      		LD	H,A		;REMAINDER 2ND FRACTION
16287:	3CD4  7B      		LD	A,E		;REMAINDER 1ST FRACTION
16288:	3CD5  CE00    		ADC	A,0		;ADD DIVISOR 1ST FRACTION
16289:	3CD7  5F      		LD	E,A		;REMAINDER 1ST FRACTION
16290:	3CD8  3E00    		LD	A,0		;REMAINDER 4TH FRACTION
16291:	3CDA  C9      		RET			;TO ROM CODE
16292:				ENDIF
16293:			
16294:	0000          		IF	CAMAC		;impure routines for CAMAC command execution
16324:				ELSE			;NOT CAMAC
16325:	0000          		IF	REALT		;SBC 80/20 version uses real time clock
16327:				ELSE			;valiues for software real time clock
16328:	3CDB  138C    	TIMEX:	DEFW	TIMEM		;TIME count for minutes, complemented
16329:	3CDD  12FE    		DEFW	TIMEN		;TIME count for seconds, complemented
16330:	3CDF  73      		DEFB	TIMEH		;TIME count for hundredths
16331:				ENDIF
16332:				ENDIF
16333:			
16334:	3CE0          	COLUM:	DZ	1	;current column position on printline
16335:	3CE1  FF      	WIDTH:	DEFB	255		;terminal width -- NB must follow COLUM
16336:			
16337:			;locations which must be zeroed in ROM version
16338:	3CE2          	LNNUM:	DZ	2		;line number (address) of current line
16339:	FFFF          		IF	NOT COMPL
16340:	FFFF          		IF	EDITC
16341:	3CE4          	ERRLN:	DZ	2		;line number (address) of most recent error
16342:				ENDIF
16343:	3CE6          	TRAP:	DZ	1		;trap mode -- 0 trapon, m1 trapoff
16344:	3CE7          	TRACE:	DZ	1		;trace mode -- 0 traceoff, m1 traceon
16345:	3CE8          	INLHS:	DZ	1		;m1 if getting LHS -- NB must follow TRACE
16346:	3CE9          	VTRAC:	DZ	1		;minus iff tracing -- NB must follow INLHS
16347:				ENDIF
16348:	0000          		IF	CAMAC
16366:				ENDIF
16367:	FFFF          		IF	NOT WILD
16368:	3CEA          	LMODE:	DZ	1		;LST mode
16369:				ENDIF
16370:	0000          		IF	PACKI
16372:				ENDIF
16373:	3CEB          	OMODE:	DZ	1		;output suppress mode
16374:	FFFF          		IF	NOT WILD
16375:	3CEC          	INTTC:	DZ	1		;number of entries currently in interrupt table
16376:	3CED          	INTAD:	DZ	INTTL		;interrupt table
16377:	3D2E          	RANDX:	DZ	2		;pseudorandom number generator seed
16378:	3D30          	NULLS:	DZ	1		;number of nulls printed after crlf
16379:				ENDIF			;end of NOT WILD conditional
16380:	3D31          	GCHAR:	DZ	1		;last console char read for GET
16381:	FFFF          		IF	STRNG		;string ram
16382:	3D32          	STEMP:	DZ	1		;number of string temporaries in use
16383:			
16384:			;locations which may come up randomly in ROM version
16385:	3D33          		DZ	2*STMAX		;string temporaries, 2 bytes each
16386:	3D3B          	STRT:	DZ	2		;top of string space address
16387:	3D3D          	STRPT:	DZ	2
16388:	3D3F          	STRP2:	DZ	2		;string space pointers
16389:	3D41          	GCMIN:	DZ	2
16390:	3D43          	GCLST:	DZ	2
16391:	3D45          	GCLOC:	DZ	2		;garbage collection temp storage
16392:				ENDIF			;end of string ram
16393:	FFFF          		IF	EDITC AND (NOT COMPL)
16394:	FFFF          		IF	STRNG
16395:	3D41          	RNNEW	EQU	GCMIN
16396:	3D43          	RNINC	EQU	GCLST
16397:	3D45          	RNOLD	EQU	GCLOC		;RENUM and garbage collection share temps
16398:				ELSE
16402:				ENDIF
16403:				ENDIF
16404:	0000          		IF	CAMAC AND NONST AND (NOT RTPAK);Northstar DOS RAM
16412:				ENDIF
16413:	0000          		IF	PACKI
16425:				ENDIF
16426:	FFFF          		IF	FLOAT
16427:	3D47          	ARGAD:	DZ	2		;address of arg for amb op retry
16428:	0000          		IF	F9511
16430:				ELSE			;NOT F9511
16431:	0000          		IF	FPBCD		;BCD floating point RAM
16451:				ELSE
16452:			;RAM LOCATIONS USED BY THE BINARY FLOATING POINT SYSTEM
16453:	3D49          	PREX:	DZ	1		;PREVIOUS EXPONENT
16454:	3D4A          	ACCE:	DZ	1		;ACC EXPONENT
16455:	3D4B          	ACCS:	DZ	1		;ACC SIGN
16456:	3D4C          	ACC1:	DZ	1		;ACC 1ST FRACTION
16457:	3D4D          	ACC2:	DZ	1		;ACC 2ND FRACTION
16458:	3D4E          	ACC3:	DZ	1		;ACC 3RD FRACTION
16459:	3D4F          	SFLAG:	DZ	1		;SUBTRACTION FLAG
16460:	3D50          	ADRL:	DZ	2		;ADDR OF CHARACTER STRING WORD ADDRESS
16461:	3D52          	TMP1:	DZ	1		;TEMPORARY STORAGE
16462:	3D53          	TMP2:	DZ	1		;    "        "
16463:	3D54          	TMP3:	DZ	1		;    "        "
16464:	3D55          	VALE:	DZ	4		;VALUE EXPONENT
16465:	3D59          	TMP4:	DZ	1		;TEMPORARY STORAGE
16466:			;and then the XMATH RAM
16467:	3D5A          	SIG:	DZ	1		;SIG INDEX FROM CALLER
16468:	3D5B          	FPTXN:	DZ	8		;RUNNING POWER AND POWER MULTIPLIER
16469:	3D63          	FPSUM:	DZ	4		;RUNNING TERM SUM
16470:	3D67          	VECT:	DZ	2		;ADDRESS OF CURRENT TERM
16471:	3D69          	FINSN:	DZ	1		;B7 = INPUT SIGN B6-B0 = 0
16472:	3D6A          	FINFP:	DZ	4		;FRACTIONAL PART
16473:	3D6E          	FPTXX:	DZ	4
16474:	3D72          	FPTF:	DZ	4
16475:	3D76          	FPTP:	DZ	4
16476:	3D7A          	FPTX:	DZ	4		;TEMP STORAGE
16477:	3D7E          	FPTN:	DZ	1		;N
16478:	3D7F          	FPSGN:	DZ	1		;INPUT SIGN
16479:	3D80          	FPTZ0:	DZ	4		;INITIAL POWER OF Z
16480:	3D84          	FPTZ1:	DZ	4		;TERM POWER MULTIPLIER (Z1=Z)
16481:	3D88          	FLNZI:	DZ	4		;INITIAL POWER
16482:	3D8C          	FLNZ2:	DZ	4		;POWER TERM MULTIPLIER
16483:	3D90          	FLNK:	DZ	1		;K,J
16484:	3D91          	FLNF:	DZ	4		;F,G,X,G(Z) -- NB must follow FLNK
16485:	3D95          	FSCFX:	DZ	1		;0AFH FOR SIN, 0 FOR COS
16486:	3D96          	FSCSG:	DZ	1		;0 IF INPUT +, 80H IF -
16487:	3D97          	FSCZ:	DZ	4		;Z
16488:	3D9B          	FSCZ2:	DZ	4		;Z^2
16489:	3D9F          	FTMPA:	DZ	4		;TEMP STORAGE
16490:	3DA3          	FTMPB:	DZ	4		; ----"-----
16491:	FFFF          		IF	NOT CAMAC	;no ATN in CAMAC versions
16492:	3DA7          	FATZX:	DZ	4		;Z,X
16493:	3DAB          	FATXM:	DZ	4		;INITIAL POWER OF X
16494:	3DAF          	FATX2:	DZ	4		;TERM POWER MULIPLIER
16495:	3DB3          	FATSG:	DZ	1		;INPUT SIGN
16496:	3DB4          	FATK:	DZ	1		;K
16497:				ENDIF			;end of NOT CAMAC conditional
16498:				ENDIF			;end of NOT FPBCD conditional
16499:				ENDIF			;end of NOT F9511 conditional
16500:				ENDIF			;end of FLOAT conditional
16501:			
16502:			;stack space
16503:	0000          		IF	ASM80
16505:				ELSE
16506:	3DB5          		DZ	STAKL
16507:			STACK:	DEFS	0
16508:				ENDIF
16509:			
16510:	3E35          	VARTY:	DZ	1	;type of last var name scanned
16511:	FFFF          		IF	STRNG OR FLOAT	;default variable type buffer
16512:	3E36          	TYBUF:	DZ	26
16513:				ENDIF
16514:	3E50          	TEMP:	DZ	2		;all-purpose temp storage
16515:	3E52          	TXTP2:	DZ	2		;secondary textp for READ, INPUT
16516:	3E54          	SAVTP:	DZ	2		;textp save
16517:	3E56          	LHSTY:	DZ	1		;lhs variable type
16518:	3E57          	LHSAD:	DZ	2		;lhs variable address
16519:	3E59          	CSTKP:	DZ	2		;control stack pointer
16520:	3E5B          	ESTKP:	DZ	2		;expression stack pointer
16521:	3E5D          	SYMTA:	DZ	2		;starting address of symbol table
16522:	3E5F          	BUFAD:	DZ	MAXNL+MAXNL	;buffer for number-string conversion, var names
16523:	3E6F  3A      		DEFB	':'		;colon precedes tokenized input buffer
16524:	3E70          	TLNAD:
16525:	FFFF          		IF	EDITC		;tokenization buffer seperate in EDITC version
16526:	3E70  0D      		DEFB	CR
16527:	3E71          		DZ	NLMAX+2		;NLMAX chars + space + cr  + eof
16528:				ENDIF
16529:	3EC3  0D      	NLNAD:	DEFB	CR		;first byte of input buffer
16530:	FFFF          		IF	(SDISK OR (CAMAC AND NONST)) AND (NOT RTPAK)
16531:	3EC4          		DZ	255		;input buffer is used by LINPUT too
16532:				ELSE
16534:				ENDIF
16535:	FFFF          		IF	NOT COMPL
16536:	3FC3          	LNLEN:	DZ	1		;length of current input line
16537:	3FC4          	CSTKD:	DZ	1		;control stack direct count
16538:	3FC5          	TRACL:	DZ	1		;line traced -- 0 no, m1 yes
16539:				ENDIF
16540:	3FC6          	TEXTP:	DZ	2		;current text line pointer
16541:	3FC8          	RDPTR:	DZ	2		;READ text pointer
16542:	3FCA          	EOFAD:	DZ	2		;ending address of user source text
16543:	3FCC          	MEMT:	DZ	2		;top of memory address
16544:	3FCE  0D      		DEFB	CR		;cr precedes source text
16545:	3FCF          	SRCAD:	DZ	1		;source text
16546:			
16547:			; $*MACRO:;resume macro expansion hex printing
16548:				ENDIF			;end of NOT ROM conditional
16549:			
16550:			;end of RAM
16552:			;ROM 12/12/80
16553:			;XYBASIC Interpreter Source Module
16554:			;Copyright (C) 1978, 1979, 1980 by Mark Williams Company, Chicago
16555:			;RAM EQUates for ROM version
16556:			
16557:	0000          		IF	ROM
16976:				ENDIF			;end of ROM conditional
16977:			
16978:			;end of ROM
16980:			;INITIAL 05/20/81
16981:			;XYBASIC Interpreter Source Module
16982:			;Copyright (C) 1978, 1979, 1980, 1981 by Mark Williams Company, Chicago
16983:			;initialization dialog
16984:			
16985:			
16986:	0000          		IF	ASM80
16988:				ENDIF
16989:			
16990:			;XYBASIC performs a JMP INIT from ROMORG on initial entry.
16991:			;The user program source and working space overlay the code
16992:			;in this module after initialization in RAM versions.
16993:			
16994:	3FD0  31353E  	INIT:	LD	SP,STACK	;initialize SP
16995:			
16996:			;save A on entry in Wild version
16997:	0000          		IF	WILD
16999:				ENDIF
17000:			
17001:			;set up RAM locations if ROM version
17002:	0000          		IF	ROM
17019:				ENDIF			;end of ROM conditional
17020:			
17021:			;initialize runtime package pointers
17022:	0000          		IF	RTPAK		;initialize souce text pointers
17027:				ENDIF			;end of RTPAK conditional
17028:			
17029:			;set up i/o jmp vector if CP/M version
17030:	FFFF          		IF	CPM
17031:	3FD3  2A0100  		LD	HL,(CPMBA+1)	;3E03H + base
17032:	3FD6  110300  		LD	DE,3
17033:	3FD9  19      		ADD	HL,DE		;3E06H + base
17034:	3FDA  22963C  		LD	(CSTAT+1),HL	;store to allow console status not via BDOS
17035:	3FDD  19      		ADD	HL,DE		;3E09H + base
17036:	3FDE  22993C  		LD	(CONIN+1),HL	;store to allow console reading without echo
17037:	3FE1  19      		ADD	HL,DE		;3E0CH + base
17038:	3FE2  229C3C  		LD	(CNOUT+1),HL	;store to allow console writing
17039:	3FE5  19      		ADD	HL,DE		;3E0FH + base
17040:	3FE6  229F3C  		LD	(LOUT+1),HL	;store to allow list device writing
17041:	0000          		IF	AMD		;also define PUN and RDR in AMD version
17046:				ENDIF			;end of AMD conditional
17047:				ENDIF			;end of CPM conditional
17048:			
17049:			;initialize the real time clock for REALT version
17050:	0000          		IF	REALT
17056:				ENDIF
17057:			
17058:			;initialize the real time clock for CAMAC version
17059:	0000          		IF	CAMAC
17095:				ENDIF
17096:			
17097:			;Packard Instruments version initialization
17098:	0000          		IF	PACKI AND NOT DEBUG
17106:				ENDIF
17107:			
17108:			;print initial message
17109:	FFFF          		IF	NOT (WILD AND RTPAK)
17110:	3FE9  CDD917  		CALL	PRNTM
17111:	0000          		IF	EPSTN
17113:				ENDIF
17114:	3FEC  0D0A    		DEFB	CR, LF
17115:	0000          		IF	COMPL
17121:				ENDIF
17122:	0000          		IF	(NOT STRNG) AND (NOT FLOAT)
17124:				ENDIF
17125:	0000          		IF	AMD
17127:				ENDIF
17128:	0000          		IF	BENDX
17130:				ENDIF
17131:	0000          		IF	PACKI
17133:				ENDIF
17134:	0000          		IF	WILD
17136:				ENDIF
17137:	3FEE  58594241		DEFB	'XYBASIC '
	      53494320
17138:	0000          		IF	EPSTN
17140:				ENDIF
17141:	FFFF          		IF	CPM AND (NOT CAMAC)
17142:	3FF6  43502F4D		DEFB	'CP/M '
	      20
17143:				ENDIF
17144:	0000          		IF	ISIS2
17146:				ENDIF
17147:	FFFF          		IF	SDISK AND (NOT CAMAC)
17148:	3FFB  4449534B		DEFB	'DISK '
	      20
17149:				ENDIF
17150:	FFFF          		IF	EDITC
17151:	4000  45444954		DEFB	'EDIT '
	      20
17152:				ENDIF
17153:	4005  52455620		DEFB	'REV ', VERSN/10000+'0', '.'
	      322E
17154:	0001          		IF	((VERSN/1000) MOD 10) NE 0
17155:	400B  31      		DEFB	(VERSN/1000) MOD 10 + '0'
17156:				ENDIF
17157:	400C  34      		DEFB	(VERSN/100) MOD 10 +'0'
17158:	0000          		IF	(VERSN MOD 100) NE 0
17164:				ENDIF
17165:	0000          		IF	DEBUG
17167:				ENDIF
17168:	400D  0D8A    		DEFB	CR, LF OR 80H
17169:			
17170:			;print copyright message unless CAMAC version
17171:	FFFF          		IF	NOT CAMAC
17172:	400F  216533  		LD	HL,MWCMA
17173:	4012  CDC217  		CALL	PRTST		;print copyright message
17174:				ENDIF
17175:				ENDIF			;end of NOT (WILD AND RTPAK) conditional
17176:			
17177:			;if compiler, find top of memory and execute program directly
17178:	0000          		IF	COMPL AND NOT RTPAK
17192:				ELSE			;(not COMPL) or RTPAK
17193:			
17194:			;check default width if ROMSQ or CP/M version
17195:	0000          		IF	ROMSQ AND NOT WILD
17199:				ENDIF
17200:	FFFF          		IF	CPM AND NOT COMPL
17201:	4015  3A5D00  		LD	A,(FCBAD+1)
17202:	4018  FE20    		CP	' '		;check if filename specified on command line
17203:	401A  3E48    		LD	A,72
17204:	401C  C23A40  		JP	NZ,INIT2	;yes, default width to 72
17205:				ENDIF
17206:			
17207:			;prompt for width
17208:	0000          		IF	WILD AND RTPAK
17211:				ELSE
17212:	401F  110100  	INIT1:	LD	DE,1		;terminal width min  = 1
17213:	4022  CDC940  		CALL	INITP		;print message, get width
17214:	4025  57494454		DEFB	'WIDTH?', ' ' OR 80H
	      483FA0
17215:	402C  DA1F40  		JP	C,INIT1		;illegal value
17216:	402F  3E50    		LD	A,NLMAX		;default width to A
17217:	4031  CA3A40  		JP	Z,INIT2		;take default value
17218:	4034  7C      		LD	A,H
17219:	4035  B7      		OR	A
17220:	4036  C21F40  		JP	NZ,INIT1	;too big -- try again
17221:	4039  7D      		LD	A,L
17222:	403A  32E13C  	INIT2:	LD	(WIDTH),A
17223:				ENDIF			;end of NOT (WILD AND RTPAK) conditional
17224:			
17225:	403D          	INIT3:
17226:	0000          		IF	ROM	;min memtop value to DE
17228:				ELSE
17229:	403D  114043  		LD	DE,EORAM+DBYTS
17230:				ENDIF
17231:			
17232:			;check default memtop value if ROMSQ or CP/M version
17233:	0000          		IF	ROMSQ AND NOT WILD
17240:				ENDIF
17241:	FFFF          		IF	CPM AND NOT COMPL
17242:	4040  3A5D00  		LD	A,(FCBAD+1)
17243:	4043  FE20    		CP	' '
17244:	4045  C26940  		JP	NZ,INIT5	;take max
17245:				ENDIF
17246:			
17247:			;prompt for end of memory
17248:	0000          		IF	WILD AND RTPAK
17252:				ELSE
17253:	4048  CDC940  		CALL	INITP		;print message, get mem top
17254:	404B  454E4420		DEFB	'END OF MEMORY?', ' ' OR 80H
	      4F46204D
	      454D4F52
	      593FA0
17255:	405A  DA3D40  		JP	C,INIT3		;bad value, retry
17256:	405D  CA6940  		JP	Z,INIT5		;take default value
17257:	4060  CD2A01  	INIT4:	CALL	RTEST		;test if specified location is RAM
17258:	4063  C23D40  		JP	NZ,INIT3	;not RAM, retry
17259:	4066  C36C40  		JP	INIT6		;else take specified location
17260:				ENDIF			;end of NOT (WILD AND RTPAK) conditional
17261:	4069  CDE640  	INIT5:	CALL	EOMEM		;find default end of memory
17262:			
17263:			;initialize RAM pointers
17264:	406C  AF      	INIT6:	XOR	A
17265:	FFFF          		IF	SDISK AND CPM AND (NOT RTPAK)
17266:	406D  22A63C  		LD	(FILET),HL	;store end of file space
17267:	4070  77      		LD	(HL),A		;initialize first default file area
17268:	4071  115AFF  		LD	DE,-FILEN
17269:	4074  19      		ADD	HL,DE
17270:	4075  77      		LD	(HL),A		;initialize second default file area
17271:	4076  19      		ADD	HL,DE
17272:				ENDIF
17273:	FFFF          		IF	STRNG
17274:	4077  223B3D  		LD	(STRT),HL	;store top of string space
17275:	407A  25      		DEC	H		;leave 100H bytes of string space
17276:				ENDIF
17277:	407B  77      		LD	(HL),A		;initialize symbol table
17278:	407C  22CC3F  		LD	(MEMT),HL
17279:	0000          		IF	RTPAK
17281:				ELSE			;NOT RTPAK
17282:	407F  CD6D27  		CALL	NEW		;initialize source, interrupt
17283:	0000          		IF	BENDX AND NOT DEBUG
17286:				ENDIF
17287:	4082  21772B  		LD	HL,STOP
17288:	4085  22A93C  		LD	(DMODC+1),HL	;change ^C branch from JMP INIT to JMP STOP
17289:				ENDIF
17290:	FFFF          		IF	NOT ROM
17291:	4088  213D07  		LD	HL,DMOD2
17292:	408B  220101  		LD	(START+1),HL	;change JMP INIT to JMP DMOD2 to allow reentry
17293:				ENDIF
17294:			
17295:			;load program if specified on CP/M command line
17296:	FFFF          		IF	CPM AND NOT COMPL
17297:	408E  3A5D00  		LD	A,(FCBAD+1)
17298:	4091  FE20    		CP	' '		;check if filename specified on command line
17299:	4093  CAB040  		JP	Z,INIT7		;no
17300:	4096  216500  		LD	HL,FCBFT
17301:	4099  3658    		LD	(HL),'X'
17302:	409B  23      		INC	HL
17303:	409C  3659    		LD	(HL),'Y'
17304:	409E  23      		INC	HL
17305:	409F  3642    		LD	(HL),'B'	;reset filetype to .XYB
17306:	40A1  CDDA05  		CALL	LOADZ		;reset LNNUM and TEXTP in case not found
17307:	40A4  CD9F05  		CALL	CDKOP		;open the file
17308:	40A7  217107  		LD	HL,NEXTS
17309:	40AA  E5      		PUSH	HL		;push normal statement return for RUN
17310:	40AB  0601    		LD	B,1		;set B for ,R to RUN after loading
17311:	40AD  C35D05  		JP	LOD0B		;and load it
17312:				ENDIF
17313:			
17314:			;print BYTES FREE message
17315:	FFFF          		IF	NOT (WILD AND RTPAK)
17316:	40B0  CDAD15  	INIT7:	CALL	FRE		;free memory bytes to BC
17317:	40B3  CD0D17  		CALL	WRTBU		;write (BC) unsigned
17318:	40B6  CDD917  		CALL	PRNTM		;print BYTES FREE message
17319:	40B9  20425954		DEFB	' BYTES FREE', CR, LF OR 80H
	      45532046
	      5245450D
	      8A
17320:				ENDIF			;end of NOT (WILD AND RTPAK) conditional
17321:			
17322:			;Wild version default program execution
17323:	0000          		IF	WILD
17336:				ELSE			;NOT WILD
17337:			
17338:			;begin at direct mode or execute specified program
17339:	0000          		IF	ROMSQ
17361:				ELSE			;not ROMSQ
17362:	40C6  C34007  		JP	DMODE
17363:				ENDIF
17364:				ENDIF			;end of NOT WILD conditional
17365:			
17366:	FFFF          		IF	NOT (WILD AND RTPAK)
17367:			;INITP prompts the user and gets a value for WIDTH or END OF MEMORY.
17368:			;Call:	DE			min value -1
17369:			;	Location after CALL	message to print
17370:			;Retn:	Carry			set iff value bad
17371:			;	Zero, no Carry		if <cr> typed
17372:			;	no Zero, no Carry	value ok,  returned in HL
17373:	40C9  E1      	INITP:	POP	HL		;message address to HL
17374:	40CA  CDC217  		CALL	PRTST		;print message
17375:	40CD  E5      		PUSH	HL		;save return addr
17376:	40CE  D5      		PUSH	DE		;save min value -1
17377:	40CF  CDB433  		CALL	GTLIN		;get a line from console
17378:	40D2  CD1119  		CALL	GTDEC		;and get decimal value to DE
17379:	40D5  EB      		EX	DE,HL		;value typed to HL
17380:	40D6  D1      		POP	DE		;min -1 to DE
17381:	40D7  DAE140  		JP	C,INIP1		;no digit -- check for <cr>
17382:	40DA  37      		SCF
17383:	40DB  C8      		RET	Z		;too big, return Carry
17384:	40DC  CD2902  		CALL	CMDHU
17385:	40DF  3F      		CCF			;Carry set iff min >= value typed
17386:	40E0  C9      		RET
17387:	40E1  FE0D    	INIP1:	CP	CR
17388:	40E3  C8      		RET	Z		;<cr>, return Zero and no Carry
17389:	0000          		IF	CAMAC
17392:				ENDIF
17393:	40E4  37      		SCF
17394:	40E5  C9      		RET			;return Carry
17395:				ENDIF			;end of NOT (WILD AND RTPAK) conditional
17396:			
17397:				ENDIF			;end of NOT COMPL OR RTPAK conditional
17398:			
17399:			;EOMEM gets default end of RAM to HL.
17400:	40E6          	EOMEM:
17401:	FFFF          		IF	CPM		;fetch end of memory from BDOS
17402:	40E6  2A0600  		LD	HL,(BDOS+1)
17403:	40E9  2B      		DEC	HL
17404:				ENDIF
17405:	0000          		IF	ISIS2
17409:				ENDIF
17410:	0000          		IF	NONST		;search for end of RAM
17427:				ENDIF
17428:	40EA  C9      	EORAM:	RET
17429:			
17430:	0000          		IF	ROM AND (RTPAK OR NOT COMPL)
17432:				ENDIF
17433:			
17434:	40EB          		END			;end of XYBASIC source



Statistics:

     4	passes
     0	jr promotions
  1307	symbols
     0	bytes

  1138	macro calls
  3268	macro bytes
    20	invented symbols



Symbol Table:

?f0019          13a9     
?f0021          13c5     
?f0023          13e1     
?f0025          13fa     
?f0027          1413     
aabs            1401     
aadd            1397     
acc1            3d4c     
acc2            3d4d     
acc3            3d4e     
acce            3d4a     
accs            3d4b     
adahl            215     
addl0           36b3     
addl1           36ea     
addl2           36f4     
addl3           3714     
addl4           371a     
addln           36a4     
adrl            3d50     
ambfn            63a     
ambo1           12b7     
ambof           12d4     
ambop           12b5     
ambos           12cc     
ambst          =   0+    
ambty           12db     
amd            =   0+    
amul            13cf     
argad           3d47     
asc             2f26     
asigi            1a1     
asign            16c     
asigv            165     
asm80          =   0+    
assi1           216b+    
assig           214d     
asub            13b3     
atemp           2c2b     
aumin           13e8     
auto            2177     
auto1           2194     
auto2           2197     
auto3           21a8     
auto4           21d0     
bakup           186b     
basft            64e     
bcd             14e9     
bcd1            14f5     
bcde            1423     
bdos           =   5+    
bdosf            4f3     
bdts1            264     
bdtst            250     
bendx          =   0+    
bferr           1fa1     
bin             150f     
bin1            151c     
bin2            1525     
binfn           2e92     
bknam            40e     
bkupc           1893     
bkvar           2255     
blkfn            629     
boot           =   0+    
bprnt            857     
break           21de     
brkl1           21ff     
brkl2           220b     
brkl3           2226     
brkl4           222f     
brkst          =   5+    
brkt           =  a2+    
bserr           1b43     
btest            7e8     
btst0            831     
btst1            846     
btst2            847     
btst3            84f     
bufad           3e5f     
bumpc           166c     
bytsd            1ac     
c3885          =   0+    
c3908          =   0+    
calcm           2266     
camac          =   0+    
camst          =   6+    
cdkc1            4dd     
cdkcl            4db     
cdkmk            4f9     
cdkop            59f     
cdkrd            5ac     
cdkwt            503     
chad             ea6     
chrs            2f37     
chrs1           2f3b     
cle0a           229b     
clea1           22a0     
clea2           22b8     
clear           226f     
clon1           1c2e     
clos1           1c02     
clos2           1c0c     
close           1bf7     
closi           1c17     
closn           1c2b     
cmbds            22f     
cmbdu            223     
cmdhu            229     
cmdta           2f81     
cmdtk          =  88+    
cmpaf           12fd     
cmpar           12e6     
cmpas           12f6     
cmpf1           1344     
cmpf2           134e     
cmpf3           1357     
cmpf4           1365     
cmpf5           136d     
cmpf6           1370     
cmpf7           1371     
cmpfl           1315     
cmpst           1b94     
cmst1           2de6     
cmst2           2de8     
cmstr           2dd2     
cnerr           22dc     
cnout           3c9b     
cntlb          =   2+    
cntlc          =   3+    
cntld          =   4+    
cntle          =   5+    
cntlf          =   6+    
cntlg          =   7+    
cntlh          =   8+    
cntlk          =   b+    
cntll          =   c+    
cntln          =   e+    
cntlo          =   f+    
cntlp          =  10+    
cntlq          =  11+    
cntlr          =  12+    
cntls          =  13+    
cntlt          =  14+    
cntlu          =  15+    
cntlx          =  18+    
cntly          =  19+    
cntlz          =  1a+    
cnvb1            c36     
cnvbi            c22     
cnvf1            c14+    
cnvfi            c02     
cnvrt            bcb     
cnvrx            c18     
cnvtb            c24     
cnvtf           1387     
colum           3ce0     
comp            1061     
comp1           1066     
compl          =   0+    
conin           3c98     
cont            22be     
cont1           22d6     
contk          =  13+    
cops0           364f     
cops1           3651+    
copya           363f     
copyd           3644     
copyh           3659     
copyp           35f0     
copyq           3643     
copys           3652     
cpld1            209     
cplde            208     
cpm            =ffff+    
cpmba          =   0+    
cpsh1           20b2     
cpsh2           20b6     
cpsh3           20dc     
cpush           20ae     
cpyd1           3647     
cpyh1           366b     
cpys0           1b9f     
cpyst           1ba2     
cr             =   d+    
csbrk          =  65+    
csdi1           2110     
csdig           210d     
csfor          =  4f+    
csgos          =  25+    
csint          =  87+    
cslbk          =  a5+    
cspo1           20fd     
cspop           20e8     
cspst           2789     
csrst           211f     
cstat           3c95     
cstkd           3fc4     
cstkp           3e59     
ctest           16d1     
ctst0           16d5     
ctst1           16f5     
ctst2           16e9     
cvis1           1747     
cvtis           173a     
datat          =  94+    
dbyts          = 256+    
dclr0           1bab     
dclr1           1bc0     
dclr2           1bcf     
dclr3           1be5     
dclr4           1bef     
dcstd           2143     
dderr           242f     
debug          =   0+    
decrc           1666     
def             22e1     
def0            230f     
def1            2322     
def2            232b     
defty           2332     
defv1           2360     
defvt           2347     
dela1           23bb     
dela2           23be     
dela3           23cc     
delay           2373     
dele1           23ee     
dele2           23fb     
dele3           23ff     
delet           23d4     
delh1           2387     
delh2           2398     
dim             241c     
dim0            241f+    
dim1a           2477+    
dims0           2434     
dims1           244a     
dims2           247f     
dims3           249c     
din10           1ce0     
din11           1cf6     
dinlf           1ced     
dinp0           1c7c     
dinp1           1c89     
dinp2           1c95     
dinp3           1ca2     
dinp4           1cae     
dinp5           1cc8     
dinp6           1ccb     
dinp7           1cd6     
dinp8           1cfa     
dinp9           1cff     
dirc1           1c54     
dircm           1c42     
disab            459     
divd0           128a     
divd1           1295     
divd3           12a3     
divd4           12a9     
divx            110a     
divx1           1158     
divx2           115c     
divx3           116f     
divx4           1176     
divx5           3cbc     
divx6           3ccd     
dkclf          =  10+    
dkdlf          =  13+    
dkdmf          =  1a+    
dkerr            4e3     
dkmkf          =  16+    
dkopf          =   f+    
dkout            5e6     
dkrdf          =  14+    
dkwtf          =  15+    
dloa1            61f     
dload            5fb     
dmaad          =  80+    
dmod2            73d     
dmod3            753     
dmodc           3ca8     
dmode            740     
dmodx            246     
dprin           1ea8     
drea0           1f13     
drea1           1f45     
drea2           1f4d     
dread           1f06     
dsab1           24bf     
dsab2           24c9     
dsab3           24cd     
dsab4           24e7     
dsabl           24ab     
dsabt          =  a5+    
dsave           16c1     
dtest            142     
dtst0            13f     
dtst1            145     
dwrit           1f52     
dwrtc           1f58     
echoc           3462     
edit            2507     
edit0           2511     
edit2           253a     
edit3           255e     
edit4           256d     
editc          =ffff+    
eferr           1f0e     
enab1           25a1     
enabl           2579     
enabt          =  a4+    
endc1           25b0     
endcm           25ad     
enerr           24c4     
eofad           3fca     
eoff0           1efd+    
eoffn           1eee     
eomem           40e6     
eoram           40ea     
eos              131     
epsh2            c51     
epstn          =   0+    
equal           1468     
eqult          =  cc+    
errln           3ce4     
erro0           17ee     
erro1           181b     
erro2           1837     
erroc           17e4     
errof           17de     
erron           17ea     
eserr            c6c     
espsh            c55     
estkp           3e5b     
esval            9a6     
esvl1            9b7     
esvl2            9c5     
etest           1307     
eva0a            8e7     
eva1a            8ed     
eva1b            913     
eval             8d5     
eval0            8db     
eval1            8ea     
eval2            91b     
eval3            91e     
eval4            94c     
eval5            98a     
eval6            990     
evals            c77     
evalt            bc5     
evalx            997     
evar1            a46     
evarp            a2b     
evco1            b23     
evcom            b20     
evfn0            a49     
evfn1            b6e     
evfn2            b61     
evfn3            b39     
evlip            9ce     
evlit            9db     
evop1            b6e     
evop2            b76     
evopa            b81     
evopu            a0b     
evpar            a1f     
evuf1            a92     
evuf2            ab5     
evuf3            aea     
evufn            a94     
evun1           2dc0     
evunq           2dae     
evva0            9fb     
evva1            9fd     
evvar            9e4     
excu1            ba1     
excut            b85     
exec           = 13a+    
exerr            13a     
exply           39c4     
exret            bb3     
exuf0            a83     
exufn            af0     
f2pi            3b2b     
f9511          =   0+    
fabs             ec1     
fadd             f47     
fadd2            f7d     
fadd3            f9d     
fadd4            faa     
fadd5            fcf     
fadd6            fdd     
fadd7            fe6     
fadd8            fec     
fadd9            ff9     
false          =   0+    
fat4            3bd3     
fat6            3bd4     
fat7            3c13     
fat8            3c4a     
fatan           3ba6     
fatc1           3c51     
fatk            3db4     
fatox           3b40     
fatpl           3c69     
fatsg           3db3     
fatx2           3daf     
fatxm           3dab     
fatzx           3da7     
fax             3b42+    
fax1            3b6b     
fax2            3b7a     
fbyts          =   4+    
fcbad          =  5c+    
fcbcr          =  7c+    
fcbfn          =  5d+    
fcbft          =  65+    
fcer0           1506     
fcerf           1392     
fcern           138c     
fcha1            72a     
fcha2            734     
fcha3            736     
fchar            712     
fchs             ebe     
fcos            3a8f     
fdiv             f25     
fdivd            f23     
fdlno           3763     
fdva1           1a8f     
fdvar           1a86     
fetbc            1b8     
fetc1            1bb     
fetcf            1e1     
fetch            1ba     
fetci            1c5     
fetcs            1d2     
fexp            38e0     
fexp0           3900     
fexp1           390a     
fexp5           392f     
ffix            1194     
ffix0           11c2     
ffix1           11c5     
ffix2           11ca     
fflot           117e     
fhpi            3b1a+    
fierr           1d23     
filen          =  a6+    
filep           3ca4     
files           3ca3     
filet           3ca6     
fillm           236c     
finc1           11fb     
finc2           1218     
finc3           121d     
finc4           122d     
fincr           11de     
findl           3741     
finfp           3d6a     
finp             cae     
finsn           3d69     
fint            37d0     
fint0           37e4     
fint2           37fb     
fint3           3809     
fint4           3823     
fint5           3834     
fint6           3841     
fint7           3859     
first          = 13a+    
flint           14d8     
flip             237     
fln             39da     
flna            3a05     
flnf            3d91     
flnk            3d90     
flnl2           3a74     
flnm2           3a78     
flnpl           3a7c     
flnr2           3a70     
flnz2           3d8c     
flnzi           3d88     
fload            edd     
float          =ffff+    
flot1           1184     
fmerr           1d28     
fmul             efa     
fndl1           3745     
fndl2           3760     
fndl3           3761     
fndln            2c3     
fnds0            26f     
fnds1            279     
fnds2            29c     
fnds3            2a8     
fnds4            2ad     
fnds5            2b9     
fndst            274     
fndt1           1fe1     
fndt2           1fe6     
fndt3           1fec     
fndt4           1fed     
fndtk           1fce     
fnln1            2c6     
foerr           1e9e     
for             25b5     
for0           =ffff+    
for1            25c8     
for1a           25cf     
for2            25f2     
for2a           262e     
fort           =  8a+    
fout             da8     
fover            f39     
fpbcd          =   0+    
fpi             3b16+    
fpmax           39c0     
fpol0           3777     
fpol1           378f     
fpol2           37cd     
fpoly           376a     
fpone            ca2     
fprnd            caa     
fpsgn           3d7f     
fpsum           3d63     
fpta1           38d0     
fpta2           38d8     
fptdf           398c     
fpten            ca6     
fptf            3d72     
fptn            3d7e     
fptp            3d76     
fptx            3d7a     
fptxn           3d5b     
fptxx           3d6e     
fptz0           3d80     
fptz1           3d84     
fre             15ad     
fre1            15b5     
fre2            15b8+    
frefn           159f     
fsc2            3abe     
fsc25           3b22     
fsc3            3ac7     
fsc4            3ad9     
fsc4a           3adf     
fsc5            3ae5     
fsc50           3b26     
fsc6            3ae8     
fsc7            3aeb     
fsc75           3b1e     
fsc8            3b10     
fscfx           3d95     
fscpl           3b2a     
fscsg           3d96     
fscz            3d97     
fscz2           3d9b     
fsgn            1588     
fsin            3a8e     
fsqr            3862     
fstor            eb0     
fstr0            eae     
fstr1            eb1     
fsub             f44     
ftan            3b85     
ftest            ec9     
ftmpa           3d9f     
ftmpb           3da3     
funta           3030     
fzro             eb8     
garb1           2cae     
garb2           2cb8     
garb4           2cd5     
garb5           2ced     
garb6           2cfe     
garb7           2d18     
garbg           2ca7     
gccmp           2d24     
gchar           3d31     
gcloc           3d45     
gclst           3d43     
gcmin           3d41     
genmc          =   0+    
geq             147a     
get             1538     
gosu1           2669     
gosub           2666     
goto            266f     
goto1           2675     
goto2           2678     
gotot          =  8c+    
gsubt          =  8d+    
gtaf0            6c7     
gtaf1            6d5     
gtaf2            6f3     
gtaf3            6fa     
gtaf4            703     
gtaf5            709     
gtafn            6aa     
gtalp           1870     
gtatn           1f91     
gtbex            c9c     
gtcbe            c96     
gtch1           185d     
gtcha           185a     
gtcho           1868     
gtclq           18c6     
gtcnd           1885     
gtcom           187c     
gtd             188e     
gtde0           1900     
gtde1           1925     
gtde2           1929     
gtde3           1942     
gtdec           1911     
gtdel           18b7     
gtdsn           18a6     
gtdtr           1897     
gtequ           18b2     
gtexp            c8f     
gtf0a            672+    
gtfil            652     
gtfl0            671+    
gtfl1            678     
gtfl2            67f     
gtfl4            687     
gtfl5            68a     
gtfn0            6a0     
gtfnm            696     
gthan           1489     
gtild           18f0     
gtiva           1b48     
gtl1a           33d8     
gtl1b           33dd     
gtl1c           33ed     
gtl1d           33c9     
gtlb1           19ab     
gtlh1           19c2     
gtlhs            14d     
gtli0           33a9     
gtli1           33c6     
gtli2           33f4     
gtli3           341e     
gtli4           342b     
gtli5           342f     
gtli6           343c     
gtli7           344c     
gtli8           345a     
gtlib           19aa     
gtlid           19f9     
gtlif           1a22     
gtlih           19c1     
gtlin           33b4     
gtlis           199e     
gtlit           1959     
gtlno           194d     
gtls1           19a3     
gtlt1           195b     
gtlt2           1961     
gtlt3           1999     
gtnam           1a2d     
gtnm1           1a46     
gtnm2           1a47     
gtnm3           1a5a     
gtnm4           1a71     
gtnm5           1a73     
gtnm6           1a7c     
gtnm7           1a81     
gtpa1            443     
gtpa2            451     
gtpar            426     
gtreq           18ad     
gtsf0           1fab     
gtsf1           1fae     
gtsf2           1fba     
gtsfn           1fa6     
gtsu0           1b0b     
gtsu1           1b28     
gtsu2           1b2f     
gtsub           1b04     
gttyp            c3b     
gtva1           1ac6     
gtva2           1af3     
gtva3           1af5     
gtvar           1aa3     
hexf0           2e9b     
hexf1           2ea2     
hexf2           2ea5     
hexf4           2ec3     
hexfn           2e98     
hl10a           152e     
iabs            141a     
iabs1           141b     
iadd            142c     
icstd           213c     
iderr            119     
idivd           144c     
idtst            115     
ieva1            c8d     
ieval            c7e     
ifcom           267e     
iinf1            486     
iinf2            496     
iinf3            499     
iinfo            461     
iint            14c8     
iitst            11e     
impm            158e     
imul            143a     
imul1           1442     
inip1           40e1     
init            3fd0     
init1           401f     
init2           403a     
init3           403d     
init4           4060+    
init5           4069     
init6           406c     
init7           40b0     
initp           40c9     
inlhs           3ce8     
inone          =2447+    
inp1             d07     
inp10            d89     
inp2             cc5     
inp3             d0e     
inp4             d1c     
inp5             d37     
inp6             d39     
inp7             d60     
inp8             d67     
inp9             d73     
inpov            d94     
inpu1           26ae     
inpu2           26c6     
inpu3           26da     
inpu4           26e5     
inpu5           270a     
inpu6           270c     
inpu7           271b     
input           2694     
inrc             29a     
inst0           2e48     
inst1           2e5f     
inst2           2e79     
inst3           2e7e     
instr           2e45     
instt          =  ef+    
int             14bb     
int1            14c5+    
intad           3ced     
intst          =   1+    
intt           =  dc+    
inttc           3cec     
inttl          =  41+    
inttn          =   8+    
inxh            12b3     
iobyf           1553     
iobyt          =   3+    
iover           19eb     
isalp           18f9     
isbyt            1fd     
iscom          =  40+    
isdel          =  10+    
isdig           18d4     
isfn0          =  50+    
isfn1          =  90+    
isfn2          =  a0+    
ishex           18db     
isis2          =   0+    
islp           =  20+    
isop1          =  70+    
isop2          =  80+    
isrp           =  30+    
isub            1428     
isufn          =  60+    
itest            87d     
itst1            880     
itst2            894     
itst3            89a     
itst4            8a4     
iumin           141d     
join            14b1     
key80          =ffff+    
keyta           3175     
klnct          =   a+    
klnta           335b     
klts1            402     
klts2            40c     
kltst            3fc     
last           = 13a+    
ldtst           18f5     
led0a           34e7     
led0b           34f2     
led0c           34f3     
led10           3594     
led11           35a0     
led1a           3500     
led1b           3512     
led2a           3525     
led3a           3536     
led3b           3538     
led3c           3545     
led3d           3550     
led4a           355a     
led9a           358f     
ledi0           34dd     
ledi1           34f8     
ledi2           351d     
ledi3           3530     
ledi4           3554     
ledi5           3561     
ledi6           356b     
ledi7           357d     
ledi8           3583     
ledi9           358b     
ledit           3471     
ledt0           347a     
ledt1           347d     
ledt2           3493     
ledt3           3496     
left1           2f47     
lefts           2f44     
len             2f31     
leq             1480     
leq1            1487     
let             272d     
let0            2726     
let1            2730     
lf             =   a+    
lhsad           3e57     
lhsty           3e56     
linb1            109     
linb2            112     
linbc            106     
linf0           1d55     
linf1           1d59     
linf2           1d6a     
linp0           1d70     
linp1           1d82     
linp2           1d8b     
linpt           1d2d     
list1           274f     
listm           2739     
listt          =  ab+    
lmode           3cea     
lnlen           3fc3     
lnnu0           372b     
lnnum           3ce2     
lnr3a            33f     
lnr3b            34c     
lnr3c            365     
lnr3d            371     
lnr3e            376     
lnr3f            3a3     
lnr3g            3b3     
lnr3h            3cf     
lnr3i            3e4     
lnr3j            30a     
lnre1            2db     
lnre2            2e3     
lnre3            2fe     
lnre4            3ed     
lnre5            3f4     
lnref            2d8     
load             531     
load0            554     
load1            568     
load2            5bf     
loada            583     
loadr            5d4     
loadx            5b9     
loadz            5da     
lod0b            55d     
loda1            590     
log2e           39bc     
lout            3c9e     
lsbyt           14e6     
lsh             102e     
lshft           15bc     
lthan           1474     
marg0           1da9     
marg1           1dac     
margn           1d90     
maxnl          =   8+    
mcerr            43e     
mdex            1008     
memt            3fcc     
mid0            2f57     
mid1            2f62     
mid2            2f69     
mid3            2f6d     
mids            2f55     
midst          =  ee+    
mint           =  c2+    
mobcm            1cd     
mod10           1768     
mod1a           176b     
mod1b           177b     
modem            1f8     
momde           2250     
movd0           3734     
move           = 13a+    
moveb           3732     
moved           3736     
msbyt           14e5     
mulbd           125f     
mult0           126a     
mult1           1270     
mult2           1279     
mult3           1286     
multt          =  c3+    
multy           126d     
mulx            10c1     
mulx1           10df     
mulx2           10e2     
mulx3           10ea     
mulx4           3cb1     
mvdem            1ee     
mvmde            1f3     
mwcma           3365     
ncmds          =  37+    
neq             146e     
new             276d     
new1            277b     
newcm           2767     
newtn           38b9     
next            2790     
next1           27ce     
next2           27d1     
next3           27dd     
next4           27f4     
next5           2832     
next6           283b     
next7           284b     
nextc            765     
nexts            771     
nextt          =  8b+    
nferr           2852     
nfuns          =  41+    
nkeys          =  78+    
nlmax          =  50+    
nlnad           3ec3     
nonst          =   0+    
norm            1074     
norm1           1076     
norm2           1087     
norm3           1094     
nrwds          =   c+    
null            2857     
nulls           3d30     
nxt4i           2820     
nxts1           2d8b     
nxts2           2d98     
nxts3           2da4     
nxtst           2d85     
octfn           2ed0     
omerr           2043     
omode           3ceb     
on              285f     
on1             2878     
on2             2888     
on3             2893     
onerr           289a     
ongot           2870     
opand           14a0     
open            1db1     
open1           1dc7     
open2           1dd3     
open3           1e08     
open4           1e15     
open6           1e51     
openo           1e3f     
openu           1e5a     
operr           1ea3     
opmod           1458     
opn2a           1de1     
opn2b           1dfe     
opn2c           1e05     
opnot           1490     
opnu1           1e6d     
opnu2           1e7a     
opnu3           1e85     
opnu4           1e88     
opor            14aa     
opxor           1493     
out0             dc9     
out1             dd3     
out10            e72     
out11            e74     
out12            e85     
out13            e95     
out2             dd5     
out3             de3     
out4             dea     
out5             df4     
out6             e0e     
out7             e17     
out8             e3b     
out9             e4d     
out9a            e50     
out9b            e5d     
ovset           19f7     
ovtst           19dc     
ovun            102a     
packi          =   0+    
patch           3c77+    
peek            1559     
peek1           155a     
plust          =  c1+    
pmask          =   f+    
poke            28ae     
pop1             995     
pop3             993     
pop4            1662     
pos             155e     
prco1           291a     
prco2           292a     
prco3           2939     
prcom           2911     
prdel           28f1     
prex            3d49     
prin0           28bf     
print           28b9     
prinv           28fe+    
priv1           2909     
prntl           178d     
prntm           17d9     
prntt          =  8e+    
prqu0           2973     
prquo           2976     
prsem           2914     
prsl1           172c     
prsng           2981     
prsp1           296b     
prspc           2966     
prst0           297d     
prst1           1730     
prstl           171a     
prstr           172f     
prta0           2951     
prta1           2940     
prta2           294b     
prtab           293d     
prtch           17bc     
prtl0           1790     
prtl1           17a2     
prtl2           17a3     
prtl3           17b6     
prtlc           1780     
prtm0           17cf     
prtst           17c2     
prval           28f5     
put             28a0     
ramorg          3c95+    
randa          =64b5+    
randc          =3a73+    
randx           3d2e     
rbout          =  7f+    
rdp1            1237     
rdptr           3fc8     
read            2993     
read1           1877     
reada           2999     
readb           29b2     
readc           168d     
readd           29b8     
reade           29cb     
readf           29e5     
readp           1233     
realt          =   0+    
redyc           16c7     
rem             29f1     
remt           =  a7+    
renu0           29fe     
renu1           2a10     
renu2           2a3f     
renu3           2a50     
renu4           2a57     
renu5           2a6a     
renu6           2a86     
renu7           2a9b     
renu8           2aa0     
renu9           2ab8     
renum           2a06     
renux           2ac0     
reset           149a     
restr           2aca     
retnc           190f     
retrn           2ade     
retry           1377     
rgerr           2afd     
righ1           2f4e     
right           2f4b     
rnd             15e4     
rnd1            15f0     
rnda             f18     
rndiz           298a     
rndr            10b3     
rninc          =3d43+    
rnnew          =3d41+    
rnold          =3d45+    
rom            =   0+    
romorg         = 100+    
romsq          =   0+    
rond            10a3     
rota1           15d1     
rota2           15d6     
rotat           15ca     
rport           3cab     
rsh             103b     
rsh1            103f     
rsh2            104c     
rsh3            104f     
rshft           15c7     
rsto1           2ad9     
rstor           2ad6     
rstrt          =  95+    
rtdma            4eb     
rtest            12a     
rtpak          =   0+    
rtry1           1384     
run             2b02     
runt           =  ae+    
rwdta           3334     
rwdtk          =   e+    
sadd            2e09     
sadd1           2e20     
sadd2           2e40     
sadd3           2e42     
sava1            522+    
save             49b     
save1            4c1     
savea            50d     
savtp           3e54     
sbahl            21c     
scal1           2b30     
scal2           2b4c     
scall           2b1f     
scop0           2c47     
scopv           2c61     
scopy           2c4a     
scrat           1ee6     
sdisk          =ffff+    
semic          =  3b+    
sense           1593     
setfn           14a7     
sfils           1fc3     
sflag           3d4f     
sgn             1571     
sgn1            1580     
siar0           2deb     
siar1           2dfb     
siarg           2df3     
sig             3d5a     
sindx          =  13+    
snerr            135     
snfix           1250     
snfx0           124c     
sngst          =   2+    
sngt           =  17+    
spct           =  12+    
sprst            5f4     
sptr            3ca1     
srcad           3fcf     
sret1           2b5d     
sretn           2b51     
stack           3e35     
stakl          =  80+    
stakm          =  19+    
start            100     
stbi1           1244     
stbit           123f     
stbt0           123d     
stcr            1438+    
stdma            4ee     
stemp           3d32     
stept          =  10+    
sterr           2c42     
stfre           2c7f     
stlk0           2061     
stlk1           2065     
stlku           205e     
stmax          =   4+    
stmov           2d33     
stnxt           2048     
stop            2b77     
stop1           2b79     
stop2           2b97     
stps1           2004     
stps2           2020     
stps3           2035     
stpsh           1ff7     
strgt          =  18+    
strng          =ffff+    
strp2           3d3f     
strpt           3d3d     
strs            2ee7     
strst          =   3+    
strt            3d3b     
sttp1           35eb     
stza1           2085     
stza2           2098     
stzap           2082     
svad             e9b     
symta           3e5d     
tabt           =  11+    
tcoff           2bcf     
tcon            2bce     
temp            3e50     
test            1564     
test1           156b     
textp           3fc6     
thent          =   e+    
time            2b9d     
time1           23b0     
timeh          =  73+    
timem          =8c13+    
timen          =fe12+    
timer           23ab     
timex           3cdb     
tkiz0           35bc     
tkiz1           35d3     
tkiza           35f2     
tkizb           360b     
tkizc           363b     
tkize           35a7     
tkza1           3606     
tkza2           3608     
tlku0           3674     
tlku1           3682     
tlku2           368c     
tlku3           3695     
tlkup           3673     
tlnad           3e70     
tmask          =  f0+    
tmerr            c1d     
tmp1            3d52     
tmp2            3d53     
tmp3            3d54     
tmp4            3d59     
token          =  1a+    
tot            =   f+    
tpmo1           2d4d     
tpmo2           2d7e     
tpmov           2d49     
tpoff           2bd4     
tpon            2bd5     
tprnt            85c     
trace           3ce7     
tracl           3fc5     
trap            3ce6     
trset           1b56     
trst1           1b85     
true           =ffff+    
trva1            18c     
trval            187     
txtp2           3e52     
tybuf           3e36     
tycha           1b87     
typta           2fef     
ubvar           2bff     
udfnt          =  bf+    
ufnst          =   4+    
umind           1420     
unbkl           209d     
unbkt          =  a3+    
unbl1           20a0     
unbr1           2be3     
unbr2           2be9     
unbr3           2bf2     
unbrk           2bda     
unsfn           14d1     
userr           1954     
val             2eed     
val1            2ef5     
vale            3d55     
varty           3e35     
vbyts          =   5+    
vect            3d67     
versn          =5398+    
vtrac           3ce9     
wait            2c10     
wait1           2c21     
wcrlf           1675     
width           3ce1     
wild           =   0+    
wlf             167a     
wnul1           1685     
wnuls           167f     
wport           3cae     
writc           161f     
wrtb1           170e     
wrtb2           170f     
wrtbs           16ff     
wrtbu           170d     
wrtc1           162e     
wrtc2           1650+    
wrts0           1617     
wrtsp           161d     
xsta1            7bc     
xsta2            7c0     
xstat            7b2     
xybft            64a     
